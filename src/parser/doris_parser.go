// Code generated from ./DorisParser.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // DorisParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type DorisParser struct {
	*antlr.BaseParser
}

var DorisParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func dorisparserParserInit() {
	staticData := &DorisParserParserStaticData
	staticData.LiteralNames = []string{
		"", "';'", "'('", "')'", "','", "'.'", "'...'", "'['", "']'", "'{'",
		"'}'", "'ACCOUNT_LOCK'", "'ACCOUNT_UNLOCK'", "'ACTIONS'", "'ADD'", "'ADMIN'",
		"'AFTER'", "'AGG_STATE'", "'AGGREGATE'", "'ALIAS'", "'ALL'", "'ALTER'",
		"'ANALYZE'", "'ANALYZED'", "'AND'", "'ANTI'", "'APPEND'", "'ARRAY'",
		"'AS'", "'ASC'", "'AT'", "'AUTHORS'", "'AUTO'", "'AUTO_INCREMENT'",
		"'ALWAYS'", "'BACKEND'", "'BACKENDS'", "'BACKUP'", "'BEGIN'", "'BELONG'",
		"'BETWEEN'", "'BIGINT'", "'BIN'", "'BINARY'", "'BINLOG'", "'BITAND'",
		"'BITMAP'", "'BITMAP_EMPTY'", "'BITMAP_UNION'", "'BITOR'", "'BITXOR'",
		"'BLOB'", "'BOOLEAN'", "'BRIEF'", "'BROKER'", "'BUCKETS'", "'BUILD'",
		"'BUILTIN'", "'BULK'", "'BY'", "'CACHE'", "'CACHED'", "'CALL'", "'CANCEL'",
		"'CASE'", "'CAST'", "'CATALOG'", "'CATALOGS'", "'CHAIN'", "", "'CHARSET'",
		"'CHECK'", "'CLEAN'", "'CLUSTER'", "'CLUSTERS'", "'COLLATE'", "'COLLATION'",
		"'COLLECT'", "'COLOCATE'", "'COLUMN'", "'COLUMNS'", "'COMMENT'", "'COMMIT'",
		"'COMMITTED'", "'COMPACT'", "'COMPLETE'", "'COMPRESS_TYPE'", "'COMPUTE'",
		"'CONDITIONS'", "'CONFIG'", "'CONNECTION'", "'CONNECTION_ID'", "'CONSISTENT'",
		"'CONSTRAINT'", "'CONSTRAINTS'", "'CONVERT'", "'CONVERT_LIGHT_SCHEMA_CHANGE_PROCESS'",
		"'COPY'", "'COUNT'", "'CREATE'", "'CREATION'", "'CRON'", "'CROSS'",
		"'CUBE'", "'CURRENT'", "'CURRENT_CATALOG'", "'CURRENT_DATE'", "'CURRENT_TIME'",
		"'CURRENT_TIMESTAMP'", "'CURRENT_USER'", "'DATA'", "'DATABASE'", "'DATABASES'",
		"'DATE'", "'DATETIME'", "'DATETIMEV2'", "'DATEV2'", "'DATETIMEV1'",
		"'DATEV1'", "'DAY'", "'DECIMAL'", "'DECIMALV2'", "'DECIMALV3'", "'DECOMMISSION'",
		"'DEFAULT'", "'DEFERRED'", "'DELETE'", "'DEMAND'", "'DESC'", "'DESCRIBE'",
		"'DIAGNOSE'", "'DIAGNOSIS'", "'DISK'", "'DISTINCT'", "'DISTINCTPC'",
		"'DISTINCTPCSA'", "'DISTRIBUTED'", "'DISTRIBUTION'", "'DIV'", "'DO'",
		"'DORIS_INTERNAL_TABLE_ID'", "'DOUBLE'", "'DROP'", "'DROPP'", "'DUAL'",
		"'DUMP'", "'DUPLICATE'", "'DYNAMIC'", "'E'", "'ELSE'", "'ENABLE'", "'ENCRYPTKEY'",
		"'ENCRYPTKEYS'", "'END'", "'ENDS'", "'ENGINE'", "'ENGINES'", "'ENTER'",
		"'ERRORS'", "'EVENTS'", "'EVERY'", "'EXCEPT'", "'EXCLUDE'", "'EXECUTE'",
		"'EXISTS'", "'EXPIRED'", "'EXPLAIN'", "'EXPORT'", "'EXTENDED'", "'EXTERNAL'",
		"'EXTRACT'", "'FAILED_LOGIN_ATTEMPTS'", "'FALSE'", "'FAST'", "'FEATURE'",
		"'FIELDS'", "'FILE'", "'FILTER'", "'FIRST'", "'FLOAT'", "'FOLLOWER'",
		"'FOLLOWING'", "'FOR'", "'FOREIGN'", "'FORCE'", "'FORMAT'", "'FREE'",
		"'FROM'", "'FRONTEND'", "'FRONTENDS'", "'FULL'", "'FUNCTION'", "'FUNCTIONS'",
		"'GENERATED'", "'GENERIC'", "'GLOBAL'", "'GRANT'", "'GRANTS'", "'GRAPH'",
		"'GROUP'", "'GROUPING'", "'GROUPS'", "'HASH'", "'HAVING'", "'HDFS'",
		"'HELP'", "'HISTOGRAM'", "'HLL'", "'HLL_UNION'", "'HOSTNAME'", "'HOTSPOT'",
		"'HOUR'", "'HUB'", "'IDENTIFIED'", "'IF'", "'IGNORE'", "'IMMEDIATE'",
		"'IN'", "'INCREMENTAL'", "'INDEX'", "'INDEXES'", "'INFILE'", "'INNER'",
		"'INSERT'", "'INSTALL'", "'INT'", "'INTEGER'", "'INTERMEDIATE'", "'INTERSECT'",
		"'INTERVAL'", "'INTO'", "'INVERTED'", "'IPV4'", "'IPV6'", "'IS'", "'IS_NOT_NULL_PRED'",
		"'IS_NULL_PRED'", "'ISNULL'", "'ISOLATION'", "'JOB'", "'JOBS'", "'JOIN'",
		"'JSON'", "'JSONB'", "'KEY'", "'KEYS'", "'KILL'", "'LABEL'", "'LARGEINT'",
		"'LAST'", "'LATERAL'", "'LDAP'", "'LDAP_ADMIN_PASSWORD'", "'LEFT'",
		"'LESS'", "'LEVEL'", "'LIKE'", "'LIMIT'", "'LINES'", "'LINK'", "'LIST'",
		"'LOAD'", "'LOCAL'", "'LOCALTIME'", "'LOCALTIMESTAMP'", "'LOCATION'",
		"'LOCK'", "'LOGICAL'", "'LOW_PRIORITY'", "'MANUAL'", "'MAP'", "'MATCH'",
		"'MATCH_ALL'", "'MATCH_ANY'", "'MATCH_PHRASE'", "'MATCH_PHRASE_EDGE'",
		"'MATCH_PHRASE_PREFIX'", "'MATCH_REGEXP'", "'MATERIALIZED'", "'MAX'",
		"'MAXVALUE'", "'MEMO'", "'MERGE'", "'MIGRATE'", "'MIGRATIONS'", "'MIN'",
		"'MINUS'", "'MINUTE'", "'MODIFY'", "'MONTH'", "'MTMV'", "'NAME'", "'NAMES'",
		"'NATURAL'", "'NEGATIVE'", "'NEVER'", "'NEXT'", "'NGRAM_BF'", "'NO'",
		"'NO_USE_MV'", "'NON_NULLABLE'", "'NOT'", "'NULL'", "'NULLS'", "'OBSERVER'",
		"'OF'", "'OFFSET'", "'ON'", "'ONLY'", "'OPEN'", "'OPTIMIZED'", "'OR'",
		"'ORDER'", "'OUTER'", "'OUTFILE'", "'OVER'", "'OVERWRITE'", "'PARAMETER'",
		"'PARSED'", "'PARTITION'", "'PARTITIONS'", "'PASSWORD'", "'PASSWORD_EXPIRE'",
		"'PASSWORD_HISTORY'", "'PASSWORD_LOCK_TIME'", "'PASSWORD_REUSE'", "'PATH'",
		"'PAUSE'", "'PERCENT'", "'PERIOD'", "'PERMISSIVE'", "'PHYSICAL'", "'PI'",
		"'?'", "'PLAN'", "'PLAY'", "'PRIVILEGES'", "'PROCESS'", "'PLUGIN'",
		"'PLUGINS'", "'POLICY'", "'PRECEDING'", "'PREPARE'", "'PRIMARY'", "'PROC'",
		"'PROCEDURE'", "'PROCESSLIST'", "'PROFILE'", "'PROPERTIES'", "'PROPERTY'",
		"'QUANTILE_STATE'", "'QUANTILE_UNION'", "'QUERY'", "'QUOTA'", "'QUALIFY'",
		"'QUARTER'", "'RANDOM'", "'RANGE'", "'READ'", "'REAL'", "'REBALANCE'",
		"'RECENT'", "'RECOVER'", "'RECYCLE'", "'REFRESH'", "'REFERENCES'", "'REGEXP'",
		"'RELEASE'", "'RENAME'", "'REPAIR'", "'REPEATABLE'", "'REPLACE'", "'REPLACE_IF_NOT_NULL'",
		"'REPLAYER'", "'REPLICA'", "'REPOSITORIES'", "'REPOSITORY'", "'RESOURCE'",
		"'RESOURCES'", "'RESTORE'", "'RESTRICTIVE'", "'RESUME'", "'RETURNS'",
		"'REVOKE'", "'REWRITTEN'", "'RIGHT'", "'RLIKE'", "'ROLE'", "'ROLES'",
		"'ROLLBACK'", "'ROLLUP'", "'ROUTINE'", "'ROW'", "'ROWS'", "'S3'", "'SAMPLE'",
		"'SCHEDULE'", "'SCHEDULER'", "'SCHEMA'", "'SCHEMAS'", "'SECOND'", "'SELECT'",
		"'SEMI'", "'SERIALIZABLE'", "'SESSION'", "'SESSION_USER'", "'SET'",
		"'SETS'", "'SET_SESSION_VARIABLE'", "'SHAPE'", "'SHOW'", "'SIGNED'",
		"'SKEW'", "'SMALLINT'", "'SNAPSHOT'", "'SONAME'", "'SPLIT'", "'SQL'",
		"'SQL_BLOCK_RULE'", "'STAGE'", "'STAGES'", "'START'", "'STARTS'", "'STATS'",
		"'STATUS'", "'STOP'", "'STORAGE'", "'STREAM'", "'STREAMING'", "'STRING'",
		"'STRUCT'", "'SUM'", "'SUPERUSER'", "'SWITCH'", "'SYNC'", "'SYSTEM'",
		"'TABLE'", "'TABLES'", "'TABLESAMPLE'", "'TABLET'", "'TABLETS'", "'TASK'",
		"'TASKS'", "'TEMPORARY'", "'TERMINATED'", "'TEXT'", "'THAN'", "'THEN'",
		"'TIME'", "'TIMESTAMP'", "'TINYINT'", "'TO'", "'TRANSACTION'", "'TRASH'",
		"'TREE'", "'TRIGGERS'", "'TRIM'", "'TRUE'", "'TRUNCATE'", "'TYPE'",
		"'TYPE_CAST'", "'TYPES'", "'UNBOUNDED'", "'UNCOMMITTED'", "'UNINSTALL'",
		"'UNION'", "'UNIQUE'", "'UNLOCK'", "'UNSET'", "'UNSIGNED'", "'UP'",
		"'UPDATE'", "'USE'", "'USER'", "'USE_MV'", "'USING'", "'VALUE'", "'VALUES'",
		"'VARCHAR'", "'VARIABLE'", "'VARIABLES'", "'VARIANT'", "'VAULT'", "'VAULTS'",
		"'VERBOSE'", "'VERSION'", "'VIEW'", "'VIEWS'", "'WARM'", "'WARNINGS'",
		"'WEEK'", "'WHEN'", "'WHERE'", "'WHITELIST'", "'WITH'", "'WORK'", "'WORKLOAD'",
		"'WRITE'", "'XOR'", "'YEAR'", "", "'<=>'", "", "'<'", "", "'>'", "",
		"'+'", "'-'", "'*'", "'/'", "'%'", "'~'", "'&'", "'&&'", "'!'", "'|'",
		"'||'", "'^'", "':'", "'->'", "'/*+'", "'*/'", "'/*'", "'@'", "'@@'",
	}
	staticData.SymbolicNames = []string{
		"", "SEMICOLON", "LEFT_PAREN", "RIGHT_PAREN", "COMMA", "DOT", "DOTDOTDOT",
		"LEFT_BRACKET", "RIGHT_BRACKET", "LEFT_BRACE", "RIGHT_BRACE", "ACCOUNT_LOCK",
		"ACCOUNT_UNLOCK", "ACTIONS", "ADD", "ADMIN", "AFTER", "AGG_STATE", "AGGREGATE",
		"ALIAS", "ALL", "ALTER", "ANALYZE", "ANALYZED", "AND", "ANTI", "APPEND",
		"ARRAY", "AS", "ASC", "AT", "AUTHORS", "AUTO", "AUTO_INCREMENT", "ALWAYS",
		"BACKEND", "BACKENDS", "BACKUP", "BEGIN", "BELONG", "BETWEEN", "BIGINT",
		"BIN", "BINARY", "BINLOG", "BITAND", "BITMAP", "BITMAP_EMPTY", "BITMAP_UNION",
		"BITOR", "BITXOR", "BLOB", "BOOLEAN", "BRIEF", "BROKER", "BUCKETS",
		"BUILD", "BUILTIN", "BULK", "BY", "CACHE", "CACHED", "CALL", "CANCEL",
		"CASE", "CAST", "CATALOG", "CATALOGS", "CHAIN", "CHAR", "CHARSET", "CHECK",
		"CLEAN", "CLUSTER", "CLUSTERS", "COLLATE", "COLLATION", "COLLECT", "COLOCATE",
		"COLUMN", "COLUMNS", "COMMENT", "COMMIT", "COMMITTED", "COMPACT", "COMPLETE",
		"COMPRESS_TYPE", "COMPUTE", "CONDITIONS", "CONFIG", "CONNECTION", "CONNECTION_ID",
		"CONSISTENT", "CONSTRAINT", "CONSTRAINTS", "CONVERT", "CONVERT_LSC",
		"COPY", "COUNT", "CREATE", "CREATION", "CRON", "CROSS", "CUBE", "CURRENT",
		"CURRENT_CATALOG", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP",
		"CURRENT_USER", "DATA", "DATABASE", "DATABASES", "DATE", "DATETIME",
		"DATETIMEV2", "DATEV2", "DATETIMEV1", "DATEV1", "DAY", "DECIMAL", "DECIMALV2",
		"DECIMALV3", "DECOMMISSION", "DEFAULT", "DEFERRED", "DELETE", "DEMAND",
		"DESC", "DESCRIBE", "DIAGNOSE", "DIAGNOSIS", "DISK", "DISTINCT", "DISTINCTPC",
		"DISTINCTPCSA", "DISTRIBUTED", "DISTRIBUTION", "DIV", "DO", "DORIS_INTERNAL_TABLE_ID",
		"DOUBLE", "DROP", "DROPP", "DUAL", "DUMP", "DUPLICATE", "DYNAMIC", "E",
		"ELSE", "ENABLE", "ENCRYPTKEY", "ENCRYPTKEYS", "END", "ENDS", "ENGINE",
		"ENGINES", "ENTER", "ERRORS", "EVENTS", "EVERY", "EXCEPT", "EXCLUDE",
		"EXECUTE", "EXISTS", "EXPIRED", "EXPLAIN", "EXPORT", "EXTENDED", "EXTERNAL",
		"EXTRACT", "FAILED_LOGIN_ATTEMPTS", "FALSE", "FAST", "FEATURE", "FIELDS",
		"FILE", "FILTER", "FIRST", "FLOAT", "FOLLOWER", "FOLLOWING", "FOR",
		"FOREIGN", "FORCE", "FORMAT", "FREE", "FROM", "FRONTEND", "FRONTENDS",
		"FULL", "FUNCTION", "FUNCTIONS", "GENERATED", "GENERIC", "GLOBAL", "GRANT",
		"GRANTS", "GRAPH", "GROUP", "GROUPING", "GROUPS", "HASH", "HAVING",
		"HDFS", "HELP", "HISTOGRAM", "HLL", "HLL_UNION", "HOSTNAME", "HOTSPOT",
		"HOUR", "HUB", "IDENTIFIED", "IF", "IGNORE", "IMMEDIATE", "IN", "INCREMENTAL",
		"INDEX", "INDEXES", "INFILE", "INNER", "INSERT", "INSTALL", "INT", "INTEGER",
		"INTERMEDIATE", "INTERSECT", "INTERVAL", "INTO", "INVERTED", "IPV4",
		"IPV6", "IS", "IS_NOT_NULL_PRED", "IS_NULL_PRED", "ISNULL", "ISOLATION",
		"JOB", "JOBS", "JOIN", "JSON", "JSONB", "KEY", "KEYS", "KILL", "LABEL",
		"LARGEINT", "LAST", "LATERAL", "LDAP", "LDAP_ADMIN_PASSWORD", "LEFT",
		"LESS", "LEVEL", "LIKE", "LIMIT", "LINES", "LINK", "LIST", "LOAD", "LOCAL",
		"LOCALTIME", "LOCALTIMESTAMP", "LOCATION", "LOCK", "LOGICAL", "LOW_PRIORITY",
		"MANUAL", "MAP", "MATCH", "MATCH_ALL", "MATCH_ANY", "MATCH_PHRASE",
		"MATCH_PHRASE_EDGE", "MATCH_PHRASE_PREFIX", "MATCH_REGEXP", "MATERIALIZED",
		"MAX", "MAXVALUE", "MEMO", "MERGE", "MIGRATE", "MIGRATIONS", "MIN",
		"MINUS", "MINUTE", "MODIFY", "MONTH", "MTMV", "NAME", "NAMES", "NATURAL",
		"NEGATIVE", "NEVER", "NEXT", "NGRAM_BF", "NO", "NO_USE_MV", "NON_NULLABLE",
		"NOT", "NULL", "NULLS", "OBSERVER", "OF", "OFFSET", "ON", "ONLY", "OPEN",
		"OPTIMIZED", "OR", "ORDER", "OUTER", "OUTFILE", "OVER", "OVERWRITE",
		"PARAMETER", "PARSED", "PARTITION", "PARTITIONS", "PASSWORD", "PASSWORD_EXPIRE",
		"PASSWORD_HISTORY", "PASSWORD_LOCK_TIME", "PASSWORD_REUSE", "PATH",
		"PAUSE", "PERCENT", "PERIOD", "PERMISSIVE", "PHYSICAL", "PI", "PLACEHOLDER",
		"PLAN", "PLAY", "PRIVILEGES", "PROCESS", "PLUGIN", "PLUGINS", "POLICY",
		"PRECEDING", "PREPARE", "PRIMARY", "PROC", "PROCEDURE", "PROCESSLIST",
		"PROFILE", "PROPERTIES", "PROPERTY", "QUANTILE_STATE", "QUANTILE_UNION",
		"QUERY", "QUOTA", "QUALIFY", "QUARTER", "RANDOM", "RANGE", "READ", "REAL",
		"REBALANCE", "RECENT", "RECOVER", "RECYCLE", "REFRESH", "REFERENCES",
		"REGEXP", "RELEASE", "RENAME", "REPAIR", "REPEATABLE", "REPLACE", "REPLACE_IF_NOT_NULL",
		"REPLAYER", "REPLICA", "REPOSITORIES", "REPOSITORY", "RESOURCE", "RESOURCES",
		"RESTORE", "RESTRICTIVE", "RESUME", "RETURNS", "REVOKE", "REWRITTEN",
		"RIGHT", "RLIKE", "ROLE", "ROLES", "ROLLBACK", "ROLLUP", "ROUTINE",
		"ROW", "ROWS", "S3", "SAMPLE", "SCHEDULE", "SCHEDULER", "SCHEMA", "SCHEMAS",
		"SECOND", "SELECT", "SEMI", "SERIALIZABLE", "SESSION", "SESSION_USER",
		"SET", "SETS", "SET_SESSION_VARIABLE", "SHAPE", "SHOW", "SIGNED", "SKEW",
		"SMALLINT", "SNAPSHOT", "SONAME", "SPLIT", "SQL", "SQL_BLOCK_RULE",
		"STAGE", "STAGES", "START", "STARTS", "STATS", "STATUS", "STOP", "STORAGE",
		"STREAM", "STREAMING", "STRING", "STRUCT", "SUM", "SUPERUSER", "SWITCH",
		"SYNC", "SYSTEM", "TABLE", "TABLES", "TABLESAMPLE", "TABLET", "TABLETS",
		"TASK", "TASKS", "TEMPORARY", "TERMINATED", "TEXT", "THAN", "THEN",
		"TIME", "TIMESTAMP", "TINYINT", "TO", "TRANSACTION", "TRASH", "TREE",
		"TRIGGERS", "TRIM", "TRUE", "TRUNCATE", "TYPE", "TYPECAST", "TYPES",
		"UNBOUNDED", "UNCOMMITTED", "UNINSTALL", "UNION", "UNIQUE", "UNLOCK",
		"UNSET", "UNSIGNED", "UP", "UPDATE", "USE", "USER", "USE_MV", "USING",
		"VALUE", "VALUES", "VARCHAR", "VARIABLE", "VARIABLES", "VARIANT", "VAULT",
		"VAULTS", "VERBOSE", "VERSION", "VIEW", "VIEWS", "WARM", "WARNINGS",
		"WEEK", "WHEN", "WHERE", "WHITELIST", "WITH", "WORK", "WORKLOAD", "WRITE",
		"XOR", "YEAR", "EQ", "NSEQ", "NEQ", "LT", "LTE", "GT", "GTE", "PLUS",
		"SUBTRACT", "ASTERISK", "SLASH", "MOD", "TILDE", "AMPERSAND", "LOGICALAND",
		"LOGICALNOT", "PIPE", "DOUBLEPIPES", "HAT", "COLON", "ARROW", "HINT_START",
		"HINT_END", "COMMENT_START", "ATSIGN", "DOUBLEATSIGN", "STRING_LITERAL",
		"LEADING_STRING", "BIGINT_LITERAL", "SMALLINT_LITERAL", "TINYINT_LITERAL",
		"INTEGER_VALUE", "EXPONENT_VALUE", "DECIMAL_VALUE", "BIGDECIMAL_LITERAL",
		"IDENTIFIER", "BACKQUOTED_IDENTIFIER", "SIMPLE_COMMENT", "BRACKETED_COMMENT",
		"FROM_DUAL", "WS", "UNRECOGNIZED",
	}
	staticData.RuleNames = []string{
		"multiStatements", "singleStatement", "statement", "statementBase",
		"unsupportedStatement", "materializedViewStatement", "supportedJobStatement",
		"constraintStatement", "supportedDmlStatement", "supportedCreateStatement",
		"supportedAlterStatement", "supportedDropStatement", "supportedShowStatement",
		"supportedLoadStatement", "supportedOtherStatement", "unsupportedOtherStatement",
		"warmUpItem", "lockTable", "unsupportedShowStatement", "createRoutineLoad",
		"unsupportedLoadStatement", "loadProperty", "importSequenceStatement",
		"importDeleteOnStatement", "importWhereStatement", "importPrecedingFilterStatement",
		"importColumnsStatement", "importColumnDesc", "channelDescriptions",
		"channelDescription", "supportedRefreshStatement", "supportedCleanStatement",
		"unsupportedRefreshStatement", "unsupportedCleanStatement", "supportedCancelStatement",
		"unsupportedCancelStatement", "supportedAdminStatement", "supportedRecoverStatement",
		"unsupportedAdminStatement", "baseTableRef", "wildWhere", "unsupportedTransactionStatement",
		"unsupportedGrantRevokeStatement", "privilege", "privilegeList", "unsupportedAlterStatement",
		"alterSystemClause", "dropRollupClause", "addRollupClause", "alterTableClause",
		"columnPosition", "toRollup", "fromRollup", "unsupportedDropStatement",
		"unsupportedStatsStatement", "analyzeProperties", "unsupportedCreateStatement",
		"workloadPolicyActions", "workloadPolicyAction", "workloadPolicyConditions",
		"workloadPolicyCondition", "storageBackend", "passwordOption", "functionArguments",
		"functionArgument", "supportedSetStatement", "optionWithType", "optionWithoutType",
		"variable", "transactionAccessMode", "isolationLevel", "supportedUnsetStatement",
		"supportedUseStatement", "unsupportedUseStatement", "unsupportedDmlStatement",
		"stageAndPattern", "unsupportedKillStatement", "unsupportedDescribeStatement",
		"constraint", "partitionSpec", "partitionTable", "identityOrFunctionList",
		"identityOrFunction", "dataDesc", "buildMode", "refreshTrigger", "refreshSchedule",
		"refreshMethod", "mvPartition", "identifierOrText", "identifierOrTextOrAsterisk",
		"multipartIdentifierOrAsterisk", "identifierOrAsterisk", "userIdentify",
		"grantUserIdentify", "explain", "explainCommand", "planType", "replayCommand",
		"replayType", "mergeType", "preFilterClause", "deleteOnClause", "sequenceColClause",
		"colFromPath", "colMappingList", "mappingExpr", "withRemoteStorageSystem",
		"resourceDesc", "mysqlDataDesc", "skipLines", "outFileClause", "query",
		"queryTerm", "setQuantifier", "queryPrimary", "querySpecification",
		"cte", "aliasQuery", "columnAliases", "selectClause", "selectColumnClause",
		"whereClause", "fromClause", "intoClause", "bulkCollectClause", "tableRow",
		"relations", "relation", "joinRelation", "distributeType", "relationHint",
		"aggClause", "groupingElement", "groupingSet", "havingClause", "qualifyClause",
		"selectHint", "hintStatement", "hintAssignment", "updateAssignment",
		"updateAssignmentSeq", "lateralView", "queryOrganization", "sortClause",
		"sortItem", "limitClause", "partitionClause", "joinType", "joinCriteria",
		"identifierList", "identifierSeq", "optScanParams", "relationPrimary",
		"materializedViewName", "propertyClause", "propertyItemList", "propertyItem",
		"propertyKey", "propertyValue", "tableAlias", "multipartIdentifier",
		"simpleColumnDefs", "simpleColumnDef", "columnDefs", "columnDef", "indexDefs",
		"indexDef", "partitionsDef", "partitionDef", "lessThanPartitionDef",
		"fixedPartitionDef", "stepPartitionDef", "inPartitionDef", "partitionValueList",
		"partitionValueDef", "rollupDefs", "rollupDef", "aggTypeDef", "tabletList",
		"inlineTable", "namedExpression", "namedExpressionSeq", "expression",
		"lambdaExpression", "booleanExpression", "rowConstructor", "rowConstructorItem",
		"predicate", "valueExpression", "primaryExpression", "exceptOrReplace",
		"castDataType", "functionCallExpression", "functionIdentifier", "functionNameIdentifier",
		"windowSpec", "windowFrame", "frameUnits", "frameBoundary", "qualifiedName",
		"specifiedPartition", "constant", "comparisonOperator", "booleanValue",
		"whenClause", "interval", "unitIdentifier", "dataTypeWithNullable",
		"dataType", "primitiveColType", "complexColTypeList", "complexColType",
		"commentSpec", "sample", "sampleMethod", "tableSnapshot", "errorCapturingIdentifier",
		"errorCapturingIdentifierExtra", "identifier", "strictIdentifier", "quotedIdentifier",
		"number", "nonReserved",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 541, 6089, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7,
		198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2,
		203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7,
		207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2,
		212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7,
		216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2,
		221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 1, 0, 5, 0, 450, 8, 0, 10,
		0, 12, 0, 453, 9, 0, 1, 0, 3, 0, 456, 8, 0, 1, 0, 4, 0, 459, 8, 0, 11,
		0, 12, 0, 460, 1, 0, 5, 0, 464, 8, 0, 10, 0, 12, 0, 467, 9, 0, 1, 0, 5,
		0, 470, 8, 0, 10, 0, 12, 0, 473, 9, 0, 1, 0, 1, 0, 1, 1, 5, 1, 478, 8,
		1, 10, 1, 12, 1, 481, 9, 1, 1, 1, 3, 1, 484, 8, 1, 1, 1, 5, 1, 487, 8,
		1, 10, 1, 12, 1, 490, 9, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1,
		2, 1, 2, 5, 2, 501, 8, 2, 10, 2, 12, 2, 504, 9, 2, 3, 2, 506, 8, 2, 1,
		2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 514, 8, 2, 1, 2, 3, 2, 517, 8, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 5, 2, 523, 8, 2, 10, 2, 12, 2, 526, 9, 2, 1, 2,
		1, 2, 5, 2, 530, 8, 2, 10, 2, 12, 2, 533, 9, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		3, 2, 539, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 548, 8,
		2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 555, 8, 2, 1, 2, 1, 2, 1, 2, 1,
		2, 1, 2, 3, 2, 562, 8, 2, 1, 2, 1, 2, 3, 2, 566, 8, 2, 3, 2, 568, 8, 2,
		1, 3, 3, 3, 571, 8, 3, 1, 3, 1, 3, 3, 3, 575, 8, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 3, 3, 596, 8, 3, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3,
		4, 615, 8, 4, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 623, 8, 5, 1, 5,
		1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 630, 8, 5, 1, 5, 3, 5, 633, 8, 5, 1, 5, 1,
		5, 3, 5, 637, 8, 5, 1, 5, 3, 5, 640, 8, 5, 3, 5, 642, 8, 5, 1, 5, 3, 5,
		645, 8, 5, 1, 5, 1, 5, 3, 5, 649, 8, 5, 1, 5, 1, 5, 3, 5, 653, 8, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 661, 8, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 3, 5, 668, 8, 5, 1, 5, 1, 5, 3, 5, 672, 8, 5, 3, 5, 674, 8, 5,
		1, 5, 3, 5, 677, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5,
		1, 5, 1, 5, 3, 5, 689, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5,
		1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 703, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5,
		1, 5, 1, 5, 3, 5, 711, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 718, 8,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 725, 8, 5, 1, 5, 1, 5, 1, 5, 3,
		5, 730, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 3, 5, 756, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 769, 8, 6, 3, 6, 771, 8, 6, 1, 6, 1, 6,
		3, 6, 775, 8, 6, 1, 6, 1, 6, 1, 6, 3, 6, 780, 8, 6, 3, 6, 782, 8, 6, 1,
		6, 3, 6, 785, 8, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 793, 8, 6,
		1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 799, 8, 6, 1, 6, 3, 6, 802, 8, 6, 1, 6, 1,
		6, 1, 6, 3, 6, 807, 8, 6, 1, 6, 1, 6, 1, 6, 3, 6, 812, 8, 6, 3, 6, 814,
		8, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7,
		1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 835, 8, 7, 1, 8,
		3, 8, 838, 8, 8, 1, 8, 3, 8, 841, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 847,
		8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 854, 8, 8, 1, 8, 3, 8, 857, 8,
		8, 1, 8, 1, 8, 1, 8, 3, 8, 862, 8, 8, 1, 8, 3, 8, 865, 8, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 3, 8, 871, 8, 8, 1, 8, 1, 8, 3, 8, 875, 8, 8, 1, 8, 3, 8, 878,
		8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 886, 8, 8, 1, 8, 3, 8,
		889, 8, 8, 1, 8, 3, 8, 892, 8, 8, 1, 8, 3, 8, 895, 8, 8, 1, 8, 1, 8, 1,
		8, 1, 8, 3, 8, 901, 8, 8, 1, 8, 1, 8, 1, 8, 3, 8, 906, 8, 8, 1, 8, 3, 8,
		909, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 5, 8, 918, 8, 8, 10,
		8, 12, 8, 921, 9, 8, 1, 8, 1, 8, 3, 8, 925, 8, 8, 1, 8, 3, 8, 928, 8, 8,
		1, 8, 3, 8, 931, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 938, 8, 8, 1,
		8, 3, 8, 941, 8, 8, 1, 8, 1, 8, 1, 8, 3, 8, 946, 8, 8, 1, 8, 3, 8, 949,
		8, 8, 1, 8, 3, 8, 952, 8, 8, 1, 9, 1, 9, 3, 9, 956, 8, 9, 1, 9, 1, 9, 1,
		9, 1, 9, 3, 9, 962, 8, 9, 1, 9, 1, 9, 3, 9, 966, 8, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 3, 9, 972, 8, 9, 1, 9, 3, 9, 975, 8, 9, 1, 9, 1, 9, 3, 9, 979, 8,
		9, 1, 9, 1, 9, 1, 9, 3, 9, 984, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1,
		9, 3, 9, 992, 8, 9, 3, 9, 994, 8, 9, 1, 9, 1, 9, 3, 9, 998, 8, 9, 1, 9,
		3, 9, 1001, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1008, 8, 9, 1, 9,
		1, 9, 1, 9, 3, 9, 1013, 8, 9, 3, 9, 1015, 8, 9, 3, 9, 1017, 8, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1024, 8, 9, 1, 9, 3, 9, 1027, 8, 9, 1, 9,
		1, 9, 3, 9, 1031, 8, 9, 1, 9, 1, 9, 3, 9, 1035, 8, 9, 1, 9, 1, 9, 1, 9,
		3, 9, 1040, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1046, 8, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 3, 9, 1053, 8, 9, 1, 9, 1, 9, 3, 9, 1057, 8, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1067, 8, 9, 1, 9, 1, 9,
		1, 9, 3, 9, 1072, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1078, 8, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1086, 8, 9, 3, 9, 1088, 8, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1095, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1100,
		8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1108, 8, 9, 1, 9, 1, 9,
		3, 9, 1112, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1119, 8, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 3, 9, 1125, 8, 9, 1, 9, 1, 9, 3, 9, 1129, 8, 9, 1, 9,
		3, 9, 1132, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1140, 8, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1151, 8, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1163,
		8, 9, 1, 9, 1, 9, 3, 9, 1167, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9,
		1174, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1180, 8, 9, 1, 10, 1, 10, 1,
		10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 3, 10, 1191, 8, 10, 1, 10,
		1, 10, 3, 10, 1195, 8, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1,
		10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 3,
		10, 1224, 8, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 3, 10, 1231, 8, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 3, 10, 1237, 8, 10, 1, 10, 1, 10, 1, 10, 1,
		10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 5,
		10, 1263, 8, 10, 10, 10, 12, 10, 1266, 9, 10, 1, 10, 1, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 5, 10, 1276, 8, 10, 10, 10, 12, 10, 1279, 9,
		10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 5, 10, 1289,
		8, 10, 10, 10, 12, 10, 1292, 9, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1,
		10, 3, 10, 1310, 8, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10,
		1, 10, 3, 10, 1320, 8, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1,
		11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 1334, 8, 11, 1, 11, 1, 11,
		1, 11, 1, 11, 1, 11, 3, 11, 1341, 8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1,
		11, 3, 11, 1348, 8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 1355,
		8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 1363, 8, 11, 1,
		11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 1371, 8, 11, 1, 11, 1, 11,
		1, 11, 1, 11, 1, 11, 3, 11, 1378, 8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1,
		11, 1, 11, 3, 11, 1386, 8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11,
		3, 11, 1394, 8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1,
		11, 3, 11, 1404, 8, 11, 1, 11, 1, 11, 3, 11, 1408, 8, 11, 3, 11, 1410,
		8, 11, 1, 12, 1, 12, 3, 12, 1414, 8, 12, 1, 12, 1, 12, 3, 12, 1418, 8,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1434, 8, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 3, 12, 1440, 8, 12, 1, 12, 3, 12, 1443, 8, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1452, 8, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 3, 12, 1458, 8, 12, 1, 12, 1, 12, 3, 12, 1462, 8, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1474, 8,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1480, 8, 12, 1, 12, 3, 12, 1483,
		8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 1, 12, 3, 12, 1496, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 3, 12, 1506, 8, 12, 1, 12, 1, 12, 3, 12, 1510, 8, 12, 1,
		12, 1, 12, 3, 12, 1514, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12,
		1521, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1538, 8, 12, 1, 12,
		1, 12, 3, 12, 1542, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1555, 8, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 3, 12, 1561, 8, 12, 1, 12, 1, 12, 3, 12, 1565, 8, 12, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 3, 12, 1572, 8, 12, 1, 12, 1, 12, 1, 12, 3, 12,
		1577, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1583, 8, 12, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1603, 8, 12, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1622, 8, 12, 1, 12, 1, 12, 1,
		12, 3, 12, 1627, 8, 12, 1, 12, 3, 12, 1630, 8, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1639, 8, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1651, 8, 12, 1, 12,
		1, 12, 3, 12, 1655, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 1, 12, 1, 12, 5, 12, 1666, 8, 12, 10, 12, 12, 12, 1669, 9, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1681,
		8, 12, 1, 12, 1, 12, 3, 12, 1685, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 3, 12, 1692, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1698, 8, 12,
		1, 12, 3, 12, 1701, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1707, 8,
		12, 3, 12, 1709, 8, 12, 1, 13, 1, 13, 3, 13, 1713, 8, 13, 1, 14, 1, 14,
		1, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 1723, 8, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 5, 15, 1733, 8, 15, 10, 15,
		12, 15, 1736, 9, 15, 3, 15, 1738, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 3, 15, 1747, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15,
		3, 15, 1754, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 5, 15, 1760, 8, 15, 10,
		15, 12, 15, 1763, 9, 15, 3, 15, 1765, 8, 15, 1, 15, 3, 15, 1768, 8, 15,
		1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 5,
		15, 1780, 8, 15, 10, 15, 12, 15, 1783, 9, 15, 1, 15, 1, 15, 3, 15, 1787,
		8, 15, 1, 15, 3, 15, 1790, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 1, 15, 1, 15, 5, 15, 1802, 8, 15, 10, 15, 12, 15, 1805,
		9, 15, 1, 15, 1, 15, 3, 15, 1809, 8, 15, 1, 15, 3, 15, 1812, 8, 15, 1,
		15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 1819, 8, 15, 3, 15, 1821, 8, 15,
		1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 1827, 8, 16, 1, 17, 1, 17, 1, 17, 3,
		17, 1832, 8, 17, 1, 17, 1, 17, 3, 17, 1836, 8, 17, 1, 17, 3, 17, 1839,
		8, 17, 1, 17, 3, 17, 1842, 8, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 1, 18, 3, 18, 1851, 8, 18, 3, 18, 1853, 8, 18, 1, 18, 1, 18, 1, 18,
		1, 18, 1, 18, 1, 18, 3, 18, 1861, 8, 18, 3, 18, 1863, 8, 18, 1, 18, 1,
		18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 1873, 8, 18, 1, 18,
		3, 18, 1876, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 1883, 8,
		18, 1, 18, 3, 18, 1886, 8, 18, 1, 18, 1, 18, 3, 18, 1890, 8, 18, 1, 18,
		1, 18, 1, 18, 3, 18, 1895, 8, 18, 1, 18, 3, 18, 1898, 8, 18, 1, 18, 1,
		18, 3, 18, 1902, 8, 18, 1, 18, 1, 18, 1, 18, 3, 18, 1907, 8, 18, 1, 18,
		3, 18, 1910, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 3, 18, 1920, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 1926, 8, 18,
		1, 18, 1, 18, 1, 18, 3, 18, 1931, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3,
		18, 1937, 8, 18, 1, 18, 3, 18, 1940, 8, 18, 1, 18, 1, 18, 3, 18, 1944,
		8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 1951, 8, 18, 1, 18, 3,
		18, 1954, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 1961, 8, 18,
		1, 18, 3, 18, 1964, 8, 18, 1, 18, 3, 18, 1967, 8, 18, 1, 18, 1, 18, 3,
		18, 1971, 8, 18, 1, 18, 1, 18, 3, 18, 1975, 8, 18, 1, 18, 1, 18, 1, 18,
		3, 18, 1980, 8, 18, 1, 18, 3, 18, 1983, 8, 18, 1, 18, 3, 18, 1986, 8, 18,
		1, 18, 3, 18, 1989, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 1995, 8,
		18, 1, 18, 3, 18, 1998, 8, 18, 1, 18, 3, 18, 2001, 8, 18, 1, 18, 3, 18,
		2004, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 2013,
		8, 18, 1, 18, 1, 18, 3, 18, 2017, 8, 18, 1, 18, 3, 18, 2020, 8, 18, 1,
		18, 3, 18, 2023, 8, 18, 1, 18, 3, 18, 2026, 8, 18, 1, 18, 1, 18, 1, 18,
		3, 18, 2031, 8, 18, 1, 18, 1, 18, 3, 18, 2035, 8, 18, 1, 18, 3, 18, 2038,
		8, 18, 1, 18, 3, 18, 2041, 8, 18, 1, 18, 1, 18, 3, 18, 2045, 8, 18, 1,
		18, 1, 18, 1, 18, 1, 18, 3, 18, 2051, 8, 18, 1, 18, 3, 18, 2054, 8, 18,
		1, 18, 3, 18, 2057, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 1, 18, 3, 18, 2067, 8, 18, 1, 18, 3, 18, 2070, 8, 18, 1, 18, 3, 18,
		2073, 8, 18, 1, 18, 3, 18, 2076, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3,
		18, 2082, 8, 18, 1, 18, 3, 18, 2085, 8, 18, 1, 18, 1, 18, 3, 18, 2089,
		8, 18, 1, 18, 1, 18, 1, 18, 3, 18, 2094, 8, 18, 1, 18, 3, 18, 2097, 8,
		18, 1, 18, 1, 18, 1, 18, 3, 18, 2102, 8, 18, 1, 18, 3, 18, 2105, 8, 18,
		1, 18, 3, 18, 2108, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 2114, 8,
		18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 2121, 8, 18, 1, 18, 1, 18,
		3, 18, 2125, 8, 18, 1, 18, 3, 18, 2128, 8, 18, 1, 18, 1, 18, 1, 18, 3,
		18, 2133, 8, 18, 1, 18, 3, 18, 2136, 8, 18, 1, 18, 1, 18, 1, 18, 3, 18,
		2141, 8, 18, 1, 18, 1, 18, 3, 18, 2145, 8, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 3, 18, 2151, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18,
		2159, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 2165, 8, 18, 1, 18, 3,
		18, 2168, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18,
		1, 18, 3, 18, 2179, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 1, 18, 1, 18, 3, 18, 2190, 8, 18, 3, 18, 2192, 8, 18, 3, 18, 2194,
		8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 2201, 8, 18, 1, 18, 3,
		18, 2204, 8, 18, 1, 18, 3, 18, 2207, 8, 18, 1, 18, 3, 18, 2210, 8, 18,
		1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 2216, 8, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 1, 18, 1, 18, 3, 18, 2224, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18,
		2230, 8, 18, 1, 18, 3, 18, 2233, 8, 18, 1, 18, 3, 18, 2236, 8, 18, 1, 18,
		3, 18, 2239, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 2246, 8,
		18, 3, 18, 2248, 8, 18, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19,
		2256, 8, 19, 1, 19, 1, 19, 3, 19, 2260, 8, 19, 1, 19, 1, 19, 1, 19, 5,
		19, 2265, 8, 19, 10, 19, 12, 19, 2268, 9, 19, 3, 19, 2270, 8, 19, 1, 19,
		3, 19, 2273, 8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 2281,
		8, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 3, 20, 2290, 8,
		20, 1, 20, 3, 20, 2293, 8, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20,
		1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 3, 20, 2307, 8, 20, 1, 20, 1,
		20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20,
		1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1,
		20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20,
		1, 20, 1, 20, 1, 20, 1, 20, 3, 20, 2346, 8, 20, 1, 20, 1, 20, 1, 20, 1,
		20, 1, 20, 3, 20, 2353, 8, 20, 3, 20, 2355, 8, 20, 1, 20, 1, 20, 1, 20,
		1, 20, 1, 20, 1, 20, 3, 20, 2363, 8, 20, 1, 20, 3, 20, 2366, 8, 20, 1,
		20, 1, 20, 3, 20, 2370, 8, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20,
		1, 20, 1, 20, 1, 20, 1, 20, 3, 20, 2382, 8, 20, 1, 21, 1, 21, 1, 21, 1,
		21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 3, 21, 2394, 8, 21, 1, 22,
		1, 22, 1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1,
		25, 1, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 5, 26, 2416,
		8, 26, 10, 26, 12, 26, 2419, 9, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27,
		3, 27, 2426, 8, 27, 1, 27, 1, 27, 1, 27, 1, 27, 3, 27, 2432, 8, 27, 1,
		27, 1, 27, 3, 27, 2436, 8, 27, 1, 28, 1, 28, 1, 28, 5, 28, 2441, 8, 28,
		10, 28, 12, 28, 2444, 9, 28, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 3, 29,
		2451, 8, 29, 1, 29, 3, 29, 2454, 8, 29, 1, 30, 1, 30, 1, 30, 1, 30, 3,
		30, 2460, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 2466, 8, 30, 1, 30,
		1, 30, 1, 30, 3, 30, 2471, 8, 30, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1,
		31, 3, 31, 2479, 8, 31, 1, 31, 1, 31, 3, 31, 2483, 8, 31, 1, 32, 1, 32,
		1, 32, 1, 32, 1, 32, 3, 32, 2490, 8, 32, 1, 33, 1, 33, 1, 33, 1, 33, 1,
		33, 1, 33, 1, 33, 3, 33, 2499, 8, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33,
		2505, 8, 33, 1, 34, 1, 34, 1, 34, 1, 34, 3, 34, 2511, 8, 34, 1, 34, 3,
		34, 2514, 8, 34, 1, 34, 1, 34, 1, 34, 1, 34, 3, 34, 2520, 8, 34, 1, 34,
		3, 34, 2523, 8, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 3, 34, 2530, 8,
		34, 3, 34, 2532, 8, 34, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35,
		3, 35, 2541, 8, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 5, 35, 2549,
		8, 35, 10, 35, 12, 35, 2552, 9, 35, 1, 35, 3, 35, 2555, 8, 35, 1, 35, 1,
		35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 5, 35, 2566, 8, 35,
		10, 35, 12, 35, 2569, 9, 35, 1, 35, 3, 35, 2572, 8, 35, 1, 35, 1, 35, 1,
		35, 1, 35, 1, 35, 1, 35, 5, 35, 2580, 8, 35, 10, 35, 12, 35, 2583, 9, 35,
		1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 2589, 8, 35, 1, 35, 1, 35, 1, 35, 1,
		35, 3, 35, 2595, 8, 35, 3, 35, 2597, 8, 35, 1, 36, 1, 36, 1, 36, 1, 36,
		1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 5,
		36, 2613, 8, 36, 10, 36, 12, 36, 2616, 9, 36, 1, 36, 3, 36, 2619, 8, 36,
		1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 5, 36, 2630,
		8, 36, 10, 36, 12, 36, 2633, 9, 36, 1, 36, 3, 36, 2636, 8, 36, 1, 36, 1,
		36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36,
		1, 36, 1, 36, 1, 36, 3, 36, 2653, 8, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1,
		36, 1, 36, 1, 36, 1, 36, 3, 36, 2663, 8, 36, 1, 36, 1, 36, 1, 36, 1, 36,
		3, 36, 2669, 8, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 3, 36, 2677,
		8, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 5, 36, 2687,
		8, 36, 10, 36, 12, 36, 2690, 9, 36, 1, 36, 3, 36, 2693, 8, 36, 1, 36, 1,
		36, 1, 36, 1, 36, 1, 36, 1, 36, 3, 36, 2701, 8, 36, 3, 36, 2703, 8, 36,
		1, 37, 1, 37, 1, 37, 1, 37, 3, 37, 2709, 8, 37, 1, 37, 1, 37, 3, 37, 2713,
		8, 37, 1, 37, 1, 37, 1, 37, 1, 37, 3, 37, 2719, 8, 37, 1, 37, 1, 37, 3,
		37, 2723, 8, 37, 1, 37, 1, 37, 1, 37, 1, 37, 3, 37, 2729, 8, 37, 1, 37,
		1, 37, 3, 37, 2733, 8, 37, 1, 37, 1, 37, 1, 37, 3, 37, 2738, 8, 37, 1,
		38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38,
		1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1,
		38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38,
		3, 38, 2772, 8, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 3, 38, 2779, 8,
		38, 1, 38, 3, 38, 2782, 8, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38,
		1, 38, 3, 38, 2791, 8, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 3, 38, 2798,
		8, 38, 3, 38, 2800, 8, 38, 1, 39, 1, 39, 3, 39, 2804, 8, 39, 1, 39, 3,
		39, 2807, 8, 39, 1, 39, 3, 39, 2810, 8, 39, 1, 39, 3, 39, 2813, 8, 39,
		1, 39, 1, 39, 3, 39, 2817, 8, 39, 1, 39, 3, 39, 2820, 8, 39, 1, 40, 1,
		40, 1, 40, 1, 40, 3, 40, 2826, 8, 40, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41,
		2832, 8, 41, 3, 41, 2834, 8, 41, 1, 41, 1, 41, 3, 41, 2838, 8, 41, 1, 41,
		1, 41, 3, 41, 2842, 8, 41, 1, 41, 3, 41, 2845, 8, 41, 1, 41, 3, 41, 2848,
		8, 41, 1, 41, 3, 41, 2851, 8, 41, 1, 41, 1, 41, 3, 41, 2855, 8, 41, 1,
		41, 1, 41, 3, 41, 2859, 8, 41, 1, 41, 3, 41, 2862, 8, 41, 1, 41, 3, 41,
		2865, 8, 41, 1, 41, 3, 41, 2868, 8, 41, 3, 41, 2870, 8, 41, 1, 42, 1, 42,
		1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 2880, 8, 42, 1, 42, 1,
		42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42,
		3, 42, 2894, 8, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 2901, 8,
		42, 1, 42, 1, 42, 1, 42, 1, 42, 5, 42, 2907, 8, 42, 10, 42, 12, 42, 2910,
		9, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1,
		42, 3, 42, 2922, 8, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42,
		1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 2936, 8, 42, 1, 42, 1, 42, 1,
		42, 1, 42, 1, 42, 3, 42, 2943, 8, 42, 1, 42, 1, 42, 1, 42, 1, 42, 5, 42,
		2949, 8, 42, 10, 42, 12, 42, 2952, 9, 42, 1, 42, 1, 42, 3, 42, 2956, 8,
		42, 1, 43, 1, 43, 3, 43, 2960, 8, 43, 1, 43, 3, 43, 2963, 8, 43, 1, 44,
		1, 44, 1, 44, 5, 44, 2968, 8, 44, 10, 44, 12, 44, 2971, 9, 44, 1, 45, 1,
		45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45,
		1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1,
		45, 1, 45, 1, 45, 3, 45, 2998, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45,
		1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3,
		45, 3015, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 3023,
		8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1,
		45, 3, 45, 3035, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 3041, 8, 45,
		1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 3047, 8, 45, 3, 45, 3049, 8, 45, 1,
		46, 1, 46, 1, 46, 1, 46, 1, 46, 5, 46, 3056, 8, 46, 10, 46, 12, 46, 3059,
		9, 46, 1, 46, 3, 46, 3062, 8, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 5,
		46, 3069, 8, 46, 10, 46, 12, 46, 3072, 9, 46, 1, 46, 1, 46, 1, 46, 1, 46,
		1, 46, 5, 46, 3079, 8, 46, 10, 46, 12, 46, 3082, 9, 46, 1, 46, 1, 46, 1,
		46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46,
		1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 5, 46, 3102, 8, 46, 10, 46, 12, 46,
		3105, 9, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 5, 46, 3113, 8,
		46, 10, 46, 12, 46, 3116, 9, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1,
		46, 1, 46, 1, 46, 1, 46, 3, 46, 3127, 8, 46, 1, 46, 1, 46, 1, 46, 1, 46,
		1, 46, 5, 46, 3134, 8, 46, 10, 46, 12, 46, 3137, 9, 46, 1, 46, 1, 46, 1,
		46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 3149, 8, 46,
		1, 47, 1, 47, 3, 47, 3153, 8, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3,
		48, 3160, 8, 48, 1, 48, 3, 48, 3163, 8, 48, 1, 48, 3, 48, 3166, 8, 48,
		1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 3172, 8, 49, 1, 49, 3, 49, 3175, 8,
		49, 1, 49, 3, 49, 3178, 8, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49,
		3, 49, 3186, 8, 49, 1, 49, 3, 49, 3189, 8, 49, 1, 49, 1, 49, 1, 49, 1,
		49, 3, 49, 3195, 8, 49, 1, 49, 3, 49, 3198, 8, 49, 1, 49, 1, 49, 1, 49,
		1, 49, 3, 49, 3204, 8, 49, 1, 49, 3, 49, 3207, 8, 49, 1, 49, 3, 49, 3210,
		8, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 3216, 8, 49, 1, 49, 3, 49, 3219,
		8, 49, 1, 49, 1, 49, 3, 49, 3223, 8, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1,
		49, 1, 49, 3, 49, 3231, 8, 49, 1, 49, 1, 49, 1, 49, 3, 49, 3236, 8, 49,
		3, 49, 3238, 8, 49, 3, 49, 3240, 8, 49, 1, 49, 3, 49, 3243, 8, 49, 1, 49,
		1, 49, 3, 49, 3247, 8, 49, 1, 49, 1, 49, 1, 49, 3, 49, 3252, 8, 49, 1,
		49, 1, 49, 3, 49, 3256, 8, 49, 1, 49, 1, 49, 1, 49, 3, 49, 3261, 8, 49,
		1, 49, 1, 49, 3, 49, 3265, 8, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1,
		49, 3, 49, 3273, 8, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49,
		3, 49, 3282, 8, 49, 1, 49, 1, 49, 3, 49, 3286, 8, 49, 1, 49, 3, 49, 3289,
		8, 49, 1, 49, 3, 49, 3292, 8, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3,
		49, 3299, 8, 49, 1, 49, 3, 49, 3302, 8, 49, 1, 49, 1, 49, 1, 49, 1, 49,
		1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1,
		49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 3327,
		8, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 3335, 8, 49, 1,
		49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 3344, 8, 49, 1, 49,
		1, 49, 1, 49, 3, 49, 3349, 8, 49, 3, 49, 3351, 8, 49, 3, 49, 3353, 8, 49,
		1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1,
		49, 1, 49, 1, 49, 1, 49, 3, 49, 3369, 8, 49, 1, 49, 1, 49, 3, 49, 3373,
		8, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 3383,
		8, 49, 1, 49, 3, 49, 3386, 8, 49, 3, 49, 3388, 8, 49, 1, 50, 1, 50, 1,
		50, 3, 50, 3393, 8, 50, 1, 51, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52, 1, 53,
		1, 53, 3, 53, 3403, 8, 53, 1, 53, 1, 53, 1, 53, 3, 53, 3408, 8, 53, 1,
		53, 1, 53, 1, 53, 3, 53, 3413, 8, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53,
		1, 53, 3, 53, 3421, 8, 53, 1, 53, 1, 53, 3, 53, 3425, 8, 53, 1, 53, 1,
		53, 1, 53, 1, 53, 3, 53, 3431, 8, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53,
		3, 53, 3438, 8, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1,
		53, 3, 53, 3448, 8, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53,
		3456, 8, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 3465,
		8, 53, 3, 53, 3467, 8, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 3473, 8,
		53, 1, 53, 3, 53, 3476, 8, 53, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 3482,
		8, 54, 1, 54, 3, 54, 3485, 8, 54, 1, 54, 1, 54, 5, 54, 3489, 8, 54, 10,
		54, 12, 54, 3492, 9, 54, 1, 54, 3, 54, 3495, 8, 54, 1, 54, 1, 54, 1, 54,
		1, 54, 1, 54, 5, 54, 3502, 8, 54, 10, 54, 12, 54, 3505, 9, 54, 1, 54, 3,
		54, 3508, 8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54,
		1, 54, 3, 54, 3519, 8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 3526,
		8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3,
		54, 3537, 8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 3543, 8, 54, 1, 54,
		3, 54, 3546, 8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1,
		54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54,
		1, 54, 3, 54, 3567, 8, 54, 1, 54, 3, 54, 3570, 8, 54, 1, 54, 1, 54, 1,
		54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54,
		3, 54, 3585, 8, 54, 1, 54, 1, 54, 1, 54, 3, 54, 3590, 8, 54, 1, 54, 3,
		54, 3593, 8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54,
		3, 54, 3603, 8, 54, 1, 54, 1, 54, 3, 54, 3607, 8, 54, 1, 54, 3, 54, 3610,
		8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 3616, 8, 54, 1, 54, 1, 54, 1,
		54, 1, 54, 3, 54, 3622, 8, 54, 1, 54, 3, 54, 3625, 8, 54, 1, 54, 1, 54,
		1, 54, 1, 54, 1, 54, 3, 54, 3632, 8, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1,
		55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 3644, 8, 55, 1, 55, 1, 55,
		1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 3652, 8, 55, 1, 56, 1, 56, 1, 56, 1,
		56, 1, 56, 3, 56, 3659, 8, 56, 1, 56, 1, 56, 3, 56, 3663, 8, 56, 1, 56,
		1, 56, 3, 56, 3667, 8, 56, 1, 56, 3, 56, 3670, 8, 56, 1, 56, 1, 56, 1,
		56, 1, 56, 3, 56, 3676, 8, 56, 1, 56, 1, 56, 1, 56, 3, 56, 3681, 8, 56,
		1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 3688, 8, 56, 1, 56, 3, 56, 3691,
		8, 56, 1, 56, 1, 56, 3, 56, 3695, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1,
		56, 3, 56, 3702, 8, 56, 1, 56, 1, 56, 1, 56, 3, 56, 3707, 8, 56, 1, 56,
		1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 3714, 8, 56, 1, 56, 1, 56, 1, 56, 1,
		56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 3725, 8, 56, 1, 56, 1, 56,
		1, 56, 1, 56, 1, 56, 3, 56, 3732, 8, 56, 1, 56, 1, 56, 1, 56, 3, 56, 3737,
		8, 56, 1, 56, 1, 56, 1, 56, 3, 56, 3742, 8, 56, 1, 56, 1, 56, 1, 56, 1,
		56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 3754, 8, 56, 1, 56,
		1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 3762, 8, 56, 1, 56, 3, 56, 3765,
		8, 56, 1, 56, 1, 56, 3, 56, 3769, 8, 56, 1, 56, 1, 56, 3, 56, 3773, 8,
		56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 3779, 8, 56, 1, 56, 1, 56, 3, 56,
		3783, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 3791, 8,
		56, 1, 56, 1, 56, 3, 56, 3795, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56,
		1, 56, 3, 56, 3803, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3,
		56, 3811, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 3818, 8, 56,
		1, 56, 3, 56, 3821, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3,
		56, 3829, 8, 56, 1, 56, 1, 56, 3, 56, 3833, 8, 56, 1, 56, 1, 56, 1, 56,
		1, 56, 1, 56, 1, 56, 3, 56, 3841, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1,
		56, 3, 56, 3848, 8, 56, 1, 56, 1, 56, 3, 56, 3852, 8, 56, 3, 56, 3854,
		8, 56, 1, 57, 1, 57, 1, 57, 5, 57, 3859, 8, 57, 10, 57, 12, 57, 3862, 9,
		57, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 3868, 8, 58, 3, 58, 3870, 8, 58,
		1, 59, 1, 59, 1, 59, 5, 59, 3875, 8, 59, 10, 59, 12, 59, 3878, 9, 59, 1,
		60, 1, 60, 1, 60, 1, 60, 3, 60, 3884, 8, 60, 1, 61, 1, 61, 3, 61, 3888,
		8, 61, 1, 61, 1, 61, 1, 61, 1, 61, 3, 61, 3894, 8, 61, 1, 62, 1, 62, 1,
		62, 3, 62, 3899, 8, 62, 3, 62, 3901, 8, 62, 1, 62, 1, 62, 1, 62, 1, 62,
		1, 62, 1, 62, 3, 62, 3909, 8, 62, 3, 62, 3911, 8, 62, 1, 62, 1, 62, 1,
		62, 1, 62, 1, 62, 3, 62, 3918, 8, 62, 3, 62, 3920, 8, 62, 1, 62, 1, 62,
		3, 62, 3924, 8, 62, 1, 62, 1, 62, 1, 62, 1, 62, 3, 62, 3930, 8, 62, 3,
		62, 3932, 8, 62, 1, 62, 3, 62, 3935, 8, 62, 1, 63, 1, 63, 1, 63, 5, 63,
		3940, 8, 63, 10, 63, 12, 63, 3943, 9, 63, 1, 64, 1, 64, 3, 64, 3947, 8,
		64, 1, 65, 1, 65, 1, 65, 3, 65, 3952, 8, 65, 1, 65, 1, 65, 1, 65, 3, 65,
		3957, 8, 65, 5, 65, 3959, 8, 65, 10, 65, 12, 65, 3962, 9, 65, 1, 65, 1,
		65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65,
		3975, 8, 65, 1, 65, 1, 65, 1, 65, 3, 65, 3980, 8, 65, 1, 65, 1, 65, 1,
		65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 3993,
		8, 65, 3, 65, 3995, 8, 65, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66, 4002,
		8, 66, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 3, 67, 4010, 8, 67, 1,
		67, 1, 67, 3, 67, 4014, 8, 67, 1, 67, 1, 67, 1, 67, 3, 67, 4019, 8, 67,
		1, 67, 1, 67, 1, 67, 3, 67, 4024, 8, 67, 1, 67, 1, 67, 1, 67, 3, 67, 4029,
		8, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 3, 67, 4037, 8, 67, 1,
		67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 3, 67, 4046, 8, 67, 1, 67,
		3, 67, 4049, 8, 67, 1, 68, 1, 68, 1, 68, 3, 68, 4054, 8, 68, 3, 68, 4056,
		8, 68, 1, 68, 1, 68, 1, 68, 1, 68, 3, 68, 4062, 8, 68, 1, 68, 1, 68, 1,
		68, 1, 68, 1, 68, 3, 68, 4069, 8, 68, 1, 69, 1, 69, 1, 69, 1, 70, 1, 70,
		1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 4083, 8, 70, 1,
		71, 1, 71, 3, 71, 4087, 8, 71, 1, 71, 1, 71, 1, 71, 3, 71, 4092, 8, 71,
		1, 71, 1, 71, 1, 71, 1, 71, 3, 71, 4098, 8, 71, 1, 72, 1, 72, 1, 72, 1,
		72, 1, 72, 1, 72, 3, 72, 4106, 8, 72, 1, 72, 3, 72, 4109, 8, 72, 1, 73,
		1, 73, 1, 73, 1, 73, 3, 73, 4115, 8, 73, 1, 73, 3, 73, 4118, 8, 73, 1,
		73, 1, 73, 1, 73, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 4127, 8, 74, 1, 74,
		3, 74, 4130, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 4136, 8, 74, 1,
		74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 4146, 8, 74,
		1, 74, 1, 74, 3, 74, 4150, 8, 74, 1, 74, 3, 74, 4153, 8, 74, 3, 74, 4155,
		8, 74, 1, 75, 1, 75, 1, 75, 3, 75, 4160, 8, 75, 1, 75, 1, 75, 1, 75, 3,
		75, 4165, 8, 75, 1, 76, 1, 76, 3, 76, 4169, 8, 76, 1, 76, 1, 76, 1, 76,
		1, 76, 3, 76, 4175, 8, 76, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 4182,
		8, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1,
		77, 3, 77, 4194, 8, 77, 3, 77, 4196, 8, 77, 1, 78, 1, 78, 1, 78, 1, 78,
		1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 4210, 8,
		78, 1, 79, 3, 79, 4213, 8, 79, 1, 79, 1, 79, 1, 79, 3, 79, 4218, 8, 79,
		1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 4226, 8, 79, 1, 80, 3,
		80, 4229, 8, 80, 1, 80, 1, 80, 1, 80, 3, 80, 4234, 8, 80, 1, 80, 1, 80,
		1, 80, 3, 80, 4239, 8, 80, 1, 80, 1, 80, 1, 81, 1, 81, 1, 81, 1, 81, 5,
		81, 4247, 8, 81, 10, 81, 12, 81, 4250, 9, 81, 1, 81, 1, 81, 1, 82, 1, 82,
		3, 82, 4256, 8, 82, 1, 83, 3, 83, 4259, 8, 83, 1, 83, 3, 83, 4262, 8, 83,
		1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 5, 83, 4270, 8, 83, 10, 83, 12,
		83, 4273, 9, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 3, 83, 4280, 8, 83,
		1, 83, 1, 83, 1, 83, 1, 83, 3, 83, 4286, 8, 83, 1, 83, 1, 83, 1, 83, 1,
		83, 3, 83, 4292, 8, 83, 1, 83, 1, 83, 1, 83, 3, 83, 4297, 8, 83, 1, 83,
		1, 83, 1, 83, 3, 83, 4302, 8, 83, 1, 83, 3, 83, 4305, 8, 83, 1, 83, 3,
		83, 4308, 8, 83, 1, 83, 3, 83, 4311, 8, 83, 1, 83, 3, 83, 4314, 8, 83,
		1, 83, 3, 83, 4317, 8, 83, 1, 83, 3, 83, 4320, 8, 83, 1, 83, 3, 83, 4323,
		8, 83, 1, 83, 3, 83, 4326, 8, 83, 1, 83, 3, 83, 4329, 8, 83, 1, 83, 3,
		83, 4332, 8, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83,
		1, 83, 3, 83, 4343, 8, 83, 1, 83, 3, 83, 4346, 8, 83, 1, 83, 3, 83, 4349,
		8, 83, 1, 83, 3, 83, 4352, 8, 83, 1, 83, 3, 83, 4355, 8, 83, 3, 83, 4357,
		8, 83, 1, 84, 1, 84, 1, 84, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1,
		85, 3, 85, 4369, 8, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 3, 86, 4376,
		8, 86, 1, 87, 1, 87, 1, 88, 1, 88, 3, 88, 4382, 8, 88, 1, 89, 1, 89, 3,
		89, 4386, 8, 89, 1, 90, 1, 90, 1, 90, 3, 90, 4391, 8, 90, 1, 91, 1, 91,
		1, 91, 5, 91, 4396, 8, 91, 10, 91, 12, 91, 4399, 9, 91, 1, 92, 1, 92, 3,
		92, 4403, 8, 92, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 3, 93,
		4412, 8, 93, 3, 93, 4414, 8, 93, 1, 94, 1, 94, 1, 94, 1, 94, 3, 94, 4420,
		8, 94, 1, 94, 3, 94, 4423, 8, 94, 1, 95, 1, 95, 3, 95, 4427, 8, 95, 1,
		95, 3, 95, 4430, 8, 95, 1, 95, 3, 95, 4433, 8, 95, 1, 96, 1, 96, 1, 97,
		1, 97, 1, 98, 1, 98, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 1, 99, 3, 99, 4447,
		8, 99, 1, 100, 1, 100, 1, 101, 1, 101, 1, 101, 1, 101, 1, 102, 1, 102,
		1, 102, 1, 102, 1, 103, 1, 103, 1, 103, 1, 103, 1, 104, 1, 104, 1, 104,
		1, 104, 1, 104, 1, 104, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 5, 105,
		4474, 8, 105, 10, 105, 12, 105, 4477, 9, 105, 1, 105, 1, 105, 1, 106, 1,
		106, 1, 106, 1, 106, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1,
		107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1,
		107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1,
		107, 1, 107, 3, 107, 4511, 8, 107, 3, 107, 4513, 8, 107, 1, 108, 1, 108,
		1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 3, 108, 4522, 8, 108, 1, 109, 1,
		109, 3, 109, 4526, 8, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109,
		1, 109, 3, 109, 4535, 8, 109, 1, 109, 1, 109, 1, 109, 1, 109, 3, 109, 4541,
		8, 109, 1, 109, 1, 109, 1, 109, 1, 109, 3, 109, 4547, 8, 109, 1, 109, 3,
		109, 4550, 8, 109, 1, 109, 3, 109, 4553, 8, 109, 1, 109, 3, 109, 4556,
		8, 109, 1, 109, 3, 109, 4559, 8, 109, 1, 110, 1, 110, 1, 110, 1, 110, 1,
		110, 1, 110, 3, 110, 4567, 8, 110, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111,
		1, 111, 3, 111, 4575, 8, 111, 1, 111, 3, 111, 4578, 8, 111, 1, 112, 3,
		112, 4581, 8, 112, 1, 112, 1, 112, 1, 112, 1, 113, 1, 113, 1, 113, 1, 113,
		1, 113, 1, 113, 3, 113, 4592, 8, 113, 1, 113, 1, 113, 1, 113, 1, 113, 3,
		113, 4598, 8, 113, 1, 113, 5, 113, 4601, 8, 113, 10, 113, 12, 113, 4604,
		9, 113, 1, 114, 1, 114, 1, 115, 1, 115, 1, 115, 1, 115, 1, 115, 1, 115,
		3, 115, 4614, 8, 115, 1, 116, 1, 116, 3, 116, 4618, 8, 116, 1, 116, 3,
		116, 4621, 8, 116, 1, 116, 3, 116, 4624, 8, 116, 1, 116, 3, 116, 4627,
		8, 116, 1, 116, 3, 116, 4630, 8, 116, 1, 116, 3, 116, 4633, 8, 116, 1,
		116, 1, 116, 1, 116, 1, 117, 1, 117, 1, 117, 1, 117, 5, 117, 4642, 8, 117,
		10, 117, 12, 117, 4645, 9, 117, 1, 118, 1, 118, 3, 118, 4649, 8, 118, 1,
		118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 119, 1, 119, 1, 119, 1, 119, 5,
		119, 4660, 8, 119, 10, 119, 12, 119, 4663, 9, 119, 1, 119, 1, 119, 1, 120,
		1, 120, 3, 120, 4669, 8, 120, 1, 120, 1, 120, 1, 121, 1, 121, 1, 122, 1,
		122, 1, 122, 1, 123, 1, 123, 1, 123, 1, 124, 3, 124, 4682, 8, 124, 1, 124,
		1, 124, 1, 124, 3, 124, 4687, 8, 124, 1, 124, 1, 124, 1, 124, 3, 124, 4692,
		8, 124, 5, 124, 4694, 8, 124, 10, 124, 12, 124, 4697, 9, 124, 1, 125, 1,
		125, 1, 125, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 127, 1, 127, 1,
		127, 5, 127, 4710, 8, 127, 10, 127, 12, 127, 4713, 9, 127, 1, 128, 1, 128,
		5, 128, 4717, 8, 128, 10, 128, 12, 128, 4720, 9, 128, 1, 129, 1, 129, 1,
		129, 3, 129, 4725, 8, 129, 1, 129, 1, 129, 3, 129, 4729, 8, 129, 1, 130,
		1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 3, 130, 4739, 8,
		130, 1, 131, 1, 131, 1, 131, 1, 131, 5, 131, 4745, 8, 131, 10, 131, 12,
		131, 4748, 9, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 5, 131,
		4756, 8, 131, 10, 131, 12, 131, 4759, 9, 131, 1, 131, 1, 131, 3, 131, 4763,
		8, 131, 1, 132, 1, 132, 1, 132, 1, 132, 1, 133, 1, 133, 1, 133, 1, 133,
		1, 133, 5, 133, 4774, 8, 133, 10, 133, 12, 133, 4777, 9, 133, 3, 133, 4779,
		8, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 5, 133, 4787, 8,
		133, 10, 133, 12, 133, 4790, 9, 133, 3, 133, 4792, 8, 133, 1, 133, 1, 133,
		1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 5, 133, 4801, 8, 133, 10, 133,
		12, 133, 4804, 9, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 5, 133,
		4811, 8, 133, 10, 133, 12, 133, 4814, 9, 133, 3, 133, 4816, 8, 133, 1,
		134, 1, 134, 1, 134, 1, 134, 5, 134, 4822, 8, 134, 10, 134, 12, 134, 4825,
		9, 134, 3, 134, 4827, 8, 134, 1, 134, 1, 134, 1, 135, 1, 135, 1, 135, 1,
		136, 1, 136, 1, 136, 1, 137, 1, 137, 3, 137, 4839, 8, 137, 1, 137, 5, 137,
		4842, 8, 137, 10, 137, 12, 137, 4845, 9, 137, 1, 137, 1, 137, 1, 138, 1,
		138, 1, 138, 1, 138, 3, 138, 4853, 8, 138, 1, 138, 5, 138, 4856, 8, 138,
		10, 138, 12, 138, 4859, 9, 138, 1, 138, 1, 138, 3, 138, 4863, 8, 138, 1,
		138, 1, 138, 1, 138, 1, 138, 1, 138, 5, 138, 4870, 8, 138, 10, 138, 12,
		138, 4873, 9, 138, 1, 138, 1, 138, 3, 138, 4877, 8, 138, 3, 138, 4879,
		8, 138, 1, 139, 1, 139, 1, 139, 1, 139, 3, 139, 4885, 8, 139, 3, 139, 4887,
		8, 139, 1, 139, 3, 139, 4890, 8, 139, 1, 140, 1, 140, 1, 140, 1, 140, 3,
		140, 4896, 8, 140, 1, 141, 1, 141, 1, 141, 5, 141, 4901, 8, 141, 10, 141,
		12, 141, 4904, 9, 141, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142,
		1, 142, 5, 142, 4913, 8, 142, 10, 142, 12, 142, 4916, 9, 142, 3, 142, 4918,
		8, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 5, 142, 4926, 8,
		142, 10, 142, 12, 142, 4929, 9, 142, 1, 143, 3, 143, 4932, 8, 143, 1, 143,
		3, 143, 4935, 8, 143, 1, 144, 1, 144, 1, 144, 1, 144, 1, 144, 5, 144, 4942,
		8, 144, 10, 144, 12, 144, 4945, 9, 144, 1, 145, 1, 145, 3, 145, 4949, 8,
		145, 1, 145, 1, 145, 3, 145, 4953, 8, 145, 1, 146, 1, 146, 1, 146, 1, 146,
		1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 3, 146, 4965, 8, 146, 1,
		147, 1, 147, 1, 147, 1, 147, 1, 147, 5, 147, 4972, 8, 147, 10, 147, 12,
		147, 4975, 9, 147, 1, 148, 3, 148, 4978, 8, 148, 1, 148, 1, 148, 1, 148,
		3, 148, 4983, 8, 148, 1, 148, 1, 148, 3, 148, 4987, 8, 148, 1, 148, 1,
		148, 3, 148, 4991, 8, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148,
		1, 148, 1, 148, 3, 148, 5001, 8, 148, 1, 149, 1, 149, 1, 149, 1, 149, 3,
		149, 5007, 8, 149, 1, 150, 1, 150, 1, 150, 1, 150, 1, 151, 1, 151, 1, 151,
		5, 151, 5016, 8, 151, 10, 151, 12, 151, 5019, 9, 151, 1, 152, 1, 152, 1,
		152, 1, 152, 3, 152, 5025, 8, 152, 1, 152, 1, 152, 1, 153, 1, 153, 3, 153,
		5031, 8, 153, 1, 153, 3, 153, 5034, 8, 153, 1, 153, 3, 153, 5037, 8, 153,
		1, 153, 3, 153, 5040, 8, 153, 1, 153, 3, 153, 5043, 8, 153, 1, 153, 1,
		153, 3, 153, 5047, 8, 153, 1, 153, 3, 153, 5050, 8, 153, 1, 153, 5, 153,
		5053, 8, 153, 10, 153, 12, 153, 5056, 9, 153, 1, 153, 1, 153, 1, 153, 1,
		153, 1, 153, 5, 153, 5063, 8, 153, 10, 153, 12, 153, 5066, 9, 153, 1, 153,
		1, 153, 1, 153, 3, 153, 5071, 8, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1,
		153, 1, 153, 1, 153, 3, 153, 5080, 8, 153, 1, 154, 1, 154, 1, 154, 1, 155,
		1, 155, 1, 155, 1, 155, 1, 155, 1, 156, 1, 156, 1, 156, 5, 156, 5093, 8,
		156, 10, 156, 12, 156, 5096, 9, 156, 1, 157, 1, 157, 1, 157, 1, 157, 1,
		158, 1, 158, 3, 158, 5104, 8, 158, 1, 159, 1, 159, 3, 159, 5108, 8, 159,
		1, 160, 3, 160, 5111, 8, 160, 1, 160, 1, 160, 3, 160, 5115, 8, 160, 3,
		160, 5117, 8, 160, 1, 161, 1, 161, 1, 161, 5, 161, 5122, 8, 161, 10, 161,
		12, 161, 5125, 9, 161, 1, 162, 1, 162, 1, 162, 5, 162, 5130, 8, 162, 10,
		162, 12, 162, 5133, 9, 162, 1, 163, 1, 163, 1, 163, 3, 163, 5138, 8, 163,
		1, 164, 1, 164, 1, 164, 5, 164, 5143, 8, 164, 10, 164, 12, 164, 5146, 9,
		164, 1, 165, 1, 165, 1, 165, 3, 165, 5151, 8, 165, 1, 165, 3, 165, 5154,
		8, 165, 1, 165, 1, 165, 3, 165, 5158, 8, 165, 1, 165, 1, 165, 1, 165, 1,
		165, 1, 165, 3, 165, 5165, 8, 165, 1, 165, 3, 165, 5168, 8, 165, 1, 165,
		3, 165, 5171, 8, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 3, 165, 5178,
		8, 165, 3, 165, 5180, 8, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1,
		165, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 3,
		165, 5196, 8, 165, 3, 165, 5198, 8, 165, 3, 165, 5200, 8, 165, 1, 165,
		1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 3, 165, 5209, 8, 165, 3,
		165, 5211, 8, 165, 1, 165, 1, 165, 3, 165, 5215, 8, 165, 1, 166, 1, 166,
		1, 166, 5, 166, 5220, 8, 166, 10, 166, 12, 166, 5223, 9, 166, 1, 167, 1,
		167, 1, 167, 1, 167, 3, 167, 5229, 8, 167, 1, 167, 1, 167, 1, 167, 1, 167,
		3, 167, 5235, 8, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 3, 167, 5242,
		8, 167, 1, 167, 1, 167, 3, 167, 5246, 8, 167, 1, 168, 1, 168, 1, 168, 5,
		168, 5251, 8, 168, 10, 168, 12, 168, 5254, 9, 168, 1, 169, 1, 169, 1, 169,
		1, 169, 3, 169, 5260, 8, 169, 1, 169, 1, 169, 1, 169, 1, 169, 3, 169, 5266,
		8, 169, 1, 170, 1, 170, 1, 170, 1, 170, 3, 170, 5272, 8, 170, 1, 170, 1,
		170, 1, 170, 1, 170, 1, 170, 1, 170, 3, 170, 5280, 8, 170, 1, 171, 1, 171,
		1, 171, 1, 171, 3, 171, 5286, 8, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1,
		171, 1, 171, 1, 171, 1, 171, 1, 172, 1, 172, 1, 172, 1, 172, 1, 172, 1,
		172, 1, 172, 3, 172, 5303, 8, 172, 1, 173, 1, 173, 1, 173, 1, 173, 3, 173,
		5309, 8, 173, 1, 173, 1, 173, 1, 173, 1, 173, 1, 173, 1, 173, 1, 173, 5,
		173, 5318, 8, 173, 10, 173, 12, 173, 5321, 9, 173, 1, 173, 1, 173, 1, 173,
		3, 173, 5326, 8, 173, 3, 173, 5328, 8, 173, 1, 174, 1, 174, 1, 174, 1,
		174, 5, 174, 5334, 8, 174, 10, 174, 12, 174, 5337, 9, 174, 1, 174, 1, 174,
		1, 175, 1, 175, 1, 176, 1, 176, 1, 176, 5, 176, 5346, 8, 176, 10, 176,
		12, 176, 5349, 9, 176, 1, 177, 1, 177, 1, 177, 1, 177, 1, 177, 3, 177,
		5356, 8, 177, 1, 177, 3, 177, 5359, 8, 177, 1, 178, 1, 178, 1, 179, 1,
		179, 1, 179, 1, 179, 1, 179, 5, 179, 5368, 8, 179, 10, 179, 12, 179, 5371,
		9, 179, 1, 179, 1, 179, 1, 180, 1, 180, 1, 180, 1, 180, 5, 180, 5379, 8,
		180, 10, 180, 12, 180, 5382, 9, 180, 1, 181, 1, 181, 3, 181, 5386, 8, 181,
		1, 181, 3, 181, 5389, 8, 181, 1, 182, 1, 182, 1, 182, 5, 182, 5394, 8,
		182, 10, 182, 12, 182, 5397, 9, 182, 1, 183, 1, 183, 3, 183, 5401, 8, 183,
		1, 184, 1, 184, 1, 184, 1, 184, 1, 184, 1, 184, 1, 184, 1, 184, 4, 184,
		5411, 8, 184, 11, 184, 12, 184, 5412, 1, 184, 1, 184, 1, 184, 1, 184, 3,
		184, 5419, 8, 184, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185,
		1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185,
		1, 185, 1, 185, 1, 185, 1, 185, 3, 185, 5441, 8, 185, 1, 185, 1, 185, 3,
		185, 5445, 8, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185,
		1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 5, 185, 5459, 8, 185, 10, 185,
		12, 185, 5462, 9, 185, 1, 186, 1, 186, 1, 186, 1, 186, 5, 186, 5468, 8,
		186, 10, 186, 12, 186, 5471, 9, 186, 3, 186, 5473, 8, 186, 1, 186, 1, 186,
		1, 187, 1, 187, 1, 187, 3, 187, 5480, 8, 187, 1, 188, 3, 188, 5483, 8,
		188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 3, 188, 5491, 8, 188,
		1, 188, 1, 188, 1, 188, 3, 188, 5496, 8, 188, 1, 188, 1, 188, 1, 188, 3,
		188, 5501, 8, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 3, 188,
		5509, 8, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 5, 188, 5516, 8,
		188, 10, 188, 12, 188, 5519, 9, 188, 1, 188, 1, 188, 1, 188, 1, 188, 3,
		188, 5525, 8, 188, 1, 188, 1, 188, 1, 188, 3, 188, 5530, 8, 188, 1, 188,
		3, 188, 5533, 8, 188, 1, 189, 1, 189, 1, 189, 1, 189, 3, 189, 5539, 8,
		189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1,
		189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1,
		189, 1, 189, 5, 189, 5560, 8, 189, 10, 189, 12, 189, 5563, 9, 189, 1, 190,
		1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190,
		4, 190, 5575, 8, 190, 11, 190, 12, 190, 5576, 1, 190, 1, 190, 3, 190, 5581,
		8, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 4, 190, 5588, 8, 190, 11,
		190, 12, 190, 5589, 1, 190, 1, 190, 3, 190, 5594, 8, 190, 1, 190, 1, 190,
		1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190,
		1, 190, 1, 190, 5, 190, 5609, 8, 190, 10, 190, 12, 190, 5612, 9, 190, 1,
		190, 1, 190, 1, 190, 1, 190, 5, 190, 5618, 8, 190, 10, 190, 12, 190, 5621,
		9, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 5, 190, 5628, 8, 190, 10,
		190, 12, 190, 5631, 9, 190, 1, 190, 1, 190, 3, 190, 5635, 8, 190, 1, 190,
		1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190,
		1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190,
		1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 3, 190, 5663, 8,
		190, 1, 190, 1, 190, 3, 190, 5667, 8, 190, 1, 190, 1, 190, 1, 190, 1, 190,
		1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 3, 190, 5678, 8, 190, 1, 190, 1,
		190, 1, 190, 1, 190, 1, 190, 1, 190, 3, 190, 5686, 8, 190, 1, 190, 1, 190,
		1, 190, 3, 190, 5691, 8, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1,
		190, 1, 190, 1, 190, 1, 190, 1, 190, 3, 190, 5703, 8, 190, 1, 190, 1, 190,
		1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 3, 190,
		5715, 8, 190, 5, 190, 5717, 8, 190, 10, 190, 12, 190, 5720, 9, 190, 1,
		191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1,
		191, 3, 191, 5732, 8, 191, 1, 192, 1, 192, 1, 192, 3, 192, 5737, 8, 192,
		3, 192, 5739, 8, 192, 1, 193, 1, 193, 1, 193, 3, 193, 5744, 8, 193, 1,
		193, 1, 193, 1, 193, 5, 193, 5749, 8, 193, 10, 193, 12, 193, 5752, 9, 193,
		1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 5, 193, 5759, 8, 193, 10, 193,
		12, 193, 5762, 9, 193, 3, 193, 5764, 8, 193, 3, 193, 5766, 8, 193, 1, 193,
		1, 193, 1, 193, 3, 193, 5771, 8, 193, 1, 194, 1, 194, 1, 194, 3, 194, 5776,
		8, 194, 1, 194, 1, 194, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195,
		1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195,
		1, 195, 3, 195, 5796, 8, 195, 1, 196, 1, 196, 3, 196, 5800, 8, 196, 1,
		196, 3, 196, 5803, 8, 196, 1, 196, 3, 196, 5806, 8, 196, 1, 196, 1, 196,
		1, 197, 1, 197, 1, 197, 1, 197, 1, 197, 1, 197, 1, 197, 1, 197, 1, 197,
		3, 197, 5819, 8, 197, 1, 198, 1, 198, 1, 199, 1, 199, 1, 199, 1, 199, 1,
		199, 1, 199, 1, 199, 3, 199, 5830, 8, 199, 1, 200, 1, 200, 1, 200, 5, 200,
		5835, 8, 200, 10, 200, 12, 200, 5838, 9, 200, 1, 201, 3, 201, 5841, 8,
		201, 1, 201, 1, 201, 1, 201, 3, 201, 5846, 8, 201, 1, 201, 3, 201, 5849,
		8, 201, 1, 201, 1, 201, 3, 201, 5853, 8, 201, 1, 202, 1, 202, 1, 202, 1,
		202, 1, 202, 1, 202, 3, 202, 5861, 8, 202, 1, 202, 1, 202, 1, 202, 3, 202,
		5866, 8, 202, 1, 202, 1, 202, 5, 202, 5870, 8, 202, 10, 202, 12, 202, 5873,
		9, 202, 1, 202, 1, 202, 1, 202, 1, 202, 1, 202, 1, 202, 3, 202, 5881, 8,
		202, 1, 202, 1, 202, 1, 202, 1, 202, 1, 202, 5, 202, 5888, 8, 202, 10,
		202, 12, 202, 5891, 9, 202, 1, 202, 1, 202, 1, 202, 1, 202, 1, 202, 5,
		202, 5898, 8, 202, 10, 202, 12, 202, 5901, 9, 202, 1, 202, 1, 202, 1, 202,
		3, 202, 5906, 8, 202, 1, 203, 1, 203, 1, 204, 1, 204, 1, 205, 1, 205, 1,
		205, 1, 205, 1, 205, 1, 206, 1, 206, 1, 206, 1, 206, 1, 207, 1, 207, 1,
		208, 1, 208, 3, 208, 5925, 8, 208, 1, 208, 3, 208, 5928, 8, 208, 1, 209,
		1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209,
		1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209,
		1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 5, 209, 5954, 8, 209, 10, 209,
		12, 209, 5957, 9, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209,
		1, 209, 1, 209, 5, 209, 5967, 8, 209, 10, 209, 12, 209, 5970, 9, 209, 1,
		209, 3, 209, 5973, 8, 209, 3, 209, 5975, 8, 209, 1, 210, 1, 210, 1, 210,
		1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210,
		1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210,
		1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210,
		1, 210, 1, 210, 3, 210, 6009, 8, 210, 1, 211, 1, 211, 1, 211, 5, 211, 6014,
		8, 211, 10, 211, 12, 211, 6017, 9, 211, 1, 212, 1, 212, 1, 212, 1, 212,
		3, 212, 6023, 8, 212, 1, 213, 1, 213, 1, 213, 1, 214, 1, 214, 1, 214, 3,
		214, 6031, 8, 214, 1, 214, 1, 214, 1, 214, 3, 214, 6036, 8, 214, 1, 215,
		1, 215, 1, 215, 1, 215, 3, 215, 6042, 8, 215, 1, 216, 1, 216, 1, 216, 1,
		216, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 3, 216, 6054, 8, 216,
		1, 217, 1, 217, 1, 217, 1, 218, 1, 218, 4, 218, 6061, 8, 218, 11, 218,
		12, 218, 6062, 1, 218, 3, 218, 6066, 8, 218, 1, 219, 1, 219, 1, 220, 1,
		220, 1, 220, 3, 220, 6073, 8, 220, 1, 221, 1, 221, 1, 222, 3, 222, 6078,
		8, 222, 1, 222, 1, 222, 3, 222, 6082, 8, 222, 1, 222, 3, 222, 6085, 8,
		222, 1, 223, 1, 223, 1, 223, 2, 524, 531, 4, 226, 370, 378, 380, 224, 0,
		2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,
		40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
		76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108,
		110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138,
		140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168,
		170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198,
		200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228,
		230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258,
		260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288,
		290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318,
		320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348,
		350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378,
		380, 382, 384, 386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408,
		410, 412, 414, 416, 418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438,
		440, 442, 444, 446, 0, 60, 1, 0, 344, 345, 2, 0, 191, 191, 345, 345, 2,
		0, 35, 35, 188, 188, 2, 0, 32, 32, 531, 531, 3, 0, 18, 18, 146, 146, 466,
		466, 2, 0, 187, 187, 217, 217, 2, 0, 330, 330, 380, 380, 3, 0, 110, 110,
		374, 374, 452, 452, 2, 0, 111, 111, 398, 398, 3, 0, 195, 195, 262, 262,
		404, 404, 2, 0, 158, 158, 489, 489, 2, 0, 162, 162, 307, 307, 1, 0, 482,
		483, 2, 0, 112, 112, 399, 399, 2, 0, 80, 80, 175, 175, 2, 0, 219, 220,
		244, 245, 3, 0, 26, 26, 126, 126, 282, 282, 1, 0, 142, 143, 2, 0, 217,
		217, 451, 451, 2, 0, 18, 18, 437, 437, 3, 0, 46, 46, 231, 231, 297, 297,
		4, 0, 54, 54, 204, 204, 262, 262, 394, 394, 3, 0, 119, 119, 211, 211, 400,
		400, 1, 0, 11, 12, 2, 0, 308, 308, 497, 497, 2, 0, 526, 526, 531, 531,
		1, 0, 319, 320, 2, 0, 260, 260, 357, 357, 2, 0, 125, 125, 216, 216, 2,
		0, 32, 32, 85, 85, 5, 0, 145, 145, 198, 198, 334, 334, 454, 454, 484, 484,
		2, 0, 128, 129, 166, 166, 10, 0, 20, 20, 23, 23, 136, 136, 267, 267, 281,
		281, 310, 310, 318, 318, 331, 331, 384, 384, 409, 409, 3, 0, 161, 161,
		286, 286, 465, 465, 2, 0, 20, 20, 133, 133, 2, 0, 299, 299, 474, 474, 2,
		0, 29, 29, 128, 128, 2, 0, 178, 178, 249, 249, 4, 0, 280, 280, 302, 302,
		526, 526, 531, 531, 8, 0, 48, 48, 194, 194, 208, 208, 279, 279, 285, 285,
		351, 351, 371, 372, 431, 431, 1, 0, 236, 237, 2, 0, 24, 24, 514, 514, 3,
		0, 256, 256, 366, 366, 386, 386, 1, 0, 271, 277, 2, 0, 172, 172, 457, 457,
		2, 0, 507, 508, 512, 512, 2, 0, 138, 138, 509, 511, 1, 0, 507, 508, 2,
		0, 195, 195, 404, 404, 2, 0, 113, 113, 449, 449, 2, 0, 411, 411, 469, 469,
		1, 0, 225, 226, 2, 0, 357, 357, 393, 393, 2, 0, 181, 181, 341, 341, 4,
		0, 113, 113, 116, 116, 118, 118, 449, 449, 1, 0, 500, 506, 8, 0, 119, 119,
		211, 211, 287, 287, 289, 289, 355, 355, 400, 400, 490, 490, 499, 499, 2,
		0, 509, 509, 531, 531, 1, 0, 532, 533, 98, 0, 9, 10, 13, 13, 16, 19, 23,
		23, 27, 27, 30, 31, 33, 34, 36, 39, 42, 42, 45, 58, 60, 62, 66, 71, 73,
		74, 76, 78, 80, 92, 94, 98, 100, 101, 105, 110, 113, 122, 125, 125, 127,
		127, 130, 131, 134, 135, 139, 140, 144, 144, 147, 148, 150, 156, 158, 160,
		162, 162, 165, 165, 169, 169, 171, 171, 173, 178, 185, 186, 189, 189, 191,
		191, 193, 195, 198, 198, 200, 202, 204, 206, 208, 213, 215, 216, 218, 218,
		220, 220, 231, 233, 235, 240, 242, 243, 247, 247, 249, 249, 251, 252, 254,
		255, 258, 259, 262, 267, 269, 270, 272, 279, 281, 285, 287, 292, 294, 298,
		300, 300, 303, 303, 305, 306, 308, 310, 317, 318, 320, 332, 334, 334, 336,
		340, 344, 344, 346, 356, 361, 364, 370, 373, 375, 382, 384, 384, 386, 386,
		389, 391, 394, 398, 400, 400, 403, 405, 408, 409, 412, 412, 414, 417, 419,
		431, 437, 437, 441, 443, 445, 446, 448, 449, 452, 452, 454, 455, 458, 459,
		461, 461, 463, 463, 467, 468, 470, 470, 473, 473, 476, 476, 478, 490, 495,
		495, 499, 499, 521, 523, 7194, 0, 451, 1, 0, 0, 0, 2, 479, 1, 0, 0, 0,
		4, 567, 1, 0, 0, 0, 6, 595, 1, 0, 0, 0, 8, 614, 1, 0, 0, 0, 10, 755, 1,
		0, 0, 0, 12, 813, 1, 0, 0, 0, 14, 834, 1, 0, 0, 0, 16, 951, 1, 0, 0, 0,
		18, 1179, 1, 0, 0, 0, 20, 1319, 1, 0, 0, 0, 22, 1409, 1, 0, 0, 0, 24, 1708,
		1, 0, 0, 0, 26, 1712, 1, 0, 0, 0, 28, 1714, 1, 0, 0, 0, 30, 1820, 1, 0,
		0, 0, 32, 1822, 1, 0, 0, 0, 34, 1828, 1, 0, 0, 0, 36, 2247, 1, 0, 0, 0,
		38, 2249, 1, 0, 0, 0, 40, 2381, 1, 0, 0, 0, 42, 2393, 1, 0, 0, 0, 44, 2395,
		1, 0, 0, 0, 46, 2399, 1, 0, 0, 0, 48, 2403, 1, 0, 0, 0, 50, 2406, 1, 0,
		0, 0, 52, 2410, 1, 0, 0, 0, 54, 2435, 1, 0, 0, 0, 56, 2437, 1, 0, 0, 0,
		58, 2445, 1, 0, 0, 0, 60, 2470, 1, 0, 0, 0, 62, 2482, 1, 0, 0, 0, 64, 2484,
		1, 0, 0, 0, 66, 2504, 1, 0, 0, 0, 68, 2531, 1, 0, 0, 0, 70, 2596, 1, 0,
		0, 0, 72, 2702, 1, 0, 0, 0, 74, 2737, 1, 0, 0, 0, 76, 2799, 1, 0, 0, 0,
		78, 2801, 1, 0, 0, 0, 80, 2825, 1, 0, 0, 0, 82, 2869, 1, 0, 0, 0, 84, 2955,
		1, 0, 0, 0, 86, 2962, 1, 0, 0, 0, 88, 2964, 1, 0, 0, 0, 90, 3048, 1, 0,
		0, 0, 92, 3148, 1, 0, 0, 0, 94, 3150, 1, 0, 0, 0, 96, 3154, 1, 0, 0, 0,
		98, 3387, 1, 0, 0, 0, 100, 3392, 1, 0, 0, 0, 102, 3394, 1, 0, 0, 0, 104,
		3397, 1, 0, 0, 0, 106, 3475, 1, 0, 0, 0, 108, 3631, 1, 0, 0, 0, 110, 3651,
		1, 0, 0, 0, 112, 3853, 1, 0, 0, 0, 114, 3855, 1, 0, 0, 0, 116, 3869, 1,
		0, 0, 0, 118, 3871, 1, 0, 0, 0, 120, 3879, 1, 0, 0, 0, 122, 3885, 1, 0,
		0, 0, 124, 3900, 1, 0, 0, 0, 126, 3936, 1, 0, 0, 0, 128, 3946, 1, 0, 0,
		0, 130, 3994, 1, 0, 0, 0, 132, 3996, 1, 0, 0, 0, 134, 4048, 1, 0, 0, 0,
		136, 4068, 1, 0, 0, 0, 138, 4070, 1, 0, 0, 0, 140, 4073, 1, 0, 0, 0, 142,
		4097, 1, 0, 0, 0, 144, 4108, 1, 0, 0, 0, 146, 4110, 1, 0, 0, 0, 148, 4154,
		1, 0, 0, 0, 150, 4156, 1, 0, 0, 0, 152, 4174, 1, 0, 0, 0, 154, 4195, 1,
		0, 0, 0, 156, 4209, 1, 0, 0, 0, 158, 4225, 1, 0, 0, 0, 160, 4228, 1, 0,
		0, 0, 162, 4242, 1, 0, 0, 0, 164, 4255, 1, 0, 0, 0, 166, 4356, 1, 0, 0,
		0, 168, 4358, 1, 0, 0, 0, 170, 4368, 1, 0, 0, 0, 172, 4370, 1, 0, 0, 0,
		174, 4377, 1, 0, 0, 0, 176, 4381, 1, 0, 0, 0, 178, 4385, 1, 0, 0, 0, 180,
		4390, 1, 0, 0, 0, 182, 4392, 1, 0, 0, 0, 184, 4402, 1, 0, 0, 0, 186, 4404,
		1, 0, 0, 0, 188, 4415, 1, 0, 0, 0, 190, 4424, 1, 0, 0, 0, 192, 4434, 1,
		0, 0, 0, 194, 4436, 1, 0, 0, 0, 196, 4438, 1, 0, 0, 0, 198, 4446, 1, 0,
		0, 0, 200, 4448, 1, 0, 0, 0, 202, 4450, 1, 0, 0, 0, 204, 4454, 1, 0, 0,
		0, 206, 4458, 1, 0, 0, 0, 208, 4462, 1, 0, 0, 0, 210, 4468, 1, 0, 0, 0,
		212, 4480, 1, 0, 0, 0, 214, 4512, 1, 0, 0, 0, 216, 4514, 1, 0, 0, 0, 218,
		4523, 1, 0, 0, 0, 220, 4566, 1, 0, 0, 0, 222, 4568, 1, 0, 0, 0, 224, 4580,
		1, 0, 0, 0, 226, 4585, 1, 0, 0, 0, 228, 4605, 1, 0, 0, 0, 230, 4613, 1,
		0, 0, 0, 232, 4615, 1, 0, 0, 0, 234, 4637, 1, 0, 0, 0, 236, 4646, 1, 0,
		0, 0, 238, 4655, 1, 0, 0, 0, 240, 4666, 1, 0, 0, 0, 242, 4672, 1, 0, 0,
		0, 244, 4674, 1, 0, 0, 0, 246, 4677, 1, 0, 0, 0, 248, 4681, 1, 0, 0, 0,
		250, 4698, 1, 0, 0, 0, 252, 4701, 1, 0, 0, 0, 254, 4706, 1, 0, 0, 0, 256,
		4714, 1, 0, 0, 0, 258, 4721, 1, 0, 0, 0, 260, 4738, 1, 0, 0, 0, 262, 4762,
		1, 0, 0, 0, 264, 4764, 1, 0, 0, 0, 266, 4815, 1, 0, 0, 0, 268, 4817, 1,
		0, 0, 0, 270, 4830, 1, 0, 0, 0, 272, 4833, 1, 0, 0, 0, 274, 4836, 1, 0,
		0, 0, 276, 4878, 1, 0, 0, 0, 278, 4889, 1, 0, 0, 0, 280, 4891, 1, 0, 0,
		0, 282, 4897, 1, 0, 0, 0, 284, 4905, 1, 0, 0, 0, 286, 4931, 1, 0, 0, 0,
		288, 4936, 1, 0, 0, 0, 290, 4946, 1, 0, 0, 0, 292, 4964, 1, 0, 0, 0, 294,
		4966, 1, 0, 0, 0, 296, 5000, 1, 0, 0, 0, 298, 5006, 1, 0, 0, 0, 300, 5008,
		1, 0, 0, 0, 302, 5012, 1, 0, 0, 0, 304, 5020, 1, 0, 0, 0, 306, 5079, 1,
		0, 0, 0, 308, 5081, 1, 0, 0, 0, 310, 5084, 1, 0, 0, 0, 312, 5089, 1, 0,
		0, 0, 314, 5097, 1, 0, 0, 0, 316, 5103, 1, 0, 0, 0, 318, 5107, 1, 0, 0,
		0, 320, 5116, 1, 0, 0, 0, 322, 5118, 1, 0, 0, 0, 324, 5126, 1, 0, 0, 0,
		326, 5134, 1, 0, 0, 0, 328, 5139, 1, 0, 0, 0, 330, 5147, 1, 0, 0, 0, 332,
		5216, 1, 0, 0, 0, 334, 5224, 1, 0, 0, 0, 336, 5247, 1, 0, 0, 0, 338, 5259,
		1, 0, 0, 0, 340, 5267, 1, 0, 0, 0, 342, 5281, 1, 0, 0, 0, 344, 5295, 1,
		0, 0, 0, 346, 5304, 1, 0, 0, 0, 348, 5329, 1, 0, 0, 0, 350, 5340, 1, 0,
		0, 0, 352, 5342, 1, 0, 0, 0, 354, 5350, 1, 0, 0, 0, 356, 5360, 1, 0, 0,
		0, 358, 5362, 1, 0, 0, 0, 360, 5374, 1, 0, 0, 0, 362, 5383, 1, 0, 0, 0,
		364, 5390, 1, 0, 0, 0, 366, 5400, 1, 0, 0, 0, 368, 5418, 1, 0, 0, 0, 370,
		5444, 1, 0, 0, 0, 372, 5463, 1, 0, 0, 0, 374, 5479, 1, 0, 0, 0, 376, 5532,
		1, 0, 0, 0, 378, 5538, 1, 0, 0, 0, 380, 5690, 1, 0, 0, 0, 382, 5731, 1,
		0, 0, 0, 384, 5738, 1, 0, 0, 0, 386, 5740, 1, 0, 0, 0, 388, 5775, 1, 0,
		0, 0, 390, 5795, 1, 0, 0, 0, 392, 5797, 1, 0, 0, 0, 394, 5818, 1, 0, 0,
		0, 396, 5820, 1, 0, 0, 0, 398, 5829, 1, 0, 0, 0, 400, 5831, 1, 0, 0, 0,
		402, 5852, 1, 0, 0, 0, 404, 5905, 1, 0, 0, 0, 406, 5907, 1, 0, 0, 0, 408,
		5909, 1, 0, 0, 0, 410, 5911, 1, 0, 0, 0, 412, 5916, 1, 0, 0, 0, 414, 5920,
		1, 0, 0, 0, 416, 5922, 1, 0, 0, 0, 418, 5974, 1, 0, 0, 0, 420, 6008, 1,
		0, 0, 0, 422, 6010, 1, 0, 0, 0, 424, 6018, 1, 0, 0, 0, 426, 6024, 1, 0,
		0, 0, 428, 6027, 1, 0, 0, 0, 430, 6041, 1, 0, 0, 0, 432, 6053, 1, 0, 0,
		0, 434, 6055, 1, 0, 0, 0, 436, 6065, 1, 0, 0, 0, 438, 6067, 1, 0, 0, 0,
		440, 6072, 1, 0, 0, 0, 442, 6074, 1, 0, 0, 0, 444, 6084, 1, 0, 0, 0, 446,
		6086, 1, 0, 0, 0, 448, 450, 5, 1, 0, 0, 449, 448, 1, 0, 0, 0, 450, 453,
		1, 0, 0, 0, 451, 449, 1, 0, 0, 0, 451, 452, 1, 0, 0, 0, 452, 455, 1, 0,
		0, 0, 453, 451, 1, 0, 0, 0, 454, 456, 3, 4, 2, 0, 455, 454, 1, 0, 0, 0,
		455, 456, 1, 0, 0, 0, 456, 465, 1, 0, 0, 0, 457, 459, 5, 1, 0, 0, 458,
		457, 1, 0, 0, 0, 459, 460, 1, 0, 0, 0, 460, 458, 1, 0, 0, 0, 460, 461,
		1, 0, 0, 0, 461, 462, 1, 0, 0, 0, 462, 464, 3, 4, 2, 0, 463, 458, 1, 0,
		0, 0, 464, 467, 1, 0, 0, 0, 465, 463, 1, 0, 0, 0, 465, 466, 1, 0, 0, 0,
		466, 471, 1, 0, 0, 0, 467, 465, 1, 0, 0, 0, 468, 470, 5, 1, 0, 0, 469,
		468, 1, 0, 0, 0, 470, 473, 1, 0, 0, 0, 471, 469, 1, 0, 0, 0, 471, 472,
		1, 0, 0, 0, 472, 474, 1, 0, 0, 0, 473, 471, 1, 0, 0, 0, 474, 475, 5, 0,
		0, 1, 475, 1, 1, 0, 0, 0, 476, 478, 5, 1, 0, 0, 477, 476, 1, 0, 0, 0, 478,
		481, 1, 0, 0, 0, 479, 477, 1, 0, 0, 0, 479, 480, 1, 0, 0, 0, 480, 483,
		1, 0, 0, 0, 481, 479, 1, 0, 0, 0, 482, 484, 3, 4, 2, 0, 483, 482, 1, 0,
		0, 0, 483, 484, 1, 0, 0, 0, 484, 488, 1, 0, 0, 0, 485, 487, 5, 1, 0, 0,
		486, 485, 1, 0, 0, 0, 487, 490, 1, 0, 0, 0, 488, 486, 1, 0, 0, 0, 488,
		489, 1, 0, 0, 0, 489, 491, 1, 0, 0, 0, 490, 488, 1, 0, 0, 0, 491, 492,
		5, 0, 0, 1, 492, 3, 1, 0, 0, 0, 493, 568, 3, 6, 3, 0, 494, 495, 5, 62,
		0, 0, 495, 496, 3, 322, 161, 0, 496, 505, 5, 2, 0, 0, 497, 502, 3, 366,
		183, 0, 498, 499, 5, 4, 0, 0, 499, 501, 3, 366, 183, 0, 500, 498, 1, 0,
		0, 0, 501, 504, 1, 0, 0, 0, 502, 500, 1, 0, 0, 0, 502, 503, 1, 0, 0, 0,
		503, 506, 1, 0, 0, 0, 504, 502, 1, 0, 0, 0, 505, 497, 1, 0, 0, 0, 505,
		506, 1, 0, 0, 0, 506, 507, 1, 0, 0, 0, 507, 508, 5, 3, 0, 0, 508, 568,
		1, 0, 0, 0, 509, 517, 5, 21, 0, 0, 510, 513, 5, 99, 0, 0, 511, 512, 5,
		311, 0, 0, 512, 514, 5, 371, 0, 0, 513, 511, 1, 0, 0, 0, 513, 514, 1, 0,
		0, 0, 514, 517, 1, 0, 0, 0, 515, 517, 5, 371, 0, 0, 516, 509, 1, 0, 0,
		0, 516, 510, 1, 0, 0, 0, 516, 515, 1, 0, 0, 0, 517, 518, 1, 0, 0, 0, 518,
		519, 7, 0, 0, 0, 519, 520, 3, 322, 161, 0, 520, 524, 5, 2, 0, 0, 521, 523,
		9, 0, 0, 0, 522, 521, 1, 0, 0, 0, 523, 526, 1, 0, 0, 0, 524, 525, 1, 0,
		0, 0, 524, 522, 1, 0, 0, 0, 525, 527, 1, 0, 0, 0, 526, 524, 1, 0, 0, 0,
		527, 531, 5, 3, 0, 0, 528, 530, 9, 0, 0, 0, 529, 528, 1, 0, 0, 0, 530,
		533, 1, 0, 0, 0, 531, 532, 1, 0, 0, 0, 531, 529, 1, 0, 0, 0, 532, 568,
		1, 0, 0, 0, 533, 531, 1, 0, 0, 0, 534, 535, 5, 142, 0, 0, 535, 538, 7,
		0, 0, 0, 536, 537, 5, 214, 0, 0, 537, 539, 5, 164, 0, 0, 538, 536, 1, 0,
		0, 0, 538, 539, 1, 0, 0, 0, 539, 540, 1, 0, 0, 0, 540, 568, 3, 322, 161,
		0, 541, 542, 5, 410, 0, 0, 542, 543, 7, 1, 0, 0, 543, 547, 5, 424, 0, 0,
		544, 545, 5, 256, 0, 0, 545, 548, 3, 378, 189, 0, 546, 548, 3, 244, 122,
		0, 547, 544, 1, 0, 0, 0, 547, 546, 1, 0, 0, 0, 547, 548, 1, 0, 0, 0, 548,
		568, 1, 0, 0, 0, 549, 550, 5, 410, 0, 0, 550, 551, 5, 99, 0, 0, 551, 552,
		5, 345, 0, 0, 552, 568, 3, 322, 161, 0, 553, 555, 5, 15, 0, 0, 554, 553,
		1, 0, 0, 0, 554, 555, 1, 0, 0, 0, 555, 556, 1, 0, 0, 0, 556, 557, 5, 410,
		0, 0, 557, 558, 7, 2, 0, 0, 558, 561, 5, 89, 0, 0, 559, 560, 5, 256, 0,
		0, 560, 562, 3, 378, 189, 0, 561, 559, 1, 0, 0, 0, 561, 562, 1, 0, 0, 0,
		562, 565, 1, 0, 0, 0, 563, 564, 5, 187, 0, 0, 564, 566, 5, 531, 0, 0, 565,
		563, 1, 0, 0, 0, 565, 566, 1, 0, 0, 0, 566, 568, 1, 0, 0, 0, 567, 493,
		1, 0, 0, 0, 567, 494, 1, 0, 0, 0, 567, 516, 1, 0, 0, 0, 567, 534, 1, 0,
		0, 0, 567, 541, 1, 0, 0, 0, 567, 549, 1, 0, 0, 0, 567, 554, 1, 0, 0, 0,
		568, 5, 1, 0, 0, 0, 569, 571, 3, 190, 95, 0, 570, 569, 1, 0, 0, 0, 570,
		571, 1, 0, 0, 0, 571, 572, 1, 0, 0, 0, 572, 574, 3, 224, 112, 0, 573, 575,
		3, 222, 111, 0, 574, 573, 1, 0, 0, 0, 574, 575, 1, 0, 0, 0, 575, 596, 1,
		0, 0, 0, 576, 596, 3, 16, 8, 0, 577, 596, 3, 18, 9, 0, 578, 596, 3, 20,
		10, 0, 579, 596, 3, 10, 5, 0, 580, 596, 3, 12, 6, 0, 581, 596, 3, 14, 7,
		0, 582, 596, 3, 62, 31, 0, 583, 596, 3, 22, 11, 0, 584, 596, 3, 130, 65,
		0, 585, 596, 3, 142, 71, 0, 586, 596, 3, 60, 30, 0, 587, 596, 3, 24, 12,
		0, 588, 596, 3, 26, 13, 0, 589, 596, 3, 68, 34, 0, 590, 596, 3, 74, 37,
		0, 591, 596, 3, 72, 36, 0, 592, 596, 3, 144, 72, 0, 593, 596, 3, 28, 14,
		0, 594, 596, 3, 8, 4, 0, 595, 570, 1, 0, 0, 0, 595, 576, 1, 0, 0, 0, 595,
		577, 1, 0, 0, 0, 595, 578, 1, 0, 0, 0, 595, 579, 1, 0, 0, 0, 595, 580,
		1, 0, 0, 0, 595, 581, 1, 0, 0, 0, 595, 582, 1, 0, 0, 0, 595, 583, 1, 0,
		0, 0, 595, 584, 1, 0, 0, 0, 595, 585, 1, 0, 0, 0, 595, 586, 1, 0, 0, 0,
		595, 587, 1, 0, 0, 0, 595, 588, 1, 0, 0, 0, 595, 589, 1, 0, 0, 0, 595,
		590, 1, 0, 0, 0, 595, 591, 1, 0, 0, 0, 595, 592, 1, 0, 0, 0, 595, 593,
		1, 0, 0, 0, 595, 594, 1, 0, 0, 0, 596, 7, 1, 0, 0, 0, 597, 615, 3, 146,
		73, 0, 598, 615, 3, 148, 74, 0, 599, 615, 3, 152, 76, 0, 600, 615, 3, 154,
		77, 0, 601, 615, 3, 112, 56, 0, 602, 615, 3, 106, 53, 0, 603, 615, 3, 108,
		54, 0, 604, 615, 3, 90, 45, 0, 605, 615, 3, 84, 42, 0, 606, 615, 3, 76,
		38, 0, 607, 615, 3, 82, 41, 0, 608, 615, 3, 70, 35, 0, 609, 615, 3, 66,
		33, 0, 610, 615, 3, 64, 32, 0, 611, 615, 3, 40, 20, 0, 612, 615, 3, 36,
		18, 0, 613, 615, 3, 30, 15, 0, 614, 597, 1, 0, 0, 0, 614, 598, 1, 0, 0,
		0, 614, 599, 1, 0, 0, 0, 614, 600, 1, 0, 0, 0, 614, 601, 1, 0, 0, 0, 614,
		602, 1, 0, 0, 0, 614, 603, 1, 0, 0, 0, 614, 604, 1, 0, 0, 0, 614, 605,
		1, 0, 0, 0, 614, 606, 1, 0, 0, 0, 614, 607, 1, 0, 0, 0, 614, 608, 1, 0,
		0, 0, 614, 609, 1, 0, 0, 0, 614, 610, 1, 0, 0, 0, 614, 611, 1, 0, 0, 0,
		614, 612, 1, 0, 0, 0, 614, 613, 1, 0, 0, 0, 615, 9, 1, 0, 0, 0, 616, 617,
		5, 99, 0, 0, 617, 618, 5, 278, 0, 0, 618, 622, 5, 486, 0, 0, 619, 620,
		5, 214, 0, 0, 620, 621, 5, 301, 0, 0, 621, 623, 5, 164, 0, 0, 622, 619,
		1, 0, 0, 0, 622, 623, 1, 0, 0, 0, 623, 624, 1, 0, 0, 0, 624, 629, 3, 322,
		161, 0, 625, 626, 5, 2, 0, 0, 626, 627, 3, 324, 162, 0, 627, 628, 5, 3,
		0, 0, 628, 630, 1, 0, 0, 0, 629, 625, 1, 0, 0, 0, 629, 630, 1, 0, 0, 0,
		630, 632, 1, 0, 0, 0, 631, 633, 3, 168, 84, 0, 632, 631, 1, 0, 0, 0, 632,
		633, 1, 0, 0, 0, 633, 641, 1, 0, 0, 0, 634, 636, 5, 364, 0, 0, 635, 637,
		3, 174, 87, 0, 636, 635, 1, 0, 0, 0, 636, 637, 1, 0, 0, 0, 637, 639, 1,
		0, 0, 0, 638, 640, 3, 170, 85, 0, 639, 638, 1, 0, 0, 0, 639, 640, 1, 0,
		0, 0, 640, 642, 1, 0, 0, 0, 641, 634, 1, 0, 0, 0, 641, 642, 1, 0, 0, 0,
		642, 648, 1, 0, 0, 0, 643, 645, 5, 146, 0, 0, 644, 643, 1, 0, 0, 0, 644,
		645, 1, 0, 0, 0, 645, 646, 1, 0, 0, 0, 646, 647, 5, 244, 0, 0, 647, 649,
		3, 300, 150, 0, 648, 644, 1, 0, 0, 0, 648, 649, 1, 0, 0, 0, 649, 652, 1,
		0, 0, 0, 650, 651, 5, 81, 0, 0, 651, 653, 5, 526, 0, 0, 652, 650, 1, 0,
		0, 0, 652, 653, 1, 0, 0, 0, 653, 660, 1, 0, 0, 0, 654, 655, 5, 319, 0,
		0, 655, 656, 5, 59, 0, 0, 656, 657, 5, 2, 0, 0, 657, 658, 3, 176, 88, 0,
		658, 659, 5, 3, 0, 0, 659, 661, 1, 0, 0, 0, 660, 654, 1, 0, 0, 0, 660,
		661, 1, 0, 0, 0, 661, 673, 1, 0, 0, 0, 662, 663, 5, 136, 0, 0, 663, 667,
		5, 59, 0, 0, 664, 665, 5, 202, 0, 0, 665, 668, 3, 300, 150, 0, 666, 668,
		5, 356, 0, 0, 667, 664, 1, 0, 0, 0, 667, 666, 1, 0, 0, 0, 668, 671, 1,
		0, 0, 0, 669, 670, 5, 55, 0, 0, 670, 672, 7, 3, 0, 0, 671, 669, 1, 0, 0,
		0, 671, 672, 1, 0, 0, 0, 672, 674, 1, 0, 0, 0, 673, 662, 1, 0, 0, 0, 673,
		674, 1, 0, 0, 0, 674, 676, 1, 0, 0, 0, 675, 677, 3, 310, 155, 0, 676, 675,
		1, 0, 0, 0, 676, 677, 1, 0, 0, 0, 677, 678, 1, 0, 0, 0, 678, 679, 5, 28,
		0, 0, 679, 680, 3, 224, 112, 0, 680, 756, 1, 0, 0, 0, 681, 682, 5, 364,
		0, 0, 682, 683, 5, 278, 0, 0, 683, 684, 5, 486, 0, 0, 684, 688, 3, 322,
		161, 0, 685, 689, 3, 158, 79, 0, 686, 689, 5, 85, 0, 0, 687, 689, 5, 32,
		0, 0, 688, 685, 1, 0, 0, 0, 688, 686, 1, 0, 0, 0, 688, 687, 1, 0, 0, 0,
		689, 756, 1, 0, 0, 0, 690, 691, 5, 21, 0, 0, 691, 692, 5, 278, 0, 0, 692,
		693, 5, 486, 0, 0, 693, 717, 3, 322, 161, 0, 694, 695, 5, 368, 0, 0, 695,
		718, 3, 438, 219, 0, 696, 702, 5, 364, 0, 0, 697, 703, 3, 174, 87, 0, 698,
		703, 3, 170, 85, 0, 699, 700, 3, 174, 87, 0, 700, 701, 3, 170, 85, 0, 701,
		703, 1, 0, 0, 0, 702, 697, 1, 0, 0, 0, 702, 698, 1, 0, 0, 0, 702, 699,
		1, 0, 0, 0, 703, 718, 1, 0, 0, 0, 704, 705, 5, 371, 0, 0, 705, 706, 5,
		494, 0, 0, 706, 707, 5, 278, 0, 0, 707, 708, 5, 486, 0, 0, 708, 710, 3,
		438, 219, 0, 709, 711, 3, 310, 155, 0, 710, 709, 1, 0, 0, 0, 710, 711,
		1, 0, 0, 0, 711, 718, 1, 0, 0, 0, 712, 713, 5, 406, 0, 0, 713, 714, 5,
		2, 0, 0, 714, 715, 3, 312, 156, 0, 715, 716, 5, 3, 0, 0, 716, 718, 1, 0,
		0, 0, 717, 694, 1, 0, 0, 0, 717, 696, 1, 0, 0, 0, 717, 704, 1, 0, 0, 0,
		717, 712, 1, 0, 0, 0, 718, 756, 1, 0, 0, 0, 719, 720, 5, 142, 0, 0, 720,
		721, 5, 278, 0, 0, 721, 724, 5, 486, 0, 0, 722, 723, 5, 214, 0, 0, 723,
		725, 5, 164, 0, 0, 724, 722, 1, 0, 0, 0, 724, 725, 1, 0, 0, 0, 725, 726,
		1, 0, 0, 0, 726, 729, 3, 322, 161, 0, 727, 728, 5, 307, 0, 0, 728, 730,
		3, 322, 161, 0, 729, 727, 1, 0, 0, 0, 729, 730, 1, 0, 0, 0, 730, 756, 1,
		0, 0, 0, 731, 732, 5, 327, 0, 0, 732, 733, 5, 278, 0, 0, 733, 734, 5, 486,
		0, 0, 734, 735, 5, 239, 0, 0, 735, 736, 5, 307, 0, 0, 736, 756, 3, 322,
		161, 0, 737, 738, 5, 381, 0, 0, 738, 739, 5, 278, 0, 0, 739, 740, 5, 486,
		0, 0, 740, 741, 5, 239, 0, 0, 741, 742, 5, 307, 0, 0, 742, 756, 3, 322,
		161, 0, 743, 744, 5, 63, 0, 0, 744, 745, 5, 278, 0, 0, 745, 746, 5, 486,
		0, 0, 746, 747, 5, 441, 0, 0, 747, 748, 5, 531, 0, 0, 748, 749, 5, 307,
		0, 0, 749, 756, 3, 322, 161, 0, 750, 751, 5, 410, 0, 0, 751, 752, 5, 99,
		0, 0, 752, 753, 5, 278, 0, 0, 753, 754, 5, 486, 0, 0, 754, 756, 3, 322,
		161, 0, 755, 616, 1, 0, 0, 0, 755, 681, 1, 0, 0, 0, 755, 690, 1, 0, 0,
		0, 755, 719, 1, 0, 0, 0, 755, 731, 1, 0, 0, 0, 755, 737, 1, 0, 0, 0, 755,
		743, 1, 0, 0, 0, 755, 750, 1, 0, 0, 0, 756, 11, 1, 0, 0, 0, 757, 758, 5,
		99, 0, 0, 758, 759, 5, 239, 0, 0, 759, 760, 3, 322, 161, 0, 760, 761, 5,
		307, 0, 0, 761, 781, 5, 396, 0, 0, 762, 763, 5, 160, 0, 0, 763, 764, 5,
		531, 0, 0, 764, 770, 3, 438, 219, 0, 765, 768, 5, 422, 0, 0, 766, 769,
		5, 526, 0, 0, 767, 769, 5, 108, 0, 0, 768, 766, 1, 0, 0, 0, 768, 767, 1,
		0, 0, 0, 769, 771, 1, 0, 0, 0, 770, 765, 1, 0, 0, 0, 770, 771, 1, 0, 0,
		0, 771, 774, 1, 0, 0, 0, 772, 773, 5, 154, 0, 0, 773, 775, 5, 526, 0, 0,
		774, 772, 1, 0, 0, 0, 774, 775, 1, 0, 0, 0, 775, 782, 1, 0, 0, 0, 776,
		779, 5, 30, 0, 0, 777, 780, 5, 526, 0, 0, 778, 780, 5, 108, 0, 0, 779,
		777, 1, 0, 0, 0, 779, 778, 1, 0, 0, 0, 780, 782, 1, 0, 0, 0, 781, 762,
		1, 0, 0, 0, 781, 776, 1, 0, 0, 0, 782, 784, 1, 0, 0, 0, 783, 785, 3, 426,
		213, 0, 784, 783, 1, 0, 0, 0, 784, 785, 1, 0, 0, 0, 785, 786, 1, 0, 0,
		0, 786, 787, 5, 139, 0, 0, 787, 788, 3, 16, 8, 0, 788, 814, 1, 0, 0, 0,
		789, 790, 5, 327, 0, 0, 790, 792, 5, 239, 0, 0, 791, 793, 3, 80, 40, 0,
		792, 791, 1, 0, 0, 0, 792, 793, 1, 0, 0, 0, 793, 814, 1, 0, 0, 0, 794,
		795, 5, 142, 0, 0, 795, 798, 5, 239, 0, 0, 796, 797, 5, 214, 0, 0, 797,
		799, 5, 164, 0, 0, 798, 796, 1, 0, 0, 0, 798, 799, 1, 0, 0, 0, 799, 801,
		1, 0, 0, 0, 800, 802, 3, 80, 40, 0, 801, 800, 1, 0, 0, 0, 801, 802, 1,
		0, 0, 0, 802, 814, 1, 0, 0, 0, 803, 804, 5, 381, 0, 0, 804, 806, 5, 239,
		0, 0, 805, 807, 3, 80, 40, 0, 806, 805, 1, 0, 0, 0, 806, 807, 1, 0, 0,
		0, 807, 814, 1, 0, 0, 0, 808, 809, 5, 63, 0, 0, 809, 811, 5, 441, 0, 0,
		810, 812, 3, 80, 40, 0, 811, 810, 1, 0, 0, 0, 811, 812, 1, 0, 0, 0, 812,
		814, 1, 0, 0, 0, 813, 757, 1, 0, 0, 0, 813, 789, 1, 0, 0, 0, 813, 794,
		1, 0, 0, 0, 813, 803, 1, 0, 0, 0, 813, 808, 1, 0, 0, 0, 814, 13, 1, 0,
		0, 0, 815, 816, 5, 21, 0, 0, 816, 817, 5, 436, 0, 0, 817, 818, 3, 322,
		161, 0, 818, 819, 5, 14, 0, 0, 819, 820, 5, 93, 0, 0, 820, 821, 3, 434,
		217, 0, 821, 822, 3, 156, 78, 0, 822, 835, 1, 0, 0, 0, 823, 824, 5, 21,
		0, 0, 824, 825, 5, 436, 0, 0, 825, 826, 3, 322, 161, 0, 826, 827, 5, 142,
		0, 0, 827, 828, 5, 93, 0, 0, 828, 829, 3, 434, 217, 0, 829, 835, 1, 0,
		0, 0, 830, 831, 5, 410, 0, 0, 831, 832, 5, 94, 0, 0, 832, 833, 5, 187,
		0, 0, 833, 835, 3, 322, 161, 0, 834, 815, 1, 0, 0, 0, 834, 823, 1, 0, 0,
		0, 834, 830, 1, 0, 0, 0, 835, 15, 1, 0, 0, 0, 836, 838, 3, 190, 95, 0,
		837, 836, 1, 0, 0, 0, 837, 838, 1, 0, 0, 0, 838, 840, 1, 0, 0, 0, 839,
		841, 3, 234, 117, 0, 840, 839, 1, 0, 0, 0, 840, 841, 1, 0, 0, 0, 841, 842,
		1, 0, 0, 0, 842, 846, 5, 223, 0, 0, 843, 847, 5, 230, 0, 0, 844, 845, 5,
		316, 0, 0, 845, 847, 5, 436, 0, 0, 846, 843, 1, 0, 0, 0, 846, 844, 1, 0,
		0, 0, 847, 853, 1, 0, 0, 0, 848, 854, 3, 322, 161, 0, 849, 850, 5, 140,
		0, 0, 850, 851, 5, 2, 0, 0, 851, 852, 5, 531, 0, 0, 852, 854, 5, 3, 0,
		0, 853, 848, 1, 0, 0, 0, 853, 849, 1, 0, 0, 0, 854, 856, 1, 0, 0, 0, 855,
		857, 3, 158, 79, 0, 856, 855, 1, 0, 0, 0, 856, 857, 1, 0, 0, 0, 857, 861,
		1, 0, 0, 0, 858, 859, 5, 494, 0, 0, 859, 860, 5, 247, 0, 0, 860, 862, 3,
		438, 219, 0, 861, 858, 1, 0, 0, 0, 861, 862, 1, 0, 0, 0, 862, 864, 1, 0,
		0, 0, 863, 865, 3, 300, 150, 0, 864, 863, 1, 0, 0, 0, 864, 865, 1, 0, 0,
		0, 865, 870, 1, 0, 0, 0, 866, 867, 5, 7, 0, 0, 867, 868, 3, 302, 151, 0,
		868, 869, 5, 8, 0, 0, 869, 871, 1, 0, 0, 0, 870, 866, 1, 0, 0, 0, 870,
		871, 1, 0, 0, 0, 871, 872, 1, 0, 0, 0, 872, 952, 3, 224, 112, 0, 873, 875,
		3, 190, 95, 0, 874, 873, 1, 0, 0, 0, 874, 875, 1, 0, 0, 0, 875, 877, 1,
		0, 0, 0, 876, 878, 3, 234, 117, 0, 877, 876, 1, 0, 0, 0, 877, 878, 1, 0,
		0, 0, 878, 879, 1, 0, 0, 0, 879, 880, 5, 471, 0, 0, 880, 881, 3, 322, 161,
		0, 881, 882, 3, 320, 160, 0, 882, 883, 5, 406, 0, 0, 883, 885, 3, 282,
		141, 0, 884, 886, 3, 246, 123, 0, 885, 884, 1, 0, 0, 0, 885, 886, 1, 0,
		0, 0, 886, 888, 1, 0, 0, 0, 887, 889, 3, 244, 122, 0, 888, 887, 1, 0, 0,
		0, 888, 889, 1, 0, 0, 0, 889, 952, 1, 0, 0, 0, 890, 892, 3, 190, 95, 0,
		891, 890, 1, 0, 0, 0, 891, 892, 1, 0, 0, 0, 892, 894, 1, 0, 0, 0, 893,
		895, 3, 234, 117, 0, 894, 893, 1, 0, 0, 0, 894, 895, 1, 0, 0, 0, 895, 896,
		1, 0, 0, 0, 896, 897, 5, 126, 0, 0, 897, 898, 5, 187, 0, 0, 898, 900, 3,
		322, 161, 0, 899, 901, 3, 158, 79, 0, 900, 899, 1, 0, 0, 0, 900, 901, 1,
		0, 0, 0, 901, 902, 1, 0, 0, 0, 902, 905, 3, 320, 160, 0, 903, 904, 5, 475,
		0, 0, 904, 906, 3, 254, 127, 0, 905, 903, 1, 0, 0, 0, 905, 906, 1, 0, 0,
		0, 906, 908, 1, 0, 0, 0, 907, 909, 3, 244, 122, 0, 908, 907, 1, 0, 0, 0,
		908, 909, 1, 0, 0, 0, 909, 952, 1, 0, 0, 0, 910, 911, 5, 261, 0, 0, 911,
		912, 5, 247, 0, 0, 912, 913, 3, 322, 161, 0, 913, 914, 5, 2, 0, 0, 914,
		919, 3, 166, 83, 0, 915, 916, 5, 4, 0, 0, 916, 918, 3, 166, 83, 0, 917,
		915, 1, 0, 0, 0, 918, 921, 1, 0, 0, 0, 919, 917, 1, 0, 0, 0, 919, 920,
		1, 0, 0, 0, 920, 922, 1, 0, 0, 0, 921, 919, 1, 0, 0, 0, 922, 924, 5, 3,
		0, 0, 923, 925, 3, 214, 107, 0, 924, 923, 1, 0, 0, 0, 924, 925, 1, 0, 0,
		0, 925, 927, 1, 0, 0, 0, 926, 928, 3, 310, 155, 0, 927, 926, 1, 0, 0, 0,
		927, 928, 1, 0, 0, 0, 928, 930, 1, 0, 0, 0, 929, 931, 3, 426, 213, 0, 930,
		929, 1, 0, 0, 0, 930, 931, 1, 0, 0, 0, 931, 952, 1, 0, 0, 0, 932, 933,
		5, 167, 0, 0, 933, 934, 5, 436, 0, 0, 934, 937, 3, 322, 161, 0, 935, 936,
		5, 319, 0, 0, 936, 938, 3, 300, 150, 0, 937, 935, 1, 0, 0, 0, 937, 938,
		1, 0, 0, 0, 938, 940, 1, 0, 0, 0, 939, 941, 3, 244, 122, 0, 940, 939, 1,
		0, 0, 0, 940, 941, 1, 0, 0, 0, 941, 942, 1, 0, 0, 0, 942, 943, 5, 451,
		0, 0, 943, 945, 5, 526, 0, 0, 944, 946, 3, 310, 155, 0, 945, 944, 1, 0,
		0, 0, 945, 946, 1, 0, 0, 0, 946, 948, 1, 0, 0, 0, 947, 949, 3, 214, 107,
		0, 948, 947, 1, 0, 0, 0, 948, 949, 1, 0, 0, 0, 949, 952, 1, 0, 0, 0, 950,
		952, 3, 196, 98, 0, 951, 837, 1, 0, 0, 0, 951, 874, 1, 0, 0, 0, 951, 891,
		1, 0, 0, 0, 951, 910, 1, 0, 0, 0, 951, 932, 1, 0, 0, 0, 951, 950, 1, 0,
		0, 0, 952, 17, 1, 0, 0, 0, 953, 955, 5, 99, 0, 0, 954, 956, 5, 169, 0,
		0, 955, 954, 1, 0, 0, 0, 955, 956, 1, 0, 0, 0, 956, 957, 1, 0, 0, 0, 957,
		961, 5, 436, 0, 0, 958, 959, 5, 214, 0, 0, 959, 960, 5, 301, 0, 0, 960,
		962, 5, 164, 0, 0, 961, 958, 1, 0, 0, 0, 961, 962, 1, 0, 0, 0, 962, 963,
		1, 0, 0, 0, 963, 978, 3, 322, 161, 0, 964, 966, 3, 300, 150, 0, 965, 964,
		1, 0, 0, 0, 965, 966, 1, 0, 0, 0, 966, 979, 1, 0, 0, 0, 967, 968, 5, 2,
		0, 0, 968, 971, 3, 328, 164, 0, 969, 970, 5, 4, 0, 0, 970, 972, 3, 332,
		166, 0, 971, 969, 1, 0, 0, 0, 971, 972, 1, 0, 0, 0, 972, 974, 1, 0, 0,
		0, 973, 975, 5, 4, 0, 0, 974, 973, 1, 0, 0, 0, 974, 975, 1, 0, 0, 0, 975,
		976, 1, 0, 0, 0, 976, 977, 5, 3, 0, 0, 977, 979, 1, 0, 0, 0, 978, 965,
		1, 0, 0, 0, 978, 967, 1, 0, 0, 0, 979, 983, 1, 0, 0, 0, 980, 981, 5, 155,
		0, 0, 981, 982, 5, 500, 0, 0, 982, 984, 3, 438, 219, 0, 983, 980, 1, 0,
		0, 0, 983, 984, 1, 0, 0, 0, 984, 993, 1, 0, 0, 0, 985, 986, 7, 4, 0, 0,
		986, 987, 5, 244, 0, 0, 987, 991, 3, 300, 150, 0, 988, 989, 5, 73, 0, 0,
		989, 990, 5, 59, 0, 0, 990, 992, 3, 300, 150, 0, 991, 988, 1, 0, 0, 0,
		991, 992, 1, 0, 0, 0, 992, 994, 1, 0, 0, 0, 993, 985, 1, 0, 0, 0, 993,
		994, 1, 0, 0, 0, 994, 997, 1, 0, 0, 0, 995, 996, 5, 81, 0, 0, 996, 998,
		5, 526, 0, 0, 997, 995, 1, 0, 0, 0, 997, 998, 1, 0, 0, 0, 998, 1000, 1,
		0, 0, 0, 999, 1001, 3, 160, 80, 0, 1000, 999, 1, 0, 0, 0, 1000, 1001, 1,
		0, 0, 0, 1001, 1016, 1, 0, 0, 0, 1002, 1003, 5, 136, 0, 0, 1003, 1007,
		5, 59, 0, 0, 1004, 1005, 5, 202, 0, 0, 1005, 1008, 3, 300, 150, 0, 1006,
		1008, 5, 356, 0, 0, 1007, 1004, 1, 0, 0, 0, 1007, 1006, 1, 0, 0, 0, 1008,
		1014, 1, 0, 0, 0, 1009, 1012, 5, 55, 0, 0, 1010, 1013, 5, 531, 0, 0, 1011,
		1013, 5, 32, 0, 0, 1012, 1010, 1, 0, 0, 0, 1012, 1011, 1, 0, 0, 0, 1013,
		1015, 1, 0, 0, 0, 1014, 1009, 1, 0, 0, 0, 1014, 1015, 1, 0, 0, 0, 1015,
		1017, 1, 0, 0, 0, 1016, 1002, 1, 0, 0, 0, 1016, 1017, 1, 0, 0, 0, 1017,
		1023, 1, 0, 0, 0, 1018, 1019, 5, 390, 0, 0, 1019, 1020, 5, 2, 0, 0, 1020,
		1021, 3, 352, 176, 0, 1021, 1022, 5, 3, 0, 0, 1022, 1024, 1, 0, 0, 0, 1023,
		1018, 1, 0, 0, 0, 1023, 1024, 1, 0, 0, 0, 1024, 1026, 1, 0, 0, 0, 1025,
		1027, 3, 310, 155, 0, 1026, 1025, 1, 0, 0, 0, 1026, 1027, 1, 0, 0, 0, 1027,
		1030, 1, 0, 0, 0, 1028, 1029, 5, 54, 0, 0, 1029, 1031, 3, 310, 155, 0,
		1030, 1028, 1, 0, 0, 0, 1030, 1031, 1, 0, 0, 0, 1031, 1034, 1, 0, 0, 0,
		1032, 1033, 5, 28, 0, 0, 1033, 1035, 3, 224, 112, 0, 1034, 1032, 1, 0,
		0, 0, 1034, 1035, 1, 0, 0, 0, 1035, 1180, 1, 0, 0, 0, 1036, 1039, 5, 99,
		0, 0, 1037, 1038, 5, 311, 0, 0, 1038, 1040, 5, 371, 0, 0, 1039, 1037, 1,
		0, 0, 0, 1039, 1040, 1, 0, 0, 0, 1040, 1041, 1, 0, 0, 0, 1041, 1045, 5,
		486, 0, 0, 1042, 1043, 5, 214, 0, 0, 1043, 1044, 5, 301, 0, 0, 1044, 1046,
		5, 164, 0, 0, 1045, 1042, 1, 0, 0, 0, 1045, 1046, 1, 0, 0, 0, 1046, 1047,
		1, 0, 0, 0, 1047, 1052, 3, 322, 161, 0, 1048, 1049, 5, 2, 0, 0, 1049, 1050,
		3, 324, 162, 0, 1050, 1051, 5, 3, 0, 0, 1051, 1053, 1, 0, 0, 0, 1052, 1048,
		1, 0, 0, 0, 1052, 1053, 1, 0, 0, 0, 1053, 1056, 1, 0, 0, 0, 1054, 1055,
		5, 81, 0, 0, 1055, 1057, 5, 526, 0, 0, 1056, 1054, 1, 0, 0, 0, 1056, 1057,
		1, 0, 0, 0, 1057, 1058, 1, 0, 0, 0, 1058, 1059, 5, 28, 0, 0, 1059, 1060,
		3, 224, 112, 0, 1060, 1180, 1, 0, 0, 0, 1061, 1062, 5, 99, 0, 0, 1062,
		1063, 5, 176, 0, 0, 1063, 1066, 5, 526, 0, 0, 1064, 1065, 7, 5, 0, 0, 1065,
		1067, 3, 438, 219, 0, 1066, 1064, 1, 0, 0, 0, 1066, 1067, 1, 0, 0, 0, 1067,
		1068, 1, 0, 0, 0, 1068, 1180, 3, 310, 155, 0, 1069, 1071, 5, 99, 0, 0,
		1070, 1072, 5, 169, 0, 0, 1071, 1070, 1, 0, 0, 0, 1071, 1072, 1, 0, 0,
		0, 1072, 1073, 1, 0, 0, 0, 1073, 1077, 5, 436, 0, 0, 1074, 1075, 5, 214,
		0, 0, 1075, 1076, 5, 301, 0, 0, 1076, 1078, 5, 164, 0, 0, 1077, 1074, 1,
		0, 0, 0, 1077, 1078, 1, 0, 0, 0, 1078, 1079, 1, 0, 0, 0, 1079, 1080, 3,
		322, 161, 0, 1080, 1081, 5, 256, 0, 0, 1081, 1087, 3, 322, 161, 0, 1082,
		1083, 5, 494, 0, 0, 1083, 1085, 5, 390, 0, 0, 1084, 1086, 3, 300, 150,
		0, 1085, 1084, 1, 0, 0, 0, 1085, 1086, 1, 0, 0, 0, 1086, 1088, 1, 0, 0,
		0, 1087, 1082, 1, 0, 0, 0, 1087, 1088, 1, 0, 0, 0, 1088, 1180, 1, 0, 0,
		0, 1089, 1090, 5, 99, 0, 0, 1090, 1094, 5, 387, 0, 0, 1091, 1092, 5, 214,
		0, 0, 1092, 1093, 5, 301, 0, 0, 1093, 1095, 5, 164, 0, 0, 1094, 1091, 1,
		0, 0, 0, 1094, 1095, 1, 0, 0, 0, 1095, 1096, 1, 0, 0, 0, 1096, 1099, 3,
		438, 219, 0, 1097, 1098, 5, 81, 0, 0, 1098, 1100, 5, 526, 0, 0, 1099, 1097,
		1, 0, 0, 0, 1099, 1100, 1, 0, 0, 0, 1100, 1180, 1, 0, 0, 0, 1101, 1102,
		5, 99, 0, 0, 1102, 1103, 5, 496, 0, 0, 1103, 1107, 5, 199, 0, 0, 1104,
		1105, 5, 214, 0, 0, 1105, 1106, 5, 301, 0, 0, 1106, 1108, 5, 164, 0, 0,
		1107, 1104, 1, 0, 0, 0, 1107, 1108, 1, 0, 0, 0, 1108, 1109, 1, 0, 0, 0,
		1109, 1111, 3, 178, 89, 0, 1110, 1112, 3, 310, 155, 0, 1111, 1110, 1, 0,
		0, 0, 1111, 1112, 1, 0, 0, 0, 1112, 1180, 1, 0, 0, 0, 1113, 1114, 5, 99,
		0, 0, 1114, 1118, 5, 66, 0, 0, 1115, 1116, 5, 214, 0, 0, 1116, 1117, 5,
		301, 0, 0, 1117, 1119, 5, 164, 0, 0, 1118, 1115, 1, 0, 0, 0, 1118, 1119,
		1, 0, 0, 0, 1119, 1120, 1, 0, 0, 0, 1120, 1124, 3, 438, 219, 0, 1121, 1122,
		5, 494, 0, 0, 1122, 1123, 5, 377, 0, 0, 1123, 1125, 3, 438, 219, 0, 1124,
		1121, 1, 0, 0, 0, 1124, 1125, 1, 0, 0, 0, 1125, 1128, 1, 0, 0, 0, 1126,
		1127, 5, 81, 0, 0, 1127, 1129, 5, 526, 0, 0, 1128, 1126, 1, 0, 0, 0, 1128,
		1129, 1, 0, 0, 0, 1129, 1131, 1, 0, 0, 0, 1130, 1132, 3, 310, 155, 0, 1131,
		1130, 1, 0, 0, 0, 1131, 1132, 1, 0, 0, 0, 1132, 1180, 1, 0, 0, 0, 1133,
		1134, 5, 99, 0, 0, 1134, 1135, 5, 392, 0, 0, 1135, 1139, 5, 340, 0, 0,
		1136, 1137, 5, 214, 0, 0, 1137, 1138, 5, 301, 0, 0, 1138, 1140, 5, 164,
		0, 0, 1139, 1136, 1, 0, 0, 0, 1139, 1140, 1, 0, 0, 0, 1140, 1141, 1, 0,
		0, 0, 1141, 1142, 3, 438, 219, 0, 1142, 1143, 5, 307, 0, 0, 1143, 1144,
		3, 322, 161, 0, 1144, 1145, 5, 28, 0, 0, 1145, 1146, 7, 6, 0, 0, 1146,
		1150, 5, 451, 0, 0, 1147, 1151, 3, 186, 93, 0, 1148, 1149, 5, 387, 0, 0,
		1149, 1151, 3, 438, 219, 0, 1150, 1147, 1, 0, 0, 0, 1150, 1148, 1, 0, 0,
		0, 1151, 1152, 1, 0, 0, 0, 1152, 1153, 5, 475, 0, 0, 1153, 1154, 5, 2,
		0, 0, 1154, 1155, 3, 370, 185, 0, 1155, 1156, 5, 3, 0, 0, 1156, 1180, 1,
		0, 0, 0, 1157, 1158, 5, 99, 0, 0, 1158, 1162, 5, 418, 0, 0, 1159, 1160,
		5, 214, 0, 0, 1160, 1161, 5, 301, 0, 0, 1161, 1163, 5, 164, 0, 0, 1162,
		1159, 1, 0, 0, 0, 1162, 1163, 1, 0, 0, 0, 1163, 1164, 1, 0, 0, 0, 1164,
		1166, 3, 438, 219, 0, 1165, 1167, 3, 310, 155, 0, 1166, 1165, 1, 0, 0,
		0, 1166, 1167, 1, 0, 0, 0, 1167, 1180, 1, 0, 0, 0, 1168, 1169, 5, 99, 0,
		0, 1169, 1173, 5, 151, 0, 0, 1170, 1171, 5, 214, 0, 0, 1171, 1172, 5, 301,
		0, 0, 1172, 1174, 5, 164, 0, 0, 1173, 1170, 1, 0, 0, 0, 1173, 1174, 1,
		0, 0, 0, 1174, 1175, 1, 0, 0, 0, 1175, 1176, 3, 322, 161, 0, 1176, 1177,
		5, 28, 0, 0, 1177, 1178, 5, 526, 0, 0, 1178, 1180, 1, 0, 0, 0, 1179, 953,
		1, 0, 0, 0, 1179, 1036, 1, 0, 0, 0, 1179, 1061, 1, 0, 0, 0, 1179, 1069,
		1, 0, 0, 0, 1179, 1089, 1, 0, 0, 0, 1179, 1101, 1, 0, 0, 0, 1179, 1113,
		1, 0, 0, 0, 1179, 1133, 1, 0, 0, 0, 1179, 1157, 1, 0, 0, 0, 1179, 1168,
		1, 0, 0, 0, 1180, 19, 1, 0, 0, 0, 1181, 1182, 5, 21, 0, 0, 1182, 1183,
		5, 486, 0, 0, 1183, 1194, 3, 322, 161, 0, 1184, 1185, 5, 288, 0, 0, 1185,
		1195, 3, 426, 213, 0, 1186, 1187, 5, 2, 0, 0, 1187, 1188, 3, 324, 162,
		0, 1188, 1189, 5, 3, 0, 0, 1189, 1191, 1, 0, 0, 0, 1190, 1186, 1, 0, 0,
		0, 1190, 1191, 1, 0, 0, 0, 1191, 1192, 1, 0, 0, 0, 1192, 1193, 5, 28, 0,
		0, 1193, 1195, 3, 224, 112, 0, 1194, 1184, 1, 0, 0, 0, 1194, 1190, 1, 0,
		0, 0, 1195, 1320, 1, 0, 0, 0, 1196, 1197, 5, 21, 0, 0, 1197, 1198, 5, 66,
		0, 0, 1198, 1199, 3, 438, 219, 0, 1199, 1200, 5, 368, 0, 0, 1200, 1201,
		3, 438, 219, 0, 1201, 1320, 1, 0, 0, 0, 1202, 1203, 5, 21, 0, 0, 1203,
		1204, 5, 387, 0, 0, 1204, 1205, 3, 438, 219, 0, 1205, 1206, 3, 426, 213,
		0, 1206, 1320, 1, 0, 0, 0, 1207, 1208, 5, 21, 0, 0, 1208, 1209, 5, 426,
		0, 0, 1209, 1210, 5, 482, 0, 0, 1210, 1211, 3, 322, 161, 0, 1211, 1212,
		3, 310, 155, 0, 1212, 1320, 1, 0, 0, 0, 1213, 1214, 5, 21, 0, 0, 1214,
		1215, 5, 387, 0, 0, 1215, 1216, 3, 438, 219, 0, 1216, 1217, 3, 426, 213,
		0, 1217, 1320, 1, 0, 0, 0, 1218, 1219, 5, 21, 0, 0, 1219, 1220, 5, 496,
		0, 0, 1220, 1221, 5, 199, 0, 0, 1221, 1223, 3, 178, 89, 0, 1222, 1224,
		3, 310, 155, 0, 1223, 1222, 1, 0, 0, 0, 1223, 1224, 1, 0, 0, 0, 1224, 1320,
		1, 0, 0, 0, 1225, 1226, 5, 21, 0, 0, 1226, 1227, 5, 496, 0, 0, 1227, 1228,
		5, 340, 0, 0, 1228, 1230, 3, 178, 89, 0, 1229, 1231, 3, 310, 155, 0, 1230,
		1229, 1, 0, 0, 0, 1230, 1231, 1, 0, 0, 0, 1231, 1320, 1, 0, 0, 0, 1232,
		1233, 5, 21, 0, 0, 1233, 1234, 5, 418, 0, 0, 1234, 1236, 3, 438, 219, 0,
		1235, 1237, 3, 310, 155, 0, 1236, 1235, 1, 0, 0, 0, 1236, 1237, 1, 0, 0,
		0, 1237, 1320, 1, 0, 0, 0, 1238, 1239, 5, 21, 0, 0, 1239, 1240, 5, 66,
		0, 0, 1240, 1241, 3, 438, 219, 0, 1241, 1242, 5, 288, 0, 0, 1242, 1243,
		5, 81, 0, 0, 1243, 1244, 5, 526, 0, 0, 1244, 1320, 1, 0, 0, 0, 1245, 1246,
		5, 21, 0, 0, 1246, 1247, 5, 111, 0, 0, 1247, 1248, 3, 438, 219, 0, 1248,
		1249, 5, 368, 0, 0, 1249, 1250, 3, 438, 219, 0, 1250, 1320, 1, 0, 0, 0,
		1251, 1252, 5, 21, 0, 0, 1252, 1253, 5, 387, 0, 0, 1253, 1254, 3, 438,
		219, 0, 1254, 1255, 3, 426, 213, 0, 1255, 1320, 1, 0, 0, 0, 1256, 1257,
		5, 21, 0, 0, 1257, 1258, 5, 436, 0, 0, 1258, 1259, 3, 322, 161, 0, 1259,
		1264, 3, 98, 49, 0, 1260, 1261, 5, 4, 0, 0, 1261, 1263, 3, 98, 49, 0, 1262,
		1260, 1, 0, 0, 0, 1263, 1266, 1, 0, 0, 0, 1264, 1262, 1, 0, 0, 0, 1264,
		1265, 1, 0, 0, 0, 1265, 1320, 1, 0, 0, 0, 1266, 1264, 1, 0, 0, 0, 1267,
		1268, 5, 21, 0, 0, 1268, 1269, 5, 436, 0, 0, 1269, 1270, 3, 322, 161, 0,
		1270, 1271, 5, 14, 0, 0, 1271, 1272, 5, 390, 0, 0, 1272, 1277, 3, 96, 48,
		0, 1273, 1274, 5, 4, 0, 0, 1274, 1276, 3, 96, 48, 0, 1275, 1273, 1, 0,
		0, 0, 1276, 1279, 1, 0, 0, 0, 1277, 1275, 1, 0, 0, 0, 1277, 1278, 1, 0,
		0, 0, 1278, 1320, 1, 0, 0, 0, 1279, 1277, 1, 0, 0, 0, 1280, 1281, 5, 21,
		0, 0, 1281, 1282, 5, 436, 0, 0, 1282, 1283, 3, 322, 161, 0, 1283, 1284,
		5, 142, 0, 0, 1284, 1285, 5, 390, 0, 0, 1285, 1290, 3, 94, 47, 0, 1286,
		1287, 5, 4, 0, 0, 1287, 1289, 3, 94, 47, 0, 1288, 1286, 1, 0, 0, 0, 1289,
		1292, 1, 0, 0, 0, 1290, 1288, 1, 0, 0, 0, 1290, 1291, 1, 0, 0, 0, 1291,
		1320, 1, 0, 0, 0, 1292, 1290, 1, 0, 0, 0, 1293, 1294, 5, 21, 0, 0, 1294,
		1295, 5, 436, 0, 0, 1295, 1296, 3, 322, 161, 0, 1296, 1297, 5, 406, 0,
		0, 1297, 1298, 5, 2, 0, 0, 1298, 1299, 3, 312, 156, 0, 1299, 1300, 5, 3,
		0, 0, 1300, 1320, 1, 0, 0, 0, 1301, 1302, 5, 21, 0, 0, 1302, 1303, 5, 111,
		0, 0, 1303, 1304, 3, 438, 219, 0, 1304, 1305, 5, 406, 0, 0, 1305, 1306,
		7, 7, 0, 0, 1306, 1309, 5, 353, 0, 0, 1307, 1310, 3, 438, 219, 0, 1308,
		1310, 5, 531, 0, 0, 1309, 1307, 1, 0, 0, 0, 1309, 1308, 1, 0, 0, 0, 1310,
		1320, 1, 0, 0, 0, 1311, 1312, 5, 21, 0, 0, 1312, 1313, 5, 435, 0, 0, 1313,
		1314, 5, 368, 0, 0, 1314, 1315, 5, 87, 0, 0, 1315, 1316, 5, 199, 0, 0,
		1316, 1317, 3, 438, 219, 0, 1317, 1318, 3, 438, 219, 0, 1318, 1320, 1,
		0, 0, 0, 1319, 1181, 1, 0, 0, 0, 1319, 1196, 1, 0, 0, 0, 1319, 1202, 1,
		0, 0, 0, 1319, 1207, 1, 0, 0, 0, 1319, 1213, 1, 0, 0, 0, 1319, 1218, 1,
		0, 0, 0, 1319, 1225, 1, 0, 0, 0, 1319, 1232, 1, 0, 0, 0, 1319, 1238, 1,
		0, 0, 0, 1319, 1245, 1, 0, 0, 0, 1319, 1251, 1, 0, 0, 0, 1319, 1256, 1,
		0, 0, 0, 1319, 1267, 1, 0, 0, 0, 1319, 1280, 1, 0, 0, 0, 1319, 1293, 1,
		0, 0, 0, 1319, 1301, 1, 0, 0, 0, 1319, 1311, 1, 0, 0, 0, 1320, 21, 1, 0,
		0, 0, 1321, 1322, 5, 142, 0, 0, 1322, 1323, 5, 66, 0, 0, 1323, 1324, 5,
		363, 0, 0, 1324, 1325, 5, 42, 0, 0, 1325, 1326, 5, 492, 0, 0, 1326, 1327,
		5, 526, 0, 0, 1327, 1328, 5, 500, 0, 0, 1328, 1410, 5, 531, 0, 0, 1329,
		1330, 5, 142, 0, 0, 1330, 1333, 5, 151, 0, 0, 1331, 1332, 5, 214, 0, 0,
		1332, 1334, 5, 164, 0, 0, 1333, 1331, 1, 0, 0, 0, 1333, 1334, 1, 0, 0,
		0, 1334, 1335, 1, 0, 0, 0, 1335, 1410, 3, 322, 161, 0, 1336, 1337, 5, 142,
		0, 0, 1337, 1340, 5, 387, 0, 0, 1338, 1339, 5, 214, 0, 0, 1339, 1341, 5,
		164, 0, 0, 1340, 1338, 1, 0, 0, 0, 1340, 1341, 1, 0, 0, 0, 1341, 1342,
		1, 0, 0, 0, 1342, 1410, 3, 438, 219, 0, 1343, 1344, 5, 142, 0, 0, 1344,
		1347, 5, 418, 0, 0, 1345, 1346, 5, 214, 0, 0, 1346, 1348, 5, 164, 0, 0,
		1347, 1345, 1, 0, 0, 0, 1347, 1348, 1, 0, 0, 0, 1348, 1349, 1, 0, 0, 0,
		1349, 1410, 3, 302, 151, 0, 1350, 1351, 5, 142, 0, 0, 1351, 1354, 5, 473,
		0, 0, 1352, 1353, 5, 214, 0, 0, 1353, 1355, 5, 164, 0, 0, 1354, 1352, 1,
		0, 0, 0, 1354, 1355, 1, 0, 0, 0, 1355, 1356, 1, 0, 0, 0, 1356, 1410, 3,
		186, 93, 0, 1357, 1358, 5, 142, 0, 0, 1358, 1359, 5, 426, 0, 0, 1359, 1362,
		5, 340, 0, 0, 1360, 1361, 5, 214, 0, 0, 1361, 1363, 5, 164, 0, 0, 1362,
		1360, 1, 0, 0, 0, 1362, 1363, 1, 0, 0, 0, 1363, 1364, 1, 0, 0, 0, 1364,
		1410, 3, 438, 219, 0, 1365, 1366, 5, 142, 0, 0, 1366, 1367, 5, 496, 0,
		0, 1367, 1370, 5, 199, 0, 0, 1368, 1369, 5, 214, 0, 0, 1369, 1371, 5, 164,
		0, 0, 1370, 1368, 1, 0, 0, 0, 1370, 1371, 1, 0, 0, 0, 1371, 1372, 1, 0,
		0, 0, 1372, 1410, 3, 178, 89, 0, 1373, 1374, 5, 142, 0, 0, 1374, 1377,
		5, 66, 0, 0, 1375, 1376, 5, 214, 0, 0, 1376, 1378, 5, 164, 0, 0, 1377,
		1375, 1, 0, 0, 0, 1377, 1378, 1, 0, 0, 0, 1378, 1379, 1, 0, 0, 0, 1379,
		1410, 3, 438, 219, 0, 1380, 1381, 5, 142, 0, 0, 1381, 1382, 5, 176, 0,
		0, 1382, 1385, 5, 526, 0, 0, 1383, 1384, 7, 5, 0, 0, 1384, 1386, 3, 438,
		219, 0, 1385, 1383, 1, 0, 0, 0, 1385, 1386, 1, 0, 0, 0, 1386, 1387, 1,
		0, 0, 0, 1387, 1410, 3, 310, 155, 0, 1388, 1389, 5, 142, 0, 0, 1389, 1390,
		5, 496, 0, 0, 1390, 1393, 5, 340, 0, 0, 1391, 1392, 5, 214, 0, 0, 1392,
		1394, 5, 164, 0, 0, 1393, 1391, 1, 0, 0, 0, 1393, 1394, 1, 0, 0, 0, 1394,
		1395, 1, 0, 0, 0, 1395, 1410, 3, 178, 89, 0, 1396, 1397, 5, 142, 0, 0,
		1397, 1398, 5, 376, 0, 0, 1398, 1410, 3, 438, 219, 0, 1399, 1400, 5, 142,
		0, 0, 1400, 1403, 7, 8, 0, 0, 1401, 1402, 5, 214, 0, 0, 1402, 1404, 5,
		164, 0, 0, 1403, 1401, 1, 0, 0, 0, 1403, 1404, 1, 0, 0, 0, 1404, 1405,
		1, 0, 0, 0, 1405, 1407, 3, 322, 161, 0, 1406, 1408, 5, 184, 0, 0, 1407,
		1406, 1, 0, 0, 0, 1407, 1408, 1, 0, 0, 0, 1408, 1410, 1, 0, 0, 0, 1409,
		1321, 1, 0, 0, 0, 1409, 1329, 1, 0, 0, 0, 1409, 1336, 1, 0, 0, 0, 1409,
		1343, 1, 0, 0, 0, 1409, 1350, 1, 0, 0, 0, 1409, 1357, 1, 0, 0, 0, 1409,
		1365, 1, 0, 0, 0, 1409, 1373, 1, 0, 0, 0, 1409, 1380, 1, 0, 0, 0, 1409,
		1388, 1, 0, 0, 0, 1409, 1396, 1, 0, 0, 0, 1409, 1399, 1, 0, 0, 0, 1410,
		23, 1, 0, 0, 0, 1411, 1413, 5, 410, 0, 0, 1412, 1414, 7, 9, 0, 0, 1413,
		1412, 1, 0, 0, 0, 1413, 1414, 1, 0, 0, 0, 1414, 1415, 1, 0, 0, 0, 1415,
		1417, 5, 480, 0, 0, 1416, 1418, 3, 80, 40, 0, 1417, 1416, 1, 0, 0, 0, 1417,
		1418, 1, 0, 0, 0, 1418, 1709, 1, 0, 0, 0, 1419, 1420, 5, 410, 0, 0, 1420,
		1709, 5, 31, 0, 0, 1421, 1422, 5, 410, 0, 0, 1422, 1423, 5, 99, 0, 0, 1423,
		1424, 7, 8, 0, 0, 1424, 1709, 3, 322, 161, 0, 1425, 1426, 5, 410, 0, 0,
		1426, 1709, 5, 54, 0, 0, 1427, 1428, 5, 410, 0, 0, 1428, 1429, 5, 147,
		0, 0, 1429, 1430, 5, 319, 0, 0, 1430, 1433, 5, 437, 0, 0, 1431, 1432, 7,
		5, 0, 0, 1432, 1434, 3, 322, 161, 0, 1433, 1431, 1, 0, 0, 0, 1433, 1434,
		1, 0, 0, 0, 1434, 1709, 1, 0, 0, 0, 1435, 1436, 5, 410, 0, 0, 1436, 1439,
		5, 159, 0, 0, 1437, 1438, 7, 5, 0, 0, 1438, 1440, 3, 322, 161, 0, 1439,
		1437, 1, 0, 0, 0, 1439, 1440, 1, 0, 0, 0, 1440, 1442, 1, 0, 0, 0, 1441,
		1443, 3, 80, 40, 0, 1442, 1441, 1, 0, 0, 0, 1442, 1443, 1, 0, 0, 0, 1443,
		1709, 1, 0, 0, 0, 1444, 1445, 5, 410, 0, 0, 1445, 1446, 5, 249, 0, 0, 1446,
		1709, 5, 223, 0, 0, 1447, 1451, 5, 410, 0, 0, 1448, 1449, 5, 69, 0, 0,
		1449, 1452, 5, 406, 0, 0, 1450, 1452, 5, 70, 0, 0, 1451, 1448, 1, 0, 0,
		0, 1451, 1450, 1, 0, 0, 0, 1452, 1709, 1, 0, 0, 0, 1453, 1454, 5, 410,
		0, 0, 1454, 1457, 5, 126, 0, 0, 1455, 1456, 7, 5, 0, 0, 1456, 1458, 3,
		322, 161, 0, 1457, 1455, 1, 0, 0, 0, 1457, 1458, 1, 0, 0, 0, 1458, 1709,
		1, 0, 0, 0, 1459, 1461, 5, 410, 0, 0, 1460, 1462, 5, 20, 0, 0, 1461, 1460,
		1, 0, 0, 0, 1461, 1462, 1, 0, 0, 0, 1462, 1463, 1, 0, 0, 0, 1463, 1709,
		5, 197, 0, 0, 1464, 1465, 5, 410, 0, 0, 1465, 1466, 5, 197, 0, 0, 1466,
		1467, 5, 182, 0, 0, 1467, 1709, 3, 186, 93, 0, 1468, 1469, 5, 410, 0, 0,
		1469, 1470, 5, 434, 0, 0, 1470, 1473, 5, 239, 0, 0, 1471, 1472, 7, 5, 0,
		0, 1472, 1474, 3, 322, 161, 0, 1473, 1471, 1, 0, 0, 0, 1473, 1474, 1, 0,
		0, 0, 1474, 1709, 1, 0, 0, 0, 1475, 1476, 5, 410, 0, 0, 1476, 1477, 5,
		261, 0, 0, 1477, 1479, 5, 347, 0, 0, 1478, 1480, 5, 526, 0, 0, 1479, 1478,
		1, 0, 0, 0, 1479, 1480, 1, 0, 0, 0, 1480, 1482, 1, 0, 0, 0, 1481, 1483,
		3, 292, 146, 0, 1482, 1481, 1, 0, 0, 0, 1482, 1483, 1, 0, 0, 0, 1483, 1709,
		1, 0, 0, 0, 1484, 1485, 5, 410, 0, 0, 1485, 1486, 5, 99, 0, 0, 1486, 1487,
		5, 376, 0, 0, 1487, 1488, 5, 182, 0, 0, 1488, 1709, 3, 438, 219, 0, 1489,
		1490, 5, 410, 0, 0, 1490, 1491, 5, 486, 0, 0, 1491, 1492, 7, 5, 0, 0, 1492,
		1495, 3, 322, 161, 0, 1493, 1494, 7, 5, 0, 0, 1494, 1496, 3, 438, 219,
		0, 1495, 1493, 1, 0, 0, 0, 1495, 1496, 1, 0, 0, 0, 1496, 1709, 1, 0, 0,
		0, 1497, 1498, 5, 410, 0, 0, 1498, 1709, 5, 339, 0, 0, 1499, 1500, 5, 410,
		0, 0, 1500, 1709, 5, 375, 0, 0, 1501, 1502, 5, 410, 0, 0, 1502, 1505, 5,
		152, 0, 0, 1503, 1504, 7, 5, 0, 0, 1504, 1506, 3, 322, 161, 0, 1505, 1503,
		1, 0, 0, 0, 1505, 1506, 1, 0, 0, 0, 1506, 1509, 1, 0, 0, 0, 1507, 1508,
		5, 256, 0, 0, 1508, 1510, 5, 526, 0, 0, 1509, 1507, 1, 0, 0, 0, 1509, 1510,
		1, 0, 0, 0, 1510, 1709, 1, 0, 0, 0, 1511, 1513, 5, 410, 0, 0, 1512, 1514,
		5, 53, 0, 0, 1513, 1512, 1, 0, 0, 0, 1513, 1514, 1, 0, 0, 0, 1514, 1515,
		1, 0, 0, 0, 1515, 1516, 5, 99, 0, 0, 1516, 1517, 5, 436, 0, 0, 1517, 1709,
		3, 322, 161, 0, 1518, 1520, 5, 410, 0, 0, 1519, 1521, 5, 190, 0, 0, 1520,
		1519, 1, 0, 0, 0, 1520, 1521, 1, 0, 0, 0, 1521, 1522, 1, 0, 0, 0, 1522,
		1709, 5, 346, 0, 0, 1523, 1524, 5, 410, 0, 0, 1524, 1709, 5, 388, 0, 0,
		1525, 1526, 5, 410, 0, 0, 1526, 1527, 5, 319, 0, 0, 1527, 1709, 5, 531,
		0, 0, 1528, 1529, 5, 410, 0, 0, 1529, 1709, 5, 336, 0, 0, 1530, 1531, 5,
		410, 0, 0, 1531, 1532, 5, 344, 0, 0, 1532, 1709, 5, 526, 0, 0, 1533, 1534,
		5, 410, 0, 0, 1534, 1537, 5, 176, 0, 0, 1535, 1536, 7, 5, 0, 0, 1536, 1538,
		3, 322, 161, 0, 1537, 1535, 1, 0, 0, 0, 1537, 1538, 1, 0, 0, 0, 1538, 1709,
		1, 0, 0, 0, 1539, 1541, 5, 410, 0, 0, 1540, 1542, 5, 426, 0, 0, 1541, 1540,
		1, 0, 0, 0, 1541, 1542, 1, 0, 0, 0, 1542, 1543, 1, 0, 0, 0, 1543, 1709,
		5, 156, 0, 0, 1544, 1545, 5, 410, 0, 0, 1545, 1546, 5, 99, 0, 0, 1546,
		1547, 5, 66, 0, 0, 1547, 1709, 3, 438, 219, 0, 1548, 1549, 5, 410, 0, 0,
		1549, 1550, 5, 66, 0, 0, 1550, 1709, 3, 438, 219, 0, 1551, 1552, 5, 410,
		0, 0, 1552, 1554, 5, 67, 0, 0, 1553, 1555, 3, 80, 40, 0, 1554, 1553, 1,
		0, 0, 0, 1554, 1555, 1, 0, 0, 0, 1555, 1709, 1, 0, 0, 0, 1556, 1557, 5,
		410, 0, 0, 1557, 1560, 5, 349, 0, 0, 1558, 1559, 5, 182, 0, 0, 1559, 1561,
		3, 178, 89, 0, 1560, 1558, 1, 0, 0, 0, 1560, 1561, 1, 0, 0, 0, 1561, 1564,
		1, 0, 0, 0, 1562, 1563, 5, 256, 0, 0, 1563, 1565, 5, 526, 0, 0, 1564, 1562,
		1, 0, 0, 0, 1564, 1565, 1, 0, 0, 0, 1565, 1709, 1, 0, 0, 0, 1566, 1567,
		5, 410, 0, 0, 1567, 1568, 5, 20, 0, 0, 1568, 1571, 5, 348, 0, 0, 1569,
		1570, 5, 256, 0, 0, 1570, 1572, 5, 526, 0, 0, 1571, 1569, 1, 0, 0, 0, 1571,
		1572, 1, 0, 0, 0, 1572, 1709, 1, 0, 0, 0, 1573, 1574, 5, 410, 0, 0, 1574,
		1576, 5, 76, 0, 0, 1575, 1577, 3, 80, 40, 0, 1576, 1575, 1, 0, 0, 0, 1576,
		1577, 1, 0, 0, 0, 1577, 1709, 1, 0, 0, 0, 1578, 1579, 5, 410, 0, 0, 1579,
		1582, 5, 418, 0, 0, 1580, 1581, 5, 182, 0, 0, 1581, 1583, 3, 438, 219,
		0, 1582, 1580, 1, 0, 0, 0, 1582, 1583, 1, 0, 0, 0, 1583, 1709, 1, 0, 0,
		0, 1584, 1585, 5, 410, 0, 0, 1585, 1586, 5, 99, 0, 0, 1586, 1587, 5, 486,
		0, 0, 1587, 1709, 3, 322, 161, 0, 1588, 1589, 5, 410, 0, 0, 1589, 1590,
		5, 110, 0, 0, 1590, 1709, 5, 461, 0, 0, 1591, 1592, 5, 410, 0, 0, 1592,
		1593, 5, 99, 0, 0, 1593, 1594, 5, 278, 0, 0, 1594, 1595, 5, 486, 0, 0,
		1595, 1596, 3, 438, 219, 0, 1596, 1597, 5, 307, 0, 0, 1597, 1598, 3, 322,
		161, 0, 1598, 1709, 1, 0, 0, 0, 1599, 1600, 5, 410, 0, 0, 1600, 1602, 7,
		10, 0, 0, 1601, 1603, 3, 292, 146, 0, 1602, 1601, 1, 0, 0, 0, 1602, 1603,
		1, 0, 0, 0, 1603, 1709, 1, 0, 0, 0, 1604, 1605, 5, 410, 0, 0, 1605, 1606,
		5, 98, 0, 0, 1606, 1607, 5, 2, 0, 0, 1607, 1608, 5, 509, 0, 0, 1608, 1609,
		5, 3, 0, 0, 1609, 1709, 7, 10, 0, 0, 1610, 1611, 5, 410, 0, 0, 1611, 1709,
		5, 36, 0, 0, 1612, 1613, 5, 410, 0, 0, 1613, 1709, 5, 420, 0, 0, 1614,
		1615, 5, 410, 0, 0, 1615, 1616, 5, 374, 0, 0, 1616, 1617, 5, 137, 0, 0,
		1617, 1618, 5, 187, 0, 0, 1618, 1709, 3, 78, 39, 0, 1619, 1621, 5, 410,
		0, 0, 1620, 1622, 5, 190, 0, 0, 1621, 1620, 1, 0, 0, 0, 1621, 1622, 1,
		0, 0, 0, 1622, 1623, 1, 0, 0, 0, 1623, 1626, 5, 455, 0, 0, 1624, 1625,
		7, 5, 0, 0, 1625, 1627, 3, 322, 161, 0, 1626, 1624, 1, 0, 0, 0, 1626, 1627,
		1, 0, 0, 0, 1627, 1629, 1, 0, 0, 0, 1628, 1630, 3, 80, 40, 0, 1629, 1628,
		1, 0, 0, 0, 1629, 1630, 1, 0, 0, 0, 1630, 1709, 1, 0, 0, 0, 1631, 1632,
		5, 410, 0, 0, 1632, 1633, 5, 439, 0, 0, 1633, 1634, 5, 131, 0, 0, 1634,
		1709, 5, 531, 0, 0, 1635, 1636, 5, 410, 0, 0, 1636, 1638, 5, 189, 0, 0,
		1637, 1639, 3, 438, 219, 0, 1638, 1637, 1, 0, 0, 0, 1638, 1639, 1, 0, 0,
		0, 1639, 1709, 1, 0, 0, 0, 1640, 1641, 5, 410, 0, 0, 1641, 1642, 5, 111,
		0, 0, 1642, 1709, 5, 531, 0, 0, 1643, 1644, 5, 410, 0, 0, 1644, 1645, 5,
		436, 0, 0, 1645, 1709, 5, 531, 0, 0, 1646, 1647, 5, 410, 0, 0, 1647, 1650,
		5, 453, 0, 0, 1648, 1649, 5, 307, 0, 0, 1649, 1651, 5, 526, 0, 0, 1650,
		1648, 1, 0, 0, 0, 1650, 1651, 1, 0, 0, 0, 1651, 1709, 1, 0, 0, 0, 1652,
		1654, 5, 410, 0, 0, 1653, 1655, 7, 9, 0, 0, 1654, 1653, 1, 0, 0, 0, 1654,
		1655, 1, 0, 0, 0, 1655, 1656, 1, 0, 0, 0, 1656, 1709, 5, 424, 0, 0, 1657,
		1658, 5, 410, 0, 0, 1658, 1709, 5, 493, 0, 0, 1659, 1660, 5, 410, 0, 0,
		1660, 1661, 5, 440, 0, 0, 1661, 1662, 5, 39, 0, 0, 1662, 1667, 5, 531,
		0, 0, 1663, 1664, 5, 4, 0, 0, 1664, 1666, 5, 531, 0, 0, 1665, 1663, 1,
		0, 0, 0, 1666, 1669, 1, 0, 0, 0, 1667, 1665, 1, 0, 0, 0, 1667, 1668, 1,
		0, 0, 0, 1668, 1709, 1, 0, 0, 0, 1669, 1667, 1, 0, 0, 0, 1670, 1671, 5,
		410, 0, 0, 1671, 1672, 5, 110, 0, 0, 1672, 1673, 5, 412, 0, 0, 1673, 1674,
		5, 187, 0, 0, 1674, 1709, 3, 78, 39, 0, 1675, 1676, 5, 410, 0, 0, 1676,
		1677, 5, 436, 0, 0, 1677, 1680, 5, 100, 0, 0, 1678, 1679, 7, 5, 0, 0, 1679,
		1681, 3, 322, 161, 0, 1680, 1678, 1, 0, 0, 0, 1680, 1681, 1, 0, 0, 0, 1681,
		1684, 1, 0, 0, 0, 1682, 1683, 5, 256, 0, 0, 1683, 1685, 5, 526, 0, 0, 1684,
		1682, 1, 0, 0, 0, 1684, 1685, 1, 0, 0, 0, 1685, 1709, 1, 0, 0, 0, 1686,
		1687, 5, 410, 0, 0, 1687, 1688, 5, 439, 0, 0, 1688, 1689, 5, 426, 0, 0,
		1689, 1691, 5, 185, 0, 0, 1690, 1692, 5, 484, 0, 0, 1691, 1690, 1, 0, 0,
		0, 1691, 1692, 1, 0, 0, 0, 1692, 1709, 1, 0, 0, 0, 1693, 1694, 5, 410,
		0, 0, 1694, 1695, 5, 352, 0, 0, 1695, 1697, 5, 347, 0, 0, 1696, 1698, 5,
		526, 0, 0, 1697, 1696, 1, 0, 0, 0, 1697, 1698, 1, 0, 0, 0, 1698, 1700,
		1, 0, 0, 0, 1699, 1701, 3, 292, 146, 0, 1700, 1699, 1, 0, 0, 0, 1700, 1701,
		1, 0, 0, 0, 1701, 1709, 1, 0, 0, 0, 1702, 1703, 5, 410, 0, 0, 1703, 1706,
		5, 96, 0, 0, 1704, 1705, 7, 5, 0, 0, 1705, 1707, 3, 322, 161, 0, 1706,
		1704, 1, 0, 0, 0, 1706, 1707, 1, 0, 0, 0, 1707, 1709, 1, 0, 0, 0, 1708,
		1411, 1, 0, 0, 0, 1708, 1419, 1, 0, 0, 0, 1708, 1421, 1, 0, 0, 0, 1708,
		1425, 1, 0, 0, 0, 1708, 1427, 1, 0, 0, 0, 1708, 1435, 1, 0, 0, 0, 1708,
		1444, 1, 0, 0, 0, 1708, 1447, 1, 0, 0, 0, 1708, 1453, 1, 0, 0, 0, 1708,
		1459, 1, 0, 0, 0, 1708, 1464, 1, 0, 0, 0, 1708, 1468, 1, 0, 0, 0, 1708,
		1475, 1, 0, 0, 0, 1708, 1484, 1, 0, 0, 0, 1708, 1489, 1, 0, 0, 0, 1708,
		1497, 1, 0, 0, 0, 1708, 1499, 1, 0, 0, 0, 1708, 1501, 1, 0, 0, 0, 1708,
		1511, 1, 0, 0, 0, 1708, 1518, 1, 0, 0, 0, 1708, 1523, 1, 0, 0, 0, 1708,
		1525, 1, 0, 0, 0, 1708, 1528, 1, 0, 0, 0, 1708, 1530, 1, 0, 0, 0, 1708,
		1533, 1, 0, 0, 0, 1708, 1539, 1, 0, 0, 0, 1708, 1544, 1, 0, 0, 0, 1708,
		1548, 1, 0, 0, 0, 1708, 1551, 1, 0, 0, 0, 1708, 1556, 1, 0, 0, 0, 1708,
		1566, 1, 0, 0, 0, 1708, 1573, 1, 0, 0, 0, 1708, 1578, 1, 0, 0, 0, 1708,
		1584, 1, 0, 0, 0, 1708, 1588, 1, 0, 0, 0, 1708, 1591, 1, 0, 0, 0, 1708,
		1599, 1, 0, 0, 0, 1708, 1604, 1, 0, 0, 0, 1708, 1610, 1, 0, 0, 0, 1708,
		1612, 1, 0, 0, 0, 1708, 1614, 1, 0, 0, 0, 1708, 1619, 1, 0, 0, 0, 1708,
		1631, 1, 0, 0, 0, 1708, 1635, 1, 0, 0, 0, 1708, 1640, 1, 0, 0, 0, 1708,
		1643, 1, 0, 0, 0, 1708, 1646, 1, 0, 0, 0, 1708, 1652, 1, 0, 0, 0, 1708,
		1657, 1, 0, 0, 0, 1708, 1659, 1, 0, 0, 0, 1708, 1670, 1, 0, 0, 0, 1708,
		1675, 1, 0, 0, 0, 1708, 1686, 1, 0, 0, 0, 1708, 1693, 1, 0, 0, 0, 1708,
		1702, 1, 0, 0, 0, 1709, 25, 1, 0, 0, 0, 1710, 1713, 5, 434, 0, 0, 1711,
		1713, 3, 38, 19, 0, 1712, 1710, 1, 0, 0, 0, 1712, 1711, 1, 0, 0, 0, 1713,
		27, 1, 0, 0, 0, 1714, 1715, 5, 205, 0, 0, 1715, 1716, 3, 178, 89, 0, 1716,
		29, 1, 0, 0, 0, 1717, 1718, 5, 224, 0, 0, 1718, 1719, 5, 338, 0, 0, 1719,
		1720, 5, 187, 0, 0, 1720, 1722, 3, 178, 89, 0, 1721, 1723, 3, 310, 155,
		0, 1722, 1721, 1, 0, 0, 0, 1722, 1723, 1, 0, 0, 0, 1723, 1821, 1, 0, 0,
		0, 1724, 1725, 5, 464, 0, 0, 1725, 1726, 5, 338, 0, 0, 1726, 1821, 3, 178,
		89, 0, 1727, 1728, 5, 266, 0, 0, 1728, 1737, 5, 437, 0, 0, 1729, 1734,
		3, 34, 17, 0, 1730, 1731, 5, 4, 0, 0, 1731, 1733, 3, 34, 17, 0, 1732, 1730,
		1, 0, 0, 0, 1733, 1736, 1, 0, 0, 0, 1734, 1732, 1, 0, 0, 0, 1734, 1735,
		1, 0, 0, 0, 1735, 1738, 1, 0, 0, 0, 1736, 1734, 1, 0, 0, 0, 1737, 1729,
		1, 0, 0, 0, 1737, 1738, 1, 0, 0, 0, 1738, 1821, 1, 0, 0, 0, 1739, 1740,
		5, 467, 0, 0, 1740, 1821, 5, 437, 0, 0, 1741, 1742, 5, 488, 0, 0, 1742,
		1746, 5, 470, 0, 0, 1743, 1747, 5, 73, 0, 0, 1744, 1745, 5, 87, 0, 0, 1745,
		1747, 5, 199, 0, 0, 1746, 1743, 1, 0, 0, 0, 1746, 1744, 1, 0, 0, 0, 1747,
		1748, 1, 0, 0, 0, 1748, 1749, 3, 438, 219, 0, 1749, 1764, 5, 494, 0, 0,
		1750, 1754, 5, 73, 0, 0, 1751, 1752, 5, 87, 0, 0, 1752, 1754, 5, 199, 0,
		0, 1753, 1750, 1, 0, 0, 0, 1753, 1751, 1, 0, 0, 0, 1754, 1755, 1, 0, 0,
		0, 1755, 1765, 3, 438, 219, 0, 1756, 1761, 3, 32, 16, 0, 1757, 1758, 5,
		24, 0, 0, 1758, 1760, 3, 32, 16, 0, 1759, 1757, 1, 0, 0, 0, 1760, 1763,
		1, 0, 0, 0, 1761, 1759, 1, 0, 0, 0, 1761, 1762, 1, 0, 0, 0, 1762, 1765,
		1, 0, 0, 0, 1763, 1761, 1, 0, 0, 0, 1764, 1753, 1, 0, 0, 0, 1764, 1756,
		1, 0, 0, 0, 1765, 1767, 1, 0, 0, 0, 1766, 1768, 5, 184, 0, 0, 1767, 1766,
		1, 0, 0, 0, 1767, 1768, 1, 0, 0, 0, 1768, 1821, 1, 0, 0, 0, 1769, 1770,
		5, 37, 0, 0, 1770, 1771, 5, 414, 0, 0, 1771, 1772, 3, 322, 161, 0, 1772,
		1773, 5, 451, 0, 0, 1773, 1786, 3, 438, 219, 0, 1774, 1775, 7, 11, 0, 0,
		1775, 1776, 5, 2, 0, 0, 1776, 1781, 3, 78, 39, 0, 1777, 1778, 5, 4, 0,
		0, 1778, 1780, 3, 78, 39, 0, 1779, 1777, 1, 0, 0, 0, 1780, 1783, 1, 0,
		0, 0, 1781, 1779, 1, 0, 0, 0, 1781, 1782, 1, 0, 0, 0, 1782, 1784, 1, 0,
		0, 0, 1783, 1781, 1, 0, 0, 0, 1784, 1785, 5, 3, 0, 0, 1785, 1787, 1, 0,
		0, 0, 1786, 1774, 1, 0, 0, 0, 1786, 1787, 1, 0, 0, 0, 1787, 1789, 1, 0,
		0, 0, 1788, 1790, 3, 310, 155, 0, 1789, 1788, 1, 0, 0, 0, 1789, 1790, 1,
		0, 0, 0, 1790, 1821, 1, 0, 0, 0, 1791, 1792, 5, 379, 0, 0, 1792, 1793,
		5, 414, 0, 0, 1793, 1794, 3, 322, 161, 0, 1794, 1795, 5, 187, 0, 0, 1795,
		1808, 3, 438, 219, 0, 1796, 1797, 7, 11, 0, 0, 1797, 1798, 5, 2, 0, 0,
		1798, 1803, 3, 78, 39, 0, 1799, 1800, 5, 4, 0, 0, 1800, 1802, 3, 78, 39,
		0, 1801, 1799, 1, 0, 0, 0, 1802, 1805, 1, 0, 0, 0, 1803, 1801, 1, 0, 0,
		0, 1803, 1804, 1, 0, 0, 0, 1804, 1806, 1, 0, 0, 0, 1805, 1803, 1, 0, 0,
		0, 1806, 1807, 5, 3, 0, 0, 1807, 1809, 1, 0, 0, 0, 1808, 1796, 1, 0, 0,
		0, 1808, 1809, 1, 0, 0, 0, 1809, 1811, 1, 0, 0, 0, 1810, 1812, 3, 310,
		155, 0, 1811, 1810, 1, 0, 0, 0, 1811, 1812, 1, 0, 0, 0, 1812, 1821, 1,
		0, 0, 0, 1813, 1814, 5, 421, 0, 0, 1814, 1818, 5, 452, 0, 0, 1815, 1816,
		5, 494, 0, 0, 1816, 1817, 5, 92, 0, 0, 1817, 1819, 5, 414, 0, 0, 1818,
		1815, 1, 0, 0, 0, 1818, 1819, 1, 0, 0, 0, 1819, 1821, 1, 0, 0, 0, 1820,
		1717, 1, 0, 0, 0, 1820, 1724, 1, 0, 0, 0, 1820, 1727, 1, 0, 0, 0, 1820,
		1739, 1, 0, 0, 0, 1820, 1741, 1, 0, 0, 0, 1820, 1769, 1, 0, 0, 0, 1820,
		1791, 1, 0, 0, 0, 1820, 1813, 1, 0, 0, 0, 1821, 31, 1, 0, 0, 0, 1822, 1823,
		5, 436, 0, 0, 1823, 1826, 3, 322, 161, 0, 1824, 1825, 5, 319, 0, 0, 1825,
		1827, 3, 438, 219, 0, 1826, 1824, 1, 0, 0, 0, 1826, 1827, 1, 0, 0, 0, 1827,
		33, 1, 0, 0, 0, 1828, 1831, 3, 322, 161, 0, 1829, 1830, 5, 28, 0, 0, 1830,
		1832, 3, 178, 89, 0, 1831, 1829, 1, 0, 0, 0, 1831, 1832, 1, 0, 0, 0, 1832,
		1841, 1, 0, 0, 0, 1833, 1835, 5, 358, 0, 0, 1834, 1836, 5, 262, 0, 0, 1835,
		1834, 1, 0, 0, 0, 1835, 1836, 1, 0, 0, 0, 1836, 1842, 1, 0, 0, 0, 1837,
		1839, 5, 268, 0, 0, 1838, 1837, 1, 0, 0, 0, 1838, 1839, 1, 0, 0, 0, 1839,
		1840, 1, 0, 0, 0, 1840, 1842, 5, 497, 0, 0, 1841, 1833, 1, 0, 0, 0, 1841,
		1838, 1, 0, 0, 0, 1842, 35, 1, 0, 0, 0, 1843, 1844, 5, 410, 0, 0, 1844,
		1845, 5, 392, 0, 0, 1845, 1852, 5, 340, 0, 0, 1846, 1850, 5, 182, 0, 0,
		1847, 1851, 3, 186, 93, 0, 1848, 1849, 5, 387, 0, 0, 1849, 1851, 3, 438,
		219, 0, 1850, 1847, 1, 0, 0, 0, 1850, 1848, 1, 0, 0, 0, 1851, 1853, 1,
		0, 0, 0, 1852, 1846, 1, 0, 0, 0, 1852, 1853, 1, 0, 0, 0, 1853, 2248, 1,
		0, 0, 0, 1854, 1855, 5, 410, 0, 0, 1855, 1856, 5, 426, 0, 0, 1856, 1862,
		5, 340, 0, 0, 1857, 1860, 5, 475, 0, 0, 1858, 1859, 5, 182, 0, 0, 1859,
		1861, 3, 178, 89, 0, 1860, 1858, 1, 0, 0, 0, 1860, 1861, 1, 0, 0, 0, 1861,
		1863, 1, 0, 0, 0, 1862, 1857, 1, 0, 0, 0, 1862, 1863, 1, 0, 0, 0, 1863,
		2248, 1, 0, 0, 0, 1864, 1865, 5, 410, 0, 0, 1865, 1866, 5, 426, 0, 0, 1866,
		2248, 7, 12, 0, 0, 1867, 1868, 5, 410, 0, 0, 1868, 1869, 5, 309, 0, 0,
		1869, 1872, 5, 437, 0, 0, 1870, 1871, 7, 5, 0, 0, 1871, 1873, 3, 322, 161,
		0, 1872, 1870, 1, 0, 0, 0, 1872, 1873, 1, 0, 0, 0, 1873, 1875, 1, 0, 0,
		0, 1874, 1876, 3, 80, 40, 0, 1875, 1874, 1, 0, 0, 0, 1875, 1876, 1, 0,
		0, 0, 1876, 2248, 1, 0, 0, 0, 1877, 1878, 5, 410, 0, 0, 1878, 1879, 5,
		436, 0, 0, 1879, 1882, 5, 424, 0, 0, 1880, 1881, 7, 5, 0, 0, 1881, 1883,
		3, 322, 161, 0, 1882, 1880, 1, 0, 0, 0, 1882, 1883, 1, 0, 0, 0, 1883, 1885,
		1, 0, 0, 0, 1884, 1886, 3, 80, 40, 0, 1885, 1884, 1, 0, 0, 0, 1885, 1886,
		1, 0, 0, 0, 1886, 2248, 1, 0, 0, 0, 1887, 1889, 5, 410, 0, 0, 1888, 1890,
		5, 190, 0, 0, 1889, 1888, 1, 0, 0, 0, 1889, 1890, 1, 0, 0, 0, 1890, 1891,
		1, 0, 0, 0, 1891, 1894, 5, 437, 0, 0, 1892, 1893, 7, 5, 0, 0, 1893, 1895,
		3, 322, 161, 0, 1894, 1892, 1, 0, 0, 0, 1894, 1895, 1, 0, 0, 0, 1895, 1897,
		1, 0, 0, 0, 1896, 1898, 3, 80, 40, 0, 1897, 1896, 1, 0, 0, 0, 1897, 1898,
		1, 0, 0, 0, 1898, 2248, 1, 0, 0, 0, 1899, 1901, 5, 410, 0, 0, 1900, 1902,
		5, 190, 0, 0, 1901, 1900, 1, 0, 0, 0, 1901, 1902, 1, 0, 0, 0, 1902, 1903,
		1, 0, 0, 0, 1903, 1906, 5, 487, 0, 0, 1904, 1905, 7, 5, 0, 0, 1905, 1907,
		3, 322, 161, 0, 1906, 1904, 1, 0, 0, 0, 1906, 1907, 1, 0, 0, 0, 1907, 1909,
		1, 0, 0, 0, 1908, 1910, 3, 80, 40, 0, 1909, 1908, 1, 0, 0, 0, 1909, 1910,
		1, 0, 0, 0, 1910, 2248, 1, 0, 0, 0, 1911, 1912, 5, 410, 0, 0, 1912, 1913,
		5, 99, 0, 0, 1913, 1914, 5, 278, 0, 0, 1914, 1915, 5, 486, 0, 0, 1915,
		2248, 3, 322, 161, 0, 1916, 1917, 5, 410, 0, 0, 1917, 1919, 5, 99, 0, 0,
		1918, 1920, 7, 9, 0, 0, 1919, 1918, 1, 0, 0, 0, 1919, 1920, 1, 0, 0, 0,
		1920, 1921, 1, 0, 0, 0, 1921, 1922, 5, 191, 0, 0, 1922, 1923, 3, 388, 194,
		0, 1923, 1925, 5, 2, 0, 0, 1924, 1926, 3, 126, 63, 0, 1925, 1924, 1, 0,
		0, 0, 1925, 1926, 1, 0, 0, 0, 1926, 1927, 1, 0, 0, 0, 1927, 1930, 5, 3,
		0, 0, 1928, 1929, 7, 5, 0, 0, 1929, 1931, 3, 322, 161, 0, 1930, 1928, 1,
		0, 0, 0, 1930, 1931, 1, 0, 0, 0, 1931, 2248, 1, 0, 0, 0, 1932, 1933, 5,
		410, 0, 0, 1933, 1936, 7, 13, 0, 0, 1934, 1935, 5, 187, 0, 0, 1935, 1937,
		3, 438, 219, 0, 1936, 1934, 1, 0, 0, 0, 1936, 1937, 1, 0, 0, 0, 1937, 1939,
		1, 0, 0, 0, 1938, 1940, 3, 80, 40, 0, 1939, 1938, 1, 0, 0, 0, 1939, 1940,
		1, 0, 0, 0, 1940, 2248, 1, 0, 0, 0, 1941, 1943, 5, 410, 0, 0, 1942, 1944,
		5, 190, 0, 0, 1943, 1942, 1, 0, 0, 0, 1943, 1944, 1, 0, 0, 0, 1944, 1945,
		1, 0, 0, 0, 1945, 1946, 7, 14, 0, 0, 1946, 1947, 7, 5, 0, 0, 1947, 1950,
		3, 322, 161, 0, 1948, 1949, 7, 5, 0, 0, 1949, 1951, 3, 322, 161, 0, 1950,
		1948, 1, 0, 0, 0, 1950, 1951, 1, 0, 0, 0, 1951, 1953, 1, 0, 0, 0, 1952,
		1954, 3, 80, 40, 0, 1953, 1952, 1, 0, 0, 0, 1953, 1954, 1, 0, 0, 0, 1954,
		2248, 1, 0, 0, 0, 1955, 1956, 5, 410, 0, 0, 1956, 1957, 5, 261, 0, 0, 1957,
		1970, 5, 489, 0, 0, 1958, 1959, 7, 5, 0, 0, 1959, 1961, 3, 322, 161, 0,
		1960, 1958, 1, 0, 0, 0, 1960, 1961, 1, 0, 0, 0, 1961, 1963, 1, 0, 0, 0,
		1962, 1964, 3, 80, 40, 0, 1963, 1962, 1, 0, 0, 0, 1963, 1964, 1, 0, 0,
		0, 1964, 1966, 1, 0, 0, 0, 1965, 1967, 3, 292, 146, 0, 1966, 1965, 1, 0,
		0, 0, 1966, 1967, 1, 0, 0, 0, 1967, 1971, 1, 0, 0, 0, 1968, 1969, 5, 307,
		0, 0, 1969, 1971, 5, 526, 0, 0, 1970, 1960, 1, 0, 0, 0, 1970, 1968, 1,
		0, 0, 0, 1971, 2248, 1, 0, 0, 0, 1972, 1974, 5, 410, 0, 0, 1973, 1975,
		5, 427, 0, 0, 1974, 1973, 1, 0, 0, 0, 1974, 1975, 1, 0, 0, 0, 1975, 1976,
		1, 0, 0, 0, 1976, 1979, 5, 261, 0, 0, 1977, 1978, 7, 5, 0, 0, 1978, 1980,
		3, 322, 161, 0, 1979, 1977, 1, 0, 0, 0, 1979, 1980, 1, 0, 0, 0, 1980, 1982,
		1, 0, 0, 0, 1981, 1983, 3, 80, 40, 0, 1982, 1981, 1, 0, 0, 0, 1982, 1983,
		1, 0, 0, 0, 1983, 1985, 1, 0, 0, 0, 1984, 1986, 3, 288, 144, 0, 1985, 1984,
		1, 0, 0, 0, 1985, 1986, 1, 0, 0, 0, 1986, 1988, 1, 0, 0, 0, 1987, 1989,
		3, 292, 146, 0, 1988, 1987, 1, 0, 0, 0, 1988, 1989, 1, 0, 0, 0, 1989, 2248,
		1, 0, 0, 0, 1990, 1991, 5, 410, 0, 0, 1991, 1994, 5, 167, 0, 0, 1992, 1993,
		7, 5, 0, 0, 1993, 1995, 3, 322, 161, 0, 1994, 1992, 1, 0, 0, 0, 1994, 1995,
		1, 0, 0, 0, 1995, 1997, 1, 0, 0, 0, 1996, 1998, 3, 80, 40, 0, 1997, 1996,
		1, 0, 0, 0, 1997, 1998, 1, 0, 0, 0, 1998, 2000, 1, 0, 0, 0, 1999, 2001,
		3, 288, 144, 0, 2000, 1999, 1, 0, 0, 0, 2000, 2001, 1, 0, 0, 0, 2001, 2003,
		1, 0, 0, 0, 2002, 2004, 3, 292, 146, 0, 2003, 2002, 1, 0, 0, 0, 2003, 2004,
		1, 0, 0, 0, 2004, 2248, 1, 0, 0, 0, 2005, 2006, 5, 410, 0, 0, 2006, 2007,
		5, 21, 0, 0, 2007, 2012, 5, 436, 0, 0, 2008, 2013, 5, 390, 0, 0, 2009,
		2010, 5, 278, 0, 0, 2010, 2013, 5, 486, 0, 0, 2011, 2013, 5, 79, 0, 0,
		2012, 2008, 1, 0, 0, 0, 2012, 2009, 1, 0, 0, 0, 2012, 2011, 1, 0, 0, 0,
		2013, 2016, 1, 0, 0, 0, 2014, 2015, 7, 5, 0, 0, 2015, 2017, 3, 322, 161,
		0, 2016, 2014, 1, 0, 0, 0, 2016, 2017, 1, 0, 0, 0, 2017, 2019, 1, 0, 0,
		0, 2018, 2020, 3, 80, 40, 0, 2019, 2018, 1, 0, 0, 0, 2019, 2020, 1, 0,
		0, 0, 2020, 2022, 1, 0, 0, 0, 2021, 2023, 3, 288, 144, 0, 2022, 2021, 1,
		0, 0, 0, 2022, 2023, 1, 0, 0, 0, 2023, 2025, 1, 0, 0, 0, 2024, 2026, 3,
		292, 146, 0, 2025, 2024, 1, 0, 0, 0, 2025, 2026, 1, 0, 0, 0, 2026, 2248,
		1, 0, 0, 0, 2027, 2028, 5, 410, 0, 0, 2028, 2030, 5, 110, 0, 0, 2029, 2031,
		5, 20, 0, 0, 2030, 2029, 1, 0, 0, 0, 2030, 2031, 1, 0, 0, 0, 2031, 2034,
		1, 0, 0, 0, 2032, 2033, 5, 187, 0, 0, 2033, 2035, 3, 322, 161, 0, 2034,
		2032, 1, 0, 0, 0, 2034, 2035, 1, 0, 0, 0, 2035, 2037, 1, 0, 0, 0, 2036,
		2038, 3, 288, 144, 0, 2037, 2036, 1, 0, 0, 0, 2037, 2038, 1, 0, 0, 0, 2038,
		2040, 1, 0, 0, 0, 2039, 2041, 3, 310, 155, 0, 2040, 2039, 1, 0, 0, 0, 2040,
		2041, 1, 0, 0, 0, 2041, 2248, 1, 0, 0, 0, 2042, 2044, 5, 410, 0, 0, 2043,
		2045, 5, 443, 0, 0, 2044, 2043, 1, 0, 0, 0, 2044, 2045, 1, 0, 0, 0, 2045,
		2046, 1, 0, 0, 0, 2046, 2047, 5, 320, 0, 0, 2047, 2048, 5, 187, 0, 0, 2048,
		2050, 3, 322, 161, 0, 2049, 2051, 3, 80, 40, 0, 2050, 2049, 1, 0, 0, 0,
		2050, 2051, 1, 0, 0, 0, 2051, 2053, 1, 0, 0, 0, 2052, 2054, 3, 288, 144,
		0, 2053, 2052, 1, 0, 0, 0, 2053, 2054, 1, 0, 0, 0, 2054, 2056, 1, 0, 0,
		0, 2055, 2057, 3, 292, 146, 0, 2056, 2055, 1, 0, 0, 0, 2056, 2057, 1, 0,
		0, 0, 2057, 2248, 1, 0, 0, 0, 2058, 2059, 5, 410, 0, 0, 2059, 2060, 5,
		439, 0, 0, 2060, 2248, 5, 531, 0, 0, 2061, 2062, 5, 410, 0, 0, 2062, 2063,
		5, 440, 0, 0, 2063, 2064, 5, 187, 0, 0, 2064, 2066, 3, 322, 161, 0, 2065,
		2067, 3, 158, 79, 0, 2066, 2065, 1, 0, 0, 0, 2066, 2067, 1, 0, 0, 0, 2067,
		2069, 1, 0, 0, 0, 2068, 2070, 3, 80, 40, 0, 2069, 2068, 1, 0, 0, 0, 2069,
		2070, 1, 0, 0, 0, 2070, 2072, 1, 0, 0, 0, 2071, 2073, 3, 288, 144, 0, 2072,
		2071, 1, 0, 0, 0, 2072, 2073, 1, 0, 0, 0, 2073, 2075, 1, 0, 0, 0, 2074,
		2076, 3, 292, 146, 0, 2075, 2074, 1, 0, 0, 0, 2075, 2076, 1, 0, 0, 0, 2076,
		2248, 1, 0, 0, 0, 2077, 2078, 5, 410, 0, 0, 2078, 2081, 5, 37, 0, 0, 2079,
		2080, 7, 5, 0, 0, 2080, 2082, 3, 322, 161, 0, 2081, 2079, 1, 0, 0, 0, 2081,
		2082, 1, 0, 0, 0, 2082, 2084, 1, 0, 0, 0, 2083, 2085, 3, 80, 40, 0, 2084,
		2083, 1, 0, 0, 0, 2084, 2085, 1, 0, 0, 0, 2085, 2248, 1, 0, 0, 0, 2086,
		2088, 5, 410, 0, 0, 2087, 2089, 5, 53, 0, 0, 2088, 2087, 1, 0, 0, 0, 2088,
		2089, 1, 0, 0, 0, 2089, 2090, 1, 0, 0, 0, 2090, 2093, 5, 379, 0, 0, 2091,
		2092, 7, 5, 0, 0, 2092, 2094, 3, 322, 161, 0, 2093, 2091, 1, 0, 0, 0, 2093,
		2094, 1, 0, 0, 0, 2094, 2096, 1, 0, 0, 0, 2095, 2097, 3, 80, 40, 0, 2096,
		2095, 1, 0, 0, 0, 2096, 2097, 1, 0, 0, 0, 2097, 2248, 1, 0, 0, 0, 2098,
		2099, 5, 410, 0, 0, 2099, 2101, 5, 378, 0, 0, 2100, 2102, 3, 80, 40, 0,
		2101, 2100, 1, 0, 0, 0, 2101, 2102, 1, 0, 0, 0, 2102, 2104, 1, 0, 0, 0,
		2103, 2105, 3, 288, 144, 0, 2104, 2103, 1, 0, 0, 0, 2104, 2105, 1, 0, 0,
		0, 2105, 2107, 1, 0, 0, 0, 2106, 2108, 3, 292, 146, 0, 2107, 2106, 1, 0,
		0, 0, 2107, 2108, 1, 0, 0, 0, 2108, 2248, 1, 0, 0, 0, 2109, 2110, 5, 410,
		0, 0, 2110, 2111, 5, 496, 0, 0, 2111, 2113, 5, 201, 0, 0, 2112, 2114, 3,
		80, 40, 0, 2113, 2112, 1, 0, 0, 0, 2113, 2114, 1, 0, 0, 0, 2114, 2248,
		1, 0, 0, 0, 2115, 2116, 5, 410, 0, 0, 2116, 2117, 5, 414, 0, 0, 2117, 2118,
		5, 307, 0, 0, 2118, 2120, 3, 438, 219, 0, 2119, 2121, 3, 80, 40, 0, 2120,
		2119, 1, 0, 0, 0, 2120, 2121, 1, 0, 0, 0, 2121, 2248, 1, 0, 0, 0, 2122,
		2124, 5, 410, 0, 0, 2123, 2125, 5, 190, 0, 0, 2124, 2123, 1, 0, 0, 0, 2124,
		2125, 1, 0, 0, 0, 2125, 2127, 1, 0, 0, 0, 2126, 2128, 5, 57, 0, 0, 2127,
		2126, 1, 0, 0, 0, 2127, 2128, 1, 0, 0, 0, 2128, 2129, 1, 0, 0, 0, 2129,
		2132, 5, 192, 0, 0, 2130, 2131, 7, 5, 0, 0, 2131, 2133, 3, 322, 161, 0,
		2132, 2130, 1, 0, 0, 0, 2132, 2133, 1, 0, 0, 0, 2133, 2135, 1, 0, 0, 0,
		2134, 2136, 3, 80, 40, 0, 2135, 2134, 1, 0, 0, 0, 2135, 2136, 1, 0, 0,
		0, 2136, 2248, 1, 0, 0, 0, 2137, 2138, 5, 410, 0, 0, 2138, 2140, 5, 195,
		0, 0, 2139, 2141, 5, 190, 0, 0, 2140, 2139, 1, 0, 0, 0, 2140, 2141, 1,
		0, 0, 0, 2141, 2142, 1, 0, 0, 0, 2142, 2144, 5, 192, 0, 0, 2143, 2145,
		3, 80, 40, 0, 2144, 2143, 1, 0, 0, 0, 2144, 2145, 1, 0, 0, 0, 2145, 2248,
		1, 0, 0, 0, 2146, 2147, 5, 410, 0, 0, 2147, 2150, 5, 460, 0, 0, 2148, 2149,
		7, 5, 0, 0, 2149, 2151, 3, 322, 161, 0, 2150, 2148, 1, 0, 0, 0, 2150, 2151,
		1, 0, 0, 0, 2151, 2248, 1, 0, 0, 0, 2152, 2153, 5, 410, 0, 0, 2153, 2154,
		7, 15, 0, 0, 2154, 2155, 7, 5, 0, 0, 2155, 2158, 3, 322, 161, 0, 2156,
		2157, 7, 5, 0, 0, 2157, 2159, 3, 322, 161, 0, 2158, 2156, 1, 0, 0, 0, 2158,
		2159, 1, 0, 0, 0, 2159, 2248, 1, 0, 0, 0, 2160, 2161, 5, 410, 0, 0, 2161,
		2164, 5, 452, 0, 0, 2162, 2163, 7, 5, 0, 0, 2163, 2165, 3, 322, 161, 0,
		2164, 2162, 1, 0, 0, 0, 2164, 2165, 1, 0, 0, 0, 2165, 2167, 1, 0, 0, 0,
		2166, 2168, 3, 80, 40, 0, 2167, 2166, 1, 0, 0, 0, 2167, 2168, 1, 0, 0,
		0, 2168, 2248, 1, 0, 0, 0, 2169, 2170, 5, 410, 0, 0, 2170, 2171, 5, 60,
		0, 0, 2171, 2172, 5, 210, 0, 0, 2172, 2248, 5, 526, 0, 0, 2173, 2174, 5,
		410, 0, 0, 2174, 2175, 5, 66, 0, 0, 2175, 2176, 5, 363, 0, 0, 2176, 2178,
		5, 42, 0, 0, 2177, 2179, 3, 80, 40, 0, 2178, 2177, 1, 0, 0, 0, 2178, 2179,
		1, 0, 0, 0, 2179, 2248, 1, 0, 0, 0, 2180, 2181, 5, 410, 0, 0, 2181, 2182,
		5, 352, 0, 0, 2182, 2193, 5, 423, 0, 0, 2183, 2184, 5, 182, 0, 0, 2184,
		2194, 3, 438, 219, 0, 2185, 2186, 5, 187, 0, 0, 2186, 2191, 3, 322, 161,
		0, 2187, 2189, 5, 20, 0, 0, 2188, 2190, 5, 484, 0, 0, 2189, 2188, 1, 0,
		0, 0, 2189, 2190, 1, 0, 0, 0, 2190, 2192, 1, 0, 0, 0, 2191, 2187, 1, 0,
		0, 0, 2191, 2192, 1, 0, 0, 0, 2192, 2194, 1, 0, 0, 0, 2193, 2183, 1, 0,
		0, 0, 2193, 2185, 1, 0, 0, 0, 2193, 2194, 1, 0, 0, 0, 2194, 2248, 1, 0,
		0, 0, 2195, 2196, 5, 410, 0, 0, 2196, 2197, 5, 56, 0, 0, 2197, 2200, 5,
		219, 0, 0, 2198, 2199, 7, 5, 0, 0, 2199, 2201, 3, 322, 161, 0, 2200, 2198,
		1, 0, 0, 0, 2200, 2201, 1, 0, 0, 0, 2201, 2203, 1, 0, 0, 0, 2202, 2204,
		3, 80, 40, 0, 2203, 2202, 1, 0, 0, 0, 2203, 2204, 1, 0, 0, 0, 2204, 2206,
		1, 0, 0, 0, 2205, 2207, 3, 288, 144, 0, 2206, 2205, 1, 0, 0, 0, 2206, 2207,
		1, 0, 0, 0, 2207, 2209, 1, 0, 0, 0, 2208, 2210, 3, 292, 146, 0, 2209, 2208,
		1, 0, 0, 0, 2209, 2210, 1, 0, 0, 0, 2210, 2248, 1, 0, 0, 0, 2211, 2215,
		5, 410, 0, 0, 2212, 2216, 5, 74, 0, 0, 2213, 2214, 5, 87, 0, 0, 2214, 2216,
		5, 201, 0, 0, 2215, 2212, 1, 0, 0, 0, 2215, 2213, 1, 0, 0, 0, 2216, 2248,
		1, 0, 0, 0, 2217, 2218, 5, 410, 0, 0, 2218, 2219, 5, 374, 0, 0, 2219, 2220,
		5, 424, 0, 0, 2220, 2221, 5, 187, 0, 0, 2221, 2223, 3, 78, 39, 0, 2222,
		2224, 3, 80, 40, 0, 2223, 2222, 1, 0, 0, 0, 2223, 2224, 1, 0, 0, 0, 2224,
		2248, 1, 0, 0, 0, 2225, 2226, 5, 410, 0, 0, 2226, 2229, 5, 97, 0, 0, 2227,
		2228, 7, 5, 0, 0, 2228, 2230, 3, 322, 161, 0, 2229, 2227, 1, 0, 0, 0, 2229,
		2230, 1, 0, 0, 0, 2230, 2232, 1, 0, 0, 0, 2231, 2233, 3, 244, 122, 0, 2232,
		2231, 1, 0, 0, 0, 2232, 2233, 1, 0, 0, 0, 2233, 2235, 1, 0, 0, 0, 2234,
		2236, 3, 288, 144, 0, 2235, 2234, 1, 0, 0, 0, 2235, 2236, 1, 0, 0, 0, 2236,
		2238, 1, 0, 0, 0, 2237, 2239, 3, 292, 146, 0, 2238, 2237, 1, 0, 0, 0, 2238,
		2239, 1, 0, 0, 0, 2239, 2248, 1, 0, 0, 0, 2240, 2241, 5, 410, 0, 0, 2241,
		2242, 5, 488, 0, 0, 2242, 2243, 5, 470, 0, 0, 2243, 2245, 5, 239, 0, 0,
		2244, 2246, 3, 80, 40, 0, 2245, 2244, 1, 0, 0, 0, 2245, 2246, 1, 0, 0,
		0, 2246, 2248, 1, 0, 0, 0, 2247, 1843, 1, 0, 0, 0, 2247, 1854, 1, 0, 0,
		0, 2247, 1864, 1, 0, 0, 0, 2247, 1867, 1, 0, 0, 0, 2247, 1877, 1, 0, 0,
		0, 2247, 1887, 1, 0, 0, 0, 2247, 1899, 1, 0, 0, 0, 2247, 1911, 1, 0, 0,
		0, 2247, 1916, 1, 0, 0, 0, 2247, 1932, 1, 0, 0, 0, 2247, 1941, 1, 0, 0,
		0, 2247, 1955, 1, 0, 0, 0, 2247, 1972, 1, 0, 0, 0, 2247, 1990, 1, 0, 0,
		0, 2247, 2005, 1, 0, 0, 0, 2247, 2027, 1, 0, 0, 0, 2247, 2042, 1, 0, 0,
		0, 2247, 2058, 1, 0, 0, 0, 2247, 2061, 1, 0, 0, 0, 2247, 2077, 1, 0, 0,
		0, 2247, 2086, 1, 0, 0, 0, 2247, 2098, 1, 0, 0, 0, 2247, 2109, 1, 0, 0,
		0, 2247, 2115, 1, 0, 0, 0, 2247, 2122, 1, 0, 0, 0, 2247, 2137, 1, 0, 0,
		0, 2247, 2146, 1, 0, 0, 0, 2247, 2152, 1, 0, 0, 0, 2247, 2160, 1, 0, 0,
		0, 2247, 2169, 1, 0, 0, 0, 2247, 2173, 1, 0, 0, 0, 2247, 2180, 1, 0, 0,
		0, 2247, 2195, 1, 0, 0, 0, 2247, 2211, 1, 0, 0, 0, 2247, 2217, 1, 0, 0,
		0, 2247, 2225, 1, 0, 0, 0, 2247, 2240, 1, 0, 0, 0, 2248, 37, 1, 0, 0, 0,
		2249, 2250, 5, 99, 0, 0, 2250, 2251, 5, 391, 0, 0, 2251, 2252, 5, 261,
		0, 0, 2252, 2255, 3, 322, 161, 0, 2253, 2254, 5, 307, 0, 0, 2254, 2256,
		3, 438, 219, 0, 2255, 2253, 1, 0, 0, 0, 2255, 2256, 1, 0, 0, 0, 2256, 2259,
		1, 0, 0, 0, 2257, 2258, 5, 494, 0, 0, 2258, 2260, 7, 16, 0, 0, 2259, 2257,
		1, 0, 0, 0, 2259, 2260, 1, 0, 0, 0, 2260, 2269, 1, 0, 0, 0, 2261, 2266,
		3, 42, 21, 0, 2262, 2263, 5, 4, 0, 0, 2263, 2265, 3, 42, 21, 0, 2264, 2262,
		1, 0, 0, 0, 2265, 2268, 1, 0, 0, 0, 2266, 2264, 1, 0, 0, 0, 2266, 2267,
		1, 0, 0, 0, 2267, 2270, 1, 0, 0, 0, 2268, 2266, 1, 0, 0, 0, 2269, 2261,
		1, 0, 0, 0, 2269, 2270, 1, 0, 0, 0, 2270, 2272, 1, 0, 0, 0, 2271, 2273,
		3, 310, 155, 0, 2272, 2271, 1, 0, 0, 0, 2272, 2273, 1, 0, 0, 0, 2273, 2274,
		1, 0, 0, 0, 2274, 2275, 5, 187, 0, 0, 2275, 2276, 3, 438, 219, 0, 2276,
		2277, 5, 2, 0, 0, 2277, 2278, 3, 312, 156, 0, 2278, 2280, 5, 3, 0, 0, 2279,
		2281, 3, 426, 213, 0, 2280, 2279, 1, 0, 0, 0, 2280, 2281, 1, 0, 0, 0, 2281,
		39, 1, 0, 0, 0, 2282, 2283, 5, 261, 0, 0, 2283, 2289, 3, 218, 109, 0, 2284,
		2285, 5, 348, 0, 0, 2285, 2286, 5, 2, 0, 0, 2286, 2287, 3, 312, 156, 0,
		2287, 2288, 5, 3, 0, 0, 2288, 2290, 1, 0, 0, 0, 2289, 2284, 1, 0, 0, 0,
		2289, 2290, 1, 0, 0, 0, 2290, 2292, 1, 0, 0, 0, 2291, 2293, 3, 426, 213,
		0, 2292, 2291, 1, 0, 0, 0, 2292, 2293, 1, 0, 0, 0, 2293, 2382, 1, 0, 0,
		0, 2294, 2295, 5, 99, 0, 0, 2295, 2296, 5, 434, 0, 0, 2296, 2297, 3, 322,
		161, 0, 2297, 2298, 5, 2, 0, 0, 2298, 2299, 3, 56, 28, 0, 2299, 2300, 5,
		3, 0, 0, 2300, 2301, 5, 187, 0, 0, 2301, 2302, 5, 44, 0, 0, 2302, 2303,
		5, 2, 0, 0, 2303, 2304, 3, 312, 156, 0, 2304, 2306, 5, 3, 0, 0, 2305, 2307,
		3, 310, 155, 0, 2306, 2305, 1, 0, 0, 0, 2306, 2307, 1, 0, 0, 0, 2307, 2382,
		1, 0, 0, 0, 2308, 2309, 5, 425, 0, 0, 2309, 2310, 5, 434, 0, 0, 2310, 2311,
		5, 239, 0, 0, 2311, 2382, 3, 322, 161, 0, 2312, 2313, 5, 381, 0, 0, 2313,
		2314, 5, 434, 0, 0, 2314, 2315, 5, 239, 0, 0, 2315, 2382, 3, 322, 161,
		0, 2316, 2317, 5, 327, 0, 0, 2317, 2318, 5, 434, 0, 0, 2318, 2319, 5, 239,
		0, 0, 2319, 2382, 3, 322, 161, 0, 2320, 2321, 5, 327, 0, 0, 2321, 2322,
		5, 391, 0, 0, 2322, 2323, 5, 261, 0, 0, 2323, 2324, 5, 182, 0, 0, 2324,
		2382, 3, 322, 161, 0, 2325, 2326, 5, 327, 0, 0, 2326, 2327, 5, 20, 0, 0,
		2327, 2328, 5, 391, 0, 0, 2328, 2382, 5, 261, 0, 0, 2329, 2330, 5, 381,
		0, 0, 2330, 2331, 5, 391, 0, 0, 2331, 2332, 5, 261, 0, 0, 2332, 2333, 5,
		182, 0, 0, 2333, 2382, 3, 322, 161, 0, 2334, 2335, 5, 381, 0, 0, 2335,
		2336, 5, 20, 0, 0, 2336, 2337, 5, 391, 0, 0, 2337, 2382, 5, 261, 0, 0,
		2338, 2339, 5, 425, 0, 0, 2339, 2340, 5, 391, 0, 0, 2340, 2341, 5, 261,
		0, 0, 2341, 2342, 5, 182, 0, 0, 2342, 2382, 3, 322, 161, 0, 2343, 2345,
		5, 410, 0, 0, 2344, 2346, 5, 20, 0, 0, 2345, 2344, 1, 0, 0, 0, 2345, 2346,
		1, 0, 0, 0, 2346, 2347, 1, 0, 0, 0, 2347, 2348, 5, 391, 0, 0, 2348, 2354,
		5, 261, 0, 0, 2349, 2350, 5, 182, 0, 0, 2350, 2355, 3, 322, 161, 0, 2351,
		2353, 3, 80, 40, 0, 2352, 2351, 1, 0, 0, 0, 2352, 2353, 1, 0, 0, 0, 2353,
		2355, 1, 0, 0, 0, 2354, 2349, 1, 0, 0, 0, 2354, 2352, 1, 0, 0, 0, 2355,
		2382, 1, 0, 0, 0, 2356, 2357, 5, 410, 0, 0, 2357, 2358, 5, 391, 0, 0, 2358,
		2359, 5, 261, 0, 0, 2359, 2362, 5, 441, 0, 0, 2360, 2361, 7, 5, 0, 0, 2361,
		2363, 3, 438, 219, 0, 2362, 2360, 1, 0, 0, 0, 2362, 2363, 1, 0, 0, 0, 2363,
		2365, 1, 0, 0, 0, 2364, 2366, 3, 80, 40, 0, 2365, 2364, 1, 0, 0, 0, 2365,
		2366, 1, 0, 0, 0, 2366, 2382, 1, 0, 0, 0, 2367, 2369, 5, 410, 0, 0, 2368,
		2370, 5, 20, 0, 0, 2369, 2368, 1, 0, 0, 0, 2369, 2370, 1, 0, 0, 0, 2370,
		2371, 1, 0, 0, 0, 2371, 2372, 5, 99, 0, 0, 2372, 2373, 5, 391, 0, 0, 2373,
		2374, 5, 261, 0, 0, 2374, 2375, 5, 182, 0, 0, 2375, 2382, 3, 322, 161,
		0, 2376, 2377, 5, 410, 0, 0, 2377, 2378, 5, 99, 0, 0, 2378, 2379, 5, 261,
		0, 0, 2379, 2380, 5, 182, 0, 0, 2380, 2382, 3, 322, 161, 0, 2381, 2282,
		1, 0, 0, 0, 2381, 2294, 1, 0, 0, 0, 2381, 2308, 1, 0, 0, 0, 2381, 2312,
		1, 0, 0, 0, 2381, 2316, 1, 0, 0, 0, 2381, 2320, 1, 0, 0, 0, 2381, 2325,
		1, 0, 0, 0, 2381, 2329, 1, 0, 0, 0, 2381, 2334, 1, 0, 0, 0, 2381, 2338,
		1, 0, 0, 0, 2381, 2343, 1, 0, 0, 0, 2381, 2356, 1, 0, 0, 0, 2381, 2367,
		1, 0, 0, 0, 2381, 2376, 1, 0, 0, 0, 2382, 41, 1, 0, 0, 0, 2383, 2384, 5,
		80, 0, 0, 2384, 2385, 5, 444, 0, 0, 2385, 2386, 5, 59, 0, 0, 2386, 2394,
		5, 526, 0, 0, 2387, 2394, 3, 52, 26, 0, 2388, 2394, 3, 50, 25, 0, 2389,
		2394, 3, 48, 24, 0, 2390, 2394, 3, 46, 23, 0, 2391, 2394, 3, 44, 22, 0,
		2392, 2394, 3, 158, 79, 0, 2393, 2383, 1, 0, 0, 0, 2393, 2387, 1, 0, 0,
		0, 2393, 2388, 1, 0, 0, 0, 2393, 2389, 1, 0, 0, 0, 2393, 2390, 1, 0, 0,
		0, 2393, 2391, 1, 0, 0, 0, 2393, 2392, 1, 0, 0, 0, 2394, 43, 1, 0, 0, 0,
		2395, 2396, 5, 312, 0, 0, 2396, 2397, 5, 59, 0, 0, 2397, 2398, 3, 438,
		219, 0, 2398, 45, 1, 0, 0, 0, 2399, 2400, 5, 126, 0, 0, 2400, 2401, 5,
		307, 0, 0, 2401, 2402, 3, 370, 185, 0, 2402, 47, 1, 0, 0, 0, 2403, 2404,
		5, 492, 0, 0, 2404, 2405, 3, 370, 185, 0, 2405, 49, 1, 0, 0, 0, 2406, 2407,
		5, 341, 0, 0, 2407, 2408, 5, 177, 0, 0, 2408, 2409, 3, 370, 185, 0, 2409,
		51, 1, 0, 0, 0, 2410, 2411, 5, 80, 0, 0, 2411, 2412, 5, 2, 0, 0, 2412,
		2417, 3, 54, 27, 0, 2413, 2414, 5, 4, 0, 0, 2414, 2416, 3, 54, 27, 0, 2415,
		2413, 1, 0, 0, 0, 2416, 2419, 1, 0, 0, 0, 2417, 2415, 1, 0, 0, 0, 2417,
		2418, 1, 0, 0, 0, 2418, 2420, 1, 0, 0, 0, 2419, 2417, 1, 0, 0, 0, 2420,
		2421, 5, 3, 0, 0, 2421, 53, 1, 0, 0, 0, 2422, 2425, 3, 438, 219, 0, 2423,
		2424, 5, 500, 0, 0, 2424, 2426, 3, 370, 185, 0, 2425, 2423, 1, 0, 0, 0,
		2425, 2426, 1, 0, 0, 0, 2426, 2436, 1, 0, 0, 0, 2427, 2428, 5, 2, 0, 0,
		2428, 2431, 3, 438, 219, 0, 2429, 2430, 5, 500, 0, 0, 2430, 2432, 3, 370,
		185, 0, 2431, 2429, 1, 0, 0, 0, 2431, 2432, 1, 0, 0, 0, 2432, 2433, 1,
		0, 0, 0, 2433, 2434, 5, 3, 0, 0, 2434, 2436, 1, 0, 0, 0, 2435, 2422, 1,
		0, 0, 0, 2435, 2427, 1, 0, 0, 0, 2436, 55, 1, 0, 0, 0, 2437, 2442, 3, 58,
		29, 0, 2438, 2439, 5, 4, 0, 0, 2439, 2441, 3, 58, 29, 0, 2440, 2438, 1,
		0, 0, 0, 2441, 2444, 1, 0, 0, 0, 2442, 2440, 1, 0, 0, 0, 2442, 2443, 1,
		0, 0, 0, 2443, 57, 1, 0, 0, 0, 2444, 2442, 1, 0, 0, 0, 2445, 2446, 5, 187,
		0, 0, 2446, 2447, 3, 322, 161, 0, 2447, 2448, 5, 230, 0, 0, 2448, 2450,
		3, 322, 161, 0, 2449, 2451, 3, 158, 79, 0, 2450, 2449, 1, 0, 0, 0, 2450,
		2451, 1, 0, 0, 0, 2451, 2453, 1, 0, 0, 0, 2452, 2454, 3, 300, 150, 0, 2453,
		2452, 1, 0, 0, 0, 2453, 2454, 1, 0, 0, 0, 2454, 59, 1, 0, 0, 0, 2455, 2456,
		5, 364, 0, 0, 2456, 2457, 5, 66, 0, 0, 2457, 2459, 3, 438, 219, 0, 2458,
		2460, 3, 310, 155, 0, 2459, 2458, 1, 0, 0, 0, 2459, 2460, 1, 0, 0, 0, 2460,
		2471, 1, 0, 0, 0, 2461, 2462, 5, 364, 0, 0, 2462, 2463, 5, 111, 0, 0, 2463,
		2465, 3, 322, 161, 0, 2464, 2466, 3, 310, 155, 0, 2465, 2464, 1, 0, 0,
		0, 2465, 2466, 1, 0, 0, 0, 2466, 2471, 1, 0, 0, 0, 2467, 2468, 5, 364,
		0, 0, 2468, 2469, 5, 436, 0, 0, 2469, 2471, 3, 322, 161, 0, 2470, 2455,
		1, 0, 0, 0, 2470, 2461, 1, 0, 0, 0, 2470, 2467, 1, 0, 0, 0, 2471, 61, 1,
		0, 0, 0, 2472, 2473, 5, 72, 0, 0, 2473, 2474, 5, 20, 0, 0, 2474, 2483,
		5, 347, 0, 0, 2475, 2476, 5, 72, 0, 0, 2476, 2478, 5, 247, 0, 0, 2477,
		2479, 3, 438, 219, 0, 2478, 2477, 1, 0, 0, 0, 2478, 2479, 1, 0, 0, 0, 2479,
		2480, 1, 0, 0, 0, 2480, 2481, 7, 5, 0, 0, 2481, 2483, 3, 438, 219, 0, 2482,
		2472, 1, 0, 0, 0, 2482, 2475, 1, 0, 0, 0, 2483, 63, 1, 0, 0, 0, 2484, 2485,
		5, 364, 0, 0, 2485, 2489, 5, 251, 0, 0, 2486, 2490, 5, 20, 0, 0, 2487,
		2488, 5, 182, 0, 0, 2488, 2490, 3, 178, 89, 0, 2489, 2486, 1, 0, 0, 0,
		2489, 2487, 1, 0, 0, 0, 2490, 65, 1, 0, 0, 0, 2491, 2492, 5, 72, 0, 0,
		2492, 2493, 5, 352, 0, 0, 2493, 2498, 5, 423, 0, 0, 2494, 2495, 5, 182,
		0, 0, 2495, 2499, 3, 438, 219, 0, 2496, 2497, 7, 5, 0, 0, 2497, 2499, 3,
		322, 161, 0, 2498, 2494, 1, 0, 0, 0, 2498, 2496, 1, 0, 0, 0, 2499, 2505,
		1, 0, 0, 0, 2500, 2501, 5, 72, 0, 0, 2501, 2502, 5, 20, 0, 0, 2502, 2503,
		5, 352, 0, 0, 2503, 2505, 5, 423, 0, 0, 2504, 2491, 1, 0, 0, 0, 2504, 2500,
		1, 0, 0, 0, 2505, 67, 1, 0, 0, 0, 2506, 2507, 5, 63, 0, 0, 2507, 2510,
		5, 261, 0, 0, 2508, 2509, 7, 5, 0, 0, 2509, 2511, 3, 438, 219, 0, 2510,
		2508, 1, 0, 0, 0, 2510, 2511, 1, 0, 0, 0, 2511, 2513, 1, 0, 0, 0, 2512,
		2514, 3, 80, 40, 0, 2513, 2512, 1, 0, 0, 0, 2513, 2514, 1, 0, 0, 0, 2514,
		2532, 1, 0, 0, 0, 2515, 2516, 5, 63, 0, 0, 2516, 2519, 5, 167, 0, 0, 2517,
		2518, 7, 5, 0, 0, 2518, 2520, 3, 438, 219, 0, 2519, 2517, 1, 0, 0, 0, 2519,
		2520, 1, 0, 0, 0, 2520, 2522, 1, 0, 0, 0, 2521, 2523, 3, 80, 40, 0, 2522,
		2521, 1, 0, 0, 0, 2522, 2523, 1, 0, 0, 0, 2523, 2532, 1, 0, 0, 0, 2524,
		2525, 5, 63, 0, 0, 2525, 2526, 5, 488, 0, 0, 2526, 2527, 5, 470, 0, 0,
		2527, 2529, 5, 239, 0, 0, 2528, 2530, 3, 80, 40, 0, 2529, 2528, 1, 0, 0,
		0, 2529, 2530, 1, 0, 0, 0, 2530, 2532, 1, 0, 0, 0, 2531, 2506, 1, 0, 0,
		0, 2531, 2515, 1, 0, 0, 0, 2531, 2524, 1, 0, 0, 0, 2532, 69, 1, 0, 0, 0,
		2533, 2534, 5, 63, 0, 0, 2534, 2535, 5, 21, 0, 0, 2535, 2540, 5, 436, 0,
		0, 2536, 2541, 5, 390, 0, 0, 2537, 2538, 5, 278, 0, 0, 2538, 2541, 5, 486,
		0, 0, 2539, 2541, 5, 79, 0, 0, 2540, 2536, 1, 0, 0, 0, 2540, 2537, 1, 0,
		0, 0, 2540, 2539, 1, 0, 0, 0, 2541, 2542, 1, 0, 0, 0, 2542, 2543, 5, 187,
		0, 0, 2543, 2554, 3, 322, 161, 0, 2544, 2545, 5, 2, 0, 0, 2545, 2550, 5,
		531, 0, 0, 2546, 2547, 5, 4, 0, 0, 2547, 2549, 5, 531, 0, 0, 2548, 2546,
		1, 0, 0, 0, 2549, 2552, 1, 0, 0, 0, 2550, 2548, 1, 0, 0, 0, 2550, 2551,
		1, 0, 0, 0, 2551, 2553, 1, 0, 0, 0, 2552, 2550, 1, 0, 0, 0, 2553, 2555,
		5, 3, 0, 0, 2554, 2544, 1, 0, 0, 0, 2554, 2555, 1, 0, 0, 0, 2555, 2597,
		1, 0, 0, 0, 2556, 2557, 5, 63, 0, 0, 2557, 2558, 5, 56, 0, 0, 2558, 2559,
		5, 219, 0, 0, 2559, 2560, 5, 307, 0, 0, 2560, 2571, 3, 322, 161, 0, 2561,
		2562, 5, 2, 0, 0, 2562, 2567, 5, 531, 0, 0, 2563, 2564, 5, 4, 0, 0, 2564,
		2566, 5, 531, 0, 0, 2565, 2563, 1, 0, 0, 0, 2566, 2569, 1, 0, 0, 0, 2567,
		2565, 1, 0, 0, 0, 2567, 2568, 1, 0, 0, 0, 2568, 2570, 1, 0, 0, 0, 2569,
		2567, 1, 0, 0, 0, 2570, 2572, 5, 3, 0, 0, 2571, 2561, 1, 0, 0, 0, 2571,
		2572, 1, 0, 0, 0, 2572, 2597, 1, 0, 0, 0, 2573, 2574, 5, 63, 0, 0, 2574,
		2575, 5, 123, 0, 0, 2575, 2576, 5, 35, 0, 0, 2576, 2581, 5, 526, 0, 0,
		2577, 2578, 5, 4, 0, 0, 2578, 2580, 5, 526, 0, 0, 2579, 2577, 1, 0, 0,
		0, 2580, 2583, 1, 0, 0, 0, 2581, 2579, 1, 0, 0, 0, 2581, 2582, 1, 0, 0,
		0, 2582, 2597, 1, 0, 0, 0, 2583, 2581, 1, 0, 0, 0, 2584, 2585, 5, 63, 0,
		0, 2585, 2588, 5, 37, 0, 0, 2586, 2587, 7, 5, 0, 0, 2587, 2589, 3, 438,
		219, 0, 2588, 2586, 1, 0, 0, 0, 2588, 2589, 1, 0, 0, 0, 2589, 2597, 1,
		0, 0, 0, 2590, 2591, 5, 63, 0, 0, 2591, 2594, 5, 379, 0, 0, 2592, 2593,
		7, 5, 0, 0, 2593, 2595, 3, 438, 219, 0, 2594, 2592, 1, 0, 0, 0, 2594, 2595,
		1, 0, 0, 0, 2595, 2597, 1, 0, 0, 0, 2596, 2533, 1, 0, 0, 0, 2596, 2556,
		1, 0, 0, 0, 2596, 2573, 1, 0, 0, 0, 2596, 2584, 1, 0, 0, 0, 2596, 2590,
		1, 0, 0, 0, 2597, 71, 1, 0, 0, 0, 2598, 2599, 5, 15, 0, 0, 2599, 2600,
		5, 410, 0, 0, 2600, 2601, 5, 374, 0, 0, 2601, 2602, 5, 137, 0, 0, 2602,
		2603, 5, 187, 0, 0, 2603, 2703, 3, 78, 39, 0, 2604, 2605, 5, 15, 0, 0,
		2605, 2606, 5, 360, 0, 0, 2606, 2618, 5, 132, 0, 0, 2607, 2608, 5, 307,
		0, 0, 2608, 2609, 5, 2, 0, 0, 2609, 2614, 5, 526, 0, 0, 2610, 2611, 5,
		4, 0, 0, 2611, 2613, 5, 526, 0, 0, 2612, 2610, 1, 0, 0, 0, 2613, 2616,
		1, 0, 0, 0, 2614, 2612, 1, 0, 0, 0, 2614, 2615, 1, 0, 0, 0, 2615, 2617,
		1, 0, 0, 0, 2616, 2614, 1, 0, 0, 0, 2617, 2619, 5, 3, 0, 0, 2618, 2607,
		1, 0, 0, 0, 2618, 2619, 1, 0, 0, 0, 2619, 2703, 1, 0, 0, 0, 2620, 2621,
		5, 15, 0, 0, 2621, 2622, 5, 63, 0, 0, 2622, 2623, 5, 360, 0, 0, 2623, 2635,
		5, 132, 0, 0, 2624, 2625, 5, 307, 0, 0, 2625, 2626, 5, 2, 0, 0, 2626, 2631,
		5, 526, 0, 0, 2627, 2628, 5, 4, 0, 0, 2628, 2630, 5, 526, 0, 0, 2629, 2627,
		1, 0, 0, 0, 2630, 2633, 1, 0, 0, 0, 2631, 2629, 1, 0, 0, 0, 2631, 2632,
		1, 0, 0, 0, 2632, 2634, 1, 0, 0, 0, 2633, 2631, 1, 0, 0, 0, 2634, 2636,
		5, 3, 0, 0, 2635, 2624, 1, 0, 0, 0, 2635, 2636, 1, 0, 0, 0, 2636, 2703,
		1, 0, 0, 0, 2637, 2638, 5, 15, 0, 0, 2638, 2639, 5, 130, 0, 0, 2639, 2640,
		5, 439, 0, 0, 2640, 2703, 5, 531, 0, 0, 2641, 2642, 5, 15, 0, 0, 2642,
		2643, 5, 410, 0, 0, 2643, 2644, 5, 374, 0, 0, 2644, 2645, 5, 424, 0, 0,
		2645, 2646, 5, 187, 0, 0, 2646, 2652, 3, 78, 39, 0, 2647, 2648, 5, 492,
		0, 0, 2648, 2649, 5, 424, 0, 0, 2649, 2653, 5, 500, 0, 0, 2650, 2651, 5,
		502, 0, 0, 2651, 2653, 5, 526, 0, 0, 2652, 2647, 1, 0, 0, 0, 2652, 2650,
		1, 0, 0, 0, 2652, 2653, 1, 0, 0, 0, 2653, 2703, 1, 0, 0, 0, 2654, 2655,
		5, 15, 0, 0, 2655, 2656, 5, 84, 0, 0, 2656, 2657, 5, 436, 0, 0, 2657, 2662,
		3, 78, 39, 0, 2658, 2659, 5, 492, 0, 0, 2659, 2660, 5, 459, 0, 0, 2660,
		2661, 5, 500, 0, 0, 2661, 2663, 5, 526, 0, 0, 2662, 2658, 1, 0, 0, 0, 2662,
		2663, 1, 0, 0, 0, 2663, 2703, 1, 0, 0, 0, 2664, 2665, 5, 15, 0, 0, 2665,
		2666, 5, 71, 0, 0, 2666, 2668, 3, 358, 179, 0, 2667, 2669, 3, 310, 155,
		0, 2668, 2667, 1, 0, 0, 0, 2668, 2669, 1, 0, 0, 0, 2669, 2703, 1, 0, 0,
		0, 2670, 2671, 5, 15, 0, 0, 2671, 2672, 5, 410, 0, 0, 2672, 2673, 5, 439,
		0, 0, 2673, 2674, 5, 426, 0, 0, 2674, 2676, 5, 185, 0, 0, 2675, 2677, 5,
		484, 0, 0, 2676, 2675, 1, 0, 0, 0, 2676, 2677, 1, 0, 0, 0, 2677, 2703,
		1, 0, 0, 0, 2678, 2679, 5, 15, 0, 0, 2679, 2680, 5, 72, 0, 0, 2680, 2692,
		5, 453, 0, 0, 2681, 2682, 5, 307, 0, 0, 2682, 2683, 5, 2, 0, 0, 2683, 2688,
		5, 526, 0, 0, 2684, 2685, 5, 4, 0, 0, 2685, 2687, 5, 526, 0, 0, 2686, 2684,
		1, 0, 0, 0, 2687, 2690, 1, 0, 0, 0, 2688, 2686, 1, 0, 0, 0, 2688, 2689,
		1, 0, 0, 0, 2689, 2691, 1, 0, 0, 0, 2690, 2688, 1, 0, 0, 0, 2691, 2693,
		5, 3, 0, 0, 2692, 2681, 1, 0, 0, 0, 2692, 2693, 1, 0, 0, 0, 2693, 2703,
		1, 0, 0, 0, 2694, 2695, 5, 15, 0, 0, 2695, 2696, 5, 406, 0, 0, 2696, 2697,
		5, 436, 0, 0, 2697, 2698, 3, 322, 161, 0, 2698, 2700, 5, 424, 0, 0, 2699,
		2701, 3, 310, 155, 0, 2700, 2699, 1, 0, 0, 0, 2700, 2701, 1, 0, 0, 0, 2701,
		2703, 1, 0, 0, 0, 2702, 2598, 1, 0, 0, 0, 2702, 2604, 1, 0, 0, 0, 2702,
		2620, 1, 0, 0, 0, 2702, 2637, 1, 0, 0, 0, 2702, 2641, 1, 0, 0, 0, 2702,
		2654, 1, 0, 0, 0, 2702, 2664, 1, 0, 0, 0, 2702, 2670, 1, 0, 0, 0, 2702,
		2678, 1, 0, 0, 0, 2702, 2694, 1, 0, 0, 0, 2703, 73, 1, 0, 0, 0, 2704, 2705,
		5, 362, 0, 0, 2705, 2706, 5, 111, 0, 0, 2706, 2708, 3, 438, 219, 0, 2707,
		2709, 5, 531, 0, 0, 2708, 2707, 1, 0, 0, 0, 2708, 2709, 1, 0, 0, 0, 2709,
		2712, 1, 0, 0, 0, 2710, 2711, 5, 28, 0, 0, 2711, 2713, 3, 438, 219, 0,
		2712, 2710, 1, 0, 0, 0, 2712, 2713, 1, 0, 0, 0, 2713, 2738, 1, 0, 0, 0,
		2714, 2715, 5, 362, 0, 0, 2715, 2716, 5, 436, 0, 0, 2716, 2718, 3, 322,
		161, 0, 2717, 2719, 5, 531, 0, 0, 2718, 2717, 1, 0, 0, 0, 2718, 2719, 1,
		0, 0, 0, 2719, 2722, 1, 0, 0, 0, 2720, 2721, 5, 28, 0, 0, 2721, 2723, 3,
		438, 219, 0, 2722, 2720, 1, 0, 0, 0, 2722, 2723, 1, 0, 0, 0, 2723, 2738,
		1, 0, 0, 0, 2724, 2725, 5, 362, 0, 0, 2725, 2726, 5, 319, 0, 0, 2726, 2728,
		3, 438, 219, 0, 2727, 2729, 5, 531, 0, 0, 2728, 2727, 1, 0, 0, 0, 2728,
		2729, 1, 0, 0, 0, 2729, 2732, 1, 0, 0, 0, 2730, 2731, 5, 28, 0, 0, 2731,
		2733, 3, 438, 219, 0, 2732, 2730, 1, 0, 0, 0, 2732, 2733, 1, 0, 0, 0, 2733,
		2734, 1, 0, 0, 0, 2734, 2735, 5, 187, 0, 0, 2735, 2736, 3, 322, 161, 0,
		2736, 2738, 1, 0, 0, 0, 2737, 2704, 1, 0, 0, 0, 2737, 2714, 1, 0, 0, 0,
		2737, 2724, 1, 0, 0, 0, 2738, 75, 1, 0, 0, 0, 2739, 2740, 5, 15, 0, 0,
		2740, 2741, 5, 406, 0, 0, 2741, 2742, 5, 374, 0, 0, 2742, 2743, 5, 424,
		0, 0, 2743, 2744, 5, 348, 0, 0, 2744, 2745, 5, 2, 0, 0, 2745, 2746, 3,
		312, 156, 0, 2746, 2747, 5, 3, 0, 0, 2747, 2800, 1, 0, 0, 0, 2748, 2749,
		5, 15, 0, 0, 2749, 2750, 5, 406, 0, 0, 2750, 2751, 5, 374, 0, 0, 2751,
		2752, 5, 485, 0, 0, 2752, 2753, 5, 348, 0, 0, 2753, 2754, 5, 2, 0, 0, 2754,
		2755, 3, 312, 156, 0, 2755, 2756, 5, 3, 0, 0, 2756, 2800, 1, 0, 0, 0, 2757,
		2758, 5, 15, 0, 0, 2758, 2759, 5, 369, 0, 0, 2759, 2760, 5, 436, 0, 0,
		2760, 2800, 3, 78, 39, 0, 2761, 2762, 5, 15, 0, 0, 2762, 2763, 5, 63, 0,
		0, 2763, 2764, 5, 369, 0, 0, 2764, 2765, 5, 436, 0, 0, 2765, 2800, 3, 78,
		39, 0, 2766, 2767, 5, 15, 0, 0, 2767, 2771, 5, 406, 0, 0, 2768, 2772, 5,
		188, 0, 0, 2769, 2770, 5, 20, 0, 0, 2770, 2772, 5, 189, 0, 0, 2771, 2768,
		1, 0, 0, 0, 2771, 2769, 1, 0, 0, 0, 2772, 2773, 1, 0, 0, 0, 2773, 2778,
		5, 89, 0, 0, 2774, 2775, 5, 2, 0, 0, 2775, 2776, 3, 312, 156, 0, 2776,
		2777, 5, 3, 0, 0, 2777, 2779, 1, 0, 0, 0, 2778, 2774, 1, 0, 0, 0, 2778,
		2779, 1, 0, 0, 0, 2779, 2781, 1, 0, 0, 0, 2780, 2782, 5, 20, 0, 0, 2781,
		2780, 1, 0, 0, 0, 2781, 2782, 1, 0, 0, 0, 2782, 2800, 1, 0, 0, 0, 2783,
		2784, 5, 15, 0, 0, 2784, 2785, 5, 406, 0, 0, 2785, 2786, 5, 436, 0, 0,
		2786, 2787, 3, 322, 161, 0, 2787, 2788, 5, 319, 0, 0, 2788, 2790, 5, 485,
		0, 0, 2789, 2791, 3, 310, 155, 0, 2790, 2789, 1, 0, 0, 0, 2790, 2791, 1,
		0, 0, 0, 2791, 2800, 1, 0, 0, 0, 2792, 2793, 5, 15, 0, 0, 2793, 2794, 5,
		97, 0, 0, 2794, 2795, 5, 439, 0, 0, 2795, 2797, 5, 531, 0, 0, 2796, 2798,
		3, 310, 155, 0, 2797, 2796, 1, 0, 0, 0, 2797, 2798, 1, 0, 0, 0, 2798, 2800,
		1, 0, 0, 0, 2799, 2739, 1, 0, 0, 0, 2799, 2748, 1, 0, 0, 0, 2799, 2757,
		1, 0, 0, 0, 2799, 2761, 1, 0, 0, 0, 2799, 2766, 1, 0, 0, 0, 2799, 2783,
		1, 0, 0, 0, 2799, 2792, 1, 0, 0, 0, 2800, 77, 1, 0, 0, 0, 2801, 2803, 3,
		322, 161, 0, 2802, 2804, 3, 304, 152, 0, 2803, 2802, 1, 0, 0, 0, 2803,
		2804, 1, 0, 0, 0, 2804, 2806, 1, 0, 0, 0, 2805, 2807, 3, 432, 216, 0, 2806,
		2805, 1, 0, 0, 0, 2806, 2807, 1, 0, 0, 0, 2807, 2809, 1, 0, 0, 0, 2808,
		2810, 3, 402, 201, 0, 2809, 2808, 1, 0, 0, 0, 2809, 2810, 1, 0, 0, 0, 2810,
		2812, 1, 0, 0, 0, 2811, 2813, 3, 358, 179, 0, 2812, 2811, 1, 0, 0, 0, 2812,
		2813, 1, 0, 0, 0, 2813, 2814, 1, 0, 0, 0, 2814, 2816, 3, 320, 160, 0, 2815,
		2817, 3, 428, 214, 0, 2816, 2815, 1, 0, 0, 0, 2816, 2817, 1, 0, 0, 0, 2817,
		2819, 1, 0, 0, 0, 2818, 2820, 3, 262, 131, 0, 2819, 2818, 1, 0, 0, 0, 2819,
		2820, 1, 0, 0, 0, 2820, 79, 1, 0, 0, 0, 2821, 2822, 5, 256, 0, 0, 2822,
		2826, 5, 526, 0, 0, 2823, 2824, 5, 492, 0, 0, 2824, 2826, 3, 366, 183,
		0, 2825, 2821, 1, 0, 0, 0, 2825, 2823, 1, 0, 0, 0, 2826, 81, 1, 0, 0, 0,
		2827, 2833, 5, 38, 0, 0, 2828, 2829, 5, 494, 0, 0, 2829, 2831, 5, 247,
		0, 0, 2830, 2832, 3, 438, 219, 0, 2831, 2830, 1, 0, 0, 0, 2831, 2832, 1,
		0, 0, 0, 2832, 2834, 1, 0, 0, 0, 2833, 2828, 1, 0, 0, 0, 2833, 2834, 1,
		0, 0, 0, 2834, 2870, 1, 0, 0, 0, 2835, 2837, 5, 82, 0, 0, 2836, 2838, 5,
		495, 0, 0, 2837, 2836, 1, 0, 0, 0, 2837, 2838, 1, 0, 0, 0, 2838, 2844,
		1, 0, 0, 0, 2839, 2841, 5, 24, 0, 0, 2840, 2842, 5, 298, 0, 0, 2841, 2840,
		1, 0, 0, 0, 2841, 2842, 1, 0, 0, 0, 2842, 2843, 1, 0, 0, 0, 2843, 2845,
		5, 68, 0, 0, 2844, 2839, 1, 0, 0, 0, 2844, 2845, 1, 0, 0, 0, 2845, 2850,
		1, 0, 0, 0, 2846, 2848, 5, 298, 0, 0, 2847, 2846, 1, 0, 0, 0, 2847, 2848,
		1, 0, 0, 0, 2848, 2849, 1, 0, 0, 0, 2849, 2851, 5, 367, 0, 0, 2850, 2847,
		1, 0, 0, 0, 2850, 2851, 1, 0, 0, 0, 2851, 2870, 1, 0, 0, 0, 2852, 2854,
		5, 389, 0, 0, 2853, 2855, 5, 495, 0, 0, 2854, 2853, 1, 0, 0, 0, 2854, 2855,
		1, 0, 0, 0, 2855, 2861, 1, 0, 0, 0, 2856, 2858, 5, 24, 0, 0, 2857, 2859,
		5, 298, 0, 0, 2858, 2857, 1, 0, 0, 0, 2858, 2859, 1, 0, 0, 0, 2859, 2860,
		1, 0, 0, 0, 2860, 2862, 5, 68, 0, 0, 2861, 2856, 1, 0, 0, 0, 2861, 2862,
		1, 0, 0, 0, 2862, 2867, 1, 0, 0, 0, 2863, 2865, 5, 298, 0, 0, 2864, 2863,
		1, 0, 0, 0, 2864, 2865, 1, 0, 0, 0, 2865, 2866, 1, 0, 0, 0, 2866, 2868,
		5, 367, 0, 0, 2867, 2864, 1, 0, 0, 0, 2867, 2868, 1, 0, 0, 0, 2868, 2870,
		1, 0, 0, 0, 2869, 2827, 1, 0, 0, 0, 2869, 2835, 1, 0, 0, 0, 2869, 2852,
		1, 0, 0, 0, 2870, 83, 1, 0, 0, 0, 2871, 2872, 5, 196, 0, 0, 2872, 2873,
		3, 88, 44, 0, 2873, 2874, 5, 307, 0, 0, 2874, 2875, 3, 182, 91, 0, 2875,
		2879, 5, 451, 0, 0, 2876, 2880, 3, 186, 93, 0, 2877, 2878, 5, 387, 0, 0,
		2878, 2880, 5, 526, 0, 0, 2879, 2876, 1, 0, 0, 0, 2879, 2877, 1, 0, 0,
		0, 2880, 2956, 1, 0, 0, 0, 2881, 2882, 5, 196, 0, 0, 2882, 2883, 3, 88,
		44, 0, 2883, 2893, 5, 307, 0, 0, 2884, 2894, 5, 377, 0, 0, 2885, 2894,
		5, 73, 0, 0, 2886, 2887, 5, 87, 0, 0, 2887, 2894, 5, 199, 0, 0, 2888, 2894,
		5, 419, 0, 0, 2889, 2890, 5, 426, 0, 0, 2890, 2894, 5, 482, 0, 0, 2891,
		2892, 5, 496, 0, 0, 2892, 2894, 5, 199, 0, 0, 2893, 2884, 1, 0, 0, 0, 2893,
		2885, 1, 0, 0, 0, 2893, 2886, 1, 0, 0, 0, 2893, 2888, 1, 0, 0, 0, 2893,
		2889, 1, 0, 0, 0, 2893, 2891, 1, 0, 0, 0, 2894, 2895, 1, 0, 0, 0, 2895,
		2896, 3, 180, 90, 0, 2896, 2900, 5, 451, 0, 0, 2897, 2901, 3, 186, 93,
		0, 2898, 2899, 5, 387, 0, 0, 2899, 2901, 5, 526, 0, 0, 2900, 2897, 1, 0,
		0, 0, 2900, 2898, 1, 0, 0, 0, 2901, 2956, 1, 0, 0, 0, 2902, 2903, 5, 196,
		0, 0, 2903, 2908, 5, 526, 0, 0, 2904, 2905, 5, 4, 0, 0, 2905, 2907, 5,
		526, 0, 0, 2906, 2904, 1, 0, 0, 0, 2907, 2910, 1, 0, 0, 0, 2908, 2906,
		1, 0, 0, 0, 2908, 2909, 1, 0, 0, 0, 2909, 2911, 1, 0, 0, 0, 2910, 2908,
		1, 0, 0, 0, 2911, 2912, 5, 451, 0, 0, 2912, 2956, 3, 186, 93, 0, 2913,
		2914, 5, 383, 0, 0, 2914, 2915, 3, 88, 44, 0, 2915, 2916, 5, 307, 0, 0,
		2916, 2917, 3, 182, 91, 0, 2917, 2921, 5, 187, 0, 0, 2918, 2922, 3, 186,
		93, 0, 2919, 2920, 5, 387, 0, 0, 2920, 2922, 5, 526, 0, 0, 2921, 2918,
		1, 0, 0, 0, 2921, 2919, 1, 0, 0, 0, 2922, 2956, 1, 0, 0, 0, 2923, 2924,
		5, 383, 0, 0, 2924, 2925, 3, 88, 44, 0, 2925, 2935, 5, 307, 0, 0, 2926,
		2936, 5, 377, 0, 0, 2927, 2936, 5, 73, 0, 0, 2928, 2929, 5, 87, 0, 0, 2929,
		2936, 5, 199, 0, 0, 2930, 2936, 5, 419, 0, 0, 2931, 2932, 5, 426, 0, 0,
		2932, 2936, 5, 482, 0, 0, 2933, 2934, 5, 496, 0, 0, 2934, 2936, 5, 199,
		0, 0, 2935, 2926, 1, 0, 0, 0, 2935, 2927, 1, 0, 0, 0, 2935, 2928, 1, 0,
		0, 0, 2935, 2930, 1, 0, 0, 0, 2935, 2931, 1, 0, 0, 0, 2935, 2933, 1, 0,
		0, 0, 2936, 2937, 1, 0, 0, 0, 2937, 2938, 3, 180, 90, 0, 2938, 2942, 5,
		187, 0, 0, 2939, 2943, 3, 186, 93, 0, 2940, 2941, 5, 387, 0, 0, 2941, 2943,
		5, 526, 0, 0, 2942, 2939, 1, 0, 0, 0, 2942, 2940, 1, 0, 0, 0, 2943, 2956,
		1, 0, 0, 0, 2944, 2945, 5, 383, 0, 0, 2945, 2950, 5, 526, 0, 0, 2946, 2947,
		5, 4, 0, 0, 2947, 2949, 5, 526, 0, 0, 2948, 2946, 1, 0, 0, 0, 2949, 2952,
		1, 0, 0, 0, 2950, 2948, 1, 0, 0, 0, 2950, 2951, 1, 0, 0, 0, 2951, 2953,
		1, 0, 0, 0, 2952, 2950, 1, 0, 0, 0, 2953, 2954, 5, 187, 0, 0, 2954, 2956,
		3, 186, 93, 0, 2955, 2871, 1, 0, 0, 0, 2955, 2881, 1, 0, 0, 0, 2955, 2902,
		1, 0, 0, 0, 2955, 2913, 1, 0, 0, 0, 2955, 2923, 1, 0, 0, 0, 2955, 2944,
		1, 0, 0, 0, 2956, 85, 1, 0, 0, 0, 2957, 2959, 3, 438, 219, 0, 2958, 2960,
		3, 300, 150, 0, 2959, 2958, 1, 0, 0, 0, 2959, 2960, 1, 0, 0, 0, 2960, 2963,
		1, 0, 0, 0, 2961, 2963, 5, 20, 0, 0, 2962, 2957, 1, 0, 0, 0, 2962, 2961,
		1, 0, 0, 0, 2963, 87, 1, 0, 0, 0, 2964, 2969, 3, 86, 43, 0, 2965, 2966,
		5, 4, 0, 0, 2966, 2968, 3, 86, 43, 0, 2967, 2965, 1, 0, 0, 0, 2968, 2971,
		1, 0, 0, 0, 2969, 2967, 1, 0, 0, 0, 2969, 2970, 1, 0, 0, 0, 2970, 89, 1,
		0, 0, 0, 2971, 2969, 1, 0, 0, 0, 2972, 2973, 5, 21, 0, 0, 2973, 2974, 5,
		435, 0, 0, 2974, 3049, 3, 92, 46, 0, 2975, 2976, 5, 21, 0, 0, 2976, 2977,
		5, 111, 0, 0, 2977, 2978, 3, 438, 219, 0, 2978, 2979, 5, 406, 0, 0, 2979,
		2980, 5, 348, 0, 0, 2980, 2981, 5, 2, 0, 0, 2981, 2982, 3, 312, 156, 0,
		2982, 2983, 5, 3, 0, 0, 2983, 3049, 1, 0, 0, 0, 2984, 2985, 5, 21, 0, 0,
		2985, 2986, 5, 66, 0, 0, 2986, 2987, 3, 438, 219, 0, 2987, 2988, 5, 406,
		0, 0, 2988, 2989, 5, 348, 0, 0, 2989, 2990, 5, 2, 0, 0, 2990, 2991, 3,
		312, 156, 0, 2991, 2992, 5, 3, 0, 0, 2992, 3049, 1, 0, 0, 0, 2993, 2994,
		5, 21, 0, 0, 2994, 2995, 5, 377, 0, 0, 2995, 2997, 3, 178, 89, 0, 2996,
		2998, 3, 310, 155, 0, 2997, 2996, 1, 0, 0, 0, 2997, 2998, 1, 0, 0, 0, 2998,
		3049, 1, 0, 0, 0, 2999, 3000, 5, 21, 0, 0, 3000, 3001, 5, 78, 0, 0, 3001,
		3002, 5, 199, 0, 0, 3002, 3003, 3, 322, 161, 0, 3003, 3004, 5, 406, 0,
		0, 3004, 3005, 5, 2, 0, 0, 3005, 3006, 3, 312, 156, 0, 3006, 3007, 5, 3,
		0, 0, 3007, 3049, 1, 0, 0, 0, 3008, 3009, 5, 21, 0, 0, 3009, 3010, 5, 391,
		0, 0, 3010, 3011, 5, 261, 0, 0, 3011, 3012, 5, 182, 0, 0, 3012, 3014, 3,
		322, 161, 0, 3013, 3015, 3, 310, 155, 0, 3014, 3013, 1, 0, 0, 0, 3014,
		3015, 1, 0, 0, 0, 3015, 3022, 1, 0, 0, 0, 3016, 3017, 5, 187, 0, 0, 3017,
		3018, 3, 438, 219, 0, 3018, 3019, 5, 2, 0, 0, 3019, 3020, 3, 312, 156,
		0, 3020, 3021, 5, 3, 0, 0, 3021, 3023, 1, 0, 0, 0, 3022, 3016, 1, 0, 0,
		0, 3022, 3023, 1, 0, 0, 0, 3023, 3049, 1, 0, 0, 0, 3024, 3025, 5, 21, 0,
		0, 3025, 3026, 5, 426, 0, 0, 3026, 3027, 5, 340, 0, 0, 3027, 3028, 3, 178,
		89, 0, 3028, 3029, 3, 310, 155, 0, 3029, 3049, 1, 0, 0, 0, 3030, 3031,
		5, 21, 0, 0, 3031, 3034, 5, 473, 0, 0, 3032, 3033, 5, 214, 0, 0, 3033,
		3035, 5, 164, 0, 0, 3034, 3032, 1, 0, 0, 0, 3034, 3035, 1, 0, 0, 0, 3035,
		3036, 1, 0, 0, 0, 3036, 3037, 3, 188, 94, 0, 3037, 3040, 3, 124, 62, 0,
		3038, 3039, 5, 81, 0, 0, 3039, 3041, 5, 526, 0, 0, 3040, 3038, 1, 0, 0,
		0, 3040, 3041, 1, 0, 0, 0, 3041, 3049, 1, 0, 0, 0, 3042, 3043, 5, 21, 0,
		0, 3043, 3044, 5, 376, 0, 0, 3044, 3046, 3, 438, 219, 0, 3045, 3047, 3,
		310, 155, 0, 3046, 3045, 1, 0, 0, 0, 3046, 3047, 1, 0, 0, 0, 3047, 3049,
		1, 0, 0, 0, 3048, 2972, 1, 0, 0, 0, 3048, 2975, 1, 0, 0, 0, 3048, 2984,
		1, 0, 0, 0, 3048, 2993, 1, 0, 0, 0, 3048, 2999, 1, 0, 0, 0, 3048, 3008,
		1, 0, 0, 0, 3048, 3024, 1, 0, 0, 0, 3048, 3030, 1, 0, 0, 0, 3048, 3042,
		1, 0, 0, 0, 3049, 91, 1, 0, 0, 0, 3050, 3051, 5, 14, 0, 0, 3051, 3052,
		5, 35, 0, 0, 3052, 3057, 5, 526, 0, 0, 3053, 3054, 5, 4, 0, 0, 3054, 3056,
		5, 526, 0, 0, 3055, 3053, 1, 0, 0, 0, 3056, 3059, 1, 0, 0, 0, 3057, 3055,
		1, 0, 0, 0, 3057, 3058, 1, 0, 0, 0, 3058, 3061, 1, 0, 0, 0, 3059, 3057,
		1, 0, 0, 0, 3060, 3062, 3, 310, 155, 0, 3061, 3060, 1, 0, 0, 0, 3061, 3062,
		1, 0, 0, 0, 3062, 3149, 1, 0, 0, 0, 3063, 3064, 7, 17, 0, 0, 3064, 3065,
		5, 35, 0, 0, 3065, 3070, 5, 526, 0, 0, 3066, 3067, 5, 4, 0, 0, 3067, 3069,
		5, 526, 0, 0, 3068, 3066, 1, 0, 0, 0, 3069, 3072, 1, 0, 0, 0, 3070, 3068,
		1, 0, 0, 0, 3070, 3071, 1, 0, 0, 0, 3071, 3149, 1, 0, 0, 0, 3072, 3070,
		1, 0, 0, 0, 3073, 3074, 5, 123, 0, 0, 3074, 3075, 5, 35, 0, 0, 3075, 3080,
		5, 526, 0, 0, 3076, 3077, 5, 4, 0, 0, 3077, 3079, 5, 526, 0, 0, 3078, 3076,
		1, 0, 0, 0, 3079, 3082, 1, 0, 0, 0, 3080, 3078, 1, 0, 0, 0, 3080, 3081,
		1, 0, 0, 0, 3081, 3149, 1, 0, 0, 0, 3082, 3080, 1, 0, 0, 0, 3083, 3084,
		5, 14, 0, 0, 3084, 3085, 5, 304, 0, 0, 3085, 3149, 5, 526, 0, 0, 3086,
		3087, 5, 142, 0, 0, 3087, 3088, 5, 304, 0, 0, 3088, 3149, 5, 526, 0, 0,
		3089, 3090, 5, 14, 0, 0, 3090, 3091, 5, 180, 0, 0, 3091, 3149, 5, 526,
		0, 0, 3092, 3093, 5, 142, 0, 0, 3093, 3094, 5, 180, 0, 0, 3094, 3149, 5,
		526, 0, 0, 3095, 3096, 5, 14, 0, 0, 3096, 3097, 5, 54, 0, 0, 3097, 3098,
		3, 178, 89, 0, 3098, 3103, 5, 526, 0, 0, 3099, 3100, 5, 4, 0, 0, 3100,
		3102, 5, 526, 0, 0, 3101, 3099, 1, 0, 0, 0, 3102, 3105, 1, 0, 0, 0, 3103,
		3101, 1, 0, 0, 0, 3103, 3104, 1, 0, 0, 0, 3104, 3149, 1, 0, 0, 0, 3105,
		3103, 1, 0, 0, 0, 3106, 3107, 5, 142, 0, 0, 3107, 3108, 5, 54, 0, 0, 3108,
		3109, 3, 178, 89, 0, 3109, 3114, 5, 526, 0, 0, 3110, 3111, 5, 4, 0, 0,
		3111, 3113, 5, 526, 0, 0, 3112, 3110, 1, 0, 0, 0, 3113, 3116, 1, 0, 0,
		0, 3114, 3112, 1, 0, 0, 0, 3114, 3115, 1, 0, 0, 0, 3115, 3149, 1, 0, 0,
		0, 3116, 3114, 1, 0, 0, 0, 3117, 3118, 5, 142, 0, 0, 3118, 3119, 5, 20,
		0, 0, 3119, 3120, 5, 54, 0, 0, 3120, 3149, 3, 178, 89, 0, 3121, 3122, 5,
		406, 0, 0, 3122, 3123, 5, 261, 0, 0, 3123, 3124, 5, 158, 0, 0, 3124, 3126,
		5, 212, 0, 0, 3125, 3127, 3, 310, 155, 0, 3126, 3125, 1, 0, 0, 0, 3126,
		3127, 1, 0, 0, 0, 3127, 3149, 1, 0, 0, 0, 3128, 3129, 5, 288, 0, 0, 3129,
		3130, 5, 35, 0, 0, 3130, 3135, 5, 526, 0, 0, 3131, 3132, 5, 4, 0, 0, 3132,
		3134, 5, 526, 0, 0, 3133, 3131, 1, 0, 0, 0, 3134, 3137, 1, 0, 0, 0, 3135,
		3133, 1, 0, 0, 0, 3135, 3136, 1, 0, 0, 0, 3136, 3138, 1, 0, 0, 0, 3137,
		3135, 1, 0, 0, 0, 3138, 3139, 5, 406, 0, 0, 3139, 3140, 5, 2, 0, 0, 3140,
		3141, 3, 312, 156, 0, 3141, 3142, 5, 3, 0, 0, 3142, 3149, 1, 0, 0, 0, 3143,
		3144, 5, 288, 0, 0, 3144, 3145, 7, 2, 0, 0, 3145, 3146, 5, 526, 0, 0, 3146,
		3147, 5, 209, 0, 0, 3147, 3149, 5, 526, 0, 0, 3148, 3050, 1, 0, 0, 0, 3148,
		3063, 1, 0, 0, 0, 3148, 3073, 1, 0, 0, 0, 3148, 3083, 1, 0, 0, 0, 3148,
		3086, 1, 0, 0, 0, 3148, 3089, 1, 0, 0, 0, 3148, 3092, 1, 0, 0, 0, 3148,
		3095, 1, 0, 0, 0, 3148, 3106, 1, 0, 0, 0, 3148, 3117, 1, 0, 0, 0, 3148,
		3121, 1, 0, 0, 0, 3148, 3128, 1, 0, 0, 0, 3148, 3143, 1, 0, 0, 0, 3149,
		93, 1, 0, 0, 0, 3150, 3152, 3, 438, 219, 0, 3151, 3153, 3, 310, 155, 0,
		3152, 3151, 1, 0, 0, 0, 3152, 3153, 1, 0, 0, 0, 3153, 95, 1, 0, 0, 0, 3154,
		3155, 3, 438, 219, 0, 3155, 3159, 3, 300, 150, 0, 3156, 3157, 5, 146, 0,
		0, 3157, 3158, 5, 244, 0, 0, 3158, 3160, 3, 300, 150, 0, 3159, 3156, 1,
		0, 0, 0, 3159, 3160, 1, 0, 0, 0, 3160, 3162, 1, 0, 0, 0, 3161, 3163, 3,
		104, 52, 0, 3162, 3161, 1, 0, 0, 0, 3162, 3163, 1, 0, 0, 0, 3163, 3165,
		1, 0, 0, 0, 3164, 3166, 3, 310, 155, 0, 3165, 3164, 1, 0, 0, 0, 3165, 3166,
		1, 0, 0, 0, 3166, 97, 1, 0, 0, 0, 3167, 3168, 5, 14, 0, 0, 3168, 3169,
		5, 79, 0, 0, 3169, 3171, 3, 330, 165, 0, 3170, 3172, 3, 100, 50, 0, 3171,
		3170, 1, 0, 0, 0, 3171, 3172, 1, 0, 0, 0, 3172, 3174, 1, 0, 0, 0, 3173,
		3175, 3, 102, 51, 0, 3174, 3173, 1, 0, 0, 0, 3174, 3175, 1, 0, 0, 0, 3175,
		3177, 1, 0, 0, 0, 3176, 3178, 3, 310, 155, 0, 3177, 3176, 1, 0, 0, 0, 3177,
		3178, 1, 0, 0, 0, 3178, 3388, 1, 0, 0, 0, 3179, 3180, 5, 14, 0, 0, 3180,
		3181, 5, 79, 0, 0, 3181, 3182, 5, 2, 0, 0, 3182, 3183, 3, 328, 164, 0,
		3183, 3185, 5, 3, 0, 0, 3184, 3186, 3, 102, 51, 0, 3185, 3184, 1, 0, 0,
		0, 3185, 3186, 1, 0, 0, 0, 3186, 3188, 1, 0, 0, 0, 3187, 3189, 3, 310,
		155, 0, 3188, 3187, 1, 0, 0, 0, 3188, 3189, 1, 0, 0, 0, 3189, 3388, 1,
		0, 0, 0, 3190, 3191, 5, 142, 0, 0, 3191, 3192, 5, 79, 0, 0, 3192, 3194,
		3, 438, 219, 0, 3193, 3195, 3, 104, 52, 0, 3194, 3193, 1, 0, 0, 0, 3194,
		3195, 1, 0, 0, 0, 3195, 3197, 1, 0, 0, 0, 3196, 3198, 3, 310, 155, 0, 3197,
		3196, 1, 0, 0, 0, 3197, 3198, 1, 0, 0, 0, 3198, 3388, 1, 0, 0, 0, 3199,
		3200, 5, 288, 0, 0, 3200, 3201, 5, 79, 0, 0, 3201, 3203, 3, 330, 165, 0,
		3202, 3204, 3, 100, 50, 0, 3203, 3202, 1, 0, 0, 0, 3203, 3204, 1, 0, 0,
		0, 3204, 3206, 1, 0, 0, 0, 3205, 3207, 3, 104, 52, 0, 3206, 3205, 1, 0,
		0, 0, 3206, 3207, 1, 0, 0, 0, 3207, 3209, 1, 0, 0, 0, 3208, 3210, 3, 310,
		155, 0, 3209, 3208, 1, 0, 0, 0, 3209, 3210, 1, 0, 0, 0, 3210, 3388, 1,
		0, 0, 0, 3211, 3212, 5, 312, 0, 0, 3212, 3213, 5, 59, 0, 0, 3213, 3215,
		3, 300, 150, 0, 3214, 3216, 3, 104, 52, 0, 3215, 3214, 1, 0, 0, 0, 3215,
		3216, 1, 0, 0, 0, 3216, 3218, 1, 0, 0, 0, 3217, 3219, 3, 310, 155, 0, 3218,
		3217, 1, 0, 0, 0, 3218, 3219, 1, 0, 0, 0, 3219, 3388, 1, 0, 0, 0, 3220,
		3222, 5, 14, 0, 0, 3221, 3223, 5, 443, 0, 0, 3222, 3221, 1, 0, 0, 0, 3222,
		3223, 1, 0, 0, 0, 3223, 3224, 1, 0, 0, 0, 3224, 3239, 3, 338, 169, 0, 3225,
		3226, 5, 136, 0, 0, 3226, 3230, 5, 59, 0, 0, 3227, 3228, 5, 202, 0, 0,
		3228, 3231, 3, 300, 150, 0, 3229, 3231, 5, 356, 0, 0, 3230, 3227, 1, 0,
		0, 0, 3230, 3229, 1, 0, 0, 0, 3231, 3237, 1, 0, 0, 0, 3232, 3235, 5, 55,
		0, 0, 3233, 3236, 5, 531, 0, 0, 3234, 3236, 5, 32, 0, 0, 3235, 3233, 1,
		0, 0, 0, 3235, 3234, 1, 0, 0, 0, 3236, 3238, 1, 0, 0, 0, 3237, 3232, 1,
		0, 0, 0, 3237, 3238, 1, 0, 0, 0, 3238, 3240, 1, 0, 0, 0, 3239, 3225, 1,
		0, 0, 0, 3239, 3240, 1, 0, 0, 0, 3240, 3242, 1, 0, 0, 0, 3241, 3243, 3,
		310, 155, 0, 3242, 3241, 1, 0, 0, 0, 3242, 3243, 1, 0, 0, 0, 3243, 3388,
		1, 0, 0, 0, 3244, 3246, 5, 142, 0, 0, 3245, 3247, 5, 443, 0, 0, 3246, 3245,
		1, 0, 0, 0, 3246, 3247, 1, 0, 0, 0, 3247, 3248, 1, 0, 0, 0, 3248, 3251,
		5, 319, 0, 0, 3249, 3250, 5, 214, 0, 0, 3250, 3252, 5, 164, 0, 0, 3251,
		3249, 1, 0, 0, 0, 3251, 3252, 1, 0, 0, 0, 3252, 3253, 1, 0, 0, 0, 3253,
		3255, 3, 438, 219, 0, 3254, 3256, 5, 184, 0, 0, 3255, 3254, 1, 0, 0, 0,
		3255, 3256, 1, 0, 0, 0, 3256, 3260, 1, 0, 0, 0, 3257, 3258, 5, 187, 0,
		0, 3258, 3259, 5, 219, 0, 0, 3259, 3261, 3, 438, 219, 0, 3260, 3257, 1,
		0, 0, 0, 3260, 3261, 1, 0, 0, 0, 3261, 3388, 1, 0, 0, 0, 3262, 3264, 5,
		288, 0, 0, 3263, 3265, 5, 443, 0, 0, 3264, 3263, 1, 0, 0, 0, 3264, 3265,
		1, 0, 0, 0, 3265, 3266, 1, 0, 0, 0, 3266, 3272, 5, 319, 0, 0, 3267, 3273,
		3, 438, 219, 0, 3268, 3273, 3, 300, 150, 0, 3269, 3270, 5, 2, 0, 0, 3270,
		3271, 5, 509, 0, 0, 3271, 3273, 5, 3, 0, 0, 3272, 3267, 1, 0, 0, 0, 3272,
		3268, 1, 0, 0, 0, 3272, 3269, 1, 0, 0, 0, 3273, 3274, 1, 0, 0, 0, 3274,
		3275, 5, 406, 0, 0, 3275, 3276, 5, 2, 0, 0, 3276, 3277, 3, 312, 156, 0,
		3277, 3278, 5, 3, 0, 0, 3278, 3388, 1, 0, 0, 0, 3279, 3281, 5, 371, 0,
		0, 3280, 3282, 3, 158, 79, 0, 3281, 3280, 1, 0, 0, 0, 3281, 3282, 1, 0,
		0, 0, 3282, 3283, 1, 0, 0, 0, 3283, 3285, 5, 494, 0, 0, 3284, 3286, 3,
		158, 79, 0, 3285, 3284, 1, 0, 0, 0, 3285, 3286, 1, 0, 0, 0, 3286, 3288,
		1, 0, 0, 0, 3287, 3289, 5, 184, 0, 0, 3288, 3287, 1, 0, 0, 0, 3288, 3289,
		1, 0, 0, 0, 3289, 3291, 1, 0, 0, 0, 3290, 3292, 3, 310, 155, 0, 3291, 3290,
		1, 0, 0, 0, 3291, 3292, 1, 0, 0, 0, 3292, 3388, 1, 0, 0, 0, 3293, 3294,
		5, 371, 0, 0, 3294, 3295, 5, 494, 0, 0, 3295, 3296, 5, 436, 0, 0, 3296,
		3298, 3, 438, 219, 0, 3297, 3299, 3, 310, 155, 0, 3298, 3297, 1, 0, 0,
		0, 3298, 3299, 1, 0, 0, 0, 3299, 3301, 1, 0, 0, 0, 3300, 3302, 5, 184,
		0, 0, 3301, 3300, 1, 0, 0, 0, 3301, 3302, 1, 0, 0, 0, 3302, 3388, 1, 0,
		0, 0, 3303, 3304, 5, 368, 0, 0, 3304, 3388, 3, 438, 219, 0, 3305, 3306,
		5, 368, 0, 0, 3306, 3307, 5, 390, 0, 0, 3307, 3308, 3, 438, 219, 0, 3308,
		3309, 3, 438, 219, 0, 3309, 3388, 1, 0, 0, 0, 3310, 3311, 5, 368, 0, 0,
		3311, 3312, 5, 319, 0, 0, 3312, 3313, 3, 438, 219, 0, 3313, 3314, 3, 438,
		219, 0, 3314, 3388, 1, 0, 0, 0, 3315, 3316, 5, 368, 0, 0, 3316, 3317, 5,
		79, 0, 0, 3317, 3318, 3, 438, 219, 0, 3318, 3319, 3, 438, 219, 0, 3319,
		3388, 1, 0, 0, 0, 3320, 3321, 5, 14, 0, 0, 3321, 3388, 3, 334, 167, 0,
		3322, 3323, 5, 142, 0, 0, 3323, 3326, 5, 219, 0, 0, 3324, 3325, 5, 214,
		0, 0, 3325, 3327, 5, 164, 0, 0, 3326, 3324, 1, 0, 0, 0, 3326, 3327, 1,
		0, 0, 0, 3327, 3328, 1, 0, 0, 0, 3328, 3388, 3, 438, 219, 0, 3329, 3330,
		5, 150, 0, 0, 3330, 3331, 5, 174, 0, 0, 3331, 3334, 5, 526, 0, 0, 3332,
		3333, 5, 494, 0, 0, 3333, 3335, 3, 310, 155, 0, 3334, 3332, 1, 0, 0, 0,
		3334, 3335, 1, 0, 0, 0, 3335, 3388, 1, 0, 0, 0, 3336, 3337, 5, 288, 0,
		0, 3337, 3352, 5, 137, 0, 0, 3338, 3339, 5, 136, 0, 0, 3339, 3343, 5, 59,
		0, 0, 3340, 3341, 5, 202, 0, 0, 3341, 3344, 3, 300, 150, 0, 3342, 3344,
		5, 356, 0, 0, 3343, 3340, 1, 0, 0, 0, 3343, 3342, 1, 0, 0, 0, 3344, 3350,
		1, 0, 0, 0, 3345, 3348, 5, 55, 0, 0, 3346, 3349, 5, 531, 0, 0, 3347, 3349,
		5, 32, 0, 0, 3348, 3346, 1, 0, 0, 0, 3348, 3347, 1, 0, 0, 0, 3349, 3351,
		1, 0, 0, 0, 3350, 3345, 1, 0, 0, 0, 3350, 3351, 1, 0, 0, 0, 3351, 3353,
		1, 0, 0, 0, 3352, 3338, 1, 0, 0, 0, 3352, 3353, 1, 0, 0, 0, 3353, 3388,
		1, 0, 0, 0, 3354, 3355, 5, 288, 0, 0, 3355, 3356, 5, 81, 0, 0, 3356, 3388,
		5, 526, 0, 0, 3357, 3358, 5, 288, 0, 0, 3358, 3359, 5, 79, 0, 0, 3359,
		3360, 3, 438, 219, 0, 3360, 3361, 5, 81, 0, 0, 3361, 3362, 5, 526, 0, 0,
		3362, 3388, 1, 0, 0, 0, 3363, 3364, 5, 288, 0, 0, 3364, 3365, 5, 155, 0,
		0, 3365, 3366, 5, 451, 0, 0, 3366, 3368, 3, 438, 219, 0, 3367, 3369, 3,
		310, 155, 0, 3368, 3367, 1, 0, 0, 0, 3368, 3369, 1, 0, 0, 0, 3369, 3388,
		1, 0, 0, 0, 3370, 3372, 5, 14, 0, 0, 3371, 3373, 5, 443, 0, 0, 3372, 3371,
		1, 0, 0, 0, 3372, 3373, 1, 0, 0, 0, 3373, 3374, 1, 0, 0, 0, 3374, 3375,
		5, 320, 0, 0, 3375, 3376, 5, 187, 0, 0, 3376, 3377, 3, 348, 174, 0, 3377,
		3378, 5, 451, 0, 0, 3378, 3379, 3, 348, 174, 0, 3379, 3380, 5, 229, 0,
		0, 3380, 3382, 5, 531, 0, 0, 3381, 3383, 3, 438, 219, 0, 3382, 3381, 1,
		0, 0, 0, 3382, 3383, 1, 0, 0, 0, 3383, 3385, 1, 0, 0, 0, 3384, 3386, 3,
		310, 155, 0, 3385, 3384, 1, 0, 0, 0, 3385, 3386, 1, 0, 0, 0, 3386, 3388,
		1, 0, 0, 0, 3387, 3167, 1, 0, 0, 0, 3387, 3179, 1, 0, 0, 0, 3387, 3190,
		1, 0, 0, 0, 3387, 3199, 1, 0, 0, 0, 3387, 3211, 1, 0, 0, 0, 3387, 3220,
		1, 0, 0, 0, 3387, 3244, 1, 0, 0, 0, 3387, 3262, 1, 0, 0, 0, 3387, 3279,
		1, 0, 0, 0, 3387, 3293, 1, 0, 0, 0, 3387, 3303, 1, 0, 0, 0, 3387, 3305,
		1, 0, 0, 0, 3387, 3310, 1, 0, 0, 0, 3387, 3315, 1, 0, 0, 0, 3387, 3320,
		1, 0, 0, 0, 3387, 3322, 1, 0, 0, 0, 3387, 3329, 1, 0, 0, 0, 3387, 3336,
		1, 0, 0, 0, 3387, 3354, 1, 0, 0, 0, 3387, 3357, 1, 0, 0, 0, 3387, 3363,
		1, 0, 0, 0, 3387, 3370, 1, 0, 0, 0, 3388, 99, 1, 0, 0, 0, 3389, 3393, 5,
		178, 0, 0, 3390, 3391, 5, 16, 0, 0, 3391, 3393, 3, 438, 219, 0, 3392, 3389,
		1, 0, 0, 0, 3392, 3390, 1, 0, 0, 0, 3393, 101, 1, 0, 0, 0, 3394, 3395,
		7, 18, 0, 0, 3395, 3396, 3, 438, 219, 0, 3396, 103, 1, 0, 0, 0, 3397, 3398,
		5, 187, 0, 0, 3398, 3399, 3, 438, 219, 0, 3399, 105, 1, 0, 0, 0, 3400,
		3402, 5, 142, 0, 0, 3401, 3403, 7, 9, 0, 0, 3402, 3401, 1, 0, 0, 0, 3402,
		3403, 1, 0, 0, 0, 3403, 3404, 1, 0, 0, 0, 3404, 3407, 5, 191, 0, 0, 3405,
		3406, 5, 214, 0, 0, 3406, 3408, 5, 164, 0, 0, 3407, 3405, 1, 0, 0, 0, 3407,
		3408, 1, 0, 0, 0, 3408, 3409, 1, 0, 0, 0, 3409, 3410, 3, 388, 194, 0, 3410,
		3412, 5, 2, 0, 0, 3411, 3413, 3, 126, 63, 0, 3412, 3411, 1, 0, 0, 0, 3412,
		3413, 1, 0, 0, 0, 3413, 3414, 1, 0, 0, 0, 3414, 3415, 5, 3, 0, 0, 3415,
		3476, 1, 0, 0, 0, 3416, 3417, 5, 142, 0, 0, 3417, 3420, 5, 436, 0, 0, 3418,
		3419, 5, 214, 0, 0, 3419, 3421, 5, 164, 0, 0, 3420, 3418, 1, 0, 0, 0, 3420,
		3421, 1, 0, 0, 0, 3421, 3422, 1, 0, 0, 0, 3422, 3424, 3, 322, 161, 0, 3423,
		3425, 5, 184, 0, 0, 3424, 3423, 1, 0, 0, 0, 3424, 3425, 1, 0, 0, 0, 3425,
		3476, 1, 0, 0, 0, 3426, 3427, 5, 142, 0, 0, 3427, 3430, 5, 486, 0, 0, 3428,
		3429, 5, 214, 0, 0, 3429, 3431, 5, 164, 0, 0, 3430, 3428, 1, 0, 0, 0, 3430,
		3431, 1, 0, 0, 0, 3431, 3432, 1, 0, 0, 0, 3432, 3476, 3, 322, 161, 0, 3433,
		3434, 5, 142, 0, 0, 3434, 3437, 5, 219, 0, 0, 3435, 3436, 5, 214, 0, 0,
		3436, 3438, 5, 164, 0, 0, 3437, 3435, 1, 0, 0, 0, 3437, 3438, 1, 0, 0,
		0, 3438, 3439, 1, 0, 0, 0, 3439, 3440, 3, 438, 219, 0, 3440, 3441, 5, 307,
		0, 0, 3441, 3442, 3, 322, 161, 0, 3442, 3476, 1, 0, 0, 0, 3443, 3444, 5,
		142, 0, 0, 3444, 3447, 5, 377, 0, 0, 3445, 3446, 5, 214, 0, 0, 3446, 3448,
		5, 164, 0, 0, 3447, 3445, 1, 0, 0, 0, 3447, 3448, 1, 0, 0, 0, 3448, 3449,
		1, 0, 0, 0, 3449, 3476, 3, 178, 89, 0, 3450, 3451, 5, 142, 0, 0, 3451,
		3452, 5, 392, 0, 0, 3452, 3455, 5, 340, 0, 0, 3453, 3454, 5, 214, 0, 0,
		3454, 3456, 5, 164, 0, 0, 3455, 3453, 1, 0, 0, 0, 3455, 3456, 1, 0, 0,
		0, 3456, 3457, 1, 0, 0, 0, 3457, 3458, 3, 438, 219, 0, 3458, 3459, 5, 307,
		0, 0, 3459, 3466, 3, 322, 161, 0, 3460, 3464, 5, 182, 0, 0, 3461, 3465,
		3, 186, 93, 0, 3462, 3463, 5, 387, 0, 0, 3463, 3465, 3, 438, 219, 0, 3464,
		3461, 1, 0, 0, 0, 3464, 3462, 1, 0, 0, 0, 3465, 3467, 1, 0, 0, 0, 3466,
		3460, 1, 0, 0, 0, 3466, 3467, 1, 0, 0, 0, 3467, 3476, 1, 0, 0, 0, 3468,
		3469, 5, 142, 0, 0, 3469, 3472, 5, 419, 0, 0, 3470, 3471, 5, 214, 0, 0,
		3471, 3473, 5, 164, 0, 0, 3472, 3470, 1, 0, 0, 0, 3472, 3473, 1, 0, 0,
		0, 3473, 3474, 1, 0, 0, 0, 3474, 3476, 3, 438, 219, 0, 3475, 3400, 1, 0,
		0, 0, 3475, 3416, 1, 0, 0, 0, 3475, 3426, 1, 0, 0, 0, 3475, 3433, 1, 0,
		0, 0, 3475, 3443, 1, 0, 0, 0, 3475, 3450, 1, 0, 0, 0, 3475, 3468, 1, 0,
		0, 0, 3476, 107, 1, 0, 0, 0, 3477, 3478, 5, 22, 0, 0, 3478, 3479, 5, 436,
		0, 0, 3479, 3481, 3, 322, 161, 0, 3480, 3482, 3, 158, 79, 0, 3481, 3480,
		1, 0, 0, 0, 3481, 3482, 1, 0, 0, 0, 3482, 3484, 1, 0, 0, 0, 3483, 3485,
		3, 300, 150, 0, 3484, 3483, 1, 0, 0, 0, 3484, 3485, 1, 0, 0, 0, 3485, 3490,
		1, 0, 0, 0, 3486, 3487, 5, 494, 0, 0, 3487, 3489, 3, 110, 55, 0, 3488,
		3486, 1, 0, 0, 0, 3489, 3492, 1, 0, 0, 0, 3490, 3488, 1, 0, 0, 0, 3490,
		3491, 1, 0, 0, 0, 3491, 3494, 1, 0, 0, 0, 3492, 3490, 1, 0, 0, 0, 3493,
		3495, 3, 310, 155, 0, 3494, 3493, 1, 0, 0, 0, 3494, 3495, 1, 0, 0, 0, 3495,
		3632, 1, 0, 0, 0, 3496, 3497, 5, 22, 0, 0, 3497, 3498, 5, 111, 0, 0, 3498,
		3503, 3, 322, 161, 0, 3499, 3500, 5, 494, 0, 0, 3500, 3502, 3, 110, 55,
		0, 3501, 3499, 1, 0, 0, 0, 3502, 3505, 1, 0, 0, 0, 3503, 3501, 1, 0, 0,
		0, 3503, 3504, 1, 0, 0, 0, 3504, 3507, 1, 0, 0, 0, 3505, 3503, 1, 0, 0,
		0, 3506, 3508, 3, 310, 155, 0, 3507, 3506, 1, 0, 0, 0, 3507, 3508, 1, 0,
		0, 0, 3508, 3632, 1, 0, 0, 0, 3509, 3510, 5, 21, 0, 0, 3510, 3511, 5, 436,
		0, 0, 3511, 3512, 3, 322, 161, 0, 3512, 3513, 5, 406, 0, 0, 3513, 3514,
		5, 423, 0, 0, 3514, 3515, 5, 2, 0, 0, 3515, 3516, 3, 312, 156, 0, 3516,
		3518, 5, 3, 0, 0, 3517, 3519, 3, 158, 79, 0, 3518, 3517, 1, 0, 0, 0, 3518,
		3519, 1, 0, 0, 0, 3519, 3632, 1, 0, 0, 0, 3520, 3521, 5, 21, 0, 0, 3521,
		3522, 5, 436, 0, 0, 3522, 3525, 3, 322, 161, 0, 3523, 3524, 5, 219, 0,
		0, 3524, 3526, 3, 438, 219, 0, 3525, 3523, 1, 0, 0, 0, 3525, 3526, 1, 0,
		0, 0, 3526, 3527, 1, 0, 0, 0, 3527, 3528, 5, 288, 0, 0, 3528, 3529, 5,
		79, 0, 0, 3529, 3530, 3, 438, 219, 0, 3530, 3531, 5, 406, 0, 0, 3531, 3532,
		5, 423, 0, 0, 3532, 3533, 5, 2, 0, 0, 3533, 3534, 3, 312, 156, 0, 3534,
		3536, 5, 3, 0, 0, 3535, 3537, 3, 158, 79, 0, 3536, 3535, 1, 0, 0, 0, 3536,
		3537, 1, 0, 0, 0, 3537, 3632, 1, 0, 0, 0, 3538, 3539, 5, 142, 0, 0, 3539,
		3540, 5, 423, 0, 0, 3540, 3542, 3, 322, 161, 0, 3541, 3543, 3, 300, 150,
		0, 3542, 3541, 1, 0, 0, 0, 3542, 3543, 1, 0, 0, 0, 3543, 3545, 1, 0, 0,
		0, 3544, 3546, 3, 158, 79, 0, 3545, 3544, 1, 0, 0, 0, 3545, 3546, 1, 0,
		0, 0, 3546, 3632, 1, 0, 0, 0, 3547, 3548, 5, 142, 0, 0, 3548, 3549, 5,
		61, 0, 0, 3549, 3550, 5, 423, 0, 0, 3550, 3632, 3, 322, 161, 0, 3551, 3552,
		5, 142, 0, 0, 3552, 3553, 5, 165, 0, 0, 3553, 3632, 5, 423, 0, 0, 3554,
		3555, 5, 142, 0, 0, 3555, 3556, 5, 22, 0, 0, 3556, 3557, 5, 239, 0, 0,
		3557, 3632, 5, 531, 0, 0, 3558, 3559, 5, 246, 0, 0, 3559, 3560, 5, 22,
		0, 0, 3560, 3632, 5, 531, 0, 0, 3561, 3562, 5, 410, 0, 0, 3562, 3563, 5,
		436, 0, 0, 3563, 3564, 5, 423, 0, 0, 3564, 3566, 3, 322, 161, 0, 3565,
		3567, 3, 158, 79, 0, 3566, 3565, 1, 0, 0, 0, 3566, 3567, 1, 0, 0, 0, 3567,
		3569, 1, 0, 0, 0, 3568, 3570, 3, 300, 150, 0, 3569, 3568, 1, 0, 0, 0, 3569,
		3570, 1, 0, 0, 0, 3570, 3632, 1, 0, 0, 0, 3571, 3572, 5, 410, 0, 0, 3572,
		3573, 5, 436, 0, 0, 3573, 3574, 5, 423, 0, 0, 3574, 3632, 5, 531, 0, 0,
		3575, 3576, 5, 410, 0, 0, 3576, 3577, 5, 219, 0, 0, 3577, 3578, 5, 423,
		0, 0, 3578, 3579, 3, 322, 161, 0, 3579, 3580, 3, 438, 219, 0, 3580, 3632,
		1, 0, 0, 0, 3581, 3582, 5, 410, 0, 0, 3582, 3584, 5, 79, 0, 0, 3583, 3585,
		5, 61, 0, 0, 3584, 3583, 1, 0, 0, 0, 3584, 3585, 1, 0, 0, 0, 3585, 3586,
		1, 0, 0, 0, 3586, 3587, 5, 423, 0, 0, 3587, 3589, 3, 322, 161, 0, 3588,
		3590, 3, 300, 150, 0, 3589, 3588, 1, 0, 0, 0, 3589, 3590, 1, 0, 0, 0, 3590,
		3592, 1, 0, 0, 0, 3591, 3593, 3, 158, 79, 0, 3592, 3591, 1, 0, 0, 0, 3592,
		3593, 1, 0, 0, 0, 3593, 3632, 1, 0, 0, 0, 3594, 3595, 5, 410, 0, 0, 3595,
		3596, 5, 79, 0, 0, 3596, 3597, 5, 206, 0, 0, 3597, 3598, 3, 322, 161, 0,
		3598, 3599, 3, 300, 150, 0, 3599, 3632, 1, 0, 0, 0, 3600, 3602, 5, 410,
		0, 0, 3601, 3603, 5, 32, 0, 0, 3602, 3601, 1, 0, 0, 0, 3602, 3603, 1, 0,
		0, 0, 3603, 3604, 1, 0, 0, 0, 3604, 3606, 5, 22, 0, 0, 3605, 3607, 3, 322,
		161, 0, 3606, 3605, 1, 0, 0, 0, 3606, 3607, 1, 0, 0, 0, 3607, 3609, 1,
		0, 0, 0, 3608, 3610, 3, 80, 40, 0, 3609, 3608, 1, 0, 0, 0, 3609, 3610,
		1, 0, 0, 0, 3610, 3632, 1, 0, 0, 0, 3611, 3612, 5, 410, 0, 0, 3612, 3613,
		5, 22, 0, 0, 3613, 3615, 5, 531, 0, 0, 3614, 3616, 3, 80, 40, 0, 3615,
		3614, 1, 0, 0, 0, 3615, 3616, 1, 0, 0, 0, 3616, 3632, 1, 0, 0, 0, 3617,
		3618, 5, 410, 0, 0, 3618, 3619, 5, 32, 0, 0, 3619, 3621, 5, 240, 0, 0,
		3620, 3622, 3, 322, 161, 0, 3621, 3620, 1, 0, 0, 0, 3621, 3622, 1, 0, 0,
		0, 3622, 3624, 1, 0, 0, 0, 3623, 3625, 3, 80, 40, 0, 3624, 3623, 1, 0,
		0, 0, 3624, 3625, 1, 0, 0, 0, 3625, 3632, 1, 0, 0, 0, 3626, 3627, 5, 410,
		0, 0, 3627, 3628, 5, 22, 0, 0, 3628, 3629, 5, 441, 0, 0, 3629, 3630, 5,
		424, 0, 0, 3630, 3632, 5, 531, 0, 0, 3631, 3477, 1, 0, 0, 0, 3631, 3496,
		1, 0, 0, 0, 3631, 3509, 1, 0, 0, 0, 3631, 3520, 1, 0, 0, 0, 3631, 3538,
		1, 0, 0, 0, 3631, 3547, 1, 0, 0, 0, 3631, 3551, 1, 0, 0, 0, 3631, 3554,
		1, 0, 0, 0, 3631, 3558, 1, 0, 0, 0, 3631, 3561, 1, 0, 0, 0, 3631, 3571,
		1, 0, 0, 0, 3631, 3575, 1, 0, 0, 0, 3631, 3581, 1, 0, 0, 0, 3631, 3594,
		1, 0, 0, 0, 3631, 3600, 1, 0, 0, 0, 3631, 3611, 1, 0, 0, 0, 3631, 3617,
		1, 0, 0, 0, 3631, 3626, 1, 0, 0, 0, 3632, 109, 1, 0, 0, 0, 3633, 3652,
		5, 434, 0, 0, 3634, 3652, 5, 218, 0, 0, 3635, 3652, 5, 190, 0, 0, 3636,
		3652, 5, 417, 0, 0, 3637, 3652, 5, 206, 0, 0, 3638, 3643, 5, 395, 0, 0,
		3639, 3640, 5, 393, 0, 0, 3640, 3644, 5, 531, 0, 0, 3641, 3642, 5, 328,
		0, 0, 3642, 3644, 5, 531, 0, 0, 3643, 3639, 1, 0, 0, 0, 3643, 3641, 1,
		0, 0, 0, 3644, 3652, 1, 0, 0, 0, 3645, 3646, 5, 55, 0, 0, 3646, 3652, 5,
		531, 0, 0, 3647, 3648, 5, 329, 0, 0, 3648, 3652, 5, 531, 0, 0, 3649, 3650,
		5, 101, 0, 0, 3650, 3652, 5, 526, 0, 0, 3651, 3633, 1, 0, 0, 0, 3651, 3634,
		1, 0, 0, 0, 3651, 3635, 1, 0, 0, 0, 3651, 3636, 1, 0, 0, 0, 3651, 3637,
		1, 0, 0, 0, 3651, 3638, 1, 0, 0, 0, 3651, 3645, 1, 0, 0, 0, 3651, 3647,
		1, 0, 0, 0, 3651, 3649, 1, 0, 0, 0, 3652, 111, 1, 0, 0, 0, 3653, 3654,
		5, 99, 0, 0, 3654, 3658, 7, 8, 0, 0, 3655, 3656, 5, 214, 0, 0, 3656, 3657,
		5, 301, 0, 0, 3657, 3659, 5, 164, 0, 0, 3658, 3655, 1, 0, 0, 0, 3658, 3659,
		1, 0, 0, 0, 3659, 3660, 1, 0, 0, 0, 3660, 3662, 3, 322, 161, 0, 3661, 3663,
		3, 310, 155, 0, 3662, 3661, 1, 0, 0, 0, 3662, 3663, 1, 0, 0, 0, 3663, 3854,
		1, 0, 0, 0, 3664, 3666, 5, 99, 0, 0, 3665, 3667, 7, 9, 0, 0, 3666, 3665,
		1, 0, 0, 0, 3666, 3667, 1, 0, 0, 0, 3667, 3669, 1, 0, 0, 0, 3668, 3670,
		7, 19, 0, 0, 3669, 3668, 1, 0, 0, 0, 3669, 3670, 1, 0, 0, 0, 3670, 3671,
		1, 0, 0, 0, 3671, 3675, 5, 191, 0, 0, 3672, 3673, 5, 214, 0, 0, 3673, 3674,
		5, 301, 0, 0, 3674, 3676, 5, 164, 0, 0, 3675, 3672, 1, 0, 0, 0, 3675, 3676,
		1, 0, 0, 0, 3676, 3677, 1, 0, 0, 0, 3677, 3678, 3, 388, 194, 0, 3678, 3680,
		5, 2, 0, 0, 3679, 3681, 3, 126, 63, 0, 3680, 3679, 1, 0, 0, 0, 3680, 3681,
		1, 0, 0, 0, 3681, 3682, 1, 0, 0, 0, 3682, 3683, 5, 3, 0, 0, 3683, 3684,
		5, 382, 0, 0, 3684, 3687, 3, 418, 209, 0, 3685, 3686, 5, 227, 0, 0, 3686,
		3688, 3, 418, 209, 0, 3687, 3685, 1, 0, 0, 0, 3687, 3688, 1, 0, 0, 0, 3688,
		3690, 1, 0, 0, 0, 3689, 3691, 3, 310, 155, 0, 3690, 3689, 1, 0, 0, 0, 3690,
		3691, 1, 0, 0, 0, 3691, 3854, 1, 0, 0, 0, 3692, 3694, 5, 99, 0, 0, 3693,
		3695, 7, 9, 0, 0, 3694, 3693, 1, 0, 0, 0, 3694, 3695, 1, 0, 0, 0, 3695,
		3696, 1, 0, 0, 0, 3696, 3697, 5, 19, 0, 0, 3697, 3701, 5, 191, 0, 0, 3698,
		3699, 5, 214, 0, 0, 3699, 3700, 5, 301, 0, 0, 3700, 3702, 5, 164, 0, 0,
		3701, 3698, 1, 0, 0, 0, 3701, 3702, 1, 0, 0, 0, 3702, 3703, 1, 0, 0, 0,
		3703, 3704, 3, 388, 194, 0, 3704, 3706, 5, 2, 0, 0, 3705, 3707, 3, 126,
		63, 0, 3706, 3705, 1, 0, 0, 0, 3706, 3707, 1, 0, 0, 0, 3707, 3708, 1, 0,
		0, 0, 3708, 3709, 5, 3, 0, 0, 3709, 3710, 5, 494, 0, 0, 3710, 3711, 5,
		317, 0, 0, 3711, 3713, 5, 2, 0, 0, 3712, 3714, 3, 302, 151, 0, 3713, 3712,
		1, 0, 0, 0, 3713, 3714, 1, 0, 0, 0, 3714, 3715, 1, 0, 0, 0, 3715, 3716,
		5, 3, 0, 0, 3716, 3717, 5, 28, 0, 0, 3717, 3718, 3, 366, 183, 0, 3718,
		3854, 1, 0, 0, 0, 3719, 3720, 5, 99, 0, 0, 3720, 3724, 5, 473, 0, 0, 3721,
		3722, 5, 214, 0, 0, 3722, 3723, 5, 301, 0, 0, 3723, 3725, 5, 164, 0, 0,
		3724, 3721, 1, 0, 0, 0, 3724, 3725, 1, 0, 0, 0, 3725, 3726, 1, 0, 0, 0,
		3726, 3731, 3, 188, 94, 0, 3727, 3732, 5, 432, 0, 0, 3728, 3729, 5, 124,
		0, 0, 3729, 3730, 5, 387, 0, 0, 3730, 3732, 5, 526, 0, 0, 3731, 3727, 1,
		0, 0, 0, 3731, 3728, 1, 0, 0, 0, 3731, 3732, 1, 0, 0, 0, 3732, 3733, 1,
		0, 0, 0, 3733, 3736, 3, 124, 62, 0, 3734, 3735, 5, 81, 0, 0, 3735, 3737,
		5, 526, 0, 0, 3736, 3734, 1, 0, 0, 0, 3736, 3737, 1, 0, 0, 0, 3737, 3854,
		1, 0, 0, 0, 3738, 3741, 5, 99, 0, 0, 3739, 3740, 5, 358, 0, 0, 3740, 3742,
		5, 308, 0, 0, 3741, 3739, 1, 0, 0, 0, 3741, 3742, 1, 0, 0, 0, 3742, 3743,
		1, 0, 0, 0, 3743, 3744, 5, 376, 0, 0, 3744, 3745, 3, 438, 219, 0, 3745,
		3746, 5, 494, 0, 0, 3746, 3747, 3, 122, 61, 0, 3747, 3854, 1, 0, 0, 0,
		3748, 3749, 5, 99, 0, 0, 3749, 3753, 5, 219, 0, 0, 3750, 3751, 5, 214,
		0, 0, 3751, 3752, 5, 301, 0, 0, 3752, 3754, 5, 164, 0, 0, 3753, 3750, 1,
		0, 0, 0, 3753, 3754, 1, 0, 0, 0, 3754, 3755, 1, 0, 0, 0, 3755, 3756, 3,
		438, 219, 0, 3756, 3757, 5, 307, 0, 0, 3757, 3758, 3, 322, 161, 0, 3758,
		3761, 3, 300, 150, 0, 3759, 3760, 5, 475, 0, 0, 3760, 3762, 7, 20, 0, 0,
		3761, 3759, 1, 0, 0, 0, 3761, 3762, 1, 0, 0, 0, 3762, 3764, 1, 0, 0, 0,
		3763, 3765, 3, 310, 155, 0, 3764, 3763, 1, 0, 0, 0, 3764, 3765, 1, 0, 0,
		0, 3765, 3768, 1, 0, 0, 0, 3766, 3767, 5, 81, 0, 0, 3767, 3769, 5, 526,
		0, 0, 3768, 3766, 1, 0, 0, 0, 3768, 3769, 1, 0, 0, 0, 3769, 3854, 1, 0,
		0, 0, 3770, 3772, 5, 99, 0, 0, 3771, 3773, 5, 169, 0, 0, 3772, 3771, 1,
		0, 0, 0, 3772, 3773, 1, 0, 0, 0, 3773, 3774, 1, 0, 0, 0, 3774, 3778, 5,
		377, 0, 0, 3775, 3776, 5, 214, 0, 0, 3776, 3777, 5, 301, 0, 0, 3777, 3779,
		5, 164, 0, 0, 3778, 3775, 1, 0, 0, 0, 3778, 3779, 1, 0, 0, 0, 3779, 3780,
		1, 0, 0, 0, 3780, 3782, 3, 178, 89, 0, 3781, 3783, 3, 310, 155, 0, 3782,
		3781, 1, 0, 0, 0, 3782, 3783, 1, 0, 0, 0, 3783, 3854, 1, 0, 0, 0, 3784,
		3785, 5, 99, 0, 0, 3785, 3786, 5, 426, 0, 0, 3786, 3790, 5, 482, 0, 0,
		3787, 3788, 5, 214, 0, 0, 3788, 3789, 5, 301, 0, 0, 3789, 3791, 5, 164,
		0, 0, 3790, 3787, 1, 0, 0, 0, 3790, 3791, 1, 0, 0, 0, 3791, 3792, 1, 0,
		0, 0, 3792, 3794, 3, 178, 89, 0, 3793, 3795, 3, 310, 155, 0, 3794, 3793,
		1, 0, 0, 0, 3794, 3795, 1, 0, 0, 0, 3795, 3854, 1, 0, 0, 0, 3796, 3797,
		5, 99, 0, 0, 3797, 3798, 5, 496, 0, 0, 3798, 3802, 5, 340, 0, 0, 3799,
		3800, 5, 214, 0, 0, 3800, 3801, 5, 301, 0, 0, 3801, 3803, 5, 164, 0, 0,
		3802, 3799, 1, 0, 0, 0, 3802, 3803, 1, 0, 0, 0, 3803, 3804, 1, 0, 0, 0,
		3804, 3810, 3, 178, 89, 0, 3805, 3806, 5, 88, 0, 0, 3806, 3807, 5, 2, 0,
		0, 3807, 3808, 3, 118, 59, 0, 3808, 3809, 5, 3, 0, 0, 3809, 3811, 1, 0,
		0, 0, 3810, 3805, 1, 0, 0, 0, 3810, 3811, 1, 0, 0, 0, 3811, 3817, 1, 0,
		0, 0, 3812, 3813, 5, 13, 0, 0, 3813, 3814, 5, 2, 0, 0, 3814, 3815, 3, 114,
		57, 0, 3815, 3816, 5, 3, 0, 0, 3816, 3818, 1, 0, 0, 0, 3817, 3812, 1, 0,
		0, 0, 3817, 3818, 1, 0, 0, 0, 3818, 3820, 1, 0, 0, 0, 3819, 3821, 3, 310,
		155, 0, 3820, 3819, 1, 0, 0, 0, 3820, 3821, 1, 0, 0, 0, 3821, 3854, 1,
		0, 0, 0, 3822, 3823, 5, 99, 0, 0, 3823, 3824, 5, 426, 0, 0, 3824, 3828,
		5, 340, 0, 0, 3825, 3826, 5, 214, 0, 0, 3826, 3827, 5, 301, 0, 0, 3827,
		3829, 5, 164, 0, 0, 3828, 3825, 1, 0, 0, 0, 3828, 3829, 1, 0, 0, 0, 3829,
		3830, 1, 0, 0, 0, 3830, 3832, 3, 438, 219, 0, 3831, 3833, 3, 310, 155,
		0, 3832, 3831, 1, 0, 0, 0, 3832, 3833, 1, 0, 0, 0, 3833, 3854, 1, 0, 0,
		0, 3834, 3835, 5, 56, 0, 0, 3835, 3836, 5, 219, 0, 0, 3836, 3837, 3, 438,
		219, 0, 3837, 3838, 5, 307, 0, 0, 3838, 3840, 3, 322, 161, 0, 3839, 3841,
		3, 158, 79, 0, 3840, 3839, 1, 0, 0, 0, 3840, 3841, 1, 0, 0, 0, 3841, 3854,
		1, 0, 0, 0, 3842, 3843, 5, 99, 0, 0, 3843, 3847, 5, 419, 0, 0, 3844, 3845,
		5, 214, 0, 0, 3845, 3846, 5, 301, 0, 0, 3846, 3848, 5, 164, 0, 0, 3847,
		3844, 1, 0, 0, 0, 3847, 3848, 1, 0, 0, 0, 3848, 3849, 1, 0, 0, 0, 3849,
		3851, 3, 438, 219, 0, 3850, 3852, 3, 310, 155, 0, 3851, 3850, 1, 0, 0,
		0, 3851, 3852, 1, 0, 0, 0, 3852, 3854, 1, 0, 0, 0, 3853, 3653, 1, 0, 0,
		0, 3853, 3664, 1, 0, 0, 0, 3853, 3692, 1, 0, 0, 0, 3853, 3719, 1, 0, 0,
		0, 3853, 3738, 1, 0, 0, 0, 3853, 3748, 1, 0, 0, 0, 3853, 3770, 1, 0, 0,
		0, 3853, 3784, 1, 0, 0, 0, 3853, 3796, 1, 0, 0, 0, 3853, 3822, 1, 0, 0,
		0, 3853, 3834, 1, 0, 0, 0, 3853, 3842, 1, 0, 0, 0, 3854, 113, 1, 0, 0,
		0, 3855, 3860, 3, 116, 58, 0, 3856, 3857, 5, 4, 0, 0, 3857, 3859, 3, 116,
		58, 0, 3858, 3856, 1, 0, 0, 0, 3859, 3862, 1, 0, 0, 0, 3860, 3858, 1, 0,
		0, 0, 3860, 3861, 1, 0, 0, 0, 3861, 115, 1, 0, 0, 0, 3862, 3860, 1, 0,
		0, 0, 3863, 3864, 5, 408, 0, 0, 3864, 3870, 5, 526, 0, 0, 3865, 3867, 3,
		438, 219, 0, 3866, 3868, 5, 526, 0, 0, 3867, 3866, 1, 0, 0, 0, 3867, 3868,
		1, 0, 0, 0, 3868, 3870, 1, 0, 0, 0, 3869, 3863, 1, 0, 0, 0, 3869, 3865,
		1, 0, 0, 0, 3870, 117, 1, 0, 0, 0, 3871, 3876, 3, 120, 60, 0, 3872, 3873,
		5, 4, 0, 0, 3873, 3875, 3, 120, 60, 0, 3874, 3872, 1, 0, 0, 0, 3875, 3878,
		1, 0, 0, 0, 3876, 3874, 1, 0, 0, 0, 3876, 3877, 1, 0, 0, 0, 3877, 119,
		1, 0, 0, 0, 3878, 3876, 1, 0, 0, 0, 3879, 3880, 3, 438, 219, 0, 3880, 3883,
		3, 406, 203, 0, 3881, 3884, 3, 444, 222, 0, 3882, 3884, 5, 526, 0, 0, 3883,
		3881, 1, 0, 0, 0, 3883, 3882, 1, 0, 0, 0, 3884, 121, 1, 0, 0, 0, 3885,
		3887, 7, 21, 0, 0, 3886, 3888, 3, 438, 219, 0, 3887, 3886, 1, 0, 0, 0,
		3887, 3888, 1, 0, 0, 0, 3888, 3889, 1, 0, 0, 0, 3889, 3890, 5, 307, 0,
		0, 3890, 3891, 5, 265, 0, 0, 3891, 3893, 5, 526, 0, 0, 3892, 3894, 3, 310,
		155, 0, 3893, 3892, 1, 0, 0, 0, 3893, 3894, 1, 0, 0, 0, 3894, 123, 1, 0,
		0, 0, 3895, 3898, 5, 323, 0, 0, 3896, 3899, 5, 124, 0, 0, 3897, 3899, 5,
		531, 0, 0, 3898, 3896, 1, 0, 0, 0, 3898, 3897, 1, 0, 0, 0, 3899, 3901,
		1, 0, 0, 0, 3900, 3895, 1, 0, 0, 0, 3900, 3901, 1, 0, 0, 0, 3901, 3910,
		1, 0, 0, 0, 3902, 3908, 5, 322, 0, 0, 3903, 3909, 5, 124, 0, 0, 3904, 3909,
		5, 295, 0, 0, 3905, 3906, 5, 229, 0, 0, 3906, 3907, 5, 531, 0, 0, 3907,
		3909, 7, 22, 0, 0, 3908, 3903, 1, 0, 0, 0, 3908, 3904, 1, 0, 0, 0, 3908,
		3905, 1, 0, 0, 0, 3909, 3911, 1, 0, 0, 0, 3910, 3902, 1, 0, 0, 0, 3910,
		3911, 1, 0, 0, 0, 3911, 3919, 1, 0, 0, 0, 3912, 3913, 5, 325, 0, 0, 3913,
		3917, 5, 229, 0, 0, 3914, 3918, 5, 124, 0, 0, 3915, 3916, 5, 531, 0, 0,
		3916, 3918, 5, 119, 0, 0, 3917, 3914, 1, 0, 0, 0, 3917, 3915, 1, 0, 0,
		0, 3918, 3920, 1, 0, 0, 0, 3919, 3912, 1, 0, 0, 0, 3919, 3920, 1, 0, 0,
		0, 3920, 3923, 1, 0, 0, 0, 3921, 3922, 5, 171, 0, 0, 3922, 3924, 5, 531,
		0, 0, 3923, 3921, 1, 0, 0, 0, 3923, 3924, 1, 0, 0, 0, 3924, 3931, 1, 0,
		0, 0, 3925, 3929, 5, 324, 0, 0, 3926, 3930, 5, 462, 0, 0, 3927, 3928, 5,
		531, 0, 0, 3928, 3930, 7, 22, 0, 0, 3929, 3926, 1, 0, 0, 0, 3929, 3927,
		1, 0, 0, 0, 3930, 3932, 1, 0, 0, 0, 3931, 3925, 1, 0, 0, 0, 3931, 3932,
		1, 0, 0, 0, 3932, 3934, 1, 0, 0, 0, 3933, 3935, 7, 23, 0, 0, 3934, 3933,
		1, 0, 0, 0, 3934, 3935, 1, 0, 0, 0, 3935, 125, 1, 0, 0, 0, 3936, 3941,
		3, 128, 64, 0, 3937, 3938, 5, 4, 0, 0, 3938, 3940, 3, 128, 64, 0, 3939,
		3937, 1, 0, 0, 0, 3940, 3943, 1, 0, 0, 0, 3941, 3939, 1, 0, 0, 0, 3941,
		3942, 1, 0, 0, 0, 3942, 127, 1, 0, 0, 0, 3943, 3941, 1, 0, 0, 0, 3944,
		3947, 5, 6, 0, 0, 3945, 3947, 3, 418, 209, 0, 3946, 3944, 1, 0, 0, 0, 3946,
		3945, 1, 0, 0, 0, 3947, 129, 1, 0, 0, 0, 3948, 3951, 5, 406, 0, 0, 3949,
		3952, 3, 132, 66, 0, 3950, 3952, 3, 134, 67, 0, 3951, 3949, 1, 0, 0, 0,
		3951, 3950, 1, 0, 0, 0, 3952, 3960, 1, 0, 0, 0, 3953, 3956, 5, 4, 0, 0,
		3954, 3957, 3, 132, 66, 0, 3955, 3957, 3, 134, 67, 0, 3956, 3954, 1, 0,
		0, 0, 3956, 3955, 1, 0, 0, 0, 3957, 3959, 1, 0, 0, 0, 3958, 3953, 1, 0,
		0, 0, 3959, 3962, 1, 0, 0, 0, 3960, 3958, 1, 0, 0, 0, 3960, 3961, 1, 0,
		0, 0, 3961, 3995, 1, 0, 0, 0, 3962, 3960, 1, 0, 0, 0, 3963, 3964, 5, 406,
		0, 0, 3964, 3965, 3, 438, 219, 0, 3965, 3966, 5, 28, 0, 0, 3966, 3967,
		5, 124, 0, 0, 3967, 3968, 5, 426, 0, 0, 3968, 3969, 5, 482, 0, 0, 3969,
		3995, 1, 0, 0, 0, 3970, 3971, 5, 406, 0, 0, 3971, 3974, 5, 349, 0, 0, 3972,
		3973, 5, 182, 0, 0, 3973, 3975, 3, 178, 89, 0, 3974, 3972, 1, 0, 0, 0,
		3974, 3975, 1, 0, 0, 0, 3975, 3976, 1, 0, 0, 0, 3976, 3995, 3, 312, 156,
		0, 3977, 3979, 5, 406, 0, 0, 3978, 3980, 7, 9, 0, 0, 3979, 3978, 1, 0,
		0, 0, 3979, 3980, 1, 0, 0, 0, 3980, 3981, 1, 0, 0, 0, 3981, 3992, 5, 452,
		0, 0, 3982, 3993, 3, 138, 69, 0, 3983, 3993, 3, 140, 70, 0, 3984, 3985,
		3, 138, 69, 0, 3985, 3986, 5, 4, 0, 0, 3986, 3987, 3, 140, 70, 0, 3987,
		3993, 1, 0, 0, 0, 3988, 3989, 3, 140, 70, 0, 3989, 3990, 5, 4, 0, 0, 3990,
		3991, 3, 138, 69, 0, 3991, 3993, 1, 0, 0, 0, 3992, 3982, 1, 0, 0, 0, 3992,
		3983, 1, 0, 0, 0, 3992, 3984, 1, 0, 0, 0, 3992, 3988, 1, 0, 0, 0, 3993,
		3995, 1, 0, 0, 0, 3994, 3948, 1, 0, 0, 0, 3994, 3963, 1, 0, 0, 0, 3994,
		3970, 1, 0, 0, 0, 3994, 3977, 1, 0, 0, 0, 3995, 131, 1, 0, 0, 0, 3996,
		3997, 7, 9, 0, 0, 3997, 3998, 3, 438, 219, 0, 3998, 4001, 5, 500, 0, 0,
		3999, 4002, 3, 366, 183, 0, 4000, 4002, 5, 124, 0, 0, 4001, 3999, 1, 0,
		0, 0, 4001, 4000, 1, 0, 0, 0, 4002, 133, 1, 0, 0, 0, 4003, 4004, 5, 292,
		0, 0, 4004, 4005, 5, 500, 0, 0, 4005, 4049, 3, 366, 183, 0, 4006, 4007,
		5, 69, 0, 0, 4007, 4010, 5, 406, 0, 0, 4008, 4010, 5, 70, 0, 0, 4009, 4006,
		1, 0, 0, 0, 4009, 4008, 1, 0, 0, 0, 4010, 4013, 1, 0, 0, 0, 4011, 4014,
		3, 178, 89, 0, 4012, 4014, 5, 124, 0, 0, 4013, 4011, 1, 0, 0, 0, 4013,
		4012, 1, 0, 0, 0, 4014, 4049, 1, 0, 0, 0, 4015, 4018, 5, 292, 0, 0, 4016,
		4019, 3, 178, 89, 0, 4017, 4019, 5, 124, 0, 0, 4018, 4016, 1, 0, 0, 0,
		4018, 4017, 1, 0, 0, 0, 4019, 4023, 1, 0, 0, 0, 4020, 4021, 5, 75, 0, 0,
		4021, 4024, 3, 178, 89, 0, 4022, 4024, 5, 124, 0, 0, 4023, 4020, 1, 0,
		0, 0, 4023, 4022, 1, 0, 0, 0, 4023, 4024, 1, 0, 0, 0, 4024, 4049, 1, 0,
		0, 0, 4025, 4028, 5, 321, 0, 0, 4026, 4027, 5, 182, 0, 0, 4027, 4029, 3,
		186, 93, 0, 4028, 4026, 1, 0, 0, 0, 4028, 4029, 1, 0, 0, 0, 4029, 4030,
		1, 0, 0, 0, 4030, 4036, 5, 500, 0, 0, 4031, 4037, 5, 526, 0, 0, 4032, 4033,
		5, 321, 0, 0, 4033, 4034, 5, 2, 0, 0, 4034, 4035, 5, 526, 0, 0, 4035, 4037,
		5, 3, 0, 0, 4036, 4031, 1, 0, 0, 0, 4036, 4032, 1, 0, 0, 0, 4037, 4049,
		1, 0, 0, 0, 4038, 4039, 5, 252, 0, 0, 4039, 4045, 5, 500, 0, 0, 4040, 4046,
		5, 526, 0, 0, 4041, 4042, 5, 321, 0, 0, 4042, 4043, 5, 2, 0, 0, 4043, 4044,
		5, 526, 0, 0, 4044, 4046, 5, 3, 0, 0, 4045, 4040, 1, 0, 0, 0, 4045, 4041,
		1, 0, 0, 0, 4046, 4049, 1, 0, 0, 0, 4047, 4049, 3, 136, 68, 0, 4048, 4003,
		1, 0, 0, 0, 4048, 4009, 1, 0, 0, 0, 4048, 4015, 1, 0, 0, 0, 4048, 4025,
		1, 0, 0, 0, 4048, 4038, 1, 0, 0, 0, 4048, 4047, 1, 0, 0, 0, 4049, 135,
		1, 0, 0, 0, 4050, 4053, 5, 525, 0, 0, 4051, 4052, 7, 9, 0, 0, 4052, 4054,
		5, 5, 0, 0, 4053, 4051, 1, 0, 0, 0, 4053, 4054, 1, 0, 0, 0, 4054, 4056,
		1, 0, 0, 0, 4055, 4050, 1, 0, 0, 0, 4055, 4056, 1, 0, 0, 0, 4056, 4057,
		1, 0, 0, 0, 4057, 4058, 3, 438, 219, 0, 4058, 4061, 5, 500, 0, 0, 4059,
		4062, 3, 366, 183, 0, 4060, 4062, 5, 124, 0, 0, 4061, 4059, 1, 0, 0, 0,
		4061, 4060, 1, 0, 0, 0, 4062, 4069, 1, 0, 0, 0, 4063, 4064, 5, 524, 0,
		0, 4064, 4065, 3, 438, 219, 0, 4065, 4066, 5, 500, 0, 0, 4066, 4067, 3,
		366, 183, 0, 4067, 4069, 1, 0, 0, 0, 4068, 4055, 1, 0, 0, 0, 4068, 4063,
		1, 0, 0, 0, 4069, 137, 1, 0, 0, 0, 4070, 4071, 5, 358, 0, 0, 4071, 4072,
		7, 24, 0, 0, 4072, 139, 1, 0, 0, 0, 4073, 4074, 5, 238, 0, 0, 4074, 4082,
		5, 255, 0, 0, 4075, 4076, 5, 358, 0, 0, 4076, 4083, 5, 463, 0, 0, 4077,
		4078, 5, 358, 0, 0, 4078, 4083, 5, 83, 0, 0, 4079, 4080, 5, 370, 0, 0,
		4080, 4083, 5, 358, 0, 0, 4081, 4083, 5, 403, 0, 0, 4082, 4075, 1, 0, 0,
		0, 4082, 4077, 1, 0, 0, 0, 4082, 4079, 1, 0, 0, 0, 4082, 4081, 1, 0, 0,
		0, 4083, 141, 1, 0, 0, 0, 4084, 4086, 5, 468, 0, 0, 4085, 4087, 7, 9, 0,
		0, 4086, 4085, 1, 0, 0, 0, 4086, 4087, 1, 0, 0, 0, 4087, 4088, 1, 0, 0,
		0, 4088, 4091, 5, 479, 0, 0, 4089, 4092, 5, 20, 0, 0, 4090, 4092, 3, 438,
		219, 0, 4091, 4089, 1, 0, 0, 0, 4091, 4090, 1, 0, 0, 0, 4092, 4098, 1,
		0, 0, 0, 4093, 4094, 5, 468, 0, 0, 4094, 4095, 5, 124, 0, 0, 4095, 4096,
		5, 426, 0, 0, 4096, 4098, 5, 482, 0, 0, 4097, 4084, 1, 0, 0, 0, 4097, 4093,
		1, 0, 0, 0, 4098, 143, 1, 0, 0, 0, 4099, 4100, 5, 433, 0, 0, 4100, 4109,
		3, 438, 219, 0, 4101, 4105, 5, 472, 0, 0, 4102, 4103, 3, 438, 219, 0, 4103,
		4104, 5, 5, 0, 0, 4104, 4106, 1, 0, 0, 0, 4105, 4102, 1, 0, 0, 0, 4105,
		4106, 1, 0, 0, 0, 4106, 4107, 1, 0, 0, 0, 4107, 4109, 3, 438, 219, 0, 4108,
		4099, 1, 0, 0, 0, 4108, 4101, 1, 0, 0, 0, 4109, 145, 1, 0, 0, 0, 4110,
		4117, 5, 472, 0, 0, 4111, 4112, 3, 438, 219, 0, 4112, 4113, 5, 5, 0, 0,
		4113, 4115, 1, 0, 0, 0, 4114, 4111, 1, 0, 0, 0, 4114, 4115, 1, 0, 0, 0,
		4115, 4116, 1, 0, 0, 0, 4116, 4118, 3, 438, 219, 0, 4117, 4114, 1, 0, 0,
		0, 4117, 4118, 1, 0, 0, 0, 4118, 4119, 1, 0, 0, 0, 4119, 4120, 5, 524,
		0, 0, 4120, 4121, 3, 438, 219, 0, 4121, 147, 1, 0, 0, 0, 4122, 4123, 5,
		458, 0, 0, 4123, 4124, 5, 436, 0, 0, 4124, 4126, 3, 322, 161, 0, 4125,
		4127, 3, 402, 201, 0, 4126, 4125, 1, 0, 0, 0, 4126, 4127, 1, 0, 0, 0, 4127,
		4129, 1, 0, 0, 0, 4128, 4130, 5, 184, 0, 0, 4129, 4128, 1, 0, 0, 0, 4129,
		4130, 1, 0, 0, 0, 4130, 4155, 1, 0, 0, 0, 4131, 4132, 5, 97, 0, 0, 4132,
		4133, 5, 230, 0, 0, 4133, 4135, 3, 322, 161, 0, 4134, 4136, 3, 300, 150,
		0, 4135, 4134, 1, 0, 0, 0, 4135, 4136, 1, 0, 0, 0, 4136, 4137, 1, 0, 0,
		0, 4137, 4149, 5, 187, 0, 0, 4138, 4150, 3, 150, 75, 0, 4139, 4140, 5,
		2, 0, 0, 4140, 4141, 5, 401, 0, 0, 4141, 4142, 3, 242, 121, 0, 4142, 4143,
		5, 187, 0, 0, 4143, 4145, 3, 150, 75, 0, 4144, 4146, 3, 244, 122, 0, 4145,
		4144, 1, 0, 0, 0, 4145, 4146, 1, 0, 0, 0, 4146, 4147, 1, 0, 0, 0, 4147,
		4148, 5, 3, 0, 0, 4148, 4150, 1, 0, 0, 0, 4149, 4138, 1, 0, 0, 0, 4149,
		4139, 1, 0, 0, 0, 4150, 4152, 1, 0, 0, 0, 4151, 4153, 3, 310, 155, 0, 4152,
		4151, 1, 0, 0, 0, 4152, 4153, 1, 0, 0, 0, 4153, 4155, 1, 0, 0, 0, 4154,
		4122, 1, 0, 0, 0, 4154, 4131, 1, 0, 0, 0, 4155, 149, 1, 0, 0, 0, 4156,
		4159, 5, 524, 0, 0, 4157, 4160, 3, 438, 219, 0, 4158, 4160, 5, 512, 0,
		0, 4159, 4157, 1, 0, 0, 0, 4159, 4158, 1, 0, 0, 0, 4160, 4164, 1, 0, 0,
		0, 4161, 4162, 5, 2, 0, 0, 4162, 4163, 5, 526, 0, 0, 4163, 4165, 5, 3,
		0, 0, 4164, 4161, 1, 0, 0, 0, 4164, 4165, 1, 0, 0, 0, 4165, 151, 1, 0,
		0, 0, 4166, 4168, 5, 246, 0, 0, 4167, 4169, 5, 90, 0, 0, 4168, 4167, 1,
		0, 0, 0, 4168, 4169, 1, 0, 0, 0, 4169, 4170, 1, 0, 0, 0, 4170, 4175, 5,
		531, 0, 0, 4171, 4172, 5, 246, 0, 0, 4172, 4173, 5, 352, 0, 0, 4173, 4175,
		7, 25, 0, 0, 4174, 4166, 1, 0, 0, 0, 4174, 4171, 1, 0, 0, 0, 4175, 153,
		1, 0, 0, 0, 4176, 4177, 3, 192, 96, 0, 4177, 4178, 5, 191, 0, 0, 4178,
		4179, 3, 438, 219, 0, 4179, 4181, 5, 2, 0, 0, 4180, 4182, 3, 312, 156,
		0, 4181, 4180, 1, 0, 0, 0, 4181, 4182, 1, 0, 0, 0, 4182, 4183, 1, 0, 0,
		0, 4183, 4184, 5, 3, 0, 0, 4184, 4185, 3, 320, 160, 0, 4185, 4196, 1, 0,
		0, 0, 4186, 4187, 3, 192, 96, 0, 4187, 4188, 3, 322, 161, 0, 4188, 4189,
		5, 20, 0, 0, 4189, 4196, 1, 0, 0, 0, 4190, 4191, 3, 192, 96, 0, 4191, 4193,
		3, 322, 161, 0, 4192, 4194, 3, 402, 201, 0, 4193, 4192, 1, 0, 0, 0, 4193,
		4194, 1, 0, 0, 0, 4194, 4196, 1, 0, 0, 0, 4195, 4176, 1, 0, 0, 0, 4195,
		4186, 1, 0, 0, 0, 4195, 4190, 1, 0, 0, 0, 4196, 155, 1, 0, 0, 0, 4197,
		4198, 5, 343, 0, 0, 4198, 4199, 5, 244, 0, 0, 4199, 4210, 3, 300, 150,
		0, 4200, 4201, 5, 466, 0, 0, 4201, 4210, 3, 300, 150, 0, 4202, 4203, 5,
		183, 0, 0, 4203, 4204, 5, 244, 0, 0, 4204, 4205, 3, 300, 150, 0, 4205,
		4206, 5, 365, 0, 0, 4206, 4207, 3, 322, 161, 0, 4207, 4208, 3, 300, 150,
		0, 4208, 4210, 1, 0, 0, 0, 4209, 4197, 1, 0, 0, 0, 4209, 4200, 1, 0, 0,
		0, 4209, 4202, 1, 0, 0, 0, 4210, 157, 1, 0, 0, 0, 4211, 4213, 5, 443, 0,
		0, 4212, 4211, 1, 0, 0, 0, 4212, 4213, 1, 0, 0, 0, 4213, 4214, 1, 0, 0,
		0, 4214, 4215, 7, 26, 0, 0, 4215, 4226, 3, 300, 150, 0, 4216, 4218, 5,
		443, 0, 0, 4217, 4216, 1, 0, 0, 0, 4217, 4218, 1, 0, 0, 0, 4218, 4219,
		1, 0, 0, 0, 4219, 4220, 5, 319, 0, 0, 4220, 4226, 3, 434, 217, 0, 4221,
		4222, 7, 26, 0, 0, 4222, 4223, 5, 2, 0, 0, 4223, 4224, 5, 509, 0, 0, 4224,
		4226, 5, 3, 0, 0, 4225, 4212, 1, 0, 0, 0, 4225, 4217, 1, 0, 0, 0, 4225,
		4221, 1, 0, 0, 0, 4226, 159, 1, 0, 0, 0, 4227, 4229, 5, 32, 0, 0, 4228,
		4227, 1, 0, 0, 0, 4228, 4229, 1, 0, 0, 0, 4229, 4230, 1, 0, 0, 0, 4230,
		4231, 5, 319, 0, 0, 4231, 4233, 5, 59, 0, 0, 4232, 4234, 7, 27, 0, 0, 4233,
		4232, 1, 0, 0, 0, 4233, 4234, 1, 0, 0, 0, 4234, 4235, 1, 0, 0, 0, 4235,
		4236, 3, 162, 81, 0, 4236, 4238, 5, 2, 0, 0, 4237, 4239, 3, 336, 168, 0,
		4238, 4237, 1, 0, 0, 0, 4238, 4239, 1, 0, 0, 0, 4239, 4240, 1, 0, 0, 0,
		4240, 4241, 5, 3, 0, 0, 4241, 161, 1, 0, 0, 0, 4242, 4243, 5, 2, 0, 0,
		4243, 4248, 3, 164, 82, 0, 4244, 4245, 5, 4, 0, 0, 4245, 4247, 3, 164,
		82, 0, 4246, 4244, 1, 0, 0, 0, 4247, 4250, 1, 0, 0, 0, 4248, 4246, 1, 0,
		0, 0, 4248, 4249, 1, 0, 0, 0, 4249, 4251, 1, 0, 0, 0, 4250, 4248, 1, 0,
		0, 0, 4251, 4252, 5, 3, 0, 0, 4252, 163, 1, 0, 0, 0, 4253, 4256, 3, 438,
		219, 0, 4254, 4256, 3, 386, 193, 0, 4255, 4253, 1, 0, 0, 0, 4255, 4254,
		1, 0, 0, 0, 4256, 165, 1, 0, 0, 0, 4257, 4259, 5, 494, 0, 0, 4258, 4257,
		1, 0, 0, 0, 4258, 4259, 1, 0, 0, 0, 4259, 4260, 1, 0, 0, 0, 4260, 4262,
		3, 200, 100, 0, 4261, 4258, 1, 0, 0, 0, 4261, 4262, 1, 0, 0, 0, 4262, 4263,
		1, 0, 0, 0, 4263, 4264, 5, 110, 0, 0, 4264, 4265, 5, 221, 0, 0, 4265, 4266,
		5, 2, 0, 0, 4266, 4271, 5, 526, 0, 0, 4267, 4268, 5, 4, 0, 0, 4268, 4270,
		5, 526, 0, 0, 4269, 4267, 1, 0, 0, 0, 4270, 4273, 1, 0, 0, 0, 4271, 4269,
		1, 0, 0, 0, 4271, 4272, 1, 0, 0, 0, 4272, 4274, 1, 0, 0, 0, 4273, 4271,
		1, 0, 0, 0, 4274, 4275, 5, 3, 0, 0, 4275, 4276, 5, 230, 0, 0, 4276, 4277,
		5, 436, 0, 0, 4277, 4279, 3, 438, 219, 0, 4278, 4280, 3, 158, 79, 0, 4279,
		4278, 1, 0, 0, 0, 4279, 4280, 1, 0, 0, 0, 4280, 4285, 1, 0, 0, 0, 4281,
		4282, 5, 80, 0, 0, 4282, 4283, 5, 444, 0, 0, 4283, 4284, 5, 59, 0, 0, 4284,
		4286, 5, 526, 0, 0, 4285, 4281, 1, 0, 0, 0, 4285, 4286, 1, 0, 0, 0, 4286,
		4291, 1, 0, 0, 0, 4287, 4288, 5, 258, 0, 0, 4288, 4289, 5, 444, 0, 0, 4289,
		4290, 5, 59, 0, 0, 4290, 4292, 5, 526, 0, 0, 4291, 4287, 1, 0, 0, 0, 4291,
		4292, 1, 0, 0, 0, 4292, 4296, 1, 0, 0, 0, 4293, 4294, 5, 185, 0, 0, 4294,
		4295, 5, 28, 0, 0, 4295, 4297, 3, 178, 89, 0, 4296, 4293, 1, 0, 0, 0, 4296,
		4297, 1, 0, 0, 0, 4297, 4301, 1, 0, 0, 0, 4298, 4299, 5, 86, 0, 0, 4299,
		4300, 5, 28, 0, 0, 4300, 4302, 3, 178, 89, 0, 4301, 4298, 1, 0, 0, 0, 4301,
		4302, 1, 0, 0, 0, 4302, 4304, 1, 0, 0, 0, 4303, 4305, 3, 300, 150, 0, 4304,
		4303, 1, 0, 0, 0, 4304, 4305, 1, 0, 0, 0, 4305, 4307, 1, 0, 0, 0, 4306,
		4308, 3, 208, 104, 0, 4307, 4306, 1, 0, 0, 0, 4307, 4308, 1, 0, 0, 0, 4308,
		4310, 1, 0, 0, 0, 4309, 4311, 3, 210, 105, 0, 4310, 4309, 1, 0, 0, 0, 4310,
		4311, 1, 0, 0, 0, 4311, 4313, 1, 0, 0, 0, 4312, 4314, 3, 202, 101, 0, 4313,
		4312, 1, 0, 0, 0, 4313, 4314, 1, 0, 0, 0, 4314, 4316, 1, 0, 0, 0, 4315,
		4317, 3, 244, 122, 0, 4316, 4315, 1, 0, 0, 0, 4316, 4317, 1, 0, 0, 0, 4317,
		4319, 1, 0, 0, 0, 4318, 4320, 3, 204, 102, 0, 4319, 4318, 1, 0, 0, 0, 4319,
		4320, 1, 0, 0, 0, 4320, 4322, 1, 0, 0, 0, 4321, 4323, 3, 206, 103, 0, 4322,
		4321, 1, 0, 0, 0, 4322, 4323, 1, 0, 0, 0, 4323, 4325, 1, 0, 0, 0, 4324,
		4326, 3, 310, 155, 0, 4325, 4324, 1, 0, 0, 0, 4325, 4326, 1, 0, 0, 0, 4326,
		4357, 1, 0, 0, 0, 4327, 4329, 5, 494, 0, 0, 4328, 4327, 1, 0, 0, 0, 4328,
		4329, 1, 0, 0, 0, 4329, 4330, 1, 0, 0, 0, 4330, 4332, 3, 200, 100, 0, 4331,
		4328, 1, 0, 0, 0, 4331, 4332, 1, 0, 0, 0, 4332, 4333, 1, 0, 0, 0, 4333,
		4334, 5, 110, 0, 0, 4334, 4335, 5, 187, 0, 0, 4335, 4336, 5, 436, 0, 0,
		4336, 4337, 3, 438, 219, 0, 4337, 4338, 5, 230, 0, 0, 4338, 4339, 5, 436,
		0, 0, 4339, 4342, 3, 438, 219, 0, 4340, 4341, 5, 319, 0, 0, 4341, 4343,
		3, 300, 150, 0, 4342, 4340, 1, 0, 0, 0, 4342, 4343, 1, 0, 0, 0, 4343, 4345,
		1, 0, 0, 0, 4344, 4346, 3, 210, 105, 0, 4345, 4344, 1, 0, 0, 0, 4345, 4346,
		1, 0, 0, 0, 4346, 4348, 1, 0, 0, 0, 4347, 4349, 3, 244, 122, 0, 4348, 4347,
		1, 0, 0, 0, 4348, 4349, 1, 0, 0, 0, 4349, 4351, 1, 0, 0, 0, 4350, 4352,
		3, 204, 102, 0, 4351, 4350, 1, 0, 0, 0, 4351, 4352, 1, 0, 0, 0, 4352, 4354,
		1, 0, 0, 0, 4353, 4355, 3, 310, 155, 0, 4354, 4353, 1, 0, 0, 0, 4354, 4355,
		1, 0, 0, 0, 4355, 4357, 1, 0, 0, 0, 4356, 4261, 1, 0, 0, 0, 4356, 4331,
		1, 0, 0, 0, 4357, 167, 1, 0, 0, 0, 4358, 4359, 5, 56, 0, 0, 4359, 4360,
		7, 28, 0, 0, 4360, 169, 1, 0, 0, 0, 4361, 4362, 5, 307, 0, 0, 4362, 4369,
		5, 269, 0, 0, 4363, 4364, 5, 307, 0, 0, 4364, 4365, 5, 396, 0, 0, 4365,
		4369, 3, 172, 86, 0, 4366, 4367, 5, 307, 0, 0, 4367, 4369, 5, 82, 0, 0,
		4368, 4361, 1, 0, 0, 0, 4368, 4363, 1, 0, 0, 0, 4368, 4366, 1, 0, 0, 0,
		4369, 171, 1, 0, 0, 0, 4370, 4371, 5, 160, 0, 0, 4371, 4372, 5, 531, 0,
		0, 4372, 4375, 3, 438, 219, 0, 4373, 4374, 5, 422, 0, 0, 4374, 4376, 5,
		526, 0, 0, 4375, 4373, 1, 0, 0, 0, 4375, 4376, 1, 0, 0, 0, 4376, 173, 1,
		0, 0, 0, 4377, 4378, 7, 29, 0, 0, 4378, 175, 1, 0, 0, 0, 4379, 4382, 3,
		438, 219, 0, 4380, 4382, 3, 386, 193, 0, 4381, 4379, 1, 0, 0, 0, 4381,
		4380, 1, 0, 0, 0, 4382, 177, 1, 0, 0, 0, 4383, 4386, 3, 438, 219, 0, 4384,
		4386, 5, 526, 0, 0, 4385, 4383, 1, 0, 0, 0, 4385, 4384, 1, 0, 0, 0, 4386,
		179, 1, 0, 0, 0, 4387, 4391, 3, 438, 219, 0, 4388, 4391, 5, 526, 0, 0,
		4389, 4391, 5, 509, 0, 0, 4390, 4387, 1, 0, 0, 0, 4390, 4388, 1, 0, 0,
		0, 4390, 4389, 1, 0, 0, 0, 4391, 181, 1, 0, 0, 0, 4392, 4397, 3, 184, 92,
		0, 4393, 4394, 5, 5, 0, 0, 4394, 4396, 3, 184, 92, 0, 4395, 4393, 1, 0,
		0, 0, 4396, 4399, 1, 0, 0, 0, 4397, 4395, 1, 0, 0, 0, 4397, 4398, 1, 0,
		0, 0, 4398, 183, 1, 0, 0, 0, 4399, 4397, 1, 0, 0, 0, 4400, 4403, 3, 178,
		89, 0, 4401, 4403, 5, 509, 0, 0, 4402, 4400, 1, 0, 0, 0, 4402, 4401, 1,
		0, 0, 0, 4403, 185, 1, 0, 0, 0, 4404, 4413, 3, 178, 89, 0, 4405, 4411,
		5, 524, 0, 0, 4406, 4412, 3, 178, 89, 0, 4407, 4408, 5, 2, 0, 0, 4408,
		4409, 3, 178, 89, 0, 4409, 4410, 5, 3, 0, 0, 4410, 4412, 1, 0, 0, 0, 4411,
		4406, 1, 0, 0, 0, 4411, 4407, 1, 0, 0, 0, 4412, 4414, 1, 0, 0, 0, 4413,
		4405, 1, 0, 0, 0, 4413, 4414, 1, 0, 0, 0, 4414, 187, 1, 0, 0, 0, 4415,
		4422, 3, 186, 93, 0, 4416, 4417, 5, 213, 0, 0, 4417, 4419, 5, 59, 0, 0,
		4418, 4420, 5, 321, 0, 0, 4419, 4418, 1, 0, 0, 0, 4419, 4420, 1, 0, 0,
		0, 4420, 4421, 1, 0, 0, 0, 4421, 4423, 5, 526, 0, 0, 4422, 4416, 1, 0,
		0, 0, 4422, 4423, 1, 0, 0, 0, 4423, 189, 1, 0, 0, 0, 4424, 4426, 3, 192,
		96, 0, 4425, 4427, 3, 194, 97, 0, 4426, 4425, 1, 0, 0, 0, 4426, 4427, 1,
		0, 0, 0, 4427, 4429, 1, 0, 0, 0, 4428, 4430, 7, 30, 0, 0, 4429, 4428, 1,
		0, 0, 0, 4429, 4430, 1, 0, 0, 0, 4430, 4432, 1, 0, 0, 0, 4431, 4433, 5,
		337, 0, 0, 4432, 4431, 1, 0, 0, 0, 4432, 4433, 1, 0, 0, 0, 4433, 191, 1,
		0, 0, 0, 4434, 4435, 7, 31, 0, 0, 4435, 193, 1, 0, 0, 0, 4436, 4437, 7,
		32, 0, 0, 4437, 195, 1, 0, 0, 0, 4438, 4439, 5, 334, 0, 0, 4439, 4440,
		5, 373, 0, 0, 4440, 4441, 3, 198, 99, 0, 4441, 197, 1, 0, 0, 0, 4442, 4443,
		5, 145, 0, 0, 4443, 4447, 3, 224, 112, 0, 4444, 4445, 5, 335, 0, 0, 4445,
		4447, 5, 526, 0, 0, 4446, 4442, 1, 0, 0, 0, 4446, 4444, 1, 0, 0, 0, 4447,
		199, 1, 0, 0, 0, 4448, 4449, 7, 16, 0, 0, 4449, 201, 1, 0, 0, 0, 4450,
		4451, 5, 341, 0, 0, 4451, 4452, 5, 177, 0, 0, 4452, 4453, 3, 366, 183,
		0, 4453, 203, 1, 0, 0, 0, 4454, 4455, 5, 126, 0, 0, 4455, 4456, 5, 307,
		0, 0, 4456, 4457, 3, 366, 183, 0, 4457, 205, 1, 0, 0, 0, 4458, 4459, 5,
		312, 0, 0, 4459, 4460, 5, 59, 0, 0, 4460, 4461, 3, 438, 219, 0, 4461, 207,
		1, 0, 0, 0, 4462, 4463, 5, 80, 0, 0, 4463, 4464, 5, 187, 0, 0, 4464, 4465,
		5, 326, 0, 0, 4465, 4466, 5, 28, 0, 0, 4466, 4467, 3, 300, 150, 0, 4467,
		209, 1, 0, 0, 0, 4468, 4469, 5, 406, 0, 0, 4469, 4470, 5, 2, 0, 0, 4470,
		4475, 3, 212, 106, 0, 4471, 4472, 5, 4, 0, 0, 4472, 4474, 3, 212, 106,
		0, 4473, 4471, 1, 0, 0, 0, 4474, 4477, 1, 0, 0, 0, 4475, 4473, 1, 0, 0,
		0, 4475, 4476, 1, 0, 0, 0, 4476, 4478, 1, 0, 0, 0, 4477, 4475, 1, 0, 0,
		0, 4478, 4479, 5, 3, 0, 0, 4479, 211, 1, 0, 0, 0, 4480, 4481, 3, 438, 219,
		0, 4481, 4482, 5, 500, 0, 0, 4482, 4483, 3, 366, 183, 0, 4483, 213, 1,
		0, 0, 0, 4484, 4513, 3, 216, 108, 0, 4485, 4486, 5, 494, 0, 0, 4486, 4487,
		5, 394, 0, 0, 4487, 4488, 5, 2, 0, 0, 4488, 4489, 3, 312, 156, 0, 4489,
		4490, 5, 3, 0, 0, 4490, 4513, 1, 0, 0, 0, 4491, 4492, 5, 494, 0, 0, 4492,
		4493, 5, 204, 0, 0, 4493, 4494, 5, 2, 0, 0, 4494, 4495, 3, 312, 156, 0,
		4495, 4496, 5, 3, 0, 0, 4496, 4513, 1, 0, 0, 0, 4497, 4498, 5, 494, 0,
		0, 4498, 4499, 5, 262, 0, 0, 4499, 4500, 5, 2, 0, 0, 4500, 4501, 3, 312,
		156, 0, 4501, 4502, 5, 3, 0, 0, 4502, 4513, 1, 0, 0, 0, 4503, 4504, 5,
		494, 0, 0, 4504, 4505, 5, 54, 0, 0, 4505, 4510, 3, 178, 89, 0, 4506, 4507,
		5, 2, 0, 0, 4507, 4508, 3, 312, 156, 0, 4508, 4509, 5, 3, 0, 0, 4509, 4511,
		1, 0, 0, 0, 4510, 4506, 1, 0, 0, 0, 4510, 4511, 1, 0, 0, 0, 4511, 4513,
		1, 0, 0, 0, 4512, 4484, 1, 0, 0, 0, 4512, 4485, 1, 0, 0, 0, 4512, 4491,
		1, 0, 0, 0, 4512, 4497, 1, 0, 0, 0, 4512, 4503, 1, 0, 0, 0, 4513, 215,
		1, 0, 0, 0, 4514, 4515, 5, 494, 0, 0, 4515, 4516, 5, 377, 0, 0, 4516, 4521,
		3, 178, 89, 0, 4517, 4518, 5, 2, 0, 0, 4518, 4519, 3, 312, 156, 0, 4519,
		4520, 5, 3, 0, 0, 4520, 4522, 1, 0, 0, 0, 4521, 4517, 1, 0, 0, 0, 4521,
		4522, 1, 0, 0, 0, 4522, 217, 1, 0, 0, 0, 4523, 4525, 5, 110, 0, 0, 4524,
		4526, 5, 262, 0, 0, 4525, 4524, 1, 0, 0, 0, 4525, 4526, 1, 0, 0, 0, 4526,
		4527, 1, 0, 0, 0, 4527, 4528, 5, 221, 0, 0, 4528, 4529, 5, 526, 0, 0, 4529,
		4530, 5, 230, 0, 0, 4530, 4531, 5, 436, 0, 0, 4531, 4534, 3, 322, 161,
		0, 4532, 4533, 5, 319, 0, 0, 4533, 4535, 3, 300, 150, 0, 4534, 4532, 1,
		0, 0, 0, 4534, 4535, 1, 0, 0, 0, 4535, 4540, 1, 0, 0, 0, 4536, 4537, 5,
		80, 0, 0, 4537, 4538, 5, 444, 0, 0, 4538, 4539, 5, 59, 0, 0, 4539, 4541,
		5, 526, 0, 0, 4540, 4536, 1, 0, 0, 0, 4540, 4541, 1, 0, 0, 0, 4541, 4546,
		1, 0, 0, 0, 4542, 4543, 5, 258, 0, 0, 4543, 4544, 5, 444, 0, 0, 4544, 4545,
		5, 59, 0, 0, 4545, 4547, 5, 526, 0, 0, 4546, 4542, 1, 0, 0, 0, 4546, 4547,
		1, 0, 0, 0, 4547, 4549, 1, 0, 0, 0, 4548, 4550, 3, 220, 110, 0, 4549, 4548,
		1, 0, 0, 0, 4549, 4550, 1, 0, 0, 0, 4550, 4552, 1, 0, 0, 0, 4551, 4553,
		3, 300, 150, 0, 4552, 4551, 1, 0, 0, 0, 4552, 4553, 1, 0, 0, 0, 4553, 4555,
		1, 0, 0, 0, 4554, 4556, 3, 210, 105, 0, 4555, 4554, 1, 0, 0, 0, 4555, 4556,
		1, 0, 0, 0, 4556, 4558, 1, 0, 0, 0, 4557, 4559, 3, 310, 155, 0, 4558, 4557,
		1, 0, 0, 0, 4558, 4559, 1, 0, 0, 0, 4559, 219, 1, 0, 0, 0, 4560, 4561,
		5, 215, 0, 0, 4561, 4562, 5, 531, 0, 0, 4562, 4567, 5, 258, 0, 0, 4563,
		4564, 5, 215, 0, 0, 4564, 4565, 5, 531, 0, 0, 4565, 4567, 5, 393, 0, 0,
		4566, 4560, 1, 0, 0, 0, 4566, 4563, 1, 0, 0, 0, 4567, 221, 1, 0, 0, 0,
		4568, 4569, 5, 230, 0, 0, 4569, 4570, 5, 314, 0, 0, 4570, 4574, 3, 404,
		202, 0, 4571, 4572, 5, 185, 0, 0, 4572, 4573, 5, 28, 0, 0, 4573, 4575,
		3, 438, 219, 0, 4574, 4571, 1, 0, 0, 0, 4574, 4575, 1, 0, 0, 0, 4575, 4577,
		1, 0, 0, 0, 4576, 4578, 3, 310, 155, 0, 4577, 4576, 1, 0, 0, 0, 4577, 4578,
		1, 0, 0, 0, 4578, 223, 1, 0, 0, 0, 4579, 4581, 3, 234, 117, 0, 4580, 4579,
		1, 0, 0, 0, 4580, 4581, 1, 0, 0, 0, 4581, 4582, 1, 0, 0, 0, 4582, 4583,
		3, 226, 113, 0, 4583, 4584, 3, 286, 143, 0, 4584, 225, 1, 0, 0, 0, 4585,
		4586, 6, 113, -1, 0, 4586, 4587, 3, 230, 115, 0, 4587, 4602, 1, 0, 0, 0,
		4588, 4589, 10, 2, 0, 0, 4589, 4591, 5, 228, 0, 0, 4590, 4592, 3, 228,
		114, 0, 4591, 4590, 1, 0, 0, 0, 4591, 4592, 1, 0, 0, 0, 4592, 4593, 1,
		0, 0, 0, 4593, 4601, 3, 226, 113, 3, 4594, 4595, 10, 1, 0, 0, 4595, 4597,
		7, 33, 0, 0, 4596, 4598, 3, 228, 114, 0, 4597, 4596, 1, 0, 0, 0, 4597,
		4598, 1, 0, 0, 0, 4598, 4599, 1, 0, 0, 0, 4599, 4601, 3, 226, 113, 2, 4600,
		4588, 1, 0, 0, 0, 4600, 4594, 1, 0, 0, 0, 4601, 4604, 1, 0, 0, 0, 4602,
		4600, 1, 0, 0, 0, 4602, 4603, 1, 0, 0, 0, 4603, 227, 1, 0, 0, 0, 4604,
		4602, 1, 0, 0, 0, 4605, 4606, 7, 34, 0, 0, 4606, 229, 1, 0, 0, 0, 4607,
		4614, 3, 232, 116, 0, 4608, 4609, 5, 2, 0, 0, 4609, 4610, 3, 224, 112,
		0, 4610, 4611, 5, 3, 0, 0, 4611, 4614, 1, 0, 0, 0, 4612, 4614, 3, 360,
		180, 0, 4613, 4607, 1, 0, 0, 0, 4613, 4608, 1, 0, 0, 0, 4613, 4612, 1,
		0, 0, 0, 4614, 231, 1, 0, 0, 0, 4615, 4617, 3, 240, 120, 0, 4616, 4618,
		3, 248, 124, 0, 4617, 4616, 1, 0, 0, 0, 4617, 4618, 1, 0, 0, 0, 4618, 4620,
		1, 0, 0, 0, 4619, 4621, 3, 246, 123, 0, 4620, 4619, 1, 0, 0, 0, 4620, 4621,
		1, 0, 0, 0, 4621, 4623, 1, 0, 0, 0, 4622, 4624, 3, 244, 122, 0, 4623, 4622,
		1, 0, 0, 0, 4623, 4624, 1, 0, 0, 0, 4624, 4626, 1, 0, 0, 0, 4625, 4627,
		3, 264, 132, 0, 4626, 4625, 1, 0, 0, 0, 4626, 4627, 1, 0, 0, 0, 4627, 4629,
		1, 0, 0, 0, 4628, 4630, 3, 270, 135, 0, 4629, 4628, 1, 0, 0, 0, 4629, 4630,
		1, 0, 0, 0, 4630, 4632, 1, 0, 0, 0, 4631, 4633, 3, 272, 136, 0, 4632, 4631,
		1, 0, 0, 0, 4632, 4633, 1, 0, 0, 0, 4633, 4634, 1, 0, 0, 0, 4634, 4635,
		4, 116, 2, 0, 4635, 4636, 3, 286, 143, 0, 4636, 233, 1, 0, 0, 0, 4637,
		4638, 5, 494, 0, 0, 4638, 4643, 3, 236, 118, 0, 4639, 4640, 5, 4, 0, 0,
		4640, 4642, 3, 236, 118, 0, 4641, 4639, 1, 0, 0, 0, 4642, 4645, 1, 0, 0,
		0, 4643, 4641, 1, 0, 0, 0, 4643, 4644, 1, 0, 0, 0, 4644, 235, 1, 0, 0,
		0, 4645, 4643, 1, 0, 0, 0, 4646, 4648, 3, 438, 219, 0, 4647, 4649, 3, 238,
		119, 0, 4648, 4647, 1, 0, 0, 0, 4648, 4649, 1, 0, 0, 0, 4649, 4650, 1,
		0, 0, 0, 4650, 4651, 5, 28, 0, 0, 4651, 4652, 5, 2, 0, 0, 4652, 4653, 3,
		224, 112, 0, 4653, 4654, 5, 3, 0, 0, 4654, 237, 1, 0, 0, 0, 4655, 4656,
		5, 2, 0, 0, 4656, 4661, 3, 438, 219, 0, 4657, 4658, 5, 4, 0, 0, 4658, 4660,
		3, 438, 219, 0, 4659, 4657, 1, 0, 0, 0, 4660, 4663, 1, 0, 0, 0, 4661, 4659,
		1, 0, 0, 0, 4661, 4662, 1, 0, 0, 0, 4662, 4664, 1, 0, 0, 0, 4663, 4661,
		1, 0, 0, 0, 4664, 4665, 5, 3, 0, 0, 4665, 239, 1, 0, 0, 0, 4666, 4668,
		5, 401, 0, 0, 4667, 4669, 7, 34, 0, 0, 4668, 4667, 1, 0, 0, 0, 4668, 4669,
		1, 0, 0, 0, 4669, 4670, 1, 0, 0, 0, 4670, 4671, 3, 242, 121, 0, 4671, 241,
		1, 0, 0, 0, 4672, 4673, 3, 364, 182, 0, 4673, 243, 1, 0, 0, 0, 4674, 4675,
		5, 492, 0, 0, 4675, 4676, 3, 370, 185, 0, 4676, 245, 1, 0, 0, 0, 4677,
		4678, 5, 187, 0, 0, 4678, 4679, 3, 254, 127, 0, 4679, 247, 1, 0, 0, 0,
		4680, 4682, 3, 250, 125, 0, 4681, 4680, 1, 0, 0, 0, 4681, 4682, 1, 0, 0,
		0, 4682, 4683, 1, 0, 0, 0, 4683, 4686, 5, 230, 0, 0, 4684, 4687, 3, 252,
		126, 0, 4685, 4687, 3, 438, 219, 0, 4686, 4684, 1, 0, 0, 0, 4686, 4685,
		1, 0, 0, 0, 4687, 4695, 1, 0, 0, 0, 4688, 4691, 5, 4, 0, 0, 4689, 4692,
		3, 252, 126, 0, 4690, 4692, 3, 438, 219, 0, 4691, 4689, 1, 0, 0, 0, 4691,
		4690, 1, 0, 0, 0, 4692, 4694, 1, 0, 0, 0, 4693, 4688, 1, 0, 0, 0, 4694,
		4697, 1, 0, 0, 0, 4695, 4693, 1, 0, 0, 0, 4695, 4696, 1, 0, 0, 0, 4696,
		249, 1, 0, 0, 0, 4697, 4695, 1, 0, 0, 0, 4698, 4699, 5, 58, 0, 0, 4699,
		4700, 5, 77, 0, 0, 4700, 251, 1, 0, 0, 0, 4701, 4702, 3, 438, 219, 0, 4702,
		4703, 5, 2, 0, 0, 4703, 4704, 5, 531, 0, 0, 4704, 4705, 5, 3, 0, 0, 4705,
		253, 1, 0, 0, 0, 4706, 4711, 3, 256, 128, 0, 4707, 4708, 5, 4, 0, 0, 4708,
		4710, 3, 256, 128, 0, 4709, 4707, 1, 0, 0, 0, 4710, 4713, 1, 0, 0, 0, 4711,
		4709, 1, 0, 0, 0, 4711, 4712, 1, 0, 0, 0, 4712, 255, 1, 0, 0, 0, 4713,
		4711, 1, 0, 0, 0, 4714, 4718, 3, 306, 153, 0, 4715, 4717, 3, 258, 129,
		0, 4716, 4715, 1, 0, 0, 0, 4717, 4720, 1, 0, 0, 0, 4718, 4716, 1, 0, 0,
		0, 4718, 4719, 1, 0, 0, 0, 4719, 257, 1, 0, 0, 0, 4720, 4718, 1, 0, 0,
		0, 4721, 4722, 3, 296, 148, 0, 4722, 4724, 5, 241, 0, 0, 4723, 4725, 3,
		260, 130, 0, 4724, 4723, 1, 0, 0, 0, 4724, 4725, 1, 0, 0, 0, 4725, 4726,
		1, 0, 0, 0, 4726, 4728, 3, 306, 153, 0, 4727, 4729, 3, 298, 149, 0, 4728,
		4727, 1, 0, 0, 0, 4728, 4729, 1, 0, 0, 0, 4729, 259, 1, 0, 0, 0, 4730,
		4731, 5, 7, 0, 0, 4731, 4732, 3, 438, 219, 0, 4732, 4733, 5, 8, 0, 0, 4733,
		4739, 1, 0, 0, 0, 4734, 4735, 5, 521, 0, 0, 4735, 4736, 3, 438, 219, 0,
		4736, 4737, 5, 522, 0, 0, 4737, 4739, 1, 0, 0, 0, 4738, 4730, 1, 0, 0,
		0, 4738, 4734, 1, 0, 0, 0, 4739, 261, 1, 0, 0, 0, 4740, 4741, 5, 7, 0,
		0, 4741, 4746, 3, 438, 219, 0, 4742, 4743, 5, 4, 0, 0, 4743, 4745, 3, 438,
		219, 0, 4744, 4742, 1, 0, 0, 0, 4745, 4748, 1, 0, 0, 0, 4746, 4744, 1,
		0, 0, 0, 4746, 4747, 1, 0, 0, 0, 4747, 4749, 1, 0, 0, 0, 4748, 4746, 1,
		0, 0, 0, 4749, 4750, 5, 8, 0, 0, 4750, 4763, 1, 0, 0, 0, 4751, 4752, 5,
		521, 0, 0, 4752, 4757, 3, 438, 219, 0, 4753, 4754, 5, 4, 0, 0, 4754, 4756,
		3, 438, 219, 0, 4755, 4753, 1, 0, 0, 0, 4756, 4759, 1, 0, 0, 0, 4757, 4755,
		1, 0, 0, 0, 4757, 4758, 1, 0, 0, 0, 4758, 4760, 1, 0, 0, 0, 4759, 4757,
		1, 0, 0, 0, 4760, 4761, 5, 522, 0, 0, 4761, 4763, 1, 0, 0, 0, 4762, 4740,
		1, 0, 0, 0, 4762, 4751, 1, 0, 0, 0, 4763, 263, 1, 0, 0, 0, 4764, 4765,
		5, 199, 0, 0, 4765, 4766, 5, 59, 0, 0, 4766, 4767, 3, 266, 133, 0, 4767,
		265, 1, 0, 0, 0, 4768, 4769, 5, 390, 0, 0, 4769, 4778, 5, 2, 0, 0, 4770,
		4775, 3, 366, 183, 0, 4771, 4772, 5, 4, 0, 0, 4772, 4774, 3, 366, 183,
		0, 4773, 4771, 1, 0, 0, 0, 4774, 4777, 1, 0, 0, 0, 4775, 4773, 1, 0, 0,
		0, 4775, 4776, 1, 0, 0, 0, 4776, 4779, 1, 0, 0, 0, 4777, 4775, 1, 0, 0,
		0, 4778, 4770, 1, 0, 0, 0, 4778, 4779, 1, 0, 0, 0, 4779, 4780, 1, 0, 0,
		0, 4780, 4816, 5, 3, 0, 0, 4781, 4782, 5, 103, 0, 0, 4782, 4791, 5, 2,
		0, 0, 4783, 4788, 3, 366, 183, 0, 4784, 4785, 5, 4, 0, 0, 4785, 4787, 3,
		366, 183, 0, 4786, 4784, 1, 0, 0, 0, 4787, 4790, 1, 0, 0, 0, 4788, 4786,
		1, 0, 0, 0, 4788, 4789, 1, 0, 0, 0, 4789, 4792, 1, 0, 0, 0, 4790, 4788,
		1, 0, 0, 0, 4791, 4783, 1, 0, 0, 0, 4791, 4792, 1, 0, 0, 0, 4792, 4793,
		1, 0, 0, 0, 4793, 4816, 5, 3, 0, 0, 4794, 4795, 5, 200, 0, 0, 4795, 4796,
		5, 407, 0, 0, 4796, 4797, 5, 2, 0, 0, 4797, 4802, 3, 268, 134, 0, 4798,
		4799, 5, 4, 0, 0, 4799, 4801, 3, 268, 134, 0, 4800, 4798, 1, 0, 0, 0, 4801,
		4804, 1, 0, 0, 0, 4802, 4800, 1, 0, 0, 0, 4802, 4803, 1, 0, 0, 0, 4803,
		4805, 1, 0, 0, 0, 4804, 4802, 1, 0, 0, 0, 4805, 4806, 5, 3, 0, 0, 4806,
		4816, 1, 0, 0, 0, 4807, 4812, 3, 366, 183, 0, 4808, 4809, 5, 4, 0, 0, 4809,
		4811, 3, 366, 183, 0, 4810, 4808, 1, 0, 0, 0, 4811, 4814, 1, 0, 0, 0, 4812,
		4810, 1, 0, 0, 0, 4812, 4813, 1, 0, 0, 0, 4813, 4816, 1, 0, 0, 0, 4814,
		4812, 1, 0, 0, 0, 4815, 4768, 1, 0, 0, 0, 4815, 4781, 1, 0, 0, 0, 4815,
		4794, 1, 0, 0, 0, 4815, 4807, 1, 0, 0, 0, 4816, 267, 1, 0, 0, 0, 4817,
		4826, 5, 2, 0, 0, 4818, 4823, 3, 366, 183, 0, 4819, 4820, 5, 4, 0, 0, 4820,
		4822, 3, 366, 183, 0, 4821, 4819, 1, 0, 0, 0, 4822, 4825, 1, 0, 0, 0, 4823,
		4821, 1, 0, 0, 0, 4823, 4824, 1, 0, 0, 0, 4824, 4827, 1, 0, 0, 0, 4825,
		4823, 1, 0, 0, 0, 4826, 4818, 1, 0, 0, 0, 4826, 4827, 1, 0, 0, 0, 4827,
		4828, 1, 0, 0, 0, 4828, 4829, 5, 3, 0, 0, 4829, 269, 1, 0, 0, 0, 4830,
		4831, 5, 203, 0, 0, 4831, 4832, 3, 370, 185, 0, 4832, 271, 1, 0, 0, 0,
		4833, 4834, 5, 354, 0, 0, 4834, 4835, 3, 370, 185, 0, 4835, 273, 1, 0,
		0, 0, 4836, 4843, 3, 276, 138, 0, 4837, 4839, 5, 4, 0, 0, 4838, 4837, 1,
		0, 0, 0, 4838, 4839, 1, 0, 0, 0, 4839, 4840, 1, 0, 0, 0, 4840, 4842, 3,
		276, 138, 0, 4841, 4838, 1, 0, 0, 0, 4842, 4845, 1, 0, 0, 0, 4843, 4841,
		1, 0, 0, 0, 4843, 4844, 1, 0, 0, 0, 4844, 4846, 1, 0, 0, 0, 4845, 4843,
		1, 0, 0, 0, 4846, 4847, 5, 522, 0, 0, 4847, 275, 1, 0, 0, 0, 4848, 4862,
		3, 438, 219, 0, 4849, 4850, 5, 2, 0, 0, 4850, 4857, 3, 278, 139, 0, 4851,
		4853, 5, 4, 0, 0, 4852, 4851, 1, 0, 0, 0, 4852, 4853, 1, 0, 0, 0, 4853,
		4854, 1, 0, 0, 0, 4854, 4856, 3, 278, 139, 0, 4855, 4852, 1, 0, 0, 0, 4856,
		4859, 1, 0, 0, 0, 4857, 4855, 1, 0, 0, 0, 4857, 4858, 1, 0, 0, 0, 4858,
		4860, 1, 0, 0, 0, 4859, 4857, 1, 0, 0, 0, 4860, 4861, 5, 3, 0, 0, 4861,
		4863, 1, 0, 0, 0, 4862, 4849, 1, 0, 0, 0, 4862, 4863, 1, 0, 0, 0, 4863,
		4879, 1, 0, 0, 0, 4864, 4876, 7, 35, 0, 0, 4865, 4866, 5, 2, 0, 0, 4866,
		4871, 3, 322, 161, 0, 4867, 4868, 5, 4, 0, 0, 4868, 4870, 3, 322, 161,
		0, 4869, 4867, 1, 0, 0, 0, 4870, 4873, 1, 0, 0, 0, 4871, 4869, 1, 0, 0,
		0, 4871, 4872, 1, 0, 0, 0, 4872, 4874, 1, 0, 0, 0, 4873, 4871, 1, 0, 0,
		0, 4874, 4875, 5, 3, 0, 0, 4875, 4877, 1, 0, 0, 0, 4876, 4865, 1, 0, 0,
		0, 4876, 4877, 1, 0, 0, 0, 4877, 4879, 1, 0, 0, 0, 4878, 4848, 1, 0, 0,
		0, 4878, 4864, 1, 0, 0, 0, 4879, 277, 1, 0, 0, 0, 4880, 4886, 3, 178, 89,
		0, 4881, 4884, 5, 500, 0, 0, 4882, 4885, 3, 404, 202, 0, 4883, 4885, 3,
		438, 219, 0, 4884, 4882, 1, 0, 0, 0, 4884, 4883, 1, 0, 0, 0, 4885, 4887,
		1, 0, 0, 0, 4886, 4881, 1, 0, 0, 0, 4886, 4887, 1, 0, 0, 0, 4887, 4890,
		1, 0, 0, 0, 4888, 4890, 3, 404, 202, 0, 4889, 4880, 1, 0, 0, 0, 4889, 4888,
		1, 0, 0, 0, 4890, 279, 1, 0, 0, 0, 4891, 4892, 3, 322, 161, 0, 4892, 4895,
		5, 500, 0, 0, 4893, 4896, 3, 366, 183, 0, 4894, 4896, 5, 124, 0, 0, 4895,
		4893, 1, 0, 0, 0, 4895, 4894, 1, 0, 0, 0, 4896, 281, 1, 0, 0, 0, 4897,
		4902, 3, 280, 140, 0, 4898, 4899, 5, 4, 0, 0, 4899, 4901, 3, 280, 140,
		0, 4900, 4898, 1, 0, 0, 0, 4901, 4904, 1, 0, 0, 0, 4902, 4900, 1, 0, 0,
		0, 4902, 4903, 1, 0, 0, 0, 4903, 283, 1, 0, 0, 0, 4904, 4902, 1, 0, 0,
		0, 4905, 4906, 5, 250, 0, 0, 4906, 4907, 5, 486, 0, 0, 4907, 4908, 3, 438,
		219, 0, 4908, 4917, 5, 2, 0, 0, 4909, 4914, 3, 366, 183, 0, 4910, 4911,
		5, 4, 0, 0, 4911, 4913, 3, 366, 183, 0, 4912, 4910, 1, 0, 0, 0, 4913, 4916,
		1, 0, 0, 0, 4914, 4912, 1, 0, 0, 0, 4914, 4915, 1, 0, 0, 0, 4915, 4918,
		1, 0, 0, 0, 4916, 4914, 1, 0, 0, 0, 4917, 4909, 1, 0, 0, 0, 4917, 4918,
		1, 0, 0, 0, 4918, 4919, 1, 0, 0, 0, 4919, 4920, 5, 3, 0, 0, 4920, 4921,
		3, 438, 219, 0, 4921, 4922, 5, 28, 0, 0, 4922, 4927, 3, 438, 219, 0, 4923,
		4924, 5, 4, 0, 0, 4924, 4926, 3, 438, 219, 0, 4925, 4923, 1, 0, 0, 0, 4926,
		4929, 1, 0, 0, 0, 4927, 4925, 1, 0, 0, 0, 4927, 4928, 1, 0, 0, 0, 4928,
		285, 1, 0, 0, 0, 4929, 4927, 1, 0, 0, 0, 4930, 4932, 3, 288, 144, 0, 4931,
		4930, 1, 0, 0, 0, 4931, 4932, 1, 0, 0, 0, 4932, 4934, 1, 0, 0, 0, 4933,
		4935, 3, 292, 146, 0, 4934, 4933, 1, 0, 0, 0, 4934, 4935, 1, 0, 0, 0, 4935,
		287, 1, 0, 0, 0, 4936, 4937, 5, 312, 0, 0, 4937, 4938, 5, 59, 0, 0, 4938,
		4943, 3, 290, 145, 0, 4939, 4940, 5, 4, 0, 0, 4940, 4942, 3, 290, 145,
		0, 4941, 4939, 1, 0, 0, 0, 4942, 4945, 1, 0, 0, 0, 4943, 4941, 1, 0, 0,
		0, 4943, 4944, 1, 0, 0, 0, 4944, 289, 1, 0, 0, 0, 4945, 4943, 1, 0, 0,
		0, 4946, 4948, 3, 366, 183, 0, 4947, 4949, 7, 36, 0, 0, 4948, 4947, 1,
		0, 0, 0, 4948, 4949, 1, 0, 0, 0, 4949, 4952, 1, 0, 0, 0, 4950, 4951, 5,
		303, 0, 0, 4951, 4953, 7, 37, 0, 0, 4952, 4950, 1, 0, 0, 0, 4952, 4953,
		1, 0, 0, 0, 4953, 291, 1, 0, 0, 0, 4954, 4955, 5, 257, 0, 0, 4955, 4965,
		5, 531, 0, 0, 4956, 4957, 5, 257, 0, 0, 4957, 4958, 5, 531, 0, 0, 4958,
		4959, 5, 306, 0, 0, 4959, 4965, 5, 531, 0, 0, 4960, 4961, 5, 257, 0, 0,
		4961, 4962, 5, 531, 0, 0, 4962, 4963, 5, 4, 0, 0, 4963, 4965, 5, 531, 0,
		0, 4964, 4954, 1, 0, 0, 0, 4964, 4956, 1, 0, 0, 0, 4964, 4960, 1, 0, 0,
		0, 4965, 293, 1, 0, 0, 0, 4966, 4967, 5, 319, 0, 0, 4967, 4968, 5, 59,
		0, 0, 4968, 4973, 3, 366, 183, 0, 4969, 4970, 5, 4, 0, 0, 4970, 4972, 3,
		366, 183, 0, 4971, 4969, 1, 0, 0, 0, 4972, 4975, 1, 0, 0, 0, 4973, 4971,
		1, 0, 0, 0, 4973, 4974, 1, 0, 0, 0, 4974, 295, 1, 0, 0, 0, 4975, 4973,
		1, 0, 0, 0, 4976, 4978, 5, 222, 0, 0, 4977, 4976, 1, 0, 0, 0, 4977, 4978,
		1, 0, 0, 0, 4978, 5001, 1, 0, 0, 0, 4979, 5001, 5, 102, 0, 0, 4980, 4982,
		5, 253, 0, 0, 4981, 4983, 5, 313, 0, 0, 4982, 4981, 1, 0, 0, 0, 4982, 4983,
		1, 0, 0, 0, 4983, 5001, 1, 0, 0, 0, 4984, 4986, 5, 385, 0, 0, 4985, 4987,
		5, 313, 0, 0, 4986, 4985, 1, 0, 0, 0, 4986, 4987, 1, 0, 0, 0, 4987, 5001,
		1, 0, 0, 0, 4988, 4990, 5, 190, 0, 0, 4989, 4991, 5, 313, 0, 0, 4990, 4989,
		1, 0, 0, 0, 4990, 4991, 1, 0, 0, 0, 4991, 5001, 1, 0, 0, 0, 4992, 4993,
		5, 253, 0, 0, 4993, 5001, 5, 402, 0, 0, 4994, 4995, 5, 385, 0, 0, 4995,
		5001, 5, 402, 0, 0, 4996, 4997, 5, 253, 0, 0, 4997, 5001, 5, 25, 0, 0,
		4998, 4999, 5, 385, 0, 0, 4999, 5001, 5, 25, 0, 0, 5000, 4977, 1, 0, 0,
		0, 5000, 4979, 1, 0, 0, 0, 5000, 4980, 1, 0, 0, 0, 5000, 4984, 1, 0, 0,
		0, 5000, 4988, 1, 0, 0, 0, 5000, 4992, 1, 0, 0, 0, 5000, 4994, 1, 0, 0,
		0, 5000, 4996, 1, 0, 0, 0, 5000, 4998, 1, 0, 0, 0, 5001, 297, 1, 0, 0,
		0, 5002, 5003, 5, 307, 0, 0, 5003, 5007, 3, 370, 185, 0, 5004, 5005, 5,
		475, 0, 0, 5005, 5007, 3, 300, 150, 0, 5006, 5002, 1, 0, 0, 0, 5006, 5004,
		1, 0, 0, 0, 5007, 299, 1, 0, 0, 0, 5008, 5009, 5, 2, 0, 0, 5009, 5010,
		3, 302, 151, 0, 5010, 5011, 5, 3, 0, 0, 5011, 301, 1, 0, 0, 0, 5012, 5017,
		3, 434, 217, 0, 5013, 5014, 5, 4, 0, 0, 5014, 5016, 3, 434, 217, 0, 5015,
		5013, 1, 0, 0, 0, 5016, 5019, 1, 0, 0, 0, 5017, 5015, 1, 0, 0, 0, 5017,
		5018, 1, 0, 0, 0, 5018, 303, 1, 0, 0, 0, 5019, 5017, 1, 0, 0, 0, 5020,
		5021, 5, 524, 0, 0, 5021, 5022, 3, 438, 219, 0, 5022, 5024, 5, 2, 0, 0,
		5023, 5025, 3, 312, 156, 0, 5024, 5023, 1, 0, 0, 0, 5024, 5025, 1, 0, 0,
		0, 5025, 5026, 1, 0, 0, 0, 5026, 5027, 5, 3, 0, 0, 5027, 305, 1, 0, 0,
		0, 5028, 5030, 3, 322, 161, 0, 5029, 5031, 3, 304, 152, 0, 5030, 5029,
		1, 0, 0, 0, 5030, 5031, 1, 0, 0, 0, 5031, 5033, 1, 0, 0, 0, 5032, 5034,
		3, 308, 154, 0, 5033, 5032, 1, 0, 0, 0, 5033, 5034, 1, 0, 0, 0, 5034, 5036,
		1, 0, 0, 0, 5035, 5037, 3, 432, 216, 0, 5036, 5035, 1, 0, 0, 0, 5036, 5037,
		1, 0, 0, 0, 5037, 5039, 1, 0, 0, 0, 5038, 5040, 3, 402, 201, 0, 5039, 5038,
		1, 0, 0, 0, 5039, 5040, 1, 0, 0, 0, 5040, 5042, 1, 0, 0, 0, 5041, 5043,
		3, 358, 179, 0, 5042, 5041, 1, 0, 0, 0, 5042, 5043, 1, 0, 0, 0, 5043, 5044,
		1, 0, 0, 0, 5044, 5046, 3, 320, 160, 0, 5045, 5047, 3, 428, 214, 0, 5046,
		5045, 1, 0, 0, 0, 5046, 5047, 1, 0, 0, 0, 5047, 5049, 1, 0, 0, 0, 5048,
		5050, 3, 262, 131, 0, 5049, 5048, 1, 0, 0, 0, 5049, 5050, 1, 0, 0, 0, 5050,
		5054, 1, 0, 0, 0, 5051, 5053, 3, 284, 142, 0, 5052, 5051, 1, 0, 0, 0, 5053,
		5056, 1, 0, 0, 0, 5054, 5052, 1, 0, 0, 0, 5054, 5055, 1, 0, 0, 0, 5055,
		5080, 1, 0, 0, 0, 5056, 5054, 1, 0, 0, 0, 5057, 5058, 5, 2, 0, 0, 5058,
		5059, 3, 224, 112, 0, 5059, 5060, 5, 3, 0, 0, 5060, 5064, 3, 320, 160,
		0, 5061, 5063, 3, 284, 142, 0, 5062, 5061, 1, 0, 0, 0, 5063, 5066, 1, 0,
		0, 0, 5064, 5062, 1, 0, 0, 0, 5064, 5065, 1, 0, 0, 0, 5065, 5080, 1, 0,
		0, 0, 5066, 5064, 1, 0, 0, 0, 5067, 5068, 3, 438, 219, 0, 5068, 5070, 5,
		2, 0, 0, 5069, 5071, 3, 312, 156, 0, 5070, 5069, 1, 0, 0, 0, 5070, 5071,
		1, 0, 0, 0, 5071, 5072, 1, 0, 0, 0, 5072, 5073, 5, 3, 0, 0, 5073, 5074,
		3, 320, 160, 0, 5074, 5080, 1, 0, 0, 0, 5075, 5076, 5, 2, 0, 0, 5076, 5077,
		3, 254, 127, 0, 5077, 5078, 5, 3, 0, 0, 5078, 5080, 1, 0, 0, 0, 5079, 5028,
		1, 0, 0, 0, 5079, 5057, 1, 0, 0, 0, 5079, 5067, 1, 0, 0, 0, 5079, 5075,
		1, 0, 0, 0, 5080, 307, 1, 0, 0, 0, 5081, 5082, 5, 219, 0, 0, 5082, 5083,
		3, 438, 219, 0, 5083, 309, 1, 0, 0, 0, 5084, 5085, 5, 348, 0, 0, 5085,
		5086, 5, 2, 0, 0, 5086, 5087, 3, 312, 156, 0, 5087, 5088, 5, 3, 0, 0, 5088,
		311, 1, 0, 0, 0, 5089, 5094, 3, 314, 157, 0, 5090, 5091, 5, 4, 0, 0, 5091,
		5093, 3, 314, 157, 0, 5092, 5090, 1, 0, 0, 0, 5093, 5096, 1, 0, 0, 0, 5094,
		5092, 1, 0, 0, 0, 5094, 5095, 1, 0, 0, 0, 5095, 313, 1, 0, 0, 0, 5096,
		5094, 1, 0, 0, 0, 5097, 5098, 3, 316, 158, 0, 5098, 5099, 5, 500, 0, 0,
		5099, 5100, 3, 318, 159, 0, 5100, 315, 1, 0, 0, 0, 5101, 5104, 3, 438,
		219, 0, 5102, 5104, 3, 404, 202, 0, 5103, 5101, 1, 0, 0, 0, 5103, 5102,
		1, 0, 0, 0, 5104, 317, 1, 0, 0, 0, 5105, 5108, 3, 438, 219, 0, 5106, 5108,
		3, 404, 202, 0, 5107, 5105, 1, 0, 0, 0, 5107, 5106, 1, 0, 0, 0, 5108, 319,
		1, 0, 0, 0, 5109, 5111, 5, 28, 0, 0, 5110, 5109, 1, 0, 0, 0, 5110, 5111,
		1, 0, 0, 0, 5111, 5112, 1, 0, 0, 0, 5112, 5114, 3, 440, 220, 0, 5113, 5115,
		3, 300, 150, 0, 5114, 5113, 1, 0, 0, 0, 5114, 5115, 1, 0, 0, 0, 5115, 5117,
		1, 0, 0, 0, 5116, 5110, 1, 0, 0, 0, 5116, 5117, 1, 0, 0, 0, 5117, 321,
		1, 0, 0, 0, 5118, 5123, 3, 434, 217, 0, 5119, 5120, 5, 5, 0, 0, 5120, 5122,
		3, 434, 217, 0, 5121, 5119, 1, 0, 0, 0, 5122, 5125, 1, 0, 0, 0, 5123, 5121,
		1, 0, 0, 0, 5123, 5124, 1, 0, 0, 0, 5124, 323, 1, 0, 0, 0, 5125, 5123,
		1, 0, 0, 0, 5126, 5131, 3, 326, 163, 0, 5127, 5128, 5, 4, 0, 0, 5128, 5130,
		3, 326, 163, 0, 5129, 5127, 1, 0, 0, 0, 5130, 5133, 1, 0, 0, 0, 5131, 5129,
		1, 0, 0, 0, 5131, 5132, 1, 0, 0, 0, 5132, 325, 1, 0, 0, 0, 5133, 5131,
		1, 0, 0, 0, 5134, 5137, 3, 438, 219, 0, 5135, 5136, 5, 81, 0, 0, 5136,
		5138, 5, 526, 0, 0, 5137, 5135, 1, 0, 0, 0, 5137, 5138, 1, 0, 0, 0, 5138,
		327, 1, 0, 0, 0, 5139, 5144, 3, 330, 165, 0, 5140, 5141, 5, 4, 0, 0, 5141,
		5143, 3, 330, 165, 0, 5142, 5140, 1, 0, 0, 0, 5143, 5146, 1, 0, 0, 0, 5144,
		5142, 1, 0, 0, 0, 5144, 5145, 1, 0, 0, 0, 5145, 329, 1, 0, 0, 0, 5146,
		5144, 1, 0, 0, 0, 5147, 5148, 3, 438, 219, 0, 5148, 5150, 3, 418, 209,
		0, 5149, 5151, 5, 244, 0, 0, 5150, 5149, 1, 0, 0, 0, 5150, 5151, 1, 0,
		0, 0, 5151, 5153, 1, 0, 0, 0, 5152, 5154, 3, 356, 178, 0, 5153, 5152, 1,
		0, 0, 0, 5153, 5154, 1, 0, 0, 0, 5154, 5164, 1, 0, 0, 0, 5155, 5156, 5,
		193, 0, 0, 5156, 5158, 5, 34, 0, 0, 5157, 5155, 1, 0, 0, 0, 5157, 5158,
		1, 0, 0, 0, 5158, 5159, 1, 0, 0, 0, 5159, 5160, 5, 28, 0, 0, 5160, 5161,
		5, 2, 0, 0, 5161, 5162, 3, 366, 183, 0, 5162, 5163, 5, 3, 0, 0, 5163, 5165,
		1, 0, 0, 0, 5164, 5157, 1, 0, 0, 0, 5164, 5165, 1, 0, 0, 0, 5165, 5170,
		1, 0, 0, 0, 5166, 5168, 5, 301, 0, 0, 5167, 5166, 1, 0, 0, 0, 5167, 5168,
		1, 0, 0, 0, 5168, 5169, 1, 0, 0, 0, 5169, 5171, 5, 302, 0, 0, 5170, 5167,
		1, 0, 0, 0, 5170, 5171, 1, 0, 0, 0, 5171, 5179, 1, 0, 0, 0, 5172, 5177,
		5, 33, 0, 0, 5173, 5174, 5, 2, 0, 0, 5174, 5175, 3, 444, 222, 0, 5175,
		5176, 5, 3, 0, 0, 5176, 5178, 1, 0, 0, 0, 5177, 5173, 1, 0, 0, 0, 5177,
		5178, 1, 0, 0, 0, 5178, 5180, 1, 0, 0, 0, 5179, 5172, 1, 0, 0, 0, 5179,
		5180, 1, 0, 0, 0, 5180, 5199, 1, 0, 0, 0, 5181, 5197, 5, 124, 0, 0, 5182,
		5198, 5, 302, 0, 0, 5183, 5198, 5, 531, 0, 0, 5184, 5198, 5, 533, 0, 0,
		5185, 5198, 5, 332, 0, 0, 5186, 5198, 5, 148, 0, 0, 5187, 5198, 5, 47,
		0, 0, 5188, 5198, 5, 526, 0, 0, 5189, 5198, 5, 106, 0, 0, 5190, 5195, 5,
		108, 0, 0, 5191, 5192, 5, 2, 0, 0, 5192, 5193, 3, 444, 222, 0, 5193, 5194,
		5, 3, 0, 0, 5194, 5196, 1, 0, 0, 0, 5195, 5191, 1, 0, 0, 0, 5195, 5196,
		1, 0, 0, 0, 5196, 5198, 1, 0, 0, 0, 5197, 5182, 1, 0, 0, 0, 5197, 5183,
		1, 0, 0, 0, 5197, 5184, 1, 0, 0, 0, 5197, 5185, 1, 0, 0, 0, 5197, 5186,
		1, 0, 0, 0, 5197, 5187, 1, 0, 0, 0, 5197, 5188, 1, 0, 0, 0, 5197, 5189,
		1, 0, 0, 0, 5197, 5190, 1, 0, 0, 0, 5198, 5200, 1, 0, 0, 0, 5199, 5181,
		1, 0, 0, 0, 5199, 5200, 1, 0, 0, 0, 5200, 5210, 1, 0, 0, 0, 5201, 5202,
		5, 307, 0, 0, 5202, 5203, 5, 471, 0, 0, 5203, 5208, 5, 108, 0, 0, 5204,
		5205, 5, 2, 0, 0, 5205, 5206, 3, 444, 222, 0, 5206, 5207, 5, 3, 0, 0, 5207,
		5209, 1, 0, 0, 0, 5208, 5204, 1, 0, 0, 0, 5208, 5209, 1, 0, 0, 0, 5209,
		5211, 1, 0, 0, 0, 5210, 5201, 1, 0, 0, 0, 5210, 5211, 1, 0, 0, 0, 5211,
		5214, 1, 0, 0, 0, 5212, 5213, 5, 81, 0, 0, 5213, 5215, 5, 526, 0, 0, 5214,
		5212, 1, 0, 0, 0, 5214, 5215, 1, 0, 0, 0, 5215, 331, 1, 0, 0, 0, 5216,
		5221, 3, 334, 167, 0, 5217, 5218, 5, 4, 0, 0, 5218, 5220, 3, 334, 167,
		0, 5219, 5217, 1, 0, 0, 0, 5220, 5223, 1, 0, 0, 0, 5221, 5219, 1, 0, 0,
		0, 5221, 5222, 1, 0, 0, 0, 5222, 333, 1, 0, 0, 0, 5223, 5221, 1, 0, 0,
		0, 5224, 5228, 5, 219, 0, 0, 5225, 5226, 5, 214, 0, 0, 5226, 5227, 5, 301,
		0, 0, 5227, 5229, 5, 164, 0, 0, 5228, 5225, 1, 0, 0, 0, 5228, 5229, 1,
		0, 0, 0, 5229, 5230, 1, 0, 0, 0, 5230, 5231, 3, 438, 219, 0, 5231, 5234,
		3, 300, 150, 0, 5232, 5233, 5, 475, 0, 0, 5233, 5235, 7, 20, 0, 0, 5234,
		5232, 1, 0, 0, 0, 5234, 5235, 1, 0, 0, 0, 5235, 5241, 1, 0, 0, 0, 5236,
		5237, 5, 348, 0, 0, 5237, 5238, 5, 2, 0, 0, 5238, 5239, 3, 312, 156, 0,
		5239, 5240, 5, 3, 0, 0, 5240, 5242, 1, 0, 0, 0, 5241, 5236, 1, 0, 0, 0,
		5241, 5242, 1, 0, 0, 0, 5242, 5245, 1, 0, 0, 0, 5243, 5244, 5, 81, 0, 0,
		5244, 5246, 5, 526, 0, 0, 5245, 5243, 1, 0, 0, 0, 5245, 5246, 1, 0, 0,
		0, 5246, 335, 1, 0, 0, 0, 5247, 5252, 3, 338, 169, 0, 5248, 5249, 5, 4,
		0, 0, 5249, 5251, 3, 338, 169, 0, 5250, 5248, 1, 0, 0, 0, 5251, 5254, 1,
		0, 0, 0, 5252, 5250, 1, 0, 0, 0, 5252, 5253, 1, 0, 0, 0, 5253, 337, 1,
		0, 0, 0, 5254, 5252, 1, 0, 0, 0, 5255, 5260, 3, 340, 170, 0, 5256, 5260,
		3, 342, 171, 0, 5257, 5260, 3, 344, 172, 0, 5258, 5260, 3, 346, 173, 0,
		5259, 5255, 1, 0, 0, 0, 5259, 5256, 1, 0, 0, 0, 5259, 5257, 1, 0, 0, 0,
		5259, 5258, 1, 0, 0, 0, 5260, 5265, 1, 0, 0, 0, 5261, 5262, 5, 2, 0, 0,
		5262, 5263, 3, 312, 156, 0, 5263, 5264, 5, 3, 0, 0, 5264, 5266, 1, 0, 0,
		0, 5265, 5261, 1, 0, 0, 0, 5265, 5266, 1, 0, 0, 0, 5266, 339, 1, 0, 0,
		0, 5267, 5271, 5, 319, 0, 0, 5268, 5269, 5, 214, 0, 0, 5269, 5270, 5, 301,
		0, 0, 5270, 5272, 5, 164, 0, 0, 5271, 5268, 1, 0, 0, 0, 5271, 5272, 1,
		0, 0, 0, 5272, 5273, 1, 0, 0, 0, 5273, 5274, 3, 438, 219, 0, 5274, 5275,
		5, 477, 0, 0, 5275, 5276, 5, 254, 0, 0, 5276, 5279, 5, 446, 0, 0, 5277,
		5280, 5, 280, 0, 0, 5278, 5280, 3, 348, 174, 0, 5279, 5277, 1, 0, 0, 0,
		5279, 5278, 1, 0, 0, 0, 5280, 341, 1, 0, 0, 0, 5281, 5285, 5, 319, 0, 0,
		5282, 5283, 5, 214, 0, 0, 5283, 5284, 5, 301, 0, 0, 5284, 5286, 5, 164,
		0, 0, 5285, 5282, 1, 0, 0, 0, 5285, 5286, 1, 0, 0, 0, 5286, 5287, 1, 0,
		0, 0, 5287, 5288, 3, 438, 219, 0, 5288, 5289, 5, 477, 0, 0, 5289, 5290,
		5, 7, 0, 0, 5290, 5291, 3, 348, 174, 0, 5291, 5292, 5, 4, 0, 0, 5292, 5293,
		3, 348, 174, 0, 5293, 5294, 5, 3, 0, 0, 5294, 343, 1, 0, 0, 0, 5295, 5296,
		5, 187, 0, 0, 5296, 5297, 3, 348, 174, 0, 5297, 5298, 5, 451, 0, 0, 5298,
		5299, 3, 348, 174, 0, 5299, 5300, 5, 229, 0, 0, 5300, 5302, 5, 531, 0,
		0, 5301, 5303, 3, 414, 207, 0, 5302, 5301, 1, 0, 0, 0, 5302, 5303, 1, 0,
		0, 0, 5303, 345, 1, 0, 0, 0, 5304, 5308, 5, 319, 0, 0, 5305, 5306, 5, 214,
		0, 0, 5306, 5307, 5, 301, 0, 0, 5307, 5309, 5, 164, 0, 0, 5308, 5305, 1,
		0, 0, 0, 5308, 5309, 1, 0, 0, 0, 5309, 5310, 1, 0, 0, 0, 5310, 5327, 3,
		438, 219, 0, 5311, 5312, 5, 477, 0, 0, 5312, 5325, 5, 217, 0, 0, 5313,
		5314, 5, 2, 0, 0, 5314, 5319, 3, 348, 174, 0, 5315, 5316, 5, 4, 0, 0, 5316,
		5318, 3, 348, 174, 0, 5317, 5315, 1, 0, 0, 0, 5318, 5321, 1, 0, 0, 0, 5319,
		5317, 1, 0, 0, 0, 5319, 5320, 1, 0, 0, 0, 5320, 5322, 1, 0, 0, 0, 5321,
		5319, 1, 0, 0, 0, 5322, 5323, 5, 3, 0, 0, 5323, 5326, 1, 0, 0, 0, 5324,
		5326, 3, 348, 174, 0, 5325, 5313, 1, 0, 0, 0, 5325, 5324, 1, 0, 0, 0, 5326,
		5328, 1, 0, 0, 0, 5327, 5311, 1, 0, 0, 0, 5327, 5328, 1, 0, 0, 0, 5328,
		347, 1, 0, 0, 0, 5329, 5330, 5, 2, 0, 0, 5330, 5335, 3, 350, 175, 0, 5331,
		5332, 5, 4, 0, 0, 5332, 5334, 3, 350, 175, 0, 5333, 5331, 1, 0, 0, 0, 5334,
		5337, 1, 0, 0, 0, 5335, 5333, 1, 0, 0, 0, 5335, 5336, 1, 0, 0, 0, 5336,
		5338, 1, 0, 0, 0, 5337, 5335, 1, 0, 0, 0, 5338, 5339, 5, 3, 0, 0, 5339,
		349, 1, 0, 0, 0, 5340, 5341, 7, 38, 0, 0, 5341, 351, 1, 0, 0, 0, 5342,
		5347, 3, 354, 177, 0, 5343, 5344, 5, 4, 0, 0, 5344, 5346, 3, 354, 177,
		0, 5345, 5343, 1, 0, 0, 0, 5346, 5349, 1, 0, 0, 0, 5347, 5345, 1, 0, 0,
		0, 5347, 5348, 1, 0, 0, 0, 5348, 353, 1, 0, 0, 0, 5349, 5347, 1, 0, 0,
		0, 5350, 5351, 3, 438, 219, 0, 5351, 5355, 3, 300, 150, 0, 5352, 5353,
		5, 146, 0, 0, 5353, 5354, 5, 244, 0, 0, 5354, 5356, 3, 300, 150, 0, 5355,
		5352, 1, 0, 0, 0, 5355, 5356, 1, 0, 0, 0, 5356, 5358, 1, 0, 0, 0, 5357,
		5359, 3, 310, 155, 0, 5358, 5357, 1, 0, 0, 0, 5358, 5359, 1, 0, 0, 0, 5359,
		355, 1, 0, 0, 0, 5360, 5361, 7, 39, 0, 0, 5361, 357, 1, 0, 0, 0, 5362,
		5363, 5, 439, 0, 0, 5363, 5364, 5, 2, 0, 0, 5364, 5369, 5, 531, 0, 0, 5365,
		5366, 5, 4, 0, 0, 5366, 5368, 5, 531, 0, 0, 5367, 5365, 1, 0, 0, 0, 5368,
		5371, 1, 0, 0, 0, 5369, 5367, 1, 0, 0, 0, 5369, 5370, 1, 0, 0, 0, 5370,
		5372, 1, 0, 0, 0, 5371, 5369, 1, 0, 0, 0, 5372, 5373, 5, 3, 0, 0, 5373,
		359, 1, 0, 0, 0, 5374, 5375, 5, 477, 0, 0, 5375, 5380, 3, 372, 186, 0,
		5376, 5377, 5, 4, 0, 0, 5377, 5379, 3, 372, 186, 0, 5378, 5376, 1, 0, 0,
		0, 5379, 5382, 1, 0, 0, 0, 5380, 5378, 1, 0, 0, 0, 5380, 5381, 1, 0, 0,
		0, 5381, 361, 1, 0, 0, 0, 5382, 5380, 1, 0, 0, 0, 5383, 5388, 3, 366, 183,
		0, 5384, 5386, 5, 28, 0, 0, 5385, 5384, 1, 0, 0, 0, 5385, 5386, 1, 0, 0,
		0, 5386, 5387, 1, 0, 0, 0, 5387, 5389, 3, 178, 89, 0, 5388, 5385, 1, 0,
		0, 0, 5388, 5389, 1, 0, 0, 0, 5389, 363, 1, 0, 0, 0, 5390, 5395, 3, 362,
		181, 0, 5391, 5392, 5, 4, 0, 0, 5392, 5394, 3, 362, 181, 0, 5393, 5391,
		1, 0, 0, 0, 5394, 5397, 1, 0, 0, 0, 5395, 5393, 1, 0, 0, 0, 5395, 5396,
		1, 0, 0, 0, 5396, 365, 1, 0, 0, 0, 5397, 5395, 1, 0, 0, 0, 5398, 5401,
		3, 370, 185, 0, 5399, 5401, 3, 368, 184, 0, 5400, 5398, 1, 0, 0, 0, 5400,
		5399, 1, 0, 0, 0, 5401, 367, 1, 0, 0, 0, 5402, 5403, 3, 434, 217, 0, 5403,
		5404, 5, 520, 0, 0, 5404, 5405, 3, 370, 185, 0, 5405, 5419, 1, 0, 0, 0,
		5406, 5407, 5, 2, 0, 0, 5407, 5410, 3, 434, 217, 0, 5408, 5409, 5, 4, 0,
		0, 5409, 5411, 3, 434, 217, 0, 5410, 5408, 1, 0, 0, 0, 5411, 5412, 1, 0,
		0, 0, 5412, 5410, 1, 0, 0, 0, 5412, 5413, 1, 0, 0, 0, 5413, 5414, 1, 0,
		0, 0, 5414, 5415, 5, 3, 0, 0, 5415, 5416, 5, 520, 0, 0, 5416, 5417, 3,
		370, 185, 0, 5417, 5419, 1, 0, 0, 0, 5418, 5402, 1, 0, 0, 0, 5418, 5406,
		1, 0, 0, 0, 5419, 369, 1, 0, 0, 0, 5420, 5421, 6, 185, -1, 0, 5421, 5422,
		5, 515, 0, 0, 5422, 5445, 3, 370, 185, 10, 5423, 5424, 5, 164, 0, 0, 5424,
		5425, 5, 2, 0, 0, 5425, 5426, 3, 224, 112, 0, 5426, 5427, 5, 3, 0, 0, 5427,
		5445, 1, 0, 0, 0, 5428, 5429, 7, 40, 0, 0, 5429, 5430, 5, 2, 0, 0, 5430,
		5431, 3, 378, 189, 0, 5431, 5432, 5, 3, 0, 0, 5432, 5445, 1, 0, 0, 0, 5433,
		5434, 5, 235, 0, 0, 5434, 5435, 5, 2, 0, 0, 5435, 5436, 3, 378, 189, 0,
		5436, 5437, 5, 3, 0, 0, 5437, 5445, 1, 0, 0, 0, 5438, 5440, 3, 378, 189,
		0, 5439, 5441, 3, 376, 188, 0, 5440, 5439, 1, 0, 0, 0, 5440, 5441, 1, 0,
		0, 0, 5441, 5445, 1, 0, 0, 0, 5442, 5443, 5, 301, 0, 0, 5443, 5445, 3,
		370, 185, 5, 5444, 5420, 1, 0, 0, 0, 5444, 5423, 1, 0, 0, 0, 5444, 5428,
		1, 0, 0, 0, 5444, 5433, 1, 0, 0, 0, 5444, 5438, 1, 0, 0, 0, 5444, 5442,
		1, 0, 0, 0, 5445, 5460, 1, 0, 0, 0, 5446, 5447, 10, 4, 0, 0, 5447, 5448,
		7, 41, 0, 0, 5448, 5459, 3, 370, 185, 5, 5449, 5450, 10, 3, 0, 0, 5450,
		5451, 5, 498, 0, 0, 5451, 5459, 3, 370, 185, 4, 5452, 5453, 10, 2, 0, 0,
		5453, 5454, 5, 311, 0, 0, 5454, 5459, 3, 370, 185, 3, 5455, 5456, 10, 1,
		0, 0, 5456, 5457, 5, 517, 0, 0, 5457, 5459, 3, 370, 185, 2, 5458, 5446,
		1, 0, 0, 0, 5458, 5449, 1, 0, 0, 0, 5458, 5452, 1, 0, 0, 0, 5458, 5455,
		1, 0, 0, 0, 5459, 5462, 1, 0, 0, 0, 5460, 5458, 1, 0, 0, 0, 5460, 5461,
		1, 0, 0, 0, 5461, 371, 1, 0, 0, 0, 5462, 5460, 1, 0, 0, 0, 5463, 5472,
		5, 2, 0, 0, 5464, 5469, 3, 374, 187, 0, 5465, 5466, 5, 4, 0, 0, 5466, 5468,
		3, 374, 187, 0, 5467, 5465, 1, 0, 0, 0, 5468, 5471, 1, 0, 0, 0, 5469, 5467,
		1, 0, 0, 0, 5469, 5470, 1, 0, 0, 0, 5470, 5473, 1, 0, 0, 0, 5471, 5469,
		1, 0, 0, 0, 5472, 5464, 1, 0, 0, 0, 5472, 5473, 1, 0, 0, 0, 5473, 5474,
		1, 0, 0, 0, 5474, 5475, 5, 3, 0, 0, 5475, 373, 1, 0, 0, 0, 5476, 5480,
		3, 404, 202, 0, 5477, 5480, 5, 124, 0, 0, 5478, 5480, 3, 362, 181, 0, 5479,
		5476, 1, 0, 0, 0, 5479, 5477, 1, 0, 0, 0, 5479, 5478, 1, 0, 0, 0, 5480,
		375, 1, 0, 0, 0, 5481, 5483, 5, 301, 0, 0, 5482, 5481, 1, 0, 0, 0, 5482,
		5483, 1, 0, 0, 0, 5483, 5484, 1, 0, 0, 0, 5484, 5485, 5, 40, 0, 0, 5485,
		5486, 3, 378, 189, 0, 5486, 5487, 5, 24, 0, 0, 5487, 5488, 3, 378, 189,
		0, 5488, 5533, 1, 0, 0, 0, 5489, 5491, 5, 301, 0, 0, 5490, 5489, 1, 0,
		0, 0, 5490, 5491, 1, 0, 0, 0, 5491, 5492, 1, 0, 0, 0, 5492, 5493, 7, 42,
		0, 0, 5493, 5533, 3, 378, 189, 0, 5494, 5496, 5, 301, 0, 0, 5495, 5494,
		1, 0, 0, 0, 5495, 5496, 1, 0, 0, 0, 5496, 5497, 1, 0, 0, 0, 5497, 5498,
		7, 43, 0, 0, 5498, 5533, 3, 378, 189, 0, 5499, 5501, 5, 301, 0, 0, 5500,
		5499, 1, 0, 0, 0, 5500, 5501, 1, 0, 0, 0, 5501, 5502, 1, 0, 0, 0, 5502,
		5503, 5, 217, 0, 0, 5503, 5504, 5, 2, 0, 0, 5504, 5505, 3, 224, 112, 0,
		5505, 5506, 5, 3, 0, 0, 5506, 5533, 1, 0, 0, 0, 5507, 5509, 5, 301, 0,
		0, 5508, 5507, 1, 0, 0, 0, 5508, 5509, 1, 0, 0, 0, 5509, 5510, 1, 0, 0,
		0, 5510, 5511, 5, 217, 0, 0, 5511, 5512, 5, 2, 0, 0, 5512, 5517, 3, 366,
		183, 0, 5513, 5514, 5, 4, 0, 0, 5514, 5516, 3, 366, 183, 0, 5515, 5513,
		1, 0, 0, 0, 5516, 5519, 1, 0, 0, 0, 5517, 5515, 1, 0, 0, 0, 5517, 5518,
		1, 0, 0, 0, 5518, 5520, 1, 0, 0, 0, 5519, 5517, 1, 0, 0, 0, 5520, 5521,
		5, 3, 0, 0, 5521, 5533, 1, 0, 0, 0, 5522, 5524, 5, 234, 0, 0, 5523, 5525,
		5, 301, 0, 0, 5524, 5523, 1, 0, 0, 0, 5524, 5525, 1, 0, 0, 0, 5525, 5526,
		1, 0, 0, 0, 5526, 5533, 5, 302, 0, 0, 5527, 5529, 5, 234, 0, 0, 5528, 5530,
		5, 301, 0, 0, 5529, 5528, 1, 0, 0, 0, 5529, 5530, 1, 0, 0, 0, 5530, 5531,
		1, 0, 0, 0, 5531, 5533, 7, 44, 0, 0, 5532, 5482, 1, 0, 0, 0, 5532, 5490,
		1, 0, 0, 0, 5532, 5495, 1, 0, 0, 0, 5532, 5500, 1, 0, 0, 0, 5532, 5508,
		1, 0, 0, 0, 5532, 5522, 1, 0, 0, 0, 5532, 5527, 1, 0, 0, 0, 5533, 377,
		1, 0, 0, 0, 5534, 5535, 6, 189, -1, 0, 5535, 5539, 3, 380, 190, 0, 5536,
		5537, 7, 45, 0, 0, 5537, 5539, 3, 378, 189, 7, 5538, 5534, 1, 0, 0, 0,
		5538, 5536, 1, 0, 0, 0, 5539, 5561, 1, 0, 0, 0, 5540, 5541, 10, 6, 0, 0,
		5541, 5542, 5, 518, 0, 0, 5542, 5560, 3, 378, 189, 7, 5543, 5544, 10, 5,
		0, 0, 5544, 5545, 7, 46, 0, 0, 5545, 5560, 3, 378, 189, 6, 5546, 5547,
		10, 4, 0, 0, 5547, 5548, 7, 47, 0, 0, 5548, 5560, 3, 378, 189, 5, 5549,
		5550, 10, 3, 0, 0, 5550, 5551, 5, 513, 0, 0, 5551, 5560, 3, 378, 189, 4,
		5552, 5553, 10, 2, 0, 0, 5553, 5554, 5, 516, 0, 0, 5554, 5560, 3, 378,
		189, 3, 5555, 5556, 10, 1, 0, 0, 5556, 5557, 3, 406, 203, 0, 5557, 5558,
		3, 378, 189, 2, 5558, 5560, 1, 0, 0, 0, 5559, 5540, 1, 0, 0, 0, 5559, 5543,
		1, 0, 0, 0, 5559, 5546, 1, 0, 0, 0, 5559, 5549, 1, 0, 0, 0, 5559, 5552,
		1, 0, 0, 0, 5559, 5555, 1, 0, 0, 0, 5560, 5563, 1, 0, 0, 0, 5561, 5559,
		1, 0, 0, 0, 5561, 5562, 1, 0, 0, 0, 5562, 379, 1, 0, 0, 0, 5563, 5561,
		1, 0, 0, 0, 5564, 5565, 6, 190, -1, 0, 5565, 5691, 5, 106, 0, 0, 5566,
		5691, 5, 107, 0, 0, 5567, 5691, 5, 108, 0, 0, 5568, 5691, 5, 263, 0, 0,
		5569, 5691, 5, 264, 0, 0, 5570, 5691, 5, 109, 0, 0, 5571, 5691, 5, 405,
		0, 0, 5572, 5574, 5, 64, 0, 0, 5573, 5575, 3, 410, 205, 0, 5574, 5573,
		1, 0, 0, 0, 5575, 5576, 1, 0, 0, 0, 5576, 5574, 1, 0, 0, 0, 5576, 5577,
		1, 0, 0, 0, 5577, 5580, 1, 0, 0, 0, 5578, 5579, 5, 149, 0, 0, 5579, 5581,
		3, 366, 183, 0, 5580, 5578, 1, 0, 0, 0, 5580, 5581, 1, 0, 0, 0, 5581, 5582,
		1, 0, 0, 0, 5582, 5583, 5, 153, 0, 0, 5583, 5691, 1, 0, 0, 0, 5584, 5585,
		5, 64, 0, 0, 5585, 5587, 3, 366, 183, 0, 5586, 5588, 3, 410, 205, 0, 5587,
		5586, 1, 0, 0, 0, 5588, 5589, 1, 0, 0, 0, 5589, 5587, 1, 0, 0, 0, 5589,
		5590, 1, 0, 0, 0, 5590, 5593, 1, 0, 0, 0, 5591, 5592, 5, 149, 0, 0, 5592,
		5594, 3, 366, 183, 0, 5593, 5591, 1, 0, 0, 0, 5593, 5594, 1, 0, 0, 0, 5594,
		5595, 1, 0, 0, 0, 5595, 5596, 5, 153, 0, 0, 5596, 5691, 1, 0, 0, 0, 5597,
		5598, 5, 65, 0, 0, 5598, 5599, 5, 2, 0, 0, 5599, 5600, 3, 366, 183, 0,
		5600, 5601, 5, 28, 0, 0, 5601, 5602, 3, 384, 192, 0, 5602, 5603, 5, 3,
		0, 0, 5603, 5691, 1, 0, 0, 0, 5604, 5691, 3, 404, 202, 0, 5605, 5691, 3,
		412, 206, 0, 5606, 5610, 5, 509, 0, 0, 5607, 5609, 3, 382, 191, 0, 5608,
		5607, 1, 0, 0, 0, 5609, 5612, 1, 0, 0, 0, 5610, 5608, 1, 0, 0, 0, 5610,
		5611, 1, 0, 0, 0, 5611, 5691, 1, 0, 0, 0, 5612, 5610, 1, 0, 0, 0, 5613,
		5614, 3, 400, 200, 0, 5614, 5615, 5, 5, 0, 0, 5615, 5619, 5, 509, 0, 0,
		5616, 5618, 3, 382, 191, 0, 5617, 5616, 1, 0, 0, 0, 5618, 5621, 1, 0, 0,
		0, 5619, 5617, 1, 0, 0, 0, 5619, 5620, 1, 0, 0, 0, 5620, 5691, 1, 0, 0,
		0, 5621, 5619, 1, 0, 0, 0, 5622, 5623, 5, 69, 0, 0, 5623, 5624, 5, 2, 0,
		0, 5624, 5629, 3, 366, 183, 0, 5625, 5626, 5, 4, 0, 0, 5626, 5628, 3, 366,
		183, 0, 5627, 5625, 1, 0, 0, 0, 5628, 5631, 1, 0, 0, 0, 5629, 5627, 1,
		0, 0, 0, 5629, 5630, 1, 0, 0, 0, 5630, 5634, 1, 0, 0, 0, 5631, 5629, 1,
		0, 0, 0, 5632, 5633, 5, 475, 0, 0, 5633, 5635, 3, 178, 89, 0, 5634, 5632,
		1, 0, 0, 0, 5634, 5635, 1, 0, 0, 0, 5635, 5636, 1, 0, 0, 0, 5636, 5637,
		5, 3, 0, 0, 5637, 5691, 1, 0, 0, 0, 5638, 5639, 5, 95, 0, 0, 5639, 5640,
		5, 2, 0, 0, 5640, 5641, 3, 366, 183, 0, 5641, 5642, 5, 475, 0, 0, 5642,
		5643, 3, 178, 89, 0, 5643, 5644, 5, 3, 0, 0, 5644, 5691, 1, 0, 0, 0, 5645,
		5646, 5, 95, 0, 0, 5646, 5647, 5, 2, 0, 0, 5647, 5648, 3, 366, 183, 0,
		5648, 5649, 5, 4, 0, 0, 5649, 5650, 3, 384, 192, 0, 5650, 5651, 5, 3, 0,
		0, 5651, 5691, 1, 0, 0, 0, 5652, 5691, 3, 386, 193, 0, 5653, 5654, 5, 2,
		0, 0, 5654, 5655, 3, 224, 112, 0, 5655, 5656, 5, 3, 0, 0, 5656, 5691, 1,
		0, 0, 0, 5657, 5658, 5, 524, 0, 0, 5658, 5691, 3, 178, 89, 0, 5659, 5662,
		5, 525, 0, 0, 5660, 5661, 7, 48, 0, 0, 5661, 5663, 5, 5, 0, 0, 5662, 5660,
		1, 0, 0, 0, 5662, 5663, 1, 0, 0, 0, 5663, 5664, 1, 0, 0, 0, 5664, 5691,
		3, 438, 219, 0, 5665, 5667, 5, 43, 0, 0, 5666, 5665, 1, 0, 0, 0, 5666,
		5667, 1, 0, 0, 0, 5667, 5668, 1, 0, 0, 0, 5668, 5691, 3, 438, 219, 0, 5669,
		5670, 5, 2, 0, 0, 5670, 5671, 3, 366, 183, 0, 5671, 5672, 5, 3, 0, 0, 5672,
		5691, 1, 0, 0, 0, 5673, 5677, 5, 244, 0, 0, 5674, 5675, 3, 438, 219, 0,
		5675, 5676, 5, 5, 0, 0, 5676, 5678, 1, 0, 0, 0, 5677, 5674, 1, 0, 0, 0,
		5677, 5678, 1, 0, 0, 0, 5678, 5679, 1, 0, 0, 0, 5679, 5691, 3, 438, 219,
		0, 5680, 5681, 5, 170, 0, 0, 5681, 5682, 5, 2, 0, 0, 5682, 5683, 3, 438,
		219, 0, 5683, 5685, 5, 187, 0, 0, 5684, 5686, 7, 49, 0, 0, 5685, 5684,
		1, 0, 0, 0, 5685, 5686, 1, 0, 0, 0, 5686, 5687, 1, 0, 0, 0, 5687, 5688,
		3, 378, 189, 0, 5688, 5689, 5, 3, 0, 0, 5689, 5691, 1, 0, 0, 0, 5690, 5564,
		1, 0, 0, 0, 5690, 5566, 1, 0, 0, 0, 5690, 5567, 1, 0, 0, 0, 5690, 5568,
		1, 0, 0, 0, 5690, 5569, 1, 0, 0, 0, 5690, 5570, 1, 0, 0, 0, 5690, 5571,
		1, 0, 0, 0, 5690, 5572, 1, 0, 0, 0, 5690, 5584, 1, 0, 0, 0, 5690, 5597,
		1, 0, 0, 0, 5690, 5604, 1, 0, 0, 0, 5690, 5605, 1, 0, 0, 0, 5690, 5606,
		1, 0, 0, 0, 5690, 5613, 1, 0, 0, 0, 5690, 5622, 1, 0, 0, 0, 5690, 5638,
		1, 0, 0, 0, 5690, 5645, 1, 0, 0, 0, 5690, 5652, 1, 0, 0, 0, 5690, 5653,
		1, 0, 0, 0, 5690, 5657, 1, 0, 0, 0, 5690, 5659, 1, 0, 0, 0, 5690, 5666,
		1, 0, 0, 0, 5690, 5669, 1, 0, 0, 0, 5690, 5673, 1, 0, 0, 0, 5690, 5680,
		1, 0, 0, 0, 5691, 5718, 1, 0, 0, 0, 5692, 5693, 10, 11, 0, 0, 5693, 5694,
		5, 7, 0, 0, 5694, 5695, 3, 378, 189, 0, 5695, 5696, 5, 8, 0, 0, 5696, 5717,
		1, 0, 0, 0, 5697, 5698, 10, 10, 0, 0, 5698, 5699, 5, 7, 0, 0, 5699, 5700,
		3, 378, 189, 0, 5700, 5702, 5, 519, 0, 0, 5701, 5703, 3, 378, 189, 0, 5702,
		5701, 1, 0, 0, 0, 5702, 5703, 1, 0, 0, 0, 5703, 5704, 1, 0, 0, 0, 5704,
		5705, 5, 8, 0, 0, 5705, 5717, 1, 0, 0, 0, 5706, 5707, 10, 5, 0, 0, 5707,
		5708, 5, 5, 0, 0, 5708, 5717, 3, 438, 219, 0, 5709, 5710, 10, 1, 0, 0,
		5710, 5714, 5, 75, 0, 0, 5711, 5715, 3, 438, 219, 0, 5712, 5715, 5, 526,
		0, 0, 5713, 5715, 5, 124, 0, 0, 5714, 5711, 1, 0, 0, 0, 5714, 5712, 1,
		0, 0, 0, 5714, 5713, 1, 0, 0, 0, 5715, 5717, 1, 0, 0, 0, 5716, 5692, 1,
		0, 0, 0, 5716, 5697, 1, 0, 0, 0, 5716, 5706, 1, 0, 0, 0, 5716, 5709, 1,
		0, 0, 0, 5717, 5720, 1, 0, 0, 0, 5718, 5716, 1, 0, 0, 0, 5718, 5719, 1,
		0, 0, 0, 5719, 381, 1, 0, 0, 0, 5720, 5718, 1, 0, 0, 0, 5721, 5722, 5,
		161, 0, 0, 5722, 5723, 5, 2, 0, 0, 5723, 5724, 3, 364, 182, 0, 5724, 5725,
		5, 3, 0, 0, 5725, 5732, 1, 0, 0, 0, 5726, 5727, 5, 371, 0, 0, 5727, 5728,
		5, 2, 0, 0, 5728, 5729, 3, 364, 182, 0, 5729, 5730, 5, 3, 0, 0, 5730, 5732,
		1, 0, 0, 0, 5731, 5721, 1, 0, 0, 0, 5731, 5726, 1, 0, 0, 0, 5732, 383,
		1, 0, 0, 0, 5733, 5739, 3, 418, 209, 0, 5734, 5736, 7, 50, 0, 0, 5735,
		5737, 7, 51, 0, 0, 5736, 5735, 1, 0, 0, 0, 5736, 5737, 1, 0, 0, 0, 5737,
		5739, 1, 0, 0, 0, 5738, 5733, 1, 0, 0, 0, 5738, 5734, 1, 0, 0, 0, 5739,
		385, 1, 0, 0, 0, 5740, 5741, 3, 388, 194, 0, 5741, 5765, 5, 2, 0, 0, 5742,
		5744, 7, 34, 0, 0, 5743, 5742, 1, 0, 0, 0, 5743, 5744, 1, 0, 0, 0, 5744,
		5745, 1, 0, 0, 0, 5745, 5750, 3, 366, 183, 0, 5746, 5747, 5, 4, 0, 0, 5747,
		5749, 3, 366, 183, 0, 5748, 5746, 1, 0, 0, 0, 5749, 5752, 1, 0, 0, 0, 5750,
		5748, 1, 0, 0, 0, 5750, 5751, 1, 0, 0, 0, 5751, 5763, 1, 0, 0, 0, 5752,
		5750, 1, 0, 0, 0, 5753, 5754, 5, 312, 0, 0, 5754, 5755, 5, 59, 0, 0, 5755,
		5760, 3, 290, 145, 0, 5756, 5757, 5, 4, 0, 0, 5757, 5759, 3, 290, 145,
		0, 5758, 5756, 1, 0, 0, 0, 5759, 5762, 1, 0, 0, 0, 5760, 5758, 1, 0, 0,
		0, 5760, 5761, 1, 0, 0, 0, 5761, 5764, 1, 0, 0, 0, 5762, 5760, 1, 0, 0,
		0, 5763, 5753, 1, 0, 0, 0, 5763, 5764, 1, 0, 0, 0, 5764, 5766, 1, 0, 0,
		0, 5765, 5743, 1, 0, 0, 0, 5765, 5766, 1, 0, 0, 0, 5766, 5767, 1, 0, 0,
		0, 5767, 5770, 5, 3, 0, 0, 5768, 5769, 5, 315, 0, 0, 5769, 5771, 3, 392,
		196, 0, 5770, 5768, 1, 0, 0, 0, 5770, 5771, 1, 0, 0, 0, 5771, 387, 1, 0,
		0, 0, 5772, 5773, 3, 438, 219, 0, 5773, 5774, 5, 5, 0, 0, 5774, 5776, 1,
		0, 0, 0, 5775, 5772, 1, 0, 0, 0, 5775, 5776, 1, 0, 0, 0, 5776, 5777, 1,
		0, 0, 0, 5777, 5778, 3, 390, 195, 0, 5778, 389, 1, 0, 0, 0, 5779, 5796,
		3, 438, 219, 0, 5780, 5796, 5, 14, 0, 0, 5781, 5796, 5, 91, 0, 0, 5782,
		5796, 5, 105, 0, 0, 5783, 5796, 5, 109, 0, 0, 5784, 5796, 5, 111, 0, 0,
		5785, 5796, 5, 214, 0, 0, 5786, 5796, 5, 253, 0, 0, 5787, 5796, 5, 256,
		0, 0, 5788, 5796, 5, 321, 0, 0, 5789, 5796, 5, 366, 0, 0, 5790, 5796, 5,
		385, 0, 0, 5791, 5796, 5, 398, 0, 0, 5792, 5796, 5, 405, 0, 0, 5793, 5796,
		5, 456, 0, 0, 5794, 5796, 5, 473, 0, 0, 5795, 5779, 1, 0, 0, 0, 5795, 5780,
		1, 0, 0, 0, 5795, 5781, 1, 0, 0, 0, 5795, 5782, 1, 0, 0, 0, 5795, 5783,
		1, 0, 0, 0, 5795, 5784, 1, 0, 0, 0, 5795, 5785, 1, 0, 0, 0, 5795, 5786,
		1, 0, 0, 0, 5795, 5787, 1, 0, 0, 0, 5795, 5788, 1, 0, 0, 0, 5795, 5789,
		1, 0, 0, 0, 5795, 5790, 1, 0, 0, 0, 5795, 5791, 1, 0, 0, 0, 5795, 5792,
		1, 0, 0, 0, 5795, 5793, 1, 0, 0, 0, 5795, 5794, 1, 0, 0, 0, 5796, 391,
		1, 0, 0, 0, 5797, 5799, 5, 2, 0, 0, 5798, 5800, 3, 294, 147, 0, 5799, 5798,
		1, 0, 0, 0, 5799, 5800, 1, 0, 0, 0, 5800, 5802, 1, 0, 0, 0, 5801, 5803,
		3, 288, 144, 0, 5802, 5801, 1, 0, 0, 0, 5802, 5803, 1, 0, 0, 0, 5803, 5805,
		1, 0, 0, 0, 5804, 5806, 3, 394, 197, 0, 5805, 5804, 1, 0, 0, 0, 5805, 5806,
		1, 0, 0, 0, 5806, 5807, 1, 0, 0, 0, 5807, 5808, 5, 3, 0, 0, 5808, 393,
		1, 0, 0, 0, 5809, 5810, 3, 396, 198, 0, 5810, 5811, 3, 398, 199, 0, 5811,
		5819, 1, 0, 0, 0, 5812, 5813, 3, 396, 198, 0, 5813, 5814, 5, 40, 0, 0,
		5814, 5815, 3, 398, 199, 0, 5815, 5816, 5, 24, 0, 0, 5816, 5817, 3, 398,
		199, 0, 5817, 5819, 1, 0, 0, 0, 5818, 5809, 1, 0, 0, 0, 5818, 5812, 1,
		0, 0, 0, 5819, 395, 1, 0, 0, 0, 5820, 5821, 7, 52, 0, 0, 5821, 397, 1,
		0, 0, 0, 5822, 5823, 5, 462, 0, 0, 5823, 5830, 7, 53, 0, 0, 5824, 5825,
		5, 104, 0, 0, 5825, 5830, 5, 392, 0, 0, 5826, 5827, 3, 366, 183, 0, 5827,
		5828, 7, 53, 0, 0, 5828, 5830, 1, 0, 0, 0, 5829, 5822, 1, 0, 0, 0, 5829,
		5824, 1, 0, 0, 0, 5829, 5826, 1, 0, 0, 0, 5830, 399, 1, 0, 0, 0, 5831,
		5836, 3, 438, 219, 0, 5832, 5833, 5, 5, 0, 0, 5833, 5835, 3, 438, 219,
		0, 5834, 5832, 1, 0, 0, 0, 5835, 5838, 1, 0, 0, 0, 5836, 5834, 1, 0, 0,
		0, 5836, 5837, 1, 0, 0, 0, 5837, 401, 1, 0, 0, 0, 5838, 5836, 1, 0, 0,
		0, 5839, 5841, 5, 443, 0, 0, 5840, 5839, 1, 0, 0, 0, 5840, 5841, 1, 0,
		0, 0, 5841, 5842, 1, 0, 0, 0, 5842, 5845, 5, 319, 0, 0, 5843, 5846, 3,
		438, 219, 0, 5844, 5846, 3, 300, 150, 0, 5845, 5843, 1, 0, 0, 0, 5845,
		5844, 1, 0, 0, 0, 5846, 5853, 1, 0, 0, 0, 5847, 5849, 5, 443, 0, 0, 5848,
		5847, 1, 0, 0, 0, 5848, 5849, 1, 0, 0, 0, 5849, 5850, 1, 0, 0, 0, 5850,
		5851, 5, 320, 0, 0, 5851, 5853, 3, 300, 150, 0, 5852, 5840, 1, 0, 0, 0,
		5852, 5848, 1, 0, 0, 0, 5853, 403, 1, 0, 0, 0, 5854, 5906, 5, 302, 0, 0,
		5855, 5856, 7, 54, 0, 0, 5856, 5906, 5, 526, 0, 0, 5857, 5906, 3, 444,
		222, 0, 5858, 5906, 3, 408, 204, 0, 5859, 5861, 5, 43, 0, 0, 5860, 5859,
		1, 0, 0, 0, 5860, 5861, 1, 0, 0, 0, 5861, 5862, 1, 0, 0, 0, 5862, 5906,
		5, 526, 0, 0, 5863, 5865, 5, 7, 0, 0, 5864, 5866, 3, 404, 202, 0, 5865,
		5864, 1, 0, 0, 0, 5865, 5866, 1, 0, 0, 0, 5866, 5871, 1, 0, 0, 0, 5867,
		5868, 5, 4, 0, 0, 5868, 5870, 3, 404, 202, 0, 5869, 5867, 1, 0, 0, 0, 5870,
		5873, 1, 0, 0, 0, 5871, 5869, 1, 0, 0, 0, 5871, 5872, 1, 0, 0, 0, 5872,
		5874, 1, 0, 0, 0, 5873, 5871, 1, 0, 0, 0, 5874, 5906, 5, 8, 0, 0, 5875,
		5880, 5, 9, 0, 0, 5876, 5877, 3, 404, 202, 0, 5877, 5878, 5, 519, 0, 0,
		5878, 5879, 3, 404, 202, 0, 5879, 5881, 1, 0, 0, 0, 5880, 5876, 1, 0, 0,
		0, 5880, 5881, 1, 0, 0, 0, 5881, 5889, 1, 0, 0, 0, 5882, 5883, 5, 4, 0,
		0, 5883, 5884, 3, 404, 202, 0, 5884, 5885, 5, 519, 0, 0, 5885, 5886, 3,
		404, 202, 0, 5886, 5888, 1, 0, 0, 0, 5887, 5882, 1, 0, 0, 0, 5888, 5891,
		1, 0, 0, 0, 5889, 5887, 1, 0, 0, 0, 5889, 5890, 1, 0, 0, 0, 5890, 5892,
		1, 0, 0, 0, 5891, 5889, 1, 0, 0, 0, 5892, 5906, 5, 10, 0, 0, 5893, 5894,
		5, 9, 0, 0, 5894, 5899, 3, 404, 202, 0, 5895, 5896, 5, 4, 0, 0, 5896, 5898,
		3, 404, 202, 0, 5897, 5895, 1, 0, 0, 0, 5898, 5901, 1, 0, 0, 0, 5899, 5897,
		1, 0, 0, 0, 5899, 5900, 1, 0, 0, 0, 5900, 5902, 1, 0, 0, 0, 5901, 5899,
		1, 0, 0, 0, 5902, 5903, 5, 10, 0, 0, 5903, 5906, 1, 0, 0, 0, 5904, 5906,
		5, 333, 0, 0, 5905, 5854, 1, 0, 0, 0, 5905, 5855, 1, 0, 0, 0, 5905, 5857,
		1, 0, 0, 0, 5905, 5858, 1, 0, 0, 0, 5905, 5860, 1, 0, 0, 0, 5905, 5863,
		1, 0, 0, 0, 5905, 5875, 1, 0, 0, 0, 5905, 5893, 1, 0, 0, 0, 5905, 5904,
		1, 0, 0, 0, 5906, 405, 1, 0, 0, 0, 5907, 5908, 7, 55, 0, 0, 5908, 407,
		1, 0, 0, 0, 5909, 5910, 7, 44, 0, 0, 5910, 409, 1, 0, 0, 0, 5911, 5912,
		5, 491, 0, 0, 5912, 5913, 3, 366, 183, 0, 5913, 5914, 5, 447, 0, 0, 5914,
		5915, 3, 366, 183, 0, 5915, 411, 1, 0, 0, 0, 5916, 5917, 5, 229, 0, 0,
		5917, 5918, 3, 366, 183, 0, 5918, 5919, 3, 414, 207, 0, 5919, 413, 1, 0,
		0, 0, 5920, 5921, 7, 56, 0, 0, 5921, 415, 1, 0, 0, 0, 5922, 5927, 3, 418,
		209, 0, 5923, 5925, 5, 301, 0, 0, 5924, 5923, 1, 0, 0, 0, 5924, 5925, 1,
		0, 0, 0, 5925, 5926, 1, 0, 0, 0, 5926, 5928, 5, 302, 0, 0, 5927, 5924,
		1, 0, 0, 0, 5927, 5928, 1, 0, 0, 0, 5928, 417, 1, 0, 0, 0, 5929, 5930,
		5, 27, 0, 0, 5930, 5931, 5, 503, 0, 0, 5931, 5932, 3, 418, 209, 0, 5932,
		5933, 5, 505, 0, 0, 5933, 5975, 1, 0, 0, 0, 5934, 5935, 5, 270, 0, 0, 5935,
		5936, 5, 503, 0, 0, 5936, 5937, 3, 418, 209, 0, 5937, 5938, 5, 4, 0, 0,
		5938, 5939, 3, 418, 209, 0, 5939, 5940, 5, 505, 0, 0, 5940, 5975, 1, 0,
		0, 0, 5941, 5942, 5, 430, 0, 0, 5942, 5943, 5, 503, 0, 0, 5943, 5944, 3,
		422, 211, 0, 5944, 5945, 5, 505, 0, 0, 5945, 5975, 1, 0, 0, 0, 5946, 5947,
		5, 17, 0, 0, 5947, 5948, 5, 503, 0, 0, 5948, 5949, 3, 390, 195, 0, 5949,
		5950, 5, 2, 0, 0, 5950, 5955, 3, 416, 208, 0, 5951, 5952, 5, 4, 0, 0, 5952,
		5954, 3, 416, 208, 0, 5953, 5951, 1, 0, 0, 0, 5954, 5957, 1, 0, 0, 0, 5955,
		5953, 1, 0, 0, 0, 5955, 5956, 1, 0, 0, 0, 5956, 5958, 1, 0, 0, 0, 5957,
		5955, 1, 0, 0, 0, 5958, 5959, 5, 3, 0, 0, 5959, 5960, 5, 505, 0, 0, 5960,
		5975, 1, 0, 0, 0, 5961, 5972, 3, 420, 210, 0, 5962, 5963, 5, 2, 0, 0, 5963,
		5968, 7, 57, 0, 0, 5964, 5965, 5, 4, 0, 0, 5965, 5967, 5, 531, 0, 0, 5966,
		5964, 1, 0, 0, 0, 5967, 5970, 1, 0, 0, 0, 5968, 5966, 1, 0, 0, 0, 5968,
		5969, 1, 0, 0, 0, 5969, 5971, 1, 0, 0, 0, 5970, 5968, 1, 0, 0, 0, 5971,
		5973, 5, 3, 0, 0, 5972, 5962, 1, 0, 0, 0, 5972, 5973, 1, 0, 0, 0, 5973,
		5975, 1, 0, 0, 0, 5974, 5929, 1, 0, 0, 0, 5974, 5934, 1, 0, 0, 0, 5974,
		5941, 1, 0, 0, 0, 5974, 5946, 1, 0, 0, 0, 5974, 5961, 1, 0, 0, 0, 5975,
		419, 1, 0, 0, 0, 5976, 6009, 5, 450, 0, 0, 5977, 6009, 5, 413, 0, 0, 5978,
		6009, 7, 51, 0, 0, 5979, 6009, 5, 41, 0, 0, 5980, 6009, 5, 248, 0, 0, 5981,
		6009, 5, 52, 0, 0, 5982, 6009, 5, 179, 0, 0, 5983, 6009, 5, 141, 0, 0,
		5984, 6009, 5, 113, 0, 0, 5985, 6009, 5, 114, 0, 0, 5986, 6009, 5, 448,
		0, 0, 5987, 6009, 5, 116, 0, 0, 5988, 6009, 5, 115, 0, 0, 5989, 6009, 5,
		118, 0, 0, 5990, 6009, 5, 117, 0, 0, 5991, 6009, 5, 46, 0, 0, 5992, 6009,
		5, 350, 0, 0, 5993, 6009, 5, 207, 0, 0, 5994, 6009, 5, 17, 0, 0, 5995,
		6009, 5, 429, 0, 0, 5996, 6009, 5, 242, 0, 0, 5997, 6009, 5, 243, 0, 0,
		5998, 6009, 5, 445, 0, 0, 5999, 6009, 5, 478, 0, 0, 6000, 6009, 5, 69,
		0, 0, 6001, 6009, 5, 120, 0, 0, 6002, 6009, 5, 121, 0, 0, 6003, 6009, 5,
		122, 0, 0, 6004, 6009, 5, 232, 0, 0, 6005, 6009, 5, 233, 0, 0, 6006, 6009,
		5, 481, 0, 0, 6007, 6009, 5, 20, 0, 0, 6008, 5976, 1, 0, 0, 0, 6008, 5977,
		1, 0, 0, 0, 6008, 5978, 1, 0, 0, 0, 6008, 5979, 1, 0, 0, 0, 6008, 5980,
		1, 0, 0, 0, 6008, 5981, 1, 0, 0, 0, 6008, 5982, 1, 0, 0, 0, 6008, 5983,
		1, 0, 0, 0, 6008, 5984, 1, 0, 0, 0, 6008, 5985, 1, 0, 0, 0, 6008, 5986,
		1, 0, 0, 0, 6008, 5987, 1, 0, 0, 0, 6008, 5988, 1, 0, 0, 0, 6008, 5989,
		1, 0, 0, 0, 6008, 5990, 1, 0, 0, 0, 6008, 5991, 1, 0, 0, 0, 6008, 5992,
		1, 0, 0, 0, 6008, 5993, 1, 0, 0, 0, 6008, 5994, 1, 0, 0, 0, 6008, 5995,
		1, 0, 0, 0, 6008, 5996, 1, 0, 0, 0, 6008, 5997, 1, 0, 0, 0, 6008, 5998,
		1, 0, 0, 0, 6008, 5999, 1, 0, 0, 0, 6008, 6000, 1, 0, 0, 0, 6008, 6001,
		1, 0, 0, 0, 6008, 6002, 1, 0, 0, 0, 6008, 6003, 1, 0, 0, 0, 6008, 6004,
		1, 0, 0, 0, 6008, 6005, 1, 0, 0, 0, 6008, 6006, 1, 0, 0, 0, 6008, 6007,
		1, 0, 0, 0, 6009, 421, 1, 0, 0, 0, 6010, 6015, 3, 424, 212, 0, 6011, 6012,
		5, 4, 0, 0, 6012, 6014, 3, 424, 212, 0, 6013, 6011, 1, 0, 0, 0, 6014, 6017,
		1, 0, 0, 0, 6015, 6013, 1, 0, 0, 0, 6015, 6016, 1, 0, 0, 0, 6016, 423,
		1, 0, 0, 0, 6017, 6015, 1, 0, 0, 0, 6018, 6019, 3, 438, 219, 0, 6019, 6020,
		5, 519, 0, 0, 6020, 6022, 3, 418, 209, 0, 6021, 6023, 3, 426, 213, 0, 6022,
		6021, 1, 0, 0, 0, 6022, 6023, 1, 0, 0, 0, 6023, 425, 1, 0, 0, 0, 6024,
		6025, 5, 81, 0, 0, 6025, 6026, 5, 526, 0, 0, 6026, 427, 1, 0, 0, 0, 6027,
		6028, 5, 438, 0, 0, 6028, 6030, 5, 2, 0, 0, 6029, 6031, 3, 430, 215, 0,
		6030, 6029, 1, 0, 0, 0, 6030, 6031, 1, 0, 0, 0, 6031, 6032, 1, 0, 0, 0,
		6032, 6035, 5, 3, 0, 0, 6033, 6034, 5, 370, 0, 0, 6034, 6036, 5, 531, 0,
		0, 6035, 6033, 1, 0, 0, 0, 6035, 6036, 1, 0, 0, 0, 6036, 429, 1, 0, 0,
		0, 6037, 6038, 5, 531, 0, 0, 6038, 6042, 5, 328, 0, 0, 6039, 6040, 5, 531,
		0, 0, 6040, 6042, 5, 393, 0, 0, 6041, 6037, 1, 0, 0, 0, 6041, 6039, 1,
		0, 0, 0, 6042, 431, 1, 0, 0, 0, 6043, 6044, 5, 182, 0, 0, 6044, 6045, 5,
		485, 0, 0, 6045, 6046, 5, 28, 0, 0, 6046, 6047, 5, 305, 0, 0, 6047, 6054,
		5, 531, 0, 0, 6048, 6049, 5, 182, 0, 0, 6049, 6050, 5, 448, 0, 0, 6050,
		6051, 5, 28, 0, 0, 6051, 6052, 5, 305, 0, 0, 6052, 6054, 5, 526, 0, 0,
		6053, 6043, 1, 0, 0, 0, 6053, 6048, 1, 0, 0, 0, 6054, 433, 1, 0, 0, 0,
		6055, 6056, 3, 438, 219, 0, 6056, 6057, 3, 436, 218, 0, 6057, 435, 1, 0,
		0, 0, 6058, 6059, 5, 508, 0, 0, 6059, 6061, 3, 438, 219, 0, 6060, 6058,
		1, 0, 0, 0, 6061, 6062, 1, 0, 0, 0, 6062, 6060, 1, 0, 0, 0, 6062, 6063,
		1, 0, 0, 0, 6063, 6066, 1, 0, 0, 0, 6064, 6066, 1, 0, 0, 0, 6065, 6060,
		1, 0, 0, 0, 6065, 6064, 1, 0, 0, 0, 6066, 437, 1, 0, 0, 0, 6067, 6068,
		3, 440, 220, 0, 6068, 439, 1, 0, 0, 0, 6069, 6073, 5, 535, 0, 0, 6070,
		6073, 3, 442, 221, 0, 6071, 6073, 3, 446, 223, 0, 6072, 6069, 1, 0, 0,
		0, 6072, 6070, 1, 0, 0, 0, 6072, 6071, 1, 0, 0, 0, 6073, 441, 1, 0, 0,
		0, 6074, 6075, 5, 536, 0, 0, 6075, 443, 1, 0, 0, 0, 6076, 6078, 5, 508,
		0, 0, 6077, 6076, 1, 0, 0, 0, 6077, 6078, 1, 0, 0, 0, 6078, 6079, 1, 0,
		0, 0, 6079, 6085, 5, 531, 0, 0, 6080, 6082, 5, 508, 0, 0, 6081, 6080, 1,
		0, 0, 0, 6081, 6082, 1, 0, 0, 0, 6082, 6083, 1, 0, 0, 0, 6083, 6085, 7,
		58, 0, 0, 6084, 6077, 1, 0, 0, 0, 6084, 6081, 1, 0, 0, 0, 6085, 445, 1,
		0, 0, 0, 6086, 6087, 7, 59, 0, 0, 6087, 447, 1, 0, 0, 0, 874, 451, 455,
		460, 465, 471, 479, 483, 488, 502, 505, 513, 516, 524, 531, 538, 547, 554,
		561, 565, 567, 570, 574, 595, 614, 622, 629, 632, 636, 639, 641, 644, 648,
		652, 660, 667, 671, 673, 676, 688, 702, 710, 717, 724, 729, 755, 768, 770,
		774, 779, 781, 784, 792, 798, 801, 806, 811, 813, 834, 837, 840, 846, 853,
		856, 861, 864, 870, 874, 877, 885, 888, 891, 894, 900, 905, 908, 919, 924,
		927, 930, 937, 940, 945, 948, 951, 955, 961, 965, 971, 974, 978, 983, 991,
		993, 997, 1000, 1007, 1012, 1014, 1016, 1023, 1026, 1030, 1034, 1039, 1045,
		1052, 1056, 1066, 1071, 1077, 1085, 1087, 1094, 1099, 1107, 1111, 1118,
		1124, 1128, 1131, 1139, 1150, 1162, 1166, 1173, 1179, 1190, 1194, 1223,
		1230, 1236, 1264, 1277, 1290, 1309, 1319, 1333, 1340, 1347, 1354, 1362,
		1370, 1377, 1385, 1393, 1403, 1407, 1409, 1413, 1417, 1433, 1439, 1442,
		1451, 1457, 1461, 1473, 1479, 1482, 1495, 1505, 1509, 1513, 1520, 1537,
		1541, 1554, 1560, 1564, 1571, 1576, 1582, 1602, 1621, 1626, 1629, 1638,
		1650, 1654, 1667, 1680, 1684, 1691, 1697, 1700, 1706, 1708, 1712, 1722,
		1734, 1737, 1746, 1753, 1761, 1764, 1767, 1781, 1786, 1789, 1803, 1808,
		1811, 1818, 1820, 1826, 1831, 1835, 1838, 1841, 1850, 1852, 1860, 1862,
		1872, 1875, 1882, 1885, 1889, 1894, 1897, 1901, 1906, 1909, 1919, 1925,
		1930, 1936, 1939, 1943, 1950, 1953, 1960, 1963, 1966, 1970, 1974, 1979,
		1982, 1985, 1988, 1994, 1997, 2000, 2003, 2012, 2016, 2019, 2022, 2025,
		2030, 2034, 2037, 2040, 2044, 2050, 2053, 2056, 2066, 2069, 2072, 2075,
		2081, 2084, 2088, 2093, 2096, 2101, 2104, 2107, 2113, 2120, 2124, 2127,
		2132, 2135, 2140, 2144, 2150, 2158, 2164, 2167, 2178, 2189, 2191, 2193,
		2200, 2203, 2206, 2209, 2215, 2223, 2229, 2232, 2235, 2238, 2245, 2247,
		2255, 2259, 2266, 2269, 2272, 2280, 2289, 2292, 2306, 2345, 2352, 2354,
		2362, 2365, 2369, 2381, 2393, 2417, 2425, 2431, 2435, 2442, 2450, 2453,
		2459, 2465, 2470, 2478, 2482, 2489, 2498, 2504, 2510, 2513, 2519, 2522,
		2529, 2531, 2540, 2550, 2554, 2567, 2571, 2581, 2588, 2594, 2596, 2614,
		2618, 2631, 2635, 2652, 2662, 2668, 2676, 2688, 2692, 2700, 2702, 2708,
		2712, 2718, 2722, 2728, 2732, 2737, 2771, 2778, 2781, 2790, 2797, 2799,
		2803, 2806, 2809, 2812, 2816, 2819, 2825, 2831, 2833, 2837, 2841, 2844,
		2847, 2850, 2854, 2858, 2861, 2864, 2867, 2869, 2879, 2893, 2900, 2908,
		2921, 2935, 2942, 2950, 2955, 2959, 2962, 2969, 2997, 3014, 3022, 3034,
		3040, 3046, 3048, 3057, 3061, 3070, 3080, 3103, 3114, 3126, 3135, 3148,
		3152, 3159, 3162, 3165, 3171, 3174, 3177, 3185, 3188, 3194, 3197, 3203,
		3206, 3209, 3215, 3218, 3222, 3230, 3235, 3237, 3239, 3242, 3246, 3251,
		3255, 3260, 3264, 3272, 3281, 3285, 3288, 3291, 3298, 3301, 3326, 3334,
		3343, 3348, 3350, 3352, 3368, 3372, 3382, 3385, 3387, 3392, 3402, 3407,
		3412, 3420, 3424, 3430, 3437, 3447, 3455, 3464, 3466, 3472, 3475, 3481,
		3484, 3490, 3494, 3503, 3507, 3518, 3525, 3536, 3542, 3545, 3566, 3569,
		3584, 3589, 3592, 3602, 3606, 3609, 3615, 3621, 3624, 3631, 3643, 3651,
		3658, 3662, 3666, 3669, 3675, 3680, 3687, 3690, 3694, 3701, 3706, 3713,
		3724, 3731, 3736, 3741, 3753, 3761, 3764, 3768, 3772, 3778, 3782, 3790,
		3794, 3802, 3810, 3817, 3820, 3828, 3832, 3840, 3847, 3851, 3853, 3860,
		3867, 3869, 3876, 3883, 3887, 3893, 3898, 3900, 3908, 3910, 3917, 3919,
		3923, 3929, 3931, 3934, 3941, 3946, 3951, 3956, 3960, 3974, 3979, 3992,
		3994, 4001, 4009, 4013, 4018, 4023, 4028, 4036, 4045, 4048, 4053, 4055,
		4061, 4068, 4082, 4086, 4091, 4097, 4105, 4108, 4114, 4117, 4126, 4129,
		4135, 4145, 4149, 4152, 4154, 4159, 4164, 4168, 4174, 4181, 4193, 4195,
		4209, 4212, 4217, 4225, 4228, 4233, 4238, 4248, 4255, 4258, 4261, 4271,
		4279, 4285, 4291, 4296, 4301, 4304, 4307, 4310, 4313, 4316, 4319, 4322,
		4325, 4328, 4331, 4342, 4345, 4348, 4351, 4354, 4356, 4368, 4375, 4381,
		4385, 4390, 4397, 4402, 4411, 4413, 4419, 4422, 4426, 4429, 4432, 4446,
		4475, 4510, 4512, 4521, 4525, 4534, 4540, 4546, 4549, 4552, 4555, 4558,
		4566, 4574, 4577, 4580, 4591, 4597, 4600, 4602, 4613, 4617, 4620, 4623,
		4626, 4629, 4632, 4643, 4648, 4661, 4668, 4681, 4686, 4691, 4695, 4711,
		4718, 4724, 4728, 4738, 4746, 4757, 4762, 4775, 4778, 4788, 4791, 4802,
		4812, 4815, 4823, 4826, 4838, 4843, 4852, 4857, 4862, 4871, 4876, 4878,
		4884, 4886, 4889, 4895, 4902, 4914, 4917, 4927, 4931, 4934, 4943, 4948,
		4952, 4964, 4973, 4977, 4982, 4986, 4990, 5000, 5006, 5017, 5024, 5030,
		5033, 5036, 5039, 5042, 5046, 5049, 5054, 5064, 5070, 5079, 5094, 5103,
		5107, 5110, 5114, 5116, 5123, 5131, 5137, 5144, 5150, 5153, 5157, 5164,
		5167, 5170, 5177, 5179, 5195, 5197, 5199, 5208, 5210, 5214, 5221, 5228,
		5234, 5241, 5245, 5252, 5259, 5265, 5271, 5279, 5285, 5302, 5308, 5319,
		5325, 5327, 5335, 5347, 5355, 5358, 5369, 5380, 5385, 5388, 5395, 5400,
		5412, 5418, 5440, 5444, 5458, 5460, 5469, 5472, 5479, 5482, 5490, 5495,
		5500, 5508, 5517, 5524, 5529, 5532, 5538, 5559, 5561, 5576, 5580, 5589,
		5593, 5610, 5619, 5629, 5634, 5662, 5666, 5677, 5685, 5690, 5702, 5714,
		5716, 5718, 5731, 5736, 5738, 5743, 5750, 5760, 5763, 5765, 5770, 5775,
		5795, 5799, 5802, 5805, 5818, 5829, 5836, 5840, 5845, 5848, 5852, 5860,
		5865, 5871, 5880, 5889, 5899, 5905, 5924, 5927, 5955, 5968, 5972, 5974,
		6008, 6015, 6022, 6030, 6035, 6041, 6053, 6062, 6065, 6072, 6077, 6081,
		6084,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// DorisParserInit initializes any static state used to implement DorisParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewDorisParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func DorisParserInit() {
	staticData := &DorisParserParserStaticData
	staticData.once.Do(dorisparserParserInit)
}

// NewDorisParser produces a new parser instance for the optional input antlr.TokenStream.
func NewDorisParser(input antlr.TokenStream) *DorisParser {
	DorisParserInit()
	this := new(DorisParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &DorisParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "DorisParser.g4"

	return this
}

// Note that '@members' cannot be changed now, but this should have been 'globals'
// If you are looking to have variables for each instance, use '@structmembers'

var doris_legacy_SQL_syntax = true

// DorisParser tokens.
const (
	DorisParserEOF                     = antlr.TokenEOF
	DorisParserSEMICOLON               = 1
	DorisParserLEFT_PAREN              = 2
	DorisParserRIGHT_PAREN             = 3
	DorisParserCOMMA                   = 4
	DorisParserDOT                     = 5
	DorisParserDOTDOTDOT               = 6
	DorisParserLEFT_BRACKET            = 7
	DorisParserRIGHT_BRACKET           = 8
	DorisParserLEFT_BRACE              = 9
	DorisParserRIGHT_BRACE             = 10
	DorisParserACCOUNT_LOCK            = 11
	DorisParserACCOUNT_UNLOCK          = 12
	DorisParserACTIONS                 = 13
	DorisParserADD                     = 14
	DorisParserADMIN                   = 15
	DorisParserAFTER                   = 16
	DorisParserAGG_STATE               = 17
	DorisParserAGGREGATE               = 18
	DorisParserALIAS                   = 19
	DorisParserALL                     = 20
	DorisParserALTER                   = 21
	DorisParserANALYZE                 = 22
	DorisParserANALYZED                = 23
	DorisParserAND                     = 24
	DorisParserANTI                    = 25
	DorisParserAPPEND                  = 26
	DorisParserARRAY                   = 27
	DorisParserAS                      = 28
	DorisParserASC                     = 29
	DorisParserAT                      = 30
	DorisParserAUTHORS                 = 31
	DorisParserAUTO                    = 32
	DorisParserAUTO_INCREMENT          = 33
	DorisParserALWAYS                  = 34
	DorisParserBACKEND                 = 35
	DorisParserBACKENDS                = 36
	DorisParserBACKUP                  = 37
	DorisParserBEGIN                   = 38
	DorisParserBELONG                  = 39
	DorisParserBETWEEN                 = 40
	DorisParserBIGINT                  = 41
	DorisParserBIN                     = 42
	DorisParserBINARY                  = 43
	DorisParserBINLOG                  = 44
	DorisParserBITAND                  = 45
	DorisParserBITMAP                  = 46
	DorisParserBITMAP_EMPTY            = 47
	DorisParserBITMAP_UNION            = 48
	DorisParserBITOR                   = 49
	DorisParserBITXOR                  = 50
	DorisParserBLOB                    = 51
	DorisParserBOOLEAN                 = 52
	DorisParserBRIEF                   = 53
	DorisParserBROKER                  = 54
	DorisParserBUCKETS                 = 55
	DorisParserBUILD                   = 56
	DorisParserBUILTIN                 = 57
	DorisParserBULK                    = 58
	DorisParserBY                      = 59
	DorisParserCACHE                   = 60
	DorisParserCACHED                  = 61
	DorisParserCALL                    = 62
	DorisParserCANCEL                  = 63
	DorisParserCASE                    = 64
	DorisParserCAST                    = 65
	DorisParserCATALOG                 = 66
	DorisParserCATALOGS                = 67
	DorisParserCHAIN                   = 68
	DorisParserCHAR                    = 69
	DorisParserCHARSET                 = 70
	DorisParserCHECK                   = 71
	DorisParserCLEAN                   = 72
	DorisParserCLUSTER                 = 73
	DorisParserCLUSTERS                = 74
	DorisParserCOLLATE                 = 75
	DorisParserCOLLATION               = 76
	DorisParserCOLLECT                 = 77
	DorisParserCOLOCATE                = 78
	DorisParserCOLUMN                  = 79
	DorisParserCOLUMNS                 = 80
	DorisParserCOMMENT                 = 81
	DorisParserCOMMIT                  = 82
	DorisParserCOMMITTED               = 83
	DorisParserCOMPACT                 = 84
	DorisParserCOMPLETE                = 85
	DorisParserCOMPRESS_TYPE           = 86
	DorisParserCOMPUTE                 = 87
	DorisParserCONDITIONS              = 88
	DorisParserCONFIG                  = 89
	DorisParserCONNECTION              = 90
	DorisParserCONNECTION_ID           = 91
	DorisParserCONSISTENT              = 92
	DorisParserCONSTRAINT              = 93
	DorisParserCONSTRAINTS             = 94
	DorisParserCONVERT                 = 95
	DorisParserCONVERT_LSC             = 96
	DorisParserCOPY                    = 97
	DorisParserCOUNT                   = 98
	DorisParserCREATE                  = 99
	DorisParserCREATION                = 100
	DorisParserCRON                    = 101
	DorisParserCROSS                   = 102
	DorisParserCUBE                    = 103
	DorisParserCURRENT                 = 104
	DorisParserCURRENT_CATALOG         = 105
	DorisParserCURRENT_DATE            = 106
	DorisParserCURRENT_TIME            = 107
	DorisParserCURRENT_TIMESTAMP       = 108
	DorisParserCURRENT_USER            = 109
	DorisParserDATA                    = 110
	DorisParserDATABASE                = 111
	DorisParserDATABASES               = 112
	DorisParserDATE                    = 113
	DorisParserDATETIME                = 114
	DorisParserDATETIMEV2              = 115
	DorisParserDATEV2                  = 116
	DorisParserDATETIMEV1              = 117
	DorisParserDATEV1                  = 118
	DorisParserDAY                     = 119
	DorisParserDECIMAL                 = 120
	DorisParserDECIMALV2               = 121
	DorisParserDECIMALV3               = 122
	DorisParserDECOMMISSION            = 123
	DorisParserDEFAULT                 = 124
	DorisParserDEFERRED                = 125
	DorisParserDELETE                  = 126
	DorisParserDEMAND                  = 127
	DorisParserDESC                    = 128
	DorisParserDESCRIBE                = 129
	DorisParserDIAGNOSE                = 130
	DorisParserDIAGNOSIS               = 131
	DorisParserDISK                    = 132
	DorisParserDISTINCT                = 133
	DorisParserDISTINCTPC              = 134
	DorisParserDISTINCTPCSA            = 135
	DorisParserDISTRIBUTED             = 136
	DorisParserDISTRIBUTION            = 137
	DorisParserDIV                     = 138
	DorisParserDO                      = 139
	DorisParserDORIS_INTERNAL_TABLE_ID = 140
	DorisParserDOUBLE                  = 141
	DorisParserDROP                    = 142
	DorisParserDROPP                   = 143
	DorisParserDUAL                    = 144
	DorisParserDUMP                    = 145
	DorisParserDUPLICATE               = 146
	DorisParserDYNAMIC                 = 147
	DorisParserE                       = 148
	DorisParserELSE                    = 149
	DorisParserENABLE                  = 150
	DorisParserENCRYPTKEY              = 151
	DorisParserENCRYPTKEYS             = 152
	DorisParserEND                     = 153
	DorisParserENDS                    = 154
	DorisParserENGINE                  = 155
	DorisParserENGINES                 = 156
	DorisParserENTER                   = 157
	DorisParserERRORS                  = 158
	DorisParserEVENTS                  = 159
	DorisParserEVERY                   = 160
	DorisParserEXCEPT                  = 161
	DorisParserEXCLUDE                 = 162
	DorisParserEXECUTE                 = 163
	DorisParserEXISTS                  = 164
	DorisParserEXPIRED                 = 165
	DorisParserEXPLAIN                 = 166
	DorisParserEXPORT                  = 167
	DorisParserEXTENDED                = 168
	DorisParserEXTERNAL                = 169
	DorisParserEXTRACT                 = 170
	DorisParserFAILED_LOGIN_ATTEMPTS   = 171
	DorisParserFALSE                   = 172
	DorisParserFAST                    = 173
	DorisParserFEATURE                 = 174
	DorisParserFIELDS                  = 175
	DorisParserFILE                    = 176
	DorisParserFILTER                  = 177
	DorisParserFIRST                   = 178
	DorisParserFLOAT                   = 179
	DorisParserFOLLOWER                = 180
	DorisParserFOLLOWING               = 181
	DorisParserFOR                     = 182
	DorisParserFOREIGN                 = 183
	DorisParserFORCE                   = 184
	DorisParserFORMAT                  = 185
	DorisParserFREE                    = 186
	DorisParserFROM                    = 187
	DorisParserFRONTEND                = 188
	DorisParserFRONTENDS               = 189
	DorisParserFULL                    = 190
	DorisParserFUNCTION                = 191
	DorisParserFUNCTIONS               = 192
	DorisParserGENERATED               = 193
	DorisParserGENERIC                 = 194
	DorisParserGLOBAL                  = 195
	DorisParserGRANT                   = 196
	DorisParserGRANTS                  = 197
	DorisParserGRAPH                   = 198
	DorisParserGROUP                   = 199
	DorisParserGROUPING                = 200
	DorisParserGROUPS                  = 201
	DorisParserHASH                    = 202
	DorisParserHAVING                  = 203
	DorisParserHDFS                    = 204
	DorisParserHELP                    = 205
	DorisParserHISTOGRAM               = 206
	DorisParserHLL                     = 207
	DorisParserHLL_UNION               = 208
	DorisParserHOSTNAME                = 209
	DorisParserHOTSPOT                 = 210
	DorisParserHOUR                    = 211
	DorisParserHUB                     = 212
	DorisParserIDENTIFIED              = 213
	DorisParserIF                      = 214
	DorisParserIGNORE                  = 215
	DorisParserIMMEDIATE               = 216
	DorisParserIN                      = 217
	DorisParserINCREMENTAL             = 218
	DorisParserINDEX                   = 219
	DorisParserINDEXES                 = 220
	DorisParserINFILE                  = 221
	DorisParserINNER                   = 222
	DorisParserINSERT                  = 223
	DorisParserINSTALL                 = 224
	DorisParserINT                     = 225
	DorisParserINTEGER                 = 226
	DorisParserINTERMEDIATE            = 227
	DorisParserINTERSECT               = 228
	DorisParserINTERVAL                = 229
	DorisParserINTO                    = 230
	DorisParserINVERTED                = 231
	DorisParserIPV4                    = 232
	DorisParserIPV6                    = 233
	DorisParserIS                      = 234
	DorisParserIS_NOT_NULL_PRED        = 235
	DorisParserIS_NULL_PRED            = 236
	DorisParserISNULL                  = 237
	DorisParserISOLATION               = 238
	DorisParserJOB                     = 239
	DorisParserJOBS                    = 240
	DorisParserJOIN                    = 241
	DorisParserJSON                    = 242
	DorisParserJSONB                   = 243
	DorisParserKEY                     = 244
	DorisParserKEYS                    = 245
	DorisParserKILL                    = 246
	DorisParserLABEL                   = 247
	DorisParserLARGEINT                = 248
	DorisParserLAST                    = 249
	DorisParserLATERAL                 = 250
	DorisParserLDAP                    = 251
	DorisParserLDAP_ADMIN_PASSWORD     = 252
	DorisParserLEFT                    = 253
	DorisParserLESS                    = 254
	DorisParserLEVEL                   = 255
	DorisParserLIKE                    = 256
	DorisParserLIMIT                   = 257
	DorisParserLINES                   = 258
	DorisParserLINK                    = 259
	DorisParserLIST                    = 260
	DorisParserLOAD                    = 261
	DorisParserLOCAL                   = 262
	DorisParserLOCALTIME               = 263
	DorisParserLOCALTIMESTAMP          = 264
	DorisParserLOCATION                = 265
	DorisParserLOCK                    = 266
	DorisParserLOGICAL                 = 267
	DorisParserLOW_PRIORITY            = 268
	DorisParserMANUAL                  = 269
	DorisParserMAP                     = 270
	DorisParserMATCH                   = 271
	DorisParserMATCH_ALL               = 272
	DorisParserMATCH_ANY               = 273
	DorisParserMATCH_PHRASE            = 274
	DorisParserMATCH_PHRASE_EDGE       = 275
	DorisParserMATCH_PHRASE_PREFIX     = 276
	DorisParserMATCH_REGEXP            = 277
	DorisParserMATERIALIZED            = 278
	DorisParserMAX                     = 279
	DorisParserMAXVALUE                = 280
	DorisParserMEMO                    = 281
	DorisParserMERGE                   = 282
	DorisParserMIGRATE                 = 283
	DorisParserMIGRATIONS              = 284
	DorisParserMIN                     = 285
	DorisParserMINUS                   = 286
	DorisParserMINUTE                  = 287
	DorisParserMODIFY                  = 288
	DorisParserMONTH                   = 289
	DorisParserMTMV                    = 290
	DorisParserNAME                    = 291
	DorisParserNAMES                   = 292
	DorisParserNATURAL                 = 293
	DorisParserNEGATIVE                = 294
	DorisParserNEVER                   = 295
	DorisParserNEXT                    = 296
	DorisParserNGRAM_BF                = 297
	DorisParserNO                      = 298
	DorisParserNO_USE_MV               = 299
	DorisParserNON_NULLABLE            = 300
	DorisParserNOT                     = 301
	DorisParserNULL                    = 302
	DorisParserNULLS                   = 303
	DorisParserOBSERVER                = 304
	DorisParserOF                      = 305
	DorisParserOFFSET                  = 306
	DorisParserON                      = 307
	DorisParserONLY                    = 308
	DorisParserOPEN                    = 309
	DorisParserOPTIMIZED               = 310
	DorisParserOR                      = 311
	DorisParserORDER                   = 312
	DorisParserOUTER                   = 313
	DorisParserOUTFILE                 = 314
	DorisParserOVER                    = 315
	DorisParserOVERWRITE               = 316
	DorisParserPARAMETER               = 317
	DorisParserPARSED                  = 318
	DorisParserPARTITION               = 319
	DorisParserPARTITIONS              = 320
	DorisParserPASSWORD                = 321
	DorisParserPASSWORD_EXPIRE         = 322
	DorisParserPASSWORD_HISTORY        = 323
	DorisParserPASSWORD_LOCK_TIME      = 324
	DorisParserPASSWORD_REUSE          = 325
	DorisParserPATH                    = 326
	DorisParserPAUSE                   = 327
	DorisParserPERCENT                 = 328
	DorisParserPERIOD                  = 329
	DorisParserPERMISSIVE              = 330
	DorisParserPHYSICAL                = 331
	DorisParserPI                      = 332
	DorisParserPLACEHOLDER             = 333
	DorisParserPLAN                    = 334
	DorisParserPLAY                    = 335
	DorisParserPRIVILEGES              = 336
	DorisParserPROCESS                 = 337
	DorisParserPLUGIN                  = 338
	DorisParserPLUGINS                 = 339
	DorisParserPOLICY                  = 340
	DorisParserPRECEDING               = 341
	DorisParserPREPARE                 = 342
	DorisParserPRIMARY                 = 343
	DorisParserPROC                    = 344
	DorisParserPROCEDURE               = 345
	DorisParserPROCESSLIST             = 346
	DorisParserPROFILE                 = 347
	DorisParserPROPERTIES              = 348
	DorisParserPROPERTY                = 349
	DorisParserQUANTILE_STATE          = 350
	DorisParserQUANTILE_UNION          = 351
	DorisParserQUERY                   = 352
	DorisParserQUOTA                   = 353
	DorisParserQUALIFY                 = 354
	DorisParserQUARTER                 = 355
	DorisParserRANDOM                  = 356
	DorisParserRANGE                   = 357
	DorisParserREAD                    = 358
	DorisParserREAL                    = 359
	DorisParserREBALANCE               = 360
	DorisParserRECENT                  = 361
	DorisParserRECOVER                 = 362
	DorisParserRECYCLE                 = 363
	DorisParserREFRESH                 = 364
	DorisParserREFERENCES              = 365
	DorisParserREGEXP                  = 366
	DorisParserRELEASE                 = 367
	DorisParserRENAME                  = 368
	DorisParserREPAIR                  = 369
	DorisParserREPEATABLE              = 370
	DorisParserREPLACE                 = 371
	DorisParserREPLACE_IF_NOT_NULL     = 372
	DorisParserREPLAYER                = 373
	DorisParserREPLICA                 = 374
	DorisParserREPOSITORIES            = 375
	DorisParserREPOSITORY              = 376
	DorisParserRESOURCE                = 377
	DorisParserRESOURCES               = 378
	DorisParserRESTORE                 = 379
	DorisParserRESTRICTIVE             = 380
	DorisParserRESUME                  = 381
	DorisParserRETURNS                 = 382
	DorisParserREVOKE                  = 383
	DorisParserREWRITTEN               = 384
	DorisParserRIGHT                   = 385
	DorisParserRLIKE                   = 386
	DorisParserROLE                    = 387
	DorisParserROLES                   = 388
	DorisParserROLLBACK                = 389
	DorisParserROLLUP                  = 390
	DorisParserROUTINE                 = 391
	DorisParserROW                     = 392
	DorisParserROWS                    = 393
	DorisParserS3                      = 394
	DorisParserSAMPLE                  = 395
	DorisParserSCHEDULE                = 396
	DorisParserSCHEDULER               = 397
	DorisParserSCHEMA                  = 398
	DorisParserSCHEMAS                 = 399
	DorisParserSECOND                  = 400
	DorisParserSELECT                  = 401
	DorisParserSEMI                    = 402
	DorisParserSERIALIZABLE            = 403
	DorisParserSESSION                 = 404
	DorisParserSESSION_USER            = 405
	DorisParserSET                     = 406
	DorisParserSETS                    = 407
	DorisParserSET_SESSION_VARIABLE    = 408
	DorisParserSHAPE                   = 409
	DorisParserSHOW                    = 410
	DorisParserSIGNED                  = 411
	DorisParserSKEW                    = 412
	DorisParserSMALLINT                = 413
	DorisParserSNAPSHOT                = 414
	DorisParserSONAME                  = 415
	DorisParserSPLIT                   = 416
	DorisParserSQL                     = 417
	DorisParserSQL_BLOCK_RULE          = 418
	DorisParserSTAGE                   = 419
	DorisParserSTAGES                  = 420
	DorisParserSTART                   = 421
	DorisParserSTARTS                  = 422
	DorisParserSTATS                   = 423
	DorisParserSTATUS                  = 424
	DorisParserSTOP                    = 425
	DorisParserSTORAGE                 = 426
	DorisParserSTREAM                  = 427
	DorisParserSTREAMING               = 428
	DorisParserSTRING                  = 429
	DorisParserSTRUCT                  = 430
	DorisParserSUM                     = 431
	DorisParserSUPERUSER               = 432
	DorisParserSWITCH                  = 433
	DorisParserSYNC                    = 434
	DorisParserSYSTEM                  = 435
	DorisParserTABLE                   = 436
	DorisParserTABLES                  = 437
	DorisParserTABLESAMPLE             = 438
	DorisParserTABLET                  = 439
	DorisParserTABLETS                 = 440
	DorisParserTASK                    = 441
	DorisParserTASKS                   = 442
	DorisParserTEMPORARY               = 443
	DorisParserTERMINATED              = 444
	DorisParserTEXT                    = 445
	DorisParserTHAN                    = 446
	DorisParserTHEN                    = 447
	DorisParserTIME                    = 448
	DorisParserTIMESTAMP               = 449
	DorisParserTINYINT                 = 450
	DorisParserTO                      = 451
	DorisParserTRANSACTION             = 452
	DorisParserTRASH                   = 453
	DorisParserTREE                    = 454
	DorisParserTRIGGERS                = 455
	DorisParserTRIM                    = 456
	DorisParserTRUE                    = 457
	DorisParserTRUNCATE                = 458
	DorisParserTYPE                    = 459
	DorisParserTYPECAST                = 460
	DorisParserTYPES                   = 461
	DorisParserUNBOUNDED               = 462
	DorisParserUNCOMMITTED             = 463
	DorisParserUNINSTALL               = 464
	DorisParserUNION                   = 465
	DorisParserUNIQUE                  = 466
	DorisParserUNLOCK                  = 467
	DorisParserUNSET                   = 468
	DorisParserUNSIGNED                = 469
	DorisParserUP                      = 470
	DorisParserUPDATE                  = 471
	DorisParserUSE                     = 472
	DorisParserUSER                    = 473
	DorisParserUSE_MV                  = 474
	DorisParserUSING                   = 475
	DorisParserVALUE                   = 476
	DorisParserVALUES                  = 477
	DorisParserVARCHAR                 = 478
	DorisParserVARIABLE                = 479
	DorisParserVARIABLES               = 480
	DorisParserVARIANT                 = 481
	DorisParserVAULT                   = 482
	DorisParserVAULTS                  = 483
	DorisParserVERBOSE                 = 484
	DorisParserVERSION                 = 485
	DorisParserVIEW                    = 486
	DorisParserVIEWS                   = 487
	DorisParserWARM                    = 488
	DorisParserWARNINGS                = 489
	DorisParserWEEK                    = 490
	DorisParserWHEN                    = 491
	DorisParserWHERE                   = 492
	DorisParserWHITELIST               = 493
	DorisParserWITH                    = 494
	DorisParserWORK                    = 495
	DorisParserWORKLOAD                = 496
	DorisParserWRITE                   = 497
	DorisParserXOR                     = 498
	DorisParserYEAR                    = 499
	DorisParserEQ                      = 500
	DorisParserNSEQ                    = 501
	DorisParserNEQ                     = 502
	DorisParserLT                      = 503
	DorisParserLTE                     = 504
	DorisParserGT                      = 505
	DorisParserGTE                     = 506
	DorisParserPLUS                    = 507
	DorisParserSUBTRACT                = 508
	DorisParserASTERISK                = 509
	DorisParserSLASH                   = 510
	DorisParserMOD                     = 511
	DorisParserTILDE                   = 512
	DorisParserAMPERSAND               = 513
	DorisParserLOGICALAND              = 514
	DorisParserLOGICALNOT              = 515
	DorisParserPIPE                    = 516
	DorisParserDOUBLEPIPES             = 517
	DorisParserHAT                     = 518
	DorisParserCOLON                   = 519
	DorisParserARROW                   = 520
	DorisParserHINT_START              = 521
	DorisParserHINT_END                = 522
	DorisParserCOMMENT_START           = 523
	DorisParserATSIGN                  = 524
	DorisParserDOUBLEATSIGN            = 525
	DorisParserSTRING_LITERAL          = 526
	DorisParserLEADING_STRING          = 527
	DorisParserBIGINT_LITERAL          = 528
	DorisParserSMALLINT_LITERAL        = 529
	DorisParserTINYINT_LITERAL         = 530
	DorisParserINTEGER_VALUE           = 531
	DorisParserEXPONENT_VALUE          = 532
	DorisParserDECIMAL_VALUE           = 533
	DorisParserBIGDECIMAL_LITERAL      = 534
	DorisParserIDENTIFIER              = 535
	DorisParserBACKQUOTED_IDENTIFIER   = 536
	DorisParserSIMPLE_COMMENT          = 537
	DorisParserBRACKETED_COMMENT       = 538
	DorisParserFROM_DUAL               = 539
	DorisParserWS                      = 540
	DorisParserUNRECOGNIZED            = 541
)

// DorisParser rules.
const (
	DorisParserRULE_multiStatements                 = 0
	DorisParserRULE_singleStatement                 = 1
	DorisParserRULE_statement                       = 2
	DorisParserRULE_statementBase                   = 3
	DorisParserRULE_unsupportedStatement            = 4
	DorisParserRULE_materializedViewStatement       = 5
	DorisParserRULE_supportedJobStatement           = 6
	DorisParserRULE_constraintStatement             = 7
	DorisParserRULE_supportedDmlStatement           = 8
	DorisParserRULE_supportedCreateStatement        = 9
	DorisParserRULE_supportedAlterStatement         = 10
	DorisParserRULE_supportedDropStatement          = 11
	DorisParserRULE_supportedShowStatement          = 12
	DorisParserRULE_supportedLoadStatement          = 13
	DorisParserRULE_supportedOtherStatement         = 14
	DorisParserRULE_unsupportedOtherStatement       = 15
	DorisParserRULE_warmUpItem                      = 16
	DorisParserRULE_lockTable                       = 17
	DorisParserRULE_unsupportedShowStatement        = 18
	DorisParserRULE_createRoutineLoad               = 19
	DorisParserRULE_unsupportedLoadStatement        = 20
	DorisParserRULE_loadProperty                    = 21
	DorisParserRULE_importSequenceStatement         = 22
	DorisParserRULE_importDeleteOnStatement         = 23
	DorisParserRULE_importWhereStatement            = 24
	DorisParserRULE_importPrecedingFilterStatement  = 25
	DorisParserRULE_importColumnsStatement          = 26
	DorisParserRULE_importColumnDesc                = 27
	DorisParserRULE_channelDescriptions             = 28
	DorisParserRULE_channelDescription              = 29
	DorisParserRULE_supportedRefreshStatement       = 30
	DorisParserRULE_supportedCleanStatement         = 31
	DorisParserRULE_unsupportedRefreshStatement     = 32
	DorisParserRULE_unsupportedCleanStatement       = 33
	DorisParserRULE_supportedCancelStatement        = 34
	DorisParserRULE_unsupportedCancelStatement      = 35
	DorisParserRULE_supportedAdminStatement         = 36
	DorisParserRULE_supportedRecoverStatement       = 37
	DorisParserRULE_unsupportedAdminStatement       = 38
	DorisParserRULE_baseTableRef                    = 39
	DorisParserRULE_wildWhere                       = 40
	DorisParserRULE_unsupportedTransactionStatement = 41
	DorisParserRULE_unsupportedGrantRevokeStatement = 42
	DorisParserRULE_privilege                       = 43
	DorisParserRULE_privilegeList                   = 44
	DorisParserRULE_unsupportedAlterStatement       = 45
	DorisParserRULE_alterSystemClause               = 46
	DorisParserRULE_dropRollupClause                = 47
	DorisParserRULE_addRollupClause                 = 48
	DorisParserRULE_alterTableClause                = 49
	DorisParserRULE_columnPosition                  = 50
	DorisParserRULE_toRollup                        = 51
	DorisParserRULE_fromRollup                      = 52
	DorisParserRULE_unsupportedDropStatement        = 53
	DorisParserRULE_unsupportedStatsStatement       = 54
	DorisParserRULE_analyzeProperties               = 55
	DorisParserRULE_unsupportedCreateStatement      = 56
	DorisParserRULE_workloadPolicyActions           = 57
	DorisParserRULE_workloadPolicyAction            = 58
	DorisParserRULE_workloadPolicyConditions        = 59
	DorisParserRULE_workloadPolicyCondition         = 60
	DorisParserRULE_storageBackend                  = 61
	DorisParserRULE_passwordOption                  = 62
	DorisParserRULE_functionArguments               = 63
	DorisParserRULE_functionArgument                = 64
	DorisParserRULE_supportedSetStatement           = 65
	DorisParserRULE_optionWithType                  = 66
	DorisParserRULE_optionWithoutType               = 67
	DorisParserRULE_variable                        = 68
	DorisParserRULE_transactionAccessMode           = 69
	DorisParserRULE_isolationLevel                  = 70
	DorisParserRULE_supportedUnsetStatement         = 71
	DorisParserRULE_supportedUseStatement           = 72
	DorisParserRULE_unsupportedUseStatement         = 73
	DorisParserRULE_unsupportedDmlStatement         = 74
	DorisParserRULE_stageAndPattern                 = 75
	DorisParserRULE_unsupportedKillStatement        = 76
	DorisParserRULE_unsupportedDescribeStatement    = 77
	DorisParserRULE_constraint                      = 78
	DorisParserRULE_partitionSpec                   = 79
	DorisParserRULE_partitionTable                  = 80
	DorisParserRULE_identityOrFunctionList          = 81
	DorisParserRULE_identityOrFunction              = 82
	DorisParserRULE_dataDesc                        = 83
	DorisParserRULE_buildMode                       = 84
	DorisParserRULE_refreshTrigger                  = 85
	DorisParserRULE_refreshSchedule                 = 86
	DorisParserRULE_refreshMethod                   = 87
	DorisParserRULE_mvPartition                     = 88
	DorisParserRULE_identifierOrText                = 89
	DorisParserRULE_identifierOrTextOrAsterisk      = 90
	DorisParserRULE_multipartIdentifierOrAsterisk   = 91
	DorisParserRULE_identifierOrAsterisk            = 92
	DorisParserRULE_userIdentify                    = 93
	DorisParserRULE_grantUserIdentify               = 94
	DorisParserRULE_explain                         = 95
	DorisParserRULE_explainCommand                  = 96
	DorisParserRULE_planType                        = 97
	DorisParserRULE_replayCommand                   = 98
	DorisParserRULE_replayType                      = 99
	DorisParserRULE_mergeType                       = 100
	DorisParserRULE_preFilterClause                 = 101
	DorisParserRULE_deleteOnClause                  = 102
	DorisParserRULE_sequenceColClause               = 103
	DorisParserRULE_colFromPath                     = 104
	DorisParserRULE_colMappingList                  = 105
	DorisParserRULE_mappingExpr                     = 106
	DorisParserRULE_withRemoteStorageSystem         = 107
	DorisParserRULE_resourceDesc                    = 108
	DorisParserRULE_mysqlDataDesc                   = 109
	DorisParserRULE_skipLines                       = 110
	DorisParserRULE_outFileClause                   = 111
	DorisParserRULE_query                           = 112
	DorisParserRULE_queryTerm                       = 113
	DorisParserRULE_setQuantifier                   = 114
	DorisParserRULE_queryPrimary                    = 115
	DorisParserRULE_querySpecification              = 116
	DorisParserRULE_cte                             = 117
	DorisParserRULE_aliasQuery                      = 118
	DorisParserRULE_columnAliases                   = 119
	DorisParserRULE_selectClause                    = 120
	DorisParserRULE_selectColumnClause              = 121
	DorisParserRULE_whereClause                     = 122
	DorisParserRULE_fromClause                      = 123
	DorisParserRULE_intoClause                      = 124
	DorisParserRULE_bulkCollectClause               = 125
	DorisParserRULE_tableRow                        = 126
	DorisParserRULE_relations                       = 127
	DorisParserRULE_relation                        = 128
	DorisParserRULE_joinRelation                    = 129
	DorisParserRULE_distributeType                  = 130
	DorisParserRULE_relationHint                    = 131
	DorisParserRULE_aggClause                       = 132
	DorisParserRULE_groupingElement                 = 133
	DorisParserRULE_groupingSet                     = 134
	DorisParserRULE_havingClause                    = 135
	DorisParserRULE_qualifyClause                   = 136
	DorisParserRULE_selectHint                      = 137
	DorisParserRULE_hintStatement                   = 138
	DorisParserRULE_hintAssignment                  = 139
	DorisParserRULE_updateAssignment                = 140
	DorisParserRULE_updateAssignmentSeq             = 141
	DorisParserRULE_lateralView                     = 142
	DorisParserRULE_queryOrganization               = 143
	DorisParserRULE_sortClause                      = 144
	DorisParserRULE_sortItem                        = 145
	DorisParserRULE_limitClause                     = 146
	DorisParserRULE_partitionClause                 = 147
	DorisParserRULE_joinType                        = 148
	DorisParserRULE_joinCriteria                    = 149
	DorisParserRULE_identifierList                  = 150
	DorisParserRULE_identifierSeq                   = 151
	DorisParserRULE_optScanParams                   = 152
	DorisParserRULE_relationPrimary                 = 153
	DorisParserRULE_materializedViewName            = 154
	DorisParserRULE_propertyClause                  = 155
	DorisParserRULE_propertyItemList                = 156
	DorisParserRULE_propertyItem                    = 157
	DorisParserRULE_propertyKey                     = 158
	DorisParserRULE_propertyValue                   = 159
	DorisParserRULE_tableAlias                      = 160
	DorisParserRULE_multipartIdentifier             = 161
	DorisParserRULE_simpleColumnDefs                = 162
	DorisParserRULE_simpleColumnDef                 = 163
	DorisParserRULE_columnDefs                      = 164
	DorisParserRULE_columnDef                       = 165
	DorisParserRULE_indexDefs                       = 166
	DorisParserRULE_indexDef                        = 167
	DorisParserRULE_partitionsDef                   = 168
	DorisParserRULE_partitionDef                    = 169
	DorisParserRULE_lessThanPartitionDef            = 170
	DorisParserRULE_fixedPartitionDef               = 171
	DorisParserRULE_stepPartitionDef                = 172
	DorisParserRULE_inPartitionDef                  = 173
	DorisParserRULE_partitionValueList              = 174
	DorisParserRULE_partitionValueDef               = 175
	DorisParserRULE_rollupDefs                      = 176
	DorisParserRULE_rollupDef                       = 177
	DorisParserRULE_aggTypeDef                      = 178
	DorisParserRULE_tabletList                      = 179
	DorisParserRULE_inlineTable                     = 180
	DorisParserRULE_namedExpression                 = 181
	DorisParserRULE_namedExpressionSeq              = 182
	DorisParserRULE_expression                      = 183
	DorisParserRULE_lambdaExpression                = 184
	DorisParserRULE_booleanExpression               = 185
	DorisParserRULE_rowConstructor                  = 186
	DorisParserRULE_rowConstructorItem              = 187
	DorisParserRULE_predicate                       = 188
	DorisParserRULE_valueExpression                 = 189
	DorisParserRULE_primaryExpression               = 190
	DorisParserRULE_exceptOrReplace                 = 191
	DorisParserRULE_castDataType                    = 192
	DorisParserRULE_functionCallExpression          = 193
	DorisParserRULE_functionIdentifier              = 194
	DorisParserRULE_functionNameIdentifier          = 195
	DorisParserRULE_windowSpec                      = 196
	DorisParserRULE_windowFrame                     = 197
	DorisParserRULE_frameUnits                      = 198
	DorisParserRULE_frameBoundary                   = 199
	DorisParserRULE_qualifiedName                   = 200
	DorisParserRULE_specifiedPartition              = 201
	DorisParserRULE_constant                        = 202
	DorisParserRULE_comparisonOperator              = 203
	DorisParserRULE_booleanValue                    = 204
	DorisParserRULE_whenClause                      = 205
	DorisParserRULE_interval                        = 206
	DorisParserRULE_unitIdentifier                  = 207
	DorisParserRULE_dataTypeWithNullable            = 208
	DorisParserRULE_dataType                        = 209
	DorisParserRULE_primitiveColType                = 210
	DorisParserRULE_complexColTypeList              = 211
	DorisParserRULE_complexColType                  = 212
	DorisParserRULE_commentSpec                     = 213
	DorisParserRULE_sample                          = 214
	DorisParserRULE_sampleMethod                    = 215
	DorisParserRULE_tableSnapshot                   = 216
	DorisParserRULE_errorCapturingIdentifier        = 217
	DorisParserRULE_errorCapturingIdentifierExtra   = 218
	DorisParserRULE_identifier                      = 219
	DorisParserRULE_strictIdentifier                = 220
	DorisParserRULE_quotedIdentifier                = 221
	DorisParserRULE_number                          = 222
	DorisParserRULE_nonReserved                     = 223
)

// IMultiStatementsContext is an interface to support dynamic dispatch.
type IMultiStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsMultiStatementsContext differentiates from other interfaces.
	IsMultiStatementsContext()
}

type MultiStatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiStatementsContext() *MultiStatementsContext {
	var p = new(MultiStatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_multiStatements
	return p
}

func InitEmptyMultiStatementsContext(p *MultiStatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_multiStatements
}

func (*MultiStatementsContext) IsMultiStatementsContext() {}

func NewMultiStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiStatementsContext {
	var p = new(MultiStatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_multiStatements

	return p
}

func (s *MultiStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiStatementsContext) EOF() antlr.TerminalNode {
	return s.GetToken(DorisParserEOF, 0)
}

func (s *MultiStatementsContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSEMICOLON)
}

func (s *MultiStatementsContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSEMICOLON, i)
}

func (s *MultiStatementsContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *MultiStatementsContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *MultiStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMultiStatements(s)
	}
}

func (s *MultiStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMultiStatements(s)
	}
}

func (p *DorisParser) MultiStatements() (localctx IMultiStatementsContext) {
	localctx = NewMultiStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, DorisParserRULE_multiStatements)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(451)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(448)
				p.Match(DorisParserSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(453)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4539628012066275324) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&234187180791038977) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&-9205357638294962175) != 0) || ((int64((_la-223)) & ^0x3f) == 0 && ((int64(1)<<(_la-223))&9070979317763) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&4706279374586904705) != 0) || ((int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&-9079256835876191711) != 0) || ((int64((_la-467)) & ^0x3f) == 0 && ((int64(1)<<(_la-467))&136315955) != 0) {
		{
			p.SetState(454)
			p.Statement()
		}

	}
	p.SetState(465)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(458)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == DorisParserSEMICOLON {
				{
					p.SetState(457)
					p.Match(DorisParserSEMICOLON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(460)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(462)
				p.Statement()
			}

		}
		p.SetState(467)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(471)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserSEMICOLON {
		{
			p.SetState(468)
			p.Match(DorisParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(473)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(474)
		p.Match(DorisParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleStatementContext is an interface to support dynamic dispatch.
type ISingleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	Statement() IStatementContext

	// IsSingleStatementContext differentiates from other interfaces.
	IsSingleStatementContext()
}

type SingleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleStatementContext() *SingleStatementContext {
	var p = new(SingleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_singleStatement
	return p
}

func InitEmptySingleStatementContext(p *SingleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_singleStatement
}

func (*SingleStatementContext) IsSingleStatementContext() {}

func NewSingleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleStatementContext {
	var p = new(SingleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_singleStatement

	return p
}

func (s *SingleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleStatementContext) EOF() antlr.TerminalNode {
	return s.GetToken(DorisParserEOF, 0)
}

func (s *SingleStatementContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSEMICOLON)
}

func (s *SingleStatementContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSEMICOLON, i)
}

func (s *SingleStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SingleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSingleStatement(s)
	}
}

func (s *SingleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSingleStatement(s)
	}
}

func (p *DorisParser) SingleStatement() (localctx ISingleStatementContext) {
	localctx = NewSingleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, DorisParserRULE_singleStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(479)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(476)
				p.Match(DorisParserSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(481)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(483)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4539628012066275324) != 0) || ((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&234187180791038977) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&-9205357638294962175) != 0) || ((int64((_la-223)) & ^0x3f) == 0 && ((int64(1)<<(_la-223))&9070979317763) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&4706279374586904705) != 0) || ((int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&-9079256835876191711) != 0) || ((int64((_la-467)) & ^0x3f) == 0 && ((int64(1)<<(_la-467))&136315955) != 0) {
		{
			p.SetState(482)
			p.Statement()
		}

	}
	p.SetState(488)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserSEMICOLON {
		{
			p.SetState(485)
			p.Match(DorisParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(490)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(491)
		p.Match(DorisParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) CopyAll(ctx *StatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowCreateProcedureContext struct {
	StatementContext
	name IMultipartIdentifierContext
}

func NewShowCreateProcedureContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateProcedureContext {
	var p = new(ShowCreateProcedureContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowCreateProcedureContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *ShowCreateProcedureContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *ShowCreateProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateProcedureContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCreateProcedureContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowCreateProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(DorisParserPROCEDURE, 0)
}

func (s *ShowCreateProcedureContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCreateProcedure(s)
	}
}

func (s *ShowCreateProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCreateProcedure(s)
	}
}

type StatementBaseAliasContext struct {
	StatementContext
}

func NewStatementBaseAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StatementBaseAliasContext {
	var p = new(StatementBaseAliasContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *StatementBaseAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementBaseAliasContext) StatementBase() IStatementBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementBaseContext)
}

func (s *StatementBaseAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStatementBaseAlias(s)
	}
}

func (s *StatementBaseAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStatementBaseAlias(s)
	}
}

type ShowProcedureStatusContext struct {
	StatementContext
	pattern IValueExpressionContext
}

func NewShowProcedureStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowProcedureStatusContext {
	var p = new(ShowProcedureStatusContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowProcedureStatusContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *ShowProcedureStatusContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *ShowProcedureStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProcedureStatusContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowProcedureStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATUS, 0)
}

func (s *ShowProcedureStatusContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(DorisParserPROCEDURE, 0)
}

func (s *ShowProcedureStatusContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserFUNCTION, 0)
}

func (s *ShowProcedureStatusContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *ShowProcedureStatusContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *ShowProcedureStatusContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ShowProcedureStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowProcedureStatus(s)
	}
}

func (s *ShowProcedureStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowProcedureStatus(s)
	}
}

type CreateProcedureContext struct {
	StatementContext
	name IMultipartIdentifierContext
}

func NewCreateProcedureContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateProcedureContext {
	var p = new(CreateProcedureContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateProcedureContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CreateProcedureContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CreateProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateProcedureContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CreateProcedureContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CreateProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(DorisParserPROCEDURE, 0)
}

func (s *CreateProcedureContext) PROC() antlr.TerminalNode {
	return s.GetToken(DorisParserPROC, 0)
}

func (s *CreateProcedureContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateProcedureContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *CreateProcedureContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateProcedureContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *CreateProcedureContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisParserOR, 0)
}

func (s *CreateProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateProcedure(s)
	}
}

func (s *CreateProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateProcedure(s)
	}
}

type ShowConfigContext struct {
	StatementContext
	type_     antlr.Token
	pattern   IValueExpressionContext
	backendId antlr.Token
}

func NewShowConfigContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowConfigContext {
	var p = new(ShowConfigContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowConfigContext) GetType_() antlr.Token { return s.type_ }

func (s *ShowConfigContext) GetBackendId() antlr.Token { return s.backendId }

func (s *ShowConfigContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *ShowConfigContext) SetBackendId(v antlr.Token) { s.backendId = v }

func (s *ShowConfigContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *ShowConfigContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *ShowConfigContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowConfigContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowConfigContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(DorisParserCONFIG, 0)
}

func (s *ShowConfigContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(DorisParserFRONTEND, 0)
}

func (s *ShowConfigContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKEND, 0)
}

func (s *ShowConfigContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *ShowConfigContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *ShowConfigContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowConfigContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ShowConfigContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ShowConfigContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowConfig(s)
	}
}

func (s *ShowConfigContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowConfig(s)
	}
}

type CallProcedureContext struct {
	StatementContext
	name IMultipartIdentifierContext
}

func NewCallProcedureContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CallProcedureContext {
	var p = new(CallProcedureContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CallProcedureContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CallProcedureContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CallProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallProcedureContext) CALL() antlr.TerminalNode {
	return s.GetToken(DorisParserCALL, 0)
}

func (s *CallProcedureContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CallProcedureContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CallProcedureContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CallProcedureContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CallProcedureContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CallProcedureContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *CallProcedureContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *CallProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCallProcedure(s)
	}
}

func (s *CallProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCallProcedure(s)
	}
}

type DropProcedureContext struct {
	StatementContext
	name IMultipartIdentifierContext
}

func NewDropProcedureContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropProcedureContext {
	var p = new(DropProcedureContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropProcedureContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *DropProcedureContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *DropProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropProcedureContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(DorisParserPROCEDURE, 0)
}

func (s *DropProcedureContext) PROC() antlr.TerminalNode {
	return s.GetToken(DorisParserPROC, 0)
}

func (s *DropProcedureContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropProcedureContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropProcedureContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropProcedure(s)
	}
}

func (s *DropProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropProcedure(s)
	}
}

func (p *DorisParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, DorisParserRULE_statement)
	var _la int

	var _alt int

	p.SetState(567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStatementBaseAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(493)
			p.StatementBase()
		}

	case 2:
		localctx = NewCallProcedureContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(494)
			p.Match(DorisParserCALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(495)

			var _x = p.MultipartIdentifier()

			localctx.(*CallProcedureContext).name = _x
		}
		{
			p.SetState(496)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(505)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8646890354245592708) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6341351709356361985) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-6232419426235955661) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&9126402704879377875) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-2873932114615608333) != 0) || ((int64((_la-322)) & ^0x3f) == 0 && ((int64(1)<<(_la-322))&-2310602210946850817) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&-2627780018309275847) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&-7818098869825860867) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&56383) != 0) {
			{
				p.SetState(497)
				p.Expression()
			}
			p.SetState(502)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(498)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(499)
					p.Expression()
				}

				p.SetState(504)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(507)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewCreateProcedureContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(516)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserALTER:
			{
				p.SetState(509)
				p.Match(DorisParserALTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCREATE:
			{
				p.SetState(510)
				p.Match(DorisParserCREATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(513)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserOR {
				{
					p.SetState(511)
					p.Match(DorisParserOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(512)
					p.Match(DorisParserREPLACE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		case DorisParserREPLACE:
			{
				p.SetState(515)
				p.Match(DorisParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(518)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserPROC || _la == DorisParserPROCEDURE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(519)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateProcedureContext).name = _x
		}
		{
			p.SetState(520)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(524)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				p.SetState(521)
				p.MatchWildcard()

			}
			p.SetState(526)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(527)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(531)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				p.SetState(528)
				p.MatchWildcard()

			}
			p.SetState(533)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 4:
		localctx = NewDropProcedureContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(534)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(535)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserPROC || _la == DorisParserPROCEDURE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(538)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(536)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(537)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(540)

			var _x = p.MultipartIdentifier()

			localctx.(*DropProcedureContext).name = _x
		}

	case 5:
		localctx = NewShowProcedureStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(541)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(542)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserFUNCTION || _la == DorisParserPROCEDURE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(543)
			p.Match(DorisParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(547)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case DorisParserLIKE:
			{
				p.SetState(544)
				p.Match(DorisParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(545)

				var _x = p.valueExpression(0)

				localctx.(*ShowProcedureStatusContext).pattern = _x
			}

		case DorisParserWHERE:
			{
				p.SetState(546)
				p.WhereClause()
			}

		case DorisParserEOF, DorisParserSEMICOLON:

		default:
		}

	case 6:
		localctx = NewShowCreateProcedureContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(549)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(550)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(551)
			p.Match(DorisParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(552)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateProcedureContext).name = _x
		}

	case 7:
		localctx = NewShowConfigContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		p.SetState(554)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserADMIN {
			{
				p.SetState(553)
				p.Match(DorisParserADMIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(556)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(557)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowConfigContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserBACKEND || _la == DorisParserFRONTEND) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowConfigContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(558)
			p.Match(DorisParserCONFIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(561)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE {
			{
				p.SetState(559)
				p.Match(DorisParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(560)

				var _x = p.valueExpression(0)

				localctx.(*ShowConfigContext).pattern = _x
			}

		}
		p.SetState(565)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(563)
				p.Match(DorisParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(564)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*ShowConfigContext).backendId = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementBaseContext is an interface to support dynamic dispatch.
type IStatementBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStatementBaseContext differentiates from other interfaces.
	IsStatementBaseContext()
}

type StatementBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementBaseContext() *StatementBaseContext {
	var p = new(StatementBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_statementBase
	return p
}

func InitEmptyStatementBaseContext(p *StatementBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_statementBase
}

func (*StatementBaseContext) IsStatementBaseContext() {}

func NewStatementBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementBaseContext {
	var p = new(StatementBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_statementBase

	return p
}

func (s *StatementBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementBaseContext) CopyAll(ctx *StatementBaseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StatementBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SupportedSetStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedSetStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedSetStatementAliasContext {
	var p = new(SupportedSetStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedSetStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedSetStatementAliasContext) SupportedSetStatement() ISupportedSetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedSetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedSetStatementContext)
}

func (s *SupportedSetStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedSetStatementAlias(s)
	}
}

func (s *SupportedSetStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedSetStatementAlias(s)
	}
}

type SupportedDmlStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedDmlStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedDmlStatementAliasContext {
	var p = new(SupportedDmlStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedDmlStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedDmlStatementAliasContext) SupportedDmlStatement() ISupportedDmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedDmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedDmlStatementContext)
}

func (s *SupportedDmlStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedDmlStatementAlias(s)
	}
}

func (s *SupportedDmlStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedDmlStatementAlias(s)
	}
}

type SupportedLoadStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedLoadStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedLoadStatementAliasContext {
	var p = new(SupportedLoadStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedLoadStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedLoadStatementAliasContext) SupportedLoadStatement() ISupportedLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedLoadStatementContext)
}

func (s *SupportedLoadStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedLoadStatementAlias(s)
	}
}

func (s *SupportedLoadStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedLoadStatementAlias(s)
	}
}

type ConstraintStatementAliasContext struct {
	StatementBaseContext
}

func NewConstraintStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstraintStatementAliasContext {
	var p = new(ConstraintStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *ConstraintStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintStatementAliasContext) ConstraintStatement() IConstraintStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintStatementContext)
}

func (s *ConstraintStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterConstraintStatementAlias(s)
	}
}

func (s *ConstraintStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitConstraintStatementAlias(s)
	}
}

type SupportedAlterStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedAlterStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedAlterStatementAliasContext {
	var p = new(SupportedAlterStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedAlterStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedAlterStatementAliasContext) SupportedAlterStatement() ISupportedAlterStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedAlterStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedAlterStatementContext)
}

func (s *SupportedAlterStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedAlterStatementAlias(s)
	}
}

func (s *SupportedAlterStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedAlterStatementAlias(s)
	}
}

type SupportedCleanStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedCleanStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedCleanStatementAliasContext {
	var p = new(SupportedCleanStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedCleanStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedCleanStatementAliasContext) SupportedCleanStatement() ISupportedCleanStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedCleanStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedCleanStatementContext)
}

func (s *SupportedCleanStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedCleanStatementAlias(s)
	}
}

func (s *SupportedCleanStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedCleanStatementAlias(s)
	}
}

type SupportedRecoverStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedRecoverStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedRecoverStatementAliasContext {
	var p = new(SupportedRecoverStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedRecoverStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedRecoverStatementAliasContext) SupportedRecoverStatement() ISupportedRecoverStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedRecoverStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedRecoverStatementContext)
}

func (s *SupportedRecoverStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedRecoverStatementAlias(s)
	}
}

func (s *SupportedRecoverStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedRecoverStatementAlias(s)
	}
}

type SupportedUnsetStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedUnsetStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedUnsetStatementAliasContext {
	var p = new(SupportedUnsetStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedUnsetStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedUnsetStatementAliasContext) SupportedUnsetStatement() ISupportedUnsetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedUnsetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedUnsetStatementContext)
}

func (s *SupportedUnsetStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedUnsetStatementAlias(s)
	}
}

func (s *SupportedUnsetStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedUnsetStatementAlias(s)
	}
}

type SupportedJobStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedJobStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedJobStatementAliasContext {
	var p = new(SupportedJobStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedJobStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedJobStatementAliasContext) SupportedJobStatement() ISupportedJobStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedJobStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedJobStatementContext)
}

func (s *SupportedJobStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedJobStatementAlias(s)
	}
}

func (s *SupportedJobStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedJobStatementAlias(s)
	}
}

type SupportedUseStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedUseStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedUseStatementAliasContext {
	var p = new(SupportedUseStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedUseStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedUseStatementAliasContext) SupportedUseStatement() ISupportedUseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedUseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedUseStatementContext)
}

func (s *SupportedUseStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedUseStatementAlias(s)
	}
}

func (s *SupportedUseStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedUseStatementAlias(s)
	}
}

type UnsupportedContext struct {
	StatementBaseContext
}

func NewUnsupportedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnsupportedContext {
	var p = new(UnsupportedContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *UnsupportedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedContext) UnsupportedStatement() IUnsupportedStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedStatementContext)
}

func (s *UnsupportedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUnsupported(s)
	}
}

func (s *UnsupportedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUnsupported(s)
	}
}

type MaterializedViewStatementAliasContext struct {
	StatementBaseContext
}

func NewMaterializedViewStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MaterializedViewStatementAliasContext {
	var p = new(MaterializedViewStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *MaterializedViewStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaterializedViewStatementAliasContext) MaterializedViewStatement() IMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaterializedViewStatementContext)
}

func (s *MaterializedViewStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMaterializedViewStatementAlias(s)
	}
}

func (s *MaterializedViewStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMaterializedViewStatementAlias(s)
	}
}

type StatementDefaultContext struct {
	StatementBaseContext
}

func NewStatementDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StatementDefaultContext {
	var p = new(StatementDefaultContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *StatementDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementDefaultContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *StatementDefaultContext) Explain() IExplainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainContext)
}

func (s *StatementDefaultContext) OutFileClause() IOutFileClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOutFileClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOutFileClauseContext)
}

func (s *StatementDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStatementDefault(s)
	}
}

func (s *StatementDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStatementDefault(s)
	}
}

type SupportedAdminStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedAdminStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedAdminStatementAliasContext {
	var p = new(SupportedAdminStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedAdminStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedAdminStatementAliasContext) SupportedAdminStatement() ISupportedAdminStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedAdminStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedAdminStatementContext)
}

func (s *SupportedAdminStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedAdminStatementAlias(s)
	}
}

func (s *SupportedAdminStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedAdminStatementAlias(s)
	}
}

type SupportedDropStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedDropStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedDropStatementAliasContext {
	var p = new(SupportedDropStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedDropStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedDropStatementAliasContext) SupportedDropStatement() ISupportedDropStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedDropStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedDropStatementContext)
}

func (s *SupportedDropStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedDropStatementAlias(s)
	}
}

func (s *SupportedDropStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedDropStatementAlias(s)
	}
}

type SupportedCancelStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedCancelStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedCancelStatementAliasContext {
	var p = new(SupportedCancelStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedCancelStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedCancelStatementAliasContext) SupportedCancelStatement() ISupportedCancelStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedCancelStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedCancelStatementContext)
}

func (s *SupportedCancelStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedCancelStatementAlias(s)
	}
}

func (s *SupportedCancelStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedCancelStatementAlias(s)
	}
}

type SupportedOtherStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedOtherStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedOtherStatementAliasContext {
	var p = new(SupportedOtherStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedOtherStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedOtherStatementAliasContext) SupportedOtherStatement() ISupportedOtherStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedOtherStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedOtherStatementContext)
}

func (s *SupportedOtherStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedOtherStatementAlias(s)
	}
}

func (s *SupportedOtherStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedOtherStatementAlias(s)
	}
}

type SupportedCreateStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedCreateStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedCreateStatementAliasContext {
	var p = new(SupportedCreateStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedCreateStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedCreateStatementAliasContext) SupportedCreateStatement() ISupportedCreateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedCreateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedCreateStatementContext)
}

func (s *SupportedCreateStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedCreateStatementAlias(s)
	}
}

func (s *SupportedCreateStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedCreateStatementAlias(s)
	}
}

type SupportedShowStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedShowStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedShowStatementAliasContext {
	var p = new(SupportedShowStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedShowStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedShowStatementAliasContext) SupportedShowStatement() ISupportedShowStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedShowStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedShowStatementContext)
}

func (s *SupportedShowStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedShowStatementAlias(s)
	}
}

func (s *SupportedShowStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedShowStatementAlias(s)
	}
}

type SupportedRefreshStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedRefreshStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedRefreshStatementAliasContext {
	var p = new(SupportedRefreshStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedRefreshStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedRefreshStatementAliasContext) SupportedRefreshStatement() ISupportedRefreshStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedRefreshStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedRefreshStatementContext)
}

func (s *SupportedRefreshStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedRefreshStatementAlias(s)
	}
}

func (s *SupportedRefreshStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedRefreshStatementAlias(s)
	}
}

func (p *DorisParser) StatementBase() (localctx IStatementBaseContext) {
	localctx = NewStatementBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, DorisParserRULE_statementBase)
	var _la int

	p.SetState(595)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStatementDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(570)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&274877906947) != 0 {
			{
				p.SetState(569)
				p.Explain()
			}

		}
		{
			p.SetState(572)
			p.Query()
		}
		p.SetState(574)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserINTO {
			{
				p.SetState(573)
				p.OutFileClause()
			}

		}

	case 2:
		localctx = NewSupportedDmlStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(576)
			p.SupportedDmlStatement()
		}

	case 3:
		localctx = NewSupportedCreateStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(577)
			p.SupportedCreateStatement()
		}

	case 4:
		localctx = NewSupportedAlterStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(578)
			p.SupportedAlterStatement()
		}

	case 5:
		localctx = NewMaterializedViewStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(579)
			p.MaterializedViewStatement()
		}

	case 6:
		localctx = NewSupportedJobStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(580)
			p.SupportedJobStatement()
		}

	case 7:
		localctx = NewConstraintStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(581)
			p.ConstraintStatement()
		}

	case 8:
		localctx = NewSupportedCleanStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(582)
			p.SupportedCleanStatement()
		}

	case 9:
		localctx = NewSupportedDropStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(583)
			p.SupportedDropStatement()
		}

	case 10:
		localctx = NewSupportedSetStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(584)
			p.SupportedSetStatement()
		}

	case 11:
		localctx = NewSupportedUnsetStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(585)
			p.SupportedUnsetStatement()
		}

	case 12:
		localctx = NewSupportedRefreshStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(586)
			p.SupportedRefreshStatement()
		}

	case 13:
		localctx = NewSupportedShowStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(587)
			p.SupportedShowStatement()
		}

	case 14:
		localctx = NewSupportedLoadStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(588)
			p.SupportedLoadStatement()
		}

	case 15:
		localctx = NewSupportedCancelStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(589)
			p.SupportedCancelStatement()
		}

	case 16:
		localctx = NewSupportedRecoverStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(590)
			p.SupportedRecoverStatement()
		}

	case 17:
		localctx = NewSupportedAdminStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(591)
			p.SupportedAdminStatement()
		}

	case 18:
		localctx = NewSupportedUseStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(592)
			p.SupportedUseStatement()
		}

	case 19:
		localctx = NewSupportedOtherStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(593)
			p.SupportedOtherStatement()
		}

	case 20:
		localctx = NewUnsupportedContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(594)
			p.UnsupportedStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedStatementContext is an interface to support dynamic dispatch.
type IUnsupportedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsupportedUseStatement() IUnsupportedUseStatementContext
	UnsupportedDmlStatement() IUnsupportedDmlStatementContext
	UnsupportedKillStatement() IUnsupportedKillStatementContext
	UnsupportedDescribeStatement() IUnsupportedDescribeStatementContext
	UnsupportedCreateStatement() IUnsupportedCreateStatementContext
	UnsupportedDropStatement() IUnsupportedDropStatementContext
	UnsupportedStatsStatement() IUnsupportedStatsStatementContext
	UnsupportedAlterStatement() IUnsupportedAlterStatementContext
	UnsupportedGrantRevokeStatement() IUnsupportedGrantRevokeStatementContext
	UnsupportedAdminStatement() IUnsupportedAdminStatementContext
	UnsupportedTransactionStatement() IUnsupportedTransactionStatementContext
	UnsupportedCancelStatement() IUnsupportedCancelStatementContext
	UnsupportedCleanStatement() IUnsupportedCleanStatementContext
	UnsupportedRefreshStatement() IUnsupportedRefreshStatementContext
	UnsupportedLoadStatement() IUnsupportedLoadStatementContext
	UnsupportedShowStatement() IUnsupportedShowStatementContext
	UnsupportedOtherStatement() IUnsupportedOtherStatementContext

	// IsUnsupportedStatementContext differentiates from other interfaces.
	IsUnsupportedStatementContext()
}

type UnsupportedStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedStatementContext() *UnsupportedStatementContext {
	var p = new(UnsupportedStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedStatement
	return p
}

func InitEmptyUnsupportedStatementContext(p *UnsupportedStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedStatement
}

func (*UnsupportedStatementContext) IsUnsupportedStatementContext() {}

func NewUnsupportedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedStatementContext {
	var p = new(UnsupportedStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedStatement

	return p
}

func (s *UnsupportedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedStatementContext) UnsupportedUseStatement() IUnsupportedUseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedUseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedUseStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedDmlStatement() IUnsupportedDmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedDmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedDmlStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedKillStatement() IUnsupportedKillStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedKillStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedKillStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedDescribeStatement() IUnsupportedDescribeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedDescribeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedDescribeStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedCreateStatement() IUnsupportedCreateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedCreateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedCreateStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedDropStatement() IUnsupportedDropStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedDropStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedDropStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedStatsStatement() IUnsupportedStatsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedStatsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedStatsStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedAlterStatement() IUnsupportedAlterStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedAlterStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedAlterStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedGrantRevokeStatement() IUnsupportedGrantRevokeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedGrantRevokeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedGrantRevokeStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedAdminStatement() IUnsupportedAdminStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedAdminStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedAdminStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedTransactionStatement() IUnsupportedTransactionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedTransactionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedTransactionStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedCancelStatement() IUnsupportedCancelStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedCancelStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedCancelStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedCleanStatement() IUnsupportedCleanStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedCleanStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedCleanStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedRefreshStatement() IUnsupportedRefreshStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedRefreshStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedRefreshStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedLoadStatement() IUnsupportedLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedLoadStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedShowStatement() IUnsupportedShowStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedShowStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedShowStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedOtherStatement() IUnsupportedOtherStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedOtherStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedOtherStatementContext)
}

func (s *UnsupportedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsupportedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUnsupportedStatement(s)
	}
}

func (s *UnsupportedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUnsupportedStatement(s)
	}
}

func (p *DorisParser) UnsupportedStatement() (localctx IUnsupportedStatementContext) {
	localctx = NewUnsupportedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, DorisParserRULE_unsupportedStatement)
	p.SetState(614)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(597)
			p.UnsupportedUseStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(598)
			p.UnsupportedDmlStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(599)
			p.UnsupportedKillStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(600)
			p.UnsupportedDescribeStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(601)
			p.UnsupportedCreateStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(602)
			p.UnsupportedDropStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(603)
			p.UnsupportedStatsStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(604)
			p.UnsupportedAlterStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(605)
			p.UnsupportedGrantRevokeStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(606)
			p.UnsupportedAdminStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(607)
			p.UnsupportedTransactionStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(608)
			p.UnsupportedCancelStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(609)
			p.UnsupportedCleanStatement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(610)
			p.UnsupportedRefreshStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(611)
			p.UnsupportedLoadStatement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(612)
			p.UnsupportedShowStatement()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(613)
			p.UnsupportedOtherStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaterializedViewStatementContext is an interface to support dynamic dispatch.
type IMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsMaterializedViewStatementContext differentiates from other interfaces.
	IsMaterializedViewStatementContext()
}

type MaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaterializedViewStatementContext() *MaterializedViewStatementContext {
	var p = new(MaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_materializedViewStatement
	return p
}

func InitEmptyMaterializedViewStatementContext(p *MaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_materializedViewStatement
}

func (*MaterializedViewStatementContext) IsMaterializedViewStatementContext() {}

func NewMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaterializedViewStatementContext {
	var p = new(MaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_materializedViewStatement

	return p
}

func (s *MaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MaterializedViewStatementContext) CopyAll(ctx *MaterializedViewStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *MaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RefreshMTMVContext struct {
	MaterializedViewStatementContext
	mvName IMultipartIdentifierContext
}

func NewRefreshMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RefreshMTMVContext {
	var p = new(RefreshMTMVContext)

	InitEmptyMaterializedViewStatementContext(&p.MaterializedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterializedViewStatementContext))

	return p
}

func (s *RefreshMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *RefreshMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *RefreshMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshMTMVContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserREFRESH, 0)
}

func (s *RefreshMTMVContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *RefreshMTMVContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *RefreshMTMVContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *RefreshMTMVContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *RefreshMTMVContext) COMPLETE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPLETE, 0)
}

func (s *RefreshMTMVContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO, 0)
}

func (s *RefreshMTMVContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRefreshMTMV(s)
	}
}

func (s *RefreshMTMVContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRefreshMTMV(s)
	}
}

type AlterMTMVContext struct {
	MaterializedViewStatementContext
	mvName         IMultipartIdentifierContext
	newName        IIdentifierContext
	fileProperties IPropertyItemListContext
}

func NewAlterMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterMTMVContext {
	var p = new(AlterMTMVContext)

	InitEmptyMaterializedViewStatementContext(&p.MaterializedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterializedViewStatementContext))

	return p
}

func (s *AlterMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *AlterMTMVContext) GetNewName() IIdentifierContext { return s.newName }

func (s *AlterMTMVContext) GetFileProperties() IPropertyItemListContext { return s.fileProperties }

func (s *AlterMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *AlterMTMVContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *AlterMTMVContext) SetFileProperties(v IPropertyItemListContext) { s.fileProperties = v }

func (s *AlterMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterMTMVContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterMTMVContext) AllMATERIALIZED() []antlr.TerminalNode {
	return s.GetTokens(DorisParserMATERIALIZED)
}

func (s *AlterMTMVContext) MATERIALIZED(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, i)
}

func (s *AlterMTMVContext) AllVIEW() []antlr.TerminalNode {
	return s.GetTokens(DorisParserVIEW)
}

func (s *AlterMTMVContext) VIEW(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, i)
}

func (s *AlterMTMVContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterMTMVContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *AlterMTMVContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *AlterMTMVContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterMTMVContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserRENAME, 0)
}

func (s *AlterMTMVContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserREFRESH, 0)
}

func (s *AlterMTMVContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterMTMVContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterMTMVContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterMTMVContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterMTMVContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterMTMVContext) RefreshMethod() IRefreshMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshMethodContext)
}

func (s *AlterMTMVContext) RefreshTrigger() IRefreshTriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshTriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshTriggerContext)
}

func (s *AlterMTMVContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterMTMV(s)
	}
}

func (s *AlterMTMVContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterMTMV(s)
	}
}

type CreateMTMVContext struct {
	MaterializedViewStatementContext
	mvName   IMultipartIdentifierContext
	cols     ISimpleColumnDefsContext
	keys     IIdentifierListContext
	hashKeys IIdentifierListContext
}

func NewCreateMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateMTMVContext {
	var p = new(CreateMTMVContext)

	InitEmptyMaterializedViewStatementContext(&p.MaterializedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterializedViewStatementContext))

	return p
}

func (s *CreateMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *CreateMTMVContext) GetCols() ISimpleColumnDefsContext { return s.cols }

func (s *CreateMTMVContext) GetKeys() IIdentifierListContext { return s.keys }

func (s *CreateMTMVContext) GetHashKeys() IIdentifierListContext { return s.hashKeys }

func (s *CreateMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *CreateMTMVContext) SetCols(v ISimpleColumnDefsContext) { s.cols = v }

func (s *CreateMTMVContext) SetKeys(v IIdentifierListContext) { s.keys = v }

func (s *CreateMTMVContext) SetHashKeys(v IIdentifierListContext) { s.hashKeys = v }

func (s *CreateMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateMTMVContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateMTMVContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *CreateMTMVContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *CreateMTMVContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *CreateMTMVContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateMTMVContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateMTMVContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateMTMVContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateMTMVContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateMTMVContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserLEFT_PAREN)
}

func (s *CreateMTMVContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, i)
}

func (s *CreateMTMVContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserRIGHT_PAREN)
}

func (s *CreateMTMVContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, i)
}

func (s *CreateMTMVContext) BuildMode() IBuildModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBuildModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBuildModeContext)
}

func (s *CreateMTMVContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserREFRESH, 0)
}

func (s *CreateMTMVContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserKEY, 0)
}

func (s *CreateMTMVContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *CreateMTMVContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateMTMVContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *CreateMTMVContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(DorisParserBY)
}

func (s *CreateMTMVContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserBY, i)
}

func (s *CreateMTMVContext) MvPartition() IMvPartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMvPartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMvPartitionContext)
}

func (s *CreateMTMVContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTRIBUTED, 0)
}

func (s *CreateMTMVContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateMTMVContext) SimpleColumnDefs() ISimpleColumnDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleColumnDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleColumnDefsContext)
}

func (s *CreateMTMVContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *CreateMTMVContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateMTMVContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisParserHASH, 0)
}

func (s *CreateMTMVContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(DorisParserRANDOM, 0)
}

func (s *CreateMTMVContext) RefreshMethod() IRefreshMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshMethodContext)
}

func (s *CreateMTMVContext) RefreshTrigger() IRefreshTriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshTriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshTriggerContext)
}

func (s *CreateMTMVContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(DorisParserDUPLICATE, 0)
}

func (s *CreateMTMVContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisParserBUCKETS, 0)
}

func (s *CreateMTMVContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *CreateMTMVContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO, 0)
}

func (s *CreateMTMVContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateMTMV(s)
	}
}

func (s *CreateMTMVContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateMTMV(s)
	}
}

type ResumeMTMVContext struct {
	MaterializedViewStatementContext
	mvName IMultipartIdentifierContext
}

func NewResumeMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ResumeMTMVContext {
	var p = new(ResumeMTMVContext)

	InitEmptyMaterializedViewStatementContext(&p.MaterializedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterializedViewStatementContext))

	return p
}

func (s *ResumeMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *ResumeMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *ResumeMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumeMTMVContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisParserRESUME, 0)
}

func (s *ResumeMTMVContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *ResumeMTMVContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *ResumeMTMVContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *ResumeMTMVContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *ResumeMTMVContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ResumeMTMVContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterResumeMTMV(s)
	}
}

func (s *ResumeMTMVContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitResumeMTMV(s)
	}
}

type ShowCreateMTMVContext struct {
	MaterializedViewStatementContext
	mvName IMultipartIdentifierContext
}

func NewShowCreateMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateMTMVContext {
	var p = new(ShowCreateMTMVContext)

	InitEmptyMaterializedViewStatementContext(&p.MaterializedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterializedViewStatementContext))

	return p
}

func (s *ShowCreateMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *ShowCreateMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *ShowCreateMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateMTMVContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCreateMTMVContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowCreateMTMVContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *ShowCreateMTMVContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *ShowCreateMTMVContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateMTMVContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCreateMTMV(s)
	}
}

func (s *ShowCreateMTMVContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCreateMTMV(s)
	}
}

type CancelMTMVTaskContext struct {
	MaterializedViewStatementContext
	taskId antlr.Token
	mvName IMultipartIdentifierContext
}

func NewCancelMTMVTaskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelMTMVTaskContext {
	var p = new(CancelMTMVTaskContext)

	InitEmptyMaterializedViewStatementContext(&p.MaterializedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterializedViewStatementContext))

	return p
}

func (s *CancelMTMVTaskContext) GetTaskId() antlr.Token { return s.taskId }

func (s *CancelMTMVTaskContext) SetTaskId(v antlr.Token) { s.taskId = v }

func (s *CancelMTMVTaskContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *CancelMTMVTaskContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *CancelMTMVTaskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelMTMVTaskContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *CancelMTMVTaskContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *CancelMTMVTaskContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *CancelMTMVTaskContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisParserTASK, 0)
}

func (s *CancelMTMVTaskContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *CancelMTMVTaskContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *CancelMTMVTaskContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CancelMTMVTaskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCancelMTMVTask(s)
	}
}

func (s *CancelMTMVTaskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCancelMTMVTask(s)
	}
}

type PauseMTMVContext struct {
	MaterializedViewStatementContext
	mvName IMultipartIdentifierContext
}

func NewPauseMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PauseMTMVContext {
	var p = new(PauseMTMVContext)

	InitEmptyMaterializedViewStatementContext(&p.MaterializedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterializedViewStatementContext))

	return p
}

func (s *PauseMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *PauseMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *PauseMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PauseMTMVContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserPAUSE, 0)
}

func (s *PauseMTMVContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *PauseMTMVContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *PauseMTMVContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *PauseMTMVContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *PauseMTMVContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *PauseMTMVContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPauseMTMV(s)
	}
}

func (s *PauseMTMVContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPauseMTMV(s)
	}
}

type DropMTMVContext struct {
	MaterializedViewStatementContext
	mvName    IMultipartIdentifierContext
	tableName IMultipartIdentifierContext
}

func NewDropMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropMTMVContext {
	var p = new(DropMTMVContext)

	InitEmptyMaterializedViewStatementContext(&p.MaterializedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterializedViewStatementContext))

	return p
}

func (s *DropMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *DropMTMVContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DropMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *DropMTMVContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DropMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropMTMVContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropMTMVContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *DropMTMVContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *DropMTMVContext) AllMultipartIdentifier() []IMultipartIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultipartIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipartIdentifierContext); ok {
			tst[i] = t.(IMultipartIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DropMTMVContext) MultipartIdentifier(i int) IMultipartIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropMTMVContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropMTMVContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropMTMVContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *DropMTMVContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropMTMV(s)
	}
}

func (s *DropMTMVContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropMTMV(s)
	}
}

func (p *DorisParser) MaterializedViewStatement() (localctx IMaterializedViewStatementContext) {
	localctx = NewMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, DorisParserRULE_materializedViewStatement)
	var _la int

	p.SetState(755)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserCREATE:
		localctx = NewCreateMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(616)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(617)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(618)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(622)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(619)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(620)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(621)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(624)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateMTMVContext).mvName = _x
		}
		p.SetState(629)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(625)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(626)

				var _x = p.SimpleColumnDefs()

				localctx.(*CreateMTMVContext).cols = _x
			}
			{
				p.SetState(627)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(632)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserBUILD {
			{
				p.SetState(631)
				p.BuildMode()
			}

		}
		p.SetState(641)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserREFRESH {
			{
				p.SetState(634)
				p.Match(DorisParserREFRESH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(636)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserAUTO || _la == DorisParserCOMPLETE {
				{
					p.SetState(635)
					p.RefreshMethod()
				}

			}
			p.SetState(639)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserON {
				{
					p.SetState(638)
					p.RefreshTrigger()
				}

			}

		}
		p.SetState(648)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserDUPLICATE || _la == DorisParserKEY {
			p.SetState(644)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserDUPLICATE {
				{
					p.SetState(643)
					p.Match(DorisParserDUPLICATE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(646)
				p.Match(DorisParserKEY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(647)

				var _x = p.IdentifierList()

				localctx.(*CreateMTMVContext).keys = _x
			}

		}
		p.SetState(652)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(650)
				p.Match(DorisParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(651)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(660)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION {
			{
				p.SetState(654)
				p.Match(DorisParserPARTITION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(655)
				p.Match(DorisParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(656)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(657)
				p.MvPartition()
			}
			{
				p.SetState(658)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(673)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserDISTRIBUTED {
			{
				p.SetState(662)
				p.Match(DorisParserDISTRIBUTED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(663)
				p.Match(DorisParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(667)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserHASH:
				{
					p.SetState(664)
					p.Match(DorisParserHASH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(665)

					var _x = p.IdentifierList()

					localctx.(*CreateMTMVContext).hashKeys = _x
				}

			case DorisParserRANDOM:
				{
					p.SetState(666)
					p.Match(DorisParserRANDOM)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			p.SetState(671)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserBUCKETS {
				{
					p.SetState(669)
					p.Match(DorisParserBUCKETS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(670)
					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisParserAUTO || _la == DorisParserINTEGER_VALUE) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}

		}
		p.SetState(676)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(675)
				p.PropertyClause()
			}

		}
		{
			p.SetState(678)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(679)
			p.Query()
		}

	case DorisParserREFRESH:
		localctx = NewRefreshMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(681)
			p.Match(DorisParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(682)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(683)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(684)

			var _x = p.MultipartIdentifier()

			localctx.(*RefreshMTMVContext).mvName = _x
		}
		p.SetState(688)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserPARTITION, DorisParserPARTITIONS, DorisParserTEMPORARY:
			{
				p.SetState(685)
				p.PartitionSpec()
			}

		case DorisParserCOMPLETE:
			{
				p.SetState(686)
				p.Match(DorisParserCOMPLETE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserAUTO:
			{
				p.SetState(687)
				p.Match(DorisParserAUTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case DorisParserALTER:
		localctx = NewAlterMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(690)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(691)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(692)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(693)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterMTMVContext).mvName = _x
		}
		p.SetState(717)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserRENAME:
			{
				p.SetState(694)
				p.Match(DorisParserRENAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(695)

				var _x = p.Identifier()

				localctx.(*AlterMTMVContext).newName = _x
			}

		case DorisParserREFRESH:
			{
				p.SetState(696)
				p.Match(DorisParserREFRESH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(702)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(697)
					p.RefreshMethod()
				}

			case 2:
				{
					p.SetState(698)
					p.RefreshTrigger()
				}

			case 3:
				{
					p.SetState(699)
					p.RefreshMethod()
				}
				{
					p.SetState(700)
					p.RefreshTrigger()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		case DorisParserREPLACE:
			{
				p.SetState(704)
				p.Match(DorisParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(705)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(706)
				p.Match(DorisParserMATERIALIZED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(707)
				p.Match(DorisParserVIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(708)

				var _x = p.Identifier()

				localctx.(*AlterMTMVContext).newName = _x
			}
			p.SetState(710)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserPROPERTIES {
				{
					p.SetState(709)
					p.PropertyClause()
				}

			}

		case DorisParserSET:
			{
				p.SetState(712)
				p.Match(DorisParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(713)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(714)

				var _x = p.PropertyItemList()

				localctx.(*AlterMTMVContext).fileProperties = _x
			}
			{
				p.SetState(715)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case DorisParserDROP:
		localctx = NewDropMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(719)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(720)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(721)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(724)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(722)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(723)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(726)

			var _x = p.MultipartIdentifier()

			localctx.(*DropMTMVContext).mvName = _x
		}
		p.SetState(729)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserON {
			{
				p.SetState(727)
				p.Match(DorisParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(728)

				var _x = p.MultipartIdentifier()

				localctx.(*DropMTMVContext).tableName = _x
			}

		}

	case DorisParserPAUSE:
		localctx = NewPauseMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(731)
			p.Match(DorisParserPAUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(732)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(733)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(734)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(735)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(736)

			var _x = p.MultipartIdentifier()

			localctx.(*PauseMTMVContext).mvName = _x
		}

	case DorisParserRESUME:
		localctx = NewResumeMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(737)
			p.Match(DorisParserRESUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(738)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(739)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(740)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(741)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(742)

			var _x = p.MultipartIdentifier()

			localctx.(*ResumeMTMVContext).mvName = _x
		}

	case DorisParserCANCEL:
		localctx = NewCancelMTMVTaskContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(743)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(744)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(745)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(746)
			p.Match(DorisParserTASK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(747)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*CancelMTMVTaskContext).taskId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(748)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(749)

			var _x = p.MultipartIdentifier()

			localctx.(*CancelMTMVTaskContext).mvName = _x
		}

	case DorisParserSHOW:
		localctx = NewShowCreateMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(750)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(751)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(752)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(753)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(754)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateMTMVContext).mvName = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedJobStatementContext is an interface to support dynamic dispatch.
type ISupportedJobStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedJobStatementContext differentiates from other interfaces.
	IsSupportedJobStatementContext()
}

type SupportedJobStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedJobStatementContext() *SupportedJobStatementContext {
	var p = new(SupportedJobStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedJobStatement
	return p
}

func InitEmptySupportedJobStatementContext(p *SupportedJobStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedJobStatement
}

func (*SupportedJobStatementContext) IsSupportedJobStatementContext() {}

func NewSupportedJobStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedJobStatementContext {
	var p = new(SupportedJobStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedJobStatement

	return p
}

func (s *SupportedJobStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedJobStatementContext) CopyAll(ctx *SupportedJobStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedJobStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedJobStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CancelJobTaskContext struct {
	SupportedJobStatementContext
}

func NewCancelJobTaskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelJobTaskContext {
	var p = new(CancelJobTaskContext)

	InitEmptySupportedJobStatementContext(&p.SupportedJobStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedJobStatementContext))

	return p
}

func (s *CancelJobTaskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelJobTaskContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *CancelJobTaskContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisParserTASK, 0)
}

func (s *CancelJobTaskContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *CancelJobTaskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCancelJobTask(s)
	}
}

func (s *CancelJobTaskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCancelJobTask(s)
	}
}

type ResumeJobContext struct {
	SupportedJobStatementContext
}

func NewResumeJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ResumeJobContext {
	var p = new(ResumeJobContext)

	InitEmptySupportedJobStatementContext(&p.SupportedJobStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedJobStatementContext))

	return p
}

func (s *ResumeJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumeJobContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisParserRESUME, 0)
}

func (s *ResumeJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *ResumeJobContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ResumeJobContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterResumeJob(s)
	}
}

func (s *ResumeJobContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitResumeJob(s)
	}
}

type DropJobContext struct {
	SupportedJobStatementContext
}

func NewDropJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropJobContext {
	var p = new(DropJobContext)

	InitEmptySupportedJobStatementContext(&p.SupportedJobStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedJobStatementContext))

	return p
}

func (s *DropJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropJobContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *DropJobContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropJobContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropJobContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *DropJobContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropJob(s)
	}
}

func (s *DropJobContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropJob(s)
	}
}

type CreateScheduledJobContext struct {
	SupportedJobStatementContext
	label        IMultipartIdentifierContext
	timeInterval antlr.Token
	timeUnit     IIdentifierContext
	startTime    antlr.Token
	endsTime     antlr.Token
	atTime       antlr.Token
}

func NewCreateScheduledJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateScheduledJobContext {
	var p = new(CreateScheduledJobContext)

	InitEmptySupportedJobStatementContext(&p.SupportedJobStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedJobStatementContext))

	return p
}

func (s *CreateScheduledJobContext) GetTimeInterval() antlr.Token { return s.timeInterval }

func (s *CreateScheduledJobContext) GetStartTime() antlr.Token { return s.startTime }

func (s *CreateScheduledJobContext) GetEndsTime() antlr.Token { return s.endsTime }

func (s *CreateScheduledJobContext) GetAtTime() antlr.Token { return s.atTime }

func (s *CreateScheduledJobContext) SetTimeInterval(v antlr.Token) { s.timeInterval = v }

func (s *CreateScheduledJobContext) SetStartTime(v antlr.Token) { s.startTime = v }

func (s *CreateScheduledJobContext) SetEndsTime(v antlr.Token) { s.endsTime = v }

func (s *CreateScheduledJobContext) SetAtTime(v antlr.Token) { s.atTime = v }

func (s *CreateScheduledJobContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *CreateScheduledJobContext) GetTimeUnit() IIdentifierContext { return s.timeUnit }

func (s *CreateScheduledJobContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *CreateScheduledJobContext) SetTimeUnit(v IIdentifierContext) { s.timeUnit = v }

func (s *CreateScheduledJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateScheduledJobContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateScheduledJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *CreateScheduledJobContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *CreateScheduledJobContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEDULE, 0)
}

func (s *CreateScheduledJobContext) DO() antlr.TerminalNode {
	return s.GetToken(DorisParserDO, 0)
}

func (s *CreateScheduledJobContext) SupportedDmlStatement() ISupportedDmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedDmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedDmlStatementContext)
}

func (s *CreateScheduledJobContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateScheduledJobContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *CreateScheduledJobContext) EVERY() antlr.TerminalNode {
	return s.GetToken(DorisParserEVERY, 0)
}

func (s *CreateScheduledJobContext) AT() antlr.TerminalNode {
	return s.GetToken(DorisParserAT, 0)
}

func (s *CreateScheduledJobContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *CreateScheduledJobContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateScheduledJobContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_TIMESTAMP, 0)
}

func (s *CreateScheduledJobContext) STARTS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTARTS, 0)
}

func (s *CreateScheduledJobContext) ENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserENDS, 0)
}

func (s *CreateScheduledJobContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *CreateScheduledJobContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *CreateScheduledJobContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateScheduledJob(s)
	}
}

func (s *CreateScheduledJobContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateScheduledJob(s)
	}
}

type PauseJobContext struct {
	SupportedJobStatementContext
}

func NewPauseJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PauseJobContext {
	var p = new(PauseJobContext)

	InitEmptySupportedJobStatementContext(&p.SupportedJobStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedJobStatementContext))

	return p
}

func (s *PauseJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PauseJobContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserPAUSE, 0)
}

func (s *PauseJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *PauseJobContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *PauseJobContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPauseJob(s)
	}
}

func (s *PauseJobContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPauseJob(s)
	}
}

func (p *DorisParser) SupportedJobStatement() (localctx ISupportedJobStatementContext) {
	localctx = NewSupportedJobStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, DorisParserRULE_supportedJobStatement)
	var _la int

	p.SetState(813)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserCREATE:
		localctx = NewCreateScheduledJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(757)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(758)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(759)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateScheduledJobContext).label = _x
		}
		{
			p.SetState(760)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(761)
			p.Match(DorisParserSCHEDULE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(781)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserEVERY:
			{
				p.SetState(762)
				p.Match(DorisParserEVERY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(763)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*CreateScheduledJobContext).timeInterval = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(764)

				var _x = p.Identifier()

				localctx.(*CreateScheduledJobContext).timeUnit = _x
			}
			p.SetState(770)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserSTARTS {
				{
					p.SetState(765)
					p.Match(DorisParserSTARTS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(768)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DorisParserSTRING_LITERAL:
					{
						p.SetState(766)

						var _m = p.Match(DorisParserSTRING_LITERAL)

						localctx.(*CreateScheduledJobContext).startTime = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case DorisParserCURRENT_TIMESTAMP:
					{
						p.SetState(767)
						p.Match(DorisParserCURRENT_TIMESTAMP)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			}
			p.SetState(774)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserENDS {
				{
					p.SetState(772)
					p.Match(DorisParserENDS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(773)

					var _m = p.Match(DorisParserSTRING_LITERAL)

					localctx.(*CreateScheduledJobContext).endsTime = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		case DorisParserAT:
			{
				p.SetState(776)
				p.Match(DorisParserAT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(779)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserSTRING_LITERAL:
				{
					p.SetState(777)

					var _m = p.Match(DorisParserSTRING_LITERAL)

					localctx.(*CreateScheduledJobContext).atTime = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case DorisParserCURRENT_TIMESTAMP:
				{
					p.SetState(778)
					p.Match(DorisParserCURRENT_TIMESTAMP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(784)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(783)
				p.CommentSpec()
			}

		}
		{
			p.SetState(786)
			p.Match(DorisParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(787)
			p.SupportedDmlStatement()
		}

	case DorisParserPAUSE:
		localctx = NewPauseJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(789)
			p.Match(DorisParserPAUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(790)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(792)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(791)
				p.WildWhere()
			}

		}

	case DorisParserDROP:
		localctx = NewDropJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(794)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(795)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(798)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(796)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(797)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(801)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(800)
				p.WildWhere()
			}

		}

	case DorisParserRESUME:
		localctx = NewResumeJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(803)
			p.Match(DorisParserRESUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(804)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(806)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(805)
				p.WildWhere()
			}

		}

	case DorisParserCANCEL:
		localctx = NewCancelJobTaskContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(808)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(809)
			p.Match(DorisParserTASK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(811)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(810)
				p.WildWhere()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstraintStatementContext is an interface to support dynamic dispatch.
type IConstraintStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsConstraintStatementContext differentiates from other interfaces.
	IsConstraintStatementContext()
}

type ConstraintStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintStatementContext() *ConstraintStatementContext {
	var p = new(ConstraintStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_constraintStatement
	return p
}

func InitEmptyConstraintStatementContext(p *ConstraintStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_constraintStatement
}

func (*ConstraintStatementContext) IsConstraintStatementContext() {}

func NewConstraintStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintStatementContext {
	var p = new(ConstraintStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_constraintStatement

	return p
}

func (s *ConstraintStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintStatementContext) CopyAll(ctx *ConstraintStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ConstraintStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowConstraintContext struct {
	ConstraintStatementContext
	table IMultipartIdentifierContext
}

func NewShowConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowConstraintContext {
	var p = new(ShowConstraintContext)

	InitEmptyConstraintStatementContext(&p.ConstraintStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstraintStatementContext))

	return p
}

func (s *ShowConstraintContext) GetTable() IMultipartIdentifierContext { return s.table }

func (s *ShowConstraintContext) SetTable(v IMultipartIdentifierContext) { s.table = v }

func (s *ShowConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowConstraintContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowConstraintContext) CONSTRAINTS() antlr.TerminalNode {
	return s.GetToken(DorisParserCONSTRAINTS, 0)
}

func (s *ShowConstraintContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowConstraintContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowConstraint(s)
	}
}

func (s *ShowConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowConstraint(s)
	}
}

type DropConstraintContext struct {
	ConstraintStatementContext
	table          IMultipartIdentifierContext
	constraintName IErrorCapturingIdentifierContext
}

func NewDropConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropConstraintContext {
	var p = new(DropConstraintContext)

	InitEmptyConstraintStatementContext(&p.ConstraintStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstraintStatementContext))

	return p
}

func (s *DropConstraintContext) GetTable() IMultipartIdentifierContext { return s.table }

func (s *DropConstraintContext) GetConstraintName() IErrorCapturingIdentifierContext {
	return s.constraintName
}

func (s *DropConstraintContext) SetTable(v IMultipartIdentifierContext) { s.table = v }

func (s *DropConstraintContext) SetConstraintName(v IErrorCapturingIdentifierContext) {
	s.constraintName = v
}

func (s *DropConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropConstraintContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *DropConstraintContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *DropConstraintContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(DorisParserCONSTRAINT, 0)
}

func (s *DropConstraintContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropConstraintContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *DropConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropConstraint(s)
	}
}

func (s *DropConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropConstraint(s)
	}
}

type AddConstraintContext struct {
	ConstraintStatementContext
	table          IMultipartIdentifierContext
	constraintName IErrorCapturingIdentifierContext
}

func NewAddConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddConstraintContext {
	var p = new(AddConstraintContext)

	InitEmptyConstraintStatementContext(&p.ConstraintStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstraintStatementContext))

	return p
}

func (s *AddConstraintContext) GetTable() IMultipartIdentifierContext { return s.table }

func (s *AddConstraintContext) GetConstraintName() IErrorCapturingIdentifierContext {
	return s.constraintName
}

func (s *AddConstraintContext) SetTable(v IMultipartIdentifierContext) { s.table = v }

func (s *AddConstraintContext) SetConstraintName(v IErrorCapturingIdentifierContext) {
	s.constraintName = v
}

func (s *AddConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddConstraintContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AddConstraintContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AddConstraintContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(DorisParserCONSTRAINT, 0)
}

func (s *AddConstraintContext) Constraint() IConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintContext)
}

func (s *AddConstraintContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AddConstraintContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *AddConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddConstraint(s)
	}
}

func (s *AddConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddConstraint(s)
	}
}

func (p *DorisParser) ConstraintStatement() (localctx IConstraintStatementContext) {
	localctx = NewConstraintStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, DorisParserRULE_constraintStatement)
	p.SetState(834)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAddConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(815)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(816)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(817)

			var _x = p.MultipartIdentifier()

			localctx.(*AddConstraintContext).table = _x
		}
		{
			p.SetState(818)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(819)
			p.Match(DorisParserCONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(820)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*AddConstraintContext).constraintName = _x
		}
		{
			p.SetState(821)
			p.Constraint()
		}

	case 2:
		localctx = NewDropConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(823)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(824)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(825)

			var _x = p.MultipartIdentifier()

			localctx.(*DropConstraintContext).table = _x
		}
		{
			p.SetState(826)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(827)
			p.Match(DorisParserCONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(828)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*DropConstraintContext).constraintName = _x
		}

	case 3:
		localctx = NewShowConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(830)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(831)
			p.Match(DorisParserCONSTRAINTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(832)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(833)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowConstraintContext).table = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedDmlStatementContext is an interface to support dynamic dispatch.
type ISupportedDmlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedDmlStatementContext differentiates from other interfaces.
	IsSupportedDmlStatementContext()
}

type SupportedDmlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedDmlStatementContext() *SupportedDmlStatementContext {
	var p = new(SupportedDmlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedDmlStatement
	return p
}

func InitEmptySupportedDmlStatementContext(p *SupportedDmlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedDmlStatement
}

func (*SupportedDmlStatementContext) IsSupportedDmlStatementContext() {}

func NewSupportedDmlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedDmlStatementContext {
	var p = new(SupportedDmlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedDmlStatement

	return p
}

func (s *SupportedDmlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedDmlStatementContext) CopyAll(ctx *SupportedDmlStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedDmlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedDmlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type InsertTableContext struct {
	SupportedDmlStatementContext
	tableName IMultipartIdentifierContext
	tableId   antlr.Token
	labelName IIdentifierContext
	cols      IIdentifierListContext
	hints     IIdentifierSeqContext
}

func NewInsertTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertTableContext {
	var p = new(InsertTableContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *InsertTableContext) GetTableId() antlr.Token { return s.tableId }

func (s *InsertTableContext) SetTableId(v antlr.Token) { s.tableId = v }

func (s *InsertTableContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *InsertTableContext) GetLabelName() IIdentifierContext { return s.labelName }

func (s *InsertTableContext) GetCols() IIdentifierListContext { return s.cols }

func (s *InsertTableContext) GetHints() IIdentifierSeqContext { return s.hints }

func (s *InsertTableContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *InsertTableContext) SetLabelName(v IIdentifierContext) { s.labelName = v }

func (s *InsertTableContext) SetCols(v IIdentifierListContext) { s.cols = v }

func (s *InsertTableContext) SetHints(v IIdentifierSeqContext) { s.hints = v }

func (s *InsertTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertTableContext) INSERT() antlr.TerminalNode {
	return s.GetToken(DorisParserINSERT, 0)
}

func (s *InsertTableContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *InsertTableContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserINTO, 0)
}

func (s *InsertTableContext) OVERWRITE() antlr.TerminalNode {
	return s.GetToken(DorisParserOVERWRITE, 0)
}

func (s *InsertTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *InsertTableContext) DORIS_INTERNAL_TABLE_ID() antlr.TerminalNode {
	return s.GetToken(DorisParserDORIS_INTERNAL_TABLE_ID, 0)
}

func (s *InsertTableContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *InsertTableContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *InsertTableContext) Explain() IExplainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainContext)
}

func (s *InsertTableContext) Cte() ICteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteContext)
}

func (s *InsertTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *InsertTableContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *InsertTableContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *InsertTableContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *InsertTableContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisParserLABEL, 0)
}

func (s *InsertTableContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACKET, 0)
}

func (s *InsertTableContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACKET, 0)
}

func (s *InsertTableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InsertTableContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *InsertTableContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *InsertTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterInsertTable(s)
	}
}

func (s *InsertTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitInsertTable(s)
	}
}

type LoadContext struct {
	SupportedDmlStatementContext
	lableName IMultipartIdentifierContext
	_dataDesc IDataDescContext
	dataDescs []IDataDescContext
}

func NewLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LoadContext {
	var p = new(LoadContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *LoadContext) GetLableName() IMultipartIdentifierContext { return s.lableName }

func (s *LoadContext) Get_dataDesc() IDataDescContext { return s._dataDesc }

func (s *LoadContext) SetLableName(v IMultipartIdentifierContext) { s.lableName = v }

func (s *LoadContext) Set_dataDesc(v IDataDescContext) { s._dataDesc = v }

func (s *LoadContext) GetDataDescs() []IDataDescContext { return s.dataDescs }

func (s *LoadContext) SetDataDescs(v []IDataDescContext) { s.dataDescs = v }

func (s *LoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *LoadContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisParserLABEL, 0)
}

func (s *LoadContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *LoadContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *LoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *LoadContext) AllDataDesc() []IDataDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataDescContext); ok {
			len++
		}
	}

	tst := make([]IDataDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataDescContext); ok {
			tst[i] = t.(IDataDescContext)
			i++
		}
	}

	return tst
}

func (s *LoadContext) DataDesc(i int) IDataDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescContext)
}

func (s *LoadContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *LoadContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *LoadContext) WithRemoteStorageSystem() IWithRemoteStorageSystemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithRemoteStorageSystemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithRemoteStorageSystemContext)
}

func (s *LoadContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *LoadContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *LoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLoad(s)
	}
}

func (s *LoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLoad(s)
	}
}

type UpdateContext struct {
	SupportedDmlStatementContext
	tableName IMultipartIdentifierContext
}

func NewUpdateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UpdateContext {
	var p = new(UpdateContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *UpdateContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *UpdateContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *UpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(DorisParserUPDATE, 0)
}

func (s *UpdateContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *UpdateContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *UpdateContext) UpdateAssignmentSeq() IUpdateAssignmentSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateAssignmentSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateAssignmentSeqContext)
}

func (s *UpdateContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *UpdateContext) Explain() IExplainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainContext)
}

func (s *UpdateContext) Cte() ICteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteContext)
}

func (s *UpdateContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *UpdateContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *UpdateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUpdate(s)
	}
}

func (s *UpdateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUpdate(s)
	}
}

type ReplayContext struct {
	SupportedDmlStatementContext
}

func NewReplayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReplayContext {
	var p = new(ReplayContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *ReplayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplayContext) ReplayCommand() IReplayCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplayCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplayCommandContext)
}

func (s *ReplayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterReplay(s)
	}
}

func (s *ReplayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitReplay(s)
	}
}

type DeleteContext struct {
	SupportedDmlStatementContext
	tableName IMultipartIdentifierContext
}

func NewDeleteContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeleteContext {
	var p = new(DeleteContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *DeleteContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DeleteContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisParserDELETE, 0)
}

func (s *DeleteContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *DeleteContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *DeleteContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DeleteContext) Explain() IExplainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainContext)
}

func (s *DeleteContext) Cte() ICteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteContext)
}

func (s *DeleteContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *DeleteContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserUSING, 0)
}

func (s *DeleteContext) Relations() IRelationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationsContext)
}

func (s *DeleteContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *DeleteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDelete(s)
	}
}

func (s *DeleteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDelete(s)
	}
}

type ExportContext struct {
	SupportedDmlStatementContext
	tableName IMultipartIdentifierContext
	partition IIdentifierListContext
	filePath  antlr.Token
}

func NewExportContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExportContext {
	var p = new(ExportContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *ExportContext) GetFilePath() antlr.Token { return s.filePath }

func (s *ExportContext) SetFilePath(v antlr.Token) { s.filePath = v }

func (s *ExportContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ExportContext) GetPartition() IIdentifierListContext { return s.partition }

func (s *ExportContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ExportContext) SetPartition(v IIdentifierListContext) { s.partition = v }

func (s *ExportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(DorisParserEXPORT, 0)
}

func (s *ExportContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *ExportContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *ExportContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ExportContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ExportContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *ExportContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *ExportContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ExportContext) WithRemoteStorageSystem() IWithRemoteStorageSystemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithRemoteStorageSystemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithRemoteStorageSystemContext)
}

func (s *ExportContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ExportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterExport(s)
	}
}

func (s *ExportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitExport(s)
	}
}

func (p *DorisParser) SupportedDmlStatement() (localctx ISupportedDmlStatementContext) {
	localctx = NewSupportedDmlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, DorisParserRULE_supportedDmlStatement)
	var _la int

	p.SetState(951)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext()) {
	case 1:
		localctx = NewInsertTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(837)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&274877906947) != 0 {
			{
				p.SetState(836)
				p.Explain()
			}

		}
		p.SetState(840)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(839)
				p.Cte()
			}

		}
		{
			p.SetState(842)
			p.Match(DorisParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(846)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserINTO:
			{
				p.SetState(843)
				p.Match(DorisParserINTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserOVERWRITE:
			{
				p.SetState(844)
				p.Match(DorisParserOVERWRITE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(845)
				p.Match(DorisParserTABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(853)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(848)

				var _x = p.MultipartIdentifier()

				localctx.(*InsertTableContext).tableName = _x
			}

		case 2:
			{
				p.SetState(849)
				p.Match(DorisParserDORIS_INTERNAL_TABLE_ID)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(850)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(851)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*InsertTableContext).tableId = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(852)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(856)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(855)
				p.PartitionSpec()
			}

		}
		p.SetState(861)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(858)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(859)
				p.Match(DorisParserLABEL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(860)

				var _x = p.Identifier()

				localctx.(*InsertTableContext).labelName = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(864)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(863)

				var _x = p.IdentifierList()

				localctx.(*InsertTableContext).cols = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(870)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_BRACKET {
			{
				p.SetState(866)
				p.Match(DorisParserLEFT_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(867)

				var _x = p.IdentifierSeq()

				localctx.(*InsertTableContext).hints = _x
			}
			{
				p.SetState(868)
				p.Match(DorisParserRIGHT_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(872)
			p.Query()
		}

	case 2:
		localctx = NewUpdateContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(874)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&274877906947) != 0 {
			{
				p.SetState(873)
				p.Explain()
			}

		}
		p.SetState(877)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(876)
				p.Cte()
			}

		}
		{
			p.SetState(879)
			p.Match(DorisParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(880)

			var _x = p.MultipartIdentifier()

			localctx.(*UpdateContext).tableName = _x
		}
		{
			p.SetState(881)
			p.TableAlias()
		}
		{
			p.SetState(882)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(883)
			p.UpdateAssignmentSeq()
		}
		p.SetState(885)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(884)
				p.FromClause()
			}

		}
		p.SetState(888)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWHERE {
			{
				p.SetState(887)
				p.WhereClause()
			}

		}

	case 3:
		localctx = NewDeleteContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(891)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&274877906947) != 0 {
			{
				p.SetState(890)
				p.Explain()
			}

		}
		p.SetState(894)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(893)
				p.Cte()
			}

		}
		{
			p.SetState(896)
			p.Match(DorisParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(897)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(898)

			var _x = p.MultipartIdentifier()

			localctx.(*DeleteContext).tableName = _x
		}
		p.SetState(900)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(899)
				p.PartitionSpec()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(902)
			p.TableAlias()
		}
		p.SetState(905)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserUSING {
			{
				p.SetState(903)
				p.Match(DorisParserUSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(904)
				p.Relations()
			}

		}
		p.SetState(908)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWHERE {
			{
				p.SetState(907)
				p.WhereClause()
			}

		}

	case 4:
		localctx = NewLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(910)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(911)
			p.Match(DorisParserLABEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(912)

			var _x = p.MultipartIdentifier()

			localctx.(*LoadContext).lableName = _x
		}
		{
			p.SetState(913)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(914)

			var _x = p.DataDesc()

			localctx.(*LoadContext)._dataDesc = _x
		}
		localctx.(*LoadContext).dataDescs = append(localctx.(*LoadContext).dataDescs, localctx.(*LoadContext)._dataDesc)
		p.SetState(919)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(915)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(916)

				var _x = p.DataDesc()

				localctx.(*LoadContext)._dataDesc = _x
			}
			localctx.(*LoadContext).dataDescs = append(localctx.(*LoadContext).dataDescs, localctx.(*LoadContext)._dataDesc)

			p.SetState(921)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(922)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(924)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(923)
				p.WithRemoteStorageSystem()
			}

		}
		p.SetState(927)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(926)
				p.PropertyClause()
			}

		}
		p.SetState(930)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(929)
				p.CommentSpec()
			}

		}

	case 5:
		localctx = NewExportContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(932)
			p.Match(DorisParserEXPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(933)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(934)

			var _x = p.MultipartIdentifier()

			localctx.(*ExportContext).tableName = _x
		}
		p.SetState(937)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION {
			{
				p.SetState(935)
				p.Match(DorisParserPARTITION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(936)

				var _x = p.IdentifierList()

				localctx.(*ExportContext).partition = _x
			}

		}
		p.SetState(940)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWHERE {
			{
				p.SetState(939)
				p.WhereClause()
			}

		}
		{
			p.SetState(942)
			p.Match(DorisParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(943)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ExportContext).filePath = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(945)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(944)
				p.PropertyClause()
			}

		}
		p.SetState(948)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(947)
				p.WithRemoteStorageSystem()
			}

		}

	case 6:
		localctx = NewReplayContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(950)
			p.ReplayCommand()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedCreateStatementContext is an interface to support dynamic dispatch.
type ISupportedCreateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedCreateStatementContext differentiates from other interfaces.
	IsSupportedCreateStatementContext()
}

type SupportedCreateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedCreateStatementContext() *SupportedCreateStatementContext {
	var p = new(SupportedCreateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedCreateStatement
	return p
}

func InitEmptySupportedCreateStatementContext(p *SupportedCreateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedCreateStatement
}

func (*SupportedCreateStatementContext) IsSupportedCreateStatementContext() {}

func NewSupportedCreateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedCreateStatementContext {
	var p = new(SupportedCreateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedCreateStatement

	return p
}

func (s *SupportedCreateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedCreateStatementContext) CopyAll(ctx *SupportedCreateStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedCreateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedCreateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CreateEncryptkeyContext struct {
	SupportedCreateStatementContext
}

func NewCreateEncryptkeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateEncryptkeyContext {
	var p = new(CreateEncryptkeyContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateEncryptkeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateEncryptkeyContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateEncryptkeyContext) ENCRYPTKEY() antlr.TerminalNode {
	return s.GetToken(DorisParserENCRYPTKEY, 0)
}

func (s *CreateEncryptkeyContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateEncryptkeyContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *CreateEncryptkeyContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateEncryptkeyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateEncryptkeyContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateEncryptkeyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateEncryptkeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateEncryptkey(s)
	}
}

func (s *CreateEncryptkeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateEncryptkey(s)
	}
}

type CreateTableContext struct {
	SupportedCreateStatementContext
	name          IMultipartIdentifierContext
	ctasCols      IIdentifierListContext
	engine        IIdentifierContext
	keys          IIdentifierListContext
	clusterKeys   IIdentifierListContext
	partition     IPartitionTableContext
	hashKeys      IIdentifierListContext
	autoBucket    antlr.Token
	properties    IPropertyClauseContext
	extProperties IPropertyClauseContext
}

func NewCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableContext {
	var p = new(CreateTableContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateTableContext) GetAutoBucket() antlr.Token { return s.autoBucket }

func (s *CreateTableContext) SetAutoBucket(v antlr.Token) { s.autoBucket = v }

func (s *CreateTableContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CreateTableContext) GetCtasCols() IIdentifierListContext { return s.ctasCols }

func (s *CreateTableContext) GetEngine() IIdentifierContext { return s.engine }

func (s *CreateTableContext) GetKeys() IIdentifierListContext { return s.keys }

func (s *CreateTableContext) GetClusterKeys() IIdentifierListContext { return s.clusterKeys }

func (s *CreateTableContext) GetPartition() IPartitionTableContext { return s.partition }

func (s *CreateTableContext) GetHashKeys() IIdentifierListContext { return s.hashKeys }

func (s *CreateTableContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateTableContext) GetExtProperties() IPropertyClauseContext { return s.extProperties }

func (s *CreateTableContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CreateTableContext) SetCtasCols(v IIdentifierListContext) { s.ctasCols = v }

func (s *CreateTableContext) SetEngine(v IIdentifierContext) { s.engine = v }

func (s *CreateTableContext) SetKeys(v IIdentifierListContext) { s.keys = v }

func (s *CreateTableContext) SetClusterKeys(v IIdentifierListContext) { s.clusterKeys = v }

func (s *CreateTableContext) SetPartition(v IPartitionTableContext) { s.partition = v }

func (s *CreateTableContext) SetHashKeys(v IIdentifierListContext) { s.hashKeys = v }

func (s *CreateTableContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateTableContext) SetExtProperties(v IPropertyClauseContext) { s.extProperties = v }

func (s *CreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *CreateTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateTableContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisParserEXTERNAL, 0)
}

func (s *CreateTableContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateTableContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateTableContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(DorisParserENGINE, 0)
}

func (s *CreateTableContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *CreateTableContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserKEY, 0)
}

func (s *CreateTableContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *CreateTableContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateTableContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTRIBUTED, 0)
}

func (s *CreateTableContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(DorisParserBY)
}

func (s *CreateTableContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserBY, i)
}

func (s *CreateTableContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *CreateTableContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserLEFT_PAREN)
}

func (s *CreateTableContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, i)
}

func (s *CreateTableContext) RollupDefs() IRollupDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupDefsContext)
}

func (s *CreateTableContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserRIGHT_PAREN)
}

func (s *CreateTableContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, i)
}

func (s *CreateTableContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserBROKER, 0)
}

func (s *CreateTableContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *CreateTableContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateTableContext) ColumnDefs() IColumnDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefsContext)
}

func (s *CreateTableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateTableContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(DorisParserAGGREGATE, 0)
}

func (s *CreateTableContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(DorisParserUNIQUE, 0)
}

func (s *CreateTableContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(DorisParserDUPLICATE, 0)
}

func (s *CreateTableContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateTableContext) PartitionTable() IPartitionTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionTableContext)
}

func (s *CreateTableContext) AllPropertyClause() []IPropertyClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			len++
		}
	}

	tst := make([]IPropertyClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyClauseContext); ok {
			tst[i] = t.(IPropertyClauseContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableContext) PropertyClause(i int) IPropertyClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateTableContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisParserHASH, 0)
}

func (s *CreateTableContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(DorisParserRANDOM, 0)
}

func (s *CreateTableContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(DorisParserCLUSTER, 0)
}

func (s *CreateTableContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisParserBUCKETS, 0)
}

func (s *CreateTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *CreateTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *CreateTableContext) IndexDefs() IIndexDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexDefsContext)
}

func (s *CreateTableContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *CreateTableContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO, 0)
}

func (s *CreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateTable(s)
	}
}

func (s *CreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateTable(s)
	}
}

type CreateWorkloadGroupContext struct {
	SupportedCreateStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewCreateWorkloadGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateWorkloadGroupContext {
	var p = new(CreateWorkloadGroupContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateWorkloadGroupContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *CreateWorkloadGroupContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateWorkloadGroupContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *CreateWorkloadGroupContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateWorkloadGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateWorkloadGroupContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateWorkloadGroupContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserWORKLOAD, 0)
}

func (s *CreateWorkloadGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUP, 0)
}

func (s *CreateWorkloadGroupContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CreateWorkloadGroupContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateWorkloadGroupContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateWorkloadGroupContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateWorkloadGroupContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateWorkloadGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateWorkloadGroup(s)
	}
}

func (s *CreateWorkloadGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateWorkloadGroup(s)
	}
}

type CreateTableLikeContext struct {
	SupportedCreateStatementContext
	name         IMultipartIdentifierContext
	existedTable IMultipartIdentifierContext
	rollupNames  IIdentifierListContext
}

func NewCreateTableLikeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableLikeContext {
	var p = new(CreateTableLikeContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateTableLikeContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CreateTableLikeContext) GetExistedTable() IMultipartIdentifierContext { return s.existedTable }

func (s *CreateTableLikeContext) GetRollupNames() IIdentifierListContext { return s.rollupNames }

func (s *CreateTableLikeContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CreateTableLikeContext) SetExistedTable(v IMultipartIdentifierContext) { s.existedTable = v }

func (s *CreateTableLikeContext) SetRollupNames(v IIdentifierListContext) { s.rollupNames = v }

func (s *CreateTableLikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableLikeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateTableLikeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *CreateTableLikeContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *CreateTableLikeContext) AllMultipartIdentifier() []IMultipartIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultipartIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipartIdentifierContext); ok {
			tst[i] = t.(IMultipartIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableLikeContext) MultipartIdentifier(i int) IMultipartIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateTableLikeContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisParserEXTERNAL, 0)
}

func (s *CreateTableLikeContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateTableLikeContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateTableLikeContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateTableLikeContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *CreateTableLikeContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *CreateTableLikeContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateTableLikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateTableLike(s)
	}
}

func (s *CreateTableLikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateTableLike(s)
	}
}

type CreateRoleContext struct {
	SupportedCreateStatementContext
	name IIdentifierContext
}

func NewCreateRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateRoleContext {
	var p = new(CreateRoleContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateRoleContext) GetName() IIdentifierContext { return s.name }

func (s *CreateRoleContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoleContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *CreateRoleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRoleContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateRoleContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateRoleContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateRoleContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *CreateRoleContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateRole(s)
	}
}

func (s *CreateRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateRole(s)
	}
}

type CreateCatalogContext struct {
	SupportedCreateStatementContext
	catalogName  IIdentifierContext
	resourceName IIdentifierContext
	properties   IPropertyClauseContext
}

func NewCreateCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateCatalogContext {
	var p = new(CreateCatalogContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateCatalogContext) GetCatalogName() IIdentifierContext { return s.catalogName }

func (s *CreateCatalogContext) GetResourceName() IIdentifierContext { return s.resourceName }

func (s *CreateCatalogContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateCatalogContext) SetCatalogName(v IIdentifierContext) { s.catalogName = v }

func (s *CreateCatalogContext) SetResourceName(v IIdentifierContext) { s.resourceName = v }

func (s *CreateCatalogContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateCatalogContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateCatalogContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *CreateCatalogContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateCatalogContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateCatalogContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateCatalogContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateCatalogContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateCatalogContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *CreateCatalogContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCE, 0)
}

func (s *CreateCatalogContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *CreateCatalogContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateCatalogContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateCatalogContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateCatalog(s)
	}
}

func (s *CreateCatalogContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateCatalog(s)
	}
}

type CreateViewContext struct {
	SupportedCreateStatementContext
	name IMultipartIdentifierContext
	cols ISimpleColumnDefsContext
}

func NewCreateViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateViewContext {
	var p = new(CreateViewContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateViewContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CreateViewContext) GetCols() ISimpleColumnDefsContext { return s.cols }

func (s *CreateViewContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CreateViewContext) SetCols(v ISimpleColumnDefsContext) { s.cols = v }

func (s *CreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *CreateViewContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *CreateViewContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateViewContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateViewContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisParserOR, 0)
}

func (s *CreateViewContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *CreateViewContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateViewContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateViewContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateViewContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CreateViewContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CreateViewContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *CreateViewContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateViewContext) SimpleColumnDefs() ISimpleColumnDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleColumnDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleColumnDefsContext)
}

func (s *CreateViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateView(s)
	}
}

func (s *CreateViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateView(s)
	}
}

type CreateFileContext struct {
	SupportedCreateStatementContext
	name       antlr.Token
	database   IIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateFileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateFileContext {
	var p = new(CreateFileContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateFileContext) GetName() antlr.Token { return s.name }

func (s *CreateFileContext) SetName(v antlr.Token) { s.name = v }

func (s *CreateFileContext) GetDatabase() IIdentifierContext { return s.database }

func (s *CreateFileContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateFileContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *CreateFileContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFileContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateFileContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisParserFILE, 0)
}

func (s *CreateFileContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateFileContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateFileContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *CreateFileContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *CreateFileContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateFile(s)
	}
}

func (s *CreateFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateFile(s)
	}
}

type CreateSqlBlockRuleContext struct {
	SupportedCreateStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateSqlBlockRuleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateSqlBlockRuleContext {
	var p = new(CreateSqlBlockRuleContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateSqlBlockRuleContext) GetName() IIdentifierContext { return s.name }

func (s *CreateSqlBlockRuleContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateSqlBlockRuleContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateSqlBlockRuleContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateSqlBlockRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateSqlBlockRuleContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateSqlBlockRuleContext) SQL_BLOCK_RULE() antlr.TerminalNode {
	return s.GetToken(DorisParserSQL_BLOCK_RULE, 0)
}

func (s *CreateSqlBlockRuleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateSqlBlockRuleContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateSqlBlockRuleContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateSqlBlockRuleContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateSqlBlockRuleContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateSqlBlockRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateSqlBlockRule(s)
	}
}

func (s *CreateSqlBlockRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateSqlBlockRule(s)
	}
}

type CreateRowPolicyContext struct {
	SupportedCreateStatementContext
	name     IIdentifierContext
	table    IMultipartIdentifierContext
	type_    antlr.Token
	user     IUserIdentifyContext
	roleName IIdentifierContext
}

func NewCreateRowPolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateRowPolicyContext {
	var p = new(CreateRowPolicyContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateRowPolicyContext) GetType_() antlr.Token { return s.type_ }

func (s *CreateRowPolicyContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *CreateRowPolicyContext) GetName() IIdentifierContext { return s.name }

func (s *CreateRowPolicyContext) GetTable() IMultipartIdentifierContext { return s.table }

func (s *CreateRowPolicyContext) GetUser() IUserIdentifyContext { return s.user }

func (s *CreateRowPolicyContext) GetRoleName() IIdentifierContext { return s.roleName }

func (s *CreateRowPolicyContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateRowPolicyContext) SetTable(v IMultipartIdentifierContext) { s.table = v }

func (s *CreateRowPolicyContext) SetUser(v IUserIdentifyContext) { s.user = v }

func (s *CreateRowPolicyContext) SetRoleName(v IIdentifierContext) { s.roleName = v }

func (s *CreateRowPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRowPolicyContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateRowPolicyContext) ROW() antlr.TerminalNode {
	return s.GetToken(DorisParserROW, 0)
}

func (s *CreateRowPolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *CreateRowPolicyContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *CreateRowPolicyContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *CreateRowPolicyContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *CreateRowPolicyContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserUSING, 0)
}

func (s *CreateRowPolicyContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CreateRowPolicyContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *CreateRowPolicyContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CreateRowPolicyContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateRowPolicyContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRowPolicyContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateRowPolicyContext) RESTRICTIVE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESTRICTIVE, 0)
}

func (s *CreateRowPolicyContext) PERMISSIVE() antlr.TerminalNode {
	return s.GetToken(DorisParserPERMISSIVE, 0)
}

func (s *CreateRowPolicyContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *CreateRowPolicyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateRowPolicyContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateRowPolicyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateRowPolicyContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *CreateRowPolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateRowPolicy(s)
	}
}

func (s *CreateRowPolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateRowPolicy(s)
	}
}

func (p *DorisParser) SupportedCreateStatement() (localctx ISupportedCreateStatementContext) {
	localctx = NewSupportedCreateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, DorisParserRULE_supportedCreateStatement)
	var _la int

	p.SetState(1179)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(953)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(955)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserEXTERNAL {
			{
				p.SetState(954)
				p.Match(DorisParserEXTERNAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(957)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(961)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(958)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(959)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(960)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(963)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateTableContext).name = _x
		}
		p.SetState(978)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext()) {
		case 1:
			p.SetState(965)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserLEFT_PAREN {
				{
					p.SetState(964)

					var _x = p.IdentifierList()

					localctx.(*CreateTableContext).ctasCols = _x
				}

			}

		case 2:
			{
				p.SetState(967)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(968)
				p.ColumnDefs()
			}
			p.SetState(971)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(969)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(970)
					p.IndexDefs()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			p.SetState(974)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserCOMMA {
				{
					p.SetState(973)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(976)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(983)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserENGINE {
			{
				p.SetState(980)
				p.Match(DorisParserENGINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(981)
				p.Match(DorisParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(982)

				var _x = p.Identifier()

				localctx.(*CreateTableContext).engine = _x
			}

		}
		p.SetState(993)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAGGREGATE || _la == DorisParserDUPLICATE || _la == DorisParserUNIQUE {
			{
				p.SetState(985)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserAGGREGATE || _la == DorisParserDUPLICATE || _la == DorisParserUNIQUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(986)
				p.Match(DorisParserKEY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(987)

				var _x = p.IdentifierList()

				localctx.(*CreateTableContext).keys = _x
			}
			p.SetState(991)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserCLUSTER {
				{
					p.SetState(988)
					p.Match(DorisParserCLUSTER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(989)
					p.Match(DorisParserBY)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(990)

					var _x = p.IdentifierList()

					localctx.(*CreateTableContext).clusterKeys = _x
				}

			}

		}
		p.SetState(997)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(995)
				p.Match(DorisParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(996)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1000)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAUTO || _la == DorisParserPARTITION {
			{
				p.SetState(999)

				var _x = p.PartitionTable()

				localctx.(*CreateTableContext).partition = _x
			}

		}
		p.SetState(1016)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserDISTRIBUTED {
			{
				p.SetState(1002)
				p.Match(DorisParserDISTRIBUTED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1003)
				p.Match(DorisParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1007)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserHASH:
				{
					p.SetState(1004)
					p.Match(DorisParserHASH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1005)

					var _x = p.IdentifierList()

					localctx.(*CreateTableContext).hashKeys = _x
				}

			case DorisParserRANDOM:
				{
					p.SetState(1006)
					p.Match(DorisParserRANDOM)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			p.SetState(1014)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserBUCKETS {
				{
					p.SetState(1009)
					p.Match(DorisParserBUCKETS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1012)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DorisParserINTEGER_VALUE:
					{
						p.SetState(1010)
						p.Match(DorisParserINTEGER_VALUE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case DorisParserAUTO:
					{
						p.SetState(1011)

						var _m = p.Match(DorisParserAUTO)

						localctx.(*CreateTableContext).autoBucket = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			}

		}
		p.SetState(1023)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserROLLUP {
			{
				p.SetState(1018)
				p.Match(DorisParserROLLUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1019)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1020)
				p.RollupDefs()
			}
			{
				p.SetState(1021)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1026)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1025)

				var _x = p.PropertyClause()

				localctx.(*CreateTableContext).properties = _x
			}

		}
		p.SetState(1030)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserBROKER {
			{
				p.SetState(1028)
				p.Match(DorisParserBROKER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1029)

				var _x = p.PropertyClause()

				localctx.(*CreateTableContext).extProperties = _x
			}

		}
		p.SetState(1034)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAS {
			{
				p.SetState(1032)
				p.Match(DorisParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1033)
				p.Query()
			}

		}

	case 2:
		localctx = NewCreateViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1036)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1039)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserOR {
			{
				p.SetState(1037)
				p.Match(DorisParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1038)
				p.Match(DorisParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1041)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1045)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1042)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1043)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1044)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1047)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateViewContext).name = _x
		}
		p.SetState(1052)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(1048)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1049)

				var _x = p.SimpleColumnDefs()

				localctx.(*CreateViewContext).cols = _x
			}
			{
				p.SetState(1050)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1056)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(1054)
				p.Match(DorisParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1055)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1058)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1059)
			p.Query()
		}

	case 3:
		localctx = NewCreateFileContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1061)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1062)
			p.Match(DorisParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1063)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*CreateFileContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1066)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1064)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1065)

				var _x = p.Identifier()

				localctx.(*CreateFileContext).database = _x
			}

		}
		{
			p.SetState(1068)

			var _x = p.PropertyClause()

			localctx.(*CreateFileContext).properties = _x
		}

	case 4:
		localctx = NewCreateTableLikeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1069)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1071)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserEXTERNAL {
			{
				p.SetState(1070)
				p.Match(DorisParserEXTERNAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1073)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1077)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1074)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1075)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1076)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1079)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateTableLikeContext).name = _x
		}
		{
			p.SetState(1080)
			p.Match(DorisParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1081)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateTableLikeContext).existedTable = _x
		}
		p.SetState(1087)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(1082)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1083)
				p.Match(DorisParserROLLUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1085)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserLEFT_PAREN {
				{
					p.SetState(1084)

					var _x = p.IdentifierList()

					localctx.(*CreateTableLikeContext).rollupNames = _x
				}

			}

		}

	case 5:
		localctx = NewCreateRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1089)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1090)
			p.Match(DorisParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1094)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1091)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1092)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1093)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1096)

			var _x = p.Identifier()

			localctx.(*CreateRoleContext).name = _x
		}
		p.SetState(1099)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(1097)
				p.Match(DorisParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1098)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		localctx = NewCreateWorkloadGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1101)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1102)
			p.Match(DorisParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1103)
			p.Match(DorisParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1107)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1104)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1105)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1106)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1109)

			var _x = p.IdentifierOrText()

			localctx.(*CreateWorkloadGroupContext).name = _x
		}
		p.SetState(1111)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1110)

				var _x = p.PropertyClause()

				localctx.(*CreateWorkloadGroupContext).properties = _x
			}

		}

	case 7:
		localctx = NewCreateCatalogContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1113)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1114)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1118)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1115)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1116)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1117)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1120)

			var _x = p.Identifier()

			localctx.(*CreateCatalogContext).catalogName = _x
		}
		p.SetState(1124)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(1121)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1122)
				p.Match(DorisParserRESOURCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1123)

				var _x = p.Identifier()

				localctx.(*CreateCatalogContext).resourceName = _x
			}

		}
		p.SetState(1128)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(1126)
				p.Match(DorisParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1127)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1131)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1130)

				var _x = p.PropertyClause()

				localctx.(*CreateCatalogContext).properties = _x
			}

		}

	case 8:
		localctx = NewCreateRowPolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1133)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1134)
			p.Match(DorisParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1135)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1139)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1136)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1137)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1138)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1141)

			var _x = p.Identifier()

			localctx.(*CreateRowPolicyContext).name = _x
		}
		{
			p.SetState(1142)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1143)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateRowPolicyContext).table = _x
		}
		{
			p.SetState(1144)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1145)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateRowPolicyContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserPERMISSIVE || _la == DorisParserRESTRICTIVE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateRowPolicyContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1146)
			p.Match(DorisParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1150)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(1147)

				var _x = p.UserIdentify()

				localctx.(*CreateRowPolicyContext).user = _x
			}

		case DorisParserROLE:
			{
				p.SetState(1148)
				p.Match(DorisParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1149)

				var _x = p.Identifier()

				localctx.(*CreateRowPolicyContext).roleName = _x
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(1152)
			p.Match(DorisParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1153)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1154)
			p.booleanExpression(0)
		}
		{
			p.SetState(1155)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewCreateSqlBlockRuleContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1157)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1158)
			p.Match(DorisParserSQL_BLOCK_RULE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1162)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1159)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1160)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1161)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1164)

			var _x = p.Identifier()

			localctx.(*CreateSqlBlockRuleContext).name = _x
		}
		p.SetState(1166)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1165)

				var _x = p.PropertyClause()

				localctx.(*CreateSqlBlockRuleContext).properties = _x
			}

		}

	case 10:
		localctx = NewCreateEncryptkeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1168)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1169)
			p.Match(DorisParserENCRYPTKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1173)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1170)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1171)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1172)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1175)
			p.MultipartIdentifier()
		}
		{
			p.SetState(1176)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1177)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedAlterStatementContext is an interface to support dynamic dispatch.
type ISupportedAlterStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedAlterStatementContext differentiates from other interfaces.
	IsSupportedAlterStatementContext()
}

type SupportedAlterStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedAlterStatementContext() *SupportedAlterStatementContext {
	var p = new(SupportedAlterStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedAlterStatement
	return p
}

func InitEmptySupportedAlterStatementContext(p *SupportedAlterStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedAlterStatement
}

func (*SupportedAlterStatementContext) IsSupportedAlterStatementContext() {}

func NewSupportedAlterStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedAlterStatementContext {
	var p = new(SupportedAlterStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedAlterStatement

	return p
}

func (s *SupportedAlterStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedAlterStatementContext) CopyAll(ctx *SupportedAlterStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedAlterStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedAlterStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AlterSystemRenameComputeGroupContext struct {
	SupportedAlterStatementContext
	name    IIdentifierContext
	newName IIdentifierContext
}

func NewAlterSystemRenameComputeGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterSystemRenameComputeGroupContext {
	var p = new(AlterSystemRenameComputeGroupContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterSystemRenameComputeGroupContext) GetName() IIdentifierContext { return s.name }

func (s *AlterSystemRenameComputeGroupContext) GetNewName() IIdentifierContext { return s.newName }

func (s *AlterSystemRenameComputeGroupContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterSystemRenameComputeGroupContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *AlterSystemRenameComputeGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSystemRenameComputeGroupContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterSystemRenameComputeGroupContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(DorisParserSYSTEM, 0)
}

func (s *AlterSystemRenameComputeGroupContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserRENAME, 0)
}

func (s *AlterSystemRenameComputeGroupContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPUTE, 0)
}

func (s *AlterSystemRenameComputeGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUP, 0)
}

func (s *AlterSystemRenameComputeGroupContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterSystemRenameComputeGroupContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterSystemRenameComputeGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterSystemRenameComputeGroup(s)
	}
}

func (s *AlterSystemRenameComputeGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterSystemRenameComputeGroup(s)
	}
}

type AlterCatalogRenameContext struct {
	SupportedAlterStatementContext
	name    IIdentifierContext
	newName IIdentifierContext
}

func NewAlterCatalogRenameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterCatalogRenameContext {
	var p = new(AlterCatalogRenameContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterCatalogRenameContext) GetName() IIdentifierContext { return s.name }

func (s *AlterCatalogRenameContext) GetNewName() IIdentifierContext { return s.newName }

func (s *AlterCatalogRenameContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterCatalogRenameContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *AlterCatalogRenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterCatalogRenameContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterCatalogRenameContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *AlterCatalogRenameContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserRENAME, 0)
}

func (s *AlterCatalogRenameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterCatalogRenameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterCatalogRenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterCatalogRename(s)
	}
}

func (s *AlterCatalogRenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterCatalogRename(s)
	}
}

type AlterDatabaseSetQuotaContext struct {
	SupportedAlterStatementContext
	name  IIdentifierContext
	quota IIdentifierContext
}

func NewAlterDatabaseSetQuotaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterDatabaseSetQuotaContext {
	var p = new(AlterDatabaseSetQuotaContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterDatabaseSetQuotaContext) GetName() IIdentifierContext { return s.name }

func (s *AlterDatabaseSetQuotaContext) GetQuota() IIdentifierContext { return s.quota }

func (s *AlterDatabaseSetQuotaContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterDatabaseSetQuotaContext) SetQuota(v IIdentifierContext) { s.quota = v }

func (s *AlterDatabaseSetQuotaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseSetQuotaContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterDatabaseSetQuotaContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *AlterDatabaseSetQuotaContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterDatabaseSetQuotaContext) QUOTA() antlr.TerminalNode {
	return s.GetToken(DorisParserQUOTA, 0)
}

func (s *AlterDatabaseSetQuotaContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterDatabaseSetQuotaContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterDatabaseSetQuotaContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserDATA, 0)
}

func (s *AlterDatabaseSetQuotaContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLICA, 0)
}

func (s *AlterDatabaseSetQuotaContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisParserTRANSACTION, 0)
}

func (s *AlterDatabaseSetQuotaContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *AlterDatabaseSetQuotaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterDatabaseSetQuota(s)
	}
}

func (s *AlterDatabaseSetQuotaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterDatabaseSetQuota(s)
	}
}

type AlterStorageVaultContext struct {
	SupportedAlterStatementContext
	name       IMultipartIdentifierContext
	properties IPropertyClauseContext
}

func NewAlterStorageVaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterStorageVaultContext {
	var p = new(AlterStorageVaultContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterStorageVaultContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterStorageVaultContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterStorageVaultContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterStorageVaultContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterStorageVaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStorageVaultContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterStorageVaultContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *AlterStorageVaultContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULT, 0)
}

func (s *AlterStorageVaultContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterStorageVaultContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterStorageVaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterStorageVault(s)
	}
}

func (s *AlterStorageVaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterStorageVault(s)
	}
}

type AlterWorkloadGroupContext struct {
	SupportedAlterStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewAlterWorkloadGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterWorkloadGroupContext {
	var p = new(AlterWorkloadGroupContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterWorkloadGroupContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *AlterWorkloadGroupContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterWorkloadGroupContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *AlterWorkloadGroupContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterWorkloadGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterWorkloadGroupContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterWorkloadGroupContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserWORKLOAD, 0)
}

func (s *AlterWorkloadGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUP, 0)
}

func (s *AlterWorkloadGroupContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *AlterWorkloadGroupContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterWorkloadGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterWorkloadGroup(s)
	}
}

func (s *AlterWorkloadGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterWorkloadGroup(s)
	}
}

type AlterTableDropRollupContext struct {
	SupportedAlterStatementContext
	tableName IMultipartIdentifierContext
}

func NewAlterTableDropRollupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableDropRollupContext {
	var p = new(AlterTableDropRollupContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterTableDropRollupContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *AlterTableDropRollupContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *AlterTableDropRollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableDropRollupContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterTableDropRollupContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AlterTableDropRollupContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *AlterTableDropRollupContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *AlterTableDropRollupContext) AllDropRollupClause() []IDropRollupClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDropRollupClauseContext); ok {
			len++
		}
	}

	tst := make([]IDropRollupClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDropRollupClauseContext); ok {
			tst[i] = t.(IDropRollupClauseContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableDropRollupContext) DropRollupClause(i int) IDropRollupClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropRollupClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropRollupClauseContext)
}

func (s *AlterTableDropRollupContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterTableDropRollupContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AlterTableDropRollupContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AlterTableDropRollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterTableDropRollup(s)
	}
}

func (s *AlterTableDropRollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterTableDropRollup(s)
	}
}

type AlterTablePropertiesContext struct {
	SupportedAlterStatementContext
	name IMultipartIdentifierContext
}

func NewAlterTablePropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTablePropertiesContext {
	var p = new(AlterTablePropertiesContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterTablePropertiesContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterTablePropertiesContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterTablePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTablePropertiesContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterTablePropertiesContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AlterTablePropertiesContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterTablePropertiesContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterTablePropertiesContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterTablePropertiesContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterTablePropertiesContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterTablePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterTableProperties(s)
	}
}

func (s *AlterTablePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterTableProperties(s)
	}
}

type AlterRoleContext struct {
	SupportedAlterStatementContext
	role IIdentifierContext
}

func NewAlterRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterRoleContext {
	var p = new(AlterRoleContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterRoleContext) GetRole() IIdentifierContext { return s.role }

func (s *AlterRoleContext) SetRole(v IIdentifierContext) { s.role = v }

func (s *AlterRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRoleContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *AlterRoleContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *AlterRoleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterRole(s)
	}
}

func (s *AlterRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterRole(s)
	}
}

type AlterWorkloadPolicyContext struct {
	SupportedAlterStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewAlterWorkloadPolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterWorkloadPolicyContext {
	var p = new(AlterWorkloadPolicyContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterWorkloadPolicyContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *AlterWorkloadPolicyContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterWorkloadPolicyContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *AlterWorkloadPolicyContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterWorkloadPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterWorkloadPolicyContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterWorkloadPolicyContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserWORKLOAD, 0)
}

func (s *AlterWorkloadPolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *AlterWorkloadPolicyContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *AlterWorkloadPolicyContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterWorkloadPolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterWorkloadPolicy(s)
	}
}

func (s *AlterWorkloadPolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterWorkloadPolicy(s)
	}
}

type AlterDatabaseRenameContext struct {
	SupportedAlterStatementContext
	name    IIdentifierContext
	newName IIdentifierContext
}

func NewAlterDatabaseRenameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterDatabaseRenameContext {
	var p = new(AlterDatabaseRenameContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterDatabaseRenameContext) GetName() IIdentifierContext { return s.name }

func (s *AlterDatabaseRenameContext) GetNewName() IIdentifierContext { return s.newName }

func (s *AlterDatabaseRenameContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterDatabaseRenameContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *AlterDatabaseRenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseRenameContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterDatabaseRenameContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *AlterDatabaseRenameContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserRENAME, 0)
}

func (s *AlterDatabaseRenameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterDatabaseRenameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterDatabaseRenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterDatabaseRename(s)
	}
}

func (s *AlterDatabaseRenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterDatabaseRename(s)
	}
}

type AlterCatalogCommentContext struct {
	SupportedAlterStatementContext
	name    IIdentifierContext
	comment antlr.Token
}

func NewAlterCatalogCommentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterCatalogCommentContext {
	var p = new(AlterCatalogCommentContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterCatalogCommentContext) GetComment() antlr.Token { return s.comment }

func (s *AlterCatalogCommentContext) SetComment(v antlr.Token) { s.comment = v }

func (s *AlterCatalogCommentContext) GetName() IIdentifierContext { return s.name }

func (s *AlterCatalogCommentContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterCatalogCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterCatalogCommentContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterCatalogCommentContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *AlterCatalogCommentContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *AlterCatalogCommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *AlterCatalogCommentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterCatalogCommentContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *AlterCatalogCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterCatalogComment(s)
	}
}

func (s *AlterCatalogCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterCatalogComment(s)
	}
}

type AlterViewContext struct {
	SupportedAlterStatementContext
	name IMultipartIdentifierContext
	cols ISimpleColumnDefsContext
}

func NewAlterViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterViewContext {
	var p = new(AlterViewContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterViewContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterViewContext) GetCols() ISimpleColumnDefsContext { return s.cols }

func (s *AlterViewContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterViewContext) SetCols(v ISimpleColumnDefsContext) { s.cols = v }

func (s *AlterViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterViewContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *AlterViewContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterViewContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *AlterViewContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *AlterViewContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *AlterViewContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *AlterViewContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterViewContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterViewContext) SimpleColumnDefs() ISimpleColumnDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleColumnDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleColumnDefsContext)
}

func (s *AlterViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterView(s)
	}
}

func (s *AlterViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterView(s)
	}
}

type AlterSqlBlockRuleContext struct {
	SupportedAlterStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewAlterSqlBlockRuleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterSqlBlockRuleContext {
	var p = new(AlterSqlBlockRuleContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterSqlBlockRuleContext) GetName() IIdentifierContext { return s.name }

func (s *AlterSqlBlockRuleContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterSqlBlockRuleContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterSqlBlockRuleContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterSqlBlockRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSqlBlockRuleContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterSqlBlockRuleContext) SQL_BLOCK_RULE() antlr.TerminalNode {
	return s.GetToken(DorisParserSQL_BLOCK_RULE, 0)
}

func (s *AlterSqlBlockRuleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterSqlBlockRuleContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterSqlBlockRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterSqlBlockRule(s)
	}
}

func (s *AlterSqlBlockRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterSqlBlockRule(s)
	}
}

type AlterTableAddRollupContext struct {
	SupportedAlterStatementContext
	tableName IMultipartIdentifierContext
}

func NewAlterTableAddRollupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableAddRollupContext {
	var p = new(AlterTableAddRollupContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterTableAddRollupContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *AlterTableAddRollupContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *AlterTableAddRollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableAddRollupContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterTableAddRollupContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AlterTableAddRollupContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AlterTableAddRollupContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *AlterTableAddRollupContext) AllAddRollupClause() []IAddRollupClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAddRollupClauseContext); ok {
			len++
		}
	}

	tst := make([]IAddRollupClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAddRollupClauseContext); ok {
			tst[i] = t.(IAddRollupClauseContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableAddRollupContext) AddRollupClause(i int) IAddRollupClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddRollupClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddRollupClauseContext)
}

func (s *AlterTableAddRollupContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterTableAddRollupContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AlterTableAddRollupContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AlterTableAddRollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterTableAddRollup(s)
	}
}

func (s *AlterTableAddRollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterTableAddRollup(s)
	}
}

type AlterTableContext struct {
	SupportedAlterStatementContext
	tableName IMultipartIdentifierContext
}

func NewAlterTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableContext {
	var p = new(AlterTableContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterTableContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *AlterTableContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *AlterTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AlterTableContext) AllAlterTableClause() []IAlterTableClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterTableClauseContext); ok {
			len++
		}
	}

	tst := make([]IAlterTableClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterTableClauseContext); ok {
			tst[i] = t.(IAlterTableClauseContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableContext) AlterTableClause(i int) IAlterTableClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableClauseContext)
}

func (s *AlterTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AlterTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AlterTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterTable(s)
	}
}

func (s *AlterTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterTable(s)
	}
}

func (p *DorisParser) SupportedAlterStatement() (localctx ISupportedAlterStatementContext) {
	localctx = NewSupportedAlterStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, DorisParserRULE_supportedAlterStatement)
	var _la int

	p.SetState(1319)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAlterViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1181)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1182)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1183)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterViewContext).name = _x
		}
		p.SetState(1194)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserMODIFY:
			{
				p.SetState(1184)
				p.Match(DorisParserMODIFY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1185)
				p.CommentSpec()
			}

		case DorisParserLEFT_PAREN, DorisParserAS:
			p.SetState(1190)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserLEFT_PAREN {
				{
					p.SetState(1186)
					p.Match(DorisParserLEFT_PAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1187)

					var _x = p.SimpleColumnDefs()

					localctx.(*AlterViewContext).cols = _x
				}
				{
					p.SetState(1188)
					p.Match(DorisParserRIGHT_PAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1192)
				p.Match(DorisParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1193)
				p.Query()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		localctx = NewAlterCatalogRenameContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1196)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1197)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1198)

			var _x = p.Identifier()

			localctx.(*AlterCatalogRenameContext).name = _x
		}
		{
			p.SetState(1199)
			p.Match(DorisParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1200)

			var _x = p.Identifier()

			localctx.(*AlterCatalogRenameContext).newName = _x
		}

	case 3:
		localctx = NewAlterRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1202)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1203)
			p.Match(DorisParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1204)

			var _x = p.Identifier()

			localctx.(*AlterRoleContext).role = _x
		}
		{
			p.SetState(1205)
			p.CommentSpec()
		}

	case 4:
		localctx = NewAlterStorageVaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1207)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1208)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1209)
			p.Match(DorisParserVAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1210)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterStorageVaultContext).name = _x
		}
		{
			p.SetState(1211)

			var _x = p.PropertyClause()

			localctx.(*AlterStorageVaultContext).properties = _x
		}

	case 5:
		localctx = NewAlterRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1213)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1214)
			p.Match(DorisParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1215)

			var _x = p.Identifier()

			localctx.(*AlterRoleContext).role = _x
		}
		{
			p.SetState(1216)
			p.CommentSpec()
		}

	case 6:
		localctx = NewAlterWorkloadGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1218)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1219)
			p.Match(DorisParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1220)
			p.Match(DorisParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1221)

			var _x = p.IdentifierOrText()

			localctx.(*AlterWorkloadGroupContext).name = _x
		}
		p.SetState(1223)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1222)

				var _x = p.PropertyClause()

				localctx.(*AlterWorkloadGroupContext).properties = _x
			}

		}

	case 7:
		localctx = NewAlterWorkloadPolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1225)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1226)
			p.Match(DorisParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1227)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1228)

			var _x = p.IdentifierOrText()

			localctx.(*AlterWorkloadPolicyContext).name = _x
		}
		p.SetState(1230)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1229)

				var _x = p.PropertyClause()

				localctx.(*AlterWorkloadPolicyContext).properties = _x
			}

		}

	case 8:
		localctx = NewAlterSqlBlockRuleContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1232)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1233)
			p.Match(DorisParserSQL_BLOCK_RULE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1234)

			var _x = p.Identifier()

			localctx.(*AlterSqlBlockRuleContext).name = _x
		}
		p.SetState(1236)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1235)

				var _x = p.PropertyClause()

				localctx.(*AlterSqlBlockRuleContext).properties = _x
			}

		}

	case 9:
		localctx = NewAlterCatalogCommentContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1238)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1239)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1240)

			var _x = p.Identifier()

			localctx.(*AlterCatalogCommentContext).name = _x
		}
		{
			p.SetState(1241)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1242)
			p.Match(DorisParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1243)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*AlterCatalogCommentContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewAlterDatabaseRenameContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1245)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1246)
			p.Match(DorisParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1247)

			var _x = p.Identifier()

			localctx.(*AlterDatabaseRenameContext).name = _x
		}
		{
			p.SetState(1248)
			p.Match(DorisParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1249)

			var _x = p.Identifier()

			localctx.(*AlterDatabaseRenameContext).newName = _x
		}

	case 11:
		localctx = NewAlterRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1251)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1252)
			p.Match(DorisParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1253)

			var _x = p.Identifier()

			localctx.(*AlterRoleContext).role = _x
		}
		{
			p.SetState(1254)
			p.CommentSpec()
		}

	case 12:
		localctx = NewAlterTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1256)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1257)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1258)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterTableContext).tableName = _x
		}
		{
			p.SetState(1259)
			p.AlterTableClause()
		}
		p.SetState(1264)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(1260)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1261)
				p.AlterTableClause()
			}

			p.SetState(1266)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 13:
		localctx = NewAlterTableAddRollupContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1267)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1268)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1269)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterTableAddRollupContext).tableName = _x
		}
		{
			p.SetState(1270)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1271)
			p.Match(DorisParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1272)
			p.AddRollupClause()
		}
		p.SetState(1277)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(1273)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1274)
				p.AddRollupClause()
			}

			p.SetState(1279)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 14:
		localctx = NewAlterTableDropRollupContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1280)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1281)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1282)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterTableDropRollupContext).tableName = _x
		}
		{
			p.SetState(1283)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1284)
			p.Match(DorisParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1285)
			p.DropRollupClause()
		}
		p.SetState(1290)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(1286)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1287)
				p.DropRollupClause()
			}

			p.SetState(1292)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 15:
		localctx = NewAlterTablePropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1293)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1294)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1295)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterTablePropertiesContext).name = _x
		}
		{
			p.SetState(1296)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1297)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1298)
			p.PropertyItemList()
		}
		{
			p.SetState(1299)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		localctx = NewAlterDatabaseSetQuotaContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1301)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1302)
			p.Match(DorisParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1303)

			var _x = p.Identifier()

			localctx.(*AlterDatabaseSetQuotaContext).name = _x
		}
		{
			p.SetState(1304)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1305)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserDATA || _la == DorisParserREPLICA || _la == DorisParserTRANSACTION) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1306)
			p.Match(DorisParserQUOTA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1309)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(1307)

				var _x = p.Identifier()

				localctx.(*AlterDatabaseSetQuotaContext).quota = _x
			}

		case DorisParserINTEGER_VALUE:
			{
				p.SetState(1308)
				p.Match(DorisParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 17:
		localctx = NewAlterSystemRenameComputeGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1311)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1312)
			p.Match(DorisParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1313)
			p.Match(DorisParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1314)
			p.Match(DorisParserCOMPUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1315)
			p.Match(DorisParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1316)

			var _x = p.Identifier()

			localctx.(*AlterSystemRenameComputeGroupContext).name = _x
		}
		{
			p.SetState(1317)

			var _x = p.Identifier()

			localctx.(*AlterSystemRenameComputeGroupContext).newName = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedDropStatementContext is an interface to support dynamic dispatch.
type ISupportedDropStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedDropStatementContext differentiates from other interfaces.
	IsSupportedDropStatementContext()
}

type SupportedDropStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedDropStatementContext() *SupportedDropStatementContext {
	var p = new(SupportedDropStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedDropStatement
	return p
}

func InitEmptySupportedDropStatementContext(p *SupportedDropStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedDropStatement
}

func (*SupportedDropStatementContext) IsSupportedDropStatementContext() {}

func NewSupportedDropStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedDropStatementContext {
	var p = new(SupportedDropStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedDropStatement

	return p
}

func (s *SupportedDropStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedDropStatementContext) CopyAll(ctx *SupportedDropStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedDropStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedDropStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DropEncryptkeyContext struct {
	SupportedDropStatementContext
	name IMultipartIdentifierContext
}

func NewDropEncryptkeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropEncryptkeyContext {
	var p = new(DropEncryptkeyContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropEncryptkeyContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *DropEncryptkeyContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *DropEncryptkeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropEncryptkeyContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropEncryptkeyContext) ENCRYPTKEY() antlr.TerminalNode {
	return s.GetToken(DorisParserENCRYPTKEY, 0)
}

func (s *DropEncryptkeyContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropEncryptkeyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropEncryptkeyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropEncryptkeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropEncryptkey(s)
	}
}

func (s *DropEncryptkeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropEncryptkey(s)
	}
}

type DropRepositoryContext struct {
	SupportedDropStatementContext
	name IIdentifierContext
}

func NewDropRepositoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropRepositoryContext {
	var p = new(DropRepositoryContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropRepositoryContext) GetName() IIdentifierContext { return s.name }

func (s *DropRepositoryContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropRepositoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRepositoryContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropRepositoryContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisParserREPOSITORY, 0)
}

func (s *DropRepositoryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropRepositoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropRepository(s)
	}
}

func (s *DropRepositoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropRepository(s)
	}
}

type DropRoleContext struct {
	SupportedDropStatementContext
	name IIdentifierContext
}

func NewDropRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropRoleContext {
	var p = new(DropRoleContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropRoleContext) GetName() IIdentifierContext { return s.name }

func (s *DropRoleContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRoleContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *DropRoleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropRoleContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropRoleContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropRole(s)
	}
}

func (s *DropRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropRole(s)
	}
}

type DropUserContext struct {
	SupportedDropStatementContext
}

func NewDropUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropUserContext {
	var p = new(DropUserContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropUserContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropUserContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisParserUSER, 0)
}

func (s *DropUserContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *DropUserContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropUserContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropUser(s)
	}
}

func (s *DropUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropUser(s)
	}
}

type DropDatabaseContext struct {
	SupportedDropStatementContext
	name IMultipartIdentifierContext
}

func NewDropDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropDatabaseContext {
	var p = new(DropDatabaseContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropDatabaseContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *DropDatabaseContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *DropDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDatabaseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *DropDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEMA, 0)
}

func (s *DropDatabaseContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropDatabaseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropDatabaseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropDatabaseContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserFORCE, 0)
}

func (s *DropDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropDatabase(s)
	}
}

func (s *DropDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropDatabase(s)
	}
}

type DropWorkloadPolicyContext struct {
	SupportedDropStatementContext
	name IIdentifierOrTextContext
}

func NewDropWorkloadPolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropWorkloadPolicyContext {
	var p = new(DropWorkloadPolicyContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropWorkloadPolicyContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *DropWorkloadPolicyContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *DropWorkloadPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropWorkloadPolicyContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropWorkloadPolicyContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserWORKLOAD, 0)
}

func (s *DropWorkloadPolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *DropWorkloadPolicyContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DropWorkloadPolicyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropWorkloadPolicyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropWorkloadPolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropWorkloadPolicy(s)
	}
}

func (s *DropWorkloadPolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropWorkloadPolicy(s)
	}
}

type DropFileContext struct {
	SupportedDropStatementContext
	name       antlr.Token
	database   IIdentifierContext
	properties IPropertyClauseContext
}

func NewDropFileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropFileContext {
	var p = new(DropFileContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropFileContext) GetName() antlr.Token { return s.name }

func (s *DropFileContext) SetName(v antlr.Token) { s.name = v }

func (s *DropFileContext) GetDatabase() IIdentifierContext { return s.database }

func (s *DropFileContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *DropFileContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *DropFileContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *DropFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFileContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropFileContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisParserFILE, 0)
}

func (s *DropFileContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *DropFileContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *DropFileContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *DropFileContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *DropFileContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropFile(s)
	}
}

func (s *DropFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropFile(s)
	}
}

type DropWorkloadGroupContext struct {
	SupportedDropStatementContext
	name IIdentifierOrTextContext
}

func NewDropWorkloadGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropWorkloadGroupContext {
	var p = new(DropWorkloadGroupContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropWorkloadGroupContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *DropWorkloadGroupContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *DropWorkloadGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropWorkloadGroupContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropWorkloadGroupContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserWORKLOAD, 0)
}

func (s *DropWorkloadGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUP, 0)
}

func (s *DropWorkloadGroupContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DropWorkloadGroupContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropWorkloadGroupContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropWorkloadGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropWorkloadGroup(s)
	}
}

func (s *DropWorkloadGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropWorkloadGroup(s)
	}
}

type DropCatalogContext struct {
	SupportedDropStatementContext
	name IIdentifierContext
}

func NewDropCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropCatalogContext {
	var p = new(DropCatalogContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropCatalogContext) GetName() IIdentifierContext { return s.name }

func (s *DropCatalogContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropCatalogContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropCatalogContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *DropCatalogContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropCatalogContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropCatalogContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropCatalogContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropCatalog(s)
	}
}

func (s *DropCatalogContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropCatalog(s)
	}
}

type DropCatalogRecycleBinContext struct {
	SupportedDropStatementContext
	idType antlr.Token
	id     antlr.Token
}

func NewDropCatalogRecycleBinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropCatalogRecycleBinContext {
	var p = new(DropCatalogRecycleBinContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropCatalogRecycleBinContext) GetIdType() antlr.Token { return s.idType }

func (s *DropCatalogRecycleBinContext) GetId() antlr.Token { return s.id }

func (s *DropCatalogRecycleBinContext) SetIdType(v antlr.Token) { s.idType = v }

func (s *DropCatalogRecycleBinContext) SetId(v antlr.Token) { s.id = v }

func (s *DropCatalogRecycleBinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropCatalogRecycleBinContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropCatalogRecycleBinContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *DropCatalogRecycleBinContext) RECYCLE() antlr.TerminalNode {
	return s.GetToken(DorisParserRECYCLE, 0)
}

func (s *DropCatalogRecycleBinContext) BIN() antlr.TerminalNode {
	return s.GetToken(DorisParserBIN, 0)
}

func (s *DropCatalogRecycleBinContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserWHERE, 0)
}

func (s *DropCatalogRecycleBinContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *DropCatalogRecycleBinContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *DropCatalogRecycleBinContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *DropCatalogRecycleBinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropCatalogRecycleBin(s)
	}
}

func (s *DropCatalogRecycleBinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropCatalogRecycleBin(s)
	}
}

type DropSqlBlockRuleContext struct {
	SupportedDropStatementContext
}

func NewDropSqlBlockRuleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropSqlBlockRuleContext {
	var p = new(DropSqlBlockRuleContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropSqlBlockRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropSqlBlockRuleContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropSqlBlockRuleContext) SQL_BLOCK_RULE() antlr.TerminalNode {
	return s.GetToken(DorisParserSQL_BLOCK_RULE, 0)
}

func (s *DropSqlBlockRuleContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *DropSqlBlockRuleContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropSqlBlockRuleContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropSqlBlockRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropSqlBlockRule(s)
	}
}

func (s *DropSqlBlockRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropSqlBlockRule(s)
	}
}

type DropStoragePolicyContext struct {
	SupportedDropStatementContext
	name IIdentifierContext
}

func NewDropStoragePolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropStoragePolicyContext {
	var p = new(DropStoragePolicyContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropStoragePolicyContext) GetName() IIdentifierContext { return s.name }

func (s *DropStoragePolicyContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropStoragePolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStoragePolicyContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropStoragePolicyContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *DropStoragePolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *DropStoragePolicyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropStoragePolicyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropStoragePolicyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropStoragePolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropStoragePolicy(s)
	}
}

func (s *DropStoragePolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropStoragePolicy(s)
	}
}

func (p *DorisParser) SupportedDropStatement() (localctx ISupportedDropStatementContext) {
	localctx = NewSupportedDropStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, DorisParserRULE_supportedDropStatement)
	var _la int

	p.SetState(1409)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDropCatalogRecycleBinContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1321)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1322)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1323)
			p.Match(DorisParserRECYCLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1324)
			p.Match(DorisParserBIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1325)
			p.Match(DorisParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1326)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*DropCatalogRecycleBinContext).idType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1327)
			p.Match(DorisParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1328)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*DropCatalogRecycleBinContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewDropEncryptkeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1329)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1330)
			p.Match(DorisParserENCRYPTKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1333)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1331)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1332)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1335)

			var _x = p.MultipartIdentifier()

			localctx.(*DropEncryptkeyContext).name = _x
		}

	case 3:
		localctx = NewDropRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1336)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1337)
			p.Match(DorisParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1340)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1338)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1339)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1342)

			var _x = p.Identifier()

			localctx.(*DropRoleContext).name = _x
		}

	case 4:
		localctx = NewDropSqlBlockRuleContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1343)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1344)
			p.Match(DorisParserSQL_BLOCK_RULE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1347)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1345)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1346)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1349)
			p.IdentifierSeq()
		}

	case 5:
		localctx = NewDropUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1350)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1351)
			p.Match(DorisParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1354)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1352)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1353)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1356)
			p.UserIdentify()
		}

	case 6:
		localctx = NewDropStoragePolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1357)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1358)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1359)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1362)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1360)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1361)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1364)

			var _x = p.Identifier()

			localctx.(*DropStoragePolicyContext).name = _x
		}

	case 7:
		localctx = NewDropWorkloadGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1365)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1366)
			p.Match(DorisParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1367)
			p.Match(DorisParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1370)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1368)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1369)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1372)

			var _x = p.IdentifierOrText()

			localctx.(*DropWorkloadGroupContext).name = _x
		}

	case 8:
		localctx = NewDropCatalogContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1373)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1374)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1377)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1375)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1376)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1379)

			var _x = p.Identifier()

			localctx.(*DropCatalogContext).name = _x
		}

	case 9:
		localctx = NewDropFileContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1380)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1381)
			p.Match(DorisParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1382)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*DropFileContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1385)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1383)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1384)

				var _x = p.Identifier()

				localctx.(*DropFileContext).database = _x
			}

		}
		{
			p.SetState(1387)

			var _x = p.PropertyClause()

			localctx.(*DropFileContext).properties = _x
		}

	case 10:
		localctx = NewDropWorkloadPolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1388)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1389)
			p.Match(DorisParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1390)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1393)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1391)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1392)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1395)

			var _x = p.IdentifierOrText()

			localctx.(*DropWorkloadPolicyContext).name = _x
		}

	case 11:
		localctx = NewDropRepositoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1396)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1397)
			p.Match(DorisParserREPOSITORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1398)

			var _x = p.Identifier()

			localctx.(*DropRepositoryContext).name = _x
		}

	case 12:
		localctx = NewDropDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1399)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1400)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserDATABASE || _la == DorisParserSCHEMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1403)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1401)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1402)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1405)

			var _x = p.MultipartIdentifier()

			localctx.(*DropDatabaseContext).name = _x
		}
		p.SetState(1407)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFORCE {
			{
				p.SetState(1406)
				p.Match(DorisParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedShowStatementContext is an interface to support dynamic dispatch.
type ISupportedShowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedShowStatementContext differentiates from other interfaces.
	IsSupportedShowStatementContext()
}

type SupportedShowStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedShowStatementContext() *SupportedShowStatementContext {
	var p = new(SupportedShowStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedShowStatement
	return p
}

func InitEmptySupportedShowStatementContext(p *SupportedShowStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedShowStatement
}

func (*SupportedShowStatementContext) IsSupportedShowStatementContext() {}

func NewSupportedShowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedShowStatementContext {
	var p = new(SupportedShowStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedShowStatement

	return p
}

func (s *SupportedShowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedShowStatementContext) CopyAll(ctx *SupportedShowStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedShowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedShowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowRepositoriesContext struct {
	SupportedShowStatementContext
}

func NewShowRepositoriesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRepositoriesContext {
	var p = new(ShowRepositoriesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowRepositoriesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRepositoriesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowRepositoriesContext) REPOSITORIES() antlr.TerminalNode {
	return s.GetToken(DorisParserREPOSITORIES, 0)
}

func (s *ShowRepositoriesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowRepositories(s)
	}
}

func (s *ShowRepositoriesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowRepositories(s)
	}
}

type ShowDynamicPartitionContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowDynamicPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDynamicPartitionContext {
	var p = new(ShowDynamicPartitionContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowDynamicPartitionContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowDynamicPartitionContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowDynamicPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDynamicPartitionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowDynamicPartitionContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(DorisParserDYNAMIC, 0)
}

func (s *ShowDynamicPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *ShowDynamicPartitionContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLES, 0)
}

func (s *ShowDynamicPartitionContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowDynamicPartitionContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowDynamicPartitionContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowDynamicPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowDynamicPartition(s)
	}
}

func (s *ShowDynamicPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowDynamicPartition(s)
	}
}

type ShowGrantsForUserContext struct {
	SupportedShowStatementContext
}

func NewShowGrantsForUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowGrantsForUserContext {
	var p = new(ShowGrantsForUserContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowGrantsForUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGrantsForUserContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowGrantsForUserContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(DorisParserGRANTS, 0)
}

func (s *ShowGrantsForUserContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *ShowGrantsForUserContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *ShowGrantsForUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowGrantsForUser(s)
	}
}

func (s *ShowGrantsForUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowGrantsForUser(s)
	}
}

type ShowViewContext struct {
	SupportedShowStatementContext
	tableName IMultipartIdentifierContext
	database  IIdentifierContext
}

func NewShowViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowViewContext {
	var p = new(ShowViewContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowViewContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowViewContext) GetDatabase() IIdentifierContext { return s.database }

func (s *ShowViewContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowViewContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *ShowViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowViewContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *ShowViewContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(DorisParserFROM)
}

func (s *ShowViewContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, i)
}

func (s *ShowViewContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserIN)
}

func (s *ShowViewContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserIN, i)
}

func (s *ShowViewContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowViewContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowView(s)
	}
}

func (s *ShowViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowView(s)
	}
}

type ShowAuthorsContext struct {
	SupportedShowStatementContext
}

func NewShowAuthorsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAuthorsContext {
	var p = new(ShowAuthorsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowAuthorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAuthorsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowAuthorsContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTHORS, 0)
}

func (s *ShowAuthorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowAuthors(s)
	}
}

func (s *ShowAuthorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowAuthors(s)
	}
}

type ShowStorageEnginesContext struct {
	SupportedShowStatementContext
}

func NewShowStorageEnginesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStorageEnginesContext {
	var p = new(ShowStorageEnginesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowStorageEnginesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStorageEnginesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowStorageEnginesContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(DorisParserENGINES, 0)
}

func (s *ShowStorageEnginesContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *ShowStorageEnginesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowStorageEngines(s)
	}
}

func (s *ShowStorageEnginesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowStorageEngines(s)
	}
}

type ShowWarningErrorsContext struct {
	SupportedShowStatementContext
}

func NewShowWarningErrorsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowWarningErrorsContext {
	var p = new(ShowWarningErrorsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowWarningErrorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWarningErrorsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowWarningErrorsContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(DorisParserWARNINGS, 0)
}

func (s *ShowWarningErrorsContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(DorisParserERRORS, 0)
}

func (s *ShowWarningErrorsContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowWarningErrorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowWarningErrors(s)
	}
}

func (s *ShowWarningErrorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowWarningErrors(s)
	}
}

type ShowCatalogsContext struct {
	SupportedShowStatementContext
}

func NewShowCatalogsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCatalogsContext {
	var p = new(ShowCatalogsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCatalogsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCatalogsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCatalogsContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOGS, 0)
}

func (s *ShowCatalogsContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowCatalogsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCatalogs(s)
	}
}

func (s *ShowCatalogsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCatalogs(s)
	}
}

type ShowRolesContext struct {
	SupportedShowStatementContext
}

func NewShowRolesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRolesContext {
	var p = new(ShowRolesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowRolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRolesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowRolesContext) ROLES() antlr.TerminalNode {
	return s.GetToken(DorisParserROLES, 0)
}

func (s *ShowRolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowRoles(s)
	}
}

func (s *ShowRolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowRoles(s)
	}
}

type ShowTabletsBelongContext struct {
	SupportedShowStatementContext
	_INTEGER_VALUE antlr.Token
	tabletIds      []antlr.Token
}

func NewShowTabletsBelongContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTabletsBelongContext {
	var p = new(ShowTabletsBelongContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTabletsBelongContext) Get_INTEGER_VALUE() antlr.Token { return s._INTEGER_VALUE }

func (s *ShowTabletsBelongContext) Set_INTEGER_VALUE(v antlr.Token) { s._INTEGER_VALUE = v }

func (s *ShowTabletsBelongContext) GetTabletIds() []antlr.Token { return s.tabletIds }

func (s *ShowTabletsBelongContext) SetTabletIds(v []antlr.Token) { s.tabletIds = v }

func (s *ShowTabletsBelongContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTabletsBelongContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTabletsBelongContext) TABLETS() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLETS, 0)
}

func (s *ShowTabletsBelongContext) BELONG() antlr.TerminalNode {
	return s.GetToken(DorisParserBELONG, 0)
}

func (s *ShowTabletsBelongContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserINTEGER_VALUE)
}

func (s *ShowTabletsBelongContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, i)
}

func (s *ShowTabletsBelongContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ShowTabletsBelongContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ShowTabletsBelongContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTabletsBelong(s)
	}
}

func (s *ShowTabletsBelongContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTabletsBelong(s)
	}
}

type ShowTriggersContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowTriggersContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTriggersContext {
	var p = new(ShowTriggersContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTriggersContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowTriggersContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowTriggersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTriggersContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTriggersContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(DorisParserTRIGGERS, 0)
}

func (s *ShowTriggersContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserFULL, 0)
}

func (s *ShowTriggersContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowTriggersContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowTriggersContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowTriggersContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowTriggersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTriggers(s)
	}
}

func (s *ShowTriggersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTriggers(s)
	}
}

type ShowCreateTableContext struct {
	SupportedShowStatementContext
	name IMultipartIdentifierContext
}

func NewShowCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateTableContext {
	var p = new(ShowCreateTableContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCreateTableContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *ShowCreateTableContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *ShowCreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateTableContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowCreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *ShowCreateTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateTableContext) BRIEF() antlr.TerminalNode {
	return s.GetToken(DorisParserBRIEF, 0)
}

func (s *ShowCreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCreateTable(s)
	}
}

func (s *ShowCreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCreateTable(s)
	}
}

type ShowCatalogContext struct {
	SupportedShowStatementContext
	name IIdentifierContext
}

func NewShowCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCatalogContext {
	var p = new(ShowCatalogContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCatalogContext) GetName() IIdentifierContext { return s.name }

func (s *ShowCatalogContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ShowCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCatalogContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCatalogContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *ShowCatalogContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCatalogContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCatalog(s)
	}
}

func (s *ShowCatalogContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCatalog(s)
	}
}

type ShowVariablesContext struct {
	SupportedShowStatementContext
}

func NewShowVariablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowVariablesContext {
	var p = new(ShowVariablesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowVariablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowVariablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowVariablesContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserVARIABLES, 0)
}

func (s *ShowVariablesContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowVariablesContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *ShowVariablesContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION, 0)
}

func (s *ShowVariablesContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *ShowVariablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowVariables(s)
	}
}

func (s *ShowVariablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowVariables(s)
	}
}

type ShowSyncJobContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowSyncJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSyncJobContext {
	var p = new(ShowSyncJobContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowSyncJobContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowSyncJobContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowSyncJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSyncJobContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowSyncJobContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DorisParserSYNC, 0)
}

func (s *ShowSyncJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *ShowSyncJobContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowSyncJobContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowSyncJobContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowSyncJobContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowSyncJob(s)
	}
}

func (s *ShowSyncJobContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowSyncJob(s)
	}
}

type ShowEventsContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowEventsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowEventsContext {
	var p = new(ShowEventsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowEventsContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowEventsContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowEventsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowEventsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowEventsContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEVENTS, 0)
}

func (s *ShowEventsContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowEventsContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowEventsContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowEventsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowEventsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowEvents(s)
	}
}

func (s *ShowEventsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowEvents(s)
	}
}

type ShowPluginsContext struct {
	SupportedShowStatementContext
}

func NewShowPluginsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowPluginsContext {
	var p = new(ShowPluginsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowPluginsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPluginsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowPluginsContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(DorisParserPLUGINS, 0)
}

func (s *ShowPluginsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowPlugins(s)
	}
}

func (s *ShowPluginsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowPlugins(s)
	}
}

type ShowAllPropertiesContext struct {
	SupportedShowStatementContext
}

func NewShowAllPropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAllPropertiesContext {
	var p = new(ShowAllPropertiesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowAllPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAllPropertiesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowAllPropertiesContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *ShowAllPropertiesContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *ShowAllPropertiesContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *ShowAllPropertiesContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowAllPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowAllProperties(s)
	}
}

func (s *ShowAllPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowAllProperties(s)
	}
}

type ShowDataSkewContext struct {
	SupportedShowStatementContext
}

func NewShowDataSkewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDataSkewContext {
	var p = new(ShowDataSkewContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowDataSkewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDataSkewContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowDataSkewContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserDATA, 0)
}

func (s *ShowDataSkewContext) SKEW() antlr.TerminalNode {
	return s.GetToken(DorisParserSKEW, 0)
}

func (s *ShowDataSkewContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowDataSkewContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *ShowDataSkewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowDataSkew(s)
	}
}

func (s *ShowDataSkewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowDataSkew(s)
	}
}

type ShowConvertLscContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowConvertLscContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowConvertLscContext {
	var p = new(ShowConvertLscContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowConvertLscContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowConvertLscContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowConvertLscContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowConvertLscContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowConvertLscContext) CONVERT_LSC() antlr.TerminalNode {
	return s.GetToken(DorisParserCONVERT_LSC, 0)
}

func (s *ShowConvertLscContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowConvertLscContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowConvertLscContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowConvertLscContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowConvertLsc(s)
	}
}

func (s *ShowConvertLscContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowConvertLsc(s)
	}
}

type ShowSqlBlockRuleContext struct {
	SupportedShowStatementContext
	ruleName IIdentifierContext
}

func NewShowSqlBlockRuleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSqlBlockRuleContext {
	var p = new(ShowSqlBlockRuleContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowSqlBlockRuleContext) GetRuleName() IIdentifierContext { return s.ruleName }

func (s *ShowSqlBlockRuleContext) SetRuleName(v IIdentifierContext) { s.ruleName = v }

func (s *ShowSqlBlockRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSqlBlockRuleContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowSqlBlockRuleContext) SQL_BLOCK_RULE() antlr.TerminalNode {
	return s.GetToken(DorisParserSQL_BLOCK_RULE, 0)
}

func (s *ShowSqlBlockRuleContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *ShowSqlBlockRuleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowSqlBlockRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowSqlBlockRule(s)
	}
}

func (s *ShowSqlBlockRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowSqlBlockRule(s)
	}
}

type ShowTableCreationContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowTableCreationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTableCreationContext {
	var p = new(ShowTableCreationContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTableCreationContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowTableCreationContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowTableCreationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTableCreationContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTableCreationContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *ShowTableCreationContext) CREATION() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATION, 0)
}

func (s *ShowTableCreationContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *ShowTableCreationContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowTableCreationContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowTableCreationContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowTableCreationContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowTableCreationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTableCreation(s)
	}
}

func (s *ShowTableCreationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTableCreation(s)
	}
}

type ShowWarningErrorCountContext struct {
	SupportedShowStatementContext
}

func NewShowWarningErrorCountContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowWarningErrorCountContext {
	var p = new(ShowWarningErrorCountContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowWarningErrorCountContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWarningErrorCountContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowWarningErrorCountContext) COUNT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOUNT, 0)
}

func (s *ShowWarningErrorCountContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ShowWarningErrorCountContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserASTERISK, 0)
}

func (s *ShowWarningErrorCountContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ShowWarningErrorCountContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(DorisParserWARNINGS, 0)
}

func (s *ShowWarningErrorCountContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(DorisParserERRORS, 0)
}

func (s *ShowWarningErrorCountContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowWarningErrorCount(s)
	}
}

func (s *ShowWarningErrorCountContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowWarningErrorCount(s)
	}
}

type ShowDeleteContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowDeleteContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDeleteContext {
	var p = new(ShowDeleteContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowDeleteContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowDeleteContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowDeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDeleteContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowDeleteContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisParserDELETE, 0)
}

func (s *ShowDeleteContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowDeleteContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowDeleteContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowDeleteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowDelete(s)
	}
}

func (s *ShowDeleteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowDelete(s)
	}
}

type ShowStagesContext struct {
	SupportedShowStatementContext
}

func NewShowStagesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStagesContext {
	var p = new(ShowStagesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowStagesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStagesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowStagesContext) STAGES() antlr.TerminalNode {
	return s.GetToken(DorisParserSTAGES, 0)
}

func (s *ShowStagesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowStages(s)
	}
}

func (s *ShowStagesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowStages(s)
	}
}

type ShowBrokerContext struct {
	SupportedShowStatementContext
}

func NewShowBrokerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowBrokerContext {
	var p = new(ShowBrokerContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowBrokerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBrokerContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowBrokerContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserBROKER, 0)
}

func (s *ShowBrokerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowBroker(s)
	}
}

func (s *ShowBrokerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowBroker(s)
	}
}

type ShowGrantsContext struct {
	SupportedShowStatementContext
}

func NewShowGrantsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowGrantsContext {
	var p = new(ShowGrantsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowGrantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGrantsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowGrantsContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(DorisParserGRANTS, 0)
}

func (s *ShowGrantsContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *ShowGrantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowGrants(s)
	}
}

func (s *ShowGrantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowGrants(s)
	}
}

type ShowReplicaDistributionContext struct {
	SupportedShowStatementContext
}

func NewShowReplicaDistributionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowReplicaDistributionContext {
	var p = new(ShowReplicaDistributionContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowReplicaDistributionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowReplicaDistributionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowReplicaDistributionContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLICA, 0)
}

func (s *ShowReplicaDistributionContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTRIBUTION, 0)
}

func (s *ShowReplicaDistributionContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowReplicaDistributionContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *ShowReplicaDistributionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowReplicaDistribution(s)
	}
}

func (s *ShowReplicaDistributionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowReplicaDistribution(s)
	}
}

type ShowTabletStorageFormatContext struct {
	SupportedShowStatementContext
}

func NewShowTabletStorageFormatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTabletStorageFormatContext {
	var p = new(ShowTabletStorageFormatContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTabletStorageFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTabletStorageFormatContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTabletStorageFormatContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLET, 0)
}

func (s *ShowTabletStorageFormatContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *ShowTabletStorageFormatContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DorisParserFORMAT, 0)
}

func (s *ShowTabletStorageFormatContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserVERBOSE, 0)
}

func (s *ShowTabletStorageFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTabletStorageFormat(s)
	}
}

func (s *ShowTabletStorageFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTabletStorageFormat(s)
	}
}

type ShowCharsetContext struct {
	SupportedShowStatementContext
}

func NewShowCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCharsetContext {
	var p = new(ShowCharsetContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCharsetContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCharsetContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(DorisParserCHARSET, 0)
}

func (s *ShowCharsetContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserCHAR, 0)
}

func (s *ShowCharsetContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *ShowCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCharset(s)
	}
}

func (s *ShowCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCharset(s)
	}
}

type ShowProcContext struct {
	SupportedShowStatementContext
	path antlr.Token
}

func NewShowProcContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowProcContext {
	var p = new(ShowProcContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowProcContext) GetPath() antlr.Token { return s.path }

func (s *ShowProcContext) SetPath(v antlr.Token) { s.path = v }

func (s *ShowProcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProcContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowProcContext) PROC() antlr.TerminalNode {
	return s.GetToken(DorisParserPROC, 0)
}

func (s *ShowProcContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowProcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowProc(s)
	}
}

func (s *ShowProcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowProc(s)
	}
}

type ShowCreateViewContext struct {
	SupportedShowStatementContext
	name IMultipartIdentifierContext
}

func NewShowCreateViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateViewContext {
	var p = new(ShowCreateViewContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCreateViewContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *ShowCreateViewContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *ShowCreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateViewContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCreateViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowCreateViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *ShowCreateViewContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCreateView(s)
	}
}

func (s *ShowCreateViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCreateView(s)
	}
}

type ShowCreateDatabaseContext struct {
	SupportedShowStatementContext
	name IMultipartIdentifierContext
}

func NewShowCreateDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateDatabaseContext {
	var p = new(ShowCreateDatabaseContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCreateDatabaseContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *ShowCreateDatabaseContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *ShowCreateDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateDatabaseContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCreateDatabaseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowCreateDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *ShowCreateDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEMA, 0)
}

func (s *ShowCreateDatabaseContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCreateDatabase(s)
	}
}

func (s *ShowCreateDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCreateDatabase(s)
	}
}

type ShowQueryProfileContext struct {
	SupportedShowStatementContext
	queryIdPath antlr.Token
}

func NewShowQueryProfileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowQueryProfileContext {
	var p = new(ShowQueryProfileContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowQueryProfileContext) GetQueryIdPath() antlr.Token { return s.queryIdPath }

func (s *ShowQueryProfileContext) SetQueryIdPath(v antlr.Token) { s.queryIdPath = v }

func (s *ShowQueryProfileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowQueryProfileContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowQueryProfileContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DorisParserQUERY, 0)
}

func (s *ShowQueryProfileContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserPROFILE, 0)
}

func (s *ShowQueryProfileContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowQueryProfileContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowQueryProfileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowQueryProfile(s)
	}
}

func (s *ShowQueryProfileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowQueryProfile(s)
	}
}

type ShowEncryptKeysContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowEncryptKeysContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowEncryptKeysContext {
	var p = new(ShowEncryptKeysContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowEncryptKeysContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowEncryptKeysContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowEncryptKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowEncryptKeysContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowEncryptKeysContext) ENCRYPTKEYS() antlr.TerminalNode {
	return s.GetToken(DorisParserENCRYPTKEYS, 0)
}

func (s *ShowEncryptKeysContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *ShowEncryptKeysContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowEncryptKeysContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowEncryptKeysContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowEncryptKeysContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowEncryptKeysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowEncryptKeys(s)
	}
}

func (s *ShowEncryptKeysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowEncryptKeys(s)
	}
}

type ShowTrashContext struct {
	SupportedShowStatementContext
	backend antlr.Token
}

func NewShowTrashContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTrashContext {
	var p = new(ShowTrashContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTrashContext) GetBackend() antlr.Token { return s.backend }

func (s *ShowTrashContext) SetBackend(v antlr.Token) { s.backend = v }

func (s *ShowTrashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTrashContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTrashContext) TRASH() antlr.TerminalNode {
	return s.GetToken(DorisParserTRASH, 0)
}

func (s *ShowTrashContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *ShowTrashContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowTrashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTrash(s)
	}
}

func (s *ShowTrashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTrash(s)
	}
}

type ShowFrontendsContext struct {
	SupportedShowStatementContext
	name IIdentifierContext
}

func NewShowFrontendsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowFrontendsContext {
	var p = new(ShowFrontendsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowFrontendsContext) GetName() IIdentifierContext { return s.name }

func (s *ShowFrontendsContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ShowFrontendsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFrontendsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowFrontendsContext) FRONTENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserFRONTENDS, 0)
}

func (s *ShowFrontendsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowFrontendsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowFrontends(s)
	}
}

func (s *ShowFrontendsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowFrontends(s)
	}
}

type ShowLoadProfileContext struct {
	SupportedShowStatementContext
	loadIdPath antlr.Token
}

func NewShowLoadProfileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowLoadProfileContext {
	var p = new(ShowLoadProfileContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowLoadProfileContext) GetLoadIdPath() antlr.Token { return s.loadIdPath }

func (s *ShowLoadProfileContext) SetLoadIdPath(v antlr.Token) { s.loadIdPath = v }

func (s *ShowLoadProfileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowLoadProfileContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowLoadProfileContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *ShowLoadProfileContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserPROFILE, 0)
}

func (s *ShowLoadProfileContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowLoadProfileContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowLoadProfileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowLoadProfile(s)
	}
}

func (s *ShowLoadProfileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowLoadProfile(s)
	}
}

type ShowPartitionIdContext struct {
	SupportedShowStatementContext
	partitionId antlr.Token
}

func NewShowPartitionIdContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowPartitionIdContext {
	var p = new(ShowPartitionIdContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowPartitionIdContext) GetPartitionId() antlr.Token { return s.partitionId }

func (s *ShowPartitionIdContext) SetPartitionId(v antlr.Token) { s.partitionId = v }

func (s *ShowPartitionIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPartitionIdContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowPartitionIdContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *ShowPartitionIdContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ShowPartitionIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowPartitionId(s)
	}
}

func (s *ShowPartitionIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowPartitionId(s)
	}
}

type ShowCollationContext struct {
	SupportedShowStatementContext
}

func NewShowCollationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCollationContext {
	var p = new(ShowCollationContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCollationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCollationContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCollationContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLLATION, 0)
}

func (s *ShowCollationContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowCollationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCollation(s)
	}
}

func (s *ShowCollationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCollation(s)
	}
}

type ShowBackendsContext struct {
	SupportedShowStatementContext
}

func NewShowBackendsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowBackendsContext {
	var p = new(ShowBackendsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowBackendsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBackendsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowBackendsContext) BACKENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKENDS, 0)
}

func (s *ShowBackendsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowBackends(s)
	}
}

func (s *ShowBackendsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowBackends(s)
	}
}

type ShowPrivilegesContext struct {
	SupportedShowStatementContext
}

func NewShowPrivilegesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowPrivilegesContext {
	var p = new(ShowPrivilegesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowPrivilegesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPrivilegesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowPrivilegesContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(DorisParserPRIVILEGES, 0)
}

func (s *ShowPrivilegesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowPrivileges(s)
	}
}

func (s *ShowPrivilegesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowPrivileges(s)
	}
}

type ShowTableIdContext struct {
	SupportedShowStatementContext
	tableId antlr.Token
}

func NewShowTableIdContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTableIdContext {
	var p = new(ShowTableIdContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTableIdContext) GetTableId() antlr.Token { return s.tableId }

func (s *ShowTableIdContext) SetTableId(v antlr.Token) { s.tableId = v }

func (s *ShowTableIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTableIdContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTableIdContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *ShowTableIdContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ShowTableIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTableId(s)
	}
}

func (s *ShowTableIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTableId(s)
	}
}

type ShowSmallFilesContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowSmallFilesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSmallFilesContext {
	var p = new(ShowSmallFilesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowSmallFilesContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowSmallFilesContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowSmallFilesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSmallFilesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowSmallFilesContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisParserFILE, 0)
}

func (s *ShowSmallFilesContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowSmallFilesContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowSmallFilesContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowSmallFilesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowSmallFiles(s)
	}
}

func (s *ShowSmallFilesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowSmallFiles(s)
	}
}

type ShowStatusContext struct {
	SupportedShowStatementContext
}

func NewShowStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStatusContext {
	var p = new(ShowStatusContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatusContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATUS, 0)
}

func (s *ShowStatusContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *ShowStatusContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION, 0)
}

func (s *ShowStatusContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *ShowStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowStatus(s)
	}
}

func (s *ShowStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowStatus(s)
	}
}

type ShowUserPropertiesContext struct {
	SupportedShowStatementContext
	user IIdentifierOrTextContext
}

func NewShowUserPropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowUserPropertiesContext {
	var p = new(ShowUserPropertiesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowUserPropertiesContext) GetUser() IIdentifierOrTextContext { return s.user }

func (s *ShowUserPropertiesContext) SetUser(v IIdentifierOrTextContext) { s.user = v }

func (s *ShowUserPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowUserPropertiesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowUserPropertiesContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTY, 0)
}

func (s *ShowUserPropertiesContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *ShowUserPropertiesContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *ShowUserPropertiesContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowUserPropertiesContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *ShowUserPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowUserProperties(s)
	}
}

func (s *ShowUserPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowUserProperties(s)
	}
}

type ShowLastInsertContext struct {
	SupportedShowStatementContext
}

func NewShowLastInsertContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowLastInsertContext {
	var p = new(ShowLastInsertContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowLastInsertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowLastInsertContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowLastInsertContext) LAST() antlr.TerminalNode {
	return s.GetToken(DorisParserLAST, 0)
}

func (s *ShowLastInsertContext) INSERT() antlr.TerminalNode {
	return s.GetToken(DorisParserINSERT, 0)
}

func (s *ShowLastInsertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowLastInsert(s)
	}
}

func (s *ShowLastInsertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowLastInsert(s)
	}
}

type ShowCreateCatalogContext struct {
	SupportedShowStatementContext
	name IIdentifierContext
}

func NewShowCreateCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateCatalogContext {
	var p = new(ShowCreateCatalogContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCreateCatalogContext) GetName() IIdentifierContext { return s.name }

func (s *ShowCreateCatalogContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ShowCreateCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateCatalogContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCreateCatalogContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowCreateCatalogContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *ShowCreateCatalogContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateCatalogContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCreateCatalog(s)
	}
}

func (s *ShowCreateCatalogContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCreateCatalog(s)
	}
}

type ShowCreateMaterializedViewContext struct {
	SupportedShowStatementContext
	mvName    IIdentifierContext
	tableName IMultipartIdentifierContext
}

func NewShowCreateMaterializedViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateMaterializedViewContext {
	var p = new(ShowCreateMaterializedViewContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCreateMaterializedViewContext) GetMvName() IIdentifierContext { return s.mvName }

func (s *ShowCreateMaterializedViewContext) GetTableName() IMultipartIdentifierContext {
	return s.tableName
}

func (s *ShowCreateMaterializedViewContext) SetMvName(v IIdentifierContext) { s.mvName = v }

func (s *ShowCreateMaterializedViewContext) SetTableName(v IMultipartIdentifierContext) {
	s.tableName = v
}

func (s *ShowCreateMaterializedViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateMaterializedViewContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCreateMaterializedViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowCreateMaterializedViewContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *ShowCreateMaterializedViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *ShowCreateMaterializedViewContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *ShowCreateMaterializedViewContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateMaterializedViewContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateMaterializedViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCreateMaterializedView(s)
	}
}

func (s *ShowCreateMaterializedViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCreateMaterializedView(s)
	}
}

type ShowProcessListContext struct {
	SupportedShowStatementContext
}

func NewShowProcessListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowProcessListContext {
	var p = new(ShowProcessListContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowProcessListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProcessListContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowProcessListContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(DorisParserPROCESSLIST, 0)
}

func (s *ShowProcessListContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserFULL, 0)
}

func (s *ShowProcessListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowProcessList(s)
	}
}

func (s *ShowProcessListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowProcessList(s)
	}
}

type ShowDataTypesContext struct {
	SupportedShowStatementContext
}

func NewShowDataTypesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDataTypesContext {
	var p = new(ShowDataTypesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowDataTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDataTypesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowDataTypesContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserDATA, 0)
}

func (s *ShowDataTypesContext) TYPES() antlr.TerminalNode {
	return s.GetToken(DorisParserTYPES, 0)
}

func (s *ShowDataTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowDataTypes(s)
	}
}

func (s *ShowDataTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowDataTypes(s)
	}
}

type ShowDiagnoseTabletContext struct {
	SupportedShowStatementContext
	tabletId antlr.Token
}

func NewShowDiagnoseTabletContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDiagnoseTabletContext {
	var p = new(ShowDiagnoseTabletContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowDiagnoseTabletContext) GetTabletId() antlr.Token { return s.tabletId }

func (s *ShowDiagnoseTabletContext) SetTabletId(v antlr.Token) { s.tabletId = v }

func (s *ShowDiagnoseTabletContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDiagnoseTabletContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowDiagnoseTabletContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLET, 0)
}

func (s *ShowDiagnoseTabletContext) DIAGNOSIS() antlr.TerminalNode {
	return s.GetToken(DorisParserDIAGNOSIS, 0)
}

func (s *ShowDiagnoseTabletContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ShowDiagnoseTabletContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowDiagnoseTablet(s)
	}
}

func (s *ShowDiagnoseTabletContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowDiagnoseTablet(s)
	}
}

type ShowWhitelistContext struct {
	SupportedShowStatementContext
}

func NewShowWhitelistContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowWhitelistContext {
	var p = new(ShowWhitelistContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowWhitelistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWhitelistContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowWhitelistContext) WHITELIST() antlr.TerminalNode {
	return s.GetToken(DorisParserWHITELIST, 0)
}

func (s *ShowWhitelistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowWhitelist(s)
	}
}

func (s *ShowWhitelistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowWhitelist(s)
	}
}

type ShowDatabaseIdContext struct {
	SupportedShowStatementContext
	databaseId antlr.Token
}

func NewShowDatabaseIdContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDatabaseIdContext {
	var p = new(ShowDatabaseIdContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowDatabaseIdContext) GetDatabaseId() antlr.Token { return s.databaseId }

func (s *ShowDatabaseIdContext) SetDatabaseId(v antlr.Token) { s.databaseId = v }

func (s *ShowDatabaseIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDatabaseIdContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowDatabaseIdContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *ShowDatabaseIdContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ShowDatabaseIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowDatabaseId(s)
	}
}

func (s *ShowDatabaseIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowDatabaseId(s)
	}
}

type ShowCreateRepositoryContext struct {
	SupportedShowStatementContext
}

func NewShowCreateRepositoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateRepositoryContext {
	var p = new(ShowCreateRepositoryContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCreateRepositoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateRepositoryContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCreateRepositoryContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowCreateRepositoryContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisParserREPOSITORY, 0)
}

func (s *ShowCreateRepositoryContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *ShowCreateRepositoryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateRepositoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCreateRepository(s)
	}
}

func (s *ShowCreateRepositoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCreateRepository(s)
	}
}

func (p *DorisParser) SupportedShowStatement() (localctx ISupportedShowStatementContext) {
	localctx = NewSupportedShowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, DorisParserRULE_supportedShowStatement)
	var _la int

	p.SetState(1708)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext()) {
	case 1:
		localctx = NewShowVariablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1411)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1413)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION {
			{
				p.SetState(1412)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1415)
			p.Match(DorisParserVARIABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1417)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(1416)
				p.WildWhere()
			}

		}

	case 2:
		localctx = NewShowAuthorsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1419)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1420)
			p.Match(DorisParserAUTHORS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewShowCreateDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1421)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1422)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1423)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserDATABASE || _la == DorisParserSCHEMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1424)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateDatabaseContext).name = _x
		}

	case 4:
		localctx = NewShowBrokerContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1425)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1426)
			p.Match(DorisParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewShowDynamicPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1427)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1428)
			p.Match(DorisParserDYNAMIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1429)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1430)
			p.Match(DorisParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1433)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1431)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1432)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowDynamicPartitionContext).database = _x
			}

		}

	case 6:
		localctx = NewShowEventsContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1435)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1436)
			p.Match(DorisParserEVENTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1439)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1437)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1438)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowEventsContext).database = _x
			}

		}
		p.SetState(1442)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(1441)
				p.WildWhere()
			}

		}

	case 7:
		localctx = NewShowLastInsertContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1444)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1445)
			p.Match(DorisParserLAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1446)
			p.Match(DorisParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewShowCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1447)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1451)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserCHAR:
			{
				p.SetState(1448)
				p.Match(DorisParserCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1449)
				p.Match(DorisParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCHARSET:
			{
				p.SetState(1450)
				p.Match(DorisParserCHARSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 9:
		localctx = NewShowDeleteContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1453)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1454)
			p.Match(DorisParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1457)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1455)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1456)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowDeleteContext).database = _x
			}

		}

	case 10:
		localctx = NewShowGrantsContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1459)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1461)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserALL {
			{
				p.SetState(1460)
				p.Match(DorisParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1463)
			p.Match(DorisParserGRANTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewShowGrantsForUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1464)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1465)
			p.Match(DorisParserGRANTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1466)
			p.Match(DorisParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1467)
			p.UserIdentify()
		}

	case 12:
		localctx = NewShowSyncJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1468)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1469)
			p.Match(DorisParserSYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1470)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1473)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1471)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1472)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowSyncJobContext).database = _x
			}

		}

	case 13:
		localctx = NewShowLoadProfileContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1475)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1476)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1477)
			p.Match(DorisParserPROFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1479)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserSTRING_LITERAL {
			{
				p.SetState(1478)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*ShowLoadProfileContext).loadIdPath = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1482)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIMIT {
			{
				p.SetState(1481)
				p.LimitClause()
			}

		}

	case 14:
		localctx = NewShowCreateRepositoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1484)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1485)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1486)
			p.Match(DorisParserREPOSITORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1487)
			p.Match(DorisParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1488)
			p.Identifier()
		}

	case 15:
		localctx = NewShowViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1489)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1490)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1491)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserFROM || _la == DorisParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1492)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowViewContext).tableName = _x
		}
		p.SetState(1495)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1493)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1494)

				var _x = p.Identifier()

				localctx.(*ShowViewContext).database = _x
			}

		}

	case 16:
		localctx = NewShowPluginsContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1497)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1498)
			p.Match(DorisParserPLUGINS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		localctx = NewShowRepositoriesContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1499)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1500)
			p.Match(DorisParserREPOSITORIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		localctx = NewShowEncryptKeysContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1501)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1502)
			p.Match(DorisParserENCRYPTKEYS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1505)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1503)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1504)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowEncryptKeysContext).database = _x
			}

		}
		p.SetState(1509)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE {
			{
				p.SetState(1507)
				p.Match(DorisParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1508)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 19:
		localctx = NewShowCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1511)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1513)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserBRIEF {
			{
				p.SetState(1512)
				p.Match(DorisParserBRIEF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1515)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1516)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1517)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateTableContext).name = _x
		}

	case 20:
		localctx = NewShowProcessListContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1518)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1520)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFULL {
			{
				p.SetState(1519)
				p.Match(DorisParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1522)
			p.Match(DorisParserPROCESSLIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		localctx = NewShowRolesContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1523)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1524)
			p.Match(DorisParserROLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 22:
		localctx = NewShowPartitionIdContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1525)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1526)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1527)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*ShowPartitionIdContext).partitionId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		localctx = NewShowPrivilegesContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1528)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1529)
			p.Match(DorisParserPRIVILEGES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		localctx = NewShowProcContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1530)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1531)
			p.Match(DorisParserPROC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1532)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ShowProcContext).path = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 25:
		localctx = NewShowSmallFilesContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1533)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1534)
			p.Match(DorisParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1537)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1535)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1536)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowSmallFilesContext).database = _x
			}

		}

	case 26:
		localctx = NewShowStorageEnginesContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1539)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1541)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserSTORAGE {
			{
				p.SetState(1540)
				p.Match(DorisParserSTORAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1543)
			p.Match(DorisParserENGINES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 27:
		localctx = NewShowCreateCatalogContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1544)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1545)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1546)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1547)

			var _x = p.Identifier()

			localctx.(*ShowCreateCatalogContext).name = _x
		}

	case 28:
		localctx = NewShowCatalogContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1548)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1549)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1550)

			var _x = p.Identifier()

			localctx.(*ShowCatalogContext).name = _x
		}

	case 29:
		localctx = NewShowCatalogsContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1551)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1552)
			p.Match(DorisParserCATALOGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1554)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(1553)
				p.WildWhere()
			}

		}

	case 30:
		localctx = NewShowUserPropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1556)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1557)
			p.Match(DorisParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1560)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFOR {
			{
				p.SetState(1558)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1559)

				var _x = p.IdentifierOrText()

				localctx.(*ShowUserPropertiesContext).user = _x
			}

		}
		p.SetState(1564)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE {
			{
				p.SetState(1562)
				p.Match(DorisParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1563)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 31:
		localctx = NewShowAllPropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(1566)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1567)
			p.Match(DorisParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1568)
			p.Match(DorisParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1571)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE {
			{
				p.SetState(1569)
				p.Match(DorisParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1570)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 32:
		localctx = NewShowCollationContext(p, localctx)
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(1573)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1574)
			p.Match(DorisParserCOLLATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1576)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(1575)
				p.WildWhere()
			}

		}

	case 33:
		localctx = NewShowSqlBlockRuleContext(p, localctx)
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(1578)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1579)
			p.Match(DorisParserSQL_BLOCK_RULE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1582)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFOR {
			{
				p.SetState(1580)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1581)

				var _x = p.Identifier()

				localctx.(*ShowSqlBlockRuleContext).ruleName = _x
			}

		}

	case 34:
		localctx = NewShowCreateViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(1584)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1585)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1586)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1587)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateViewContext).name = _x
		}

	case 35:
		localctx = NewShowDataTypesContext(p, localctx)
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(1588)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1589)
			p.Match(DorisParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1590)
			p.Match(DorisParserTYPES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 36:
		localctx = NewShowCreateMaterializedViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(1591)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1592)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1593)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1594)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1595)

			var _x = p.Identifier()

			localctx.(*ShowCreateMaterializedViewContext).mvName = _x
		}
		{
			p.SetState(1596)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1597)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateMaterializedViewContext).tableName = _x
		}

	case 37:
		localctx = NewShowWarningErrorsContext(p, localctx)
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(1599)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1600)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserERRORS || _la == DorisParserWARNINGS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1602)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIMIT {
			{
				p.SetState(1601)
				p.LimitClause()
			}

		}

	case 38:
		localctx = NewShowWarningErrorCountContext(p, localctx)
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(1604)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1605)
			p.Match(DorisParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1606)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1607)
			p.Match(DorisParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1608)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1609)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserERRORS || _la == DorisParserWARNINGS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 39:
		localctx = NewShowBackendsContext(p, localctx)
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(1610)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1611)
			p.Match(DorisParserBACKENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 40:
		localctx = NewShowStagesContext(p, localctx)
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(1612)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1613)
			p.Match(DorisParserSTAGES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 41:
		localctx = NewShowReplicaDistributionContext(p, localctx)
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(1614)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1615)
			p.Match(DorisParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1616)
			p.Match(DorisParserDISTRIBUTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1617)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1618)
			p.BaseTableRef()
		}

	case 42:
		localctx = NewShowTriggersContext(p, localctx)
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(1619)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1621)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFULL {
			{
				p.SetState(1620)
				p.Match(DorisParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1623)
			p.Match(DorisParserTRIGGERS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1626)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1624)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1625)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowTriggersContext).database = _x
			}

		}
		p.SetState(1629)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(1628)
				p.WildWhere()
			}

		}

	case 43:
		localctx = NewShowDiagnoseTabletContext(p, localctx)
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(1631)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1632)
			p.Match(DorisParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1633)
			p.Match(DorisParserDIAGNOSIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1634)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*ShowDiagnoseTabletContext).tabletId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 44:
		localctx = NewShowFrontendsContext(p, localctx)
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(1635)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1636)
			p.Match(DorisParserFRONTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1638)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8646881558152553984) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&3026312906716208575) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-6232424940973963725) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&3937129999880936915) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-2873958502894674957) != 0) || ((int64((_la-322)) & ^0x3f) == 0 && ((int64(1)<<(_la-322))&6912752233721878527) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&-2627780018309275847) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&150083289320141) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&49159) != 0) {
			{
				p.SetState(1637)

				var _x = p.Identifier()

				localctx.(*ShowFrontendsContext).name = _x
			}

		}

	case 45:
		localctx = NewShowDatabaseIdContext(p, localctx)
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(1640)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1641)
			p.Match(DorisParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1642)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*ShowDatabaseIdContext).databaseId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 46:
		localctx = NewShowTableIdContext(p, localctx)
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(1643)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1644)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1645)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*ShowTableIdContext).tableId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 47:
		localctx = NewShowTrashContext(p, localctx)
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(1646)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1647)
			p.Match(DorisParserTRASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1650)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserON {
			{
				p.SetState(1648)
				p.Match(DorisParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1649)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*ShowTrashContext).backend = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 48:
		localctx = NewShowStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(1652)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1654)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION {
			{
				p.SetState(1653)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1656)
			p.Match(DorisParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 49:
		localctx = NewShowWhitelistContext(p, localctx)
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(1657)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1658)
			p.Match(DorisParserWHITELIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 50:
		localctx = NewShowTabletsBelongContext(p, localctx)
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(1659)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1660)
			p.Match(DorisParserTABLETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1661)
			p.Match(DorisParserBELONG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1662)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*ShowTabletsBelongContext)._INTEGER_VALUE = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ShowTabletsBelongContext).tabletIds = append(localctx.(*ShowTabletsBelongContext).tabletIds, localctx.(*ShowTabletsBelongContext)._INTEGER_VALUE)
		p.SetState(1667)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(1663)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1664)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*ShowTabletsBelongContext)._INTEGER_VALUE = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*ShowTabletsBelongContext).tabletIds = append(localctx.(*ShowTabletsBelongContext).tabletIds, localctx.(*ShowTabletsBelongContext)._INTEGER_VALUE)

			p.SetState(1669)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 51:
		localctx = NewShowDataSkewContext(p, localctx)
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(1670)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1671)
			p.Match(DorisParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1672)
			p.Match(DorisParserSKEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1673)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1674)
			p.BaseTableRef()
		}

	case 52:
		localctx = NewShowTableCreationContext(p, localctx)
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(1675)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1676)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1677)
			p.Match(DorisParserCREATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1680)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1678)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1679)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowTableCreationContext).database = _x
			}

		}
		p.SetState(1684)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE {
			{
				p.SetState(1682)
				p.Match(DorisParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1683)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 53:
		localctx = NewShowTabletStorageFormatContext(p, localctx)
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(1686)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1687)
			p.Match(DorisParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1688)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1689)
			p.Match(DorisParserFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1691)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserVERBOSE {
			{
				p.SetState(1690)
				p.Match(DorisParserVERBOSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 54:
		localctx = NewShowQueryProfileContext(p, localctx)
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(1693)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1694)
			p.Match(DorisParserQUERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1695)
			p.Match(DorisParserPROFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1697)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserSTRING_LITERAL {
			{
				p.SetState(1696)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*ShowQueryProfileContext).queryIdPath = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1700)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIMIT {
			{
				p.SetState(1699)
				p.LimitClause()
			}

		}

	case 55:
		localctx = NewShowConvertLscContext(p, localctx)
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(1702)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1703)
			p.Match(DorisParserCONVERT_LSC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1706)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1704)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1705)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowConvertLscContext).database = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedLoadStatementContext is an interface to support dynamic dispatch.
type ISupportedLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedLoadStatementContext differentiates from other interfaces.
	IsSupportedLoadStatementContext()
}

type SupportedLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedLoadStatementContext() *SupportedLoadStatementContext {
	var p = new(SupportedLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedLoadStatement
	return p
}

func InitEmptySupportedLoadStatementContext(p *SupportedLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedLoadStatement
}

func (*SupportedLoadStatementContext) IsSupportedLoadStatementContext() {}

func NewSupportedLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedLoadStatementContext {
	var p = new(SupportedLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedLoadStatement

	return p
}

func (s *SupportedLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedLoadStatementContext) CopyAll(ctx *SupportedLoadStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CreateRoutineLoadAliasContext struct {
	SupportedLoadStatementContext
}

func NewCreateRoutineLoadAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateRoutineLoadAliasContext {
	var p = new(CreateRoutineLoadAliasContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *CreateRoutineLoadAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoutineLoadAliasContext) CreateRoutineLoad() ICreateRoutineLoadContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRoutineLoadContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRoutineLoadContext)
}

func (s *CreateRoutineLoadAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateRoutineLoadAlias(s)
	}
}

func (s *CreateRoutineLoadAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateRoutineLoadAlias(s)
	}
}

type SyncContext struct {
	SupportedLoadStatementContext
}

func NewSyncContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SyncContext {
	var p = new(SyncContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *SyncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyncContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DorisParserSYNC, 0)
}

func (s *SyncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSync(s)
	}
}

func (s *SyncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSync(s)
	}
}

func (p *DorisParser) SupportedLoadStatement() (localctx ISupportedLoadStatementContext) {
	localctx = NewSupportedLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, DorisParserRULE_supportedLoadStatement)
	p.SetState(1712)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserSYNC:
		localctx = NewSyncContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1710)
			p.Match(DorisParserSYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserCREATE:
		localctx = NewCreateRoutineLoadAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1711)
			p.CreateRoutineLoad()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedOtherStatementContext is an interface to support dynamic dispatch.
type ISupportedOtherStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedOtherStatementContext differentiates from other interfaces.
	IsSupportedOtherStatementContext()
}

type SupportedOtherStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedOtherStatementContext() *SupportedOtherStatementContext {
	var p = new(SupportedOtherStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedOtherStatement
	return p
}

func InitEmptySupportedOtherStatementContext(p *SupportedOtherStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedOtherStatement
}

func (*SupportedOtherStatementContext) IsSupportedOtherStatementContext() {}

func NewSupportedOtherStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedOtherStatementContext {
	var p = new(SupportedOtherStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedOtherStatement

	return p
}

func (s *SupportedOtherStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedOtherStatementContext) CopyAll(ctx *SupportedOtherStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedOtherStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedOtherStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type HelpContext struct {
	SupportedOtherStatementContext
	mark IIdentifierOrTextContext
}

func NewHelpContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HelpContext {
	var p = new(HelpContext)

	InitEmptySupportedOtherStatementContext(&p.SupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedOtherStatementContext))

	return p
}

func (s *HelpContext) GetMark() IIdentifierOrTextContext { return s.mark }

func (s *HelpContext) SetMark(v IIdentifierOrTextContext) { s.mark = v }

func (s *HelpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelpContext) HELP() antlr.TerminalNode {
	return s.GetToken(DorisParserHELP, 0)
}

func (s *HelpContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *HelpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterHelp(s)
	}
}

func (s *HelpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitHelp(s)
	}
}

func (p *DorisParser) SupportedOtherStatement() (localctx ISupportedOtherStatementContext) {
	localctx = NewSupportedOtherStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, DorisParserRULE_supportedOtherStatement)
	localctx = NewHelpContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1714)
		p.Match(DorisParserHELP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1715)

		var _x = p.IdentifierOrText()

		localctx.(*HelpContext).mark = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedOtherStatementContext is an interface to support dynamic dispatch.
type IUnsupportedOtherStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedOtherStatementContext differentiates from other interfaces.
	IsUnsupportedOtherStatementContext()
}

type UnsupportedOtherStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedOtherStatementContext() *UnsupportedOtherStatementContext {
	var p = new(UnsupportedOtherStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedOtherStatement
	return p
}

func InitEmptyUnsupportedOtherStatementContext(p *UnsupportedOtherStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedOtherStatement
}

func (*UnsupportedOtherStatementContext) IsUnsupportedOtherStatementContext() {}

func NewUnsupportedOtherStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedOtherStatementContext {
	var p = new(UnsupportedOtherStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedOtherStatement

	return p
}

func (s *UnsupportedOtherStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedOtherStatementContext) CopyAll(ctx *UnsupportedOtherStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedOtherStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedOtherStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UninstallPluginContext struct {
	UnsupportedOtherStatementContext
	name IIdentifierOrTextContext
}

func NewUninstallPluginContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UninstallPluginContext {
	var p = new(UninstallPluginContext)

	InitEmptyUnsupportedOtherStatementContext(&p.UnsupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedOtherStatementContext))

	return p
}

func (s *UninstallPluginContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *UninstallPluginContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *UninstallPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UninstallPluginContext) UNINSTALL() antlr.TerminalNode {
	return s.GetToken(DorisParserUNINSTALL, 0)
}

func (s *UninstallPluginContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(DorisParserPLUGIN, 0)
}

func (s *UninstallPluginContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *UninstallPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUninstallPlugin(s)
	}
}

func (s *UninstallPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUninstallPlugin(s)
	}
}

type UnlockTablesContext struct {
	UnsupportedOtherStatementContext
}

func NewUnlockTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnlockTablesContext {
	var p = new(UnlockTablesContext)

	InitEmptyUnsupportedOtherStatementContext(&p.UnsupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedOtherStatementContext))

	return p
}

func (s *UnlockTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnlockTablesContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(DorisParserUNLOCK, 0)
}

func (s *UnlockTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLES, 0)
}

func (s *UnlockTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUnlockTables(s)
	}
}

func (s *UnlockTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUnlockTables(s)
	}
}

type BackupContext struct {
	UnsupportedOtherStatementContext
	label      IMultipartIdentifierContext
	repo       IIdentifierContext
	properties IPropertyClauseContext
}

func NewBackupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BackupContext {
	var p = new(BackupContext)

	InitEmptyUnsupportedOtherStatementContext(&p.UnsupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedOtherStatementContext))

	return p
}

func (s *BackupContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *BackupContext) GetRepo() IIdentifierContext { return s.repo }

func (s *BackupContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *BackupContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *BackupContext) SetRepo(v IIdentifierContext) { s.repo = v }

func (s *BackupContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *BackupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackupContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKUP, 0)
}

func (s *BackupContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisParserSNAPSHOT, 0)
}

func (s *BackupContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *BackupContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *BackupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BackupContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *BackupContext) AllBaseTableRef() []IBaseTableRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			len++
		}
	}

	tst := make([]IBaseTableRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBaseTableRefContext); ok {
			tst[i] = t.(IBaseTableRefContext)
			i++
		}
	}

	return tst
}

func (s *BackupContext) BaseTableRef(i int) IBaseTableRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *BackupContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *BackupContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *BackupContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(DorisParserEXCLUDE, 0)
}

func (s *BackupContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *BackupContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *BackupContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *BackupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBackup(s)
	}
}

func (s *BackupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBackup(s)
	}
}

type LockTablesContext struct {
	UnsupportedOtherStatementContext
}

func NewLockTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LockTablesContext {
	var p = new(LockTablesContext)

	InitEmptyUnsupportedOtherStatementContext(&p.UnsupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedOtherStatementContext))

	return p
}

func (s *LockTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockTablesContext) LOCK() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCK, 0)
}

func (s *LockTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLES, 0)
}

func (s *LockTablesContext) AllLockTable() []ILockTableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILockTableContext); ok {
			len++
		}
	}

	tst := make([]ILockTableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILockTableContext); ok {
			tst[i] = t.(ILockTableContext)
			i++
		}
	}

	return tst
}

func (s *LockTablesContext) LockTable(i int) ILockTableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockTableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockTableContext)
}

func (s *LockTablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *LockTablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *LockTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLockTables(s)
	}
}

func (s *LockTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLockTables(s)
	}
}

type RestoreContext struct {
	UnsupportedOtherStatementContext
	label      IMultipartIdentifierContext
	repo       IIdentifierContext
	properties IPropertyClauseContext
}

func NewRestoreContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RestoreContext {
	var p = new(RestoreContext)

	InitEmptyUnsupportedOtherStatementContext(&p.UnsupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedOtherStatementContext))

	return p
}

func (s *RestoreContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *RestoreContext) GetRepo() IIdentifierContext { return s.repo }

func (s *RestoreContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *RestoreContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *RestoreContext) SetRepo(v IIdentifierContext) { s.repo = v }

func (s *RestoreContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *RestoreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RestoreContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESTORE, 0)
}

func (s *RestoreContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisParserSNAPSHOT, 0)
}

func (s *RestoreContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *RestoreContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *RestoreContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RestoreContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *RestoreContext) AllBaseTableRef() []IBaseTableRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			len++
		}
	}

	tst := make([]IBaseTableRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBaseTableRefContext); ok {
			tst[i] = t.(IBaseTableRefContext)
			i++
		}
	}

	return tst
}

func (s *RestoreContext) BaseTableRef(i int) IBaseTableRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *RestoreContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *RestoreContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *RestoreContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(DorisParserEXCLUDE, 0)
}

func (s *RestoreContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *RestoreContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *RestoreContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *RestoreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRestore(s)
	}
}

func (s *RestoreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRestore(s)
	}
}

type InstallPluginContext struct {
	UnsupportedOtherStatementContext
	source     IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewInstallPluginContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InstallPluginContext {
	var p = new(InstallPluginContext)

	InitEmptyUnsupportedOtherStatementContext(&p.UnsupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedOtherStatementContext))

	return p
}

func (s *InstallPluginContext) GetSource() IIdentifierOrTextContext { return s.source }

func (s *InstallPluginContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *InstallPluginContext) SetSource(v IIdentifierOrTextContext) { s.source = v }

func (s *InstallPluginContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *InstallPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstallPluginContext) INSTALL() antlr.TerminalNode {
	return s.GetToken(DorisParserINSTALL, 0)
}

func (s *InstallPluginContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(DorisParserPLUGIN, 0)
}

func (s *InstallPluginContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *InstallPluginContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *InstallPluginContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *InstallPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterInstallPlugin(s)
	}
}

func (s *InstallPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitInstallPlugin(s)
	}
}

type WarmUpClusterContext struct {
	UnsupportedOtherStatementContext
	destination IIdentifierContext
	source      IIdentifierContext
}

func NewWarmUpClusterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WarmUpClusterContext {
	var p = new(WarmUpClusterContext)

	InitEmptyUnsupportedOtherStatementContext(&p.UnsupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedOtherStatementContext))

	return p
}

func (s *WarmUpClusterContext) GetDestination() IIdentifierContext { return s.destination }

func (s *WarmUpClusterContext) GetSource() IIdentifierContext { return s.source }

func (s *WarmUpClusterContext) SetDestination(v IIdentifierContext) { s.destination = v }

func (s *WarmUpClusterContext) SetSource(v IIdentifierContext) { s.source = v }

func (s *WarmUpClusterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WarmUpClusterContext) WARM() antlr.TerminalNode {
	return s.GetToken(DorisParserWARM, 0)
}

func (s *WarmUpClusterContext) UP() antlr.TerminalNode {
	return s.GetToken(DorisParserUP, 0)
}

func (s *WarmUpClusterContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *WarmUpClusterContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *WarmUpClusterContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WarmUpClusterContext) AllCLUSTER() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCLUSTER)
}

func (s *WarmUpClusterContext) CLUSTER(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCLUSTER, i)
}

func (s *WarmUpClusterContext) AllCOMPUTE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMPUTE)
}

func (s *WarmUpClusterContext) COMPUTE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPUTE, i)
}

func (s *WarmUpClusterContext) AllGROUP() []antlr.TerminalNode {
	return s.GetTokens(DorisParserGROUP)
}

func (s *WarmUpClusterContext) GROUP(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserGROUP, i)
}

func (s *WarmUpClusterContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserFORCE, 0)
}

func (s *WarmUpClusterContext) AllWarmUpItem() []IWarmUpItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWarmUpItemContext); ok {
			len++
		}
	}

	tst := make([]IWarmUpItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWarmUpItemContext); ok {
			tst[i] = t.(IWarmUpItemContext)
			i++
		}
	}

	return tst
}

func (s *WarmUpClusterContext) WarmUpItem(i int) IWarmUpItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWarmUpItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWarmUpItemContext)
}

func (s *WarmUpClusterContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(DorisParserAND)
}

func (s *WarmUpClusterContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserAND, i)
}

func (s *WarmUpClusterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWarmUpCluster(s)
	}
}

func (s *WarmUpClusterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWarmUpCluster(s)
	}
}

type UnsupportedStartTransactionContext struct {
	UnsupportedOtherStatementContext
}

func NewUnsupportedStartTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnsupportedStartTransactionContext {
	var p = new(UnsupportedStartTransactionContext)

	InitEmptyUnsupportedOtherStatementContext(&p.UnsupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedOtherStatementContext))

	return p
}

func (s *UnsupportedStartTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedStartTransactionContext) START() antlr.TerminalNode {
	return s.GetToken(DorisParserSTART, 0)
}

func (s *UnsupportedStartTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisParserTRANSACTION, 0)
}

func (s *UnsupportedStartTransactionContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *UnsupportedStartTransactionContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCONSISTENT, 0)
}

func (s *UnsupportedStartTransactionContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisParserSNAPSHOT, 0)
}

func (s *UnsupportedStartTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUnsupportedStartTransaction(s)
	}
}

func (s *UnsupportedStartTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUnsupportedStartTransaction(s)
	}
}

func (p *DorisParser) UnsupportedOtherStatement() (localctx IUnsupportedOtherStatementContext) {
	localctx = NewUnsupportedOtherStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, DorisParserRULE_unsupportedOtherStatement)
	var _la int

	p.SetState(1820)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserINSTALL:
		localctx = NewInstallPluginContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1717)
			p.Match(DorisParserINSTALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1718)
			p.Match(DorisParserPLUGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1719)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1720)

			var _x = p.IdentifierOrText()

			localctx.(*InstallPluginContext).source = _x
		}
		p.SetState(1722)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1721)

				var _x = p.PropertyClause()

				localctx.(*InstallPluginContext).properties = _x
			}

		}

	case DorisParserUNINSTALL:
		localctx = NewUninstallPluginContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1724)
			p.Match(DorisParserUNINSTALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1725)
			p.Match(DorisParserPLUGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1726)

			var _x = p.IdentifierOrText()

			localctx.(*UninstallPluginContext).name = _x
		}

	case DorisParserLOCK:
		localctx = NewLockTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1727)
			p.Match(DorisParserLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1728)
			p.Match(DorisParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1737)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8646881558152553984) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&3026312906716208575) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-6232424940973963725) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&3937129999880936915) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-2873958502894674957) != 0) || ((int64((_la-322)) & ^0x3f) == 0 && ((int64(1)<<(_la-322))&6912752233721878527) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&-2627780018309275847) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&150083289320141) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&49159) != 0) {
			{
				p.SetState(1729)
				p.LockTable()
			}
			p.SetState(1734)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(1730)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1731)
					p.LockTable()
				}

				p.SetState(1736)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}

	case DorisParserUNLOCK:
		localctx = NewUnlockTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1739)
			p.Match(DorisParserUNLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1740)
			p.Match(DorisParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserWARM:
		localctx = NewWarmUpClusterContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1741)
			p.Match(DorisParserWARM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1742)
			p.Match(DorisParserUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1746)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserCLUSTER:
			{
				p.SetState(1743)
				p.Match(DorisParserCLUSTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCOMPUTE:
			{
				p.SetState(1744)
				p.Match(DorisParserCOMPUTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1745)
				p.Match(DorisParserGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(1748)

			var _x = p.Identifier()

			localctx.(*WarmUpClusterContext).destination = _x
		}
		{
			p.SetState(1749)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1764)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserCLUSTER, DorisParserCOMPUTE:
			p.SetState(1753)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserCLUSTER:
				{
					p.SetState(1750)
					p.Match(DorisParserCLUSTER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case DorisParserCOMPUTE:
				{
					p.SetState(1751)
					p.Match(DorisParserCOMPUTE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1752)
					p.Match(DorisParserGROUP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			{
				p.SetState(1755)

				var _x = p.Identifier()

				localctx.(*WarmUpClusterContext).source = _x
			}

		case DorisParserTABLE:
			{
				p.SetState(1756)
				p.WarmUpItem()
			}
			p.SetState(1761)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserAND {
				{
					p.SetState(1757)
					p.Match(DorisParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1758)
					p.WarmUpItem()
				}

				p.SetState(1763)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(1767)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFORCE {
			{
				p.SetState(1766)
				p.Match(DorisParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DorisParserBACKUP:
		localctx = NewBackupContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1769)
			p.Match(DorisParserBACKUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1770)
			p.Match(DorisParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1771)

			var _x = p.MultipartIdentifier()

			localctx.(*BackupContext).label = _x
		}
		{
			p.SetState(1772)
			p.Match(DorisParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1773)

			var _x = p.Identifier()

			localctx.(*BackupContext).repo = _x
		}
		p.SetState(1786)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserEXCLUDE || _la == DorisParserON {
			{
				p.SetState(1774)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserEXCLUDE || _la == DorisParserON) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1775)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1776)
				p.BaseTableRef()
			}
			p.SetState(1781)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(1777)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1778)
					p.BaseTableRef()
				}

				p.SetState(1783)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1784)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1789)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1788)

				var _x = p.PropertyClause()

				localctx.(*BackupContext).properties = _x
			}

		}

	case DorisParserRESTORE:
		localctx = NewRestoreContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1791)
			p.Match(DorisParserRESTORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1792)
			p.Match(DorisParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1793)

			var _x = p.MultipartIdentifier()

			localctx.(*RestoreContext).label = _x
		}
		{
			p.SetState(1794)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1795)

			var _x = p.Identifier()

			localctx.(*RestoreContext).repo = _x
		}
		p.SetState(1808)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserEXCLUDE || _la == DorisParserON {
			{
				p.SetState(1796)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserEXCLUDE || _la == DorisParserON) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1797)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1798)
				p.BaseTableRef()
			}
			p.SetState(1803)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(1799)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1800)
					p.BaseTableRef()
				}

				p.SetState(1805)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1806)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1811)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1810)

				var _x = p.PropertyClause()

				localctx.(*RestoreContext).properties = _x
			}

		}

	case DorisParserSTART:
		localctx = NewUnsupportedStartTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1813)
			p.Match(DorisParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1814)
			p.Match(DorisParserTRANSACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1818)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(1815)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1816)
				p.Match(DorisParserCONSISTENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1817)
				p.Match(DorisParserSNAPSHOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWarmUpItemContext is an interface to support dynamic dispatch.
type IWarmUpItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTableName returns the tableName rule contexts.
	GetTableName() IMultipartIdentifierContext

	// GetPartitionName returns the partitionName rule contexts.
	GetPartitionName() IIdentifierContext

	// SetTableName sets the tableName rule contexts.
	SetTableName(IMultipartIdentifierContext)

	// SetPartitionName sets the partitionName rule contexts.
	SetPartitionName(IIdentifierContext)

	// Getter signatures
	TABLE() antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsWarmUpItemContext differentiates from other interfaces.
	IsWarmUpItemContext()
}

type WarmUpItemContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	tableName     IMultipartIdentifierContext
	partitionName IIdentifierContext
}

func NewEmptyWarmUpItemContext() *WarmUpItemContext {
	var p = new(WarmUpItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_warmUpItem
	return p
}

func InitEmptyWarmUpItemContext(p *WarmUpItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_warmUpItem
}

func (*WarmUpItemContext) IsWarmUpItemContext() {}

func NewWarmUpItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WarmUpItemContext {
	var p = new(WarmUpItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_warmUpItem

	return p
}

func (s *WarmUpItemContext) GetParser() antlr.Parser { return s.parser }

func (s *WarmUpItemContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *WarmUpItemContext) GetPartitionName() IIdentifierContext { return s.partitionName }

func (s *WarmUpItemContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *WarmUpItemContext) SetPartitionName(v IIdentifierContext) { s.partitionName = v }

func (s *WarmUpItemContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *WarmUpItemContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *WarmUpItemContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *WarmUpItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WarmUpItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WarmUpItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WarmUpItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWarmUpItem(s)
	}
}

func (s *WarmUpItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWarmUpItem(s)
	}
}

func (p *DorisParser) WarmUpItem() (localctx IWarmUpItemContext) {
	localctx = NewWarmUpItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, DorisParserRULE_warmUpItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1822)
		p.Match(DorisParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1823)

		var _x = p.MultipartIdentifier()

		localctx.(*WarmUpItemContext).tableName = _x
	}
	p.SetState(1826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPARTITION {
		{
			p.SetState(1824)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1825)

			var _x = p.Identifier()

			localctx.(*WarmUpItemContext).partitionName = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockTableContext is an interface to support dynamic dispatch.
type ILockTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IMultipartIdentifierContext

	// GetAlias returns the alias rule contexts.
	GetAlias() IIdentifierOrTextContext

	// SetName sets the name rule contexts.
	SetName(IMultipartIdentifierContext)

	// SetAlias sets the alias rule contexts.
	SetAlias(IIdentifierOrTextContext)

	// Getter signatures
	MultipartIdentifier() IMultipartIdentifierContext
	READ() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	AS() antlr.TerminalNode
	IdentifierOrText() IIdentifierOrTextContext
	LOCAL() antlr.TerminalNode
	LOW_PRIORITY() antlr.TerminalNode

	// IsLockTableContext differentiates from other interfaces.
	IsLockTableContext()
}

type LockTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IMultipartIdentifierContext
	alias  IIdentifierOrTextContext
}

func NewEmptyLockTableContext() *LockTableContext {
	var p = new(LockTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_lockTable
	return p
}

func InitEmptyLockTableContext(p *LockTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_lockTable
}

func (*LockTableContext) IsLockTableContext() {}

func NewLockTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockTableContext {
	var p = new(LockTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_lockTable

	return p
}

func (s *LockTableContext) GetParser() antlr.Parser { return s.parser }

func (s *LockTableContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *LockTableContext) GetAlias() IIdentifierOrTextContext { return s.alias }

func (s *LockTableContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *LockTableContext) SetAlias(v IIdentifierOrTextContext) { s.alias = v }

func (s *LockTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *LockTableContext) READ() antlr.TerminalNode {
	return s.GetToken(DorisParserREAD, 0)
}

func (s *LockTableContext) WRITE() antlr.TerminalNode {
	return s.GetToken(DorisParserWRITE, 0)
}

func (s *LockTableContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *LockTableContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *LockTableContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *LockTableContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(DorisParserLOW_PRIORITY, 0)
}

func (s *LockTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLockTable(s)
	}
}

func (s *LockTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLockTable(s)
	}
}

func (p *DorisParser) LockTable() (localctx ILockTableContext) {
	localctx = NewLockTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, DorisParserRULE_lockTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1828)

		var _x = p.MultipartIdentifier()

		localctx.(*LockTableContext).name = _x
	}
	p.SetState(1831)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserAS {
		{
			p.SetState(1829)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1830)

			var _x = p.IdentifierOrText()

			localctx.(*LockTableContext).alias = _x
		}

	}
	p.SetState(1841)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserREAD:
		{
			p.SetState(1833)
			p.Match(DorisParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1835)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLOCAL {
			{
				p.SetState(1834)
				p.Match(DorisParserLOCAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DorisParserLOW_PRIORITY, DorisParserWRITE:
		p.SetState(1838)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLOW_PRIORITY {
			{
				p.SetState(1837)
				p.Match(DorisParserLOW_PRIORITY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1840)
			p.Match(DorisParserWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedShowStatementContext is an interface to support dynamic dispatch.
type IUnsupportedShowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedShowStatementContext differentiates from other interfaces.
	IsUnsupportedShowStatementContext()
}

type UnsupportedShowStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedShowStatementContext() *UnsupportedShowStatementContext {
	var p = new(UnsupportedShowStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedShowStatement
	return p
}

func InitEmptyUnsupportedShowStatementContext(p *UnsupportedShowStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedShowStatement
}

func (*UnsupportedShowStatementContext) IsUnsupportedShowStatementContext() {}

func NewUnsupportedShowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedShowStatementContext {
	var p = new(UnsupportedShowStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedShowStatement

	return p
}

func (s *UnsupportedShowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedShowStatementContext) CopyAll(ctx *UnsupportedShowStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedShowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedShowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowOpenTablesContext struct {
	UnsupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowOpenTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowOpenTablesContext {
	var p = new(ShowOpenTablesContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowOpenTablesContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowOpenTablesContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowOpenTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowOpenTablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowOpenTablesContext) OPEN() antlr.TerminalNode {
	return s.GetToken(DorisParserOPEN, 0)
}

func (s *ShowOpenTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLES, 0)
}

func (s *ShowOpenTablesContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowOpenTablesContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowOpenTablesContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowOpenTablesContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowOpenTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowOpenTables(s)
	}
}

func (s *ShowOpenTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowOpenTables(s)
	}
}

type ShowQueryStatsContext struct {
	UnsupportedShowStatementContext
	database  IIdentifierContext
	tableName IMultipartIdentifierContext
}

func NewShowQueryStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowQueryStatsContext {
	var p = new(ShowQueryStatsContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowQueryStatsContext) GetDatabase() IIdentifierContext { return s.database }

func (s *ShowQueryStatsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowQueryStatsContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *ShowQueryStatsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowQueryStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowQueryStatsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowQueryStatsContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DorisParserQUERY, 0)
}

func (s *ShowQueryStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *ShowQueryStatsContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *ShowQueryStatsContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowQueryStatsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowQueryStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowQueryStatsContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *ShowQueryStatsContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserVERBOSE, 0)
}

func (s *ShowQueryStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowQueryStats(s)
	}
}

func (s *ShowQueryStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowQueryStats(s)
	}
}

type ShowDataContext struct {
	UnsupportedShowStatementContext
	tableName IMultipartIdentifierContext
}

func NewShowDataContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDataContext {
	var p = new(ShowDataContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowDataContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowDataContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDataContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowDataContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserDATA, 0)
}

func (s *ShowDataContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *ShowDataContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowDataContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowDataContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ShowDataContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowData(s)
	}
}

func (s *ShowDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowData(s)
	}
}

type ShowIndexContext struct {
	UnsupportedShowStatementContext
	tableName IMultipartIdentifierContext
	database  IMultipartIdentifierContext
}

func NewShowIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowIndexContext {
	var p = new(ShowIndexContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowIndexContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowIndexContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowIndexContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowIndexContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowIndexContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowIndexContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserKEY, 0)
}

func (s *ShowIndexContext) KEYS() antlr.TerminalNode {
	return s.GetToken(DorisParserKEYS, 0)
}

func (s *ShowIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *ShowIndexContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEXES, 0)
}

func (s *ShowIndexContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(DorisParserFROM)
}

func (s *ShowIndexContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, i)
}

func (s *ShowIndexContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserIN)
}

func (s *ShowIndexContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserIN, i)
}

func (s *ShowIndexContext) AllMultipartIdentifier() []IMultipartIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultipartIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipartIdentifierContext); ok {
			tst[i] = t.(IMultipartIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ShowIndexContext) MultipartIdentifier(i int) IMultipartIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowIndex(s)
	}
}

func (s *ShowIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowIndex(s)
	}
}

type ShowStoragePolicyContext struct {
	UnsupportedShowStatementContext
	policy IIdentifierOrTextContext
}

func NewShowStoragePolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStoragePolicyContext {
	var p = new(ShowStoragePolicyContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowStoragePolicyContext) GetPolicy() IIdentifierOrTextContext { return s.policy }

func (s *ShowStoragePolicyContext) SetPolicy(v IIdentifierOrTextContext) { s.policy = v }

func (s *ShowStoragePolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStoragePolicyContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowStoragePolicyContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *ShowStoragePolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *ShowStoragePolicyContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserUSING, 0)
}

func (s *ShowStoragePolicyContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *ShowStoragePolicyContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *ShowStoragePolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowStoragePolicy(s)
	}
}

func (s *ShowStoragePolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowStoragePolicy(s)
	}
}

type ShowTableStatusContext struct {
	UnsupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowTableStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTableStatusContext {
	var p = new(ShowTableStatusContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowTableStatusContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowTableStatusContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowTableStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTableStatusContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTableStatusContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *ShowTableStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATUS, 0)
}

func (s *ShowTableStatusContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowTableStatusContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowTableStatusContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowTableStatusContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowTableStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTableStatus(s)
	}
}

func (s *ShowTableStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTableStatus(s)
	}
}

type ShowBackupContext struct {
	UnsupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowBackupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowBackupContext {
	var p = new(ShowBackupContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowBackupContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowBackupContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowBackupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBackupContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowBackupContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKUP, 0)
}

func (s *ShowBackupContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowBackupContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowBackupContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowBackupContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowBackupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowBackup(s)
	}
}

func (s *ShowBackupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowBackup(s)
	}
}

type ShowLoadContext struct {
	UnsupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowLoadContext {
	var p = new(ShowLoadContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowLoadContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowLoadContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowLoadContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *ShowLoadContext) STREAM() antlr.TerminalNode {
	return s.GetToken(DorisParserSTREAM, 0)
}

func (s *ShowLoadContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowLoadContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowLoadContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowLoadContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowLoadContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowLoad(s)
	}
}

func (s *ShowLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowLoad(s)
	}
}

type ShowClustersContext struct {
	UnsupportedShowStatementContext
}

func NewShowClustersContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowClustersContext {
	var p = new(ShowClustersContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowClustersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowClustersContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowClustersContext) CLUSTERS() antlr.TerminalNode {
	return s.GetToken(DorisParserCLUSTERS, 0)
}

func (s *ShowClustersContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPUTE, 0)
}

func (s *ShowClustersContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUPS, 0)
}

func (s *ShowClustersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowClusters(s)
	}
}

func (s *ShowClustersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowClusters(s)
	}
}

type ShowCreateFunctionContext struct {
	UnsupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowCreateFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateFunctionContext {
	var p = new(ShowCreateFunctionContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowCreateFunctionContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowCreateFunctionContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowCreateFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateFunctionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCreateFunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowCreateFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserFUNCTION, 0)
}

func (s *ShowCreateFunctionContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *ShowCreateFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ShowCreateFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ShowCreateFunctionContext) FunctionArguments() IFunctionArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgumentsContext)
}

func (s *ShowCreateFunctionContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *ShowCreateFunctionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION, 0)
}

func (s *ShowCreateFunctionContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *ShowCreateFunctionContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowCreateFunctionContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowCreateFunctionContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCreateFunction(s)
	}
}

func (s *ShowCreateFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCreateFunction(s)
	}
}

type ShowPartitionsContext struct {
	UnsupportedShowStatementContext
	tableName IMultipartIdentifierContext
}

func NewShowPartitionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowPartitionsContext {
	var p = new(ShowPartitionsContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowPartitionsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowPartitionsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowPartitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPartitionsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowPartitionsContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITIONS, 0)
}

func (s *ShowPartitionsContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowPartitionsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowPartitionsContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *ShowPartitionsContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowPartitionsContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowPartitionsContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowPartitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowPartitions(s)
	}
}

func (s *ShowPartitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowPartitions(s)
	}
}

type ShowCacheHotSpotContext struct {
	UnsupportedShowStatementContext
	tablePath antlr.Token
}

func NewShowCacheHotSpotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCacheHotSpotContext {
	var p = new(ShowCacheHotSpotContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowCacheHotSpotContext) GetTablePath() antlr.Token { return s.tablePath }

func (s *ShowCacheHotSpotContext) SetTablePath(v antlr.Token) { s.tablePath = v }

func (s *ShowCacheHotSpotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCacheHotSpotContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCacheHotSpotContext) CACHE() antlr.TerminalNode {
	return s.GetToken(DorisParserCACHE, 0)
}

func (s *ShowCacheHotSpotContext) HOTSPOT() antlr.TerminalNode {
	return s.GetToken(DorisParserHOTSPOT, 0)
}

func (s *ShowCacheHotSpotContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowCacheHotSpotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCacheHotSpot(s)
	}
}

func (s *ShowCacheHotSpotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCacheHotSpot(s)
	}
}

type ShowTablesContext struct {
	UnsupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTablesContext {
	var p = new(ShowTablesContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowTablesContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowTablesContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLES, 0)
}

func (s *ShowTablesContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserFULL, 0)
}

func (s *ShowTablesContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowTablesContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowTablesContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowTablesContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTables(s)
	}
}

func (s *ShowTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTables(s)
	}
}

type ShowGlobalFunctionsContext struct {
	UnsupportedShowStatementContext
}

func NewShowGlobalFunctionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowGlobalFunctionsContext {
	var p = new(ShowGlobalFunctionsContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowGlobalFunctionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGlobalFunctionsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowGlobalFunctionsContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *ShowGlobalFunctionsContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserFUNCTIONS, 0)
}

func (s *ShowGlobalFunctionsContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserFULL, 0)
}

func (s *ShowGlobalFunctionsContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowGlobalFunctionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowGlobalFunctions(s)
	}
}

func (s *ShowGlobalFunctionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowGlobalFunctions(s)
	}
}

type ShowMaterializedViewContext struct {
	UnsupportedShowStatementContext
	name IMultipartIdentifierContext
}

func NewShowMaterializedViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowMaterializedViewContext {
	var p = new(ShowMaterializedViewContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowMaterializedViewContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *ShowMaterializedViewContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *ShowMaterializedViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowMaterializedViewContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowMaterializedViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowMaterializedViewContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *ShowMaterializedViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *ShowMaterializedViewContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowMaterializedViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowMaterializedView(s)
	}
}

func (s *ShowMaterializedViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowMaterializedView(s)
	}
}

type ShowExportContext struct {
	UnsupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowExportContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowExportContext {
	var p = new(ShowExportContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowExportContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowExportContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowExportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowExportContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowExportContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(DorisParserEXPORT, 0)
}

func (s *ShowExportContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowExportContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowExportContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowExportContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowExportContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowExportContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowExportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowExport(s)
	}
}

func (s *ShowExportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowExport(s)
	}
}

type ShowSnapshotContext struct {
	UnsupportedShowStatementContext
	repo IIdentifierContext
}

func NewShowSnapshotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSnapshotContext {
	var p = new(ShowSnapshotContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowSnapshotContext) GetRepo() IIdentifierContext { return s.repo }

func (s *ShowSnapshotContext) SetRepo(v IIdentifierContext) { s.repo = v }

func (s *ShowSnapshotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSnapshotContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowSnapshotContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisParserSNAPSHOT, 0)
}

func (s *ShowSnapshotContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *ShowSnapshotContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowSnapshotContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowSnapshotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowSnapshot(s)
	}
}

func (s *ShowSnapshotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowSnapshot(s)
	}
}

type ShowCatalogRecycleBinContext struct {
	UnsupportedShowStatementContext
}

func NewShowCatalogRecycleBinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCatalogRecycleBinContext {
	var p = new(ShowCatalogRecycleBinContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowCatalogRecycleBinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCatalogRecycleBinContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCatalogRecycleBinContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *ShowCatalogRecycleBinContext) RECYCLE() antlr.TerminalNode {
	return s.GetToken(DorisParserRECYCLE, 0)
}

func (s *ShowCatalogRecycleBinContext) BIN() antlr.TerminalNode {
	return s.GetToken(DorisParserBIN, 0)
}

func (s *ShowCatalogRecycleBinContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowCatalogRecycleBinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCatalogRecycleBin(s)
	}
}

func (s *ShowCatalogRecycleBinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCatalogRecycleBin(s)
	}
}

type ShowCopyContext struct {
	UnsupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowCopyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCopyContext {
	var p = new(ShowCopyContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowCopyContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowCopyContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowCopyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCopyContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCopyContext) COPY() antlr.TerminalNode {
	return s.GetToken(DorisParserCOPY, 0)
}

func (s *ShowCopyContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *ShowCopyContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowCopyContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowCopyContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowCopyContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowCopyContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCopyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCopy(s)
	}
}

func (s *ShowCopyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCopy(s)
	}
}

type ShowRowPolicyContext struct {
	UnsupportedShowStatementContext
	role IIdentifierContext
}

func NewShowRowPolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRowPolicyContext {
	var p = new(ShowRowPolicyContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowRowPolicyContext) GetRole() IIdentifierContext { return s.role }

func (s *ShowRowPolicyContext) SetRole(v IIdentifierContext) { s.role = v }

func (s *ShowRowPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRowPolicyContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowRowPolicyContext) ROW() antlr.TerminalNode {
	return s.GetToken(DorisParserROW, 0)
}

func (s *ShowRowPolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *ShowRowPolicyContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *ShowRowPolicyContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *ShowRowPolicyContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *ShowRowPolicyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowRowPolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowRowPolicy(s)
	}
}

func (s *ShowRowPolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowRowPolicy(s)
	}
}

type ShowTypeCastContext struct {
	UnsupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowTypeCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTypeCastContext {
	var p = new(ShowTypeCastContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowTypeCastContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowTypeCastContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowTypeCastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTypeCastContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTypeCastContext) TYPECAST() antlr.TerminalNode {
	return s.GetToken(DorisParserTYPECAST, 0)
}

func (s *ShowTypeCastContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowTypeCastContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowTypeCastContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowTypeCastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTypeCast(s)
	}
}

func (s *ShowTypeCastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTypeCast(s)
	}
}

type ShowRestoreContext struct {
	UnsupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowRestoreContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRestoreContext {
	var p = new(ShowRestoreContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowRestoreContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowRestoreContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowRestoreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRestoreContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowRestoreContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESTORE, 0)
}

func (s *ShowRestoreContext) BRIEF() antlr.TerminalNode {
	return s.GetToken(DorisParserBRIEF, 0)
}

func (s *ShowRestoreContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowRestoreContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowRestoreContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowRestoreContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowRestoreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowRestore(s)
	}
}

func (s *ShowRestoreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowRestore(s)
	}
}

type ShowLoadWaringsContext struct {
	UnsupportedShowStatementContext
	database IMultipartIdentifierContext
	url      antlr.Token
}

func NewShowLoadWaringsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowLoadWaringsContext {
	var p = new(ShowLoadWaringsContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowLoadWaringsContext) GetUrl() antlr.Token { return s.url }

func (s *ShowLoadWaringsContext) SetUrl(v antlr.Token) { s.url = v }

func (s *ShowLoadWaringsContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowLoadWaringsContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowLoadWaringsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowLoadWaringsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowLoadWaringsContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *ShowLoadWaringsContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(DorisParserWARNINGS, 0)
}

func (s *ShowLoadWaringsContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *ShowLoadWaringsContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowLoadWaringsContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowLoadWaringsContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowLoadWaringsContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowLoadWaringsContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowLoadWaringsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowLoadWaringsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowLoadWarings(s)
	}
}

func (s *ShowLoadWaringsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowLoadWarings(s)
	}
}

type ShowColumnsContext struct {
	UnsupportedShowStatementContext
	tableName IMultipartIdentifierContext
	database  IMultipartIdentifierContext
}

func NewShowColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnsContext {
	var p = new(ShowColumnsContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowColumnsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowColumnsContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowColumnsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowColumnsContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMNS, 0)
}

func (s *ShowColumnsContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(DorisParserFIELDS, 0)
}

func (s *ShowColumnsContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(DorisParserFROM)
}

func (s *ShowColumnsContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, i)
}

func (s *ShowColumnsContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserIN)
}

func (s *ShowColumnsContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserIN, i)
}

func (s *ShowColumnsContext) AllMultipartIdentifier() []IMultipartIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultipartIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipartIdentifierContext); ok {
			tst[i] = t.(IMultipartIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ShowColumnsContext) MultipartIdentifier(i int) IMultipartIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowColumnsContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserFULL, 0)
}

func (s *ShowColumnsContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowColumns(s)
	}
}

func (s *ShowColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowColumns(s)
	}
}

type ShowAlterTableContext struct {
	UnsupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowAlterTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAlterTableContext {
	var p = new(ShowAlterTableContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowAlterTableContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowAlterTableContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowAlterTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAlterTableContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowAlterTableContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *ShowAlterTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *ShowAlterTableContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *ShowAlterTableContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *ShowAlterTableContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowAlterTableContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowAlterTableContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowAlterTableContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *ShowAlterTableContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *ShowAlterTableContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowAlterTableContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowAlterTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowAlterTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowAlterTable(s)
	}
}

func (s *ShowAlterTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowAlterTable(s)
	}
}

type ShowBuildIndexContext struct {
	UnsupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowBuildIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowBuildIndexContext {
	var p = new(ShowBuildIndexContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowBuildIndexContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowBuildIndexContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowBuildIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBuildIndexContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowBuildIndexContext) BUILD() antlr.TerminalNode {
	return s.GetToken(DorisParserBUILD, 0)
}

func (s *ShowBuildIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *ShowBuildIndexContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowBuildIndexContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowBuildIndexContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowBuildIndexContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowBuildIndexContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowBuildIndexContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowBuildIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowBuildIndex(s)
	}
}

func (s *ShowBuildIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowBuildIndex(s)
	}
}

type ShowDatabasesContext struct {
	UnsupportedShowStatementContext
	catalog IIdentifierContext
}

func NewShowDatabasesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDatabasesContext {
	var p = new(ShowDatabasesContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowDatabasesContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *ShowDatabasesContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *ShowDatabasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDatabasesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowDatabasesContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASES, 0)
}

func (s *ShowDatabasesContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEMAS, 0)
}

func (s *ShowDatabasesContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowDatabasesContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowDatabasesContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowDatabasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowDatabases(s)
	}
}

func (s *ShowDatabasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowDatabases(s)
	}
}

type ShowTabletIdContext struct {
	UnsupportedShowStatementContext
	tabletId antlr.Token
}

func NewShowTabletIdContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTabletIdContext {
	var p = new(ShowTabletIdContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowTabletIdContext) GetTabletId() antlr.Token { return s.tabletId }

func (s *ShowTabletIdContext) SetTabletId(v antlr.Token) { s.tabletId = v }

func (s *ShowTabletIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTabletIdContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTabletIdContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLET, 0)
}

func (s *ShowTabletIdContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ShowTabletIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTabletId(s)
	}
}

func (s *ShowTabletIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTabletId(s)
	}
}

type ShowStorageVaultContext struct {
	UnsupportedShowStatementContext
}

func NewShowStorageVaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStorageVaultContext {
	var p = new(ShowStorageVaultContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowStorageVaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStorageVaultContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowStorageVaultContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *ShowStorageVaultContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULT, 0)
}

func (s *ShowStorageVaultContext) VAULTS() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULTS, 0)
}

func (s *ShowStorageVaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowStorageVault(s)
	}
}

func (s *ShowStorageVaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowStorageVault(s)
	}
}

type ShowWarmUpJobContext struct {
	UnsupportedShowStatementContext
}

func NewShowWarmUpJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowWarmUpJobContext {
	var p = new(ShowWarmUpJobContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowWarmUpJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWarmUpJobContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowWarmUpJobContext) WARM() antlr.TerminalNode {
	return s.GetToken(DorisParserWARM, 0)
}

func (s *ShowWarmUpJobContext) UP() antlr.TerminalNode {
	return s.GetToken(DorisParserUP, 0)
}

func (s *ShowWarmUpJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *ShowWarmUpJobContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowWarmUpJobContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowWarmUpJob(s)
	}
}

func (s *ShowWarmUpJobContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowWarmUpJob(s)
	}
}

type ShowReplicaStatusContext struct {
	UnsupportedShowStatementContext
}

func NewShowReplicaStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowReplicaStatusContext {
	var p = new(ShowReplicaStatusContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowReplicaStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowReplicaStatusContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowReplicaStatusContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLICA, 0)
}

func (s *ShowReplicaStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATUS, 0)
}

func (s *ShowReplicaStatusContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowReplicaStatusContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *ShowReplicaStatusContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowReplicaStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowReplicaStatus(s)
	}
}

func (s *ShowReplicaStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowReplicaStatus(s)
	}
}

type ShowTabletsFromTableContext struct {
	UnsupportedShowStatementContext
	tableName IMultipartIdentifierContext
}

func NewShowTabletsFromTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTabletsFromTableContext {
	var p = new(ShowTabletsFromTableContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowTabletsFromTableContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowTabletsFromTableContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowTabletsFromTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTabletsFromTableContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTabletsFromTableContext) TABLETS() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLETS, 0)
}

func (s *ShowTabletsFromTableContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowTabletsFromTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowTabletsFromTableContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *ShowTabletsFromTableContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowTabletsFromTableContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowTabletsFromTableContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowTabletsFromTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTabletsFromTable(s)
	}
}

func (s *ShowTabletsFromTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTabletsFromTable(s)
	}
}

type ShowViewsContext struct {
	UnsupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowViewsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowViewsContext {
	var p = new(ShowViewsContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowViewsContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowViewsContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowViewsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowViewsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowViewsContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEWS, 0)
}

func (s *ShowViewsContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserFULL, 0)
}

func (s *ShowViewsContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowViewsContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowViewsContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowViewsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowViewsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowViews(s)
	}
}

func (s *ShowViewsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowViews(s)
	}
}

type ShowTransactionContext struct {
	UnsupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTransactionContext {
	var p = new(ShowTransactionContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowTransactionContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowTransactionContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTransactionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisParserTRANSACTION, 0)
}

func (s *ShowTransactionContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowTransactionContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowTransactionContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowTransactionContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTransaction(s)
	}
}

func (s *ShowTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTransaction(s)
	}
}

type ShowResourcesContext struct {
	UnsupportedShowStatementContext
}

func NewShowResourcesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowResourcesContext {
	var p = new(ShowResourcesContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowResourcesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowResourcesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowResourcesContext) RESOURCES() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCES, 0)
}

func (s *ShowResourcesContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowResourcesContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowResourcesContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowResourcesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowResources(s)
	}
}

func (s *ShowResourcesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowResources(s)
	}
}

type ShowFunctionsContext struct {
	UnsupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowFunctionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowFunctionsContext {
	var p = new(ShowFunctionsContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowFunctionsContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowFunctionsContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowFunctionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFunctionsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowFunctionsContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserFUNCTIONS, 0)
}

func (s *ShowFunctionsContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserFULL, 0)
}

func (s *ShowFunctionsContext) BUILTIN() antlr.TerminalNode {
	return s.GetToken(DorisParserBUILTIN, 0)
}

func (s *ShowFunctionsContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowFunctionsContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowFunctionsContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowFunctionsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowFunctionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowFunctions(s)
	}
}

func (s *ShowFunctionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowFunctions(s)
	}
}

type ShowWorkloadGroupsContext struct {
	UnsupportedShowStatementContext
}

func NewShowWorkloadGroupsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowWorkloadGroupsContext {
	var p = new(ShowWorkloadGroupsContext)

	InitEmptyUnsupportedShowStatementContext(&p.UnsupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedShowStatementContext))

	return p
}

func (s *ShowWorkloadGroupsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWorkloadGroupsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowWorkloadGroupsContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserWORKLOAD, 0)
}

func (s *ShowWorkloadGroupsContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUPS, 0)
}

func (s *ShowWorkloadGroupsContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowWorkloadGroupsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowWorkloadGroups(s)
	}
}

func (s *ShowWorkloadGroupsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowWorkloadGroups(s)
	}
}

func (p *DorisParser) UnsupportedShowStatement() (localctx IUnsupportedShowStatementContext) {
	localctx = NewUnsupportedShowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, DorisParserRULE_unsupportedShowStatement)
	var _la int

	p.SetState(2247)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 296, p.GetParserRuleContext()) {
	case 1:
		localctx = NewShowRowPolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1843)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1844)
			p.Match(DorisParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1845)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1852)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFOR {
			{
				p.SetState(1846)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1850)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
				{
					p.SetState(1847)
					p.UserIdentify()
				}

			case DorisParserROLE:
				{
					p.SetState(1848)
					p.Match(DorisParserROLE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1849)

					var _x = p.Identifier()

					localctx.(*ShowRowPolicyContext).role = _x
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}

	case 2:
		localctx = NewShowStoragePolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1854)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1855)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1856)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1862)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserUSING {
			{
				p.SetState(1857)
				p.Match(DorisParserUSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1860)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserFOR {
				{
					p.SetState(1858)
					p.Match(DorisParserFOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1859)

					var _x = p.IdentifierOrText()

					localctx.(*ShowStoragePolicyContext).policy = _x
				}

			}

		}

	case 3:
		localctx = NewShowStorageVaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1864)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1865)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1866)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserVAULT || _la == DorisParserVAULTS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 4:
		localctx = NewShowOpenTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1867)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1868)
			p.Match(DorisParserOPEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1869)
			p.Match(DorisParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1872)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1870)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1871)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowOpenTablesContext).database = _x
			}

		}
		p.SetState(1875)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(1874)
				p.WildWhere()
			}

		}

	case 5:
		localctx = NewShowTableStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1877)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1878)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1879)
			p.Match(DorisParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1882)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1880)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1881)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowTableStatusContext).database = _x
			}

		}
		p.SetState(1885)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(1884)
				p.WildWhere()
			}

		}

	case 6:
		localctx = NewShowTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1887)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1889)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFULL {
			{
				p.SetState(1888)
				p.Match(DorisParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1891)
			p.Match(DorisParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1894)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1892)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1893)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowTablesContext).database = _x
			}

		}
		p.SetState(1897)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(1896)
				p.WildWhere()
			}

		}

	case 7:
		localctx = NewShowViewsContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1899)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1901)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFULL {
			{
				p.SetState(1900)
				p.Match(DorisParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1903)
			p.Match(DorisParserVIEWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1906)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1904)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1905)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowViewsContext).database = _x
			}

		}
		p.SetState(1909)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(1908)
				p.WildWhere()
			}

		}

	case 8:
		localctx = NewShowMaterializedViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1911)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1912)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1913)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1914)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1915)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowMaterializedViewContext).name = _x
		}

	case 9:
		localctx = NewShowCreateFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1916)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1917)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1919)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION {
			{
				p.SetState(1918)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1921)
			p.Match(DorisParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1922)
			p.FunctionIdentifier()
		}
		{
			p.SetState(1923)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1925)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4576167530201152) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&16870906416594945) != 0) || _la == DorisParserDOUBLE || _la == DorisParserFLOAT || ((int64((_la-207)) & ^0x3f) == 0 && ((int64(1)<<(_la-207))&-9223369734650855423) != 0) || _la == DorisParserQUANTILE_STATE || _la == DorisParserSMALLINT || ((int64((_la-429)) & ^0x3f) == 0 && ((int64(1)<<(_la-429))&5066549583478787) != 0) {
			{
				p.SetState(1924)
				p.FunctionArguments()
			}

		}
		{
			p.SetState(1927)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1930)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1928)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1929)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowCreateFunctionContext).database = _x
			}

		}

	case 10:
		localctx = NewShowDatabasesContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1932)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1933)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserDATABASES || _la == DorisParserSCHEMAS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1936)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(1934)
				p.Match(DorisParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1935)

				var _x = p.Identifier()

				localctx.(*ShowDatabasesContext).catalog = _x
			}

		}
		p.SetState(1939)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(1938)
				p.WildWhere()
			}

		}

	case 11:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1941)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1943)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFULL {
			{
				p.SetState(1942)
				p.Match(DorisParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1945)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserCOLUMNS || _la == DorisParserFIELDS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1946)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserFROM || _la == DorisParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1947)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowColumnsContext).tableName = _x
		}
		p.SetState(1950)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1948)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1949)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowColumnsContext).database = _x
			}

		}
		p.SetState(1953)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(1952)
				p.WildWhere()
			}

		}

	case 12:
		localctx = NewShowLoadWaringsContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1955)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1956)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1957)
			p.Match(DorisParserWARNINGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1970)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserEOF, DorisParserSEMICOLON, DorisParserFROM, DorisParserIN, DorisParserLIKE, DorisParserLIMIT, DorisParserWHERE:
			p.SetState(1960)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserFROM || _la == DorisParserIN {
				{
					p.SetState(1958)
					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisParserFROM || _la == DorisParserIN) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1959)

					var _x = p.MultipartIdentifier()

					localctx.(*ShowLoadWaringsContext).database = _x
				}

			}
			p.SetState(1963)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserLIKE || _la == DorisParserWHERE {
				{
					p.SetState(1962)
					p.WildWhere()
				}

			}
			p.SetState(1966)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserLIMIT {
				{
					p.SetState(1965)
					p.LimitClause()
				}

			}

		case DorisParserON:
			{
				p.SetState(1968)
				p.Match(DorisParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1969)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*ShowLoadWaringsContext).url = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 13:
		localctx = NewShowLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1972)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1974)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserSTREAM {
			{
				p.SetState(1973)
				p.Match(DorisParserSTREAM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1976)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1979)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1977)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1978)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowLoadContext).database = _x
			}

		}
		p.SetState(1982)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(1981)
				p.WildWhere()
			}

		}
		p.SetState(1985)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserORDER {
			{
				p.SetState(1984)
				p.SortClause()
			}

		}
		p.SetState(1988)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIMIT {
			{
				p.SetState(1987)
				p.LimitClause()
			}

		}

	case 14:
		localctx = NewShowExportContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1990)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1991)
			p.Match(DorisParserEXPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1994)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1992)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1993)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowExportContext).database = _x
			}

		}
		p.SetState(1997)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(1996)
				p.WildWhere()
			}

		}
		p.SetState(2000)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserORDER {
			{
				p.SetState(1999)
				p.SortClause()
			}

		}
		p.SetState(2003)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIMIT {
			{
				p.SetState(2002)
				p.LimitClause()
			}

		}

	case 15:
		localctx = NewShowAlterTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(2005)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2006)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2007)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2012)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserROLLUP:
			{
				p.SetState(2008)
				p.Match(DorisParserROLLUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserMATERIALIZED:
			{
				p.SetState(2009)
				p.Match(DorisParserMATERIALIZED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2010)
				p.Match(DorisParserVIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCOLUMN:
			{
				p.SetState(2011)
				p.Match(DorisParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(2016)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2014)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2015)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowAlterTableContext).database = _x
			}

		}
		p.SetState(2019)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2018)
				p.WildWhere()
			}

		}
		p.SetState(2022)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserORDER {
			{
				p.SetState(2021)
				p.SortClause()
			}

		}
		p.SetState(2025)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIMIT {
			{
				p.SetState(2024)
				p.LimitClause()
			}

		}

	case 16:
		localctx = NewShowDataContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(2027)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2028)
			p.Match(DorisParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2030)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserALL {
			{
				p.SetState(2029)
				p.Match(DorisParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2034)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(2032)
				p.Match(DorisParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2033)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowDataContext).tableName = _x
			}

		}
		p.SetState(2037)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserORDER {
			{
				p.SetState(2036)
				p.SortClause()
			}

		}
		p.SetState(2040)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2039)
				p.PropertyClause()
			}

		}

	case 17:
		localctx = NewShowPartitionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(2042)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2044)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(2043)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2046)
			p.Match(DorisParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2047)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2048)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowPartitionsContext).tableName = _x
		}
		p.SetState(2050)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2049)
				p.WildWhere()
			}

		}
		p.SetState(2053)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserORDER {
			{
				p.SetState(2052)
				p.SortClause()
			}

		}
		p.SetState(2056)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIMIT {
			{
				p.SetState(2055)
				p.LimitClause()
			}

		}

	case 18:
		localctx = NewShowTabletIdContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(2058)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2059)
			p.Match(DorisParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2060)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*ShowTabletIdContext).tabletId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		localctx = NewShowTabletsFromTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(2061)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2062)
			p.Match(DorisParserTABLETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2063)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2064)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowTabletsFromTableContext).tableName = _x
		}
		p.SetState(2066)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(2065)
				p.PartitionSpec()
			}

		}
		p.SetState(2069)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2068)
				p.WildWhere()
			}

		}
		p.SetState(2072)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserORDER {
			{
				p.SetState(2071)
				p.SortClause()
			}

		}
		p.SetState(2075)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIMIT {
			{
				p.SetState(2074)
				p.LimitClause()
			}

		}

	case 20:
		localctx = NewShowBackupContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(2077)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2078)
			p.Match(DorisParserBACKUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2081)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2079)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2080)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowBackupContext).database = _x
			}

		}
		p.SetState(2084)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2083)
				p.WildWhere()
			}

		}

	case 21:
		localctx = NewShowRestoreContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(2086)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2088)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserBRIEF {
			{
				p.SetState(2087)
				p.Match(DorisParserBRIEF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2090)
			p.Match(DorisParserRESTORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2093)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2091)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2092)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowRestoreContext).database = _x
			}

		}
		p.SetState(2096)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2095)
				p.WildWhere()
			}

		}

	case 22:
		localctx = NewShowResourcesContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(2098)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2099)
			p.Match(DorisParserRESOURCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2101)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2100)
				p.WildWhere()
			}

		}
		p.SetState(2104)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserORDER {
			{
				p.SetState(2103)
				p.SortClause()
			}

		}
		p.SetState(2107)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIMIT {
			{
				p.SetState(2106)
				p.LimitClause()
			}

		}

	case 23:
		localctx = NewShowWorkloadGroupsContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(2109)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2110)
			p.Match(DorisParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2111)
			p.Match(DorisParserGROUPS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2113)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2112)
				p.WildWhere()
			}

		}

	case 24:
		localctx = NewShowSnapshotContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(2115)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2116)
			p.Match(DorisParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2117)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2118)

			var _x = p.Identifier()

			localctx.(*ShowSnapshotContext).repo = _x
		}
		p.SetState(2120)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2119)
				p.WildWhere()
			}

		}

	case 25:
		localctx = NewShowFunctionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(2122)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2124)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFULL {
			{
				p.SetState(2123)
				p.Match(DorisParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2127)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserBUILTIN {
			{
				p.SetState(2126)
				p.Match(DorisParserBUILTIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2129)
			p.Match(DorisParserFUNCTIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2132)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2130)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2131)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowFunctionsContext).database = _x
			}

		}
		p.SetState(2135)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2134)
				p.WildWhere()
			}

		}

	case 26:
		localctx = NewShowGlobalFunctionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(2137)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2138)
			p.Match(DorisParserGLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2140)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFULL {
			{
				p.SetState(2139)
				p.Match(DorisParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2142)
			p.Match(DorisParserFUNCTIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2144)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2143)
				p.WildWhere()
			}

		}

	case 27:
		localctx = NewShowTypeCastContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(2146)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2147)
			p.Match(DorisParserTYPECAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2150)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2148)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2149)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowTypeCastContext).database = _x
			}

		}

	case 28:
		localctx = NewShowIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(2152)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2153)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-219)) & ^0x3f) == 0 && ((int64(1)<<(_la-219))&100663299) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2154)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserFROM || _la == DorisParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2155)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowIndexContext).tableName = _x
		}
		p.SetState(2158)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2156)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2157)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowIndexContext).database = _x
			}

		}

	case 29:
		localctx = NewShowTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(2160)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2161)
			p.Match(DorisParserTRANSACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2164)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2162)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2163)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowTransactionContext).database = _x
			}

		}
		p.SetState(2167)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2166)
				p.WildWhere()
			}

		}

	case 30:
		localctx = NewShowCacheHotSpotContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(2169)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2170)
			p.Match(DorisParserCACHE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2171)
			p.Match(DorisParserHOTSPOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2172)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ShowCacheHotSpotContext).tablePath = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 31:
		localctx = NewShowCatalogRecycleBinContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(2173)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2174)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2175)
			p.Match(DorisParserRECYCLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2176)
			p.Match(DorisParserBIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2178)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2177)
				p.WildWhere()
			}

		}

	case 32:
		localctx = NewShowQueryStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(2180)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2181)
			p.Match(DorisParserQUERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2182)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2193)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case DorisParserFOR:
			{
				p.SetState(2183)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2184)

				var _x = p.Identifier()

				localctx.(*ShowQueryStatsContext).database = _x
			}

		case DorisParserFROM:
			{
				p.SetState(2185)
				p.Match(DorisParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2186)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowQueryStatsContext).tableName = _x
			}
			p.SetState(2191)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserALL {
				{
					p.SetState(2187)
					p.Match(DorisParserALL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(2189)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisParserVERBOSE {
					{
						p.SetState(2188)
						p.Match(DorisParserVERBOSE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}

			}

		case DorisParserEOF, DorisParserSEMICOLON:

		default:
		}

	case 33:
		localctx = NewShowBuildIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(2195)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2196)
			p.Match(DorisParserBUILD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2197)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2200)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2198)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2199)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowBuildIndexContext).database = _x
			}

		}
		p.SetState(2203)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2202)
				p.WildWhere()
			}

		}
		p.SetState(2206)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserORDER {
			{
				p.SetState(2205)
				p.SortClause()
			}

		}
		p.SetState(2209)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIMIT {
			{
				p.SetState(2208)
				p.LimitClause()
			}

		}

	case 34:
		localctx = NewShowClustersContext(p, localctx)
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(2211)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2215)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserCLUSTERS:
			{
				p.SetState(2212)
				p.Match(DorisParserCLUSTERS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCOMPUTE:
			{
				p.SetState(2213)
				p.Match(DorisParserCOMPUTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2214)
				p.Match(DorisParserGROUPS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 35:
		localctx = NewShowReplicaStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(2217)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2218)
			p.Match(DorisParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2219)
			p.Match(DorisParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2220)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2221)
			p.BaseTableRef()
		}
		p.SetState(2223)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2222)
				p.WildWhere()
			}

		}

	case 36:
		localctx = NewShowCopyContext(p, localctx)
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(2225)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2226)
			p.Match(DorisParserCOPY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2229)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2227)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2228)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowCopyContext).database = _x
			}

		}
		p.SetState(2232)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWHERE {
			{
				p.SetState(2231)
				p.WhereClause()
			}

		}
		p.SetState(2235)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserORDER {
			{
				p.SetState(2234)
				p.SortClause()
			}

		}
		p.SetState(2238)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIMIT {
			{
				p.SetState(2237)
				p.LimitClause()
			}

		}

	case 37:
		localctx = NewShowWarmUpJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(2240)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2241)
			p.Match(DorisParserWARM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2242)
			p.Match(DorisParserUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2243)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2245)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2244)
				p.WildWhere()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateRoutineLoadContext is an interface to support dynamic dispatch.
type ICreateRoutineLoadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLabel returns the label rule contexts.
	GetLabel() IMultipartIdentifierContext

	// GetTable returns the table rule contexts.
	GetTable() IIdentifierContext

	// GetType_ returns the type_ rule contexts.
	GetType_() IIdentifierContext

	// GetCustomProperties returns the customProperties rule contexts.
	GetCustomProperties() IPropertyItemListContext

	// SetLabel sets the label rule contexts.
	SetLabel(IMultipartIdentifierContext)

	// SetTable sets the table rule contexts.
	SetTable(IIdentifierContext)

	// SetType_ sets the type_ rule contexts.
	SetType_(IIdentifierContext)

	// SetCustomProperties sets the customProperties rule contexts.
	SetCustomProperties(IPropertyItemListContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FROM() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	PropertyItemList() IPropertyItemListContext
	ON() antlr.TerminalNode
	WITH() antlr.TerminalNode
	AllLoadProperty() []ILoadPropertyContext
	LoadProperty(i int) ILoadPropertyContext
	PropertyClause() IPropertyClauseContext
	CommentSpec() ICommentSpecContext
	APPEND() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreateRoutineLoadContext differentiates from other interfaces.
	IsCreateRoutineLoadContext()
}

type CreateRoutineLoadContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	label            IMultipartIdentifierContext
	table            IIdentifierContext
	type_            IIdentifierContext
	customProperties IPropertyItemListContext
}

func NewEmptyCreateRoutineLoadContext() *CreateRoutineLoadContext {
	var p = new(CreateRoutineLoadContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_createRoutineLoad
	return p
}

func InitEmptyCreateRoutineLoadContext(p *CreateRoutineLoadContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_createRoutineLoad
}

func (*CreateRoutineLoadContext) IsCreateRoutineLoadContext() {}

func NewCreateRoutineLoadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRoutineLoadContext {
	var p = new(CreateRoutineLoadContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_createRoutineLoad

	return p
}

func (s *CreateRoutineLoadContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRoutineLoadContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *CreateRoutineLoadContext) GetTable() IIdentifierContext { return s.table }

func (s *CreateRoutineLoadContext) GetType_() IIdentifierContext { return s.type_ }

func (s *CreateRoutineLoadContext) GetCustomProperties() IPropertyItemListContext {
	return s.customProperties
}

func (s *CreateRoutineLoadContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *CreateRoutineLoadContext) SetTable(v IIdentifierContext) { s.table = v }

func (s *CreateRoutineLoadContext) SetType_(v IIdentifierContext) { s.type_ = v }

func (s *CreateRoutineLoadContext) SetCustomProperties(v IPropertyItemListContext) {
	s.customProperties = v
}

func (s *CreateRoutineLoadContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserROUTINE, 0)
}

func (s *CreateRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *CreateRoutineLoadContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *CreateRoutineLoadContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CreateRoutineLoadContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CreateRoutineLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateRoutineLoadContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateRoutineLoadContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRoutineLoadContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *CreateRoutineLoadContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *CreateRoutineLoadContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *CreateRoutineLoadContext) AllLoadProperty() []ILoadPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILoadPropertyContext); ok {
			len++
		}
	}

	tst := make([]ILoadPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILoadPropertyContext); ok {
			tst[i] = t.(ILoadPropertyContext)
			i++
		}
	}

	return tst
}

func (s *CreateRoutineLoadContext) LoadProperty(i int) ILoadPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadPropertyContext)
}

func (s *CreateRoutineLoadContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateRoutineLoadContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *CreateRoutineLoadContext) APPEND() antlr.TerminalNode {
	return s.GetToken(DorisParserAPPEND, 0)
}

func (s *CreateRoutineLoadContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisParserDELETE, 0)
}

func (s *CreateRoutineLoadContext) MERGE() antlr.TerminalNode {
	return s.GetToken(DorisParserMERGE, 0)
}

func (s *CreateRoutineLoadContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *CreateRoutineLoadContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *CreateRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoutineLoadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRoutineLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateRoutineLoad(s)
	}
}

func (s *CreateRoutineLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateRoutineLoad(s)
	}
}

func (p *DorisParser) CreateRoutineLoad() (localctx ICreateRoutineLoadContext) {
	localctx = NewCreateRoutineLoadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, DorisParserRULE_createRoutineLoad)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2249)
		p.Match(DorisParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2250)
		p.Match(DorisParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2251)
		p.Match(DorisParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2252)

		var _x = p.MultipartIdentifier()

		localctx.(*CreateRoutineLoadContext).label = _x
	}
	p.SetState(2255)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserON {
		{
			p.SetState(2253)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2254)

			var _x = p.Identifier()

			localctx.(*CreateRoutineLoadContext).table = _x
		}

	}
	p.SetState(2259)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserWITH {
		{
			p.SetState(2257)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2258)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserAPPEND || _la == DorisParserDELETE || _la == DorisParserMERGE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(2269)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserCOLUMNS || _la == DorisParserDELETE || ((int64((_la-312)) & ^0x3f) == 0 && ((int64(1)<<(_la-312))&536871297) != 0) || _la == DorisParserTEMPORARY || _la == DorisParserWHERE {
		{
			p.SetState(2261)
			p.LoadProperty()
		}
		p.SetState(2266)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(2262)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2263)
				p.LoadProperty()
			}

			p.SetState(2268)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(2272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPROPERTIES {
		{
			p.SetState(2271)
			p.PropertyClause()
		}

	}
	{
		p.SetState(2274)
		p.Match(DorisParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2275)

		var _x = p.Identifier()

		localctx.(*CreateRoutineLoadContext).type_ = _x
	}
	{
		p.SetState(2276)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2277)

		var _x = p.PropertyItemList()

		localctx.(*CreateRoutineLoadContext).customProperties = _x
	}
	{
		p.SetState(2278)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2280)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserCOMMENT {
		{
			p.SetState(2279)
			p.CommentSpec()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedLoadStatementContext is an interface to support dynamic dispatch.
type IUnsupportedLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedLoadStatementContext differentiates from other interfaces.
	IsUnsupportedLoadStatementContext()
}

type UnsupportedLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedLoadStatementContext() *UnsupportedLoadStatementContext {
	var p = new(UnsupportedLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedLoadStatement
	return p
}

func InitEmptyUnsupportedLoadStatementContext(p *UnsupportedLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedLoadStatement
}

func (*UnsupportedLoadStatementContext) IsUnsupportedLoadStatementContext() {}

func NewUnsupportedLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedLoadStatementContext {
	var p = new(UnsupportedLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedLoadStatement

	return p
}

func (s *UnsupportedLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedLoadStatementContext) CopyAll(ctx *UnsupportedLoadStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowRoutineLoadContext struct {
	UnsupportedLoadStatementContext
	label IMultipartIdentifierContext
}

func NewShowRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRoutineLoadContext {
	var p = new(ShowRoutineLoadContext)

	InitEmptyUnsupportedLoadStatementContext(&p.UnsupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedLoadStatementContext))

	return p
}

func (s *ShowRoutineLoadContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *ShowRoutineLoadContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *ShowRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRoutineLoadContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserROUTINE, 0)
}

func (s *ShowRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *ShowRoutineLoadContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *ShowRoutineLoadContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *ShowRoutineLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowRoutineLoadContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowRoutineLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowRoutineLoad(s)
	}
}

func (s *ShowRoutineLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowRoutineLoad(s)
	}
}

type ResumeRoutineLoadContext struct {
	UnsupportedLoadStatementContext
	label IMultipartIdentifierContext
}

func NewResumeRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ResumeRoutineLoadContext {
	var p = new(ResumeRoutineLoadContext)

	InitEmptyUnsupportedLoadStatementContext(&p.UnsupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedLoadStatementContext))

	return p
}

func (s *ResumeRoutineLoadContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *ResumeRoutineLoadContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *ResumeRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumeRoutineLoadContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisParserRESUME, 0)
}

func (s *ResumeRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserROUTINE, 0)
}

func (s *ResumeRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *ResumeRoutineLoadContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *ResumeRoutineLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ResumeRoutineLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterResumeRoutineLoad(s)
	}
}

func (s *ResumeRoutineLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitResumeRoutineLoad(s)
	}
}

type ShowCreateLoadContext struct {
	UnsupportedLoadStatementContext
	label IMultipartIdentifierContext
}

func NewShowCreateLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateLoadContext {
	var p = new(ShowCreateLoadContext)

	InitEmptyUnsupportedLoadStatementContext(&p.UnsupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedLoadStatementContext))

	return p
}

func (s *ShowCreateLoadContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *ShowCreateLoadContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *ShowCreateLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateLoadContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCreateLoadContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowCreateLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *ShowCreateLoadContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *ShowCreateLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCreateLoad(s)
	}
}

func (s *ShowCreateLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCreateLoad(s)
	}
}

type CreateDataSyncJobContext struct {
	UnsupportedLoadStatementContext
	label      IMultipartIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateDataSyncJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateDataSyncJobContext {
	var p = new(CreateDataSyncJobContext)

	InitEmptyUnsupportedLoadStatementContext(&p.UnsupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedLoadStatementContext))

	return p
}

func (s *CreateDataSyncJobContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *CreateDataSyncJobContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateDataSyncJobContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *CreateDataSyncJobContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateDataSyncJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDataSyncJobContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateDataSyncJobContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DorisParserSYNC, 0)
}

func (s *CreateDataSyncJobContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserLEFT_PAREN)
}

func (s *CreateDataSyncJobContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, i)
}

func (s *CreateDataSyncJobContext) ChannelDescriptions() IChannelDescriptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelDescriptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelDescriptionsContext)
}

func (s *CreateDataSyncJobContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserRIGHT_PAREN)
}

func (s *CreateDataSyncJobContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, i)
}

func (s *CreateDataSyncJobContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *CreateDataSyncJobContext) BINLOG() antlr.TerminalNode {
	return s.GetToken(DorisParserBINLOG, 0)
}

func (s *CreateDataSyncJobContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *CreateDataSyncJobContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateDataSyncJobContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateDataSyncJobContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateDataSyncJob(s)
	}
}

func (s *CreateDataSyncJobContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateDataSyncJob(s)
	}
}

type PauseDataSyncJobContext struct {
	UnsupportedLoadStatementContext
	name IMultipartIdentifierContext
}

func NewPauseDataSyncJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PauseDataSyncJobContext {
	var p = new(PauseDataSyncJobContext)

	InitEmptyUnsupportedLoadStatementContext(&p.UnsupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedLoadStatementContext))

	return p
}

func (s *PauseDataSyncJobContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *PauseDataSyncJobContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *PauseDataSyncJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PauseDataSyncJobContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserPAUSE, 0)
}

func (s *PauseDataSyncJobContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DorisParserSYNC, 0)
}

func (s *PauseDataSyncJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *PauseDataSyncJobContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *PauseDataSyncJobContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPauseDataSyncJob(s)
	}
}

func (s *PauseDataSyncJobContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPauseDataSyncJob(s)
	}
}

type ResumeDataSyncJobContext struct {
	UnsupportedLoadStatementContext
	name IMultipartIdentifierContext
}

func NewResumeDataSyncJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ResumeDataSyncJobContext {
	var p = new(ResumeDataSyncJobContext)

	InitEmptyUnsupportedLoadStatementContext(&p.UnsupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedLoadStatementContext))

	return p
}

func (s *ResumeDataSyncJobContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *ResumeDataSyncJobContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *ResumeDataSyncJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumeDataSyncJobContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisParserRESUME, 0)
}

func (s *ResumeDataSyncJobContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DorisParserSYNC, 0)
}

func (s *ResumeDataSyncJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *ResumeDataSyncJobContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ResumeDataSyncJobContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterResumeDataSyncJob(s)
	}
}

func (s *ResumeDataSyncJobContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitResumeDataSyncJob(s)
	}
}

type PauseAllRoutineLoadContext struct {
	UnsupportedLoadStatementContext
}

func NewPauseAllRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PauseAllRoutineLoadContext {
	var p = new(PauseAllRoutineLoadContext)

	InitEmptyUnsupportedLoadStatementContext(&p.UnsupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedLoadStatementContext))

	return p
}

func (s *PauseAllRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PauseAllRoutineLoadContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserPAUSE, 0)
}

func (s *PauseAllRoutineLoadContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *PauseAllRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserROUTINE, 0)
}

func (s *PauseAllRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *PauseAllRoutineLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPauseAllRoutineLoad(s)
	}
}

func (s *PauseAllRoutineLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPauseAllRoutineLoad(s)
	}
}

type StopDataSyncJobContext struct {
	UnsupportedLoadStatementContext
	name IMultipartIdentifierContext
}

func NewStopDataSyncJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StopDataSyncJobContext {
	var p = new(StopDataSyncJobContext)

	InitEmptyUnsupportedLoadStatementContext(&p.UnsupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedLoadStatementContext))

	return p
}

func (s *StopDataSyncJobContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *StopDataSyncJobContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *StopDataSyncJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StopDataSyncJobContext) STOP() antlr.TerminalNode {
	return s.GetToken(DorisParserSTOP, 0)
}

func (s *StopDataSyncJobContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DorisParserSYNC, 0)
}

func (s *StopDataSyncJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *StopDataSyncJobContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *StopDataSyncJobContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStopDataSyncJob(s)
	}
}

func (s *StopDataSyncJobContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStopDataSyncJob(s)
	}
}

type MysqlLoadContext struct {
	UnsupportedLoadStatementContext
	properties IPropertyItemListContext
}

func NewMysqlLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MysqlLoadContext {
	var p = new(MysqlLoadContext)

	InitEmptyUnsupportedLoadStatementContext(&p.UnsupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedLoadStatementContext))

	return p
}

func (s *MysqlLoadContext) GetProperties() IPropertyItemListContext { return s.properties }

func (s *MysqlLoadContext) SetProperties(v IPropertyItemListContext) { s.properties = v }

func (s *MysqlLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MysqlLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *MysqlLoadContext) MysqlDataDesc() IMysqlDataDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMysqlDataDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMysqlDataDescContext)
}

func (s *MysqlLoadContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *MysqlLoadContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *MysqlLoadContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *MysqlLoadContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *MysqlLoadContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *MysqlLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMysqlLoad(s)
	}
}

func (s *MysqlLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMysqlLoad(s)
	}
}

type ShowCreateRoutineLoadContext struct {
	UnsupportedLoadStatementContext
	label IMultipartIdentifierContext
}

func NewShowCreateRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateRoutineLoadContext {
	var p = new(ShowCreateRoutineLoadContext)

	InitEmptyUnsupportedLoadStatementContext(&p.UnsupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedLoadStatementContext))

	return p
}

func (s *ShowCreateRoutineLoadContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *ShowCreateRoutineLoadContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *ShowCreateRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateRoutineLoadContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCreateRoutineLoadContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowCreateRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserROUTINE, 0)
}

func (s *ShowCreateRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *ShowCreateRoutineLoadContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *ShowCreateRoutineLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateRoutineLoadContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *ShowCreateRoutineLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCreateRoutineLoad(s)
	}
}

func (s *ShowCreateRoutineLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCreateRoutineLoad(s)
	}
}

type PauseRoutineLoadContext struct {
	UnsupportedLoadStatementContext
	label IMultipartIdentifierContext
}

func NewPauseRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PauseRoutineLoadContext {
	var p = new(PauseRoutineLoadContext)

	InitEmptyUnsupportedLoadStatementContext(&p.UnsupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedLoadStatementContext))

	return p
}

func (s *PauseRoutineLoadContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *PauseRoutineLoadContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *PauseRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PauseRoutineLoadContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserPAUSE, 0)
}

func (s *PauseRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserROUTINE, 0)
}

func (s *PauseRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *PauseRoutineLoadContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *PauseRoutineLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *PauseRoutineLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPauseRoutineLoad(s)
	}
}

func (s *PauseRoutineLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPauseRoutineLoad(s)
	}
}

type ShowRoutineLoadTaskContext struct {
	UnsupportedLoadStatementContext
	database IIdentifierContext
}

func NewShowRoutineLoadTaskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRoutineLoadTaskContext {
	var p = new(ShowRoutineLoadTaskContext)

	InitEmptyUnsupportedLoadStatementContext(&p.UnsupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedLoadStatementContext))

	return p
}

func (s *ShowRoutineLoadTaskContext) GetDatabase() IIdentifierContext { return s.database }

func (s *ShowRoutineLoadTaskContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *ShowRoutineLoadTaskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRoutineLoadTaskContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowRoutineLoadTaskContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserROUTINE, 0)
}

func (s *ShowRoutineLoadTaskContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *ShowRoutineLoadTaskContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisParserTASK, 0)
}

func (s *ShowRoutineLoadTaskContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowRoutineLoadTaskContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowRoutineLoadTaskContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowRoutineLoadTaskContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowRoutineLoadTaskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowRoutineLoadTask(s)
	}
}

func (s *ShowRoutineLoadTaskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowRoutineLoadTask(s)
	}
}

type ResumeAllRoutineLoadContext struct {
	UnsupportedLoadStatementContext
}

func NewResumeAllRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ResumeAllRoutineLoadContext {
	var p = new(ResumeAllRoutineLoadContext)

	InitEmptyUnsupportedLoadStatementContext(&p.UnsupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedLoadStatementContext))

	return p
}

func (s *ResumeAllRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumeAllRoutineLoadContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisParserRESUME, 0)
}

func (s *ResumeAllRoutineLoadContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *ResumeAllRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserROUTINE, 0)
}

func (s *ResumeAllRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *ResumeAllRoutineLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterResumeAllRoutineLoad(s)
	}
}

func (s *ResumeAllRoutineLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitResumeAllRoutineLoad(s)
	}
}

type StopRoutineLoadContext struct {
	UnsupportedLoadStatementContext
	label IMultipartIdentifierContext
}

func NewStopRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StopRoutineLoadContext {
	var p = new(StopRoutineLoadContext)

	InitEmptyUnsupportedLoadStatementContext(&p.UnsupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedLoadStatementContext))

	return p
}

func (s *StopRoutineLoadContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *StopRoutineLoadContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *StopRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StopRoutineLoadContext) STOP() antlr.TerminalNode {
	return s.GetToken(DorisParserSTOP, 0)
}

func (s *StopRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserROUTINE, 0)
}

func (s *StopRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *StopRoutineLoadContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *StopRoutineLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *StopRoutineLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStopRoutineLoad(s)
	}
}

func (s *StopRoutineLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStopRoutineLoad(s)
	}
}

func (p *DorisParser) UnsupportedLoadStatement() (localctx IUnsupportedLoadStatementContext) {
	localctx = NewUnsupportedLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, DorisParserRULE_unsupportedLoadStatement)
	var _la int

	p.SetState(2381)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 312, p.GetParserRuleContext()) {
	case 1:
		localctx = NewMysqlLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2282)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2283)
			p.MysqlDataDesc()
		}
		p.SetState(2289)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2284)
				p.Match(DorisParserPROPERTIES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2285)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2286)

				var _x = p.PropertyItemList()

				localctx.(*MysqlLoadContext).properties = _x
			}
			{
				p.SetState(2287)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2292)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(2291)
				p.CommentSpec()
			}

		}

	case 2:
		localctx = NewCreateDataSyncJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2294)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2295)
			p.Match(DorisParserSYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2296)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateDataSyncJobContext).label = _x
		}
		{
			p.SetState(2297)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2298)
			p.ChannelDescriptions()
		}
		{
			p.SetState(2299)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2300)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2301)
			p.Match(DorisParserBINLOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2302)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2303)
			p.PropertyItemList()
		}
		{
			p.SetState(2304)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2306)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2305)

				var _x = p.PropertyClause()

				localctx.(*CreateDataSyncJobContext).properties = _x
			}

		}

	case 3:
		localctx = NewStopDataSyncJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2308)
			p.Match(DorisParserSTOP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2309)
			p.Match(DorisParserSYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2310)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2311)

			var _x = p.MultipartIdentifier()

			localctx.(*StopDataSyncJobContext).name = _x
		}

	case 4:
		localctx = NewResumeDataSyncJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2312)
			p.Match(DorisParserRESUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2313)
			p.Match(DorisParserSYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2314)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2315)

			var _x = p.MultipartIdentifier()

			localctx.(*ResumeDataSyncJobContext).name = _x
		}

	case 5:
		localctx = NewPauseDataSyncJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2316)
			p.Match(DorisParserPAUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2317)
			p.Match(DorisParserSYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2318)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2319)

			var _x = p.MultipartIdentifier()

			localctx.(*PauseDataSyncJobContext).name = _x
		}

	case 6:
		localctx = NewPauseRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2320)
			p.Match(DorisParserPAUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2321)
			p.Match(DorisParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2322)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2323)
			p.Match(DorisParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2324)

			var _x = p.MultipartIdentifier()

			localctx.(*PauseRoutineLoadContext).label = _x
		}

	case 7:
		localctx = NewPauseAllRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2325)
			p.Match(DorisParserPAUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2326)
			p.Match(DorisParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2327)
			p.Match(DorisParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2328)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewResumeRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2329)
			p.Match(DorisParserRESUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2330)
			p.Match(DorisParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2331)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2332)
			p.Match(DorisParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2333)

			var _x = p.MultipartIdentifier()

			localctx.(*ResumeRoutineLoadContext).label = _x
		}

	case 9:
		localctx = NewResumeAllRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2334)
			p.Match(DorisParserRESUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2335)
			p.Match(DorisParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2336)
			p.Match(DorisParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2337)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewStopRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2338)
			p.Match(DorisParserSTOP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2339)
			p.Match(DorisParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2340)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2341)
			p.Match(DorisParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2342)

			var _x = p.MultipartIdentifier()

			localctx.(*StopRoutineLoadContext).label = _x
		}

	case 11:
		localctx = NewShowRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2343)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2345)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserALL {
			{
				p.SetState(2344)
				p.Match(DorisParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2347)
			p.Match(DorisParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2348)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2354)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserFOR:
			{
				p.SetState(2349)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2350)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowRoutineLoadContext).label = _x
			}

		case DorisParserEOF, DorisParserSEMICOLON, DorisParserLIKE, DorisParserWHERE:
			p.SetState(2352)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserLIKE || _la == DorisParserWHERE {
				{
					p.SetState(2351)
					p.WildWhere()
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 12:
		localctx = NewShowRoutineLoadTaskContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2356)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2357)
			p.Match(DorisParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2358)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2359)
			p.Match(DorisParserTASK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2362)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2360)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2361)

				var _x = p.Identifier()

				localctx.(*ShowRoutineLoadTaskContext).database = _x
			}

		}
		p.SetState(2365)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2364)
				p.WildWhere()
			}

		}

	case 13:
		localctx = NewShowCreateRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2367)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2369)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserALL {
			{
				p.SetState(2368)
				p.Match(DorisParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2371)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2372)
			p.Match(DorisParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2373)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2374)
			p.Match(DorisParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2375)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateRoutineLoadContext).label = _x
		}

	case 14:
		localctx = NewShowCreateLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2376)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2377)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2378)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2379)
			p.Match(DorisParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2380)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateLoadContext).label = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoadPropertyContext is an interface to support dynamic dispatch.
type ILoadPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLoadPropertyContext differentiates from other interfaces.
	IsLoadPropertyContext()
}

type LoadPropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoadPropertyContext() *LoadPropertyContext {
	var p = new(LoadPropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_loadProperty
	return p
}

func InitEmptyLoadPropertyContext(p *LoadPropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_loadProperty
}

func (*LoadPropertyContext) IsLoadPropertyContext() {}

func NewLoadPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadPropertyContext {
	var p = new(LoadPropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_loadProperty

	return p
}

func (s *LoadPropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadPropertyContext) CopyAll(ctx *LoadPropertyContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LoadPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadPropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ImportPrecedingFilterContext struct {
	LoadPropertyContext
}

func NewImportPrecedingFilterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImportPrecedingFilterContext {
	var p = new(ImportPrecedingFilterContext)

	InitEmptyLoadPropertyContext(&p.LoadPropertyContext)
	p.parser = parser
	p.CopyAll(ctx.(*LoadPropertyContext))

	return p
}

func (s *ImportPrecedingFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportPrecedingFilterContext) ImportPrecedingFilterStatement() IImportPrecedingFilterStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportPrecedingFilterStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportPrecedingFilterStatementContext)
}

func (s *ImportPrecedingFilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterImportPrecedingFilter(s)
	}
}

func (s *ImportPrecedingFilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitImportPrecedingFilter(s)
	}
}

type ImportSequenceContext struct {
	LoadPropertyContext
}

func NewImportSequenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImportSequenceContext {
	var p = new(ImportSequenceContext)

	InitEmptyLoadPropertyContext(&p.LoadPropertyContext)
	p.parser = parser
	p.CopyAll(ctx.(*LoadPropertyContext))

	return p
}

func (s *ImportSequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportSequenceContext) ImportSequenceStatement() IImportSequenceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportSequenceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportSequenceStatementContext)
}

func (s *ImportSequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterImportSequence(s)
	}
}

func (s *ImportSequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitImportSequence(s)
	}
}

type ImportColumnsContext struct {
	LoadPropertyContext
}

func NewImportColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImportColumnsContext {
	var p = new(ImportColumnsContext)

	InitEmptyLoadPropertyContext(&p.LoadPropertyContext)
	p.parser = parser
	p.CopyAll(ctx.(*LoadPropertyContext))

	return p
}

func (s *ImportColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportColumnsContext) ImportColumnsStatement() IImportColumnsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportColumnsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportColumnsStatementContext)
}

func (s *ImportColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterImportColumns(s)
	}
}

func (s *ImportColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitImportColumns(s)
	}
}

type ImportWhereContext struct {
	LoadPropertyContext
}

func NewImportWhereContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImportWhereContext {
	var p = new(ImportWhereContext)

	InitEmptyLoadPropertyContext(&p.LoadPropertyContext)
	p.parser = parser
	p.CopyAll(ctx.(*LoadPropertyContext))

	return p
}

func (s *ImportWhereContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportWhereContext) ImportWhereStatement() IImportWhereStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportWhereStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportWhereStatementContext)
}

func (s *ImportWhereContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterImportWhere(s)
	}
}

func (s *ImportWhereContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitImportWhere(s)
	}
}

type SeparatorContext struct {
	LoadPropertyContext
}

func NewSeparatorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SeparatorContext {
	var p = new(SeparatorContext)

	InitEmptyLoadPropertyContext(&p.LoadPropertyContext)
	p.parser = parser
	p.CopyAll(ctx.(*LoadPropertyContext))

	return p
}

func (s *SeparatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SeparatorContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMNS, 0)
}

func (s *SeparatorContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(DorisParserTERMINATED, 0)
}

func (s *SeparatorContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *SeparatorContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *SeparatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSeparator(s)
	}
}

func (s *SeparatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSeparator(s)
	}
}

type ImportPartitionsContext struct {
	LoadPropertyContext
}

func NewImportPartitionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImportPartitionsContext {
	var p = new(ImportPartitionsContext)

	InitEmptyLoadPropertyContext(&p.LoadPropertyContext)
	p.parser = parser
	p.CopyAll(ctx.(*LoadPropertyContext))

	return p
}

func (s *ImportPartitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportPartitionsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *ImportPartitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterImportPartitions(s)
	}
}

func (s *ImportPartitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitImportPartitions(s)
	}
}

type ImportDeleteOnContext struct {
	LoadPropertyContext
}

func NewImportDeleteOnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImportDeleteOnContext {
	var p = new(ImportDeleteOnContext)

	InitEmptyLoadPropertyContext(&p.LoadPropertyContext)
	p.parser = parser
	p.CopyAll(ctx.(*LoadPropertyContext))

	return p
}

func (s *ImportDeleteOnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeleteOnContext) ImportDeleteOnStatement() IImportDeleteOnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDeleteOnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDeleteOnStatementContext)
}

func (s *ImportDeleteOnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterImportDeleteOn(s)
	}
}

func (s *ImportDeleteOnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitImportDeleteOn(s)
	}
}

func (p *DorisParser) LoadProperty() (localctx ILoadPropertyContext) {
	localctx = NewLoadPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, DorisParserRULE_loadProperty)
	p.SetState(2393)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 313, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSeparatorContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2383)
			p.Match(DorisParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2384)
			p.Match(DorisParserTERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2385)
			p.Match(DorisParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2386)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewImportColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2387)
			p.ImportColumnsStatement()
		}

	case 3:
		localctx = NewImportPrecedingFilterContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2388)
			p.ImportPrecedingFilterStatement()
		}

	case 4:
		localctx = NewImportWhereContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2389)
			p.ImportWhereStatement()
		}

	case 5:
		localctx = NewImportDeleteOnContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2390)
			p.ImportDeleteOnStatement()
		}

	case 6:
		localctx = NewImportSequenceContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2391)
			p.ImportSequenceStatement()
		}

	case 7:
		localctx = NewImportPartitionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2392)
			p.PartitionSpec()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportSequenceStatementContext is an interface to support dynamic dispatch.
type IImportSequenceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsImportSequenceStatementContext differentiates from other interfaces.
	IsImportSequenceStatementContext()
}

type ImportSequenceStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportSequenceStatementContext() *ImportSequenceStatementContext {
	var p = new(ImportSequenceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_importSequenceStatement
	return p
}

func InitEmptyImportSequenceStatementContext(p *ImportSequenceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_importSequenceStatement
}

func (*ImportSequenceStatementContext) IsImportSequenceStatementContext() {}

func NewImportSequenceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportSequenceStatementContext {
	var p = new(ImportSequenceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_importSequenceStatement

	return p
}

func (s *ImportSequenceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportSequenceStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisParserORDER, 0)
}

func (s *ImportSequenceStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *ImportSequenceStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ImportSequenceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportSequenceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportSequenceStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterImportSequenceStatement(s)
	}
}

func (s *ImportSequenceStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitImportSequenceStatement(s)
	}
}

func (p *DorisParser) ImportSequenceStatement() (localctx IImportSequenceStatementContext) {
	localctx = NewImportSequenceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, DorisParserRULE_importSequenceStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2395)
		p.Match(DorisParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2396)
		p.Match(DorisParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2397)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportDeleteOnStatementContext is an interface to support dynamic dispatch.
type IImportDeleteOnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	ON() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsImportDeleteOnStatementContext differentiates from other interfaces.
	IsImportDeleteOnStatementContext()
}

type ImportDeleteOnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDeleteOnStatementContext() *ImportDeleteOnStatementContext {
	var p = new(ImportDeleteOnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_importDeleteOnStatement
	return p
}

func InitEmptyImportDeleteOnStatementContext(p *ImportDeleteOnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_importDeleteOnStatement
}

func (*ImportDeleteOnStatementContext) IsImportDeleteOnStatementContext() {}

func NewImportDeleteOnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDeleteOnStatementContext {
	var p = new(ImportDeleteOnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_importDeleteOnStatement

	return p
}

func (s *ImportDeleteOnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDeleteOnStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisParserDELETE, 0)
}

func (s *ImportDeleteOnStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *ImportDeleteOnStatementContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ImportDeleteOnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeleteOnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDeleteOnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterImportDeleteOnStatement(s)
	}
}

func (s *ImportDeleteOnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitImportDeleteOnStatement(s)
	}
}

func (p *DorisParser) ImportDeleteOnStatement() (localctx IImportDeleteOnStatementContext) {
	localctx = NewImportDeleteOnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, DorisParserRULE_importDeleteOnStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2399)
		p.Match(DorisParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2400)
		p.Match(DorisParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2401)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportWhereStatementContext is an interface to support dynamic dispatch.
type IImportWhereStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsImportWhereStatementContext differentiates from other interfaces.
	IsImportWhereStatementContext()
}

type ImportWhereStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportWhereStatementContext() *ImportWhereStatementContext {
	var p = new(ImportWhereStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_importWhereStatement
	return p
}

func InitEmptyImportWhereStatementContext(p *ImportWhereStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_importWhereStatement
}

func (*ImportWhereStatementContext) IsImportWhereStatementContext() {}

func NewImportWhereStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportWhereStatementContext {
	var p = new(ImportWhereStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_importWhereStatement

	return p
}

func (s *ImportWhereStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportWhereStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserWHERE, 0)
}

func (s *ImportWhereStatementContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ImportWhereStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportWhereStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportWhereStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterImportWhereStatement(s)
	}
}

func (s *ImportWhereStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitImportWhereStatement(s)
	}
}

func (p *DorisParser) ImportWhereStatement() (localctx IImportWhereStatementContext) {
	localctx = NewImportWhereStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, DorisParserRULE_importWhereStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2403)
		p.Match(DorisParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2404)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportPrecedingFilterStatementContext is an interface to support dynamic dispatch.
type IImportPrecedingFilterStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRECEDING() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsImportPrecedingFilterStatementContext differentiates from other interfaces.
	IsImportPrecedingFilterStatementContext()
}

type ImportPrecedingFilterStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportPrecedingFilterStatementContext() *ImportPrecedingFilterStatementContext {
	var p = new(ImportPrecedingFilterStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_importPrecedingFilterStatement
	return p
}

func InitEmptyImportPrecedingFilterStatementContext(p *ImportPrecedingFilterStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_importPrecedingFilterStatement
}

func (*ImportPrecedingFilterStatementContext) IsImportPrecedingFilterStatementContext() {}

func NewImportPrecedingFilterStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportPrecedingFilterStatementContext {
	var p = new(ImportPrecedingFilterStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_importPrecedingFilterStatement

	return p
}

func (s *ImportPrecedingFilterStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportPrecedingFilterStatementContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(DorisParserPRECEDING, 0)
}

func (s *ImportPrecedingFilterStatementContext) FILTER() antlr.TerminalNode {
	return s.GetToken(DorisParserFILTER, 0)
}

func (s *ImportPrecedingFilterStatementContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ImportPrecedingFilterStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportPrecedingFilterStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportPrecedingFilterStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterImportPrecedingFilterStatement(s)
	}
}

func (s *ImportPrecedingFilterStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitImportPrecedingFilterStatement(s)
	}
}

func (p *DorisParser) ImportPrecedingFilterStatement() (localctx IImportPrecedingFilterStatementContext) {
	localctx = NewImportPrecedingFilterStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, DorisParserRULE_importPrecedingFilterStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2406)
		p.Match(DorisParserPRECEDING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2407)
		p.Match(DorisParserFILTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2408)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportColumnsStatementContext is an interface to support dynamic dispatch.
type IImportColumnsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLUMNS() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	AllImportColumnDesc() []IImportColumnDescContext
	ImportColumnDesc(i int) IImportColumnDescContext
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsImportColumnsStatementContext differentiates from other interfaces.
	IsImportColumnsStatementContext()
}

type ImportColumnsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportColumnsStatementContext() *ImportColumnsStatementContext {
	var p = new(ImportColumnsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_importColumnsStatement
	return p
}

func InitEmptyImportColumnsStatementContext(p *ImportColumnsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_importColumnsStatement
}

func (*ImportColumnsStatementContext) IsImportColumnsStatementContext() {}

func NewImportColumnsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportColumnsStatementContext {
	var p = new(ImportColumnsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_importColumnsStatement

	return p
}

func (s *ImportColumnsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportColumnsStatementContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMNS, 0)
}

func (s *ImportColumnsStatementContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ImportColumnsStatementContext) AllImportColumnDesc() []IImportColumnDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportColumnDescContext); ok {
			len++
		}
	}

	tst := make([]IImportColumnDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportColumnDescContext); ok {
			tst[i] = t.(IImportColumnDescContext)
			i++
		}
	}

	return tst
}

func (s *ImportColumnsStatementContext) ImportColumnDesc(i int) IImportColumnDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportColumnDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportColumnDescContext)
}

func (s *ImportColumnsStatementContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ImportColumnsStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ImportColumnsStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ImportColumnsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportColumnsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportColumnsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterImportColumnsStatement(s)
	}
}

func (s *ImportColumnsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitImportColumnsStatement(s)
	}
}

func (p *DorisParser) ImportColumnsStatement() (localctx IImportColumnsStatementContext) {
	localctx = NewImportColumnsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, DorisParserRULE_importColumnsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2410)
		p.Match(DorisParserCOLUMNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2411)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2412)
		p.ImportColumnDesc()
	}
	p.SetState(2417)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(2413)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2414)
			p.ImportColumnDesc()
		}

		p.SetState(2419)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2420)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportColumnDescContext is an interface to support dynamic dispatch.
type IImportColumnDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	Identifier() IIdentifierContext
	EQ() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode

	// IsImportColumnDescContext differentiates from other interfaces.
	IsImportColumnDescContext()
}

type ImportColumnDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyImportColumnDescContext() *ImportColumnDescContext {
	var p = new(ImportColumnDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_importColumnDesc
	return p
}

func InitEmptyImportColumnDescContext(p *ImportColumnDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_importColumnDesc
}

func (*ImportColumnDescContext) IsImportColumnDescContext() {}

func NewImportColumnDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportColumnDescContext {
	var p = new(ImportColumnDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_importColumnDesc

	return p
}

func (s *ImportColumnDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportColumnDescContext) GetName() IIdentifierContext { return s.name }

func (s *ImportColumnDescContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ImportColumnDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ImportColumnDescContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *ImportColumnDescContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ImportColumnDescContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ImportColumnDescContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ImportColumnDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportColumnDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportColumnDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterImportColumnDesc(s)
	}
}

func (s *ImportColumnDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitImportColumnDesc(s)
	}
}

func (p *DorisParser) ImportColumnDesc() (localctx IImportColumnDescContext) {
	localctx = NewImportColumnDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, DorisParserRULE_importColumnDesc)
	var _la int

	p.SetState(2435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2422)

			var _x = p.Identifier()

			localctx.(*ImportColumnDescContext).name = _x
		}
		p.SetState(2425)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserEQ {
			{
				p.SetState(2423)
				p.Match(DorisParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2424)
				p.booleanExpression(0)
			}

		}

	case DorisParserLEFT_PAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2427)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2428)

			var _x = p.Identifier()

			localctx.(*ImportColumnDescContext).name = _x
		}
		p.SetState(2431)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserEQ {
			{
				p.SetState(2429)
				p.Match(DorisParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2430)
				p.booleanExpression(0)
			}

		}
		{
			p.SetState(2433)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChannelDescriptionsContext is an interface to support dynamic dispatch.
type IChannelDescriptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllChannelDescription() []IChannelDescriptionContext
	ChannelDescription(i int) IChannelDescriptionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsChannelDescriptionsContext differentiates from other interfaces.
	IsChannelDescriptionsContext()
}

type ChannelDescriptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChannelDescriptionsContext() *ChannelDescriptionsContext {
	var p = new(ChannelDescriptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_channelDescriptions
	return p
}

func InitEmptyChannelDescriptionsContext(p *ChannelDescriptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_channelDescriptions
}

func (*ChannelDescriptionsContext) IsChannelDescriptionsContext() {}

func NewChannelDescriptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChannelDescriptionsContext {
	var p = new(ChannelDescriptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_channelDescriptions

	return p
}

func (s *ChannelDescriptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ChannelDescriptionsContext) AllChannelDescription() []IChannelDescriptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IChannelDescriptionContext); ok {
			len++
		}
	}

	tst := make([]IChannelDescriptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IChannelDescriptionContext); ok {
			tst[i] = t.(IChannelDescriptionContext)
			i++
		}
	}

	return tst
}

func (s *ChannelDescriptionsContext) ChannelDescription(i int) IChannelDescriptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelDescriptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelDescriptionContext)
}

func (s *ChannelDescriptionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ChannelDescriptionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ChannelDescriptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChannelDescriptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChannelDescriptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterChannelDescriptions(s)
	}
}

func (s *ChannelDescriptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitChannelDescriptions(s)
	}
}

func (p *DorisParser) ChannelDescriptions() (localctx IChannelDescriptionsContext) {
	localctx = NewChannelDescriptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, DorisParserRULE_channelDescriptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2437)
		p.ChannelDescription()
	}
	p.SetState(2442)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(2438)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2439)
			p.ChannelDescription()
		}

		p.SetState(2444)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChannelDescriptionContext is an interface to support dynamic dispatch.
type IChannelDescriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSource returns the source rule contexts.
	GetSource() IMultipartIdentifierContext

	// GetDestination returns the destination rule contexts.
	GetDestination() IMultipartIdentifierContext

	// GetColumnList returns the columnList rule contexts.
	GetColumnList() IIdentifierListContext

	// SetSource sets the source rule contexts.
	SetSource(IMultipartIdentifierContext)

	// SetDestination sets the destination rule contexts.
	SetDestination(IMultipartIdentifierContext)

	// SetColumnList sets the columnList rule contexts.
	SetColumnList(IIdentifierListContext)

	// Getter signatures
	FROM() antlr.TerminalNode
	INTO() antlr.TerminalNode
	AllMultipartIdentifier() []IMultipartIdentifierContext
	MultipartIdentifier(i int) IMultipartIdentifierContext
	PartitionSpec() IPartitionSpecContext
	IdentifierList() IIdentifierListContext

	// IsChannelDescriptionContext differentiates from other interfaces.
	IsChannelDescriptionContext()
}

type ChannelDescriptionContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	source      IMultipartIdentifierContext
	destination IMultipartIdentifierContext
	columnList  IIdentifierListContext
}

func NewEmptyChannelDescriptionContext() *ChannelDescriptionContext {
	var p = new(ChannelDescriptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_channelDescription
	return p
}

func InitEmptyChannelDescriptionContext(p *ChannelDescriptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_channelDescription
}

func (*ChannelDescriptionContext) IsChannelDescriptionContext() {}

func NewChannelDescriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChannelDescriptionContext {
	var p = new(ChannelDescriptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_channelDescription

	return p
}

func (s *ChannelDescriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ChannelDescriptionContext) GetSource() IMultipartIdentifierContext { return s.source }

func (s *ChannelDescriptionContext) GetDestination() IMultipartIdentifierContext {
	return s.destination
}

func (s *ChannelDescriptionContext) GetColumnList() IIdentifierListContext { return s.columnList }

func (s *ChannelDescriptionContext) SetSource(v IMultipartIdentifierContext) { s.source = v }

func (s *ChannelDescriptionContext) SetDestination(v IMultipartIdentifierContext) { s.destination = v }

func (s *ChannelDescriptionContext) SetColumnList(v IIdentifierListContext) { s.columnList = v }

func (s *ChannelDescriptionContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ChannelDescriptionContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserINTO, 0)
}

func (s *ChannelDescriptionContext) AllMultipartIdentifier() []IMultipartIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultipartIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipartIdentifierContext); ok {
			tst[i] = t.(IMultipartIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ChannelDescriptionContext) MultipartIdentifier(i int) IMultipartIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ChannelDescriptionContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *ChannelDescriptionContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ChannelDescriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChannelDescriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChannelDescriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterChannelDescription(s)
	}
}

func (s *ChannelDescriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitChannelDescription(s)
	}
}

func (p *DorisParser) ChannelDescription() (localctx IChannelDescriptionContext) {
	localctx = NewChannelDescriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, DorisParserRULE_channelDescription)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2445)
		p.Match(DorisParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2446)

		var _x = p.MultipartIdentifier()

		localctx.(*ChannelDescriptionContext).source = _x
	}
	{
		p.SetState(2447)
		p.Match(DorisParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2448)

		var _x = p.MultipartIdentifier()

		localctx.(*ChannelDescriptionContext).destination = _x
	}
	p.SetState(2450)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
		{
			p.SetState(2449)
			p.PartitionSpec()
		}

	}
	p.SetState(2453)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLEFT_PAREN {
		{
			p.SetState(2452)

			var _x = p.IdentifierList()

			localctx.(*ChannelDescriptionContext).columnList = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedRefreshStatementContext is an interface to support dynamic dispatch.
type ISupportedRefreshStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedRefreshStatementContext differentiates from other interfaces.
	IsSupportedRefreshStatementContext()
}

type SupportedRefreshStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedRefreshStatementContext() *SupportedRefreshStatementContext {
	var p = new(SupportedRefreshStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedRefreshStatement
	return p
}

func InitEmptySupportedRefreshStatementContext(p *SupportedRefreshStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedRefreshStatement
}

func (*SupportedRefreshStatementContext) IsSupportedRefreshStatementContext() {}

func NewSupportedRefreshStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedRefreshStatementContext {
	var p = new(SupportedRefreshStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedRefreshStatement

	return p
}

func (s *SupportedRefreshStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedRefreshStatementContext) CopyAll(ctx *SupportedRefreshStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedRefreshStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedRefreshStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RefreshCatalogContext struct {
	SupportedRefreshStatementContext
	name IIdentifierContext
}

func NewRefreshCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RefreshCatalogContext {
	var p = new(RefreshCatalogContext)

	InitEmptySupportedRefreshStatementContext(&p.SupportedRefreshStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedRefreshStatementContext))

	return p
}

func (s *RefreshCatalogContext) GetName() IIdentifierContext { return s.name }

func (s *RefreshCatalogContext) SetName(v IIdentifierContext) { s.name = v }

func (s *RefreshCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshCatalogContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserREFRESH, 0)
}

func (s *RefreshCatalogContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *RefreshCatalogContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RefreshCatalogContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *RefreshCatalogContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRefreshCatalog(s)
	}
}

func (s *RefreshCatalogContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRefreshCatalog(s)
	}
}

type RefreshDatabaseContext struct {
	SupportedRefreshStatementContext
	name IMultipartIdentifierContext
}

func NewRefreshDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RefreshDatabaseContext {
	var p = new(RefreshDatabaseContext)

	InitEmptySupportedRefreshStatementContext(&p.SupportedRefreshStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedRefreshStatementContext))

	return p
}

func (s *RefreshDatabaseContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *RefreshDatabaseContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *RefreshDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshDatabaseContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserREFRESH, 0)
}

func (s *RefreshDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *RefreshDatabaseContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *RefreshDatabaseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *RefreshDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRefreshDatabase(s)
	}
}

func (s *RefreshDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRefreshDatabase(s)
	}
}

type RefreshTableContext struct {
	SupportedRefreshStatementContext
	name IMultipartIdentifierContext
}

func NewRefreshTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RefreshTableContext {
	var p = new(RefreshTableContext)

	InitEmptySupportedRefreshStatementContext(&p.SupportedRefreshStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedRefreshStatementContext))

	return p
}

func (s *RefreshTableContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *RefreshTableContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *RefreshTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshTableContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserREFRESH, 0)
}

func (s *RefreshTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *RefreshTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *RefreshTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRefreshTable(s)
	}
}

func (s *RefreshTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRefreshTable(s)
	}
}

func (p *DorisParser) SupportedRefreshStatement() (localctx ISupportedRefreshStatementContext) {
	localctx = NewSupportedRefreshStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, DorisParserRULE_supportedRefreshStatement)
	var _la int

	p.SetState(2470)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 323, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRefreshCatalogContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2455)
			p.Match(DorisParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2456)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2457)

			var _x = p.Identifier()

			localctx.(*RefreshCatalogContext).name = _x
		}
		p.SetState(2459)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2458)
				p.PropertyClause()
			}

		}

	case 2:
		localctx = NewRefreshDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2461)
			p.Match(DorisParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2462)
			p.Match(DorisParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2463)

			var _x = p.MultipartIdentifier()

			localctx.(*RefreshDatabaseContext).name = _x
		}
		p.SetState(2465)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2464)
				p.PropertyClause()
			}

		}

	case 3:
		localctx = NewRefreshTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2467)
			p.Match(DorisParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2468)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2469)

			var _x = p.MultipartIdentifier()

			localctx.(*RefreshTableContext).name = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedCleanStatementContext is an interface to support dynamic dispatch.
type ISupportedCleanStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedCleanStatementContext differentiates from other interfaces.
	IsSupportedCleanStatementContext()
}

type SupportedCleanStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedCleanStatementContext() *SupportedCleanStatementContext {
	var p = new(SupportedCleanStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedCleanStatement
	return p
}

func InitEmptySupportedCleanStatementContext(p *SupportedCleanStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedCleanStatement
}

func (*SupportedCleanStatementContext) IsSupportedCleanStatementContext() {}

func NewSupportedCleanStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedCleanStatementContext {
	var p = new(SupportedCleanStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedCleanStatement

	return p
}

func (s *SupportedCleanStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedCleanStatementContext) CopyAll(ctx *SupportedCleanStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedCleanStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedCleanStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CleanLabelContext struct {
	SupportedCleanStatementContext
	label    IIdentifierContext
	database IIdentifierContext
}

func NewCleanLabelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CleanLabelContext {
	var p = new(CleanLabelContext)

	InitEmptySupportedCleanStatementContext(&p.SupportedCleanStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCleanStatementContext))

	return p
}

func (s *CleanLabelContext) GetLabel() IIdentifierContext { return s.label }

func (s *CleanLabelContext) GetDatabase() IIdentifierContext { return s.database }

func (s *CleanLabelContext) SetLabel(v IIdentifierContext) { s.label = v }

func (s *CleanLabelContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *CleanLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CleanLabelContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(DorisParserCLEAN, 0)
}

func (s *CleanLabelContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisParserLABEL, 0)
}

func (s *CleanLabelContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *CleanLabelContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *CleanLabelContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CleanLabelContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CleanLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCleanLabel(s)
	}
}

func (s *CleanLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCleanLabel(s)
	}
}

type CleanAllProfileContext struct {
	SupportedCleanStatementContext
}

func NewCleanAllProfileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CleanAllProfileContext {
	var p = new(CleanAllProfileContext)

	InitEmptySupportedCleanStatementContext(&p.SupportedCleanStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCleanStatementContext))

	return p
}

func (s *CleanAllProfileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CleanAllProfileContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(DorisParserCLEAN, 0)
}

func (s *CleanAllProfileContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *CleanAllProfileContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserPROFILE, 0)
}

func (s *CleanAllProfileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCleanAllProfile(s)
	}
}

func (s *CleanAllProfileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCleanAllProfile(s)
	}
}

func (p *DorisParser) SupportedCleanStatement() (localctx ISupportedCleanStatementContext) {
	localctx = NewSupportedCleanStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, DorisParserRULE_supportedCleanStatement)
	var _la int

	p.SetState(2482)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 325, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCleanAllProfileContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2472)
			p.Match(DorisParserCLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2473)
			p.Match(DorisParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2474)
			p.Match(DorisParserPROFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewCleanLabelContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2475)
			p.Match(DorisParserCLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2476)
			p.Match(DorisParserLABEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2478)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8646881558152553984) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&3026312906716208575) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-6232424940973963725) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&3937129999880936915) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-2873958502894674957) != 0) || ((int64((_la-322)) & ^0x3f) == 0 && ((int64(1)<<(_la-322))&6912752233721878527) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&-2627780018309275847) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&150083289320141) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&49159) != 0) {
			{
				p.SetState(2477)

				var _x = p.Identifier()

				localctx.(*CleanLabelContext).label = _x
			}

		}
		{
			p.SetState(2480)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserFROM || _la == DorisParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2481)

			var _x = p.Identifier()

			localctx.(*CleanLabelContext).database = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedRefreshStatementContext is an interface to support dynamic dispatch.
type IUnsupportedRefreshStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedRefreshStatementContext differentiates from other interfaces.
	IsUnsupportedRefreshStatementContext()
}

type UnsupportedRefreshStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedRefreshStatementContext() *UnsupportedRefreshStatementContext {
	var p = new(UnsupportedRefreshStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedRefreshStatement
	return p
}

func InitEmptyUnsupportedRefreshStatementContext(p *UnsupportedRefreshStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedRefreshStatement
}

func (*UnsupportedRefreshStatementContext) IsUnsupportedRefreshStatementContext() {}

func NewUnsupportedRefreshStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedRefreshStatementContext {
	var p = new(UnsupportedRefreshStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedRefreshStatement

	return p
}

func (s *UnsupportedRefreshStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedRefreshStatementContext) CopyAll(ctx *UnsupportedRefreshStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedRefreshStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedRefreshStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RefreshLdapContext struct {
	UnsupportedRefreshStatementContext
	user IIdentifierOrTextContext
}

func NewRefreshLdapContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RefreshLdapContext {
	var p = new(RefreshLdapContext)

	InitEmptyUnsupportedRefreshStatementContext(&p.UnsupportedRefreshStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedRefreshStatementContext))

	return p
}

func (s *RefreshLdapContext) GetUser() IIdentifierOrTextContext { return s.user }

func (s *RefreshLdapContext) SetUser(v IIdentifierOrTextContext) { s.user = v }

func (s *RefreshLdapContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshLdapContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserREFRESH, 0)
}

func (s *RefreshLdapContext) LDAP() antlr.TerminalNode {
	return s.GetToken(DorisParserLDAP, 0)
}

func (s *RefreshLdapContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *RefreshLdapContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *RefreshLdapContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *RefreshLdapContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRefreshLdap(s)
	}
}

func (s *RefreshLdapContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRefreshLdap(s)
	}
}

func (p *DorisParser) UnsupportedRefreshStatement() (localctx IUnsupportedRefreshStatementContext) {
	localctx = NewUnsupportedRefreshStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, DorisParserRULE_unsupportedRefreshStatement)
	localctx = NewRefreshLdapContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2484)
		p.Match(DorisParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2485)
		p.Match(DorisParserLDAP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2489)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserALL:
		{
			p.SetState(2486)
			p.Match(DorisParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserFOR:
		{
			p.SetState(2487)
			p.Match(DorisParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2488)

			var _x = p.IdentifierOrText()

			localctx.(*RefreshLdapContext).user = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedCleanStatementContext is an interface to support dynamic dispatch.
type IUnsupportedCleanStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedCleanStatementContext differentiates from other interfaces.
	IsUnsupportedCleanStatementContext()
}

type UnsupportedCleanStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedCleanStatementContext() *UnsupportedCleanStatementContext {
	var p = new(UnsupportedCleanStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedCleanStatement
	return p
}

func InitEmptyUnsupportedCleanStatementContext(p *UnsupportedCleanStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedCleanStatement
}

func (*UnsupportedCleanStatementContext) IsUnsupportedCleanStatementContext() {}

func NewUnsupportedCleanStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedCleanStatementContext {
	var p = new(UnsupportedCleanStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedCleanStatement

	return p
}

func (s *UnsupportedCleanStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedCleanStatementContext) CopyAll(ctx *UnsupportedCleanStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedCleanStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedCleanStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CleanQueryStatsContext struct {
	UnsupportedCleanStatementContext
	database IIdentifierContext
	table    IMultipartIdentifierContext
}

func NewCleanQueryStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CleanQueryStatsContext {
	var p = new(CleanQueryStatsContext)

	InitEmptyUnsupportedCleanStatementContext(&p.UnsupportedCleanStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCleanStatementContext))

	return p
}

func (s *CleanQueryStatsContext) GetDatabase() IIdentifierContext { return s.database }

func (s *CleanQueryStatsContext) GetTable() IMultipartIdentifierContext { return s.table }

func (s *CleanQueryStatsContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *CleanQueryStatsContext) SetTable(v IMultipartIdentifierContext) { s.table = v }

func (s *CleanQueryStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CleanQueryStatsContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(DorisParserCLEAN, 0)
}

func (s *CleanQueryStatsContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DorisParserQUERY, 0)
}

func (s *CleanQueryStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *CleanQueryStatsContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *CleanQueryStatsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CleanQueryStatsContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *CleanQueryStatsContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *CleanQueryStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CleanQueryStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCleanQueryStats(s)
	}
}

func (s *CleanQueryStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCleanQueryStats(s)
	}
}

type CleanAllQueryStatsContext struct {
	UnsupportedCleanStatementContext
}

func NewCleanAllQueryStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CleanAllQueryStatsContext {
	var p = new(CleanAllQueryStatsContext)

	InitEmptyUnsupportedCleanStatementContext(&p.UnsupportedCleanStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCleanStatementContext))

	return p
}

func (s *CleanAllQueryStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CleanAllQueryStatsContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(DorisParserCLEAN, 0)
}

func (s *CleanAllQueryStatsContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *CleanAllQueryStatsContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DorisParserQUERY, 0)
}

func (s *CleanAllQueryStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *CleanAllQueryStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCleanAllQueryStats(s)
	}
}

func (s *CleanAllQueryStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCleanAllQueryStats(s)
	}
}

func (p *DorisParser) UnsupportedCleanStatement() (localctx IUnsupportedCleanStatementContext) {
	localctx = NewUnsupportedCleanStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, DorisParserRULE_unsupportedCleanStatement)
	var _la int

	p.SetState(2504)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 328, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCleanQueryStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2491)
			p.Match(DorisParserCLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2492)
			p.Match(DorisParserQUERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2493)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2498)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserFOR:
			{
				p.SetState(2494)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2495)

				var _x = p.Identifier()

				localctx.(*CleanQueryStatsContext).database = _x
			}

		case DorisParserFROM, DorisParserIN:
			{
				p.SetState(2496)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2497)

				var _x = p.MultipartIdentifier()

				localctx.(*CleanQueryStatsContext).table = _x
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		localctx = NewCleanAllQueryStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2500)
			p.Match(DorisParserCLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2501)
			p.Match(DorisParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2502)
			p.Match(DorisParserQUERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2503)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedCancelStatementContext is an interface to support dynamic dispatch.
type ISupportedCancelStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedCancelStatementContext differentiates from other interfaces.
	IsSupportedCancelStatementContext()
}

type SupportedCancelStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedCancelStatementContext() *SupportedCancelStatementContext {
	var p = new(SupportedCancelStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedCancelStatement
	return p
}

func InitEmptySupportedCancelStatementContext(p *SupportedCancelStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedCancelStatement
}

func (*SupportedCancelStatementContext) IsSupportedCancelStatementContext() {}

func NewSupportedCancelStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedCancelStatementContext {
	var p = new(SupportedCancelStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedCancelStatement

	return p
}

func (s *SupportedCancelStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedCancelStatementContext) CopyAll(ctx *SupportedCancelStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedCancelStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedCancelStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CancelWarmUpJobContext struct {
	SupportedCancelStatementContext
}

func NewCancelWarmUpJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelWarmUpJobContext {
	var p = new(CancelWarmUpJobContext)

	InitEmptySupportedCancelStatementContext(&p.SupportedCancelStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCancelStatementContext))

	return p
}

func (s *CancelWarmUpJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelWarmUpJobContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *CancelWarmUpJobContext) WARM() antlr.TerminalNode {
	return s.GetToken(DorisParserWARM, 0)
}

func (s *CancelWarmUpJobContext) UP() antlr.TerminalNode {
	return s.GetToken(DorisParserUP, 0)
}

func (s *CancelWarmUpJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *CancelWarmUpJobContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *CancelWarmUpJobContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCancelWarmUpJob(s)
	}
}

func (s *CancelWarmUpJobContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCancelWarmUpJob(s)
	}
}

type CancelExportContext struct {
	SupportedCancelStatementContext
	database IIdentifierContext
}

func NewCancelExportContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelExportContext {
	var p = new(CancelExportContext)

	InitEmptySupportedCancelStatementContext(&p.SupportedCancelStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCancelStatementContext))

	return p
}

func (s *CancelExportContext) GetDatabase() IIdentifierContext { return s.database }

func (s *CancelExportContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *CancelExportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelExportContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *CancelExportContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(DorisParserEXPORT, 0)
}

func (s *CancelExportContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *CancelExportContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *CancelExportContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *CancelExportContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelExportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCancelExport(s)
	}
}

func (s *CancelExportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCancelExport(s)
	}
}

type CancelLoadContext struct {
	SupportedCancelStatementContext
	database IIdentifierContext
}

func NewCancelLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelLoadContext {
	var p = new(CancelLoadContext)

	InitEmptySupportedCancelStatementContext(&p.SupportedCancelStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCancelStatementContext))

	return p
}

func (s *CancelLoadContext) GetDatabase() IIdentifierContext { return s.database }

func (s *CancelLoadContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *CancelLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelLoadContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *CancelLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *CancelLoadContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *CancelLoadContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *CancelLoadContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *CancelLoadContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCancelLoad(s)
	}
}

func (s *CancelLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCancelLoad(s)
	}
}

func (p *DorisParser) SupportedCancelStatement() (localctx ISupportedCancelStatementContext) {
	localctx = NewSupportedCancelStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, DorisParserRULE_supportedCancelStatement)
	var _la int

	p.SetState(2531)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 334, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCancelLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2506)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2507)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2510)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2508)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2509)

				var _x = p.Identifier()

				localctx.(*CancelLoadContext).database = _x
			}

		}
		p.SetState(2513)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2512)
				p.WildWhere()
			}

		}

	case 2:
		localctx = NewCancelExportContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2515)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2516)
			p.Match(DorisParserEXPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2517)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2518)

				var _x = p.Identifier()

				localctx.(*CancelExportContext).database = _x
			}

		}
		p.SetState(2522)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2521)
				p.WildWhere()
			}

		}

	case 3:
		localctx = NewCancelWarmUpJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2524)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2525)
			p.Match(DorisParserWARM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2526)
			p.Match(DorisParserUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2527)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2529)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2528)
				p.WildWhere()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedCancelStatementContext is an interface to support dynamic dispatch.
type IUnsupportedCancelStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedCancelStatementContext differentiates from other interfaces.
	IsUnsupportedCancelStatementContext()
}

type UnsupportedCancelStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedCancelStatementContext() *UnsupportedCancelStatementContext {
	var p = new(UnsupportedCancelStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedCancelStatement
	return p
}

func InitEmptyUnsupportedCancelStatementContext(p *UnsupportedCancelStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedCancelStatement
}

func (*UnsupportedCancelStatementContext) IsUnsupportedCancelStatementContext() {}

func NewUnsupportedCancelStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedCancelStatementContext {
	var p = new(UnsupportedCancelStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedCancelStatement

	return p
}

func (s *UnsupportedCancelStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedCancelStatementContext) CopyAll(ctx *UnsupportedCancelStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedCancelStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedCancelStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CancelBackupContext struct {
	UnsupportedCancelStatementContext
	database IIdentifierContext
}

func NewCancelBackupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelBackupContext {
	var p = new(CancelBackupContext)

	InitEmptyUnsupportedCancelStatementContext(&p.UnsupportedCancelStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCancelStatementContext))

	return p
}

func (s *CancelBackupContext) GetDatabase() IIdentifierContext { return s.database }

func (s *CancelBackupContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *CancelBackupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelBackupContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *CancelBackupContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKUP, 0)
}

func (s *CancelBackupContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *CancelBackupContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *CancelBackupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelBackupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCancelBackup(s)
	}
}

func (s *CancelBackupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCancelBackup(s)
	}
}

type CancelBuildIndexContext struct {
	UnsupportedCancelStatementContext
	tableName      IMultipartIdentifierContext
	_INTEGER_VALUE antlr.Token
	jobIds         []antlr.Token
}

func NewCancelBuildIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelBuildIndexContext {
	var p = new(CancelBuildIndexContext)

	InitEmptyUnsupportedCancelStatementContext(&p.UnsupportedCancelStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCancelStatementContext))

	return p
}

func (s *CancelBuildIndexContext) Get_INTEGER_VALUE() antlr.Token { return s._INTEGER_VALUE }

func (s *CancelBuildIndexContext) Set_INTEGER_VALUE(v antlr.Token) { s._INTEGER_VALUE = v }

func (s *CancelBuildIndexContext) GetJobIds() []antlr.Token { return s.jobIds }

func (s *CancelBuildIndexContext) SetJobIds(v []antlr.Token) { s.jobIds = v }

func (s *CancelBuildIndexContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *CancelBuildIndexContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *CancelBuildIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelBuildIndexContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *CancelBuildIndexContext) BUILD() antlr.TerminalNode {
	return s.GetToken(DorisParserBUILD, 0)
}

func (s *CancelBuildIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *CancelBuildIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *CancelBuildIndexContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CancelBuildIndexContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CancelBuildIndexContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CancelBuildIndexContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserINTEGER_VALUE)
}

func (s *CancelBuildIndexContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, i)
}

func (s *CancelBuildIndexContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *CancelBuildIndexContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *CancelBuildIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCancelBuildIndex(s)
	}
}

func (s *CancelBuildIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCancelBuildIndex(s)
	}
}

type CancelRestoreContext struct {
	UnsupportedCancelStatementContext
	database IIdentifierContext
}

func NewCancelRestoreContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelRestoreContext {
	var p = new(CancelRestoreContext)

	InitEmptyUnsupportedCancelStatementContext(&p.UnsupportedCancelStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCancelStatementContext))

	return p
}

func (s *CancelRestoreContext) GetDatabase() IIdentifierContext { return s.database }

func (s *CancelRestoreContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *CancelRestoreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelRestoreContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *CancelRestoreContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESTORE, 0)
}

func (s *CancelRestoreContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *CancelRestoreContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *CancelRestoreContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelRestoreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCancelRestore(s)
	}
}

func (s *CancelRestoreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCancelRestore(s)
	}
}

type CancelAlterTableContext struct {
	UnsupportedCancelStatementContext
	tableName      IMultipartIdentifierContext
	_INTEGER_VALUE antlr.Token
	jobIds         []antlr.Token
}

func NewCancelAlterTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelAlterTableContext {
	var p = new(CancelAlterTableContext)

	InitEmptyUnsupportedCancelStatementContext(&p.UnsupportedCancelStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCancelStatementContext))

	return p
}

func (s *CancelAlterTableContext) Get_INTEGER_VALUE() antlr.Token { return s._INTEGER_VALUE }

func (s *CancelAlterTableContext) Set_INTEGER_VALUE(v antlr.Token) { s._INTEGER_VALUE = v }

func (s *CancelAlterTableContext) GetJobIds() []antlr.Token { return s.jobIds }

func (s *CancelAlterTableContext) SetJobIds(v []antlr.Token) { s.jobIds = v }

func (s *CancelAlterTableContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *CancelAlterTableContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *CancelAlterTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelAlterTableContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *CancelAlterTableContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *CancelAlterTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *CancelAlterTableContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *CancelAlterTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CancelAlterTableContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *CancelAlterTableContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *CancelAlterTableContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CancelAlterTableContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CancelAlterTableContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *CancelAlterTableContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *CancelAlterTableContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserINTEGER_VALUE)
}

func (s *CancelAlterTableContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, i)
}

func (s *CancelAlterTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *CancelAlterTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *CancelAlterTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCancelAlterTable(s)
	}
}

func (s *CancelAlterTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCancelAlterTable(s)
	}
}

type CancelDecommisionBackendContext struct {
	UnsupportedCancelStatementContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
}

func NewCancelDecommisionBackendContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelDecommisionBackendContext {
	var p = new(CancelDecommisionBackendContext)

	InitEmptyUnsupportedCancelStatementContext(&p.UnsupportedCancelStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCancelStatementContext))

	return p
}

func (s *CancelDecommisionBackendContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *CancelDecommisionBackendContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *CancelDecommisionBackendContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *CancelDecommisionBackendContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *CancelDecommisionBackendContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelDecommisionBackendContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *CancelDecommisionBackendContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(DorisParserDECOMMISSION, 0)
}

func (s *CancelDecommisionBackendContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKEND, 0)
}

func (s *CancelDecommisionBackendContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *CancelDecommisionBackendContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *CancelDecommisionBackendContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *CancelDecommisionBackendContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *CancelDecommisionBackendContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCancelDecommisionBackend(s)
	}
}

func (s *CancelDecommisionBackendContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCancelDecommisionBackend(s)
	}
}

func (p *DorisParser) UnsupportedCancelStatement() (localctx IUnsupportedCancelStatementContext) {
	localctx = NewUnsupportedCancelStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, DorisParserRULE_unsupportedCancelStatement)
	var _la int

	p.SetState(2596)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 343, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCancelAlterTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2533)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2534)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2535)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2540)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserROLLUP:
			{
				p.SetState(2536)
				p.Match(DorisParserROLLUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserMATERIALIZED:
			{
				p.SetState(2537)
				p.Match(DorisParserMATERIALIZED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2538)
				p.Match(DorisParserVIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCOLUMN:
			{
				p.SetState(2539)
				p.Match(DorisParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(2542)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2543)

			var _x = p.MultipartIdentifier()

			localctx.(*CancelAlterTableContext).tableName = _x
		}
		p.SetState(2554)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(2544)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2545)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*CancelAlterTableContext)._INTEGER_VALUE = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*CancelAlterTableContext).jobIds = append(localctx.(*CancelAlterTableContext).jobIds, localctx.(*CancelAlterTableContext)._INTEGER_VALUE)
			p.SetState(2550)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(2546)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2547)

					var _m = p.Match(DorisParserINTEGER_VALUE)

					localctx.(*CancelAlterTableContext)._INTEGER_VALUE = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*CancelAlterTableContext).jobIds = append(localctx.(*CancelAlterTableContext).jobIds, localctx.(*CancelAlterTableContext)._INTEGER_VALUE)

				p.SetState(2552)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2553)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		localctx = NewCancelBuildIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2556)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2557)
			p.Match(DorisParserBUILD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2558)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2559)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2560)

			var _x = p.MultipartIdentifier()

			localctx.(*CancelBuildIndexContext).tableName = _x
		}
		p.SetState(2571)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(2561)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2562)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*CancelBuildIndexContext)._INTEGER_VALUE = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*CancelBuildIndexContext).jobIds = append(localctx.(*CancelBuildIndexContext).jobIds, localctx.(*CancelBuildIndexContext)._INTEGER_VALUE)
			p.SetState(2567)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(2563)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2564)

					var _m = p.Match(DorisParserINTEGER_VALUE)

					localctx.(*CancelBuildIndexContext)._INTEGER_VALUE = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*CancelBuildIndexContext).jobIds = append(localctx.(*CancelBuildIndexContext).jobIds, localctx.(*CancelBuildIndexContext)._INTEGER_VALUE)

				p.SetState(2569)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2570)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		localctx = NewCancelDecommisionBackendContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2573)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2574)
			p.Match(DorisParserDECOMMISSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2575)
			p.Match(DorisParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2576)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*CancelDecommisionBackendContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*CancelDecommisionBackendContext).hostPorts = append(localctx.(*CancelDecommisionBackendContext).hostPorts, localctx.(*CancelDecommisionBackendContext)._STRING_LITERAL)
		p.SetState(2581)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(2577)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2578)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*CancelDecommisionBackendContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*CancelDecommisionBackendContext).hostPorts = append(localctx.(*CancelDecommisionBackendContext).hostPorts, localctx.(*CancelDecommisionBackendContext)._STRING_LITERAL)

			p.SetState(2583)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 4:
		localctx = NewCancelBackupContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2584)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2585)
			p.Match(DorisParserBACKUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2588)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2586)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2587)

				var _x = p.Identifier()

				localctx.(*CancelBackupContext).database = _x
			}

		}

	case 5:
		localctx = NewCancelRestoreContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2590)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2591)
			p.Match(DorisParserRESTORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2594)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2592)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2593)

				var _x = p.Identifier()

				localctx.(*CancelRestoreContext).database = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedAdminStatementContext is an interface to support dynamic dispatch.
type ISupportedAdminStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedAdminStatementContext differentiates from other interfaces.
	IsSupportedAdminStatementContext()
}

type SupportedAdminStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedAdminStatementContext() *SupportedAdminStatementContext {
	var p = new(SupportedAdminStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedAdminStatement
	return p
}

func InitEmptySupportedAdminStatementContext(p *SupportedAdminStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedAdminStatement
}

func (*SupportedAdminStatementContext) IsSupportedAdminStatementContext() {}

func NewSupportedAdminStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedAdminStatementContext {
	var p = new(SupportedAdminStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedAdminStatement

	return p
}

func (s *SupportedAdminStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedAdminStatementContext) CopyAll(ctx *SupportedAdminStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedAdminStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedAdminStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AdminShowReplicaDistributionContext struct {
	SupportedAdminStatementContext
}

func NewAdminShowReplicaDistributionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminShowReplicaDistributionContext {
	var p = new(AdminShowReplicaDistributionContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminShowReplicaDistributionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminShowReplicaDistributionContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminShowReplicaDistributionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *AdminShowReplicaDistributionContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLICA, 0)
}

func (s *AdminShowReplicaDistributionContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTRIBUTION, 0)
}

func (s *AdminShowReplicaDistributionContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *AdminShowReplicaDistributionContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *AdminShowReplicaDistributionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminShowReplicaDistribution(s)
	}
}

func (s *AdminShowReplicaDistributionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminShowReplicaDistribution(s)
	}
}

type AdminShowTabletStorageFormatContext struct {
	SupportedAdminStatementContext
}

func NewAdminShowTabletStorageFormatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminShowTabletStorageFormatContext {
	var p = new(AdminShowTabletStorageFormatContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminShowTabletStorageFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminShowTabletStorageFormatContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminShowTabletStorageFormatContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *AdminShowTabletStorageFormatContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLET, 0)
}

func (s *AdminShowTabletStorageFormatContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *AdminShowTabletStorageFormatContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DorisParserFORMAT, 0)
}

func (s *AdminShowTabletStorageFormatContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserVERBOSE, 0)
}

func (s *AdminShowTabletStorageFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminShowTabletStorageFormat(s)
	}
}

func (s *AdminShowTabletStorageFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminShowTabletStorageFormat(s)
	}
}

type AdminCheckTabletsContext struct {
	SupportedAdminStatementContext
	properties IPropertyClauseContext
}

func NewAdminCheckTabletsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminCheckTabletsContext {
	var p = new(AdminCheckTabletsContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminCheckTabletsContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AdminCheckTabletsContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AdminCheckTabletsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCheckTabletsContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminCheckTabletsContext) CHECK() antlr.TerminalNode {
	return s.GetToken(DorisParserCHECK, 0)
}

func (s *AdminCheckTabletsContext) TabletList() ITabletListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabletListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabletListContext)
}

func (s *AdminCheckTabletsContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AdminCheckTabletsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminCheckTablets(s)
	}
}

func (s *AdminCheckTabletsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminCheckTablets(s)
	}
}

type AdminRebalanceDiskContext struct {
	SupportedAdminStatementContext
	_STRING_LITERAL antlr.Token
	backends        []antlr.Token
}

func NewAdminRebalanceDiskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminRebalanceDiskContext {
	var p = new(AdminRebalanceDiskContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminRebalanceDiskContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *AdminRebalanceDiskContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *AdminRebalanceDiskContext) GetBackends() []antlr.Token { return s.backends }

func (s *AdminRebalanceDiskContext) SetBackends(v []antlr.Token) { s.backends = v }

func (s *AdminRebalanceDiskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminRebalanceDiskContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminRebalanceDiskContext) REBALANCE() antlr.TerminalNode {
	return s.GetToken(DorisParserREBALANCE, 0)
}

func (s *AdminRebalanceDiskContext) DISK() antlr.TerminalNode {
	return s.GetToken(DorisParserDISK, 0)
}

func (s *AdminRebalanceDiskContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *AdminRebalanceDiskContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AdminRebalanceDiskContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AdminRebalanceDiskContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *AdminRebalanceDiskContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *AdminRebalanceDiskContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AdminRebalanceDiskContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AdminRebalanceDiskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminRebalanceDisk(s)
	}
}

func (s *AdminRebalanceDiskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminRebalanceDisk(s)
	}
}

type AdminSetTableStatusContext struct {
	SupportedAdminStatementContext
	name       IMultipartIdentifierContext
	properties IPropertyClauseContext
}

func NewAdminSetTableStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminSetTableStatusContext {
	var p = new(AdminSetTableStatusContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminSetTableStatusContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AdminSetTableStatusContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AdminSetTableStatusContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AdminSetTableStatusContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AdminSetTableStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetTableStatusContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminSetTableStatusContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AdminSetTableStatusContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AdminSetTableStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATUS, 0)
}

func (s *AdminSetTableStatusContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AdminSetTableStatusContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AdminSetTableStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminSetTableStatus(s)
	}
}

func (s *AdminSetTableStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminSetTableStatus(s)
	}
}

type AdminCleanTrashContext struct {
	SupportedAdminStatementContext
	_STRING_LITERAL antlr.Token
	backends        []antlr.Token
}

func NewAdminCleanTrashContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminCleanTrashContext {
	var p = new(AdminCleanTrashContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminCleanTrashContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *AdminCleanTrashContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *AdminCleanTrashContext) GetBackends() []antlr.Token { return s.backends }

func (s *AdminCleanTrashContext) SetBackends(v []antlr.Token) { s.backends = v }

func (s *AdminCleanTrashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCleanTrashContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminCleanTrashContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(DorisParserCLEAN, 0)
}

func (s *AdminCleanTrashContext) TRASH() antlr.TerminalNode {
	return s.GetToken(DorisParserTRASH, 0)
}

func (s *AdminCleanTrashContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *AdminCleanTrashContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AdminCleanTrashContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AdminCleanTrashContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *AdminCleanTrashContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *AdminCleanTrashContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AdminCleanTrashContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AdminCleanTrashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminCleanTrash(s)
	}
}

func (s *AdminCleanTrashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminCleanTrash(s)
	}
}

type AdminCompactTableContext struct {
	SupportedAdminStatementContext
}

func NewAdminCompactTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminCompactTableContext {
	var p = new(AdminCompactTableContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminCompactTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCompactTableContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminCompactTableContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPACT, 0)
}

func (s *AdminCompactTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AdminCompactTableContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *AdminCompactTableContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserWHERE, 0)
}

func (s *AdminCompactTableContext) TYPE() antlr.TerminalNode {
	return s.GetToken(DorisParserTYPE, 0)
}

func (s *AdminCompactTableContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *AdminCompactTableContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *AdminCompactTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminCompactTable(s)
	}
}

func (s *AdminCompactTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminCompactTable(s)
	}
}

type AdminDiagnoseTabletContext struct {
	SupportedAdminStatementContext
	tabletId antlr.Token
}

func NewAdminDiagnoseTabletContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminDiagnoseTabletContext {
	var p = new(AdminDiagnoseTabletContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminDiagnoseTabletContext) GetTabletId() antlr.Token { return s.tabletId }

func (s *AdminDiagnoseTabletContext) SetTabletId(v antlr.Token) { s.tabletId = v }

func (s *AdminDiagnoseTabletContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminDiagnoseTabletContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminDiagnoseTabletContext) DIAGNOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserDIAGNOSE, 0)
}

func (s *AdminDiagnoseTabletContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLET, 0)
}

func (s *AdminDiagnoseTabletContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *AdminDiagnoseTabletContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminDiagnoseTablet(s)
	}
}

func (s *AdminDiagnoseTabletContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminDiagnoseTablet(s)
	}
}

type AdminCancelRebalanceDiskContext struct {
	SupportedAdminStatementContext
	_STRING_LITERAL antlr.Token
	backends        []antlr.Token
}

func NewAdminCancelRebalanceDiskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminCancelRebalanceDiskContext {
	var p = new(AdminCancelRebalanceDiskContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminCancelRebalanceDiskContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *AdminCancelRebalanceDiskContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *AdminCancelRebalanceDiskContext) GetBackends() []antlr.Token { return s.backends }

func (s *AdminCancelRebalanceDiskContext) SetBackends(v []antlr.Token) { s.backends = v }

func (s *AdminCancelRebalanceDiskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCancelRebalanceDiskContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminCancelRebalanceDiskContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *AdminCancelRebalanceDiskContext) REBALANCE() antlr.TerminalNode {
	return s.GetToken(DorisParserREBALANCE, 0)
}

func (s *AdminCancelRebalanceDiskContext) DISK() antlr.TerminalNode {
	return s.GetToken(DorisParserDISK, 0)
}

func (s *AdminCancelRebalanceDiskContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *AdminCancelRebalanceDiskContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AdminCancelRebalanceDiskContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AdminCancelRebalanceDiskContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *AdminCancelRebalanceDiskContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *AdminCancelRebalanceDiskContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AdminCancelRebalanceDiskContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AdminCancelRebalanceDiskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminCancelRebalanceDisk(s)
	}
}

func (s *AdminCancelRebalanceDiskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminCancelRebalanceDisk(s)
	}
}

type AdminShowReplicaStatusContext struct {
	SupportedAdminStatementContext
}

func NewAdminShowReplicaStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminShowReplicaStatusContext {
	var p = new(AdminShowReplicaStatusContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminShowReplicaStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminShowReplicaStatusContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminShowReplicaStatusContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *AdminShowReplicaStatusContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLICA, 0)
}

func (s *AdminShowReplicaStatusContext) AllSTATUS() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTATUS)
}

func (s *AdminShowReplicaStatusContext) STATUS(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTATUS, i)
}

func (s *AdminShowReplicaStatusContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *AdminShowReplicaStatusContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *AdminShowReplicaStatusContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserWHERE, 0)
}

func (s *AdminShowReplicaStatusContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *AdminShowReplicaStatusContext) NEQ() antlr.TerminalNode {
	return s.GetToken(DorisParserNEQ, 0)
}

func (s *AdminShowReplicaStatusContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *AdminShowReplicaStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminShowReplicaStatus(s)
	}
}

func (s *AdminShowReplicaStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminShowReplicaStatus(s)
	}
}

func (p *DorisParser) SupportedAdminStatement() (localctx ISupportedAdminStatementContext) {
	localctx = NewSupportedAdminStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, DorisParserRULE_supportedAdminStatement)
	var _la int

	p.SetState(2702)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 355, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAdminShowReplicaDistributionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2598)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2599)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2600)
			p.Match(DorisParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2601)
			p.Match(DorisParserDISTRIBUTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2602)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2603)
			p.BaseTableRef()
		}

	case 2:
		localctx = NewAdminRebalanceDiskContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2604)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2605)
			p.Match(DorisParserREBALANCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2606)
			p.Match(DorisParserDISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2618)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserON {
			{
				p.SetState(2607)
				p.Match(DorisParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2608)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2609)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*AdminRebalanceDiskContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*AdminRebalanceDiskContext).backends = append(localctx.(*AdminRebalanceDiskContext).backends, localctx.(*AdminRebalanceDiskContext)._STRING_LITERAL)
			p.SetState(2614)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(2610)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2611)

					var _m = p.Match(DorisParserSTRING_LITERAL)

					localctx.(*AdminRebalanceDiskContext)._STRING_LITERAL = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*AdminRebalanceDiskContext).backends = append(localctx.(*AdminRebalanceDiskContext).backends, localctx.(*AdminRebalanceDiskContext)._STRING_LITERAL)

				p.SetState(2616)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2617)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		localctx = NewAdminCancelRebalanceDiskContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2620)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2621)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2622)
			p.Match(DorisParserREBALANCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2623)
			p.Match(DorisParserDISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2635)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserON {
			{
				p.SetState(2624)
				p.Match(DorisParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2625)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2626)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*AdminCancelRebalanceDiskContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*AdminCancelRebalanceDiskContext).backends = append(localctx.(*AdminCancelRebalanceDiskContext).backends, localctx.(*AdminCancelRebalanceDiskContext)._STRING_LITERAL)
			p.SetState(2631)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(2627)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2628)

					var _m = p.Match(DorisParserSTRING_LITERAL)

					localctx.(*AdminCancelRebalanceDiskContext)._STRING_LITERAL = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*AdminCancelRebalanceDiskContext).backends = append(localctx.(*AdminCancelRebalanceDiskContext).backends, localctx.(*AdminCancelRebalanceDiskContext)._STRING_LITERAL)

				p.SetState(2633)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2634)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		localctx = NewAdminDiagnoseTabletContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2637)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2638)
			p.Match(DorisParserDIAGNOSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2639)
			p.Match(DorisParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2640)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*AdminDiagnoseTabletContext).tabletId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewAdminShowReplicaStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2641)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2642)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2643)
			p.Match(DorisParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2644)
			p.Match(DorisParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2645)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2646)
			p.BaseTableRef()
		}
		p.SetState(2652)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case DorisParserWHERE:
			{
				p.SetState(2647)
				p.Match(DorisParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2648)
				p.Match(DorisParserSTATUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2649)
				p.Match(DorisParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserNEQ:
			{
				p.SetState(2650)
				p.Match(DorisParserNEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2651)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserEOF, DorisParserSEMICOLON:

		default:
		}

	case 6:
		localctx = NewAdminCompactTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2654)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2655)
			p.Match(DorisParserCOMPACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2656)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2657)
			p.BaseTableRef()
		}
		p.SetState(2662)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWHERE {
			{
				p.SetState(2658)
				p.Match(DorisParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2659)
				p.Match(DorisParserTYPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2660)
				p.Match(DorisParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2661)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 7:
		localctx = NewAdminCheckTabletsContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2664)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2665)
			p.Match(DorisParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2666)
			p.TabletList()
		}
		p.SetState(2668)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2667)

				var _x = p.PropertyClause()

				localctx.(*AdminCheckTabletsContext).properties = _x
			}

		}

	case 8:
		localctx = NewAdminShowTabletStorageFormatContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2670)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2671)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2672)
			p.Match(DorisParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2673)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2674)
			p.Match(DorisParserFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2676)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserVERBOSE {
			{
				p.SetState(2675)
				p.Match(DorisParserVERBOSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 9:
		localctx = NewAdminCleanTrashContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2678)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2679)
			p.Match(DorisParserCLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2680)
			p.Match(DorisParserTRASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2692)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserON {
			{
				p.SetState(2681)
				p.Match(DorisParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2682)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2683)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*AdminCleanTrashContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*AdminCleanTrashContext).backends = append(localctx.(*AdminCleanTrashContext).backends, localctx.(*AdminCleanTrashContext)._STRING_LITERAL)
			p.SetState(2688)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(2684)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2685)

					var _m = p.Match(DorisParserSTRING_LITERAL)

					localctx.(*AdminCleanTrashContext)._STRING_LITERAL = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*AdminCleanTrashContext).backends = append(localctx.(*AdminCleanTrashContext).backends, localctx.(*AdminCleanTrashContext)._STRING_LITERAL)

				p.SetState(2690)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2691)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 10:
		localctx = NewAdminSetTableStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2694)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2695)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2696)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2697)

			var _x = p.MultipartIdentifier()

			localctx.(*AdminSetTableStatusContext).name = _x
		}
		{
			p.SetState(2698)
			p.Match(DorisParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2700)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2699)

				var _x = p.PropertyClause()

				localctx.(*AdminSetTableStatusContext).properties = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedRecoverStatementContext is an interface to support dynamic dispatch.
type ISupportedRecoverStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedRecoverStatementContext differentiates from other interfaces.
	IsSupportedRecoverStatementContext()
}

type SupportedRecoverStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedRecoverStatementContext() *SupportedRecoverStatementContext {
	var p = new(SupportedRecoverStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedRecoverStatement
	return p
}

func InitEmptySupportedRecoverStatementContext(p *SupportedRecoverStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedRecoverStatement
}

func (*SupportedRecoverStatementContext) IsSupportedRecoverStatementContext() {}

func NewSupportedRecoverStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedRecoverStatementContext {
	var p = new(SupportedRecoverStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedRecoverStatement

	return p
}

func (s *SupportedRecoverStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedRecoverStatementContext) CopyAll(ctx *SupportedRecoverStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedRecoverStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedRecoverStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RecoverPartitionContext struct {
	SupportedRecoverStatementContext
	name      IIdentifierContext
	id        antlr.Token
	alias     IIdentifierContext
	tableName IMultipartIdentifierContext
}

func NewRecoverPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RecoverPartitionContext {
	var p = new(RecoverPartitionContext)

	InitEmptySupportedRecoverStatementContext(&p.SupportedRecoverStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedRecoverStatementContext))

	return p
}

func (s *RecoverPartitionContext) GetId() antlr.Token { return s.id }

func (s *RecoverPartitionContext) SetId(v antlr.Token) { s.id = v }

func (s *RecoverPartitionContext) GetName() IIdentifierContext { return s.name }

func (s *RecoverPartitionContext) GetAlias() IIdentifierContext { return s.alias }

func (s *RecoverPartitionContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *RecoverPartitionContext) SetName(v IIdentifierContext) { s.name = v }

func (s *RecoverPartitionContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *RecoverPartitionContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *RecoverPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecoverPartitionContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(DorisParserRECOVER, 0)
}

func (s *RecoverPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *RecoverPartitionContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *RecoverPartitionContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RecoverPartitionContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RecoverPartitionContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *RecoverPartitionContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *RecoverPartitionContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *RecoverPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRecoverPartition(s)
	}
}

func (s *RecoverPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRecoverPartition(s)
	}
}

type RecoverTableContext struct {
	SupportedRecoverStatementContext
	name  IMultipartIdentifierContext
	id    antlr.Token
	alias IIdentifierContext
}

func NewRecoverTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RecoverTableContext {
	var p = new(RecoverTableContext)

	InitEmptySupportedRecoverStatementContext(&p.SupportedRecoverStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedRecoverStatementContext))

	return p
}

func (s *RecoverTableContext) GetId() antlr.Token { return s.id }

func (s *RecoverTableContext) SetId(v antlr.Token) { s.id = v }

func (s *RecoverTableContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *RecoverTableContext) GetAlias() IIdentifierContext { return s.alias }

func (s *RecoverTableContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *RecoverTableContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *RecoverTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecoverTableContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(DorisParserRECOVER, 0)
}

func (s *RecoverTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *RecoverTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *RecoverTableContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *RecoverTableContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *RecoverTableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RecoverTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRecoverTable(s)
	}
}

func (s *RecoverTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRecoverTable(s)
	}
}

type RecoverDatabaseContext struct {
	SupportedRecoverStatementContext
	name  IIdentifierContext
	id    antlr.Token
	alias IIdentifierContext
}

func NewRecoverDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RecoverDatabaseContext {
	var p = new(RecoverDatabaseContext)

	InitEmptySupportedRecoverStatementContext(&p.SupportedRecoverStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedRecoverStatementContext))

	return p
}

func (s *RecoverDatabaseContext) GetId() antlr.Token { return s.id }

func (s *RecoverDatabaseContext) SetId(v antlr.Token) { s.id = v }

func (s *RecoverDatabaseContext) GetName() IIdentifierContext { return s.name }

func (s *RecoverDatabaseContext) GetAlias() IIdentifierContext { return s.alias }

func (s *RecoverDatabaseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *RecoverDatabaseContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *RecoverDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecoverDatabaseContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(DorisParserRECOVER, 0)
}

func (s *RecoverDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *RecoverDatabaseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RecoverDatabaseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RecoverDatabaseContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *RecoverDatabaseContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *RecoverDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRecoverDatabase(s)
	}
}

func (s *RecoverDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRecoverDatabase(s)
	}
}

func (p *DorisParser) SupportedRecoverStatement() (localctx ISupportedRecoverStatementContext) {
	localctx = NewSupportedRecoverStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, DorisParserRULE_supportedRecoverStatement)
	var _la int

	p.SetState(2737)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 362, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRecoverDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2704)
			p.Match(DorisParserRECOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2705)
			p.Match(DorisParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2706)

			var _x = p.Identifier()

			localctx.(*RecoverDatabaseContext).name = _x
		}
		p.SetState(2708)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserINTEGER_VALUE {
			{
				p.SetState(2707)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*RecoverDatabaseContext).id = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2712)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAS {
			{
				p.SetState(2710)
				p.Match(DorisParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2711)

				var _x = p.Identifier()

				localctx.(*RecoverDatabaseContext).alias = _x
			}

		}

	case 2:
		localctx = NewRecoverTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2714)
			p.Match(DorisParserRECOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2715)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2716)

			var _x = p.MultipartIdentifier()

			localctx.(*RecoverTableContext).name = _x
		}
		p.SetState(2718)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserINTEGER_VALUE {
			{
				p.SetState(2717)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*RecoverTableContext).id = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2722)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAS {
			{
				p.SetState(2720)
				p.Match(DorisParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2721)

				var _x = p.Identifier()

				localctx.(*RecoverTableContext).alias = _x
			}

		}

	case 3:
		localctx = NewRecoverPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2724)
			p.Match(DorisParserRECOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2725)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2726)

			var _x = p.Identifier()

			localctx.(*RecoverPartitionContext).name = _x
		}
		p.SetState(2728)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserINTEGER_VALUE {
			{
				p.SetState(2727)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*RecoverPartitionContext).id = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2732)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAS {
			{
				p.SetState(2730)
				p.Match(DorisParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2731)

				var _x = p.Identifier()

				localctx.(*RecoverPartitionContext).alias = _x
			}

		}
		{
			p.SetState(2734)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2735)

			var _x = p.MultipartIdentifier()

			localctx.(*RecoverPartitionContext).tableName = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedAdminStatementContext is an interface to support dynamic dispatch.
type IUnsupportedAdminStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedAdminStatementContext differentiates from other interfaces.
	IsUnsupportedAdminStatementContext()
}

type UnsupportedAdminStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedAdminStatementContext() *UnsupportedAdminStatementContext {
	var p = new(UnsupportedAdminStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedAdminStatement
	return p
}

func InitEmptyUnsupportedAdminStatementContext(p *UnsupportedAdminStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedAdminStatement
}

func (*UnsupportedAdminStatementContext) IsUnsupportedAdminStatementContext() {}

func NewUnsupportedAdminStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedAdminStatementContext {
	var p = new(UnsupportedAdminStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedAdminStatement

	return p
}

func (s *UnsupportedAdminStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedAdminStatementContext) CopyAll(ctx *UnsupportedAdminStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedAdminStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedAdminStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AdminSetFrontendConfigContext struct {
	UnsupportedAdminStatementContext
}

func NewAdminSetFrontendConfigContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminSetFrontendConfigContext {
	var p = new(AdminSetFrontendConfigContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminSetFrontendConfigContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetFrontendConfigContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminSetFrontendConfigContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AdminSetFrontendConfigContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(DorisParserCONFIG, 0)
}

func (s *AdminSetFrontendConfigContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(DorisParserFRONTEND, 0)
}

func (s *AdminSetFrontendConfigContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AdminSetFrontendConfigContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AdminSetFrontendConfigContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AdminSetFrontendConfigContext) AllALL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserALL)
}

func (s *AdminSetFrontendConfigContext) ALL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserALL, i)
}

func (s *AdminSetFrontendConfigContext) FRONTENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserFRONTENDS, 0)
}

func (s *AdminSetFrontendConfigContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminSetFrontendConfig(s)
	}
}

func (s *AdminSetFrontendConfigContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminSetFrontendConfig(s)
	}
}

type AdminSetReplicaStatusContext struct {
	UnsupportedAdminStatementContext
}

func NewAdminSetReplicaStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminSetReplicaStatusContext {
	var p = new(AdminSetReplicaStatusContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminSetReplicaStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetReplicaStatusContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminSetReplicaStatusContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AdminSetReplicaStatusContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLICA, 0)
}

func (s *AdminSetReplicaStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATUS, 0)
}

func (s *AdminSetReplicaStatusContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *AdminSetReplicaStatusContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AdminSetReplicaStatusContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AdminSetReplicaStatusContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AdminSetReplicaStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminSetReplicaStatus(s)
	}
}

func (s *AdminSetReplicaStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminSetReplicaStatus(s)
	}
}

type AdminSetReplicaVersionContext struct {
	UnsupportedAdminStatementContext
}

func NewAdminSetReplicaVersionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminSetReplicaVersionContext {
	var p = new(AdminSetReplicaVersionContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminSetReplicaVersionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetReplicaVersionContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminSetReplicaVersionContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AdminSetReplicaVersionContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLICA, 0)
}

func (s *AdminSetReplicaVersionContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisParserVERSION, 0)
}

func (s *AdminSetReplicaVersionContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *AdminSetReplicaVersionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AdminSetReplicaVersionContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AdminSetReplicaVersionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AdminSetReplicaVersionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminSetReplicaVersion(s)
	}
}

func (s *AdminSetReplicaVersionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminSetReplicaVersion(s)
	}
}

type AdminSetPartitionVersionContext struct {
	UnsupportedAdminStatementContext
	name       IMultipartIdentifierContext
	properties IPropertyClauseContext
}

func NewAdminSetPartitionVersionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminSetPartitionVersionContext {
	var p = new(AdminSetPartitionVersionContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminSetPartitionVersionContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AdminSetPartitionVersionContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AdminSetPartitionVersionContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AdminSetPartitionVersionContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AdminSetPartitionVersionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetPartitionVersionContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminSetPartitionVersionContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AdminSetPartitionVersionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AdminSetPartitionVersionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *AdminSetPartitionVersionContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisParserVERSION, 0)
}

func (s *AdminSetPartitionVersionContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AdminSetPartitionVersionContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AdminSetPartitionVersionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminSetPartitionVersion(s)
	}
}

func (s *AdminSetPartitionVersionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminSetPartitionVersion(s)
	}
}

type AdminCancelRepairTableContext struct {
	UnsupportedAdminStatementContext
}

func NewAdminCancelRepairTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminCancelRepairTableContext {
	var p = new(AdminCancelRepairTableContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminCancelRepairTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCancelRepairTableContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminCancelRepairTableContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *AdminCancelRepairTableContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(DorisParserREPAIR, 0)
}

func (s *AdminCancelRepairTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AdminCancelRepairTableContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *AdminCancelRepairTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminCancelRepairTable(s)
	}
}

func (s *AdminCancelRepairTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminCancelRepairTable(s)
	}
}

type AdminCopyTabletContext struct {
	UnsupportedAdminStatementContext
	tabletId   antlr.Token
	properties IPropertyClauseContext
}

func NewAdminCopyTabletContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminCopyTabletContext {
	var p = new(AdminCopyTabletContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminCopyTabletContext) GetTabletId() antlr.Token { return s.tabletId }

func (s *AdminCopyTabletContext) SetTabletId(v antlr.Token) { s.tabletId = v }

func (s *AdminCopyTabletContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AdminCopyTabletContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AdminCopyTabletContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCopyTabletContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminCopyTabletContext) COPY() antlr.TerminalNode {
	return s.GetToken(DorisParserCOPY, 0)
}

func (s *AdminCopyTabletContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLET, 0)
}

func (s *AdminCopyTabletContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *AdminCopyTabletContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AdminCopyTabletContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminCopyTablet(s)
	}
}

func (s *AdminCopyTabletContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminCopyTablet(s)
	}
}

type AdminRepairTableContext struct {
	UnsupportedAdminStatementContext
}

func NewAdminRepairTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminRepairTableContext {
	var p = new(AdminRepairTableContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminRepairTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminRepairTableContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminRepairTableContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(DorisParserREPAIR, 0)
}

func (s *AdminRepairTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AdminRepairTableContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *AdminRepairTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminRepairTable(s)
	}
}

func (s *AdminRepairTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminRepairTable(s)
	}
}

func (p *DorisParser) UnsupportedAdminStatement() (localctx IUnsupportedAdminStatementContext) {
	localctx = NewUnsupportedAdminStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, DorisParserRULE_unsupportedAdminStatement)
	var _la int

	p.SetState(2799)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 368, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAdminSetReplicaStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2739)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2740)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2741)
			p.Match(DorisParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2742)
			p.Match(DorisParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2743)
			p.Match(DorisParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2744)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2745)
			p.PropertyItemList()
		}
		{
			p.SetState(2746)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewAdminSetReplicaVersionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2748)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2749)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2750)
			p.Match(DorisParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2751)
			p.Match(DorisParserVERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2752)
			p.Match(DorisParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2753)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2754)
			p.PropertyItemList()
		}
		{
			p.SetState(2755)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewAdminRepairTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2757)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2758)
			p.Match(DorisParserREPAIR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2759)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2760)
			p.BaseTableRef()
		}

	case 4:
		localctx = NewAdminCancelRepairTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2761)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2762)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2763)
			p.Match(DorisParserREPAIR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2764)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2765)
			p.BaseTableRef()
		}

	case 5:
		localctx = NewAdminSetFrontendConfigContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2766)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2767)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2771)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserFRONTEND:
			{
				p.SetState(2768)
				p.Match(DorisParserFRONTEND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserALL:
			{
				p.SetState(2769)
				p.Match(DorisParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2770)
				p.Match(DorisParserFRONTENDS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(2773)
			p.Match(DorisParserCONFIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2778)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(2774)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2775)
				p.PropertyItemList()
			}
			{
				p.SetState(2776)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2781)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserALL {
			{
				p.SetState(2780)
				p.Match(DorisParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		localctx = NewAdminSetPartitionVersionContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2783)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2784)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2785)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2786)

			var _x = p.MultipartIdentifier()

			localctx.(*AdminSetPartitionVersionContext).name = _x
		}
		{
			p.SetState(2787)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2788)
			p.Match(DorisParserVERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2790)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2789)

				var _x = p.PropertyClause()

				localctx.(*AdminSetPartitionVersionContext).properties = _x
			}

		}

	case 7:
		localctx = NewAdminCopyTabletContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2792)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2793)
			p.Match(DorisParserCOPY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2794)
			p.Match(DorisParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2795)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*AdminCopyTabletContext).tabletId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2797)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2796)

				var _x = p.PropertyClause()

				localctx.(*AdminCopyTabletContext).properties = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBaseTableRefContext is an interface to support dynamic dispatch.
type IBaseTableRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MultipartIdentifier() IMultipartIdentifierContext
	TableAlias() ITableAliasContext
	OptScanParams() IOptScanParamsContext
	TableSnapshot() ITableSnapshotContext
	SpecifiedPartition() ISpecifiedPartitionContext
	TabletList() ITabletListContext
	Sample() ISampleContext
	RelationHint() IRelationHintContext

	// IsBaseTableRefContext differentiates from other interfaces.
	IsBaseTableRefContext()
}

type BaseTableRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseTableRefContext() *BaseTableRefContext {
	var p = new(BaseTableRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_baseTableRef
	return p
}

func InitEmptyBaseTableRefContext(p *BaseTableRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_baseTableRef
}

func (*BaseTableRefContext) IsBaseTableRefContext() {}

func NewBaseTableRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseTableRefContext {
	var p = new(BaseTableRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_baseTableRef

	return p
}

func (s *BaseTableRefContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseTableRefContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *BaseTableRefContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *BaseTableRefContext) OptScanParams() IOptScanParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptScanParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptScanParamsContext)
}

func (s *BaseTableRefContext) TableSnapshot() ITableSnapshotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSnapshotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSnapshotContext)
}

func (s *BaseTableRefContext) SpecifiedPartition() ISpecifiedPartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecifiedPartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecifiedPartitionContext)
}

func (s *BaseTableRefContext) TabletList() ITabletListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabletListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabletListContext)
}

func (s *BaseTableRefContext) Sample() ISampleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleContext)
}

func (s *BaseTableRefContext) RelationHint() IRelationHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationHintContext)
}

func (s *BaseTableRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseTableRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseTableRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBaseTableRef(s)
	}
}

func (s *BaseTableRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBaseTableRef(s)
	}
}

func (p *DorisParser) BaseTableRef() (localctx IBaseTableRefContext) {
	localctx = NewBaseTableRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, DorisParserRULE_baseTableRef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2801)
		p.MultipartIdentifier()
	}
	p.SetState(2803)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserATSIGN {
		{
			p.SetState(2802)
			p.OptScanParams()
		}

	}
	p.SetState(2806)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserFOR {
		{
			p.SetState(2805)
			p.TableSnapshot()
		}

	}
	p.SetState(2809)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 371, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2808)
			p.SpecifiedPartition()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2812)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserTABLET {
		{
			p.SetState(2811)
			p.TabletList()
		}

	}
	{
		p.SetState(2814)
		p.TableAlias()
	}
	p.SetState(2816)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserTABLESAMPLE {
		{
			p.SetState(2815)
			p.Sample()
		}

	}
	p.SetState(2819)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLEFT_BRACKET || _la == DorisParserHINT_START {
		{
			p.SetState(2818)
			p.RelationHint()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWildWhereContext is an interface to support dynamic dispatch.
type IWildWhereContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIKE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsWildWhereContext differentiates from other interfaces.
	IsWildWhereContext()
}

type WildWhereContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWildWhereContext() *WildWhereContext {
	var p = new(WildWhereContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_wildWhere
	return p
}

func InitEmptyWildWhereContext(p *WildWhereContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_wildWhere
}

func (*WildWhereContext) IsWildWhereContext() {}

func NewWildWhereContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WildWhereContext {
	var p = new(WildWhereContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_wildWhere

	return p
}

func (s *WildWhereContext) GetParser() antlr.Parser { return s.parser }

func (s *WildWhereContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *WildWhereContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *WildWhereContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserWHERE, 0)
}

func (s *WildWhereContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WildWhereContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildWhereContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WildWhereContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWildWhere(s)
	}
}

func (s *WildWhereContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWildWhere(s)
	}
}

func (p *DorisParser) WildWhere() (localctx IWildWhereContext) {
	localctx = NewWildWhereContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, DorisParserRULE_wildWhere)
	p.SetState(2825)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLIKE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2821)
			p.Match(DorisParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2822)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserWHERE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2823)
			p.Match(DorisParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2824)
			p.Expression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedTransactionStatementContext is an interface to support dynamic dispatch.
type IUnsupportedTransactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedTransactionStatementContext differentiates from other interfaces.
	IsUnsupportedTransactionStatementContext()
}

type UnsupportedTransactionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedTransactionStatementContext() *UnsupportedTransactionStatementContext {
	var p = new(UnsupportedTransactionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedTransactionStatement
	return p
}

func InitEmptyUnsupportedTransactionStatementContext(p *UnsupportedTransactionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedTransactionStatement
}

func (*UnsupportedTransactionStatementContext) IsUnsupportedTransactionStatementContext() {}

func NewUnsupportedTransactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedTransactionStatementContext {
	var p = new(UnsupportedTransactionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedTransactionStatement

	return p
}

func (s *UnsupportedTransactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedTransactionStatementContext) CopyAll(ctx *UnsupportedTransactionStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedTransactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedTransactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TranscationCommitContext struct {
	UnsupportedTransactionStatementContext
}

func NewTranscationCommitContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TranscationCommitContext {
	var p = new(TranscationCommitContext)

	InitEmptyUnsupportedTransactionStatementContext(&p.UnsupportedTransactionStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedTransactionStatementContext))

	return p
}

func (s *TranscationCommitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TranscationCommitContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMIT, 0)
}

func (s *TranscationCommitContext) WORK() antlr.TerminalNode {
	return s.GetToken(DorisParserWORK, 0)
}

func (s *TranscationCommitContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisParserAND, 0)
}

func (s *TranscationCommitContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(DorisParserCHAIN, 0)
}

func (s *TranscationCommitContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(DorisParserRELEASE, 0)
}

func (s *TranscationCommitContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(DorisParserNO)
}

func (s *TranscationCommitContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserNO, i)
}

func (s *TranscationCommitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTranscationCommit(s)
	}
}

func (s *TranscationCommitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTranscationCommit(s)
	}
}

type TransactionRollbackContext struct {
	UnsupportedTransactionStatementContext
}

func NewTransactionRollbackContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TransactionRollbackContext {
	var p = new(TransactionRollbackContext)

	InitEmptyUnsupportedTransactionStatementContext(&p.UnsupportedTransactionStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedTransactionStatementContext))

	return p
}

func (s *TransactionRollbackContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionRollbackContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLBACK, 0)
}

func (s *TransactionRollbackContext) WORK() antlr.TerminalNode {
	return s.GetToken(DorisParserWORK, 0)
}

func (s *TransactionRollbackContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisParserAND, 0)
}

func (s *TransactionRollbackContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(DorisParserCHAIN, 0)
}

func (s *TransactionRollbackContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(DorisParserRELEASE, 0)
}

func (s *TransactionRollbackContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(DorisParserNO)
}

func (s *TransactionRollbackContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserNO, i)
}

func (s *TransactionRollbackContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTransactionRollback(s)
	}
}

func (s *TransactionRollbackContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTransactionRollback(s)
	}
}

type TransactionBeginContext struct {
	UnsupportedTransactionStatementContext
}

func NewTransactionBeginContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TransactionBeginContext {
	var p = new(TransactionBeginContext)

	InitEmptyUnsupportedTransactionStatementContext(&p.UnsupportedTransactionStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedTransactionStatementContext))

	return p
}

func (s *TransactionBeginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionBeginContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(DorisParserBEGIN, 0)
}

func (s *TransactionBeginContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *TransactionBeginContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisParserLABEL, 0)
}

func (s *TransactionBeginContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TransactionBeginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTransactionBegin(s)
	}
}

func (s *TransactionBeginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTransactionBegin(s)
	}
}

func (p *DorisParser) UnsupportedTransactionStatement() (localctx IUnsupportedTransactionStatementContext) {
	localctx = NewUnsupportedTransactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, DorisParserRULE_unsupportedTransactionStatement)
	var _la int

	p.SetState(2869)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserBEGIN:
		localctx = NewTransactionBeginContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2827)
			p.Match(DorisParserBEGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2833)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(2828)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2829)
				p.Match(DorisParserLABEL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2831)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8646881558152553984) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&3026312906716208575) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-6232424940973963725) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&3937129999880936915) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-2873958502894674957) != 0) || ((int64((_la-322)) & ^0x3f) == 0 && ((int64(1)<<(_la-322))&6912752233721878527) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&-2627780018309275847) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&150083289320141) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&49159) != 0) {
				{
					p.SetState(2830)
					p.Identifier()
				}

			}

		}

	case DorisParserCOMMIT:
		localctx = NewTranscationCommitContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2835)
			p.Match(DorisParserCOMMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2837)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWORK {
			{
				p.SetState(2836)
				p.Match(DorisParserWORK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2844)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAND {
			{
				p.SetState(2839)
				p.Match(DorisParserAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2841)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserNO {
				{
					p.SetState(2840)
					p.Match(DorisParserNO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(2843)
				p.Match(DorisParserCHAIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2850)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNO || _la == DorisParserRELEASE {
			p.SetState(2847)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserNO {
				{
					p.SetState(2846)
					p.Match(DorisParserNO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(2849)
				p.Match(DorisParserRELEASE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DorisParserROLLBACK:
		localctx = NewTransactionRollbackContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2852)
			p.Match(DorisParserROLLBACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2854)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWORK {
			{
				p.SetState(2853)
				p.Match(DorisParserWORK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2861)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAND {
			{
				p.SetState(2856)
				p.Match(DorisParserAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2858)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserNO {
				{
					p.SetState(2857)
					p.Match(DorisParserNO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(2860)
				p.Match(DorisParserCHAIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2867)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNO || _la == DorisParserRELEASE {
			p.SetState(2864)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserNO {
				{
					p.SetState(2863)
					p.Match(DorisParserNO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(2866)
				p.Match(DorisParserRELEASE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedGrantRevokeStatementContext is an interface to support dynamic dispatch.
type IUnsupportedGrantRevokeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedGrantRevokeStatementContext differentiates from other interfaces.
	IsUnsupportedGrantRevokeStatementContext()
}

type UnsupportedGrantRevokeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedGrantRevokeStatementContext() *UnsupportedGrantRevokeStatementContext {
	var p = new(UnsupportedGrantRevokeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedGrantRevokeStatement
	return p
}

func InitEmptyUnsupportedGrantRevokeStatementContext(p *UnsupportedGrantRevokeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedGrantRevokeStatement
}

func (*UnsupportedGrantRevokeStatementContext) IsUnsupportedGrantRevokeStatementContext() {}

func NewUnsupportedGrantRevokeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedGrantRevokeStatementContext {
	var p = new(UnsupportedGrantRevokeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedGrantRevokeStatement

	return p
}

func (s *UnsupportedGrantRevokeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedGrantRevokeStatementContext) CopyAll(ctx *UnsupportedGrantRevokeStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedGrantRevokeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedGrantRevokeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type GrantResourcePrivilegeContext struct {
	UnsupportedGrantRevokeStatementContext
}

func NewGrantResourcePrivilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantResourcePrivilegeContext {
	var p = new(GrantResourcePrivilegeContext)

	InitEmptyUnsupportedGrantRevokeStatementContext(&p.UnsupportedGrantRevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedGrantRevokeStatementContext))

	return p
}

func (s *GrantResourcePrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantResourcePrivilegeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(DorisParserGRANT, 0)
}

func (s *GrantResourcePrivilegeContext) PrivilegeList() IPrivilegeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeListContext)
}

func (s *GrantResourcePrivilegeContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *GrantResourcePrivilegeContext) IdentifierOrTextOrAsterisk() IIdentifierOrTextOrAsteriskContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextOrAsteriskContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextOrAsteriskContext)
}

func (s *GrantResourcePrivilegeContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *GrantResourcePrivilegeContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCE, 0)
}

func (s *GrantResourcePrivilegeContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(DorisParserCLUSTER, 0)
}

func (s *GrantResourcePrivilegeContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPUTE, 0)
}

func (s *GrantResourcePrivilegeContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUP, 0)
}

func (s *GrantResourcePrivilegeContext) STAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTAGE, 0)
}

func (s *GrantResourcePrivilegeContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *GrantResourcePrivilegeContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULT, 0)
}

func (s *GrantResourcePrivilegeContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserWORKLOAD, 0)
}

func (s *GrantResourcePrivilegeContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *GrantResourcePrivilegeContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *GrantResourcePrivilegeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *GrantResourcePrivilegeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisParserREVOKE, 0)
}

func (s *GrantResourcePrivilegeContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *GrantResourcePrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterGrantResourcePrivilege(s)
	}
}

func (s *GrantResourcePrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitGrantResourcePrivilege(s)
	}
}

type GrantTablePrivilegeContext struct {
	UnsupportedGrantRevokeStatementContext
}

func NewGrantTablePrivilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantTablePrivilegeContext {
	var p = new(GrantTablePrivilegeContext)

	InitEmptyUnsupportedGrantRevokeStatementContext(&p.UnsupportedGrantRevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedGrantRevokeStatementContext))

	return p
}

func (s *GrantTablePrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantTablePrivilegeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(DorisParserGRANT, 0)
}

func (s *GrantTablePrivilegeContext) PrivilegeList() IPrivilegeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeListContext)
}

func (s *GrantTablePrivilegeContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *GrantTablePrivilegeContext) MultipartIdentifierOrAsterisk() IMultipartIdentifierOrAsteriskContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierOrAsteriskContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierOrAsteriskContext)
}

func (s *GrantTablePrivilegeContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *GrantTablePrivilegeContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *GrantTablePrivilegeContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *GrantTablePrivilegeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *GrantTablePrivilegeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisParserREVOKE, 0)
}

func (s *GrantTablePrivilegeContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *GrantTablePrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterGrantTablePrivilege(s)
	}
}

func (s *GrantTablePrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitGrantTablePrivilege(s)
	}
}

type GrantRoleContext struct {
	UnsupportedGrantRevokeStatementContext
	_STRING_LITERAL antlr.Token
	roles           []antlr.Token
}

func NewGrantRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantRoleContext {
	var p = new(GrantRoleContext)

	InitEmptyUnsupportedGrantRevokeStatementContext(&p.UnsupportedGrantRevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedGrantRevokeStatementContext))

	return p
}

func (s *GrantRoleContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *GrantRoleContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *GrantRoleContext) GetRoles() []antlr.Token { return s.roles }

func (s *GrantRoleContext) SetRoles(v []antlr.Token) { s.roles = v }

func (s *GrantRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRoleContext) GRANT() antlr.TerminalNode {
	return s.GetToken(DorisParserGRANT, 0)
}

func (s *GrantRoleContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *GrantRoleContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *GrantRoleContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *GrantRoleContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *GrantRoleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *GrantRoleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *GrantRoleContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisParserREVOKE, 0)
}

func (s *GrantRoleContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *GrantRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterGrantRole(s)
	}
}

func (s *GrantRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitGrantRole(s)
	}
}

func (p *DorisParser) UnsupportedGrantRevokeStatement() (localctx IUnsupportedGrantRevokeStatementContext) {
	localctx = NewUnsupportedGrantRevokeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, DorisParserRULE_unsupportedGrantRevokeStatement)
	var _la int

	p.SetState(2955)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 397, p.GetParserRuleContext()) {
	case 1:
		localctx = NewGrantTablePrivilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2871)
			p.Match(DorisParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2872)
			p.PrivilegeList()
		}
		{
			p.SetState(2873)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2874)
			p.MultipartIdentifierOrAsterisk()
		}
		{
			p.SetState(2875)
			p.Match(DorisParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2879)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(2876)
				p.UserIdentify()
			}

		case DorisParserROLE:
			{
				p.SetState(2877)
				p.Match(DorisParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2878)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		localctx = NewGrantResourcePrivilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2881)
			p.Match(DorisParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2882)
			p.PrivilegeList()
		}
		{
			p.SetState(2883)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2893)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserRESOURCE:
			{
				p.SetState(2884)
				p.Match(DorisParserRESOURCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCLUSTER:
			{
				p.SetState(2885)
				p.Match(DorisParserCLUSTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCOMPUTE:
			{
				p.SetState(2886)
				p.Match(DorisParserCOMPUTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2887)
				p.Match(DorisParserGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserSTAGE:
			{
				p.SetState(2888)
				p.Match(DorisParserSTAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserSTORAGE:
			{
				p.SetState(2889)
				p.Match(DorisParserSTORAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2890)
				p.Match(DorisParserVAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserWORKLOAD:
			{
				p.SetState(2891)
				p.Match(DorisParserWORKLOAD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2892)
				p.Match(DorisParserGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(2895)
			p.IdentifierOrTextOrAsterisk()
		}
		{
			p.SetState(2896)
			p.Match(DorisParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2900)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(2897)
				p.UserIdentify()
			}

		case DorisParserROLE:
			{
				p.SetState(2898)
				p.Match(DorisParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2899)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		localctx = NewGrantRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2902)
			p.Match(DorisParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2903)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*GrantRoleContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*GrantRoleContext).roles = append(localctx.(*GrantRoleContext).roles, localctx.(*GrantRoleContext)._STRING_LITERAL)
		p.SetState(2908)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(2904)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2905)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*GrantRoleContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*GrantRoleContext).roles = append(localctx.(*GrantRoleContext).roles, localctx.(*GrantRoleContext)._STRING_LITERAL)

			p.SetState(2910)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2911)
			p.Match(DorisParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2912)
			p.UserIdentify()
		}

	case 4:
		localctx = NewGrantTablePrivilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2913)
			p.Match(DorisParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2914)
			p.PrivilegeList()
		}
		{
			p.SetState(2915)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2916)
			p.MultipartIdentifierOrAsterisk()
		}
		{
			p.SetState(2917)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2921)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(2918)
				p.UserIdentify()
			}

		case DorisParserROLE:
			{
				p.SetState(2919)
				p.Match(DorisParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2920)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 5:
		localctx = NewGrantResourcePrivilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2923)
			p.Match(DorisParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2924)
			p.PrivilegeList()
		}
		{
			p.SetState(2925)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2935)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserRESOURCE:
			{
				p.SetState(2926)
				p.Match(DorisParserRESOURCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCLUSTER:
			{
				p.SetState(2927)
				p.Match(DorisParserCLUSTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCOMPUTE:
			{
				p.SetState(2928)
				p.Match(DorisParserCOMPUTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2929)
				p.Match(DorisParserGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserSTAGE:
			{
				p.SetState(2930)
				p.Match(DorisParserSTAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserSTORAGE:
			{
				p.SetState(2931)
				p.Match(DorisParserSTORAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2932)
				p.Match(DorisParserVAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserWORKLOAD:
			{
				p.SetState(2933)
				p.Match(DorisParserWORKLOAD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2934)
				p.Match(DorisParserGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(2937)
			p.IdentifierOrTextOrAsterisk()
		}
		{
			p.SetState(2938)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2942)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(2939)
				p.UserIdentify()
			}

		case DorisParserROLE:
			{
				p.SetState(2940)
				p.Match(DorisParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2941)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 6:
		localctx = NewGrantRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2944)
			p.Match(DorisParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2945)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*GrantRoleContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*GrantRoleContext).roles = append(localctx.(*GrantRoleContext).roles, localctx.(*GrantRoleContext)._STRING_LITERAL)
		p.SetState(2950)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(2946)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2947)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*GrantRoleContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*GrantRoleContext).roles = append(localctx.(*GrantRoleContext).roles, localctx.(*GrantRoleContext)._STRING_LITERAL)

			p.SetState(2952)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2953)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2954)
			p.UserIdentify()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeContext is an interface to support dynamic dispatch.
type IPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IIdentifierListContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IIdentifierListContext)

	// Getter signatures
	Identifier() IIdentifierContext
	IdentifierList() IIdentifierListContext
	ALL() antlr.TerminalNode

	// IsPrivilegeContext differentiates from other interfaces.
	IsPrivilegeContext()
}

type PrivilegeContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	name    IIdentifierContext
	columns IIdentifierListContext
}

func NewEmptyPrivilegeContext() *PrivilegeContext {
	var p = new(PrivilegeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_privilege
	return p
}

func InitEmptyPrivilegeContext(p *PrivilegeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_privilege
}

func (*PrivilegeContext) IsPrivilegeContext() {}

func NewPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeContext {
	var p = new(PrivilegeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_privilege

	return p
}

func (s *PrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeContext) GetName() IIdentifierContext { return s.name }

func (s *PrivilegeContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *PrivilegeContext) SetName(v IIdentifierContext) { s.name = v }

func (s *PrivilegeContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *PrivilegeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrivilegeContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PrivilegeContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *PrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPrivilege(s)
	}
}

func (s *PrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPrivilege(s)
	}
}

func (p *DorisParser) Privilege() (localctx IPrivilegeContext) {
	localctx = NewPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, DorisParserRULE_privilege)
	var _la int

	p.SetState(2962)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2957)

			var _x = p.Identifier()

			localctx.(*PrivilegeContext).name = _x
		}
		p.SetState(2959)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(2958)

				var _x = p.IdentifierList()

				localctx.(*PrivilegeContext).columns = _x
			}

		}

	case DorisParserALL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2961)
			p.Match(DorisParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeListContext is an interface to support dynamic dispatch.
type IPrivilegeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrivilege() []IPrivilegeContext
	Privilege(i int) IPrivilegeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPrivilegeListContext differentiates from other interfaces.
	IsPrivilegeListContext()
}

type PrivilegeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeListContext() *PrivilegeListContext {
	var p = new(PrivilegeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_privilegeList
	return p
}

func InitEmptyPrivilegeListContext(p *PrivilegeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_privilegeList
}

func (*PrivilegeListContext) IsPrivilegeListContext() {}

func NewPrivilegeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeListContext {
	var p = new(PrivilegeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_privilegeList

	return p
}

func (s *PrivilegeListContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeListContext) AllPrivilege() []IPrivilegeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivilegeContext); ok {
			len++
		}
	}

	tst := make([]IPrivilegeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivilegeContext); ok {
			tst[i] = t.(IPrivilegeContext)
			i++
		}
	}

	return tst
}

func (s *PrivilegeListContext) Privilege(i int) IPrivilegeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeContext)
}

func (s *PrivilegeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *PrivilegeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *PrivilegeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPrivilegeList(s)
	}
}

func (s *PrivilegeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPrivilegeList(s)
	}
}

func (p *DorisParser) PrivilegeList() (localctx IPrivilegeListContext) {
	localctx = NewPrivilegeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, DorisParserRULE_privilegeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2964)
		p.Privilege()
	}
	p.SetState(2969)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(2965)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2966)
			p.Privilege()
		}

		p.SetState(2971)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedAlterStatementContext is an interface to support dynamic dispatch.
type IUnsupportedAlterStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedAlterStatementContext differentiates from other interfaces.
	IsUnsupportedAlterStatementContext()
}

type UnsupportedAlterStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedAlterStatementContext() *UnsupportedAlterStatementContext {
	var p = new(UnsupportedAlterStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedAlterStatement
	return p
}

func InitEmptyUnsupportedAlterStatementContext(p *UnsupportedAlterStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedAlterStatement
}

func (*UnsupportedAlterStatementContext) IsUnsupportedAlterStatementContext() {}

func NewUnsupportedAlterStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedAlterStatementContext {
	var p = new(UnsupportedAlterStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedAlterStatement

	return p
}

func (s *UnsupportedAlterStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedAlterStatementContext) CopyAll(ctx *UnsupportedAlterStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedAlterStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedAlterStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AlterStoragePlicyContext struct {
	UnsupportedAlterStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewAlterStoragePlicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterStoragePlicyContext {
	var p = new(AlterStoragePlicyContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterStoragePlicyContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *AlterStoragePlicyContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterStoragePlicyContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *AlterStoragePlicyContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterStoragePlicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStoragePlicyContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterStoragePlicyContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *AlterStoragePlicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *AlterStoragePlicyContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *AlterStoragePlicyContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterStoragePlicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterStoragePlicy(s)
	}
}

func (s *AlterStoragePlicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterStoragePlicy(s)
	}
}

type AlterSystemContext struct {
	UnsupportedAlterStatementContext
}

func NewAlterSystemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterSystemContext {
	var p = new(AlterSystemContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterSystemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSystemContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterSystemContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(DorisParserSYSTEM, 0)
}

func (s *AlterSystemContext) AlterSystemClause() IAlterSystemClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterSystemClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterSystemClauseContext)
}

func (s *AlterSystemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterSystem(s)
	}
}

func (s *AlterSystemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterSystem(s)
	}
}

type AlterResourceContext struct {
	UnsupportedAlterStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewAlterResourceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterResourceContext {
	var p = new(AlterResourceContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterResourceContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *AlterResourceContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterResourceContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *AlterResourceContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterResourceContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterResourceContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCE, 0)
}

func (s *AlterResourceContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *AlterResourceContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterResourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterResource(s)
	}
}

func (s *AlterResourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterResource(s)
	}
}

type AlterRoutineLoadContext struct {
	UnsupportedAlterStatementContext
	name       IMultipartIdentifierContext
	properties IPropertyClauseContext
	type_      IIdentifierContext
}

func NewAlterRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterRoutineLoadContext {
	var p = new(AlterRoutineLoadContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterRoutineLoadContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterRoutineLoadContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterRoutineLoadContext) GetType_() IIdentifierContext { return s.type_ }

func (s *AlterRoutineLoadContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterRoutineLoadContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterRoutineLoadContext) SetType_(v IIdentifierContext) { s.type_ = v }

func (s *AlterRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRoutineLoadContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserROUTINE, 0)
}

func (s *AlterRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *AlterRoutineLoadContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *AlterRoutineLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterRoutineLoadContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *AlterRoutineLoadContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterRoutineLoadContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterRoutineLoadContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterRoutineLoadContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterRoutineLoadContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterRoutineLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterRoutineLoad(s)
	}
}

func (s *AlterRoutineLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterRoutineLoad(s)
	}
}

type AlterUserContext struct {
	UnsupportedAlterStatementContext
}

func NewAlterUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterUserContext {
	var p = new(AlterUserContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterUserContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisParserUSER, 0)
}

func (s *AlterUserContext) GrantUserIdentify() IGrantUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantUserIdentifyContext)
}

func (s *AlterUserContext) PasswordOption() IPasswordOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordOptionContext)
}

func (s *AlterUserContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *AlterUserContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *AlterUserContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *AlterUserContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *AlterUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterUser(s)
	}
}

func (s *AlterUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterUser(s)
	}
}

type AlterRepositoryContext struct {
	UnsupportedAlterStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewAlterRepositoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterRepositoryContext {
	var p = new(AlterRepositoryContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterRepositoryContext) GetName() IIdentifierContext { return s.name }

func (s *AlterRepositoryContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterRepositoryContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterRepositoryContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterRepositoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRepositoryContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterRepositoryContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisParserREPOSITORY, 0)
}

func (s *AlterRepositoryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterRepositoryContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterRepositoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterRepository(s)
	}
}

func (s *AlterRepositoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterRepository(s)
	}
}

type AlterDatabasePropertiesContext struct {
	UnsupportedAlterStatementContext
	name IIdentifierContext
}

func NewAlterDatabasePropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterDatabasePropertiesContext {
	var p = new(AlterDatabasePropertiesContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterDatabasePropertiesContext) GetName() IIdentifierContext { return s.name }

func (s *AlterDatabasePropertiesContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterDatabasePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabasePropertiesContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterDatabasePropertiesContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *AlterDatabasePropertiesContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterDatabasePropertiesContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *AlterDatabasePropertiesContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterDatabasePropertiesContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterDatabasePropertiesContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterDatabasePropertiesContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterDatabasePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterDatabaseProperties(s)
	}
}

func (s *AlterDatabasePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterDatabaseProperties(s)
	}
}

type AlterCatalogPropertiesContext struct {
	UnsupportedAlterStatementContext
	name IIdentifierContext
}

func NewAlterCatalogPropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterCatalogPropertiesContext {
	var p = new(AlterCatalogPropertiesContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterCatalogPropertiesContext) GetName() IIdentifierContext { return s.name }

func (s *AlterCatalogPropertiesContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterCatalogPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterCatalogPropertiesContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterCatalogPropertiesContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *AlterCatalogPropertiesContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterCatalogPropertiesContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *AlterCatalogPropertiesContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterCatalogPropertiesContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterCatalogPropertiesContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterCatalogPropertiesContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterCatalogPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterCatalogProperties(s)
	}
}

func (s *AlterCatalogPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterCatalogProperties(s)
	}
}

type AlterColocateGroupContext struct {
	UnsupportedAlterStatementContext
	name IMultipartIdentifierContext
}

func NewAlterColocateGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterColocateGroupContext {
	var p = new(AlterColocateGroupContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterColocateGroupContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterColocateGroupContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterColocateGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterColocateGroupContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterColocateGroupContext) COLOCATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLOCATE, 0)
}

func (s *AlterColocateGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUP, 0)
}

func (s *AlterColocateGroupContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterColocateGroupContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterColocateGroupContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterColocateGroupContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterColocateGroupContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterColocateGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterColocateGroup(s)
	}
}

func (s *AlterColocateGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterColocateGroup(s)
	}
}

func (p *DorisParser) UnsupportedAlterStatement() (localctx IUnsupportedAlterStatementContext) {
	localctx = NewUnsupportedAlterStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, DorisParserRULE_unsupportedAlterStatement)
	var _la int

	p.SetState(3048)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 407, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAlterSystemContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2972)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2973)
			p.Match(DorisParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2974)
			p.AlterSystemClause()
		}

	case 2:
		localctx = NewAlterDatabasePropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2975)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2976)
			p.Match(DorisParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2977)

			var _x = p.Identifier()

			localctx.(*AlterDatabasePropertiesContext).name = _x
		}
		{
			p.SetState(2978)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2979)
			p.Match(DorisParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2980)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2981)
			p.PropertyItemList()
		}
		{
			p.SetState(2982)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewAlterCatalogPropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2984)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2985)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2986)

			var _x = p.Identifier()

			localctx.(*AlterCatalogPropertiesContext).name = _x
		}
		{
			p.SetState(2987)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2988)
			p.Match(DorisParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2989)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2990)
			p.PropertyItemList()
		}
		{
			p.SetState(2991)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewAlterResourceContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2993)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2994)
			p.Match(DorisParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2995)

			var _x = p.IdentifierOrText()

			localctx.(*AlterResourceContext).name = _x
		}
		p.SetState(2997)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2996)

				var _x = p.PropertyClause()

				localctx.(*AlterResourceContext).properties = _x
			}

		}

	case 5:
		localctx = NewAlterColocateGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2999)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3000)
			p.Match(DorisParserCOLOCATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3001)
			p.Match(DorisParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3002)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterColocateGroupContext).name = _x
		}
		{
			p.SetState(3003)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3004)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3005)
			p.PropertyItemList()
		}
		{
			p.SetState(3006)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewAlterRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3008)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3009)
			p.Match(DorisParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3010)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3011)
			p.Match(DorisParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3012)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterRoutineLoadContext).name = _x
		}
		p.SetState(3014)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3013)

				var _x = p.PropertyClause()

				localctx.(*AlterRoutineLoadContext).properties = _x
			}

		}
		p.SetState(3022)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(3016)
				p.Match(DorisParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3017)

				var _x = p.Identifier()

				localctx.(*AlterRoutineLoadContext).type_ = _x
			}
			{
				p.SetState(3018)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3019)
				p.PropertyItemList()
			}
			{
				p.SetState(3020)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 7:
		localctx = NewAlterStoragePlicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3024)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3025)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3026)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3027)

			var _x = p.IdentifierOrText()

			localctx.(*AlterStoragePlicyContext).name = _x
		}
		{
			p.SetState(3028)

			var _x = p.PropertyClause()

			localctx.(*AlterStoragePlicyContext).properties = _x
		}

	case 8:
		localctx = NewAlterUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3030)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3031)
			p.Match(DorisParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3034)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(3032)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3033)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3036)
			p.GrantUserIdentify()
		}
		{
			p.SetState(3037)
			p.PasswordOption()
		}
		p.SetState(3040)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(3038)
				p.Match(DorisParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3039)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 9:
		localctx = NewAlterRepositoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3042)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3043)
			p.Match(DorisParserREPOSITORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3044)

			var _x = p.Identifier()

			localctx.(*AlterRepositoryContext).name = _x
		}
		p.SetState(3046)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3045)

				var _x = p.PropertyClause()

				localctx.(*AlterRepositoryContext).properties = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterSystemClauseContext is an interface to support dynamic dispatch.
type IAlterSystemClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlterSystemClauseContext differentiates from other interfaces.
	IsAlterSystemClauseContext()
}

type AlterSystemClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterSystemClauseContext() *AlterSystemClauseContext {
	var p = new(AlterSystemClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_alterSystemClause
	return p
}

func InitEmptyAlterSystemClauseContext(p *AlterSystemClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_alterSystemClause
}

func (*AlterSystemClauseContext) IsAlterSystemClauseContext() {}

func NewAlterSystemClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterSystemClauseContext {
	var p = new(AlterSystemClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_alterSystemClause

	return p
}

func (s *AlterSystemClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterSystemClauseContext) CopyAll(ctx *AlterSystemClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AlterSystemClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSystemClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DropBrokerClauseContext struct {
	AlterSystemClauseContext
	name            IIdentifierOrTextContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
}

func NewDropBrokerClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropBrokerClauseContext {
	var p = new(DropBrokerClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *DropBrokerClauseContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *DropBrokerClauseContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *DropBrokerClauseContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *DropBrokerClauseContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *DropBrokerClauseContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *DropBrokerClauseContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *DropBrokerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropBrokerClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropBrokerClauseContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserBROKER, 0)
}

func (s *DropBrokerClauseContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DropBrokerClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *DropBrokerClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *DropBrokerClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *DropBrokerClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *DropBrokerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropBrokerClause(s)
	}
}

func (s *DropBrokerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropBrokerClause(s)
	}
}

type ModifyFrontendOrBackendHostNameClauseContext struct {
	AlterSystemClauseContext
	hostPort antlr.Token
	hostName antlr.Token
}

func NewModifyFrontendOrBackendHostNameClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyFrontendOrBackendHostNameClauseContext {
	var p = new(ModifyFrontendOrBackendHostNameClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) GetHostPort() antlr.Token { return s.hostPort }

func (s *ModifyFrontendOrBackendHostNameClauseContext) GetHostName() antlr.Token { return s.hostName }

func (s *ModifyFrontendOrBackendHostNameClauseContext) SetHostPort(v antlr.Token) { s.hostPort = v }

func (s *ModifyFrontendOrBackendHostNameClauseContext) SetHostName(v antlr.Token) { s.hostName = v }

func (s *ModifyFrontendOrBackendHostNameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) HOSTNAME() antlr.TerminalNode {
	return s.GetToken(DorisParserHOSTNAME, 0)
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(DorisParserFRONTEND, 0)
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKEND, 0)
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterModifyFrontendOrBackendHostNameClause(s)
	}
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitModifyFrontendOrBackendHostNameClause(s)
	}
}

type DropObserverClauseContext struct {
	AlterSystemClauseContext
	hostPort antlr.Token
}

func NewDropObserverClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropObserverClauseContext {
	var p = new(DropObserverClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *DropObserverClauseContext) GetHostPort() antlr.Token { return s.hostPort }

func (s *DropObserverClauseContext) SetHostPort(v antlr.Token) { s.hostPort = v }

func (s *DropObserverClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropObserverClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropObserverClauseContext) OBSERVER() antlr.TerminalNode {
	return s.GetToken(DorisParserOBSERVER, 0)
}

func (s *DropObserverClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *DropObserverClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropObserverClause(s)
	}
}

func (s *DropObserverClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropObserverClause(s)
	}
}

type AddFollowerClauseContext struct {
	AlterSystemClauseContext
	hostPort antlr.Token
}

func NewAddFollowerClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddFollowerClauseContext {
	var p = new(AddFollowerClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *AddFollowerClauseContext) GetHostPort() antlr.Token { return s.hostPort }

func (s *AddFollowerClauseContext) SetHostPort(v antlr.Token) { s.hostPort = v }

func (s *AddFollowerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddFollowerClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddFollowerClauseContext) FOLLOWER() antlr.TerminalNode {
	return s.GetToken(DorisParserFOLLOWER, 0)
}

func (s *AddFollowerClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *AddFollowerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddFollowerClause(s)
	}
}

func (s *AddFollowerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddFollowerClause(s)
	}
}

type DropFollowerClauseContext struct {
	AlterSystemClauseContext
	hostPort antlr.Token
}

func NewDropFollowerClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropFollowerClauseContext {
	var p = new(DropFollowerClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *DropFollowerClauseContext) GetHostPort() antlr.Token { return s.hostPort }

func (s *DropFollowerClauseContext) SetHostPort(v antlr.Token) { s.hostPort = v }

func (s *DropFollowerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFollowerClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropFollowerClauseContext) FOLLOWER() antlr.TerminalNode {
	return s.GetToken(DorisParserFOLLOWER, 0)
}

func (s *DropFollowerClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *DropFollowerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropFollowerClause(s)
	}
}

func (s *DropFollowerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropFollowerClause(s)
	}
}

type DropAllBrokerClauseContext struct {
	AlterSystemClauseContext
	name IIdentifierOrTextContext
}

func NewDropAllBrokerClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropAllBrokerClauseContext {
	var p = new(DropAllBrokerClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *DropAllBrokerClauseContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *DropAllBrokerClauseContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *DropAllBrokerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropAllBrokerClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropAllBrokerClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *DropAllBrokerClauseContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserBROKER, 0)
}

func (s *DropAllBrokerClauseContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DropAllBrokerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropAllBrokerClause(s)
	}
}

func (s *DropAllBrokerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropAllBrokerClause(s)
	}
}

type DropBackendClauseContext struct {
	AlterSystemClauseContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
}

func NewDropBackendClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropBackendClauseContext {
	var p = new(DropBackendClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *DropBackendClauseContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *DropBackendClauseContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *DropBackendClauseContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *DropBackendClauseContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *DropBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKEND, 0)
}

func (s *DropBackendClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropBackendClauseContext) DROPP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROPP, 0)
}

func (s *DropBackendClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *DropBackendClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *DropBackendClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *DropBackendClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *DropBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropBackendClause(s)
	}
}

func (s *DropBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropBackendClause(s)
	}
}

type AlterLoadErrorUrlClauseContext struct {
	AlterSystemClauseContext
	properties IPropertyClauseContext
}

func NewAlterLoadErrorUrlClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterLoadErrorUrlClauseContext {
	var p = new(AlterLoadErrorUrlClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *AlterLoadErrorUrlClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterLoadErrorUrlClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterLoadErrorUrlClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterLoadErrorUrlClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterLoadErrorUrlClauseContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *AlterLoadErrorUrlClauseContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(DorisParserERRORS, 0)
}

func (s *AlterLoadErrorUrlClauseContext) HUB() antlr.TerminalNode {
	return s.GetToken(DorisParserHUB, 0)
}

func (s *AlterLoadErrorUrlClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterLoadErrorUrlClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterLoadErrorUrlClause(s)
	}
}

func (s *AlterLoadErrorUrlClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterLoadErrorUrlClause(s)
	}
}

type ModifyBackendClauseContext struct {
	AlterSystemClauseContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
}

func NewModifyBackendClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyBackendClauseContext {
	var p = new(ModifyBackendClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *ModifyBackendClauseContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *ModifyBackendClauseContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *ModifyBackendClauseContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *ModifyBackendClauseContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *ModifyBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyBackendClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *ModifyBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKEND, 0)
}

func (s *ModifyBackendClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *ModifyBackendClauseContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ModifyBackendClauseContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *ModifyBackendClauseContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ModifyBackendClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *ModifyBackendClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *ModifyBackendClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ModifyBackendClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ModifyBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterModifyBackendClause(s)
	}
}

func (s *ModifyBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitModifyBackendClause(s)
	}
}

type AddBrokerClauseContext struct {
	AlterSystemClauseContext
	name            IIdentifierOrTextContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
}

func NewAddBrokerClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddBrokerClauseContext {
	var p = new(AddBrokerClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *AddBrokerClauseContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *AddBrokerClauseContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *AddBrokerClauseContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *AddBrokerClauseContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *AddBrokerClauseContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *AddBrokerClauseContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *AddBrokerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddBrokerClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddBrokerClauseContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserBROKER, 0)
}

func (s *AddBrokerClauseContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *AddBrokerClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *AddBrokerClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *AddBrokerClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AddBrokerClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AddBrokerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddBrokerClause(s)
	}
}

func (s *AddBrokerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddBrokerClause(s)
	}
}

type AddObserverClauseContext struct {
	AlterSystemClauseContext
	hostPort antlr.Token
}

func NewAddObserverClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddObserverClauseContext {
	var p = new(AddObserverClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *AddObserverClauseContext) GetHostPort() antlr.Token { return s.hostPort }

func (s *AddObserverClauseContext) SetHostPort(v antlr.Token) { s.hostPort = v }

func (s *AddObserverClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddObserverClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddObserverClauseContext) OBSERVER() antlr.TerminalNode {
	return s.GetToken(DorisParserOBSERVER, 0)
}

func (s *AddObserverClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *AddObserverClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddObserverClause(s)
	}
}

func (s *AddObserverClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddObserverClause(s)
	}
}

type DecommissionBackendClauseContext struct {
	AlterSystemClauseContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
}

func NewDecommissionBackendClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecommissionBackendClauseContext {
	var p = new(DecommissionBackendClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *DecommissionBackendClauseContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *DecommissionBackendClauseContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *DecommissionBackendClauseContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *DecommissionBackendClauseContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *DecommissionBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecommissionBackendClauseContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(DorisParserDECOMMISSION, 0)
}

func (s *DecommissionBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKEND, 0)
}

func (s *DecommissionBackendClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *DecommissionBackendClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *DecommissionBackendClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *DecommissionBackendClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *DecommissionBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDecommissionBackendClause(s)
	}
}

func (s *DecommissionBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDecommissionBackendClause(s)
	}
}

type AddBackendClauseContext struct {
	AlterSystemClauseContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
	properties      IPropertyClauseContext
}

func NewAddBackendClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddBackendClauseContext {
	var p = new(AddBackendClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *AddBackendClauseContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *AddBackendClauseContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *AddBackendClauseContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *AddBackendClauseContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *AddBackendClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AddBackendClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AddBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddBackendClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKEND, 0)
}

func (s *AddBackendClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *AddBackendClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *AddBackendClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AddBackendClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AddBackendClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AddBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddBackendClause(s)
	}
}

func (s *AddBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddBackendClause(s)
	}
}

func (p *DorisParser) AlterSystemClause() (localctx IAlterSystemClauseContext) {
	localctx = NewAlterSystemClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, DorisParserRULE_alterSystemClause)
	var _la int

	p.SetState(3148)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 416, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAddBackendClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3050)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3051)
			p.Match(DorisParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3052)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*AddBackendClauseContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*AddBackendClauseContext).hostPorts = append(localctx.(*AddBackendClauseContext).hostPorts, localctx.(*AddBackendClauseContext)._STRING_LITERAL)
		p.SetState(3057)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(3053)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3054)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*AddBackendClauseContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*AddBackendClauseContext).hostPorts = append(localctx.(*AddBackendClauseContext).hostPorts, localctx.(*AddBackendClauseContext)._STRING_LITERAL)

			p.SetState(3059)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(3061)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3060)

				var _x = p.PropertyClause()

				localctx.(*AddBackendClauseContext).properties = _x
			}

		}

	case 2:
		localctx = NewDropBackendClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3063)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserDROP || _la == DorisParserDROPP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3064)
			p.Match(DorisParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3065)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*DropBackendClauseContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*DropBackendClauseContext).hostPorts = append(localctx.(*DropBackendClauseContext).hostPorts, localctx.(*DropBackendClauseContext)._STRING_LITERAL)
		p.SetState(3070)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(3066)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3067)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*DropBackendClauseContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*DropBackendClauseContext).hostPorts = append(localctx.(*DropBackendClauseContext).hostPorts, localctx.(*DropBackendClauseContext)._STRING_LITERAL)

			p.SetState(3072)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		localctx = NewDecommissionBackendClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3073)
			p.Match(DorisParserDECOMMISSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3074)
			p.Match(DorisParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3075)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*DecommissionBackendClauseContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*DecommissionBackendClauseContext).hostPorts = append(localctx.(*DecommissionBackendClauseContext).hostPorts, localctx.(*DecommissionBackendClauseContext)._STRING_LITERAL)
		p.SetState(3080)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(3076)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3077)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*DecommissionBackendClauseContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*DecommissionBackendClauseContext).hostPorts = append(localctx.(*DecommissionBackendClauseContext).hostPorts, localctx.(*DecommissionBackendClauseContext)._STRING_LITERAL)

			p.SetState(3082)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 4:
		localctx = NewAddObserverClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3083)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3084)
			p.Match(DorisParserOBSERVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3085)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*AddObserverClauseContext).hostPort = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewDropObserverClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3086)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3087)
			p.Match(DorisParserOBSERVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3088)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*DropObserverClauseContext).hostPort = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewAddFollowerClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3089)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3090)
			p.Match(DorisParserFOLLOWER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3091)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*AddFollowerClauseContext).hostPort = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewDropFollowerClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3092)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3093)
			p.Match(DorisParserFOLLOWER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3094)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*DropFollowerClauseContext).hostPort = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewAddBrokerClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3095)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3096)
			p.Match(DorisParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3097)

			var _x = p.IdentifierOrText()

			localctx.(*AddBrokerClauseContext).name = _x
		}
		{
			p.SetState(3098)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*AddBrokerClauseContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*AddBrokerClauseContext).hostPorts = append(localctx.(*AddBrokerClauseContext).hostPorts, localctx.(*AddBrokerClauseContext)._STRING_LITERAL)
		p.SetState(3103)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(3099)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3100)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*AddBrokerClauseContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*AddBrokerClauseContext).hostPorts = append(localctx.(*AddBrokerClauseContext).hostPorts, localctx.(*AddBrokerClauseContext)._STRING_LITERAL)

			p.SetState(3105)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 9:
		localctx = NewDropBrokerClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3106)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3107)
			p.Match(DorisParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3108)

			var _x = p.IdentifierOrText()

			localctx.(*DropBrokerClauseContext).name = _x
		}
		{
			p.SetState(3109)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*DropBrokerClauseContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*DropBrokerClauseContext).hostPorts = append(localctx.(*DropBrokerClauseContext).hostPorts, localctx.(*DropBrokerClauseContext)._STRING_LITERAL)
		p.SetState(3114)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(3110)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3111)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*DropBrokerClauseContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*DropBrokerClauseContext).hostPorts = append(localctx.(*DropBrokerClauseContext).hostPorts, localctx.(*DropBrokerClauseContext)._STRING_LITERAL)

			p.SetState(3116)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 10:
		localctx = NewDropAllBrokerClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3117)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3118)
			p.Match(DorisParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3119)
			p.Match(DorisParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3120)

			var _x = p.IdentifierOrText()

			localctx.(*DropAllBrokerClauseContext).name = _x
		}

	case 11:
		localctx = NewAlterLoadErrorUrlClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3121)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3122)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3123)
			p.Match(DorisParserERRORS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3124)
			p.Match(DorisParserHUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3126)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3125)

				var _x = p.PropertyClause()

				localctx.(*AlterLoadErrorUrlClauseContext).properties = _x
			}

		}

	case 12:
		localctx = NewModifyBackendClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3128)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3129)
			p.Match(DorisParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3130)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ModifyBackendClauseContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ModifyBackendClauseContext).hostPorts = append(localctx.(*ModifyBackendClauseContext).hostPorts, localctx.(*ModifyBackendClauseContext)._STRING_LITERAL)
		p.SetState(3135)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(3131)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3132)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*ModifyBackendClauseContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*ModifyBackendClauseContext).hostPorts = append(localctx.(*ModifyBackendClauseContext).hostPorts, localctx.(*ModifyBackendClauseContext)._STRING_LITERAL)

			p.SetState(3137)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3138)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3139)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3140)
			p.PropertyItemList()
		}
		{
			p.SetState(3141)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		localctx = NewModifyFrontendOrBackendHostNameClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3143)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3144)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserBACKEND || _la == DorisParserFRONTEND) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3145)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ModifyFrontendOrBackendHostNameClauseContext).hostPort = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3146)
			p.Match(DorisParserHOSTNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3147)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ModifyFrontendOrBackendHostNameClauseContext).hostName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropRollupClauseContext is an interface to support dynamic dispatch.
type IDropRollupClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// GetProperties returns the properties rule contexts.
	GetProperties() IPropertyClauseContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// SetProperties sets the properties rule contexts.
	SetProperties(IPropertyClauseContext)

	// Getter signatures
	Identifier() IIdentifierContext
	PropertyClause() IPropertyClauseContext

	// IsDropRollupClauseContext differentiates from other interfaces.
	IsDropRollupClauseContext()
}

type DropRollupClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
	properties IPropertyClauseContext
}

func NewEmptyDropRollupClauseContext() *DropRollupClauseContext {
	var p = new(DropRollupClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dropRollupClause
	return p
}

func InitEmptyDropRollupClauseContext(p *DropRollupClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dropRollupClause
}

func (*DropRollupClauseContext) IsDropRollupClauseContext() {}

func NewDropRollupClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropRollupClauseContext {
	var p = new(DropRollupClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_dropRollupClause

	return p
}

func (s *DropRollupClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropRollupClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *DropRollupClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *DropRollupClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *DropRollupClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *DropRollupClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropRollupClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *DropRollupClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRollupClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropRollupClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropRollupClause(s)
	}
}

func (s *DropRollupClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropRollupClause(s)
	}
}

func (p *DorisParser) DropRollupClause() (localctx IDropRollupClauseContext) {
	localctx = NewDropRollupClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, DorisParserRULE_dropRollupClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3150)

		var _x = p.Identifier()

		localctx.(*DropRollupClauseContext).rollupName = _x
	}
	p.SetState(3152)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPROPERTIES {
		{
			p.SetState(3151)

			var _x = p.PropertyClause()

			localctx.(*DropRollupClauseContext).properties = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddRollupClauseContext is an interface to support dynamic dispatch.
type IAddRollupClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IIdentifierListContext

	// GetDupKeys returns the dupKeys rule contexts.
	GetDupKeys() IIdentifierListContext

	// GetProperties returns the properties rule contexts.
	GetProperties() IPropertyClauseContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IIdentifierListContext)

	// SetDupKeys sets the dupKeys rule contexts.
	SetDupKeys(IIdentifierListContext)

	// SetProperties sets the properties rule contexts.
	SetProperties(IPropertyClauseContext)

	// Getter signatures
	Identifier() IIdentifierContext
	AllIdentifierList() []IIdentifierListContext
	IdentifierList(i int) IIdentifierListContext
	DUPLICATE() antlr.TerminalNode
	KEY() antlr.TerminalNode
	FromRollup() IFromRollupContext
	PropertyClause() IPropertyClauseContext

	// IsAddRollupClauseContext differentiates from other interfaces.
	IsAddRollupClauseContext()
}

type AddRollupClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
	columns    IIdentifierListContext
	dupKeys    IIdentifierListContext
	properties IPropertyClauseContext
}

func NewEmptyAddRollupClauseContext() *AddRollupClauseContext {
	var p = new(AddRollupClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_addRollupClause
	return p
}

func InitEmptyAddRollupClauseContext(p *AddRollupClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_addRollupClause
}

func (*AddRollupClauseContext) IsAddRollupClauseContext() {}

func NewAddRollupClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddRollupClauseContext {
	var p = new(AddRollupClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_addRollupClause

	return p
}

func (s *AddRollupClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddRollupClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *AddRollupClauseContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *AddRollupClauseContext) GetDupKeys() IIdentifierListContext { return s.dupKeys }

func (s *AddRollupClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AddRollupClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *AddRollupClauseContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *AddRollupClauseContext) SetDupKeys(v IIdentifierListContext) { s.dupKeys = v }

func (s *AddRollupClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AddRollupClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddRollupClauseContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *AddRollupClauseContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *AddRollupClauseContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(DorisParserDUPLICATE, 0)
}

func (s *AddRollupClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserKEY, 0)
}

func (s *AddRollupClauseContext) FromRollup() IFromRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromRollupContext)
}

func (s *AddRollupClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AddRollupClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddRollupClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddRollupClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddRollupClause(s)
	}
}

func (s *AddRollupClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddRollupClause(s)
	}
}

func (p *DorisParser) AddRollupClause() (localctx IAddRollupClauseContext) {
	localctx = NewAddRollupClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, DorisParserRULE_addRollupClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3154)

		var _x = p.Identifier()

		localctx.(*AddRollupClauseContext).rollupName = _x
	}
	{
		p.SetState(3155)

		var _x = p.IdentifierList()

		localctx.(*AddRollupClauseContext).columns = _x
	}
	p.SetState(3159)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserDUPLICATE {
		{
			p.SetState(3156)
			p.Match(DorisParserDUPLICATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3157)
			p.Match(DorisParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3158)

			var _x = p.IdentifierList()

			localctx.(*AddRollupClauseContext).dupKeys = _x
		}

	}
	p.SetState(3162)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserFROM {
		{
			p.SetState(3161)
			p.FromRollup()
		}

	}
	p.SetState(3165)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPROPERTIES {
		{
			p.SetState(3164)

			var _x = p.PropertyClause()

			localctx.(*AddRollupClauseContext).properties = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableClauseContext is an interface to support dynamic dispatch.
type IAlterTableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlterTableClauseContext differentiates from other interfaces.
	IsAlterTableClauseContext()
}

type AlterTableClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableClauseContext() *AlterTableClauseContext {
	var p = new(AlterTableClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_alterTableClause
	return p
}

func InitEmptyAlterTableClauseContext(p *AlterTableClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_alterTableClause
}

func (*AlterTableClauseContext) IsAlterTableClauseContext() {}

func NewAlterTableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableClauseContext {
	var p = new(AlterTableClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_alterTableClause

	return p
}

func (s *AlterTableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableClauseContext) CopyAll(ctx *AlterTableClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AlterTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AddPartitionClauseContext struct {
	AlterTableClauseContext
	hashKeys   IIdentifierListContext
	autoBucket antlr.Token
	properties IPropertyClauseContext
}

func NewAddPartitionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddPartitionClauseContext {
	var p = new(AddPartitionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AddPartitionClauseContext) GetAutoBucket() antlr.Token { return s.autoBucket }

func (s *AddPartitionClauseContext) SetAutoBucket(v antlr.Token) { s.autoBucket = v }

func (s *AddPartitionClauseContext) GetHashKeys() IIdentifierListContext { return s.hashKeys }

func (s *AddPartitionClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AddPartitionClauseContext) SetHashKeys(v IIdentifierListContext) { s.hashKeys = v }

func (s *AddPartitionClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AddPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddPartitionClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddPartitionClauseContext) PartitionDef() IPartitionDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefContext)
}

func (s *AddPartitionClauseContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *AddPartitionClauseContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTRIBUTED, 0)
}

func (s *AddPartitionClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *AddPartitionClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AddPartitionClauseContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisParserHASH, 0)
}

func (s *AddPartitionClauseContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(DorisParserRANDOM, 0)
}

func (s *AddPartitionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *AddPartitionClauseContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisParserBUCKETS, 0)
}

func (s *AddPartitionClauseContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *AddPartitionClauseContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO, 0)
}

func (s *AddPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddPartitionClause(s)
	}
}

func (s *AddPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddPartitionClause(s)
	}
}

type ModifyDistributionClauseContext struct {
	AlterTableClauseContext
	hashKeys   IIdentifierListContext
	autoBucket antlr.Token
}

func NewModifyDistributionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyDistributionClauseContext {
	var p = new(ModifyDistributionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ModifyDistributionClauseContext) GetAutoBucket() antlr.Token { return s.autoBucket }

func (s *ModifyDistributionClauseContext) SetAutoBucket(v antlr.Token) { s.autoBucket = v }

func (s *ModifyDistributionClauseContext) GetHashKeys() IIdentifierListContext { return s.hashKeys }

func (s *ModifyDistributionClauseContext) SetHashKeys(v IIdentifierListContext) { s.hashKeys = v }

func (s *ModifyDistributionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyDistributionClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *ModifyDistributionClauseContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTRIBUTION, 0)
}

func (s *ModifyDistributionClauseContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTRIBUTED, 0)
}

func (s *ModifyDistributionClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *ModifyDistributionClauseContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisParserHASH, 0)
}

func (s *ModifyDistributionClauseContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(DorisParserRANDOM, 0)
}

func (s *ModifyDistributionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ModifyDistributionClauseContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisParserBUCKETS, 0)
}

func (s *ModifyDistributionClauseContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ModifyDistributionClauseContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO, 0)
}

func (s *ModifyDistributionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterModifyDistributionClause(s)
	}
}

func (s *ModifyDistributionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitModifyDistributionClause(s)
	}
}

type AddColumnClauseContext struct {
	AlterTableClauseContext
	properties IPropertyClauseContext
}

func NewAddColumnClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddColumnClauseContext {
	var p = new(AddColumnClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AddColumnClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AddColumnClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AddColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddColumnClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *AddColumnClauseContext) ColumnDef() IColumnDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefContext)
}

func (s *AddColumnClauseContext) ColumnPosition() IColumnPositionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnPositionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnPositionContext)
}

func (s *AddColumnClauseContext) ToRollup() IToRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IToRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IToRollupContext)
}

func (s *AddColumnClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AddColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddColumnClause(s)
	}
}

func (s *AddColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddColumnClause(s)
	}
}

type ModifyColumnClauseContext struct {
	AlterTableClauseContext
	properties IPropertyClauseContext
}

func NewModifyColumnClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyColumnClauseContext {
	var p = new(ModifyColumnClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ModifyColumnClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *ModifyColumnClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *ModifyColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyColumnClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *ModifyColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *ModifyColumnClauseContext) ColumnDef() IColumnDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefContext)
}

func (s *ModifyColumnClauseContext) ColumnPosition() IColumnPositionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnPositionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnPositionContext)
}

func (s *ModifyColumnClauseContext) FromRollup() IFromRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromRollupContext)
}

func (s *ModifyColumnClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ModifyColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterModifyColumnClause(s)
	}
}

func (s *ModifyColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitModifyColumnClause(s)
	}
}

type RenameRollupClauseContext struct {
	AlterTableClauseContext
	name    IIdentifierContext
	newName IIdentifierContext
}

func NewRenameRollupClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameRollupClauseContext {
	var p = new(RenameRollupClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *RenameRollupClauseContext) GetName() IIdentifierContext { return s.name }

func (s *RenameRollupClauseContext) GetNewName() IIdentifierContext { return s.newName }

func (s *RenameRollupClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *RenameRollupClauseContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *RenameRollupClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameRollupClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserRENAME, 0)
}

func (s *RenameRollupClauseContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *RenameRollupClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RenameRollupClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenameRollupClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRenameRollupClause(s)
	}
}

func (s *RenameRollupClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRenameRollupClause(s)
	}
}

type AddColumnsClauseContext struct {
	AlterTableClauseContext
	properties IPropertyClauseContext
}

func NewAddColumnsClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddColumnsClauseContext {
	var p = new(AddColumnsClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AddColumnsClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AddColumnsClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AddColumnsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddColumnsClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddColumnsClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *AddColumnsClauseContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AddColumnsClauseContext) ColumnDefs() IColumnDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefsContext)
}

func (s *AddColumnsClauseContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AddColumnsClauseContext) ToRollup() IToRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IToRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IToRollupContext)
}

func (s *AddColumnsClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AddColumnsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddColumnsClause(s)
	}
}

func (s *AddColumnsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddColumnsClause(s)
	}
}

type ReplaceTableClauseContext struct {
	AlterTableClauseContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewReplaceTableClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReplaceTableClauseContext {
	var p = new(ReplaceTableClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ReplaceTableClauseContext) GetName() IIdentifierContext { return s.name }

func (s *ReplaceTableClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *ReplaceTableClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ReplaceTableClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *ReplaceTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplaceTableClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *ReplaceTableClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *ReplaceTableClauseContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *ReplaceTableClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReplaceTableClauseContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserFORCE, 0)
}

func (s *ReplaceTableClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ReplaceTableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterReplaceTableClause(s)
	}
}

func (s *ReplaceTableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitReplaceTableClause(s)
	}
}

type RenamePartitionClauseContext struct {
	AlterTableClauseContext
	name    IIdentifierContext
	newName IIdentifierContext
}

func NewRenamePartitionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenamePartitionClauseContext {
	var p = new(RenamePartitionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *RenamePartitionClauseContext) GetName() IIdentifierContext { return s.name }

func (s *RenamePartitionClauseContext) GetNewName() IIdentifierContext { return s.newName }

func (s *RenamePartitionClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *RenamePartitionClauseContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *RenamePartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenamePartitionClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserRENAME, 0)
}

func (s *RenamePartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *RenamePartitionClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RenamePartitionClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenamePartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRenamePartitionClause(s)
	}
}

func (s *RenamePartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRenamePartitionClause(s)
	}
}

type DropIndexClauseContext struct {
	AlterTableClauseContext
	name IIdentifierContext
}

func NewDropIndexClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropIndexClauseContext {
	var p = new(DropIndexClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *DropIndexClauseContext) GetName() IIdentifierContext { return s.name }

func (s *DropIndexClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropIndexClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropIndexClauseContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *DropIndexClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropIndexClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropIndexClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropIndexClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropIndexClause(s)
	}
}

func (s *DropIndexClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropIndexClause(s)
	}
}

type DropColumnClauseContext struct {
	AlterTableClauseContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewDropColumnClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropColumnClauseContext {
	var p = new(DropColumnClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *DropColumnClauseContext) GetName() IIdentifierContext { return s.name }

func (s *DropColumnClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *DropColumnClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropColumnClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *DropColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropColumnClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *DropColumnClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropColumnClauseContext) FromRollup() IFromRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromRollupContext)
}

func (s *DropColumnClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *DropColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropColumnClause(s)
	}
}

func (s *DropColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropColumnClause(s)
	}
}

type DropPartitionClauseContext struct {
	AlterTableClauseContext
	partitionName IIdentifierContext
	indexName     IIdentifierContext
}

func NewDropPartitionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropPartitionClauseContext {
	var p = new(DropPartitionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *DropPartitionClauseContext) GetPartitionName() IIdentifierContext { return s.partitionName }

func (s *DropPartitionClauseContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *DropPartitionClauseContext) SetPartitionName(v IIdentifierContext) { s.partitionName = v }

func (s *DropPartitionClauseContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *DropPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropPartitionClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropPartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *DropPartitionClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DropPartitionClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropPartitionClauseContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *DropPartitionClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropPartitionClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropPartitionClauseContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserFORCE, 0)
}

func (s *DropPartitionClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *DropPartitionClauseContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *DropPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropPartitionClause(s)
	}
}

func (s *DropPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropPartitionClause(s)
	}
}

type ReplacePartitionClauseContext struct {
	AlterTableClauseContext
	partitions     IPartitionSpecContext
	tempPartitions IPartitionSpecContext
	properties     IPropertyClauseContext
}

func NewReplacePartitionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReplacePartitionClauseContext {
	var p = new(ReplacePartitionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ReplacePartitionClauseContext) GetPartitions() IPartitionSpecContext { return s.partitions }

func (s *ReplacePartitionClauseContext) GetTempPartitions() IPartitionSpecContext {
	return s.tempPartitions
}

func (s *ReplacePartitionClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *ReplacePartitionClauseContext) SetPartitions(v IPartitionSpecContext) { s.partitions = v }

func (s *ReplacePartitionClauseContext) SetTempPartitions(v IPartitionSpecContext) {
	s.tempPartitions = v
}

func (s *ReplacePartitionClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *ReplacePartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplacePartitionClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *ReplacePartitionClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *ReplacePartitionClauseContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserFORCE, 0)
}

func (s *ReplacePartitionClauseContext) AllPartitionSpec() []IPartitionSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			len++
		}
	}

	tst := make([]IPartitionSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionSpecContext); ok {
			tst[i] = t.(IPartitionSpecContext)
			i++
		}
	}

	return tst
}

func (s *ReplacePartitionClauseContext) PartitionSpec(i int) IPartitionSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *ReplacePartitionClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ReplacePartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterReplacePartitionClause(s)
	}
}

func (s *ReplacePartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitReplacePartitionClause(s)
	}
}

type RenameClauseContext struct {
	AlterTableClauseContext
	newName IIdentifierContext
}

func NewRenameClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameClauseContext {
	var p = new(RenameClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *RenameClauseContext) GetNewName() IIdentifierContext { return s.newName }

func (s *RenameClauseContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *RenameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserRENAME, 0)
}

func (s *RenameClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRenameClause(s)
	}
}

func (s *RenameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRenameClause(s)
	}
}

type ModifyTableCommentClauseContext struct {
	AlterTableClauseContext
	comment antlr.Token
}

func NewModifyTableCommentClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyTableCommentClauseContext {
	var p = new(ModifyTableCommentClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ModifyTableCommentClauseContext) GetComment() antlr.Token { return s.comment }

func (s *ModifyTableCommentClauseContext) SetComment(v antlr.Token) { s.comment = v }

func (s *ModifyTableCommentClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyTableCommentClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *ModifyTableCommentClauseContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *ModifyTableCommentClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ModifyTableCommentClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterModifyTableCommentClause(s)
	}
}

func (s *ModifyTableCommentClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitModifyTableCommentClause(s)
	}
}

type ModifyPartitionClauseContext struct {
	AlterTableClauseContext
	partitionName       IIdentifierContext
	partitionNames      IIdentifierListContext
	partitionProperties IPropertyItemListContext
}

func NewModifyPartitionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyPartitionClauseContext {
	var p = new(ModifyPartitionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ModifyPartitionClauseContext) GetPartitionName() IIdentifierContext { return s.partitionName }

func (s *ModifyPartitionClauseContext) GetPartitionNames() IIdentifierListContext {
	return s.partitionNames
}

func (s *ModifyPartitionClauseContext) GetPartitionProperties() IPropertyItemListContext {
	return s.partitionProperties
}

func (s *ModifyPartitionClauseContext) SetPartitionName(v IIdentifierContext) { s.partitionName = v }

func (s *ModifyPartitionClauseContext) SetPartitionNames(v IIdentifierListContext) {
	s.partitionNames = v
}

func (s *ModifyPartitionClauseContext) SetPartitionProperties(v IPropertyItemListContext) {
	s.partitionProperties = v
}

func (s *ModifyPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyPartitionClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *ModifyPartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *ModifyPartitionClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *ModifyPartitionClauseContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserLEFT_PAREN)
}

func (s *ModifyPartitionClauseContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, i)
}

func (s *ModifyPartitionClauseContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserRIGHT_PAREN)
}

func (s *ModifyPartitionClauseContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, i)
}

func (s *ModifyPartitionClauseContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *ModifyPartitionClauseContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserASTERISK, 0)
}

func (s *ModifyPartitionClauseContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *ModifyPartitionClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifyPartitionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ModifyPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterModifyPartitionClause(s)
	}
}

func (s *ModifyPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitModifyPartitionClause(s)
	}
}

type ModifyEngineClauseContext struct {
	AlterTableClauseContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewModifyEngineClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyEngineClauseContext {
	var p = new(ModifyEngineClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ModifyEngineClauseContext) GetName() IIdentifierContext { return s.name }

func (s *ModifyEngineClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *ModifyEngineClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ModifyEngineClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *ModifyEngineClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyEngineClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *ModifyEngineClauseContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(DorisParserENGINE, 0)
}

func (s *ModifyEngineClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *ModifyEngineClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifyEngineClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ModifyEngineClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterModifyEngineClause(s)
	}
}

func (s *ModifyEngineClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitModifyEngineClause(s)
	}
}

type ReorderColumnsClauseContext struct {
	AlterTableClauseContext
	properties IPropertyClauseContext
}

func NewReorderColumnsClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReorderColumnsClauseContext {
	var p = new(ReorderColumnsClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ReorderColumnsClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *ReorderColumnsClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *ReorderColumnsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReorderColumnsClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisParserORDER, 0)
}

func (s *ReorderColumnsClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *ReorderColumnsClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ReorderColumnsClauseContext) FromRollup() IFromRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromRollupContext)
}

func (s *ReorderColumnsClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ReorderColumnsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterReorderColumnsClause(s)
	}
}

func (s *ReorderColumnsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitReorderColumnsClause(s)
	}
}

type AddIndexClauseContext struct {
	AlterTableClauseContext
}

func NewAddIndexClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddIndexClauseContext {
	var p = new(AddIndexClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AddIndexClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddIndexClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddIndexClauseContext) IndexDef() IIndexDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexDefContext)
}

func (s *AddIndexClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddIndexClause(s)
	}
}

func (s *AddIndexClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddIndexClause(s)
	}
}

type ModifyColumnCommentClauseContext struct {
	AlterTableClauseContext
	name    IIdentifierContext
	comment antlr.Token
}

func NewModifyColumnCommentClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyColumnCommentClauseContext {
	var p = new(ModifyColumnCommentClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ModifyColumnCommentClauseContext) GetComment() antlr.Token { return s.comment }

func (s *ModifyColumnCommentClauseContext) SetComment(v antlr.Token) { s.comment = v }

func (s *ModifyColumnCommentClauseContext) GetName() IIdentifierContext { return s.name }

func (s *ModifyColumnCommentClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ModifyColumnCommentClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyColumnCommentClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *ModifyColumnCommentClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *ModifyColumnCommentClauseContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *ModifyColumnCommentClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifyColumnCommentClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ModifyColumnCommentClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterModifyColumnCommentClause(s)
	}
}

func (s *ModifyColumnCommentClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitModifyColumnCommentClause(s)
	}
}

type AlterMultiPartitionClauseContext struct {
	AlterTableClauseContext
	from       IPartitionValueListContext
	to         IPartitionValueListContext
	unit       IIdentifierContext
	properties IPropertyClauseContext
}

func NewAlterMultiPartitionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterMultiPartitionClauseContext {
	var p = new(AlterMultiPartitionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterMultiPartitionClauseContext) GetFrom() IPartitionValueListContext { return s.from }

func (s *AlterMultiPartitionClauseContext) GetTo() IPartitionValueListContext { return s.to }

func (s *AlterMultiPartitionClauseContext) GetUnit() IIdentifierContext { return s.unit }

func (s *AlterMultiPartitionClauseContext) GetProperties() IPropertyClauseContext {
	return s.properties
}

func (s *AlterMultiPartitionClauseContext) SetFrom(v IPartitionValueListContext) { s.from = v }

func (s *AlterMultiPartitionClauseContext) SetTo(v IPartitionValueListContext) { s.to = v }

func (s *AlterMultiPartitionClauseContext) SetUnit(v IIdentifierContext) { s.unit = v }

func (s *AlterMultiPartitionClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterMultiPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterMultiPartitionClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AlterMultiPartitionClauseContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITIONS, 0)
}

func (s *AlterMultiPartitionClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *AlterMultiPartitionClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *AlterMultiPartitionClauseContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DorisParserINTERVAL, 0)
}

func (s *AlterMultiPartitionClauseContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *AlterMultiPartitionClauseContext) AllPartitionValueList() []IPartitionValueListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueListContext); ok {
			tst[i] = t.(IPartitionValueListContext)
			i++
		}
	}

	return tst
}

func (s *AlterMultiPartitionClauseContext) PartitionValueList(i int) IPartitionValueListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueListContext)
}

func (s *AlterMultiPartitionClauseContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *AlterMultiPartitionClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterMultiPartitionClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterMultiPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterMultiPartitionClause(s)
	}
}

func (s *AlterMultiPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterMultiPartitionClause(s)
	}
}

type RenameColumnClauseContext struct {
	AlterTableClauseContext
	name    IIdentifierContext
	newName IIdentifierContext
}

func NewRenameColumnClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameColumnClauseContext {
	var p = new(RenameColumnClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *RenameColumnClauseContext) GetName() IIdentifierContext { return s.name }

func (s *RenameColumnClauseContext) GetNewName() IIdentifierContext { return s.newName }

func (s *RenameColumnClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *RenameColumnClauseContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *RenameColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameColumnClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserRENAME, 0)
}

func (s *RenameColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *RenameColumnClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RenameColumnClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenameColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRenameColumnClause(s)
	}
}

func (s *RenameColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRenameColumnClause(s)
	}
}

type EnableFeatureClauseContext struct {
	AlterTableClauseContext
	name       antlr.Token
	properties IPropertyClauseContext
}

func NewEnableFeatureClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EnableFeatureClauseContext {
	var p = new(EnableFeatureClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *EnableFeatureClauseContext) GetName() antlr.Token { return s.name }

func (s *EnableFeatureClauseContext) SetName(v antlr.Token) { s.name = v }

func (s *EnableFeatureClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *EnableFeatureClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *EnableFeatureClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnableFeatureClauseContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserENABLE, 0)
}

func (s *EnableFeatureClauseContext) FEATURE() antlr.TerminalNode {
	return s.GetToken(DorisParserFEATURE, 0)
}

func (s *EnableFeatureClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *EnableFeatureClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *EnableFeatureClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *EnableFeatureClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterEnableFeatureClause(s)
	}
}

func (s *EnableFeatureClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitEnableFeatureClause(s)
	}
}

func (p *DorisParser) AlterTableClause() (localctx IAlterTableClauseContext) {
	localctx = NewAlterTableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, DorisParserRULE_alterTableClause)
	var _la int

	p.SetState(3387)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 461, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAddColumnClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3167)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3168)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3169)
			p.ColumnDef()
		}
		p.SetState(3171)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAFTER || _la == DorisParserFIRST {
			{
				p.SetState(3170)
				p.ColumnPosition()
			}

		}
		p.SetState(3174)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIN || _la == DorisParserTO {
			{
				p.SetState(3173)
				p.ToRollup()
			}

		}
		p.SetState(3177)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3176)

				var _x = p.PropertyClause()

				localctx.(*AddColumnClauseContext).properties = _x
			}

		}

	case 2:
		localctx = NewAddColumnsClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3179)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3180)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3181)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3182)
			p.ColumnDefs()
		}
		{
			p.SetState(3183)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3185)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIN || _la == DorisParserTO {
			{
				p.SetState(3184)
				p.ToRollup()
			}

		}
		p.SetState(3188)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3187)

				var _x = p.PropertyClause()

				localctx.(*AddColumnsClauseContext).properties = _x
			}

		}

	case 3:
		localctx = NewDropColumnClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3190)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3191)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3192)

			var _x = p.Identifier()

			localctx.(*DropColumnClauseContext).name = _x
		}
		p.SetState(3194)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(3193)
				p.FromRollup()
			}

		}
		p.SetState(3197)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3196)

				var _x = p.PropertyClause()

				localctx.(*DropColumnClauseContext).properties = _x
			}

		}

	case 4:
		localctx = NewModifyColumnClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3199)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3200)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3201)
			p.ColumnDef()
		}
		p.SetState(3203)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAFTER || _la == DorisParserFIRST {
			{
				p.SetState(3202)
				p.ColumnPosition()
			}

		}
		p.SetState(3206)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(3205)
				p.FromRollup()
			}

		}
		p.SetState(3209)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3208)

				var _x = p.PropertyClause()

				localctx.(*ModifyColumnClauseContext).properties = _x
			}

		}

	case 5:
		localctx = NewReorderColumnsClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3211)
			p.Match(DorisParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3212)
			p.Match(DorisParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3213)
			p.IdentifierList()
		}
		p.SetState(3215)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(3214)
				p.FromRollup()
			}

		}
		p.SetState(3218)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3217)

				var _x = p.PropertyClause()

				localctx.(*ReorderColumnsClauseContext).properties = _x
			}

		}

	case 6:
		localctx = NewAddPartitionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3220)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3222)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(3221)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3224)
			p.PartitionDef()
		}
		p.SetState(3239)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserDISTRIBUTED {
			{
				p.SetState(3225)
				p.Match(DorisParserDISTRIBUTED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3226)
				p.Match(DorisParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3230)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserHASH:
				{
					p.SetState(3227)
					p.Match(DorisParserHASH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3228)

					var _x = p.IdentifierList()

					localctx.(*AddPartitionClauseContext).hashKeys = _x
				}

			case DorisParserRANDOM:
				{
					p.SetState(3229)
					p.Match(DorisParserRANDOM)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			p.SetState(3237)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserBUCKETS {
				{
					p.SetState(3232)
					p.Match(DorisParserBUCKETS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(3235)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DorisParserINTEGER_VALUE:
					{
						p.SetState(3233)
						p.Match(DorisParserINTEGER_VALUE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case DorisParserAUTO:
					{
						p.SetState(3234)

						var _m = p.Match(DorisParserAUTO)

						localctx.(*AddPartitionClauseContext).autoBucket = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			}

		}
		p.SetState(3242)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3241)

				var _x = p.PropertyClause()

				localctx.(*AddPartitionClauseContext).properties = _x
			}

		}

	case 7:
		localctx = NewDropPartitionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3244)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3246)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(3245)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3248)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3251)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(3249)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3250)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3253)

			var _x = p.Identifier()

			localctx.(*DropPartitionClauseContext).partitionName = _x
		}
		p.SetState(3255)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFORCE {
			{
				p.SetState(3254)
				p.Match(DorisParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3260)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(3257)
				p.Match(DorisParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3258)
				p.Match(DorisParserINDEX)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3259)

				var _x = p.Identifier()

				localctx.(*DropPartitionClauseContext).indexName = _x
			}

		}

	case 8:
		localctx = NewModifyPartitionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3262)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3264)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(3263)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3266)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3272)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 444, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3267)

				var _x = p.Identifier()

				localctx.(*ModifyPartitionClauseContext).partitionName = _x
			}

		case 2:
			{
				p.SetState(3268)

				var _x = p.IdentifierList()

				localctx.(*ModifyPartitionClauseContext).partitionNames = _x
			}

		case 3:
			{
				p.SetState(3269)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3270)
				p.Match(DorisParserASTERISK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3271)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(3274)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3275)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3276)

			var _x = p.PropertyItemList()

			localctx.(*ModifyPartitionClauseContext).partitionProperties = _x
		}
		{
			p.SetState(3277)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewReplacePartitionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3279)
			p.Match(DorisParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3281)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(3280)

				var _x = p.PartitionSpec()

				localctx.(*ReplacePartitionClauseContext).partitions = _x
			}

		}
		{
			p.SetState(3283)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3285)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(3284)

				var _x = p.PartitionSpec()

				localctx.(*ReplacePartitionClauseContext).tempPartitions = _x
			}

		}
		p.SetState(3288)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFORCE {
			{
				p.SetState(3287)
				p.Match(DorisParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3291)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3290)

				var _x = p.PropertyClause()

				localctx.(*ReplacePartitionClauseContext).properties = _x
			}

		}

	case 10:
		localctx = NewReplaceTableClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3293)
			p.Match(DorisParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3294)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3295)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3296)

			var _x = p.Identifier()

			localctx.(*ReplaceTableClauseContext).name = _x
		}
		p.SetState(3298)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3297)

				var _x = p.PropertyClause()

				localctx.(*ReplaceTableClauseContext).properties = _x
			}

		}
		p.SetState(3301)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFORCE {
			{
				p.SetState(3300)
				p.Match(DorisParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 11:
		localctx = NewRenameClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3303)
			p.Match(DorisParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3304)

			var _x = p.Identifier()

			localctx.(*RenameClauseContext).newName = _x
		}

	case 12:
		localctx = NewRenameRollupClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3305)
			p.Match(DorisParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3306)
			p.Match(DorisParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3307)

			var _x = p.Identifier()

			localctx.(*RenameRollupClauseContext).name = _x
		}
		{
			p.SetState(3308)

			var _x = p.Identifier()

			localctx.(*RenameRollupClauseContext).newName = _x
		}

	case 13:
		localctx = NewRenamePartitionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3310)
			p.Match(DorisParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3311)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3312)

			var _x = p.Identifier()

			localctx.(*RenamePartitionClauseContext).name = _x
		}
		{
			p.SetState(3313)

			var _x = p.Identifier()

			localctx.(*RenamePartitionClauseContext).newName = _x
		}

	case 14:
		localctx = NewRenameColumnClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3315)
			p.Match(DorisParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3316)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3317)

			var _x = p.Identifier()

			localctx.(*RenameColumnClauseContext).name = _x
		}
		{
			p.SetState(3318)

			var _x = p.Identifier()

			localctx.(*RenameColumnClauseContext).newName = _x
		}

	case 15:
		localctx = NewAddIndexClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3320)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3321)
			p.IndexDef()
		}

	case 16:
		localctx = NewDropIndexClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3322)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3323)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3326)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(3324)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3325)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3328)

			var _x = p.Identifier()

			localctx.(*DropIndexClauseContext).name = _x
		}

	case 17:
		localctx = NewEnableFeatureClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(3329)
			p.Match(DorisParserENABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3330)
			p.Match(DorisParserFEATURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3331)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*EnableFeatureClauseContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3334)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(3332)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3333)

				var _x = p.PropertyClause()

				localctx.(*EnableFeatureClauseContext).properties = _x
			}

		}

	case 18:
		localctx = NewModifyDistributionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(3336)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3337)
			p.Match(DorisParserDISTRIBUTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3352)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserDISTRIBUTED {
			{
				p.SetState(3338)
				p.Match(DorisParserDISTRIBUTED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3339)
				p.Match(DorisParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3343)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserHASH:
				{
					p.SetState(3340)
					p.Match(DorisParserHASH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3341)

					var _x = p.IdentifierList()

					localctx.(*ModifyDistributionClauseContext).hashKeys = _x
				}

			case DorisParserRANDOM:
				{
					p.SetState(3342)
					p.Match(DorisParserRANDOM)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			p.SetState(3350)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserBUCKETS {
				{
					p.SetState(3345)
					p.Match(DorisParserBUCKETS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(3348)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DorisParserINTEGER_VALUE:
					{
						p.SetState(3346)
						p.Match(DorisParserINTEGER_VALUE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case DorisParserAUTO:
					{
						p.SetState(3347)

						var _m = p.Match(DorisParserAUTO)

						localctx.(*ModifyDistributionClauseContext).autoBucket = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			}

		}

	case 19:
		localctx = NewModifyTableCommentClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(3354)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3355)
			p.Match(DorisParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3356)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ModifyTableCommentClauseContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		localctx = NewModifyColumnCommentClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(3357)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3358)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3359)

			var _x = p.Identifier()

			localctx.(*ModifyColumnCommentClauseContext).name = _x
		}
		{
			p.SetState(3360)
			p.Match(DorisParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3361)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ModifyColumnCommentClauseContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		localctx = NewModifyEngineClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(3363)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3364)
			p.Match(DorisParserENGINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3365)
			p.Match(DorisParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3366)

			var _x = p.Identifier()

			localctx.(*ModifyEngineClauseContext).name = _x
		}
		p.SetState(3368)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3367)

				var _x = p.PropertyClause()

				localctx.(*ModifyEngineClauseContext).properties = _x
			}

		}

	case 22:
		localctx = NewAlterMultiPartitionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(3370)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3372)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(3371)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3374)
			p.Match(DorisParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3375)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3376)

			var _x = p.PartitionValueList()

			localctx.(*AlterMultiPartitionClauseContext).from = _x
		}
		{
			p.SetState(3377)
			p.Match(DorisParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3378)

			var _x = p.PartitionValueList()

			localctx.(*AlterMultiPartitionClauseContext).to = _x
		}
		{
			p.SetState(3379)
			p.Match(DorisParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3380)
			p.Match(DorisParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3382)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 459, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3381)

				var _x = p.Identifier()

				localctx.(*AlterMultiPartitionClauseContext).unit = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3385)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3384)

				var _x = p.PropertyClause()

				localctx.(*AlterMultiPartitionClauseContext).properties = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnPositionContext is an interface to support dynamic dispatch.
type IColumnPositionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPosition returns the position rule contexts.
	GetPosition() IIdentifierContext

	// SetPosition sets the position rule contexts.
	SetPosition(IIdentifierContext)

	// Getter signatures
	FIRST() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsColumnPositionContext differentiates from other interfaces.
	IsColumnPositionContext()
}

type ColumnPositionContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	position IIdentifierContext
}

func NewEmptyColumnPositionContext() *ColumnPositionContext {
	var p = new(ColumnPositionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_columnPosition
	return p
}

func InitEmptyColumnPositionContext(p *ColumnPositionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_columnPosition
}

func (*ColumnPositionContext) IsColumnPositionContext() {}

func NewColumnPositionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnPositionContext {
	var p = new(ColumnPositionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_columnPosition

	return p
}

func (s *ColumnPositionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnPositionContext) GetPosition() IIdentifierContext { return s.position }

func (s *ColumnPositionContext) SetPosition(v IIdentifierContext) { s.position = v }

func (s *ColumnPositionContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DorisParserFIRST, 0)
}

func (s *ColumnPositionContext) AFTER() antlr.TerminalNode {
	return s.GetToken(DorisParserAFTER, 0)
}

func (s *ColumnPositionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnPositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnPositionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnPositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterColumnPosition(s)
	}
}

func (s *ColumnPositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitColumnPosition(s)
	}
}

func (p *DorisParser) ColumnPosition() (localctx IColumnPositionContext) {
	localctx = NewColumnPositionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, DorisParserRULE_columnPosition)
	p.SetState(3392)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserFIRST:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3389)
			p.Match(DorisParserFIRST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserAFTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3390)
			p.Match(DorisParserAFTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3391)

			var _x = p.Identifier()

			localctx.(*ColumnPositionContext).position = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IToRollupContext is an interface to support dynamic dispatch.
type IToRollupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollup returns the rollup rule contexts.
	GetRollup() IIdentifierContext

	// SetRollup sets the rollup rule contexts.
	SetRollup(IIdentifierContext)

	// Getter signatures
	TO() antlr.TerminalNode
	IN() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsToRollupContext differentiates from other interfaces.
	IsToRollupContext()
}

type ToRollupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	rollup IIdentifierContext
}

func NewEmptyToRollupContext() *ToRollupContext {
	var p = new(ToRollupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_toRollup
	return p
}

func InitEmptyToRollupContext(p *ToRollupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_toRollup
}

func (*ToRollupContext) IsToRollupContext() {}

func NewToRollupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ToRollupContext {
	var p = new(ToRollupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_toRollup

	return p
}

func (s *ToRollupContext) GetParser() antlr.Parser { return s.parser }

func (s *ToRollupContext) GetRollup() IIdentifierContext { return s.rollup }

func (s *ToRollupContext) SetRollup(v IIdentifierContext) { s.rollup = v }

func (s *ToRollupContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *ToRollupContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ToRollupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ToRollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ToRollupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ToRollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterToRollup(s)
	}
}

func (s *ToRollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitToRollup(s)
	}
}

func (p *DorisParser) ToRollup() (localctx IToRollupContext) {
	localctx = NewToRollupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, DorisParserRULE_toRollup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3394)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserIN || _la == DorisParserTO) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3395)

		var _x = p.Identifier()

		localctx.(*ToRollupContext).rollup = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromRollupContext is an interface to support dynamic dispatch.
type IFromRollupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollup returns the rollup rule contexts.
	GetRollup() IIdentifierContext

	// SetRollup sets the rollup rule contexts.
	SetRollup(IIdentifierContext)

	// Getter signatures
	FROM() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsFromRollupContext differentiates from other interfaces.
	IsFromRollupContext()
}

type FromRollupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	rollup IIdentifierContext
}

func NewEmptyFromRollupContext() *FromRollupContext {
	var p = new(FromRollupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_fromRollup
	return p
}

func InitEmptyFromRollupContext(p *FromRollupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_fromRollup
}

func (*FromRollupContext) IsFromRollupContext() {}

func NewFromRollupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromRollupContext {
	var p = new(FromRollupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_fromRollup

	return p
}

func (s *FromRollupContext) GetParser() antlr.Parser { return s.parser }

func (s *FromRollupContext) GetRollup() IIdentifierContext { return s.rollup }

func (s *FromRollupContext) SetRollup(v IIdentifierContext) { s.rollup = v }

func (s *FromRollupContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *FromRollupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FromRollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromRollupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromRollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFromRollup(s)
	}
}

func (s *FromRollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFromRollup(s)
	}
}

func (p *DorisParser) FromRollup() (localctx IFromRollupContext) {
	localctx = NewFromRollupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, DorisParserRULE_fromRollup)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3397)
		p.Match(DorisParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3398)

		var _x = p.Identifier()

		localctx.(*FromRollupContext).rollup = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedDropStatementContext is an interface to support dynamic dispatch.
type IUnsupportedDropStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedDropStatementContext differentiates from other interfaces.
	IsUnsupportedDropStatementContext()
}

type UnsupportedDropStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedDropStatementContext() *UnsupportedDropStatementContext {
	var p = new(UnsupportedDropStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedDropStatement
	return p
}

func InitEmptyUnsupportedDropStatementContext(p *UnsupportedDropStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedDropStatement
}

func (*UnsupportedDropStatementContext) IsUnsupportedDropStatementContext() {}

func NewUnsupportedDropStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedDropStatementContext {
	var p = new(UnsupportedDropStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedDropStatement

	return p
}

func (s *UnsupportedDropStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedDropStatementContext) CopyAll(ctx *UnsupportedDropStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedDropStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedDropStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DropStageContext struct {
	UnsupportedDropStatementContext
	name IIdentifierContext
}

func NewDropStageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropStageContext {
	var p = new(DropStageContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropStageContext) GetName() IIdentifierContext { return s.name }

func (s *DropStageContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropStageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStageContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropStageContext) STAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTAGE, 0)
}

func (s *DropStageContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropStageContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropStageContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropStageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropStage(s)
	}
}

func (s *DropStageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropStage(s)
	}
}

type DropRowPolicyContext struct {
	UnsupportedDropStatementContext
	policyName IIdentifierContext
	tableName  IMultipartIdentifierContext
	roleName   IIdentifierContext
}

func NewDropRowPolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropRowPolicyContext {
	var p = new(DropRowPolicyContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropRowPolicyContext) GetPolicyName() IIdentifierContext { return s.policyName }

func (s *DropRowPolicyContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DropRowPolicyContext) GetRoleName() IIdentifierContext { return s.roleName }

func (s *DropRowPolicyContext) SetPolicyName(v IIdentifierContext) { s.policyName = v }

func (s *DropRowPolicyContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DropRowPolicyContext) SetRoleName(v IIdentifierContext) { s.roleName = v }

func (s *DropRowPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRowPolicyContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropRowPolicyContext) ROW() antlr.TerminalNode {
	return s.GetToken(DorisParserROW, 0)
}

func (s *DropRowPolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *DropRowPolicyContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *DropRowPolicyContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DropRowPolicyContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropRowPolicyContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropRowPolicyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropRowPolicyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropRowPolicyContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *DropRowPolicyContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *DropRowPolicyContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *DropRowPolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropRowPolicy(s)
	}
}

func (s *DropRowPolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropRowPolicy(s)
	}
}

type DropResourceContext struct {
	UnsupportedDropStatementContext
	name IIdentifierOrTextContext
}

func NewDropResourceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropResourceContext {
	var p = new(DropResourceContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropResourceContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *DropResourceContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *DropResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropResourceContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropResourceContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCE, 0)
}

func (s *DropResourceContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DropResourceContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropResourceContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropResourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropResource(s)
	}
}

func (s *DropResourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropResource(s)
	}
}

type DropFunctionContext struct {
	UnsupportedDropStatementContext
}

func NewDropFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropFunctionContext {
	var p = new(DropFunctionContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFunctionContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserFUNCTION, 0)
}

func (s *DropFunctionContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *DropFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *DropFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *DropFunctionContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropFunctionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropFunctionContext) FunctionArguments() IFunctionArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgumentsContext)
}

func (s *DropFunctionContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *DropFunctionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION, 0)
}

func (s *DropFunctionContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *DropFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropFunction(s)
	}
}

func (s *DropFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropFunction(s)
	}
}

type DropViewContext struct {
	UnsupportedDropStatementContext
	name IMultipartIdentifierContext
}

func NewDropViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropViewContext {
	var p = new(DropViewContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropViewContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *DropViewContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *DropViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropViewContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *DropViewContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropViewContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropViewContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropView(s)
	}
}

func (s *DropViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropView(s)
	}
}

type DropTableContext struct {
	UnsupportedDropStatementContext
	name IMultipartIdentifierContext
}

func NewDropTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropTableContext {
	var p = new(DropTableContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropTableContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *DropTableContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *DropTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *DropTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropTableContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropTableContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserFORCE, 0)
}

func (s *DropTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropTable(s)
	}
}

func (s *DropTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropTable(s)
	}
}

type DropIndexContext struct {
	UnsupportedDropStatementContext
	name      IIdentifierContext
	tableName IMultipartIdentifierContext
}

func NewDropIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropIndexContext {
	var p = new(DropIndexContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropIndexContext) GetName() IIdentifierContext { return s.name }

func (s *DropIndexContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DropIndexContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropIndexContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DropIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *DropIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *DropIndexContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropIndexContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropIndexContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropIndexContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropIndex(s)
	}
}

func (s *DropIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropIndex(s)
	}
}

func (p *DorisParser) UnsupportedDropStatement() (localctx IUnsupportedDropStatementContext) {
	localctx = NewUnsupportedDropStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, DorisParserRULE_unsupportedDropStatement)
	var _la int

	p.SetState(3475)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 475, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDropFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3400)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3402)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION {
			{
				p.SetState(3401)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(3404)
			p.Match(DorisParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3407)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 464, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3405)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3406)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3409)
			p.FunctionIdentifier()
		}
		{
			p.SetState(3410)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3412)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4576167530201152) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&16870906416594945) != 0) || _la == DorisParserDOUBLE || _la == DorisParserFLOAT || ((int64((_la-207)) & ^0x3f) == 0 && ((int64(1)<<(_la-207))&-9223369734650855423) != 0) || _la == DorisParserQUANTILE_STATE || _la == DorisParserSMALLINT || ((int64((_la-429)) & ^0x3f) == 0 && ((int64(1)<<(_la-429))&5066549583478787) != 0) {
			{
				p.SetState(3411)
				p.FunctionArguments()
			}

		}
		{
			p.SetState(3414)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewDropTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3416)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3417)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3420)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(3418)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3419)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3422)

			var _x = p.MultipartIdentifier()

			localctx.(*DropTableContext).name = _x
		}
		p.SetState(3424)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFORCE {
			{
				p.SetState(3423)
				p.Match(DorisParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		localctx = NewDropViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3426)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3427)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3430)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(3428)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3429)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3432)

			var _x = p.MultipartIdentifier()

			localctx.(*DropViewContext).name = _x
		}

	case 4:
		localctx = NewDropIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3433)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3434)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3437)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(3435)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3436)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3439)

			var _x = p.Identifier()

			localctx.(*DropIndexContext).name = _x
		}
		{
			p.SetState(3440)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3441)

			var _x = p.MultipartIdentifier()

			localctx.(*DropIndexContext).tableName = _x
		}

	case 5:
		localctx = NewDropResourceContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3443)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3444)
			p.Match(DorisParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3447)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(3445)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3446)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3449)

			var _x = p.IdentifierOrText()

			localctx.(*DropResourceContext).name = _x
		}

	case 6:
		localctx = NewDropRowPolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3450)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3451)
			p.Match(DorisParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3452)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3455)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(3453)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3454)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3457)

			var _x = p.Identifier()

			localctx.(*DropRowPolicyContext).policyName = _x
		}
		{
			p.SetState(3458)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3459)

			var _x = p.MultipartIdentifier()

			localctx.(*DropRowPolicyContext).tableName = _x
		}
		p.SetState(3466)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFOR {
			{
				p.SetState(3460)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3464)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
				{
					p.SetState(3461)
					p.UserIdentify()
				}

			case DorisParserROLE:
				{
					p.SetState(3462)
					p.Match(DorisParserROLE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3463)

					var _x = p.Identifier()

					localctx.(*DropRowPolicyContext).roleName = _x
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}

	case 7:
		localctx = NewDropStageContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3468)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3469)
			p.Match(DorisParserSTAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3472)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(3470)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3471)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3474)

			var _x = p.Identifier()

			localctx.(*DropStageContext).name = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedStatsStatementContext is an interface to support dynamic dispatch.
type IUnsupportedStatsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedStatsStatementContext differentiates from other interfaces.
	IsUnsupportedStatsStatementContext()
}

type UnsupportedStatsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedStatsStatementContext() *UnsupportedStatsStatementContext {
	var p = new(UnsupportedStatsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedStatsStatement
	return p
}

func InitEmptyUnsupportedStatsStatementContext(p *UnsupportedStatsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedStatsStatement
}

func (*UnsupportedStatsStatementContext) IsUnsupportedStatsStatementContext() {}

func NewUnsupportedStatsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedStatsStatementContext {
	var p = new(UnsupportedStatsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedStatsStatement

	return p
}

func (s *UnsupportedStatsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedStatsStatementContext) CopyAll(ctx *UnsupportedStatsStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedStatsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedStatsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowTableStatsContext struct {
	UnsupportedStatsStatementContext
	tableName  IMultipartIdentifierContext
	columnList IIdentifierListContext
	tableId    antlr.Token
}

func NewShowTableStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTableStatsContext {
	var p = new(ShowTableStatsContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *ShowTableStatsContext) GetTableId() antlr.Token { return s.tableId }

func (s *ShowTableStatsContext) SetTableId(v antlr.Token) { s.tableId = v }

func (s *ShowTableStatsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowTableStatsContext) GetColumnList() IIdentifierListContext { return s.columnList }

func (s *ShowTableStatsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowTableStatsContext) SetColumnList(v IIdentifierListContext) { s.columnList = v }

func (s *ShowTableStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTableStatsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTableStatsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *ShowTableStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *ShowTableStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowTableStatsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *ShowTableStatsContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ShowTableStatsContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ShowTableStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTableStats(s)
	}
}

func (s *ShowTableStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTableStats(s)
	}
}

type DropAanalyzeJobContext struct {
	UnsupportedStatsStatementContext
}

func NewDropAanalyzeJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropAanalyzeJobContext {
	var p = new(DropAanalyzeJobContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *DropAanalyzeJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropAanalyzeJobContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropAanalyzeJobContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisParserANALYZE, 0)
}

func (s *DropAanalyzeJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *DropAanalyzeJobContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *DropAanalyzeJobContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropAanalyzeJob(s)
	}
}

func (s *DropAanalyzeJobContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropAanalyzeJob(s)
	}
}

type ShowColumnStatsContext struct {
	UnsupportedStatsStatementContext
	tableName  IMultipartIdentifierContext
	columnList IIdentifierListContext
}

func NewShowColumnStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnStatsContext {
	var p = new(ShowColumnStatsContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *ShowColumnStatsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowColumnStatsContext) GetColumnList() IIdentifierListContext { return s.columnList }

func (s *ShowColumnStatsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowColumnStatsContext) SetColumnList(v IIdentifierListContext) { s.columnList = v }

func (s *ShowColumnStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnStatsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowColumnStatsContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *ShowColumnStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *ShowColumnStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowColumnStatsContext) CACHED() antlr.TerminalNode {
	return s.GetToken(DorisParserCACHED, 0)
}

func (s *ShowColumnStatsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *ShowColumnStatsContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ShowColumnStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowColumnStats(s)
	}
}

func (s *ShowColumnStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowColumnStats(s)
	}
}

type AnalyzeDatabaseContext struct {
	UnsupportedStatsStatementContext
	name IMultipartIdentifierContext
}

func NewAnalyzeDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AnalyzeDatabaseContext {
	var p = new(AnalyzeDatabaseContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *AnalyzeDatabaseContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AnalyzeDatabaseContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AnalyzeDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeDatabaseContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisParserANALYZE, 0)
}

func (s *AnalyzeDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *AnalyzeDatabaseContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AnalyzeDatabaseContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(DorisParserWITH)
}

func (s *AnalyzeDatabaseContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, i)
}

func (s *AnalyzeDatabaseContext) AllAnalyzeProperties() []IAnalyzePropertiesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnalyzePropertiesContext); ok {
			len++
		}
	}

	tst := make([]IAnalyzePropertiesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnalyzePropertiesContext); ok {
			tst[i] = t.(IAnalyzePropertiesContext)
			i++
		}
	}

	return tst
}

func (s *AnalyzeDatabaseContext) AnalyzeProperties(i int) IAnalyzePropertiesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzePropertiesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzePropertiesContext)
}

func (s *AnalyzeDatabaseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AnalyzeDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAnalyzeDatabase(s)
	}
}

func (s *AnalyzeDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAnalyzeDatabase(s)
	}
}

type ShowAnalyzeTaskContext struct {
	UnsupportedStatsStatementContext
	jobId antlr.Token
}

func NewShowAnalyzeTaskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAnalyzeTaskContext {
	var p = new(ShowAnalyzeTaskContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *ShowAnalyzeTaskContext) GetJobId() antlr.Token { return s.jobId }

func (s *ShowAnalyzeTaskContext) SetJobId(v antlr.Token) { s.jobId = v }

func (s *ShowAnalyzeTaskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAnalyzeTaskContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowAnalyzeTaskContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisParserANALYZE, 0)
}

func (s *ShowAnalyzeTaskContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisParserTASK, 0)
}

func (s *ShowAnalyzeTaskContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATUS, 0)
}

func (s *ShowAnalyzeTaskContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ShowAnalyzeTaskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowAnalyzeTask(s)
	}
}

func (s *ShowAnalyzeTaskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowAnalyzeTask(s)
	}
}

type ShowIndexStatsContext struct {
	UnsupportedStatsStatementContext
	tableName IMultipartIdentifierContext
	indexId   IIdentifierContext
}

func NewShowIndexStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowIndexStatsContext {
	var p = new(ShowIndexStatsContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *ShowIndexStatsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowIndexStatsContext) GetIndexId() IIdentifierContext { return s.indexId }

func (s *ShowIndexStatsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowIndexStatsContext) SetIndexId(v IIdentifierContext) { s.indexId = v }

func (s *ShowIndexStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowIndexStatsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowIndexStatsContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *ShowIndexStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *ShowIndexStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowIndexStatsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowIndexStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowIndexStats(s)
	}
}

func (s *ShowIndexStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowIndexStats(s)
	}
}

type ShowAutoAnalyzeJobsContext struct {
	UnsupportedStatsStatementContext
	tableName IMultipartIdentifierContext
}

func NewShowAutoAnalyzeJobsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAutoAnalyzeJobsContext {
	var p = new(ShowAutoAnalyzeJobsContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *ShowAutoAnalyzeJobsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowAutoAnalyzeJobsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowAutoAnalyzeJobsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAutoAnalyzeJobsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowAutoAnalyzeJobsContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO, 0)
}

func (s *ShowAutoAnalyzeJobsContext) JOBS() antlr.TerminalNode {
	return s.GetToken(DorisParserJOBS, 0)
}

func (s *ShowAutoAnalyzeJobsContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowAutoAnalyzeJobsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowAutoAnalyzeJobsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowAutoAnalyzeJobs(s)
	}
}

func (s *ShowAutoAnalyzeJobsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowAutoAnalyzeJobs(s)
	}
}

type DropStatsContext struct {
	UnsupportedStatsStatementContext
	tableName IMultipartIdentifierContext
	columns   IIdentifierListContext
}

func NewDropStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropStatsContext {
	var p = new(DropStatsContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *DropStatsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DropStatsContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *DropStatsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DropStatsContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *DropStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStatsContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *DropStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropStatsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *DropStatsContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DropStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropStats(s)
	}
}

func (s *DropStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropStats(s)
	}
}

type DropCachedStatsContext struct {
	UnsupportedStatsStatementContext
	tableName IMultipartIdentifierContext
}

func NewDropCachedStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropCachedStatsContext {
	var p = new(DropCachedStatsContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *DropCachedStatsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DropCachedStatsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DropCachedStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropCachedStatsContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropCachedStatsContext) CACHED() antlr.TerminalNode {
	return s.GetToken(DorisParserCACHED, 0)
}

func (s *DropCachedStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *DropCachedStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropCachedStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropCachedStats(s)
	}
}

func (s *DropCachedStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropCachedStats(s)
	}
}

type KillAnalyzeJobContext struct {
	UnsupportedStatsStatementContext
	jobId antlr.Token
}

func NewKillAnalyzeJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KillAnalyzeJobContext {
	var p = new(KillAnalyzeJobContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *KillAnalyzeJobContext) GetJobId() antlr.Token { return s.jobId }

func (s *KillAnalyzeJobContext) SetJobId(v antlr.Token) { s.jobId = v }

func (s *KillAnalyzeJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillAnalyzeJobContext) KILL() antlr.TerminalNode {
	return s.GetToken(DorisParserKILL, 0)
}

func (s *KillAnalyzeJobContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisParserANALYZE, 0)
}

func (s *KillAnalyzeJobContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *KillAnalyzeJobContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterKillAnalyzeJob(s)
	}
}

func (s *KillAnalyzeJobContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitKillAnalyzeJob(s)
	}
}

type ShowAnalyzeContext struct {
	UnsupportedStatsStatementContext
	tableName IMultipartIdentifierContext
}

func NewShowAnalyzeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAnalyzeContext {
	var p = new(ShowAnalyzeContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *ShowAnalyzeContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowAnalyzeContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowAnalyzeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAnalyzeContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowAnalyzeContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisParserANALYZE, 0)
}

func (s *ShowAnalyzeContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO, 0)
}

func (s *ShowAnalyzeContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowAnalyzeContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowAnalyzeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowAnalyze(s)
	}
}

func (s *ShowAnalyzeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowAnalyze(s)
	}
}

type AlterColumnStatsContext struct {
	UnsupportedStatsStatementContext
	name       IMultipartIdentifierContext
	indexName  IIdentifierContext
	columnName IIdentifierContext
}

func NewAlterColumnStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterColumnStatsContext {
	var p = new(AlterColumnStatsContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *AlterColumnStatsContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterColumnStatsContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *AlterColumnStatsContext) GetColumnName() IIdentifierContext { return s.columnName }

func (s *AlterColumnStatsContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterColumnStatsContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *AlterColumnStatsContext) SetColumnName(v IIdentifierContext) { s.columnName = v }

func (s *AlterColumnStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterColumnStatsContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterColumnStatsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AlterColumnStatsContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *AlterColumnStatsContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *AlterColumnStatsContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterColumnStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *AlterColumnStatsContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterColumnStatsContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterColumnStatsContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterColumnStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterColumnStatsContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterColumnStatsContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterColumnStatsContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *AlterColumnStatsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *AlterColumnStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterColumnStats(s)
	}
}

func (s *AlterColumnStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterColumnStats(s)
	}
}

type DropExpiredStatsContext struct {
	UnsupportedStatsStatementContext
}

func NewDropExpiredStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropExpiredStatsContext {
	var p = new(DropExpiredStatsContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *DropExpiredStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropExpiredStatsContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropExpiredStatsContext) EXPIRED() antlr.TerminalNode {
	return s.GetToken(DorisParserEXPIRED, 0)
}

func (s *DropExpiredStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *DropExpiredStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropExpiredStats(s)
	}
}

func (s *DropExpiredStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropExpiredStats(s)
	}
}

type AnalyzeTableContext struct {
	UnsupportedStatsStatementContext
	name    IMultipartIdentifierContext
	columns IIdentifierListContext
}

func NewAnalyzeTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AnalyzeTableContext {
	var p = new(AnalyzeTableContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *AnalyzeTableContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AnalyzeTableContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *AnalyzeTableContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AnalyzeTableContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *AnalyzeTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeTableContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisParserANALYZE, 0)
}

func (s *AnalyzeTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AnalyzeTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AnalyzeTableContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *AnalyzeTableContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(DorisParserWITH)
}

func (s *AnalyzeTableContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, i)
}

func (s *AnalyzeTableContext) AllAnalyzeProperties() []IAnalyzePropertiesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnalyzePropertiesContext); ok {
			len++
		}
	}

	tst := make([]IAnalyzePropertiesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnalyzePropertiesContext); ok {
			tst[i] = t.(IAnalyzePropertiesContext)
			i++
		}
	}

	return tst
}

func (s *AnalyzeTableContext) AnalyzeProperties(i int) IAnalyzePropertiesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzePropertiesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzePropertiesContext)
}

func (s *AnalyzeTableContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AnalyzeTableContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *AnalyzeTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAnalyzeTable(s)
	}
}

func (s *AnalyzeTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAnalyzeTable(s)
	}
}

type ShowAnalyzeFromJobIdContext struct {
	UnsupportedStatsStatementContext
	jobId antlr.Token
}

func NewShowAnalyzeFromJobIdContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAnalyzeFromJobIdContext {
	var p = new(ShowAnalyzeFromJobIdContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *ShowAnalyzeFromJobIdContext) GetJobId() antlr.Token { return s.jobId }

func (s *ShowAnalyzeFromJobIdContext) SetJobId(v antlr.Token) { s.jobId = v }

func (s *ShowAnalyzeFromJobIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAnalyzeFromJobIdContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowAnalyzeFromJobIdContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisParserANALYZE, 0)
}

func (s *ShowAnalyzeFromJobIdContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ShowAnalyzeFromJobIdContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowAnalyzeFromJobIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowAnalyzeFromJobId(s)
	}
}

func (s *ShowAnalyzeFromJobIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowAnalyzeFromJobId(s)
	}
}

type AlterTableStatsContext struct {
	UnsupportedStatsStatementContext
	name IMultipartIdentifierContext
}

func NewAlterTableStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableStatsContext {
	var p = new(AlterTableStatsContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *AlterTableStatsContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterTableStatsContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterTableStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableStatsContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterTableStatsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AlterTableStatsContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterTableStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *AlterTableStatsContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterTableStatsContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterTableStatsContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterTableStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterTableStatsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *AlterTableStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterTableStats(s)
	}
}

func (s *AlterTableStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterTableStats(s)
	}
}

type ShowColumnHistogramStatsContext struct {
	UnsupportedStatsStatementContext
	tableName  IMultipartIdentifierContext
	columnList IIdentifierListContext
}

func NewShowColumnHistogramStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnHistogramStatsContext {
	var p = new(ShowColumnHistogramStatsContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *ShowColumnHistogramStatsContext) GetTableName() IMultipartIdentifierContext {
	return s.tableName
}

func (s *ShowColumnHistogramStatsContext) GetColumnList() IIdentifierListContext { return s.columnList }

func (s *ShowColumnHistogramStatsContext) SetTableName(v IMultipartIdentifierContext) {
	s.tableName = v
}

func (s *ShowColumnHistogramStatsContext) SetColumnList(v IIdentifierListContext) { s.columnList = v }

func (s *ShowColumnHistogramStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnHistogramStatsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowColumnHistogramStatsContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *ShowColumnHistogramStatsContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(DorisParserHISTOGRAM, 0)
}

func (s *ShowColumnHistogramStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowColumnHistogramStatsContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ShowColumnHistogramStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowColumnHistogramStats(s)
	}
}

func (s *ShowColumnHistogramStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowColumnHistogramStats(s)
	}
}

func (p *DorisParser) UnsupportedStatsStatement() (localctx IUnsupportedStatsStatementContext) {
	localctx = NewUnsupportedStatsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, DorisParserRULE_unsupportedStatsStatement)
	var _la int

	p.SetState(3631)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 498, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAnalyzeTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3477)
			p.Match(DorisParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3478)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3479)

			var _x = p.MultipartIdentifier()

			localctx.(*AnalyzeTableContext).name = _x
		}
		p.SetState(3481)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(3480)
				p.PartitionSpec()
			}

		}
		p.SetState(3484)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(3483)

				var _x = p.IdentifierList()

				localctx.(*AnalyzeTableContext).columns = _x
			}

		}
		p.SetState(3490)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserWITH {
			{
				p.SetState(3486)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3487)
				p.AnalyzeProperties()
			}

			p.SetState(3492)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(3494)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3493)
				p.PropertyClause()
			}

		}

	case 2:
		localctx = NewAnalyzeDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3496)
			p.Match(DorisParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3497)
			p.Match(DorisParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3498)

			var _x = p.MultipartIdentifier()

			localctx.(*AnalyzeDatabaseContext).name = _x
		}
		p.SetState(3503)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserWITH {
			{
				p.SetState(3499)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3500)
				p.AnalyzeProperties()
			}

			p.SetState(3505)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(3507)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3506)
				p.PropertyClause()
			}

		}

	case 3:
		localctx = NewAlterTableStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3509)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3510)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3511)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterTableStatsContext).name = _x
		}
		{
			p.SetState(3512)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3513)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3514)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3515)
			p.PropertyItemList()
		}
		{
			p.SetState(3516)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3518)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(3517)
				p.PartitionSpec()
			}

		}

	case 4:
		localctx = NewAlterColumnStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3520)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3521)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3522)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterColumnStatsContext).name = _x
		}
		p.SetState(3525)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserINDEX {
			{
				p.SetState(3523)
				p.Match(DorisParserINDEX)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3524)

				var _x = p.Identifier()

				localctx.(*AlterColumnStatsContext).indexName = _x
			}

		}
		{
			p.SetState(3527)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3528)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3529)

			var _x = p.Identifier()

			localctx.(*AlterColumnStatsContext).columnName = _x
		}
		{
			p.SetState(3530)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3531)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3532)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3533)
			p.PropertyItemList()
		}
		{
			p.SetState(3534)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3536)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(3535)
				p.PartitionSpec()
			}

		}

	case 5:
		localctx = NewDropStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3538)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3539)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3540)

			var _x = p.MultipartIdentifier()

			localctx.(*DropStatsContext).tableName = _x
		}
		p.SetState(3542)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(3541)

				var _x = p.IdentifierList()

				localctx.(*DropStatsContext).columns = _x
			}

		}
		p.SetState(3545)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(3544)
				p.PartitionSpec()
			}

		}

	case 6:
		localctx = NewDropCachedStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3547)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3548)
			p.Match(DorisParserCACHED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3549)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3550)

			var _x = p.MultipartIdentifier()

			localctx.(*DropCachedStatsContext).tableName = _x
		}

	case 7:
		localctx = NewDropExpiredStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3551)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3552)
			p.Match(DorisParserEXPIRED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3553)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewDropAanalyzeJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3554)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3555)
			p.Match(DorisParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3556)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3557)
			p.Match(DorisParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewKillAnalyzeJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3558)
			p.Match(DorisParserKILL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3559)
			p.Match(DorisParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3560)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*KillAnalyzeJobContext).jobId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewShowTableStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3561)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3562)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3563)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3564)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowTableStatsContext).tableName = _x
		}
		p.SetState(3566)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(3565)
				p.PartitionSpec()
			}

		}
		p.SetState(3569)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(3568)

				var _x = p.IdentifierList()

				localctx.(*ShowTableStatsContext).columnList = _x
			}

		}

	case 11:
		localctx = NewShowTableStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3571)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3572)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3573)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3574)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*ShowTableStatsContext).tableId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewShowIndexStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3575)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3576)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3577)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3578)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowIndexStatsContext).tableName = _x
		}
		{
			p.SetState(3579)

			var _x = p.Identifier()

			localctx.(*ShowIndexStatsContext).indexId = _x
		}

	case 13:
		localctx = NewShowColumnStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3581)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3582)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3584)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCACHED {
			{
				p.SetState(3583)
				p.Match(DorisParserCACHED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3586)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3587)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowColumnStatsContext).tableName = _x
		}
		p.SetState(3589)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(3588)

				var _x = p.IdentifierList()

				localctx.(*ShowColumnStatsContext).columnList = _x
			}

		}
		p.SetState(3592)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(3591)
				p.PartitionSpec()
			}

		}

	case 14:
		localctx = NewShowColumnHistogramStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3594)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3595)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3596)
			p.Match(DorisParserHISTOGRAM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3597)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowColumnHistogramStatsContext).tableName = _x
		}
		{
			p.SetState(3598)

			var _x = p.IdentifierList()

			localctx.(*ShowColumnHistogramStatsContext).columnList = _x
		}

	case 15:
		localctx = NewShowAnalyzeContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3600)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3602)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAUTO {
			{
				p.SetState(3601)
				p.Match(DorisParserAUTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3604)
			p.Match(DorisParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3606)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8646881558152553984) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&3026312906716208575) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-6232424940973963725) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&3937129999880936915) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-2873958502894674957) != 0) || ((int64((_la-322)) & ^0x3f) == 0 && ((int64(1)<<(_la-322))&6912752233721878527) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&-2627780018309275847) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&150083289320141) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&49159) != 0) {
			{
				p.SetState(3605)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowAnalyzeContext).tableName = _x
			}

		}
		p.SetState(3609)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(3608)
				p.WildWhere()
			}

		}

	case 16:
		localctx = NewShowAnalyzeFromJobIdContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3611)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3612)
			p.Match(DorisParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3613)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*ShowAnalyzeFromJobIdContext).jobId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3615)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(3614)
				p.WildWhere()
			}

		}

	case 17:
		localctx = NewShowAutoAnalyzeJobsContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(3617)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3618)
			p.Match(DorisParserAUTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3619)
			p.Match(DorisParserJOBS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3621)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8646881558152553984) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&3026312906716208575) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-6232424940973963725) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&3937129999880936915) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-2873958502894674957) != 0) || ((int64((_la-322)) & ^0x3f) == 0 && ((int64(1)<<(_la-322))&6912752233721878527) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&-2627780018309275847) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&150083289320141) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&49159) != 0) {
			{
				p.SetState(3620)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowAutoAnalyzeJobsContext).tableName = _x
			}

		}
		p.SetState(3624)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(3623)
				p.WildWhere()
			}

		}

	case 18:
		localctx = NewShowAnalyzeTaskContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(3626)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3627)
			p.Match(DorisParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3628)
			p.Match(DorisParserTASK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3629)
			p.Match(DorisParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3630)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*ShowAnalyzeTaskContext).jobId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyzePropertiesContext is an interface to support dynamic dispatch.
type IAnalyzePropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRows returns the rows token.
	GetRows() antlr.Token

	// GetPercent returns the percent token.
	GetPercent() antlr.Token

	// GetBucket returns the bucket token.
	GetBucket() antlr.Token

	// GetPeriodInSecond returns the periodInSecond token.
	GetPeriodInSecond() antlr.Token

	// GetCrontabExpr returns the crontabExpr token.
	GetCrontabExpr() antlr.Token

	// SetRows sets the rows token.
	SetRows(antlr.Token)

	// SetPercent sets the percent token.
	SetPercent(antlr.Token)

	// SetBucket sets the bucket token.
	SetBucket(antlr.Token)

	// SetPeriodInSecond sets the periodInSecond token.
	SetPeriodInSecond(antlr.Token)

	// SetCrontabExpr sets the crontabExpr token.
	SetCrontabExpr(antlr.Token)

	// Getter signatures
	SYNC() antlr.TerminalNode
	INCREMENTAL() antlr.TerminalNode
	FULL() antlr.TerminalNode
	SQL() antlr.TerminalNode
	HISTOGRAM() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	PERCENT() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	PERIOD() antlr.TerminalNode
	CRON() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsAnalyzePropertiesContext differentiates from other interfaces.
	IsAnalyzePropertiesContext()
}

type AnalyzePropertiesContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	rows           antlr.Token
	percent        antlr.Token
	bucket         antlr.Token
	periodInSecond antlr.Token
	crontabExpr    antlr.Token
}

func NewEmptyAnalyzePropertiesContext() *AnalyzePropertiesContext {
	var p = new(AnalyzePropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_analyzeProperties
	return p
}

func InitEmptyAnalyzePropertiesContext(p *AnalyzePropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_analyzeProperties
}

func (*AnalyzePropertiesContext) IsAnalyzePropertiesContext() {}

func NewAnalyzePropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzePropertiesContext {
	var p = new(AnalyzePropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_analyzeProperties

	return p
}

func (s *AnalyzePropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzePropertiesContext) GetRows() antlr.Token { return s.rows }

func (s *AnalyzePropertiesContext) GetPercent() antlr.Token { return s.percent }

func (s *AnalyzePropertiesContext) GetBucket() antlr.Token { return s.bucket }

func (s *AnalyzePropertiesContext) GetPeriodInSecond() antlr.Token { return s.periodInSecond }

func (s *AnalyzePropertiesContext) GetCrontabExpr() antlr.Token { return s.crontabExpr }

func (s *AnalyzePropertiesContext) SetRows(v antlr.Token) { s.rows = v }

func (s *AnalyzePropertiesContext) SetPercent(v antlr.Token) { s.percent = v }

func (s *AnalyzePropertiesContext) SetBucket(v antlr.Token) { s.bucket = v }

func (s *AnalyzePropertiesContext) SetPeriodInSecond(v antlr.Token) { s.periodInSecond = v }

func (s *AnalyzePropertiesContext) SetCrontabExpr(v antlr.Token) { s.crontabExpr = v }

func (s *AnalyzePropertiesContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DorisParserSYNC, 0)
}

func (s *AnalyzePropertiesContext) INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(DorisParserINCREMENTAL, 0)
}

func (s *AnalyzePropertiesContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserFULL, 0)
}

func (s *AnalyzePropertiesContext) SQL() antlr.TerminalNode {
	return s.GetToken(DorisParserSQL, 0)
}

func (s *AnalyzePropertiesContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(DorisParserHISTOGRAM, 0)
}

func (s *AnalyzePropertiesContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(DorisParserSAMPLE, 0)
}

func (s *AnalyzePropertiesContext) ROWS() antlr.TerminalNode {
	return s.GetToken(DorisParserROWS, 0)
}

func (s *AnalyzePropertiesContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(DorisParserPERCENT, 0)
}

func (s *AnalyzePropertiesContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *AnalyzePropertiesContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisParserBUCKETS, 0)
}

func (s *AnalyzePropertiesContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(DorisParserPERIOD, 0)
}

func (s *AnalyzePropertiesContext) CRON() antlr.TerminalNode {
	return s.GetToken(DorisParserCRON, 0)
}

func (s *AnalyzePropertiesContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *AnalyzePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzePropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnalyzePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAnalyzeProperties(s)
	}
}

func (s *AnalyzePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAnalyzeProperties(s)
	}
}

func (p *DorisParser) AnalyzeProperties() (localctx IAnalyzePropertiesContext) {
	localctx = NewAnalyzePropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, DorisParserRULE_analyzeProperties)
	p.SetState(3651)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserSYNC:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3633)
			p.Match(DorisParserSYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserINCREMENTAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3634)
			p.Match(DorisParserINCREMENTAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserFULL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3635)
			p.Match(DorisParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserSQL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3636)
			p.Match(DorisParserSQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserHISTOGRAM:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3637)
			p.Match(DorisParserHISTOGRAM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserSAMPLE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3638)
			p.Match(DorisParserSAMPLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3643)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserROWS:
			{
				p.SetState(3639)
				p.Match(DorisParserROWS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3640)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*AnalyzePropertiesContext).rows = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserPERCENT:
			{
				p.SetState(3641)
				p.Match(DorisParserPERCENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3642)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*AnalyzePropertiesContext).percent = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case DorisParserBUCKETS:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3645)
			p.Match(DorisParserBUCKETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3646)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*AnalyzePropertiesContext).bucket = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserPERIOD:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3647)
			p.Match(DorisParserPERIOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3648)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*AnalyzePropertiesContext).periodInSecond = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserCRON:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3649)
			p.Match(DorisParserCRON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3650)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*AnalyzePropertiesContext).crontabExpr = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedCreateStatementContext is an interface to support dynamic dispatch.
type IUnsupportedCreateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedCreateStatementContext differentiates from other interfaces.
	IsUnsupportedCreateStatementContext()
}

type UnsupportedCreateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedCreateStatementContext() *UnsupportedCreateStatementContext {
	var p = new(UnsupportedCreateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedCreateStatement
	return p
}

func InitEmptyUnsupportedCreateStatementContext(p *UnsupportedCreateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedCreateStatement
}

func (*UnsupportedCreateStatementContext) IsUnsupportedCreateStatementContext() {}

func NewUnsupportedCreateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedCreateStatementContext {
	var p = new(UnsupportedCreateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedCreateStatement

	return p
}

func (s *UnsupportedCreateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedCreateStatementContext) CopyAll(ctx *UnsupportedCreateStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedCreateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedCreateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CreateRepositoryContext struct {
	UnsupportedCreateStatementContext
	name IIdentifierContext
}

func NewCreateRepositoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateRepositoryContext {
	var p = new(CreateRepositoryContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateRepositoryContext) GetName() IIdentifierContext { return s.name }

func (s *CreateRepositoryContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateRepositoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRepositoryContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateRepositoryContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisParserREPOSITORY, 0)
}

func (s *CreateRepositoryContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *CreateRepositoryContext) StorageBackend() IStorageBackendContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStorageBackendContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStorageBackendContext)
}

func (s *CreateRepositoryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRepositoryContext) READ() antlr.TerminalNode {
	return s.GetToken(DorisParserREAD, 0)
}

func (s *CreateRepositoryContext) ONLY() antlr.TerminalNode {
	return s.GetToken(DorisParserONLY, 0)
}

func (s *CreateRepositoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateRepository(s)
	}
}

func (s *CreateRepositoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateRepository(s)
	}
}

type CreateDatabaseContext struct {
	UnsupportedCreateStatementContext
	name       IMultipartIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateDatabaseContext {
	var p = new(CreateDatabaseContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateDatabaseContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CreateDatabaseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateDatabaseContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CreateDatabaseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDatabaseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *CreateDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEMA, 0)
}

func (s *CreateDatabaseContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateDatabaseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateDatabaseContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateDatabaseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateDatabaseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateDatabase(s)
	}
}

func (s *CreateDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateDatabase(s)
	}
}

type CreateStorageVaultContext struct {
	UnsupportedCreateStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewCreateStorageVaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateStorageVaultContext {
	var p = new(CreateStorageVaultContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateStorageVaultContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *CreateStorageVaultContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateStorageVaultContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *CreateStorageVaultContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateStorageVaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStorageVaultContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateStorageVaultContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *CreateStorageVaultContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULT, 0)
}

func (s *CreateStorageVaultContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CreateStorageVaultContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateStorageVaultContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateStorageVaultContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateStorageVaultContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateStorageVaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateStorageVault(s)
	}
}

func (s *CreateStorageVaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateStorageVault(s)
	}
}

type CreateWorkloadPolicyContext struct {
	UnsupportedCreateStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewCreateWorkloadPolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateWorkloadPolicyContext {
	var p = new(CreateWorkloadPolicyContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateWorkloadPolicyContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *CreateWorkloadPolicyContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateWorkloadPolicyContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *CreateWorkloadPolicyContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateWorkloadPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateWorkloadPolicyContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateWorkloadPolicyContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserWORKLOAD, 0)
}

func (s *CreateWorkloadPolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *CreateWorkloadPolicyContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CreateWorkloadPolicyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateWorkloadPolicyContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateWorkloadPolicyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateWorkloadPolicyContext) CONDITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserCONDITIONS, 0)
}

func (s *CreateWorkloadPolicyContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserLEFT_PAREN)
}

func (s *CreateWorkloadPolicyContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, i)
}

func (s *CreateWorkloadPolicyContext) WorkloadPolicyConditions() IWorkloadPolicyConditionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWorkloadPolicyConditionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWorkloadPolicyConditionsContext)
}

func (s *CreateWorkloadPolicyContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserRIGHT_PAREN)
}

func (s *CreateWorkloadPolicyContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, i)
}

func (s *CreateWorkloadPolicyContext) ACTIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserACTIONS, 0)
}

func (s *CreateWorkloadPolicyContext) WorkloadPolicyActions() IWorkloadPolicyActionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWorkloadPolicyActionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWorkloadPolicyActionsContext)
}

func (s *CreateWorkloadPolicyContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateWorkloadPolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateWorkloadPolicy(s)
	}
}

func (s *CreateWorkloadPolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateWorkloadPolicy(s)
	}
}

type CreateResourceContext struct {
	UnsupportedCreateStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewCreateResourceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateResourceContext {
	var p = new(CreateResourceContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateResourceContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *CreateResourceContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateResourceContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *CreateResourceContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateResourceContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateResourceContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCE, 0)
}

func (s *CreateResourceContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CreateResourceContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisParserEXTERNAL, 0)
}

func (s *CreateResourceContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateResourceContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateResourceContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateResourceContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateResourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateResource(s)
	}
}

func (s *CreateResourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateResource(s)
	}
}

type CreateUserDefineFunctionContext struct {
	UnsupportedCreateStatementContext
	returnType       IDataTypeContext
	intermediateType IDataTypeContext
	properties       IPropertyClauseContext
}

func NewCreateUserDefineFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateUserDefineFunctionContext {
	var p = new(CreateUserDefineFunctionContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateUserDefineFunctionContext) GetReturnType() IDataTypeContext { return s.returnType }

func (s *CreateUserDefineFunctionContext) GetIntermediateType() IDataTypeContext {
	return s.intermediateType
}

func (s *CreateUserDefineFunctionContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateUserDefineFunctionContext) SetReturnType(v IDataTypeContext) { s.returnType = v }

func (s *CreateUserDefineFunctionContext) SetIntermediateType(v IDataTypeContext) {
	s.intermediateType = v
}

func (s *CreateUserDefineFunctionContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateUserDefineFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserDefineFunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateUserDefineFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserFUNCTION, 0)
}

func (s *CreateUserDefineFunctionContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *CreateUserDefineFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CreateUserDefineFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CreateUserDefineFunctionContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(DorisParserRETURNS, 0)
}

func (s *CreateUserDefineFunctionContext) AllDataType() []IDataTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeContext); ok {
			tst[i] = t.(IDataTypeContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserDefineFunctionContext) DataType(i int) IDataTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CreateUserDefineFunctionContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateUserDefineFunctionContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateUserDefineFunctionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateUserDefineFunctionContext) FunctionArguments() IFunctionArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgumentsContext)
}

func (s *CreateUserDefineFunctionContext) INTERMEDIATE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTERMEDIATE, 0)
}

func (s *CreateUserDefineFunctionContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *CreateUserDefineFunctionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION, 0)
}

func (s *CreateUserDefineFunctionContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *CreateUserDefineFunctionContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLES, 0)
}

func (s *CreateUserDefineFunctionContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(DorisParserAGGREGATE, 0)
}

func (s *CreateUserDefineFunctionContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateUserDefineFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateUserDefineFunction(s)
	}
}

func (s *CreateUserDefineFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateUserDefineFunction(s)
	}
}

type CreateStoragePolicyContext struct {
	UnsupportedCreateStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateStoragePolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateStoragePolicyContext {
	var p = new(CreateStoragePolicyContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateStoragePolicyContext) GetName() IIdentifierContext { return s.name }

func (s *CreateStoragePolicyContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateStoragePolicyContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateStoragePolicyContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateStoragePolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStoragePolicyContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateStoragePolicyContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *CreateStoragePolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *CreateStoragePolicyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateStoragePolicyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateStoragePolicyContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateStoragePolicyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateStoragePolicyContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateStoragePolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateStoragePolicy(s)
	}
}

func (s *CreateStoragePolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateStoragePolicy(s)
	}
}

type BuildIndexContext struct {
	UnsupportedCreateStatementContext
	name      IIdentifierContext
	tableName IMultipartIdentifierContext
}

func NewBuildIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BuildIndexContext {
	var p = new(BuildIndexContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *BuildIndexContext) GetName() IIdentifierContext { return s.name }

func (s *BuildIndexContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *BuildIndexContext) SetName(v IIdentifierContext) { s.name = v }

func (s *BuildIndexContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *BuildIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BuildIndexContext) BUILD() antlr.TerminalNode {
	return s.GetToken(DorisParserBUILD, 0)
}

func (s *BuildIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *BuildIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *BuildIndexContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BuildIndexContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *BuildIndexContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *BuildIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBuildIndex(s)
	}
}

func (s *BuildIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBuildIndex(s)
	}
}

type CreateStageContext struct {
	UnsupportedCreateStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateStageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateStageContext {
	var p = new(CreateStageContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateStageContext) GetName() IIdentifierContext { return s.name }

func (s *CreateStageContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateStageContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateStageContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateStageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStageContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateStageContext) STAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTAGE, 0)
}

func (s *CreateStageContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateStageContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateStageContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateStageContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateStageContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateStageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateStage(s)
	}
}

func (s *CreateStageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateStage(s)
	}
}

type CreateUserContext struct {
	UnsupportedCreateStatementContext
	role antlr.Token
}

func NewCreateUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateUserContext {
	var p = new(CreateUserContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateUserContext) GetRole() antlr.Token { return s.role }

func (s *CreateUserContext) SetRole(v antlr.Token) { s.role = v }

func (s *CreateUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateUserContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisParserUSER, 0)
}

func (s *CreateUserContext) GrantUserIdentify() IGrantUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantUserIdentifyContext)
}

func (s *CreateUserContext) PasswordOption() IPasswordOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordOptionContext)
}

func (s *CreateUserContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateUserContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateUserContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateUserContext) SUPERUSER() antlr.TerminalNode {
	return s.GetToken(DorisParserSUPERUSER, 0)
}

func (s *CreateUserContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *CreateUserContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *CreateUserContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *CreateUserContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *CreateUserContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *CreateUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateUser(s)
	}
}

func (s *CreateUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateUser(s)
	}
}

type CreateAliasFunctionContext struct {
	UnsupportedCreateStatementContext
	parameters IIdentifierSeqContext
}

func NewCreateAliasFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateAliasFunctionContext {
	var p = new(CreateAliasFunctionContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateAliasFunctionContext) GetParameters() IIdentifierSeqContext { return s.parameters }

func (s *CreateAliasFunctionContext) SetParameters(v IIdentifierSeqContext) { s.parameters = v }

func (s *CreateAliasFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateAliasFunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateAliasFunctionContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(DorisParserALIAS, 0)
}

func (s *CreateAliasFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserFUNCTION, 0)
}

func (s *CreateAliasFunctionContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *CreateAliasFunctionContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserLEFT_PAREN)
}

func (s *CreateAliasFunctionContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, i)
}

func (s *CreateAliasFunctionContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserRIGHT_PAREN)
}

func (s *CreateAliasFunctionContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, i)
}

func (s *CreateAliasFunctionContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *CreateAliasFunctionContext) PARAMETER() antlr.TerminalNode {
	return s.GetToken(DorisParserPARAMETER, 0)
}

func (s *CreateAliasFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *CreateAliasFunctionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CreateAliasFunctionContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateAliasFunctionContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateAliasFunctionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateAliasFunctionContext) FunctionArguments() IFunctionArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgumentsContext)
}

func (s *CreateAliasFunctionContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *CreateAliasFunctionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION, 0)
}

func (s *CreateAliasFunctionContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *CreateAliasFunctionContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *CreateAliasFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateAliasFunction(s)
	}
}

func (s *CreateAliasFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateAliasFunction(s)
	}
}

type CreateIndexContext struct {
	UnsupportedCreateStatementContext
	name       IIdentifierContext
	tableName  IMultipartIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateIndexContext {
	var p = new(CreateIndexContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateIndexContext) GetName() IIdentifierContext { return s.name }

func (s *CreateIndexContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *CreateIndexContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateIndexContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateIndexContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *CreateIndexContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *CreateIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *CreateIndexContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateIndexContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateIndexContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateIndexContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateIndexContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateIndexContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateIndexContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserUSING, 0)
}

func (s *CreateIndexContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *CreateIndexContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateIndexContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(DorisParserBITMAP, 0)
}

func (s *CreateIndexContext) NGRAM_BF() antlr.TerminalNode {
	return s.GetToken(DorisParserNGRAM_BF, 0)
}

func (s *CreateIndexContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserINVERTED, 0)
}

func (s *CreateIndexContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateIndex(s)
	}
}

func (s *CreateIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateIndex(s)
	}
}

func (p *DorisParser) UnsupportedCreateStatement() (localctx IUnsupportedCreateStatementContext) {
	localctx = NewUnsupportedCreateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, DorisParserRULE_unsupportedCreateStatement)
	var _la int

	p.SetState(3853)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 535, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCreateDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3653)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3654)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserDATABASE || _la == DorisParserSCHEMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(3658)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(3655)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3656)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3657)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3660)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateDatabaseContext).name = _x
		}
		p.SetState(3662)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3661)

				var _x = p.PropertyClause()

				localctx.(*CreateDatabaseContext).properties = _x
			}

		}

	case 2:
		localctx = NewCreateUserDefineFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3664)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3666)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION {
			{
				p.SetState(3665)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(3669)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAGGREGATE || _la == DorisParserTABLES {
			{
				p.SetState(3668)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserAGGREGATE || _la == DorisParserTABLES) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(3671)
			p.Match(DorisParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3675)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 505, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3672)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3673)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3674)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3677)
			p.FunctionIdentifier()
		}
		{
			p.SetState(3678)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3680)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4576167530201152) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&16870906416594945) != 0) || _la == DorisParserDOUBLE || _la == DorisParserFLOAT || ((int64((_la-207)) & ^0x3f) == 0 && ((int64(1)<<(_la-207))&-9223369734650855423) != 0) || _la == DorisParserQUANTILE_STATE || _la == DorisParserSMALLINT || ((int64((_la-429)) & ^0x3f) == 0 && ((int64(1)<<(_la-429))&5066549583478787) != 0) {
			{
				p.SetState(3679)
				p.FunctionArguments()
			}

		}
		{
			p.SetState(3682)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3683)
			p.Match(DorisParserRETURNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3684)

			var _x = p.DataType()

			localctx.(*CreateUserDefineFunctionContext).returnType = _x
		}
		p.SetState(3687)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserINTERMEDIATE {
			{
				p.SetState(3685)
				p.Match(DorisParserINTERMEDIATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3686)

				var _x = p.DataType()

				localctx.(*CreateUserDefineFunctionContext).intermediateType = _x
			}

		}
		p.SetState(3690)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3689)

				var _x = p.PropertyClause()

				localctx.(*CreateUserDefineFunctionContext).properties = _x
			}

		}

	case 3:
		localctx = NewCreateAliasFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3692)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3694)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION {
			{
				p.SetState(3693)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(3696)
			p.Match(DorisParserALIAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3697)
			p.Match(DorisParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3701)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 510, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3698)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3699)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3700)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3703)
			p.FunctionIdentifier()
		}
		{
			p.SetState(3704)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3706)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4576167530201152) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&16870906416594945) != 0) || _la == DorisParserDOUBLE || _la == DorisParserFLOAT || ((int64((_la-207)) & ^0x3f) == 0 && ((int64(1)<<(_la-207))&-9223369734650855423) != 0) || _la == DorisParserQUANTILE_STATE || _la == DorisParserSMALLINT || ((int64((_la-429)) & ^0x3f) == 0 && ((int64(1)<<(_la-429))&5066549583478787) != 0) {
			{
				p.SetState(3705)
				p.FunctionArguments()
			}

		}
		{
			p.SetState(3708)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3709)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3710)
			p.Match(DorisParserPARAMETER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3711)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3713)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8646881558152553984) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&3026312906716208575) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-6232424940973963725) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&3937129999880936915) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-2873958502894674957) != 0) || ((int64((_la-322)) & ^0x3f) == 0 && ((int64(1)<<(_la-322))&6912752233721878527) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&-2627780018309275847) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&150083289320141) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&49159) != 0) {
			{
				p.SetState(3712)

				var _x = p.IdentifierSeq()

				localctx.(*CreateAliasFunctionContext).parameters = _x
			}

		}
		{
			p.SetState(3715)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3716)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3717)
			p.Expression()
		}

	case 4:
		localctx = NewCreateUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3719)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3720)
			p.Match(DorisParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3724)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(3721)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3722)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3723)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3726)
			p.GrantUserIdentify()
		}
		p.SetState(3731)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case DorisParserSUPERUSER:
			{
				p.SetState(3727)
				p.Match(DorisParserSUPERUSER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserDEFAULT:
			{
				p.SetState(3728)
				p.Match(DorisParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3729)
				p.Match(DorisParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3730)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*CreateUserContext).role = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserEOF, DorisParserSEMICOLON, DorisParserACCOUNT_LOCK, DorisParserACCOUNT_UNLOCK, DorisParserCOMMENT, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE:

		default:
		}
		{
			p.SetState(3733)
			p.PasswordOption()
		}
		p.SetState(3736)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(3734)
				p.Match(DorisParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3735)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		localctx = NewCreateRepositoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3738)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3741)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserREAD {
			{
				p.SetState(3739)
				p.Match(DorisParserREAD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3740)
				p.Match(DorisParserONLY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3743)
			p.Match(DorisParserREPOSITORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3744)

			var _x = p.Identifier()

			localctx.(*CreateRepositoryContext).name = _x
		}
		{
			p.SetState(3745)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3746)
			p.StorageBackend()
		}

	case 6:
		localctx = NewCreateIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3748)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3749)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3753)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(3750)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3751)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3752)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3755)

			var _x = p.Identifier()

			localctx.(*CreateIndexContext).name = _x
		}
		{
			p.SetState(3756)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3757)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateIndexContext).tableName = _x
		}
		{
			p.SetState(3758)
			p.IdentifierList()
		}
		p.SetState(3761)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserUSING {
			{
				p.SetState(3759)
				p.Match(DorisParserUSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3760)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserBITMAP || _la == DorisParserINVERTED || _la == DorisParserNGRAM_BF) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(3764)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3763)

				var _x = p.PropertyClause()

				localctx.(*CreateIndexContext).properties = _x
			}

		}
		p.SetState(3768)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(3766)
				p.Match(DorisParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3767)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 7:
		localctx = NewCreateResourceContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3770)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3772)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserEXTERNAL {
			{
				p.SetState(3771)
				p.Match(DorisParserEXTERNAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3774)
			p.Match(DorisParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3778)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(3775)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3776)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3777)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3780)

			var _x = p.IdentifierOrText()

			localctx.(*CreateResourceContext).name = _x
		}
		p.SetState(3782)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3781)

				var _x = p.PropertyClause()

				localctx.(*CreateResourceContext).properties = _x
			}

		}

	case 8:
		localctx = NewCreateStorageVaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3784)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3785)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3786)
			p.Match(DorisParserVAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3790)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(3787)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3788)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3789)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3792)

			var _x = p.IdentifierOrText()

			localctx.(*CreateStorageVaultContext).name = _x
		}
		p.SetState(3794)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3793)

				var _x = p.PropertyClause()

				localctx.(*CreateStorageVaultContext).properties = _x
			}

		}

	case 9:
		localctx = NewCreateWorkloadPolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3796)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3797)
			p.Match(DorisParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3798)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3802)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(3799)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3800)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3801)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3804)

			var _x = p.IdentifierOrText()

			localctx.(*CreateWorkloadPolicyContext).name = _x
		}
		p.SetState(3810)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCONDITIONS {
			{
				p.SetState(3805)
				p.Match(DorisParserCONDITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3806)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3807)
				p.WorkloadPolicyConditions()
			}
			{
				p.SetState(3808)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3817)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserACTIONS {
			{
				p.SetState(3812)
				p.Match(DorisParserACTIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3813)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3814)
				p.WorkloadPolicyActions()
			}
			{
				p.SetState(3815)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3820)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3819)

				var _x = p.PropertyClause()

				localctx.(*CreateWorkloadPolicyContext).properties = _x
			}

		}

	case 10:
		localctx = NewCreateStoragePolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3822)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3823)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3824)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3828)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(3825)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3826)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3827)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3830)

			var _x = p.Identifier()

			localctx.(*CreateStoragePolicyContext).name = _x
		}
		p.SetState(3832)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3831)

				var _x = p.PropertyClause()

				localctx.(*CreateStoragePolicyContext).properties = _x
			}

		}

	case 11:
		localctx = NewBuildIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3834)
			p.Match(DorisParserBUILD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3835)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3836)

			var _x = p.Identifier()

			localctx.(*BuildIndexContext).name = _x
		}
		{
			p.SetState(3837)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3838)

			var _x = p.MultipartIdentifier()

			localctx.(*BuildIndexContext).tableName = _x
		}
		p.SetState(3840)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(3839)
				p.PartitionSpec()
			}

		}

	case 12:
		localctx = NewCreateStageContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3842)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3843)
			p.Match(DorisParserSTAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3847)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(3844)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3845)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3846)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3849)

			var _x = p.Identifier()

			localctx.(*CreateStageContext).name = _x
		}
		p.SetState(3851)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3850)

				var _x = p.PropertyClause()

				localctx.(*CreateStageContext).properties = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWorkloadPolicyActionsContext is an interface to support dynamic dispatch.
type IWorkloadPolicyActionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWorkloadPolicyAction() []IWorkloadPolicyActionContext
	WorkloadPolicyAction(i int) IWorkloadPolicyActionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWorkloadPolicyActionsContext differentiates from other interfaces.
	IsWorkloadPolicyActionsContext()
}

type WorkloadPolicyActionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWorkloadPolicyActionsContext() *WorkloadPolicyActionsContext {
	var p = new(WorkloadPolicyActionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_workloadPolicyActions
	return p
}

func InitEmptyWorkloadPolicyActionsContext(p *WorkloadPolicyActionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_workloadPolicyActions
}

func (*WorkloadPolicyActionsContext) IsWorkloadPolicyActionsContext() {}

func NewWorkloadPolicyActionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WorkloadPolicyActionsContext {
	var p = new(WorkloadPolicyActionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_workloadPolicyActions

	return p
}

func (s *WorkloadPolicyActionsContext) GetParser() antlr.Parser { return s.parser }

func (s *WorkloadPolicyActionsContext) AllWorkloadPolicyAction() []IWorkloadPolicyActionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWorkloadPolicyActionContext); ok {
			len++
		}
	}

	tst := make([]IWorkloadPolicyActionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWorkloadPolicyActionContext); ok {
			tst[i] = t.(IWorkloadPolicyActionContext)
			i++
		}
	}

	return tst
}

func (s *WorkloadPolicyActionsContext) WorkloadPolicyAction(i int) IWorkloadPolicyActionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWorkloadPolicyActionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWorkloadPolicyActionContext)
}

func (s *WorkloadPolicyActionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *WorkloadPolicyActionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *WorkloadPolicyActionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WorkloadPolicyActionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WorkloadPolicyActionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWorkloadPolicyActions(s)
	}
}

func (s *WorkloadPolicyActionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWorkloadPolicyActions(s)
	}
}

func (p *DorisParser) WorkloadPolicyActions() (localctx IWorkloadPolicyActionsContext) {
	localctx = NewWorkloadPolicyActionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, DorisParserRULE_workloadPolicyActions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3855)
		p.WorkloadPolicyAction()
	}
	p.SetState(3860)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(3856)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3857)
			p.WorkloadPolicyAction()
		}

		p.SetState(3862)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWorkloadPolicyActionContext is an interface to support dynamic dispatch.
type IWorkloadPolicyActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET_SESSION_VARIABLE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsWorkloadPolicyActionContext differentiates from other interfaces.
	IsWorkloadPolicyActionContext()
}

type WorkloadPolicyActionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWorkloadPolicyActionContext() *WorkloadPolicyActionContext {
	var p = new(WorkloadPolicyActionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_workloadPolicyAction
	return p
}

func InitEmptyWorkloadPolicyActionContext(p *WorkloadPolicyActionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_workloadPolicyAction
}

func (*WorkloadPolicyActionContext) IsWorkloadPolicyActionContext() {}

func NewWorkloadPolicyActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WorkloadPolicyActionContext {
	var p = new(WorkloadPolicyActionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_workloadPolicyAction

	return p
}

func (s *WorkloadPolicyActionContext) GetParser() antlr.Parser { return s.parser }

func (s *WorkloadPolicyActionContext) SET_SESSION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserSET_SESSION_VARIABLE, 0)
}

func (s *WorkloadPolicyActionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *WorkloadPolicyActionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WorkloadPolicyActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WorkloadPolicyActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WorkloadPolicyActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWorkloadPolicyAction(s)
	}
}

func (s *WorkloadPolicyActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWorkloadPolicyAction(s)
	}
}

func (p *DorisParser) WorkloadPolicyAction() (localctx IWorkloadPolicyActionContext) {
	localctx = NewWorkloadPolicyActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, DorisParserRULE_workloadPolicyAction)
	var _la int

	p.SetState(3869)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 538, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3863)
			p.Match(DorisParserSET_SESSION_VARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3864)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3865)
			p.Identifier()
		}
		p.SetState(3867)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserSTRING_LITERAL {
			{
				p.SetState(3866)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWorkloadPolicyConditionsContext is an interface to support dynamic dispatch.
type IWorkloadPolicyConditionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWorkloadPolicyCondition() []IWorkloadPolicyConditionContext
	WorkloadPolicyCondition(i int) IWorkloadPolicyConditionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWorkloadPolicyConditionsContext differentiates from other interfaces.
	IsWorkloadPolicyConditionsContext()
}

type WorkloadPolicyConditionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWorkloadPolicyConditionsContext() *WorkloadPolicyConditionsContext {
	var p = new(WorkloadPolicyConditionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_workloadPolicyConditions
	return p
}

func InitEmptyWorkloadPolicyConditionsContext(p *WorkloadPolicyConditionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_workloadPolicyConditions
}

func (*WorkloadPolicyConditionsContext) IsWorkloadPolicyConditionsContext() {}

func NewWorkloadPolicyConditionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WorkloadPolicyConditionsContext {
	var p = new(WorkloadPolicyConditionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_workloadPolicyConditions

	return p
}

func (s *WorkloadPolicyConditionsContext) GetParser() antlr.Parser { return s.parser }

func (s *WorkloadPolicyConditionsContext) AllWorkloadPolicyCondition() []IWorkloadPolicyConditionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWorkloadPolicyConditionContext); ok {
			len++
		}
	}

	tst := make([]IWorkloadPolicyConditionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWorkloadPolicyConditionContext); ok {
			tst[i] = t.(IWorkloadPolicyConditionContext)
			i++
		}
	}

	return tst
}

func (s *WorkloadPolicyConditionsContext) WorkloadPolicyCondition(i int) IWorkloadPolicyConditionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWorkloadPolicyConditionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWorkloadPolicyConditionContext)
}

func (s *WorkloadPolicyConditionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *WorkloadPolicyConditionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *WorkloadPolicyConditionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WorkloadPolicyConditionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WorkloadPolicyConditionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWorkloadPolicyConditions(s)
	}
}

func (s *WorkloadPolicyConditionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWorkloadPolicyConditions(s)
	}
}

func (p *DorisParser) WorkloadPolicyConditions() (localctx IWorkloadPolicyConditionsContext) {
	localctx = NewWorkloadPolicyConditionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, DorisParserRULE_workloadPolicyConditions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3871)
		p.WorkloadPolicyCondition()
	}
	p.SetState(3876)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(3872)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3873)
			p.WorkloadPolicyCondition()
		}

		p.SetState(3878)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWorkloadPolicyConditionContext is an interface to support dynamic dispatch.
type IWorkloadPolicyConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMetricName returns the metricName rule contexts.
	GetMetricName() IIdentifierContext

	// SetMetricName sets the metricName rule contexts.
	SetMetricName(IIdentifierContext)

	// Getter signatures
	ComparisonOperator() IComparisonOperatorContext
	Identifier() IIdentifierContext
	Number() INumberContext
	STRING_LITERAL() antlr.TerminalNode

	// IsWorkloadPolicyConditionContext differentiates from other interfaces.
	IsWorkloadPolicyConditionContext()
}

type WorkloadPolicyConditionContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	metricName IIdentifierContext
}

func NewEmptyWorkloadPolicyConditionContext() *WorkloadPolicyConditionContext {
	var p = new(WorkloadPolicyConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_workloadPolicyCondition
	return p
}

func InitEmptyWorkloadPolicyConditionContext(p *WorkloadPolicyConditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_workloadPolicyCondition
}

func (*WorkloadPolicyConditionContext) IsWorkloadPolicyConditionContext() {}

func NewWorkloadPolicyConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WorkloadPolicyConditionContext {
	var p = new(WorkloadPolicyConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_workloadPolicyCondition

	return p
}

func (s *WorkloadPolicyConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *WorkloadPolicyConditionContext) GetMetricName() IIdentifierContext { return s.metricName }

func (s *WorkloadPolicyConditionContext) SetMetricName(v IIdentifierContext) { s.metricName = v }

func (s *WorkloadPolicyConditionContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *WorkloadPolicyConditionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WorkloadPolicyConditionContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *WorkloadPolicyConditionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *WorkloadPolicyConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WorkloadPolicyConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WorkloadPolicyConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWorkloadPolicyCondition(s)
	}
}

func (s *WorkloadPolicyConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWorkloadPolicyCondition(s)
	}
}

func (p *DorisParser) WorkloadPolicyCondition() (localctx IWorkloadPolicyConditionContext) {
	localctx = NewWorkloadPolicyConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, DorisParserRULE_workloadPolicyCondition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3879)

		var _x = p.Identifier()

		localctx.(*WorkloadPolicyConditionContext).metricName = _x
	}
	{
		p.SetState(3880)
		p.ComparisonOperator()
	}
	p.SetState(3883)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserSUBTRACT, DorisParserINTEGER_VALUE, DorisParserEXPONENT_VALUE, DorisParserDECIMAL_VALUE:
		{
			p.SetState(3881)
			p.Number()
		}

	case DorisParserSTRING_LITERAL:
		{
			p.SetState(3882)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStorageBackendContext is an interface to support dynamic dispatch.
type IStorageBackendContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBrokerName returns the brokerName rule contexts.
	GetBrokerName() IIdentifierContext

	// GetProperties returns the properties rule contexts.
	GetProperties() IPropertyClauseContext

	// SetBrokerName sets the brokerName rule contexts.
	SetBrokerName(IIdentifierContext)

	// SetProperties sets the properties rule contexts.
	SetProperties(IPropertyClauseContext)

	// Getter signatures
	ON() antlr.TerminalNode
	LOCATION() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	S3() antlr.TerminalNode
	HDFS() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	Identifier() IIdentifierContext
	PropertyClause() IPropertyClauseContext

	// IsStorageBackendContext differentiates from other interfaces.
	IsStorageBackendContext()
}

type StorageBackendContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	brokerName IIdentifierContext
	properties IPropertyClauseContext
}

func NewEmptyStorageBackendContext() *StorageBackendContext {
	var p = new(StorageBackendContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_storageBackend
	return p
}

func InitEmptyStorageBackendContext(p *StorageBackendContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_storageBackend
}

func (*StorageBackendContext) IsStorageBackendContext() {}

func NewStorageBackendContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StorageBackendContext {
	var p = new(StorageBackendContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_storageBackend

	return p
}

func (s *StorageBackendContext) GetParser() antlr.Parser { return s.parser }

func (s *StorageBackendContext) GetBrokerName() IIdentifierContext { return s.brokerName }

func (s *StorageBackendContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *StorageBackendContext) SetBrokerName(v IIdentifierContext) { s.brokerName = v }

func (s *StorageBackendContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *StorageBackendContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *StorageBackendContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCATION, 0)
}

func (s *StorageBackendContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *StorageBackendContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserBROKER, 0)
}

func (s *StorageBackendContext) S3() antlr.TerminalNode {
	return s.GetToken(DorisParserS3, 0)
}

func (s *StorageBackendContext) HDFS() antlr.TerminalNode {
	return s.GetToken(DorisParserHDFS, 0)
}

func (s *StorageBackendContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *StorageBackendContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StorageBackendContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *StorageBackendContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StorageBackendContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StorageBackendContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStorageBackend(s)
	}
}

func (s *StorageBackendContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStorageBackend(s)
	}
}

func (p *DorisParser) StorageBackend() (localctx IStorageBackendContext) {
	localctx = NewStorageBackendContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, DorisParserRULE_storageBackend)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3885)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserBROKER || _la == DorisParserHDFS || _la == DorisParserLOCAL || _la == DorisParserS3) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3887)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8646881558152553984) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&3026312906716208575) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-6232424940973963725) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&3937129999880936915) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-2873958502894674957) != 0) || ((int64((_la-322)) & ^0x3f) == 0 && ((int64(1)<<(_la-322))&6912752233721878527) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&-2627780018309275847) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&150083289320141) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&49159) != 0) {
		{
			p.SetState(3886)

			var _x = p.Identifier()

			localctx.(*StorageBackendContext).brokerName = _x
		}

	}
	{
		p.SetState(3889)
		p.Match(DorisParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3890)
		p.Match(DorisParserLOCATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3891)
		p.Match(DorisParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3893)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPROPERTIES {
		{
			p.SetState(3892)

			var _x = p.PropertyClause()

			localctx.(*StorageBackendContext).properties = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPasswordOptionContext is an interface to support dynamic dispatch.
type IPasswordOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetHistoryDefault returns the historyDefault token.
	GetHistoryDefault() antlr.Token

	// GetHistoryValue returns the historyValue token.
	GetHistoryValue() antlr.Token

	// GetExpireDefault returns the expireDefault token.
	GetExpireDefault() antlr.Token

	// GetExpireNever returns the expireNever token.
	GetExpireNever() antlr.Token

	// GetExpireValue returns the expireValue token.
	GetExpireValue() antlr.Token

	// GetExpireTimeUnit returns the expireTimeUnit token.
	GetExpireTimeUnit() antlr.Token

	// GetReuseDefault returns the reuseDefault token.
	GetReuseDefault() antlr.Token

	// GetReuseValue returns the reuseValue token.
	GetReuseValue() antlr.Token

	// GetAttemptsValue returns the attemptsValue token.
	GetAttemptsValue() antlr.Token

	// GetLockUnbounded returns the lockUnbounded token.
	GetLockUnbounded() antlr.Token

	// GetLockValue returns the lockValue token.
	GetLockValue() antlr.Token

	// GetLockTimeUint returns the lockTimeUint token.
	GetLockTimeUint() antlr.Token

	// SetHistoryDefault sets the historyDefault token.
	SetHistoryDefault(antlr.Token)

	// SetHistoryValue sets the historyValue token.
	SetHistoryValue(antlr.Token)

	// SetExpireDefault sets the expireDefault token.
	SetExpireDefault(antlr.Token)

	// SetExpireNever sets the expireNever token.
	SetExpireNever(antlr.Token)

	// SetExpireValue sets the expireValue token.
	SetExpireValue(antlr.Token)

	// SetExpireTimeUnit sets the expireTimeUnit token.
	SetExpireTimeUnit(antlr.Token)

	// SetReuseDefault sets the reuseDefault token.
	SetReuseDefault(antlr.Token)

	// SetReuseValue sets the reuseValue token.
	SetReuseValue(antlr.Token)

	// SetAttemptsValue sets the attemptsValue token.
	SetAttemptsValue(antlr.Token)

	// SetLockUnbounded sets the lockUnbounded token.
	SetLockUnbounded(antlr.Token)

	// SetLockValue sets the lockValue token.
	SetLockValue(antlr.Token)

	// SetLockTimeUint sets the lockTimeUint token.
	SetLockTimeUint(antlr.Token)

	// Getter signatures
	PASSWORD_HISTORY() antlr.TerminalNode
	PASSWORD_EXPIRE() antlr.TerminalNode
	PASSWORD_REUSE() antlr.TerminalNode
	AllINTERVAL() []antlr.TerminalNode
	INTERVAL(i int) antlr.TerminalNode
	FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode
	PASSWORD_LOCK_TIME() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	ACCOUNT_LOCK() antlr.TerminalNode
	ACCOUNT_UNLOCK() antlr.TerminalNode
	AllDAY() []antlr.TerminalNode
	DAY(i int) antlr.TerminalNode
	AllDEFAULT() []antlr.TerminalNode
	DEFAULT(i int) antlr.TerminalNode
	NEVER() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	AllHOUR() []antlr.TerminalNode
	HOUR(i int) antlr.TerminalNode
	AllSECOND() []antlr.TerminalNode
	SECOND(i int) antlr.TerminalNode

	// IsPasswordOptionContext differentiates from other interfaces.
	IsPasswordOptionContext()
}

type PasswordOptionContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	historyDefault antlr.Token
	historyValue   antlr.Token
	expireDefault  antlr.Token
	expireNever    antlr.Token
	expireValue    antlr.Token
	expireTimeUnit antlr.Token
	reuseDefault   antlr.Token
	reuseValue     antlr.Token
	attemptsValue  antlr.Token
	lockUnbounded  antlr.Token
	lockValue      antlr.Token
	lockTimeUint   antlr.Token
}

func NewEmptyPasswordOptionContext() *PasswordOptionContext {
	var p = new(PasswordOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_passwordOption
	return p
}

func InitEmptyPasswordOptionContext(p *PasswordOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_passwordOption
}

func (*PasswordOptionContext) IsPasswordOptionContext() {}

func NewPasswordOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PasswordOptionContext {
	var p = new(PasswordOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_passwordOption

	return p
}

func (s *PasswordOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *PasswordOptionContext) GetHistoryDefault() antlr.Token { return s.historyDefault }

func (s *PasswordOptionContext) GetHistoryValue() antlr.Token { return s.historyValue }

func (s *PasswordOptionContext) GetExpireDefault() antlr.Token { return s.expireDefault }

func (s *PasswordOptionContext) GetExpireNever() antlr.Token { return s.expireNever }

func (s *PasswordOptionContext) GetExpireValue() antlr.Token { return s.expireValue }

func (s *PasswordOptionContext) GetExpireTimeUnit() antlr.Token { return s.expireTimeUnit }

func (s *PasswordOptionContext) GetReuseDefault() antlr.Token { return s.reuseDefault }

func (s *PasswordOptionContext) GetReuseValue() antlr.Token { return s.reuseValue }

func (s *PasswordOptionContext) GetAttemptsValue() antlr.Token { return s.attemptsValue }

func (s *PasswordOptionContext) GetLockUnbounded() antlr.Token { return s.lockUnbounded }

func (s *PasswordOptionContext) GetLockValue() antlr.Token { return s.lockValue }

func (s *PasswordOptionContext) GetLockTimeUint() antlr.Token { return s.lockTimeUint }

func (s *PasswordOptionContext) SetHistoryDefault(v antlr.Token) { s.historyDefault = v }

func (s *PasswordOptionContext) SetHistoryValue(v antlr.Token) { s.historyValue = v }

func (s *PasswordOptionContext) SetExpireDefault(v antlr.Token) { s.expireDefault = v }

func (s *PasswordOptionContext) SetExpireNever(v antlr.Token) { s.expireNever = v }

func (s *PasswordOptionContext) SetExpireValue(v antlr.Token) { s.expireValue = v }

func (s *PasswordOptionContext) SetExpireTimeUnit(v antlr.Token) { s.expireTimeUnit = v }

func (s *PasswordOptionContext) SetReuseDefault(v antlr.Token) { s.reuseDefault = v }

func (s *PasswordOptionContext) SetReuseValue(v antlr.Token) { s.reuseValue = v }

func (s *PasswordOptionContext) SetAttemptsValue(v antlr.Token) { s.attemptsValue = v }

func (s *PasswordOptionContext) SetLockUnbounded(v antlr.Token) { s.lockUnbounded = v }

func (s *PasswordOptionContext) SetLockValue(v antlr.Token) { s.lockValue = v }

func (s *PasswordOptionContext) SetLockTimeUint(v antlr.Token) { s.lockTimeUint = v }

func (s *PasswordOptionContext) PASSWORD_HISTORY() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD_HISTORY, 0)
}

func (s *PasswordOptionContext) PASSWORD_EXPIRE() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD_EXPIRE, 0)
}

func (s *PasswordOptionContext) PASSWORD_REUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD_REUSE, 0)
}

func (s *PasswordOptionContext) AllINTERVAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserINTERVAL)
}

func (s *PasswordOptionContext) INTERVAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserINTERVAL, i)
}

func (s *PasswordOptionContext) FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode {
	return s.GetToken(DorisParserFAILED_LOGIN_ATTEMPTS, 0)
}

func (s *PasswordOptionContext) PASSWORD_LOCK_TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD_LOCK_TIME, 0)
}

func (s *PasswordOptionContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserINTEGER_VALUE)
}

func (s *PasswordOptionContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, i)
}

func (s *PasswordOptionContext) ACCOUNT_LOCK() antlr.TerminalNode {
	return s.GetToken(DorisParserACCOUNT_LOCK, 0)
}

func (s *PasswordOptionContext) ACCOUNT_UNLOCK() antlr.TerminalNode {
	return s.GetToken(DorisParserACCOUNT_UNLOCK, 0)
}

func (s *PasswordOptionContext) AllDAY() []antlr.TerminalNode {
	return s.GetTokens(DorisParserDAY)
}

func (s *PasswordOptionContext) DAY(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserDAY, i)
}

func (s *PasswordOptionContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(DorisParserDEFAULT)
}

func (s *PasswordOptionContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, i)
}

func (s *PasswordOptionContext) NEVER() antlr.TerminalNode {
	return s.GetToken(DorisParserNEVER, 0)
}

func (s *PasswordOptionContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(DorisParserUNBOUNDED, 0)
}

func (s *PasswordOptionContext) AllHOUR() []antlr.TerminalNode {
	return s.GetTokens(DorisParserHOUR)
}

func (s *PasswordOptionContext) HOUR(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserHOUR, i)
}

func (s *PasswordOptionContext) AllSECOND() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSECOND)
}

func (s *PasswordOptionContext) SECOND(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSECOND, i)
}

func (s *PasswordOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PasswordOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPasswordOption(s)
	}
}

func (s *PasswordOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPasswordOption(s)
	}
}

func (p *DorisParser) PasswordOption() (localctx IPasswordOptionContext) {
	localctx = NewPasswordOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, DorisParserRULE_passwordOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3900)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPASSWORD_HISTORY {
		{
			p.SetState(3895)
			p.Match(DorisParserPASSWORD_HISTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3898)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserDEFAULT:
			{
				p.SetState(3896)

				var _m = p.Match(DorisParserDEFAULT)

				localctx.(*PasswordOptionContext).historyDefault = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserINTEGER_VALUE:
			{
				p.SetState(3897)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*PasswordOptionContext).historyValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(3910)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPASSWORD_EXPIRE {
		{
			p.SetState(3902)
			p.Match(DorisParserPASSWORD_EXPIRE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3908)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserDEFAULT:
			{
				p.SetState(3903)

				var _m = p.Match(DorisParserDEFAULT)

				localctx.(*PasswordOptionContext).expireDefault = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserNEVER:
			{
				p.SetState(3904)

				var _m = p.Match(DorisParserNEVER)

				localctx.(*PasswordOptionContext).expireNever = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserINTERVAL:
			{
				p.SetState(3905)
				p.Match(DorisParserINTERVAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3906)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*PasswordOptionContext).expireValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3907)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*PasswordOptionContext).expireTimeUnit = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserDAY || _la == DorisParserHOUR || _la == DorisParserSECOND) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*PasswordOptionContext).expireTimeUnit = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(3919)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPASSWORD_REUSE {
		{
			p.SetState(3912)
			p.Match(DorisParserPASSWORD_REUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3913)
			p.Match(DorisParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3917)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserDEFAULT:
			{
				p.SetState(3914)

				var _m = p.Match(DorisParserDEFAULT)

				localctx.(*PasswordOptionContext).reuseDefault = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserINTEGER_VALUE:
			{
				p.SetState(3915)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*PasswordOptionContext).reuseValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3916)
				p.Match(DorisParserDAY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(3923)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserFAILED_LOGIN_ATTEMPTS {
		{
			p.SetState(3921)
			p.Match(DorisParserFAILED_LOGIN_ATTEMPTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3922)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*PasswordOptionContext).attemptsValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3931)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPASSWORD_LOCK_TIME {
		{
			p.SetState(3925)
			p.Match(DorisParserPASSWORD_LOCK_TIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3929)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserUNBOUNDED:
			{
				p.SetState(3926)

				var _m = p.Match(DorisParserUNBOUNDED)

				localctx.(*PasswordOptionContext).lockUnbounded = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserINTEGER_VALUE:
			{
				p.SetState(3927)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*PasswordOptionContext).lockValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3928)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*PasswordOptionContext).lockTimeUint = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserDAY || _la == DorisParserHOUR || _la == DorisParserSECOND) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*PasswordOptionContext).lockTimeUint = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(3934)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserACCOUNT_LOCK || _la == DorisParserACCOUNT_UNLOCK {
		{
			p.SetState(3933)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserACCOUNT_LOCK || _la == DorisParserACCOUNT_UNLOCK) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionArgumentsContext is an interface to support dynamic dispatch.
type IFunctionArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFunctionArgument() []IFunctionArgumentContext
	FunctionArgument(i int) IFunctionArgumentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFunctionArgumentsContext differentiates from other interfaces.
	IsFunctionArgumentsContext()
}

type FunctionArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionArgumentsContext() *FunctionArgumentsContext {
	var p = new(FunctionArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionArguments
	return p
}

func InitEmptyFunctionArgumentsContext(p *FunctionArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionArguments
}

func (*FunctionArgumentsContext) IsFunctionArgumentsContext() {}

func NewFunctionArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgumentsContext {
	var p = new(FunctionArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_functionArguments

	return p
}

func (s *FunctionArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgumentsContext) AllFunctionArgument() []IFunctionArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionArgumentContext); ok {
			len++
		}
	}

	tst := make([]IFunctionArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionArgumentContext); ok {
			tst[i] = t.(IFunctionArgumentContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgumentsContext) FunctionArgument(i int) IFunctionArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgumentContext)
}

func (s *FunctionArgumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *FunctionArgumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *FunctionArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFunctionArguments(s)
	}
}

func (s *FunctionArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFunctionArguments(s)
	}
}

func (p *DorisParser) FunctionArguments() (localctx IFunctionArgumentsContext) {
	localctx = NewFunctionArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, DorisParserRULE_functionArguments)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3936)
		p.FunctionArgument()
	}
	p.SetState(3941)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(3937)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3938)
			p.FunctionArgument()
		}

		p.SetState(3943)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionArgumentContext is an interface to support dynamic dispatch.
type IFunctionArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOTDOTDOT() antlr.TerminalNode
	DataType() IDataTypeContext

	// IsFunctionArgumentContext differentiates from other interfaces.
	IsFunctionArgumentContext()
}

type FunctionArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionArgumentContext() *FunctionArgumentContext {
	var p = new(FunctionArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionArgument
	return p
}

func InitEmptyFunctionArgumentContext(p *FunctionArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionArgument
}

func (*FunctionArgumentContext) IsFunctionArgumentContext() {}

func NewFunctionArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgumentContext {
	var p = new(FunctionArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_functionArgument

	return p
}

func (s *FunctionArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgumentContext) DOTDOTDOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOTDOTDOT, 0)
}

func (s *FunctionArgumentContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *FunctionArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFunctionArgument(s)
	}
}

func (s *FunctionArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFunctionArgument(s)
	}
}

func (p *DorisParser) FunctionArgument() (localctx IFunctionArgumentContext) {
	localctx = NewFunctionArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, DorisParserRULE_functionArgument)
	p.SetState(3946)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserDOTDOTDOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3944)
			p.Match(DorisParserDOTDOTDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserAGG_STATE, DorisParserALL, DorisParserARRAY, DorisParserBIGINT, DorisParserBITMAP, DorisParserBOOLEAN, DorisParserCHAR, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDOUBLE, DorisParserFLOAT, DorisParserHLL, DorisParserINT, DorisParserINTEGER, DorisParserIPV4, DorisParserIPV6, DorisParserJSON, DorisParserJSONB, DorisParserLARGEINT, DorisParserMAP, DorisParserQUANTILE_STATE, DorisParserSMALLINT, DorisParserSTRING, DorisParserSTRUCT, DorisParserTEXT, DorisParserTIME, DorisParserTINYINT, DorisParserVARCHAR, DorisParserVARIANT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3945)
			p.DataType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedSetStatementContext is an interface to support dynamic dispatch.
type ISupportedSetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedSetStatementContext differentiates from other interfaces.
	IsSupportedSetStatementContext()
}

type SupportedSetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedSetStatementContext() *SupportedSetStatementContext {
	var p = new(SupportedSetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedSetStatement
	return p
}

func InitEmptySupportedSetStatementContext(p *SupportedSetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedSetStatement
}

func (*SupportedSetStatementContext) IsSupportedSetStatementContext() {}

func NewSupportedSetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedSetStatementContext {
	var p = new(SupportedSetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedSetStatement

	return p
}

func (s *SupportedSetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedSetStatementContext) CopyAll(ctx *SupportedSetStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedSetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedSetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SetTransactionContext struct {
	SupportedSetStatementContext
}

func NewSetTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetTransactionContext {
	var p = new(SetTransactionContext)

	InitEmptySupportedSetStatementContext(&p.SupportedSetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedSetStatementContext))

	return p
}

func (s *SetTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTransactionContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *SetTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisParserTRANSACTION, 0)
}

func (s *SetTransactionContext) TransactionAccessMode() ITransactionAccessModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionAccessModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionAccessModeContext)
}

func (s *SetTransactionContext) IsolationLevel() IIsolationLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsolationLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsolationLevelContext)
}

func (s *SetTransactionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, 0)
}

func (s *SetTransactionContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *SetTransactionContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *SetTransactionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION, 0)
}

func (s *SetTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetTransaction(s)
	}
}

func (s *SetTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetTransaction(s)
	}
}

type SetUserPropertiesContext struct {
	SupportedSetStatementContext
	user IIdentifierOrTextContext
}

func NewSetUserPropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetUserPropertiesContext {
	var p = new(SetUserPropertiesContext)

	InitEmptySupportedSetStatementContext(&p.SupportedSetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedSetStatementContext))

	return p
}

func (s *SetUserPropertiesContext) GetUser() IIdentifierOrTextContext { return s.user }

func (s *SetUserPropertiesContext) SetUser(v IIdentifierOrTextContext) { s.user = v }

func (s *SetUserPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetUserPropertiesContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *SetUserPropertiesContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTY, 0)
}

func (s *SetUserPropertiesContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *SetUserPropertiesContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *SetUserPropertiesContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *SetUserPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetUserProperties(s)
	}
}

func (s *SetUserPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetUserProperties(s)
	}
}

type SetDefaultStorageVaultContext struct {
	SupportedSetStatementContext
}

func NewSetDefaultStorageVaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetDefaultStorageVaultContext {
	var p = new(SetDefaultStorageVaultContext)

	InitEmptySupportedSetStatementContext(&p.SupportedSetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedSetStatementContext))

	return p
}

func (s *SetDefaultStorageVaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetDefaultStorageVaultContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *SetDefaultStorageVaultContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetDefaultStorageVaultContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *SetDefaultStorageVaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *SetDefaultStorageVaultContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *SetDefaultStorageVaultContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULT, 0)
}

func (s *SetDefaultStorageVaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetDefaultStorageVault(s)
	}
}

func (s *SetDefaultStorageVaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetDefaultStorageVault(s)
	}
}

type SetOptionsContext struct {
	SupportedSetStatementContext
}

func NewSetOptionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetOptionsContext {
	var p = new(SetOptionsContext)

	InitEmptySupportedSetStatementContext(&p.SupportedSetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedSetStatementContext))

	return p
}

func (s *SetOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOptionsContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *SetOptionsContext) AllOptionWithType() []IOptionWithTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOptionWithTypeContext); ok {
			len++
		}
	}

	tst := make([]IOptionWithTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOptionWithTypeContext); ok {
			tst[i] = t.(IOptionWithTypeContext)
			i++
		}
	}

	return tst
}

func (s *SetOptionsContext) OptionWithType(i int) IOptionWithTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionWithTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionWithTypeContext)
}

func (s *SetOptionsContext) AllOptionWithoutType() []IOptionWithoutTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOptionWithoutTypeContext); ok {
			len++
		}
	}

	tst := make([]IOptionWithoutTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOptionWithoutTypeContext); ok {
			tst[i] = t.(IOptionWithoutTypeContext)
			i++
		}
	}

	return tst
}

func (s *SetOptionsContext) OptionWithoutType(i int) IOptionWithoutTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionWithoutTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionWithoutTypeContext)
}

func (s *SetOptionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *SetOptionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *SetOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetOptions(s)
	}
}

func (s *SetOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetOptions(s)
	}
}

func (p *DorisParser) SupportedSetStatement() (localctx ISupportedSetStatementContext) {
	localctx = NewSupportedSetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, DorisParserRULE_supportedSetStatement)
	var _la int

	p.SetState(3994)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 561, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSetOptionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3948)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3951)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 555, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3949)
				p.OptionWithType()
			}

		case 2:
			{
				p.SetState(3950)
				p.OptionWithoutType()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(3960)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(3953)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3956)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 556, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(3954)
					p.OptionWithType()
				}

			case 2:
				{
					p.SetState(3955)
					p.OptionWithoutType()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

			p.SetState(3962)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewSetDefaultStorageVaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3963)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3964)
			p.Identifier()
		}
		{
			p.SetState(3965)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3966)
			p.Match(DorisParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3967)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3968)
			p.Match(DorisParserVAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewSetUserPropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3970)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3971)
			p.Match(DorisParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3974)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFOR {
			{
				p.SetState(3972)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3973)

				var _x = p.IdentifierOrText()

				localctx.(*SetUserPropertiesContext).user = _x
			}

		}
		{
			p.SetState(3976)
			p.PropertyItemList()
		}

	case 4:
		localctx = NewSetTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3977)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3979)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION {
			{
				p.SetState(3978)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(3981)
			p.Match(DorisParserTRANSACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3992)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 560, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3982)
				p.TransactionAccessMode()
			}

		case 2:
			{
				p.SetState(3983)
				p.IsolationLevel()
			}

		case 3:
			{
				p.SetState(3984)
				p.TransactionAccessMode()
			}
			{
				p.SetState(3985)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3986)
				p.IsolationLevel()
			}

		case 4:
			{
				p.SetState(3988)
				p.IsolationLevel()
			}
			{
				p.SetState(3989)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3990)
				p.TransactionAccessMode()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionWithTypeContext is an interface to support dynamic dispatch.
type IOptionWithTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsOptionWithTypeContext differentiates from other interfaces.
	IsOptionWithTypeContext()
}

type OptionWithTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionWithTypeContext() *OptionWithTypeContext {
	var p = new(OptionWithTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_optionWithType
	return p
}

func InitEmptyOptionWithTypeContext(p *OptionWithTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_optionWithType
}

func (*OptionWithTypeContext) IsOptionWithTypeContext() {}

func NewOptionWithTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionWithTypeContext {
	var p = new(OptionWithTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_optionWithType

	return p
}

func (s *OptionWithTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionWithTypeContext) CopyAll(ctx *OptionWithTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *OptionWithTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionWithTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SetVariableWithTypeContext struct {
	OptionWithTypeContext
}

func NewSetVariableWithTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetVariableWithTypeContext {
	var p = new(SetVariableWithTypeContext)

	InitEmptyOptionWithTypeContext(&p.OptionWithTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithTypeContext))

	return p
}

func (s *SetVariableWithTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetVariableWithTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetVariableWithTypeContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *SetVariableWithTypeContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *SetVariableWithTypeContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *SetVariableWithTypeContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION, 0)
}

func (s *SetVariableWithTypeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetVariableWithTypeContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *SetVariableWithTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetVariableWithType(s)
	}
}

func (s *SetVariableWithTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetVariableWithType(s)
	}
}

func (p *DorisParser) OptionWithType() (localctx IOptionWithTypeContext) {
	localctx = NewOptionWithTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, DorisParserRULE_optionWithType)
	var _la int

	localctx = NewSetVariableWithTypeContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3996)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3997)
		p.Identifier()
	}
	{
		p.SetState(3998)
		p.Match(DorisParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4001)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_PAREN, DorisParserLEFT_BRACKET, DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADD, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBINARY, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCASE, DorisParserCAST, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATABASE, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXISTS, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserEXTRACT, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFALSE, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIF, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINTERVAL, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserKEY, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLEFT, DorisParserLESS, DorisParserLEVEL, DorisParserLIKE, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNOT, DorisParserNULL, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLACEHOLDER, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREGEXP, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRIGHT, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRIM, DorisParserTRUE, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserPLUS, DorisParserSUBTRACT, DorisParserASTERISK, DorisParserTILDE, DorisParserLOGICALNOT, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserATSIGN, DorisParserDOUBLEATSIGN, DorisParserSTRING_LITERAL, DorisParserINTEGER_VALUE, DorisParserEXPONENT_VALUE, DorisParserDECIMAL_VALUE, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		{
			p.SetState(3999)
			p.Expression()
		}

	case DorisParserDEFAULT:
		{
			p.SetState(4000)
			p.Match(DorisParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionWithoutTypeContext is an interface to support dynamic dispatch.
type IOptionWithoutTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsOptionWithoutTypeContext differentiates from other interfaces.
	IsOptionWithoutTypeContext()
}

type OptionWithoutTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionWithoutTypeContext() *OptionWithoutTypeContext {
	var p = new(OptionWithoutTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_optionWithoutType
	return p
}

func InitEmptyOptionWithoutTypeContext(p *OptionWithoutTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_optionWithoutType
}

func (*OptionWithoutTypeContext) IsOptionWithoutTypeContext() {}

func NewOptionWithoutTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionWithoutTypeContext {
	var p = new(OptionWithoutTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_optionWithoutType

	return p
}

func (s *OptionWithoutTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionWithoutTypeContext) CopyAll(ctx *OptionWithoutTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *OptionWithoutTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionWithoutTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SetNamesContext struct {
	OptionWithoutTypeContext
}

func NewSetNamesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetNamesContext {
	var p = new(SetNamesContext)

	InitEmptyOptionWithoutTypeContext(&p.OptionWithoutTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithoutTypeContext))

	return p
}

func (s *SetNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetNamesContext) NAMES() antlr.TerminalNode {
	return s.GetToken(DorisParserNAMES, 0)
}

func (s *SetNamesContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *SetNamesContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetNames(s)
	}
}

func (s *SetNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetNames(s)
	}
}

type SetCharsetContext struct {
	OptionWithoutTypeContext
	charsetName IIdentifierOrTextContext
}

func NewSetCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetCharsetContext {
	var p = new(SetCharsetContext)

	InitEmptyOptionWithoutTypeContext(&p.OptionWithoutTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithoutTypeContext))

	return p
}

func (s *SetCharsetContext) GetCharsetName() IIdentifierOrTextContext { return s.charsetName }

func (s *SetCharsetContext) SetCharsetName(v IIdentifierOrTextContext) { s.charsetName = v }

func (s *SetCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetCharsetContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserCHAR, 0)
}

func (s *SetCharsetContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *SetCharsetContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(DorisParserCHARSET, 0)
}

func (s *SetCharsetContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *SetCharsetContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *SetCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetCharset(s)
	}
}

func (s *SetCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetCharset(s)
	}
}

type SetCollateContext struct {
	OptionWithoutTypeContext
	charsetName IIdentifierOrTextContext
	collateName IIdentifierOrTextContext
}

func NewSetCollateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetCollateContext {
	var p = new(SetCollateContext)

	InitEmptyOptionWithoutTypeContext(&p.OptionWithoutTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithoutTypeContext))

	return p
}

func (s *SetCollateContext) GetCharsetName() IIdentifierOrTextContext { return s.charsetName }

func (s *SetCollateContext) GetCollateName() IIdentifierOrTextContext { return s.collateName }

func (s *SetCollateContext) SetCharsetName(v IIdentifierOrTextContext) { s.charsetName = v }

func (s *SetCollateContext) SetCollateName(v IIdentifierOrTextContext) { s.collateName = v }

func (s *SetCollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetCollateContext) NAMES() antlr.TerminalNode {
	return s.GetToken(DorisParserNAMES, 0)
}

func (s *SetCollateContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(DorisParserDEFAULT)
}

func (s *SetCollateContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, i)
}

func (s *SetCollateContext) AllIdentifierOrText() []IIdentifierOrTextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrTextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrTextContext); ok {
			tst[i] = t.(IIdentifierOrTextContext)
			i++
		}
	}

	return tst
}

func (s *SetCollateContext) IdentifierOrText(i int) IIdentifierOrTextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *SetCollateContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLLATE, 0)
}

func (s *SetCollateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetCollate(s)
	}
}

func (s *SetCollateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetCollate(s)
	}
}

type SetPasswordContext struct {
	OptionWithoutTypeContext
	isPlain antlr.Token
}

func NewSetPasswordContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetPasswordContext {
	var p = new(SetPasswordContext)

	InitEmptyOptionWithoutTypeContext(&p.OptionWithoutTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithoutTypeContext))

	return p
}

func (s *SetPasswordContext) GetIsPlain() antlr.Token { return s.isPlain }

func (s *SetPasswordContext) SetIsPlain(v antlr.Token) { s.isPlain = v }

func (s *SetPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetPasswordContext) AllPASSWORD() []antlr.TerminalNode {
	return s.GetTokens(DorisParserPASSWORD)
}

func (s *SetPasswordContext) PASSWORD(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD, i)
}

func (s *SetPasswordContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *SetPasswordContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *SetPasswordContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *SetPasswordContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *SetPasswordContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *SetPasswordContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *SetPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetPassword(s)
	}
}

func (s *SetPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetPassword(s)
	}
}

type SetVariableWithoutTypeContext struct {
	OptionWithoutTypeContext
}

func NewSetVariableWithoutTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetVariableWithoutTypeContext {
	var p = new(SetVariableWithoutTypeContext)

	InitEmptyOptionWithoutTypeContext(&p.OptionWithoutTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithoutTypeContext))

	return p
}

func (s *SetVariableWithoutTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetVariableWithoutTypeContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *SetVariableWithoutTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetVariableWithoutType(s)
	}
}

func (s *SetVariableWithoutTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetVariableWithoutType(s)
	}
}

type SetLdapAdminPasswordContext struct {
	OptionWithoutTypeContext
}

func NewSetLdapAdminPasswordContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetLdapAdminPasswordContext {
	var p = new(SetLdapAdminPasswordContext)

	InitEmptyOptionWithoutTypeContext(&p.OptionWithoutTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithoutTypeContext))

	return p
}

func (s *SetLdapAdminPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetLdapAdminPasswordContext) LDAP_ADMIN_PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisParserLDAP_ADMIN_PASSWORD, 0)
}

func (s *SetLdapAdminPasswordContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *SetLdapAdminPasswordContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *SetLdapAdminPasswordContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD, 0)
}

func (s *SetLdapAdminPasswordContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *SetLdapAdminPasswordContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *SetLdapAdminPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetLdapAdminPassword(s)
	}
}

func (s *SetLdapAdminPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetLdapAdminPassword(s)
	}
}

func (p *DorisParser) OptionWithoutType() (localctx IOptionWithoutTypeContext) {
	localctx = NewOptionWithoutTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, DorisParserRULE_optionWithoutType)
	var _la int

	p.SetState(4048)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 570, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSetNamesContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4003)
			p.Match(DorisParserNAMES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4004)
			p.Match(DorisParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4005)
			p.Expression()
		}

	case 2:
		localctx = NewSetCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4009)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserCHAR:
			{
				p.SetState(4006)
				p.Match(DorisParserCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4007)
				p.Match(DorisParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCHARSET:
			{
				p.SetState(4008)
				p.Match(DorisParserCHARSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(4013)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(4011)

				var _x = p.IdentifierOrText()

				localctx.(*SetCharsetContext).charsetName = _x
			}

		case DorisParserDEFAULT:
			{
				p.SetState(4012)
				p.Match(DorisParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		localctx = NewSetCollateContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4015)
			p.Match(DorisParserNAMES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4018)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(4016)

				var _x = p.IdentifierOrText()

				localctx.(*SetCollateContext).charsetName = _x
			}

		case DorisParserDEFAULT:
			{
				p.SetState(4017)
				p.Match(DorisParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(4023)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case DorisParserCOLLATE:
			{
				p.SetState(4020)
				p.Match(DorisParserCOLLATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4021)

				var _x = p.IdentifierOrText()

				localctx.(*SetCollateContext).collateName = _x
			}

		case DorisParserDEFAULT:
			{
				p.SetState(4022)
				p.Match(DorisParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserEOF, DorisParserSEMICOLON, DorisParserCOMMA:

		default:
		}

	case 4:
		localctx = NewSetPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4025)
			p.Match(DorisParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4028)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFOR {
			{
				p.SetState(4026)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4027)
				p.UserIdentify()
			}

		}
		{
			p.SetState(4030)
			p.Match(DorisParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4036)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserSTRING_LITERAL:
			{
				p.SetState(4031)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserPASSWORD:
			{
				p.SetState(4032)

				var _m = p.Match(DorisParserPASSWORD)

				localctx.(*SetPasswordContext).isPlain = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4033)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4034)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4035)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 5:
		localctx = NewSetLdapAdminPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4038)
			p.Match(DorisParserLDAP_ADMIN_PASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4039)
			p.Match(DorisParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4045)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserSTRING_LITERAL:
			{
				p.SetState(4040)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserPASSWORD:
			{
				p.SetState(4041)
				p.Match(DorisParserPASSWORD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4042)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4043)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4044)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 6:
		localctx = NewSetVariableWithoutTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4047)
			p.Variable()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableContext is an interface to support dynamic dispatch.
type IVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsVariableContext differentiates from other interfaces.
	IsVariableContext()
}

type VariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableContext() *VariableContext {
	var p = new(VariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_variable
	return p
}

func InitEmptyVariableContext(p *VariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_variable
}

func (*VariableContext) IsVariableContext() {}

func NewVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableContext {
	var p = new(VariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_variable

	return p
}

func (s *VariableContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableContext) CopyAll(ctx *VariableContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *VariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SetUserVariableContext struct {
	VariableContext
}

func NewSetUserVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetUserVariableContext {
	var p = new(SetUserVariableContext)

	InitEmptyVariableContext(&p.VariableContext)
	p.parser = parser
	p.CopyAll(ctx.(*VariableContext))

	return p
}

func (s *SetUserVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetUserVariableContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserATSIGN, 0)
}

func (s *SetUserVariableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetUserVariableContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *SetUserVariableContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetUserVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetUserVariable(s)
	}
}

func (s *SetUserVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetUserVariable(s)
	}
}

type SetSystemVariableContext struct {
	VariableContext
}

func NewSetSystemVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetSystemVariableContext {
	var p = new(SetSystemVariableContext)

	InitEmptyVariableContext(&p.VariableContext)
	p.parser = parser
	p.CopyAll(ctx.(*VariableContext))

	return p
}

func (s *SetSystemVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetSystemVariableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetSystemVariableContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *SetSystemVariableContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetSystemVariableContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *SetSystemVariableContext) DOUBLEATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserDOUBLEATSIGN, 0)
}

func (s *SetSystemVariableContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *SetSystemVariableContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *SetSystemVariableContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *SetSystemVariableContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION, 0)
}

func (s *SetSystemVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetSystemVariable(s)
	}
}

func (s *SetSystemVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetSystemVariable(s)
	}
}

func (p *DorisParser) Variable() (localctx IVariableContext) {
	localctx = NewVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, DorisParserRULE_variable)
	var _la int

	p.SetState(4068)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserDOUBLEATSIGN, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		localctx = NewSetSystemVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4055)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserDOUBLEATSIGN {
			{
				p.SetState(4050)
				p.Match(DorisParserDOUBLEATSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(4053)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 571, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(4051)
					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(4052)
					p.Match(DorisParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}
		{
			p.SetState(4057)
			p.Identifier()
		}
		{
			p.SetState(4058)
			p.Match(DorisParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4061)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_PAREN, DorisParserLEFT_BRACKET, DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADD, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBINARY, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCASE, DorisParserCAST, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATABASE, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXISTS, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserEXTRACT, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFALSE, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIF, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINTERVAL, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserKEY, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLEFT, DorisParserLESS, DorisParserLEVEL, DorisParserLIKE, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNOT, DorisParserNULL, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLACEHOLDER, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREGEXP, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRIGHT, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRIM, DorisParserTRUE, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserPLUS, DorisParserSUBTRACT, DorisParserASTERISK, DorisParserTILDE, DorisParserLOGICALNOT, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserATSIGN, DorisParserDOUBLEATSIGN, DorisParserSTRING_LITERAL, DorisParserINTEGER_VALUE, DorisParserEXPONENT_VALUE, DorisParserDECIMAL_VALUE, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(4059)
				p.Expression()
			}

		case DorisParserDEFAULT:
			{
				p.SetState(4060)
				p.Match(DorisParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case DorisParserATSIGN:
		localctx = NewSetUserVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4063)
			p.Match(DorisParserATSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4064)
			p.Identifier()
		}
		{
			p.SetState(4065)
			p.Match(DorisParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4066)
			p.Expression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionAccessModeContext is an interface to support dynamic dispatch.
type ITransactionAccessModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	WRITE() antlr.TerminalNode

	// IsTransactionAccessModeContext differentiates from other interfaces.
	IsTransactionAccessModeContext()
}

type TransactionAccessModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionAccessModeContext() *TransactionAccessModeContext {
	var p = new(TransactionAccessModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_transactionAccessMode
	return p
}

func InitEmptyTransactionAccessModeContext(p *TransactionAccessModeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_transactionAccessMode
}

func (*TransactionAccessModeContext) IsTransactionAccessModeContext() {}

func NewTransactionAccessModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionAccessModeContext {
	var p = new(TransactionAccessModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_transactionAccessMode

	return p
}

func (s *TransactionAccessModeContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionAccessModeContext) READ() antlr.TerminalNode {
	return s.GetToken(DorisParserREAD, 0)
}

func (s *TransactionAccessModeContext) ONLY() antlr.TerminalNode {
	return s.GetToken(DorisParserONLY, 0)
}

func (s *TransactionAccessModeContext) WRITE() antlr.TerminalNode {
	return s.GetToken(DorisParserWRITE, 0)
}

func (s *TransactionAccessModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionAccessModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionAccessModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTransactionAccessMode(s)
	}
}

func (s *TransactionAccessModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTransactionAccessMode(s)
	}
}

func (p *DorisParser) TransactionAccessMode() (localctx ITransactionAccessModeContext) {
	localctx = NewTransactionAccessModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, DorisParserRULE_transactionAccessMode)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4070)
		p.Match(DorisParserREAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4071)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserONLY || _la == DorisParserWRITE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIsolationLevelContext is an interface to support dynamic dispatch.
type IIsolationLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ISOLATION() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	READ() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	REPEATABLE() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode

	// IsIsolationLevelContext differentiates from other interfaces.
	IsIsolationLevelContext()
}

type IsolationLevelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsolationLevelContext() *IsolationLevelContext {
	var p = new(IsolationLevelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_isolationLevel
	return p
}

func InitEmptyIsolationLevelContext(p *IsolationLevelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_isolationLevel
}

func (*IsolationLevelContext) IsIsolationLevelContext() {}

func NewIsolationLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IsolationLevelContext {
	var p = new(IsolationLevelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_isolationLevel

	return p
}

func (s *IsolationLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *IsolationLevelContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(DorisParserISOLATION, 0)
}

func (s *IsolationLevelContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(DorisParserLEVEL, 0)
}

func (s *IsolationLevelContext) READ() antlr.TerminalNode {
	return s.GetToken(DorisParserREAD, 0)
}

func (s *IsolationLevelContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(DorisParserUNCOMMITTED, 0)
}

func (s *IsolationLevelContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMITTED, 0)
}

func (s *IsolationLevelContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPEATABLE, 0)
}

func (s *IsolationLevelContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserSERIALIZABLE, 0)
}

func (s *IsolationLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsolationLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IsolationLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIsolationLevel(s)
	}
}

func (s *IsolationLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIsolationLevel(s)
	}
}

func (p *DorisParser) IsolationLevel() (localctx IIsolationLevelContext) {
	localctx = NewIsolationLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, DorisParserRULE_isolationLevel)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4073)
		p.Match(DorisParserISOLATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4074)
		p.Match(DorisParserLEVEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4082)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 575, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4075)
			p.Match(DorisParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4076)
			p.Match(DorisParserUNCOMMITTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(4077)
			p.Match(DorisParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4078)
			p.Match(DorisParserCOMMITTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(4079)
			p.Match(DorisParserREPEATABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4080)
			p.Match(DorisParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(4081)
			p.Match(DorisParserSERIALIZABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedUnsetStatementContext is an interface to support dynamic dispatch.
type ISupportedUnsetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNSET() antlr.TerminalNode
	VARIABLE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	Identifier() IIdentifierContext
	GLOBAL() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VAULT() antlr.TerminalNode

	// IsSupportedUnsetStatementContext differentiates from other interfaces.
	IsSupportedUnsetStatementContext()
}

type SupportedUnsetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedUnsetStatementContext() *SupportedUnsetStatementContext {
	var p = new(SupportedUnsetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedUnsetStatement
	return p
}

func InitEmptySupportedUnsetStatementContext(p *SupportedUnsetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedUnsetStatement
}

func (*SupportedUnsetStatementContext) IsSupportedUnsetStatementContext() {}

func NewSupportedUnsetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedUnsetStatementContext {
	var p = new(SupportedUnsetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedUnsetStatement

	return p
}

func (s *SupportedUnsetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedUnsetStatementContext) UNSET() antlr.TerminalNode {
	return s.GetToken(DorisParserUNSET, 0)
}

func (s *SupportedUnsetStatementContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserVARIABLE, 0)
}

func (s *SupportedUnsetStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *SupportedUnsetStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SupportedUnsetStatementContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *SupportedUnsetStatementContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION, 0)
}

func (s *SupportedUnsetStatementContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *SupportedUnsetStatementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *SupportedUnsetStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *SupportedUnsetStatementContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULT, 0)
}

func (s *SupportedUnsetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedUnsetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SupportedUnsetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedUnsetStatement(s)
	}
}

func (s *SupportedUnsetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedUnsetStatement(s)
	}
}

func (p *DorisParser) SupportedUnsetStatement() (localctx ISupportedUnsetStatementContext) {
	localctx = NewSupportedUnsetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, DorisParserRULE_supportedUnsetStatement)
	var _la int

	p.SetState(4097)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 578, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4084)
			p.Match(DorisParserUNSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4086)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION {
			{
				p.SetState(4085)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(4088)
			p.Match(DorisParserVARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4091)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserALL:
			{
				p.SetState(4089)
				p.Match(DorisParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(4090)
				p.Identifier()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4093)
			p.Match(DorisParserUNSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4094)
			p.Match(DorisParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4095)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4096)
			p.Match(DorisParserVAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedUseStatementContext is an interface to support dynamic dispatch.
type ISupportedUseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedUseStatementContext differentiates from other interfaces.
	IsSupportedUseStatementContext()
}

type SupportedUseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedUseStatementContext() *SupportedUseStatementContext {
	var p = new(SupportedUseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedUseStatement
	return p
}

func InitEmptySupportedUseStatementContext(p *SupportedUseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedUseStatement
}

func (*SupportedUseStatementContext) IsSupportedUseStatementContext() {}

func NewSupportedUseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedUseStatementContext {
	var p = new(SupportedUseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedUseStatement

	return p
}

func (s *SupportedUseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedUseStatementContext) CopyAll(ctx *SupportedUseStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedUseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedUseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UseDatabaseContext struct {
	SupportedUseStatementContext
	catalog  IIdentifierContext
	database IIdentifierContext
}

func NewUseDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UseDatabaseContext {
	var p = new(UseDatabaseContext)

	InitEmptySupportedUseStatementContext(&p.SupportedUseStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedUseStatementContext))

	return p
}

func (s *UseDatabaseContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *UseDatabaseContext) GetDatabase() IIdentifierContext { return s.database }

func (s *UseDatabaseContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *UseDatabaseContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *UseDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseDatabaseContext) USE() antlr.TerminalNode {
	return s.GetToken(DorisParserUSE, 0)
}

func (s *UseDatabaseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *UseDatabaseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UseDatabaseContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *UseDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUseDatabase(s)
	}
}

func (s *UseDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUseDatabase(s)
	}
}

type SwitchCatalogContext struct {
	SupportedUseStatementContext
	catalog IIdentifierContext
}

func NewSwitchCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SwitchCatalogContext {
	var p = new(SwitchCatalogContext)

	InitEmptySupportedUseStatementContext(&p.SupportedUseStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedUseStatementContext))

	return p
}

func (s *SwitchCatalogContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *SwitchCatalogContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *SwitchCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchCatalogContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(DorisParserSWITCH, 0)
}

func (s *SwitchCatalogContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SwitchCatalogContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSwitchCatalog(s)
	}
}

func (s *SwitchCatalogContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSwitchCatalog(s)
	}
}

func (p *DorisParser) SupportedUseStatement() (localctx ISupportedUseStatementContext) {
	localctx = NewSupportedUseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, DorisParserRULE_supportedUseStatement)
	p.SetState(4108)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserSWITCH:
		localctx = NewSwitchCatalogContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4099)
			p.Match(DorisParserSWITCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4100)

			var _x = p.Identifier()

			localctx.(*SwitchCatalogContext).catalog = _x
		}

	case DorisParserUSE:
		localctx = NewUseDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4101)
			p.Match(DorisParserUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4105)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 579, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4102)

				var _x = p.Identifier()

				localctx.(*UseDatabaseContext).catalog = _x
			}
			{
				p.SetState(4103)
				p.Match(DorisParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4107)

			var _x = p.Identifier()

			localctx.(*UseDatabaseContext).database = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedUseStatementContext is an interface to support dynamic dispatch.
type IUnsupportedUseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedUseStatementContext differentiates from other interfaces.
	IsUnsupportedUseStatementContext()
}

type UnsupportedUseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedUseStatementContext() *UnsupportedUseStatementContext {
	var p = new(UnsupportedUseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedUseStatement
	return p
}

func InitEmptyUnsupportedUseStatementContext(p *UnsupportedUseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedUseStatement
}

func (*UnsupportedUseStatementContext) IsUnsupportedUseStatementContext() {}

func NewUnsupportedUseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedUseStatementContext {
	var p = new(UnsupportedUseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedUseStatement

	return p
}

func (s *UnsupportedUseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedUseStatementContext) CopyAll(ctx *UnsupportedUseStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedUseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedUseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UseCloudClusterContext struct {
	UnsupportedUseStatementContext
	catalog  IIdentifierContext
	database IIdentifierContext
	cluster  IIdentifierContext
}

func NewUseCloudClusterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UseCloudClusterContext {
	var p = new(UseCloudClusterContext)

	InitEmptyUnsupportedUseStatementContext(&p.UnsupportedUseStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedUseStatementContext))

	return p
}

func (s *UseCloudClusterContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *UseCloudClusterContext) GetDatabase() IIdentifierContext { return s.database }

func (s *UseCloudClusterContext) GetCluster() IIdentifierContext { return s.cluster }

func (s *UseCloudClusterContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *UseCloudClusterContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *UseCloudClusterContext) SetCluster(v IIdentifierContext) { s.cluster = v }

func (s *UseCloudClusterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseCloudClusterContext) USE() antlr.TerminalNode {
	return s.GetToken(DorisParserUSE, 0)
}

func (s *UseCloudClusterContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserATSIGN, 0)
}

func (s *UseCloudClusterContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *UseCloudClusterContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UseCloudClusterContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *UseCloudClusterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUseCloudCluster(s)
	}
}

func (s *UseCloudClusterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUseCloudCluster(s)
	}
}

func (p *DorisParser) UnsupportedUseStatement() (localctx IUnsupportedUseStatementContext) {
	localctx = NewUnsupportedUseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, DorisParserRULE_unsupportedUseStatement)
	var _la int

	localctx = NewUseCloudClusterContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4110)
		p.Match(DorisParserUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4117)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8646881558152553984) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&3026312906716208575) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-6232424940973963725) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&3937129999880936915) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-2873958502894674957) != 0) || ((int64((_la-322)) & ^0x3f) == 0 && ((int64(1)<<(_la-322))&6912752233721878527) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&-2627780018309275847) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&150083289320141) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&49159) != 0) {
		p.SetState(4114)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 581, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4111)

				var _x = p.Identifier()

				localctx.(*UseCloudClusterContext).catalog = _x
			}
			{
				p.SetState(4112)
				p.Match(DorisParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4116)

			var _x = p.Identifier()

			localctx.(*UseCloudClusterContext).database = _x
		}

	}
	{
		p.SetState(4119)
		p.Match(DorisParserATSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4120)

		var _x = p.Identifier()

		localctx.(*UseCloudClusterContext).cluster = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedDmlStatementContext is an interface to support dynamic dispatch.
type IUnsupportedDmlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedDmlStatementContext differentiates from other interfaces.
	IsUnsupportedDmlStatementContext()
}

type UnsupportedDmlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedDmlStatementContext() *UnsupportedDmlStatementContext {
	var p = new(UnsupportedDmlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedDmlStatement
	return p
}

func InitEmptyUnsupportedDmlStatementContext(p *UnsupportedDmlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedDmlStatement
}

func (*UnsupportedDmlStatementContext) IsUnsupportedDmlStatementContext() {}

func NewUnsupportedDmlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedDmlStatementContext {
	var p = new(UnsupportedDmlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedDmlStatement

	return p
}

func (s *UnsupportedDmlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedDmlStatementContext) CopyAll(ctx *UnsupportedDmlStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedDmlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedDmlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CopyIntoContext struct {
	UnsupportedDmlStatementContext
	name       IMultipartIdentifierContext
	columns    IIdentifierListContext
	properties IPropertyClauseContext
}

func NewCopyIntoContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CopyIntoContext {
	var p = new(CopyIntoContext)

	InitEmptyUnsupportedDmlStatementContext(&p.UnsupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDmlStatementContext))

	return p
}

func (s *CopyIntoContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CopyIntoContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *CopyIntoContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CopyIntoContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CopyIntoContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *CopyIntoContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CopyIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CopyIntoContext) COPY() antlr.TerminalNode {
	return s.GetToken(DorisParserCOPY, 0)
}

func (s *CopyIntoContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserINTO, 0)
}

func (s *CopyIntoContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(DorisParserFROM)
}

func (s *CopyIntoContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, i)
}

func (s *CopyIntoContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CopyIntoContext) StageAndPattern() IStageAndPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStageAndPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStageAndPatternContext)
}

func (s *CopyIntoContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CopyIntoContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CopyIntoContext) SELECT() antlr.TerminalNode {
	return s.GetToken(DorisParserSELECT, 0)
}

func (s *CopyIntoContext) SelectColumnClause() ISelectColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectColumnClauseContext)
}

func (s *CopyIntoContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CopyIntoContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CopyIntoContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *CopyIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCopyInto(s)
	}
}

func (s *CopyIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCopyInto(s)
	}
}

type TruncateTableContext struct {
	UnsupportedDmlStatementContext
}

func NewTruncateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TruncateTableContext {
	var p = new(TruncateTableContext)

	InitEmptyUnsupportedDmlStatementContext(&p.UnsupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDmlStatementContext))

	return p
}

func (s *TruncateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncateTableContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(DorisParserTRUNCATE, 0)
}

func (s *TruncateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *TruncateTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *TruncateTableContext) SpecifiedPartition() ISpecifiedPartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecifiedPartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecifiedPartitionContext)
}

func (s *TruncateTableContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserFORCE, 0)
}

func (s *TruncateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTruncateTable(s)
	}
}

func (s *TruncateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTruncateTable(s)
	}
}

func (p *DorisParser) UnsupportedDmlStatement() (localctx IUnsupportedDmlStatementContext) {
	localctx = NewUnsupportedDmlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, DorisParserRULE_unsupportedDmlStatement)
	var _la int

	p.SetState(4154)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserTRUNCATE:
		localctx = NewTruncateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4122)
			p.Match(DorisParserTRUNCATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4123)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4124)
			p.MultipartIdentifier()
		}
		p.SetState(4126)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(4125)
				p.SpecifiedPartition()
			}

		}
		p.SetState(4129)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFORCE {
			{
				p.SetState(4128)
				p.Match(DorisParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DorisParserCOPY:
		localctx = NewCopyIntoContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4131)
			p.Match(DorisParserCOPY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4132)
			p.Match(DorisParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4133)

			var _x = p.MultipartIdentifier()

			localctx.(*CopyIntoContext).name = _x
		}
		p.SetState(4135)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(4134)

				var _x = p.IdentifierList()

				localctx.(*CopyIntoContext).columns = _x
			}

		}
		{
			p.SetState(4137)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4149)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserATSIGN:
			{
				p.SetState(4138)
				p.StageAndPattern()
			}

		case DorisParserLEFT_PAREN:
			{
				p.SetState(4139)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4140)
				p.Match(DorisParserSELECT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4141)
				p.SelectColumnClause()
			}
			{
				p.SetState(4142)
				p.Match(DorisParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4143)
				p.StageAndPattern()
			}
			p.SetState(4145)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserWHERE {
				{
					p.SetState(4144)
					p.WhereClause()
				}

			}
			{
				p.SetState(4147)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(4152)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(4151)

				var _x = p.PropertyClause()

				localctx.(*CopyIntoContext).properties = _x
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStageAndPatternContext is an interface to support dynamic dispatch.
type IStageAndPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern token.
	GetPattern() antlr.Token

	// SetPattern sets the pattern token.
	SetPattern(antlr.Token)

	// GetStage returns the stage rule contexts.
	GetStage() IIdentifierContext

	// SetStage sets the stage rule contexts.
	SetStage(IIdentifierContext)

	// Getter signatures
	ATSIGN() antlr.TerminalNode
	TILDE() antlr.TerminalNode
	Identifier() IIdentifierContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsStageAndPatternContext differentiates from other interfaces.
	IsStageAndPatternContext()
}

type StageAndPatternContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	stage   IIdentifierContext
	pattern antlr.Token
}

func NewEmptyStageAndPatternContext() *StageAndPatternContext {
	var p = new(StageAndPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_stageAndPattern
	return p
}

func InitEmptyStageAndPatternContext(p *StageAndPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_stageAndPattern
}

func (*StageAndPatternContext) IsStageAndPatternContext() {}

func NewStageAndPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StageAndPatternContext {
	var p = new(StageAndPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_stageAndPattern

	return p
}

func (s *StageAndPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *StageAndPatternContext) GetPattern() antlr.Token { return s.pattern }

func (s *StageAndPatternContext) SetPattern(v antlr.Token) { s.pattern = v }

func (s *StageAndPatternContext) GetStage() IIdentifierContext { return s.stage }

func (s *StageAndPatternContext) SetStage(v IIdentifierContext) { s.stage = v }

func (s *StageAndPatternContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserATSIGN, 0)
}

func (s *StageAndPatternContext) TILDE() antlr.TerminalNode {
	return s.GetToken(DorisParserTILDE, 0)
}

func (s *StageAndPatternContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StageAndPatternContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *StageAndPatternContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *StageAndPatternContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *StageAndPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StageAndPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StageAndPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStageAndPattern(s)
	}
}

func (s *StageAndPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStageAndPattern(s)
	}
}

func (p *DorisParser) StageAndPattern() (localctx IStageAndPatternContext) {
	localctx = NewStageAndPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, DorisParserRULE_stageAndPattern)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4156)
		p.Match(DorisParserATSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4159)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		{
			p.SetState(4157)

			var _x = p.Identifier()

			localctx.(*StageAndPatternContext).stage = _x
		}

	case DorisParserTILDE:
		{
			p.SetState(4158)
			p.Match(DorisParserTILDE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(4164)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLEFT_PAREN {
		{
			p.SetState(4161)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4162)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*StageAndPatternContext).pattern = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4163)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedKillStatementContext is an interface to support dynamic dispatch.
type IUnsupportedKillStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedKillStatementContext differentiates from other interfaces.
	IsUnsupportedKillStatementContext()
}

type UnsupportedKillStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedKillStatementContext() *UnsupportedKillStatementContext {
	var p = new(UnsupportedKillStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedKillStatement
	return p
}

func InitEmptyUnsupportedKillStatementContext(p *UnsupportedKillStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedKillStatement
}

func (*UnsupportedKillStatementContext) IsUnsupportedKillStatementContext() {}

func NewUnsupportedKillStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedKillStatementContext {
	var p = new(UnsupportedKillStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedKillStatement

	return p
}

func (s *UnsupportedKillStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedKillStatementContext) CopyAll(ctx *UnsupportedKillStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedKillStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedKillStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type KillQueryContext struct {
	UnsupportedKillStatementContext
}

func NewKillQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KillQueryContext {
	var p = new(KillQueryContext)

	InitEmptyUnsupportedKillStatementContext(&p.UnsupportedKillStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedKillStatementContext))

	return p
}

func (s *KillQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillQueryContext) KILL() antlr.TerminalNode {
	return s.GetToken(DorisParserKILL, 0)
}

func (s *KillQueryContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DorisParserQUERY, 0)
}

func (s *KillQueryContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *KillQueryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *KillQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterKillQuery(s)
	}
}

func (s *KillQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitKillQuery(s)
	}
}

type KillConnectionContext struct {
	UnsupportedKillStatementContext
}

func NewKillConnectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KillConnectionContext {
	var p = new(KillConnectionContext)

	InitEmptyUnsupportedKillStatementContext(&p.UnsupportedKillStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedKillStatementContext))

	return p
}

func (s *KillConnectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillConnectionContext) KILL() antlr.TerminalNode {
	return s.GetToken(DorisParserKILL, 0)
}

func (s *KillConnectionContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *KillConnectionContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(DorisParserCONNECTION, 0)
}

func (s *KillConnectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterKillConnection(s)
	}
}

func (s *KillConnectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitKillConnection(s)
	}
}

func (p *DorisParser) UnsupportedKillStatement() (localctx IUnsupportedKillStatementContext) {
	localctx = NewUnsupportedKillStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, DorisParserRULE_unsupportedKillStatement)
	var _la int

	p.SetState(4174)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 593, p.GetParserRuleContext()) {
	case 1:
		localctx = NewKillConnectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4166)
			p.Match(DorisParserKILL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4168)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCONNECTION {
			{
				p.SetState(4167)
				p.Match(DorisParserCONNECTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4170)
			p.Match(DorisParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewKillQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4171)
			p.Match(DorisParserKILL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4172)
			p.Match(DorisParserQUERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4173)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserSTRING_LITERAL || _la == DorisParserINTEGER_VALUE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedDescribeStatementContext is an interface to support dynamic dispatch.
type IUnsupportedDescribeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedDescribeStatementContext differentiates from other interfaces.
	IsUnsupportedDescribeStatementContext()
}

type UnsupportedDescribeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedDescribeStatementContext() *UnsupportedDescribeStatementContext {
	var p = new(UnsupportedDescribeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedDescribeStatement
	return p
}

func InitEmptyUnsupportedDescribeStatementContext(p *UnsupportedDescribeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedDescribeStatement
}

func (*UnsupportedDescribeStatementContext) IsUnsupportedDescribeStatementContext() {}

func NewUnsupportedDescribeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedDescribeStatementContext {
	var p = new(UnsupportedDescribeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedDescribeStatement

	return p
}

func (s *UnsupportedDescribeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedDescribeStatementContext) CopyAll(ctx *UnsupportedDescribeStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedDescribeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedDescribeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DescribeTableValuedFunctionContext struct {
	UnsupportedDescribeStatementContext
	tvfName    IIdentifierContext
	properties IPropertyItemListContext
}

func NewDescribeTableValuedFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeTableValuedFunctionContext {
	var p = new(DescribeTableValuedFunctionContext)

	InitEmptyUnsupportedDescribeStatementContext(&p.UnsupportedDescribeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDescribeStatementContext))

	return p
}

func (s *DescribeTableValuedFunctionContext) GetTvfName() IIdentifierContext { return s.tvfName }

func (s *DescribeTableValuedFunctionContext) GetProperties() IPropertyItemListContext {
	return s.properties
}

func (s *DescribeTableValuedFunctionContext) SetTvfName(v IIdentifierContext) { s.tvfName = v }

func (s *DescribeTableValuedFunctionContext) SetProperties(v IPropertyItemListContext) {
	s.properties = v
}

func (s *DescribeTableValuedFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeTableValuedFunctionContext) ExplainCommand() IExplainCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainCommandContext)
}

func (s *DescribeTableValuedFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserFUNCTION, 0)
}

func (s *DescribeTableValuedFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *DescribeTableValuedFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *DescribeTableValuedFunctionContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *DescribeTableValuedFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DescribeTableValuedFunctionContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *DescribeTableValuedFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDescribeTableValuedFunction(s)
	}
}

func (s *DescribeTableValuedFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDescribeTableValuedFunction(s)
	}
}

type DescribeTableContext struct {
	UnsupportedDescribeStatementContext
}

func NewDescribeTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeTableContext {
	var p = new(DescribeTableContext)

	InitEmptyUnsupportedDescribeStatementContext(&p.UnsupportedDescribeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDescribeStatementContext))

	return p
}

func (s *DescribeTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeTableContext) ExplainCommand() IExplainCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainCommandContext)
}

func (s *DescribeTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DescribeTableContext) SpecifiedPartition() ISpecifiedPartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecifiedPartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecifiedPartitionContext)
}

func (s *DescribeTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDescribeTable(s)
	}
}

func (s *DescribeTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDescribeTable(s)
	}
}

type DescribeTableAllContext struct {
	UnsupportedDescribeStatementContext
}

func NewDescribeTableAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeTableAllContext {
	var p = new(DescribeTableAllContext)

	InitEmptyUnsupportedDescribeStatementContext(&p.UnsupportedDescribeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDescribeStatementContext))

	return p
}

func (s *DescribeTableAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeTableAllContext) ExplainCommand() IExplainCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainCommandContext)
}

func (s *DescribeTableAllContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DescribeTableAllContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *DescribeTableAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDescribeTableAll(s)
	}
}

func (s *DescribeTableAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDescribeTableAll(s)
	}
}

func (p *DorisParser) UnsupportedDescribeStatement() (localctx IUnsupportedDescribeStatementContext) {
	localctx = NewUnsupportedDescribeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, DorisParserRULE_unsupportedDescribeStatement)
	var _la int

	p.SetState(4195)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 596, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDescribeTableValuedFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4176)
			p.ExplainCommand()
		}
		{
			p.SetState(4177)
			p.Match(DorisParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4178)

			var _x = p.Identifier()

			localctx.(*DescribeTableValuedFunctionContext).tvfName = _x
		}
		{
			p.SetState(4179)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4181)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8646890354245576320) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&3026312906716208575) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-6232420542927452621) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&3937129999880936915) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-2873940910708630541) != 0) || ((int64((_la-322)) & ^0x3f) == 0 && ((int64(1)<<(_la-322))&6912752233721880575) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&-2627780018309275847) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&72207677327248109) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&56359) != 0) {
			{
				p.SetState(4180)

				var _x = p.PropertyItemList()

				localctx.(*DescribeTableValuedFunctionContext).properties = _x
			}

		}
		{
			p.SetState(4183)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4184)
			p.TableAlias()
		}

	case 2:
		localctx = NewDescribeTableAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4186)
			p.ExplainCommand()
		}
		{
			p.SetState(4187)
			p.MultipartIdentifier()
		}
		{
			p.SetState(4188)
			p.Match(DorisParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewDescribeTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4190)
			p.ExplainCommand()
		}
		{
			p.SetState(4191)
			p.MultipartIdentifier()
		}
		p.SetState(4193)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(4192)
				p.SpecifiedPartition()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstraintContext is an interface to support dynamic dispatch.
type IConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSlots returns the slots rule contexts.
	GetSlots() IIdentifierListContext

	// GetReferenceTable returns the referenceTable rule contexts.
	GetReferenceTable() IMultipartIdentifierContext

	// GetReferencedSlots returns the referencedSlots rule contexts.
	GetReferencedSlots() IIdentifierListContext

	// SetSlots sets the slots rule contexts.
	SetSlots(IIdentifierListContext)

	// SetReferenceTable sets the referenceTable rule contexts.
	SetReferenceTable(IMultipartIdentifierContext)

	// SetReferencedSlots sets the referencedSlots rule contexts.
	SetReferencedSlots(IIdentifierListContext)

	// Getter signatures
	PRIMARY() antlr.TerminalNode
	KEY() antlr.TerminalNode
	AllIdentifierList() []IIdentifierListContext
	IdentifierList(i int) IIdentifierListContext
	UNIQUE() antlr.TerminalNode
	FOREIGN() antlr.TerminalNode
	REFERENCES() antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext

	// IsConstraintContext differentiates from other interfaces.
	IsConstraintContext()
}

type ConstraintContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	slots           IIdentifierListContext
	referenceTable  IMultipartIdentifierContext
	referencedSlots IIdentifierListContext
}

func NewEmptyConstraintContext() *ConstraintContext {
	var p = new(ConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_constraint
	return p
}

func InitEmptyConstraintContext(p *ConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_constraint
}

func (*ConstraintContext) IsConstraintContext() {}

func NewConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintContext {
	var p = new(ConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_constraint

	return p
}

func (s *ConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintContext) GetSlots() IIdentifierListContext { return s.slots }

func (s *ConstraintContext) GetReferenceTable() IMultipartIdentifierContext { return s.referenceTable }

func (s *ConstraintContext) GetReferencedSlots() IIdentifierListContext { return s.referencedSlots }

func (s *ConstraintContext) SetSlots(v IIdentifierListContext) { s.slots = v }

func (s *ConstraintContext) SetReferenceTable(v IMultipartIdentifierContext) { s.referenceTable = v }

func (s *ConstraintContext) SetReferencedSlots(v IIdentifierListContext) { s.referencedSlots = v }

func (s *ConstraintContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(DorisParserPRIMARY, 0)
}

func (s *ConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserKEY, 0)
}

func (s *ConstraintContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *ConstraintContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ConstraintContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(DorisParserUNIQUE, 0)
}

func (s *ConstraintContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserFOREIGN, 0)
}

func (s *ConstraintContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(DorisParserREFERENCES, 0)
}

func (s *ConstraintContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterConstraint(s)
	}
}

func (s *ConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitConstraint(s)
	}
}

func (p *DorisParser) Constraint() (localctx IConstraintContext) {
	localctx = NewConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, DorisParserRULE_constraint)
	p.SetState(4209)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserPRIMARY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4197)
			p.Match(DorisParserPRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4198)
			p.Match(DorisParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4199)

			var _x = p.IdentifierList()

			localctx.(*ConstraintContext).slots = _x
		}

	case DorisParserUNIQUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4200)
			p.Match(DorisParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4201)

			var _x = p.IdentifierList()

			localctx.(*ConstraintContext).slots = _x
		}

	case DorisParserFOREIGN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4202)
			p.Match(DorisParserFOREIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4203)
			p.Match(DorisParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4204)

			var _x = p.IdentifierList()

			localctx.(*ConstraintContext).slots = _x
		}
		{
			p.SetState(4205)
			p.Match(DorisParserREFERENCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4206)

			var _x = p.MultipartIdentifier()

			localctx.(*ConstraintContext).referenceTable = _x
		}
		{
			p.SetState(4207)

			var _x = p.IdentifierList()

			localctx.(*ConstraintContext).referencedSlots = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionSpecContext is an interface to support dynamic dispatch.
type IPartitionSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitions returns the partitions rule contexts.
	GetPartitions() IIdentifierListContext

	// GetPartition returns the partition rule contexts.
	GetPartition() IErrorCapturingIdentifierContext

	// SetPartitions sets the partitions rule contexts.
	SetPartitions(IIdentifierListContext)

	// SetPartition sets the partition rule contexts.
	SetPartition(IErrorCapturingIdentifierContext)

	// Getter signatures
	PARTITION() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	TEMPORARY() antlr.TerminalNode
	ErrorCapturingIdentifier() IErrorCapturingIdentifierContext
	LEFT_PAREN() antlr.TerminalNode
	ASTERISK() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode

	// IsPartitionSpecContext differentiates from other interfaces.
	IsPartitionSpecContext()
}

type PartitionSpecContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	partitions IIdentifierListContext
	partition  IErrorCapturingIdentifierContext
}

func NewEmptyPartitionSpecContext() *PartitionSpecContext {
	var p = new(PartitionSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionSpec
	return p
}

func InitEmptyPartitionSpecContext(p *PartitionSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionSpec
}

func (*PartitionSpecContext) IsPartitionSpecContext() {}

func NewPartitionSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionSpecContext {
	var p = new(PartitionSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_partitionSpec

	return p
}

func (s *PartitionSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionSpecContext) GetPartitions() IIdentifierListContext { return s.partitions }

func (s *PartitionSpecContext) GetPartition() IErrorCapturingIdentifierContext { return s.partition }

func (s *PartitionSpecContext) SetPartitions(v IIdentifierListContext) { s.partitions = v }

func (s *PartitionSpecContext) SetPartition(v IErrorCapturingIdentifierContext) { s.partition = v }

func (s *PartitionSpecContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *PartitionSpecContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITIONS, 0)
}

func (s *PartitionSpecContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PartitionSpecContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *PartitionSpecContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *PartitionSpecContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *PartitionSpecContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserASTERISK, 0)
}

func (s *PartitionSpecContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *PartitionSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPartitionSpec(s)
	}
}

func (s *PartitionSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPartitionSpec(s)
	}
}

func (p *DorisParser) PartitionSpec() (localctx IPartitionSpecContext) {
	localctx = NewPartitionSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, DorisParserRULE_partitionSpec)
	var _la int

	p.SetState(4225)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 600, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4212)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(4211)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4214)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserPARTITION || _la == DorisParserPARTITIONS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4215)

			var _x = p.IdentifierList()

			localctx.(*PartitionSpecContext).partitions = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4217)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(4216)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4219)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4220)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*PartitionSpecContext).partition = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4221)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserPARTITION || _la == DorisParserPARTITIONS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4222)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4223)
			p.Match(DorisParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4224)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionTableContext is an interface to support dynamic dispatch.
type IPartitionTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAutoPartition returns the autoPartition token.
	GetAutoPartition() antlr.Token

	// SetAutoPartition sets the autoPartition token.
	SetAutoPartition(antlr.Token)

	// GetPartitionList returns the partitionList rule contexts.
	GetPartitionList() IIdentityOrFunctionListContext

	// GetPartitions returns the partitions rule contexts.
	GetPartitions() IPartitionsDefContext

	// SetPartitionList sets the partitionList rule contexts.
	SetPartitionList(IIdentityOrFunctionListContext)

	// SetPartitions sets the partitions rule contexts.
	SetPartitions(IPartitionsDefContext)

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	IdentityOrFunctionList() IIdentityOrFunctionListContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AUTO() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	LIST() antlr.TerminalNode
	PartitionsDef() IPartitionsDefContext

	// IsPartitionTableContext differentiates from other interfaces.
	IsPartitionTableContext()
}

type PartitionTableContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	autoPartition antlr.Token
	partitionList IIdentityOrFunctionListContext
	partitions    IPartitionsDefContext
}

func NewEmptyPartitionTableContext() *PartitionTableContext {
	var p = new(PartitionTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionTable
	return p
}

func InitEmptyPartitionTableContext(p *PartitionTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionTable
}

func (*PartitionTableContext) IsPartitionTableContext() {}

func NewPartitionTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionTableContext {
	var p = new(PartitionTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_partitionTable

	return p
}

func (s *PartitionTableContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionTableContext) GetAutoPartition() antlr.Token { return s.autoPartition }

func (s *PartitionTableContext) SetAutoPartition(v antlr.Token) { s.autoPartition = v }

func (s *PartitionTableContext) GetPartitionList() IIdentityOrFunctionListContext {
	return s.partitionList
}

func (s *PartitionTableContext) GetPartitions() IPartitionsDefContext { return s.partitions }

func (s *PartitionTableContext) SetPartitionList(v IIdentityOrFunctionListContext) {
	s.partitionList = v
}

func (s *PartitionTableContext) SetPartitions(v IPartitionsDefContext) { s.partitions = v }

func (s *PartitionTableContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *PartitionTableContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *PartitionTableContext) IdentityOrFunctionList() IIdentityOrFunctionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentityOrFunctionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentityOrFunctionListContext)
}

func (s *PartitionTableContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *PartitionTableContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *PartitionTableContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO, 0)
}

func (s *PartitionTableContext) RANGE() antlr.TerminalNode {
	return s.GetToken(DorisParserRANGE, 0)
}

func (s *PartitionTableContext) LIST() antlr.TerminalNode {
	return s.GetToken(DorisParserLIST, 0)
}

func (s *PartitionTableContext) PartitionsDef() IPartitionsDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionsDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionsDefContext)
}

func (s *PartitionTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPartitionTable(s)
	}
}

func (s *PartitionTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPartitionTable(s)
	}
}

func (p *DorisParser) PartitionTable() (localctx IPartitionTableContext) {
	localctx = NewPartitionTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, DorisParserRULE_partitionTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4228)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserAUTO {
		{
			p.SetState(4227)

			var _m = p.Match(DorisParserAUTO)

			localctx.(*PartitionTableContext).autoPartition = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4230)
		p.Match(DorisParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4231)
		p.Match(DorisParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4233)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLIST || _la == DorisParserRANGE {
		{
			p.SetState(4232)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserLIST || _la == DorisParserRANGE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(4235)

		var _x = p.IdentityOrFunctionList()

		localctx.(*PartitionTableContext).partitionList = _x
	}

	{
		p.SetState(4236)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4238)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserFROM || _la == DorisParserPARTITION {
		{
			p.SetState(4237)

			var _x = p.PartitionsDef()

			localctx.(*PartitionTableContext).partitions = _x
		}

	}
	{
		p.SetState(4240)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentityOrFunctionListContext is an interface to support dynamic dispatch.
type IIdentityOrFunctionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_identityOrFunction returns the _identityOrFunction rule contexts.
	Get_identityOrFunction() IIdentityOrFunctionContext

	// Set_identityOrFunction sets the _identityOrFunction rule contexts.
	Set_identityOrFunction(IIdentityOrFunctionContext)

	// GetPartitions returns the partitions rule context list.
	GetPartitions() []IIdentityOrFunctionContext

	// SetPartitions sets the partitions rule context list.
	SetPartitions([]IIdentityOrFunctionContext)

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	AllIdentityOrFunction() []IIdentityOrFunctionContext
	IdentityOrFunction(i int) IIdentityOrFunctionContext
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentityOrFunctionListContext differentiates from other interfaces.
	IsIdentityOrFunctionListContext()
}

type IdentityOrFunctionListContext struct {
	antlr.BaseParserRuleContext
	parser              antlr.Parser
	_identityOrFunction IIdentityOrFunctionContext
	partitions          []IIdentityOrFunctionContext
}

func NewEmptyIdentityOrFunctionListContext() *IdentityOrFunctionListContext {
	var p = new(IdentityOrFunctionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identityOrFunctionList
	return p
}

func InitEmptyIdentityOrFunctionListContext(p *IdentityOrFunctionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identityOrFunctionList
}

func (*IdentityOrFunctionListContext) IsIdentityOrFunctionListContext() {}

func NewIdentityOrFunctionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentityOrFunctionListContext {
	var p = new(IdentityOrFunctionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_identityOrFunctionList

	return p
}

func (s *IdentityOrFunctionListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentityOrFunctionListContext) Get_identityOrFunction() IIdentityOrFunctionContext {
	return s._identityOrFunction
}

func (s *IdentityOrFunctionListContext) Set_identityOrFunction(v IIdentityOrFunctionContext) {
	s._identityOrFunction = v
}

func (s *IdentityOrFunctionListContext) GetPartitions() []IIdentityOrFunctionContext {
	return s.partitions
}

func (s *IdentityOrFunctionListContext) SetPartitions(v []IIdentityOrFunctionContext) {
	s.partitions = v
}

func (s *IdentityOrFunctionListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *IdentityOrFunctionListContext) AllIdentityOrFunction() []IIdentityOrFunctionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentityOrFunctionContext); ok {
			len++
		}
	}

	tst := make([]IIdentityOrFunctionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentityOrFunctionContext); ok {
			tst[i] = t.(IIdentityOrFunctionContext)
			i++
		}
	}

	return tst
}

func (s *IdentityOrFunctionListContext) IdentityOrFunction(i int) IIdentityOrFunctionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentityOrFunctionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentityOrFunctionContext)
}

func (s *IdentityOrFunctionListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *IdentityOrFunctionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *IdentityOrFunctionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *IdentityOrFunctionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentityOrFunctionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentityOrFunctionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIdentityOrFunctionList(s)
	}
}

func (s *IdentityOrFunctionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIdentityOrFunctionList(s)
	}
}

func (p *DorisParser) IdentityOrFunctionList() (localctx IIdentityOrFunctionListContext) {
	localctx = NewIdentityOrFunctionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, DorisParserRULE_identityOrFunctionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4242)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4243)
		p.IdentityOrFunction()
	}
	p.SetState(4248)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(4244)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4245)

			var _x = p.IdentityOrFunction()

			localctx.(*IdentityOrFunctionListContext)._identityOrFunction = _x
		}
		localctx.(*IdentityOrFunctionListContext).partitions = append(localctx.(*IdentityOrFunctionListContext).partitions, localctx.(*IdentityOrFunctionListContext)._identityOrFunction)

		p.SetState(4250)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4251)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentityOrFunctionContext is an interface to support dynamic dispatch.
type IIdentityOrFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	FunctionCallExpression() IFunctionCallExpressionContext

	// IsIdentityOrFunctionContext differentiates from other interfaces.
	IsIdentityOrFunctionContext()
}

type IdentityOrFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentityOrFunctionContext() *IdentityOrFunctionContext {
	var p = new(IdentityOrFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identityOrFunction
	return p
}

func InitEmptyIdentityOrFunctionContext(p *IdentityOrFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identityOrFunction
}

func (*IdentityOrFunctionContext) IsIdentityOrFunctionContext() {}

func NewIdentityOrFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentityOrFunctionContext {
	var p = new(IdentityOrFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_identityOrFunction

	return p
}

func (s *IdentityOrFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentityOrFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentityOrFunctionContext) FunctionCallExpression() IFunctionCallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallExpressionContext)
}

func (s *IdentityOrFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentityOrFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentityOrFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIdentityOrFunction(s)
	}
}

func (s *IdentityOrFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIdentityOrFunction(s)
	}
}

func (p *DorisParser) IdentityOrFunction() (localctx IIdentityOrFunctionContext) {
	localctx = NewIdentityOrFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, DorisParserRULE_identityOrFunction)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4255)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 605, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4253)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4254)
			p.FunctionCallExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataDescContext is an interface to support dynamic dispatch.
type IDataDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_STRING_LITERAL returns the _STRING_LITERAL token.
	Get_STRING_LITERAL() antlr.Token

	// GetComma returns the comma token.
	GetComma() antlr.Token

	// GetSeparator returns the separator token.
	GetSeparator() antlr.Token

	// Set_STRING_LITERAL sets the _STRING_LITERAL token.
	Set_STRING_LITERAL(antlr.Token)

	// SetComma sets the comma token.
	SetComma(antlr.Token)

	// SetSeparator sets the separator token.
	SetSeparator(antlr.Token)

	// GetFilePaths returns the filePaths token list.
	GetFilePaths() []antlr.Token

	// GetFilePath returns the filePath token list.
	GetFilePath() []antlr.Token

	// SetFilePaths sets the filePaths token list.
	SetFilePaths([]antlr.Token)

	// SetFilePath sets the filePath token list.
	SetFilePath([]antlr.Token)

	// GetTargetTableName returns the targetTableName rule contexts.
	GetTargetTableName() IIdentifierContext

	// GetFormat returns the format rule contexts.
	GetFormat() IIdentifierOrTextContext

	// GetCompressType returns the compressType rule contexts.
	GetCompressType() IIdentifierOrTextContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IIdentifierListContext

	// GetColumnsFromPath returns the columnsFromPath rule contexts.
	GetColumnsFromPath() IColFromPathContext

	// GetColumnMapping returns the columnMapping rule contexts.
	GetColumnMapping() IColMappingListContext

	// GetPreFilter returns the preFilter rule contexts.
	GetPreFilter() IPreFilterClauseContext

	// GetWhere returns the where rule contexts.
	GetWhere() IWhereClauseContext

	// GetDeleteOn returns the deleteOn rule contexts.
	GetDeleteOn() IDeleteOnClauseContext

	// GetSequenceColumn returns the sequenceColumn rule contexts.
	GetSequenceColumn() ISequenceColClauseContext

	// GetSourceTableName returns the sourceTableName rule contexts.
	GetSourceTableName() IIdentifierContext

	// GetPartition returns the partition rule contexts.
	GetPartition() IIdentifierListContext

	// SetTargetTableName sets the targetTableName rule contexts.
	SetTargetTableName(IIdentifierContext)

	// SetFormat sets the format rule contexts.
	SetFormat(IIdentifierOrTextContext)

	// SetCompressType sets the compressType rule contexts.
	SetCompressType(IIdentifierOrTextContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IIdentifierListContext)

	// SetColumnsFromPath sets the columnsFromPath rule contexts.
	SetColumnsFromPath(IColFromPathContext)

	// SetColumnMapping sets the columnMapping rule contexts.
	SetColumnMapping(IColMappingListContext)

	// SetPreFilter sets the preFilter rule contexts.
	SetPreFilter(IPreFilterClauseContext)

	// SetWhere sets the where rule contexts.
	SetWhere(IWhereClauseContext)

	// SetDeleteOn sets the deleteOn rule contexts.
	SetDeleteOn(IDeleteOnClauseContext)

	// SetSequenceColumn sets the sequenceColumn rule contexts.
	SetSequenceColumn(ISequenceColClauseContext)

	// SetSourceTableName sets the sourceTableName rule contexts.
	SetSourceTableName(IIdentifierContext)

	// SetPartition sets the partition rule contexts.
	SetPartition(IIdentifierListContext)

	// Getter signatures
	DATA() antlr.TerminalNode
	INFILE() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	INTO() antlr.TerminalNode
	AllTABLE() []antlr.TerminalNode
	TABLE(i int) antlr.TerminalNode
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	MergeType() IMergeTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	PartitionSpec() IPartitionSpecContext
	COLUMNS() antlr.TerminalNode
	AllTERMINATED() []antlr.TerminalNode
	TERMINATED(i int) antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	LINES() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	AllAS() []antlr.TerminalNode
	AS(i int) antlr.TerminalNode
	COMPRESS_TYPE() antlr.TerminalNode
	PropertyClause() IPropertyClauseContext
	AllIdentifierOrText() []IIdentifierOrTextContext
	IdentifierOrText(i int) IIdentifierOrTextContext
	IdentifierList() IIdentifierListContext
	ColFromPath() IColFromPathContext
	ColMappingList() IColMappingListContext
	PreFilterClause() IPreFilterClauseContext
	WhereClause() IWhereClauseContext
	DeleteOnClause() IDeleteOnClauseContext
	SequenceColClause() ISequenceColClauseContext
	WITH() antlr.TerminalNode
	FROM() antlr.TerminalNode
	PARTITION() antlr.TerminalNode

	// IsDataDescContext differentiates from other interfaces.
	IsDataDescContext()
}

type DataDescContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	_STRING_LITERAL antlr.Token
	filePaths       []antlr.Token
	filePath        []antlr.Token
	targetTableName IIdentifierContext
	comma           antlr.Token
	separator       antlr.Token
	format          IIdentifierOrTextContext
	compressType    IIdentifierOrTextContext
	columns         IIdentifierListContext
	columnsFromPath IColFromPathContext
	columnMapping   IColMappingListContext
	preFilter       IPreFilterClauseContext
	where           IWhereClauseContext
	deleteOn        IDeleteOnClauseContext
	sequenceColumn  ISequenceColClauseContext
	sourceTableName IIdentifierContext
	partition       IIdentifierListContext
}

func NewEmptyDataDescContext() *DataDescContext {
	var p = new(DataDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dataDesc
	return p
}

func InitEmptyDataDescContext(p *DataDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dataDesc
}

func (*DataDescContext) IsDataDescContext() {}

func NewDataDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescContext {
	var p = new(DataDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_dataDesc

	return p
}

func (s *DataDescContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDescContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *DataDescContext) GetComma() antlr.Token { return s.comma }

func (s *DataDescContext) GetSeparator() antlr.Token { return s.separator }

func (s *DataDescContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *DataDescContext) SetComma(v antlr.Token) { s.comma = v }

func (s *DataDescContext) SetSeparator(v antlr.Token) { s.separator = v }

func (s *DataDescContext) GetFilePaths() []antlr.Token { return s.filePaths }

func (s *DataDescContext) GetFilePath() []antlr.Token { return s.filePath }

func (s *DataDescContext) SetFilePaths(v []antlr.Token) { s.filePaths = v }

func (s *DataDescContext) SetFilePath(v []antlr.Token) { s.filePath = v }

func (s *DataDescContext) GetTargetTableName() IIdentifierContext { return s.targetTableName }

func (s *DataDescContext) GetFormat() IIdentifierOrTextContext { return s.format }

func (s *DataDescContext) GetCompressType() IIdentifierOrTextContext { return s.compressType }

func (s *DataDescContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *DataDescContext) GetColumnsFromPath() IColFromPathContext { return s.columnsFromPath }

func (s *DataDescContext) GetColumnMapping() IColMappingListContext { return s.columnMapping }

func (s *DataDescContext) GetPreFilter() IPreFilterClauseContext { return s.preFilter }

func (s *DataDescContext) GetWhere() IWhereClauseContext { return s.where }

func (s *DataDescContext) GetDeleteOn() IDeleteOnClauseContext { return s.deleteOn }

func (s *DataDescContext) GetSequenceColumn() ISequenceColClauseContext { return s.sequenceColumn }

func (s *DataDescContext) GetSourceTableName() IIdentifierContext { return s.sourceTableName }

func (s *DataDescContext) GetPartition() IIdentifierListContext { return s.partition }

func (s *DataDescContext) SetTargetTableName(v IIdentifierContext) { s.targetTableName = v }

func (s *DataDescContext) SetFormat(v IIdentifierOrTextContext) { s.format = v }

func (s *DataDescContext) SetCompressType(v IIdentifierOrTextContext) { s.compressType = v }

func (s *DataDescContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *DataDescContext) SetColumnsFromPath(v IColFromPathContext) { s.columnsFromPath = v }

func (s *DataDescContext) SetColumnMapping(v IColMappingListContext) { s.columnMapping = v }

func (s *DataDescContext) SetPreFilter(v IPreFilterClauseContext) { s.preFilter = v }

func (s *DataDescContext) SetWhere(v IWhereClauseContext) { s.where = v }

func (s *DataDescContext) SetDeleteOn(v IDeleteOnClauseContext) { s.deleteOn = v }

func (s *DataDescContext) SetSequenceColumn(v ISequenceColClauseContext) { s.sequenceColumn = v }

func (s *DataDescContext) SetSourceTableName(v IIdentifierContext) { s.sourceTableName = v }

func (s *DataDescContext) SetPartition(v IIdentifierListContext) { s.partition = v }

func (s *DataDescContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserDATA, 0)
}

func (s *DataDescContext) INFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserINFILE, 0)
}

func (s *DataDescContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *DataDescContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *DataDescContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserINTO, 0)
}

func (s *DataDescContext) AllTABLE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserTABLE)
}

func (s *DataDescContext) TABLE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, i)
}

func (s *DataDescContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *DataDescContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *DataDescContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DataDescContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DataDescContext) MergeType() IMergeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeTypeContext)
}

func (s *DataDescContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *DataDescContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *DataDescContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *DataDescContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMNS, 0)
}

func (s *DataDescContext) AllTERMINATED() []antlr.TerminalNode {
	return s.GetTokens(DorisParserTERMINATED)
}

func (s *DataDescContext) TERMINATED(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserTERMINATED, i)
}

func (s *DataDescContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(DorisParserBY)
}

func (s *DataDescContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserBY, i)
}

func (s *DataDescContext) LINES() antlr.TerminalNode {
	return s.GetToken(DorisParserLINES, 0)
}

func (s *DataDescContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DorisParserFORMAT, 0)
}

func (s *DataDescContext) AllAS() []antlr.TerminalNode {
	return s.GetTokens(DorisParserAS)
}

func (s *DataDescContext) AS(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserAS, i)
}

func (s *DataDescContext) COMPRESS_TYPE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPRESS_TYPE, 0)
}

func (s *DataDescContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *DataDescContext) AllIdentifierOrText() []IIdentifierOrTextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrTextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrTextContext); ok {
			tst[i] = t.(IIdentifierOrTextContext)
			i++
		}
	}

	return tst
}

func (s *DataDescContext) IdentifierOrText(i int) IIdentifierOrTextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DataDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DataDescContext) ColFromPath() IColFromPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColFromPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColFromPathContext)
}

func (s *DataDescContext) ColMappingList() IColMappingListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColMappingListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColMappingListContext)
}

func (s *DataDescContext) PreFilterClause() IPreFilterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreFilterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreFilterClauseContext)
}

func (s *DataDescContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *DataDescContext) DeleteOnClause() IDeleteOnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteOnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteOnClauseContext)
}

func (s *DataDescContext) SequenceColClause() ISequenceColClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceColClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceColClauseContext)
}

func (s *DataDescContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *DataDescContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *DataDescContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *DataDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDataDesc(s)
	}
}

func (s *DataDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDataDesc(s)
	}
}

func (p *DorisParser) DataDesc() (localctx IDataDescContext) {
	localctx = NewDataDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, DorisParserRULE_dataDesc)
	var _la int

	p.SetState(4356)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 629, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4261)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAPPEND || _la == DorisParserDELETE || _la == DorisParserMERGE || _la == DorisParserWITH {
			p.SetState(4258)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserWITH {
				{
					p.SetState(4257)
					p.Match(DorisParserWITH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(4260)
				p.MergeType()
			}

		}
		{
			p.SetState(4263)
			p.Match(DorisParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4264)
			p.Match(DorisParserINFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4265)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4266)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*DataDescContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*DataDescContext).filePaths = append(localctx.(*DataDescContext).filePaths, localctx.(*DataDescContext)._STRING_LITERAL)
		p.SetState(4271)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(4267)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4268)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*DataDescContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*DataDescContext).filePath = append(localctx.(*DataDescContext).filePath, localctx.(*DataDescContext)._STRING_LITERAL)

			p.SetState(4273)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4274)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4275)
			p.Match(DorisParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4276)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4277)

			var _x = p.Identifier()

			localctx.(*DataDescContext).targetTableName = _x
		}
		p.SetState(4279)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(4278)
				p.PartitionSpec()
			}

		}
		p.SetState(4285)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 610, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4281)
				p.Match(DorisParserCOLUMNS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4282)
				p.Match(DorisParserTERMINATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4283)
				p.Match(DorisParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4284)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*DataDescContext).comma = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4291)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLINES {
			{
				p.SetState(4287)
				p.Match(DorisParserLINES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4288)
				p.Match(DorisParserTERMINATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4289)
				p.Match(DorisParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4290)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*DataDescContext).separator = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(4296)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFORMAT {
			{
				p.SetState(4293)
				p.Match(DorisParserFORMAT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4294)
				p.Match(DorisParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4295)

				var _x = p.IdentifierOrText()

				localctx.(*DataDescContext).format = _x
			}

		}
		p.SetState(4301)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMPRESS_TYPE {
			{
				p.SetState(4298)
				p.Match(DorisParserCOMPRESS_TYPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4299)
				p.Match(DorisParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4300)

				var _x = p.IdentifierOrText()

				localctx.(*DataDescContext).compressType = _x
			}

		}
		p.SetState(4304)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(4303)

				var _x = p.IdentifierList()

				localctx.(*DataDescContext).columns = _x
			}

		}
		p.SetState(4307)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOLUMNS {
			{
				p.SetState(4306)

				var _x = p.ColFromPath()

				localctx.(*DataDescContext).columnsFromPath = _x
			}

		}
		p.SetState(4310)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserSET {
			{
				p.SetState(4309)

				var _x = p.ColMappingList()

				localctx.(*DataDescContext).columnMapping = _x
			}

		}
		p.SetState(4313)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPRECEDING {
			{
				p.SetState(4312)

				var _x = p.PreFilterClause()

				localctx.(*DataDescContext).preFilter = _x
			}

		}
		p.SetState(4316)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWHERE {
			{
				p.SetState(4315)

				var _x = p.WhereClause()

				localctx.(*DataDescContext).where = _x
			}

		}
		p.SetState(4319)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserDELETE {
			{
				p.SetState(4318)

				var _x = p.DeleteOnClause()

				localctx.(*DataDescContext).deleteOn = _x
			}

		}
		p.SetState(4322)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserORDER {
			{
				p.SetState(4321)

				var _x = p.SequenceColClause()

				localctx.(*DataDescContext).sequenceColumn = _x
			}

		}
		p.SetState(4325)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(4324)
				p.PropertyClause()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4331)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAPPEND || _la == DorisParserDELETE || _la == DorisParserMERGE || _la == DorisParserWITH {
			p.SetState(4328)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserWITH {
				{
					p.SetState(4327)
					p.Match(DorisParserWITH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(4330)
				p.MergeType()
			}

		}
		{
			p.SetState(4333)
			p.Match(DorisParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4334)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4335)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4336)

			var _x = p.Identifier()

			localctx.(*DataDescContext).sourceTableName = _x
		}
		{
			p.SetState(4337)
			p.Match(DorisParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4338)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4339)

			var _x = p.Identifier()

			localctx.(*DataDescContext).targetTableName = _x
		}
		p.SetState(4342)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION {
			{
				p.SetState(4340)
				p.Match(DorisParserPARTITION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4341)

				var _x = p.IdentifierList()

				localctx.(*DataDescContext).partition = _x
			}

		}
		p.SetState(4345)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserSET {
			{
				p.SetState(4344)

				var _x = p.ColMappingList()

				localctx.(*DataDescContext).columnMapping = _x
			}

		}
		p.SetState(4348)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWHERE {
			{
				p.SetState(4347)

				var _x = p.WhereClause()

				localctx.(*DataDescContext).where = _x
			}

		}
		p.SetState(4351)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserDELETE {
			{
				p.SetState(4350)

				var _x = p.DeleteOnClause()

				localctx.(*DataDescContext).deleteOn = _x
			}

		}
		p.SetState(4354)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(4353)
				p.PropertyClause()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBuildModeContext is an interface to support dynamic dispatch.
type IBuildModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BUILD() antlr.TerminalNode
	IMMEDIATE() antlr.TerminalNode
	DEFERRED() antlr.TerminalNode

	// IsBuildModeContext differentiates from other interfaces.
	IsBuildModeContext()
}

type BuildModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBuildModeContext() *BuildModeContext {
	var p = new(BuildModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_buildMode
	return p
}

func InitEmptyBuildModeContext(p *BuildModeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_buildMode
}

func (*BuildModeContext) IsBuildModeContext() {}

func NewBuildModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BuildModeContext {
	var p = new(BuildModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_buildMode

	return p
}

func (s *BuildModeContext) GetParser() antlr.Parser { return s.parser }

func (s *BuildModeContext) BUILD() antlr.TerminalNode {
	return s.GetToken(DorisParserBUILD, 0)
}

func (s *BuildModeContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(DorisParserIMMEDIATE, 0)
}

func (s *BuildModeContext) DEFERRED() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFERRED, 0)
}

func (s *BuildModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BuildModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BuildModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBuildMode(s)
	}
}

func (s *BuildModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBuildMode(s)
	}
}

func (p *DorisParser) BuildMode() (localctx IBuildModeContext) {
	localctx = NewBuildModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, DorisParserRULE_buildMode)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4358)
		p.Match(DorisParserBUILD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4359)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserDEFERRED || _la == DorisParserIMMEDIATE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshTriggerContext is an interface to support dynamic dispatch.
type IRefreshTriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	MANUAL() antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	RefreshSchedule() IRefreshScheduleContext
	COMMIT() antlr.TerminalNode

	// IsRefreshTriggerContext differentiates from other interfaces.
	IsRefreshTriggerContext()
}

type RefreshTriggerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefreshTriggerContext() *RefreshTriggerContext {
	var p = new(RefreshTriggerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_refreshTrigger
	return p
}

func InitEmptyRefreshTriggerContext(p *RefreshTriggerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_refreshTrigger
}

func (*RefreshTriggerContext) IsRefreshTriggerContext() {}

func NewRefreshTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshTriggerContext {
	var p = new(RefreshTriggerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_refreshTrigger

	return p
}

func (s *RefreshTriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshTriggerContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *RefreshTriggerContext) MANUAL() antlr.TerminalNode {
	return s.GetToken(DorisParserMANUAL, 0)
}

func (s *RefreshTriggerContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEDULE, 0)
}

func (s *RefreshTriggerContext) RefreshSchedule() IRefreshScheduleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshScheduleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshScheduleContext)
}

func (s *RefreshTriggerContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMIT, 0)
}

func (s *RefreshTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshTriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRefreshTrigger(s)
	}
}

func (s *RefreshTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRefreshTrigger(s)
	}
}

func (p *DorisParser) RefreshTrigger() (localctx IRefreshTriggerContext) {
	localctx = NewRefreshTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, DorisParserRULE_refreshTrigger)
	p.SetState(4368)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 630, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4361)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4362)
			p.Match(DorisParserMANUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4363)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4364)
			p.Match(DorisParserSCHEDULE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4365)
			p.RefreshSchedule()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4366)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4367)
			p.Match(DorisParserCOMMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshScheduleContext is an interface to support dynamic dispatch.
type IRefreshScheduleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRefreshUnit returns the refreshUnit rule contexts.
	GetRefreshUnit() IIdentifierContext

	// SetRefreshUnit sets the refreshUnit rule contexts.
	SetRefreshUnit(IIdentifierContext)

	// Getter signatures
	EVERY() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	Identifier() IIdentifierContext
	STARTS() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsRefreshScheduleContext differentiates from other interfaces.
	IsRefreshScheduleContext()
}

type RefreshScheduleContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	refreshUnit IIdentifierContext
}

func NewEmptyRefreshScheduleContext() *RefreshScheduleContext {
	var p = new(RefreshScheduleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_refreshSchedule
	return p
}

func InitEmptyRefreshScheduleContext(p *RefreshScheduleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_refreshSchedule
}

func (*RefreshScheduleContext) IsRefreshScheduleContext() {}

func NewRefreshScheduleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshScheduleContext {
	var p = new(RefreshScheduleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_refreshSchedule

	return p
}

func (s *RefreshScheduleContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshScheduleContext) GetRefreshUnit() IIdentifierContext { return s.refreshUnit }

func (s *RefreshScheduleContext) SetRefreshUnit(v IIdentifierContext) { s.refreshUnit = v }

func (s *RefreshScheduleContext) EVERY() antlr.TerminalNode {
	return s.GetToken(DorisParserEVERY, 0)
}

func (s *RefreshScheduleContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *RefreshScheduleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RefreshScheduleContext) STARTS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTARTS, 0)
}

func (s *RefreshScheduleContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *RefreshScheduleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshScheduleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshScheduleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRefreshSchedule(s)
	}
}

func (s *RefreshScheduleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRefreshSchedule(s)
	}
}

func (p *DorisParser) RefreshSchedule() (localctx IRefreshScheduleContext) {
	localctx = NewRefreshScheduleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, DorisParserRULE_refreshSchedule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4370)
		p.Match(DorisParserEVERY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4371)
		p.Match(DorisParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4372)

		var _x = p.Identifier()

		localctx.(*RefreshScheduleContext).refreshUnit = _x
	}
	p.SetState(4375)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserSTARTS {
		{
			p.SetState(4373)
			p.Match(DorisParserSTARTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4374)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshMethodContext is an interface to support dynamic dispatch.
type IRefreshMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMPLETE() antlr.TerminalNode
	AUTO() antlr.TerminalNode

	// IsRefreshMethodContext differentiates from other interfaces.
	IsRefreshMethodContext()
}

type RefreshMethodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefreshMethodContext() *RefreshMethodContext {
	var p = new(RefreshMethodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_refreshMethod
	return p
}

func InitEmptyRefreshMethodContext(p *RefreshMethodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_refreshMethod
}

func (*RefreshMethodContext) IsRefreshMethodContext() {}

func NewRefreshMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshMethodContext {
	var p = new(RefreshMethodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_refreshMethod

	return p
}

func (s *RefreshMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshMethodContext) COMPLETE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPLETE, 0)
}

func (s *RefreshMethodContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO, 0)
}

func (s *RefreshMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshMethodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRefreshMethod(s)
	}
}

func (s *RefreshMethodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRefreshMethod(s)
	}
}

func (p *DorisParser) RefreshMethod() (localctx IRefreshMethodContext) {
	localctx = NewRefreshMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, DorisParserRULE_refreshMethod)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4377)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserAUTO || _la == DorisParserCOMPLETE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMvPartitionContext is an interface to support dynamic dispatch.
type IMvPartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionKey returns the partitionKey rule contexts.
	GetPartitionKey() IIdentifierContext

	// GetPartitionExpr returns the partitionExpr rule contexts.
	GetPartitionExpr() IFunctionCallExpressionContext

	// SetPartitionKey sets the partitionKey rule contexts.
	SetPartitionKey(IIdentifierContext)

	// SetPartitionExpr sets the partitionExpr rule contexts.
	SetPartitionExpr(IFunctionCallExpressionContext)

	// Getter signatures
	Identifier() IIdentifierContext
	FunctionCallExpression() IFunctionCallExpressionContext

	// IsMvPartitionContext differentiates from other interfaces.
	IsMvPartitionContext()
}

type MvPartitionContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	partitionKey  IIdentifierContext
	partitionExpr IFunctionCallExpressionContext
}

func NewEmptyMvPartitionContext() *MvPartitionContext {
	var p = new(MvPartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_mvPartition
	return p
}

func InitEmptyMvPartitionContext(p *MvPartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_mvPartition
}

func (*MvPartitionContext) IsMvPartitionContext() {}

func NewMvPartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MvPartitionContext {
	var p = new(MvPartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_mvPartition

	return p
}

func (s *MvPartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *MvPartitionContext) GetPartitionKey() IIdentifierContext { return s.partitionKey }

func (s *MvPartitionContext) GetPartitionExpr() IFunctionCallExpressionContext {
	return s.partitionExpr
}

func (s *MvPartitionContext) SetPartitionKey(v IIdentifierContext) { s.partitionKey = v }

func (s *MvPartitionContext) SetPartitionExpr(v IFunctionCallExpressionContext) { s.partitionExpr = v }

func (s *MvPartitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MvPartitionContext) FunctionCallExpression() IFunctionCallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallExpressionContext)
}

func (s *MvPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MvPartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MvPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMvPartition(s)
	}
}

func (s *MvPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMvPartition(s)
	}
}

func (p *DorisParser) MvPartition() (localctx IMvPartitionContext) {
	localctx = NewMvPartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, DorisParserRULE_mvPartition)
	p.SetState(4381)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 632, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4379)

			var _x = p.Identifier()

			localctx.(*MvPartitionContext).partitionKey = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4380)

			var _x = p.FunctionCallExpression()

			localctx.(*MvPartitionContext).partitionExpr = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrTextContext is an interface to support dynamic dispatch.
type IIdentifierOrTextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	STRING_LITERAL() antlr.TerminalNode

	// IsIdentifierOrTextContext differentiates from other interfaces.
	IsIdentifierOrTextContext()
}

type IdentifierOrTextContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrTextContext() *IdentifierOrTextContext {
	var p = new(IdentifierOrTextContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierOrText
	return p
}

func InitEmptyIdentifierOrTextContext(p *IdentifierOrTextContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierOrText
}

func (*IdentifierOrTextContext) IsIdentifierOrTextContext() {}

func NewIdentifierOrTextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrTextContext {
	var p = new(IdentifierOrTextContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_identifierOrText

	return p
}

func (s *IdentifierOrTextContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrTextContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierOrTextContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *IdentifierOrTextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrTextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrTextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIdentifierOrText(s)
	}
}

func (s *IdentifierOrTextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIdentifierOrText(s)
	}
}

func (p *DorisParser) IdentifierOrText() (localctx IIdentifierOrTextContext) {
	localctx = NewIdentifierOrTextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, DorisParserRULE_identifierOrText)
	p.SetState(4385)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4383)
			p.Identifier()
		}

	case DorisParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4384)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrTextOrAsteriskContext is an interface to support dynamic dispatch.
type IIdentifierOrTextOrAsteriskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	STRING_LITERAL() antlr.TerminalNode
	ASTERISK() antlr.TerminalNode

	// IsIdentifierOrTextOrAsteriskContext differentiates from other interfaces.
	IsIdentifierOrTextOrAsteriskContext()
}

type IdentifierOrTextOrAsteriskContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrTextOrAsteriskContext() *IdentifierOrTextOrAsteriskContext {
	var p = new(IdentifierOrTextOrAsteriskContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierOrTextOrAsterisk
	return p
}

func InitEmptyIdentifierOrTextOrAsteriskContext(p *IdentifierOrTextOrAsteriskContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierOrTextOrAsterisk
}

func (*IdentifierOrTextOrAsteriskContext) IsIdentifierOrTextOrAsteriskContext() {}

func NewIdentifierOrTextOrAsteriskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrTextOrAsteriskContext {
	var p = new(IdentifierOrTextOrAsteriskContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_identifierOrTextOrAsterisk

	return p
}

func (s *IdentifierOrTextOrAsteriskContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrTextOrAsteriskContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierOrTextOrAsteriskContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *IdentifierOrTextOrAsteriskContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserASTERISK, 0)
}

func (s *IdentifierOrTextOrAsteriskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrTextOrAsteriskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrTextOrAsteriskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIdentifierOrTextOrAsterisk(s)
	}
}

func (s *IdentifierOrTextOrAsteriskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIdentifierOrTextOrAsterisk(s)
	}
}

func (p *DorisParser) IdentifierOrTextOrAsterisk() (localctx IIdentifierOrTextOrAsteriskContext) {
	localctx = NewIdentifierOrTextOrAsteriskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, DorisParserRULE_identifierOrTextOrAsterisk)
	p.SetState(4390)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4387)
			p.Identifier()
		}

	case DorisParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4388)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserASTERISK:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4389)
			p.Match(DorisParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultipartIdentifierOrAsteriskContext is an interface to support dynamic dispatch.
type IMultipartIdentifierOrAsteriskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_identifierOrAsterisk returns the _identifierOrAsterisk rule contexts.
	Get_identifierOrAsterisk() IIdentifierOrAsteriskContext

	// Set_identifierOrAsterisk sets the _identifierOrAsterisk rule contexts.
	Set_identifierOrAsterisk(IIdentifierOrAsteriskContext)

	// GetParts returns the parts rule context list.
	GetParts() []IIdentifierOrAsteriskContext

	// SetParts sets the parts rule context list.
	SetParts([]IIdentifierOrAsteriskContext)

	// Getter signatures
	AllIdentifierOrAsterisk() []IIdentifierOrAsteriskContext
	IdentifierOrAsterisk(i int) IIdentifierOrAsteriskContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsMultipartIdentifierOrAsteriskContext differentiates from other interfaces.
	IsMultipartIdentifierOrAsteriskContext()
}

type MultipartIdentifierOrAsteriskContext struct {
	antlr.BaseParserRuleContext
	parser                antlr.Parser
	_identifierOrAsterisk IIdentifierOrAsteriskContext
	parts                 []IIdentifierOrAsteriskContext
}

func NewEmptyMultipartIdentifierOrAsteriskContext() *MultipartIdentifierOrAsteriskContext {
	var p = new(MultipartIdentifierOrAsteriskContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_multipartIdentifierOrAsterisk
	return p
}

func InitEmptyMultipartIdentifierOrAsteriskContext(p *MultipartIdentifierOrAsteriskContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_multipartIdentifierOrAsterisk
}

func (*MultipartIdentifierOrAsteriskContext) IsMultipartIdentifierOrAsteriskContext() {}

func NewMultipartIdentifierOrAsteriskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipartIdentifierOrAsteriskContext {
	var p = new(MultipartIdentifierOrAsteriskContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_multipartIdentifierOrAsterisk

	return p
}

func (s *MultipartIdentifierOrAsteriskContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipartIdentifierOrAsteriskContext) Get_identifierOrAsterisk() IIdentifierOrAsteriskContext {
	return s._identifierOrAsterisk
}

func (s *MultipartIdentifierOrAsteriskContext) Set_identifierOrAsterisk(v IIdentifierOrAsteriskContext) {
	s._identifierOrAsterisk = v
}

func (s *MultipartIdentifierOrAsteriskContext) GetParts() []IIdentifierOrAsteriskContext {
	return s.parts
}

func (s *MultipartIdentifierOrAsteriskContext) SetParts(v []IIdentifierOrAsteriskContext) {
	s.parts = v
}

func (s *MultipartIdentifierOrAsteriskContext) AllIdentifierOrAsterisk() []IIdentifierOrAsteriskContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrAsteriskContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrAsteriskContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrAsteriskContext); ok {
			tst[i] = t.(IIdentifierOrAsteriskContext)
			i++
		}
	}

	return tst
}

func (s *MultipartIdentifierOrAsteriskContext) IdentifierOrAsterisk(i int) IIdentifierOrAsteriskContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrAsteriskContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrAsteriskContext)
}

func (s *MultipartIdentifierOrAsteriskContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(DorisParserDOT)
}

func (s *MultipartIdentifierOrAsteriskContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, i)
}

func (s *MultipartIdentifierOrAsteriskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipartIdentifierOrAsteriskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipartIdentifierOrAsteriskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMultipartIdentifierOrAsterisk(s)
	}
}

func (s *MultipartIdentifierOrAsteriskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMultipartIdentifierOrAsterisk(s)
	}
}

func (p *DorisParser) MultipartIdentifierOrAsterisk() (localctx IMultipartIdentifierOrAsteriskContext) {
	localctx = NewMultipartIdentifierOrAsteriskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, DorisParserRULE_multipartIdentifierOrAsterisk)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4392)

		var _x = p.IdentifierOrAsterisk()

		localctx.(*MultipartIdentifierOrAsteriskContext)._identifierOrAsterisk = _x
	}
	localctx.(*MultipartIdentifierOrAsteriskContext).parts = append(localctx.(*MultipartIdentifierOrAsteriskContext).parts, localctx.(*MultipartIdentifierOrAsteriskContext)._identifierOrAsterisk)
	p.SetState(4397)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserDOT {
		{
			p.SetState(4393)
			p.Match(DorisParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4394)

			var _x = p.IdentifierOrAsterisk()

			localctx.(*MultipartIdentifierOrAsteriskContext)._identifierOrAsterisk = _x
		}
		localctx.(*MultipartIdentifierOrAsteriskContext).parts = append(localctx.(*MultipartIdentifierOrAsteriskContext).parts, localctx.(*MultipartIdentifierOrAsteriskContext)._identifierOrAsterisk)

		p.SetState(4399)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrAsteriskContext is an interface to support dynamic dispatch.
type IIdentifierOrAsteriskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierOrText() IIdentifierOrTextContext
	ASTERISK() antlr.TerminalNode

	// IsIdentifierOrAsteriskContext differentiates from other interfaces.
	IsIdentifierOrAsteriskContext()
}

type IdentifierOrAsteriskContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrAsteriskContext() *IdentifierOrAsteriskContext {
	var p = new(IdentifierOrAsteriskContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierOrAsterisk
	return p
}

func InitEmptyIdentifierOrAsteriskContext(p *IdentifierOrAsteriskContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierOrAsterisk
}

func (*IdentifierOrAsteriskContext) IsIdentifierOrAsteriskContext() {}

func NewIdentifierOrAsteriskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrAsteriskContext {
	var p = new(IdentifierOrAsteriskContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_identifierOrAsterisk

	return p
}

func (s *IdentifierOrAsteriskContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrAsteriskContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *IdentifierOrAsteriskContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserASTERISK, 0)
}

func (s *IdentifierOrAsteriskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrAsteriskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrAsteriskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIdentifierOrAsterisk(s)
	}
}

func (s *IdentifierOrAsteriskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIdentifierOrAsterisk(s)
	}
}

func (p *DorisParser) IdentifierOrAsterisk() (localctx IIdentifierOrAsteriskContext) {
	localctx = NewIdentifierOrAsteriskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, DorisParserRULE_identifierOrAsterisk)
	p.SetState(4402)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4400)
			p.IdentifierOrText()
		}

	case DorisParserASTERISK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4401)
			p.Match(DorisParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserIdentifyContext is an interface to support dynamic dispatch.
type IUserIdentifyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUser returns the user rule contexts.
	GetUser() IIdentifierOrTextContext

	// GetHost returns the host rule contexts.
	GetHost() IIdentifierOrTextContext

	// SetUser sets the user rule contexts.
	SetUser(IIdentifierOrTextContext)

	// SetHost sets the host rule contexts.
	SetHost(IIdentifierOrTextContext)

	// Getter signatures
	AllIdentifierOrText() []IIdentifierOrTextContext
	IdentifierOrText(i int) IIdentifierOrTextContext
	ATSIGN() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode

	// IsUserIdentifyContext differentiates from other interfaces.
	IsUserIdentifyContext()
}

type UserIdentifyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	user   IIdentifierOrTextContext
	host   IIdentifierOrTextContext
}

func NewEmptyUserIdentifyContext() *UserIdentifyContext {
	var p = new(UserIdentifyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_userIdentify
	return p
}

func InitEmptyUserIdentifyContext(p *UserIdentifyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_userIdentify
}

func (*UserIdentifyContext) IsUserIdentifyContext() {}

func NewUserIdentifyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserIdentifyContext {
	var p = new(UserIdentifyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_userIdentify

	return p
}

func (s *UserIdentifyContext) GetParser() antlr.Parser { return s.parser }

func (s *UserIdentifyContext) GetUser() IIdentifierOrTextContext { return s.user }

func (s *UserIdentifyContext) GetHost() IIdentifierOrTextContext { return s.host }

func (s *UserIdentifyContext) SetUser(v IIdentifierOrTextContext) { s.user = v }

func (s *UserIdentifyContext) SetHost(v IIdentifierOrTextContext) { s.host = v }

func (s *UserIdentifyContext) AllIdentifierOrText() []IIdentifierOrTextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrTextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrTextContext); ok {
			tst[i] = t.(IIdentifierOrTextContext)
			i++
		}
	}

	return tst
}

func (s *UserIdentifyContext) IdentifierOrText(i int) IIdentifierOrTextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *UserIdentifyContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserATSIGN, 0)
}

func (s *UserIdentifyContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *UserIdentifyContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *UserIdentifyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserIdentifyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserIdentifyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUserIdentify(s)
	}
}

func (s *UserIdentifyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUserIdentify(s)
	}
}

func (p *DorisParser) UserIdentify() (localctx IUserIdentifyContext) {
	localctx = NewUserIdentifyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, DorisParserRULE_userIdentify)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4404)

		var _x = p.IdentifierOrText()

		localctx.(*UserIdentifyContext).user = _x
	}
	p.SetState(4413)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserATSIGN {
		{
			p.SetState(4405)
			p.Match(DorisParserATSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4411)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(4406)

				var _x = p.IdentifierOrText()

				localctx.(*UserIdentifyContext).host = _x
			}

		case DorisParserLEFT_PAREN:
			{
				p.SetState(4407)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4408)

				var _x = p.IdentifierOrText()

				localctx.(*UserIdentifyContext).host = _x
			}
			{
				p.SetState(4409)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantUserIdentifyContext is an interface to support dynamic dispatch.
type IGrantUserIdentifyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserIdentify() IUserIdentifyContext
	IDENTIFIED() antlr.TerminalNode
	BY() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode

	// IsGrantUserIdentifyContext differentiates from other interfaces.
	IsGrantUserIdentifyContext()
}

type GrantUserIdentifyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantUserIdentifyContext() *GrantUserIdentifyContext {
	var p = new(GrantUserIdentifyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_grantUserIdentify
	return p
}

func InitEmptyGrantUserIdentifyContext(p *GrantUserIdentifyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_grantUserIdentify
}

func (*GrantUserIdentifyContext) IsGrantUserIdentifyContext() {}

func NewGrantUserIdentifyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantUserIdentifyContext {
	var p = new(GrantUserIdentifyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_grantUserIdentify

	return p
}

func (s *GrantUserIdentifyContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantUserIdentifyContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *GrantUserIdentifyContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(DorisParserIDENTIFIED, 0)
}

func (s *GrantUserIdentifyContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *GrantUserIdentifyContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *GrantUserIdentifyContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD, 0)
}

func (s *GrantUserIdentifyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantUserIdentifyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantUserIdentifyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterGrantUserIdentify(s)
	}
}

func (s *GrantUserIdentifyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitGrantUserIdentify(s)
	}
}

func (p *DorisParser) GrantUserIdentify() (localctx IGrantUserIdentifyContext) {
	localctx = NewGrantUserIdentifyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, DorisParserRULE_grantUserIdentify)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4415)
		p.UserIdentify()
	}
	p.SetState(4422)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserIDENTIFIED {
		{
			p.SetState(4416)
			p.Match(DorisParserIDENTIFIED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4417)
			p.Match(DorisParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4419)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPASSWORD {
			{
				p.SetState(4418)
				p.Match(DorisParserPASSWORD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4421)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplainContext is an interface to support dynamic dispatch.
type IExplainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLevel returns the level token.
	GetLevel() antlr.Token

	// SetLevel sets the level token.
	SetLevel(antlr.Token)

	// Getter signatures
	ExplainCommand() IExplainCommandContext
	PlanType() IPlanTypeContext
	PROCESS() antlr.TerminalNode
	VERBOSE() antlr.TerminalNode
	TREE() antlr.TerminalNode
	GRAPH() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	DUMP() antlr.TerminalNode

	// IsExplainContext differentiates from other interfaces.
	IsExplainContext()
}

type ExplainContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	level  antlr.Token
}

func NewEmptyExplainContext() *ExplainContext {
	var p = new(ExplainContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_explain
	return p
}

func InitEmptyExplainContext(p *ExplainContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_explain
}

func (*ExplainContext) IsExplainContext() {}

func NewExplainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainContext {
	var p = new(ExplainContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_explain

	return p
}

func (s *ExplainContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainContext) GetLevel() antlr.Token { return s.level }

func (s *ExplainContext) SetLevel(v antlr.Token) { s.level = v }

func (s *ExplainContext) ExplainCommand() IExplainCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainCommandContext)
}

func (s *ExplainContext) PlanType() IPlanTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPlanTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPlanTypeContext)
}

func (s *ExplainContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(DorisParserPROCESS, 0)
}

func (s *ExplainContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserVERBOSE, 0)
}

func (s *ExplainContext) TREE() antlr.TerminalNode {
	return s.GetToken(DorisParserTREE, 0)
}

func (s *ExplainContext) GRAPH() antlr.TerminalNode {
	return s.GetToken(DorisParserGRAPH, 0)
}

func (s *ExplainContext) PLAN() antlr.TerminalNode {
	return s.GetToken(DorisParserPLAN, 0)
}

func (s *ExplainContext) DUMP() antlr.TerminalNode {
	return s.GetToken(DorisParserDUMP, 0)
}

func (s *ExplainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterExplain(s)
	}
}

func (s *ExplainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitExplain(s)
	}
}

func (p *DorisParser) Explain() (localctx IExplainContext) {
	localctx = NewExplainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, DorisParserRULE_explain)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4424)
		p.ExplainCommand()
	}
	p.SetState(4426)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserALL || _la == DorisParserANALYZED || _la == DorisParserDISTRIBUTED || ((int64((_la-267)) & ^0x3f) == 0 && ((int64(1)<<(_la-267))&2260595906723841) != 0) || _la == DorisParserPHYSICAL || _la == DorisParserREWRITTEN || _la == DorisParserSHAPE {
		{
			p.SetState(4425)
			p.PlanType()
		}

	}
	p.SetState(4429)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserDUMP || _la == DorisParserGRAPH || _la == DorisParserPLAN || _la == DorisParserTREE || _la == DorisParserVERBOSE {
		{
			p.SetState(4428)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ExplainContext).level = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserDUMP || _la == DorisParserGRAPH || _la == DorisParserPLAN || _la == DorisParserTREE || _la == DorisParserVERBOSE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ExplainContext).level = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(4432)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPROCESS {
		{
			p.SetState(4431)
			p.Match(DorisParserPROCESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplainCommandContext is an interface to support dynamic dispatch.
type IExplainCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXPLAIN() antlr.TerminalNode
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode

	// IsExplainCommandContext differentiates from other interfaces.
	IsExplainCommandContext()
}

type ExplainCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainCommandContext() *ExplainCommandContext {
	var p = new(ExplainCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_explainCommand
	return p
}

func InitEmptyExplainCommandContext(p *ExplainCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_explainCommand
}

func (*ExplainCommandContext) IsExplainCommandContext() {}

func NewExplainCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainCommandContext {
	var p = new(ExplainCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_explainCommand

	return p
}

func (s *ExplainCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainCommandContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(DorisParserEXPLAIN, 0)
}

func (s *ExplainCommandContext) DESC() antlr.TerminalNode {
	return s.GetToken(DorisParserDESC, 0)
}

func (s *ExplainCommandContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(DorisParserDESCRIBE, 0)
}

func (s *ExplainCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplainCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterExplainCommand(s)
	}
}

func (s *ExplainCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitExplainCommand(s)
	}
}

func (p *DorisParser) ExplainCommand() (localctx IExplainCommandContext) {
	localctx = NewExplainCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, DorisParserRULE_explainCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4434)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&274877906947) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPlanTypeContext is an interface to support dynamic dispatch.
type IPlanTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARSED() antlr.TerminalNode
	ANALYZED() antlr.TerminalNode
	REWRITTEN() antlr.TerminalNode
	LOGICAL() antlr.TerminalNode
	OPTIMIZED() antlr.TerminalNode
	PHYSICAL() antlr.TerminalNode
	SHAPE() antlr.TerminalNode
	MEMO() antlr.TerminalNode
	DISTRIBUTED() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsPlanTypeContext differentiates from other interfaces.
	IsPlanTypeContext()
}

type PlanTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPlanTypeContext() *PlanTypeContext {
	var p = new(PlanTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_planType
	return p
}

func InitEmptyPlanTypeContext(p *PlanTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_planType
}

func (*PlanTypeContext) IsPlanTypeContext() {}

func NewPlanTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PlanTypeContext {
	var p = new(PlanTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_planType

	return p
}

func (s *PlanTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PlanTypeContext) PARSED() antlr.TerminalNode {
	return s.GetToken(DorisParserPARSED, 0)
}

func (s *PlanTypeContext) ANALYZED() antlr.TerminalNode {
	return s.GetToken(DorisParserANALYZED, 0)
}

func (s *PlanTypeContext) REWRITTEN() antlr.TerminalNode {
	return s.GetToken(DorisParserREWRITTEN, 0)
}

func (s *PlanTypeContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOGICAL, 0)
}

func (s *PlanTypeContext) OPTIMIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserOPTIMIZED, 0)
}

func (s *PlanTypeContext) PHYSICAL() antlr.TerminalNode {
	return s.GetToken(DorisParserPHYSICAL, 0)
}

func (s *PlanTypeContext) SHAPE() antlr.TerminalNode {
	return s.GetToken(DorisParserSHAPE, 0)
}

func (s *PlanTypeContext) MEMO() antlr.TerminalNode {
	return s.GetToken(DorisParserMEMO, 0)
}

func (s *PlanTypeContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTRIBUTED, 0)
}

func (s *PlanTypeContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *PlanTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PlanTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PlanTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPlanType(s)
	}
}

func (s *PlanTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPlanType(s)
	}
}

func (p *DorisParser) PlanType() (localctx IPlanTypeContext) {
	localctx = NewPlanTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, DorisParserRULE_planType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4436)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserALL || _la == DorisParserANALYZED || _la == DorisParserDISTRIBUTED || ((int64((_la-267)) & ^0x3f) == 0 && ((int64(1)<<(_la-267))&2260595906723841) != 0) || _la == DorisParserPHYSICAL || _la == DorisParserREWRITTEN || _la == DorisParserSHAPE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplayCommandContext is an interface to support dynamic dispatch.
type IReplayCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLAN() antlr.TerminalNode
	REPLAYER() antlr.TerminalNode
	ReplayType() IReplayTypeContext

	// IsReplayCommandContext differentiates from other interfaces.
	IsReplayCommandContext()
}

type ReplayCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplayCommandContext() *ReplayCommandContext {
	var p = new(ReplayCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_replayCommand
	return p
}

func InitEmptyReplayCommandContext(p *ReplayCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_replayCommand
}

func (*ReplayCommandContext) IsReplayCommandContext() {}

func NewReplayCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplayCommandContext {
	var p = new(ReplayCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_replayCommand

	return p
}

func (s *ReplayCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplayCommandContext) PLAN() antlr.TerminalNode {
	return s.GetToken(DorisParserPLAN, 0)
}

func (s *ReplayCommandContext) REPLAYER() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLAYER, 0)
}

func (s *ReplayCommandContext) ReplayType() IReplayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplayTypeContext)
}

func (s *ReplayCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplayCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplayCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterReplayCommand(s)
	}
}

func (s *ReplayCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitReplayCommand(s)
	}
}

func (p *DorisParser) ReplayCommand() (localctx IReplayCommandContext) {
	localctx = NewReplayCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, DorisParserRULE_replayCommand)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4438)
		p.Match(DorisParserPLAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4439)
		p.Match(DorisParserREPLAYER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4440)
		p.ReplayType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplayTypeContext is an interface to support dynamic dispatch.
type IReplayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFilePath returns the filePath token.
	GetFilePath() antlr.Token

	// SetFilePath sets the filePath token.
	SetFilePath(antlr.Token)

	// Getter signatures
	DUMP() antlr.TerminalNode
	Query() IQueryContext
	PLAY() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsReplayTypeContext differentiates from other interfaces.
	IsReplayTypeContext()
}

type ReplayTypeContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	filePath antlr.Token
}

func NewEmptyReplayTypeContext() *ReplayTypeContext {
	var p = new(ReplayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_replayType
	return p
}

func InitEmptyReplayTypeContext(p *ReplayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_replayType
}

func (*ReplayTypeContext) IsReplayTypeContext() {}

func NewReplayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplayTypeContext {
	var p = new(ReplayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_replayType

	return p
}

func (s *ReplayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplayTypeContext) GetFilePath() antlr.Token { return s.filePath }

func (s *ReplayTypeContext) SetFilePath(v antlr.Token) { s.filePath = v }

func (s *ReplayTypeContext) DUMP() antlr.TerminalNode {
	return s.GetToken(DorisParserDUMP, 0)
}

func (s *ReplayTypeContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *ReplayTypeContext) PLAY() antlr.TerminalNode {
	return s.GetToken(DorisParserPLAY, 0)
}

func (s *ReplayTypeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ReplayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterReplayType(s)
	}
}

func (s *ReplayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitReplayType(s)
	}
}

func (p *DorisParser) ReplayType() (localctx IReplayTypeContext) {
	localctx = NewReplayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, DorisParserRULE_replayType)
	p.SetState(4446)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserDUMP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4442)
			p.Match(DorisParserDUMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4443)
			p.Query()
		}

	case DorisParserPLAY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4444)
			p.Match(DorisParserPLAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4445)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ReplayTypeContext).filePath = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMergeTypeContext is an interface to support dynamic dispatch.
type IMergeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	APPEND() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	MERGE() antlr.TerminalNode

	// IsMergeTypeContext differentiates from other interfaces.
	IsMergeTypeContext()
}

type MergeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeTypeContext() *MergeTypeContext {
	var p = new(MergeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_mergeType
	return p
}

func InitEmptyMergeTypeContext(p *MergeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_mergeType
}

func (*MergeTypeContext) IsMergeTypeContext() {}

func NewMergeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeTypeContext {
	var p = new(MergeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_mergeType

	return p
}

func (s *MergeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeTypeContext) APPEND() antlr.TerminalNode {
	return s.GetToken(DorisParserAPPEND, 0)
}

func (s *MergeTypeContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisParserDELETE, 0)
}

func (s *MergeTypeContext) MERGE() antlr.TerminalNode {
	return s.GetToken(DorisParserMERGE, 0)
}

func (s *MergeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMergeType(s)
	}
}

func (s *MergeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMergeType(s)
	}
}

func (p *DorisParser) MergeType() (localctx IMergeTypeContext) {
	localctx = NewMergeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, DorisParserRULE_mergeType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4448)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserAPPEND || _la == DorisParserDELETE || _la == DorisParserMERGE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPreFilterClauseContext is an interface to support dynamic dispatch.
type IPreFilterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRECEDING() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	Expression() IExpressionContext

	// IsPreFilterClauseContext differentiates from other interfaces.
	IsPreFilterClauseContext()
}

type PreFilterClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreFilterClauseContext() *PreFilterClauseContext {
	var p = new(PreFilterClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_preFilterClause
	return p
}

func InitEmptyPreFilterClauseContext(p *PreFilterClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_preFilterClause
}

func (*PreFilterClauseContext) IsPreFilterClauseContext() {}

func NewPreFilterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PreFilterClauseContext {
	var p = new(PreFilterClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_preFilterClause

	return p
}

func (s *PreFilterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PreFilterClauseContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(DorisParserPRECEDING, 0)
}

func (s *PreFilterClauseContext) FILTER() antlr.TerminalNode {
	return s.GetToken(DorisParserFILTER, 0)
}

func (s *PreFilterClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PreFilterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreFilterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PreFilterClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPreFilterClause(s)
	}
}

func (s *PreFilterClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPreFilterClause(s)
	}
}

func (p *DorisParser) PreFilterClause() (localctx IPreFilterClauseContext) {
	localctx = NewPreFilterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, DorisParserRULE_preFilterClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4450)
		p.Match(DorisParserPRECEDING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4451)
		p.Match(DorisParserFILTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4452)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteOnClauseContext is an interface to support dynamic dispatch.
type IDeleteOnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	ON() antlr.TerminalNode
	Expression() IExpressionContext

	// IsDeleteOnClauseContext differentiates from other interfaces.
	IsDeleteOnClauseContext()
}

type DeleteOnClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteOnClauseContext() *DeleteOnClauseContext {
	var p = new(DeleteOnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_deleteOnClause
	return p
}

func InitEmptyDeleteOnClauseContext(p *DeleteOnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_deleteOnClause
}

func (*DeleteOnClauseContext) IsDeleteOnClauseContext() {}

func NewDeleteOnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteOnClauseContext {
	var p = new(DeleteOnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_deleteOnClause

	return p
}

func (s *DeleteOnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteOnClauseContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisParserDELETE, 0)
}

func (s *DeleteOnClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *DeleteOnClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DeleteOnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteOnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteOnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDeleteOnClause(s)
	}
}

func (s *DeleteOnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDeleteOnClause(s)
	}
}

func (p *DorisParser) DeleteOnClause() (localctx IDeleteOnClauseContext) {
	localctx = NewDeleteOnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, DorisParserRULE_deleteOnClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4454)
		p.Match(DorisParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4455)
		p.Match(DorisParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4456)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISequenceColClauseContext is an interface to support dynamic dispatch.
type ISequenceColClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsSequenceColClauseContext differentiates from other interfaces.
	IsSequenceColClauseContext()
}

type SequenceColClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequenceColClauseContext() *SequenceColClauseContext {
	var p = new(SequenceColClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sequenceColClause
	return p
}

func InitEmptySequenceColClauseContext(p *SequenceColClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sequenceColClause
}

func (*SequenceColClauseContext) IsSequenceColClauseContext() {}

func NewSequenceColClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SequenceColClauseContext {
	var p = new(SequenceColClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_sequenceColClause

	return p
}

func (s *SequenceColClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SequenceColClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisParserORDER, 0)
}

func (s *SequenceColClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *SequenceColClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SequenceColClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SequenceColClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SequenceColClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSequenceColClause(s)
	}
}

func (s *SequenceColClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSequenceColClause(s)
	}
}

func (p *DorisParser) SequenceColClause() (localctx ISequenceColClauseContext) {
	localctx = NewSequenceColClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, DorisParserRULE_sequenceColClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4458)
		p.Match(DorisParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4459)
		p.Match(DorisParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4460)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColFromPathContext is an interface to support dynamic dispatch.
type IColFromPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLUMNS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	PATH() antlr.TerminalNode
	AS() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsColFromPathContext differentiates from other interfaces.
	IsColFromPathContext()
}

type ColFromPathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColFromPathContext() *ColFromPathContext {
	var p = new(ColFromPathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_colFromPath
	return p
}

func InitEmptyColFromPathContext(p *ColFromPathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_colFromPath
}

func (*ColFromPathContext) IsColFromPathContext() {}

func NewColFromPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColFromPathContext {
	var p = new(ColFromPathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_colFromPath

	return p
}

func (s *ColFromPathContext) GetParser() antlr.Parser { return s.parser }

func (s *ColFromPathContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMNS, 0)
}

func (s *ColFromPathContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ColFromPathContext) PATH() antlr.TerminalNode {
	return s.GetToken(DorisParserPATH, 0)
}

func (s *ColFromPathContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *ColFromPathContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ColFromPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColFromPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColFromPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterColFromPath(s)
	}
}

func (s *ColFromPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitColFromPath(s)
	}
}

func (p *DorisParser) ColFromPath() (localctx IColFromPathContext) {
	localctx = NewColFromPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, DorisParserRULE_colFromPath)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4462)
		p.Match(DorisParserCOLUMNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4463)
		p.Match(DorisParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4464)
		p.Match(DorisParserPATH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4465)
		p.Match(DorisParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4466)
		p.IdentifierList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColMappingListContext is an interface to support dynamic dispatch.
type IColMappingListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_mappingExpr returns the _mappingExpr rule contexts.
	Get_mappingExpr() IMappingExprContext

	// Set_mappingExpr sets the _mappingExpr rule contexts.
	Set_mappingExpr(IMappingExprContext)

	// GetMappingSet returns the mappingSet rule context list.
	GetMappingSet() []IMappingExprContext

	// SetMappingSet sets the mappingSet rule context list.
	SetMappingSet([]IMappingExprContext)

	// Getter signatures
	SET() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllMappingExpr() []IMappingExprContext
	MappingExpr(i int) IMappingExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColMappingListContext differentiates from other interfaces.
	IsColMappingListContext()
}

type ColMappingListContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	_mappingExpr IMappingExprContext
	mappingSet   []IMappingExprContext
}

func NewEmptyColMappingListContext() *ColMappingListContext {
	var p = new(ColMappingListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_colMappingList
	return p
}

func InitEmptyColMappingListContext(p *ColMappingListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_colMappingList
}

func (*ColMappingListContext) IsColMappingListContext() {}

func NewColMappingListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColMappingListContext {
	var p = new(ColMappingListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_colMappingList

	return p
}

func (s *ColMappingListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColMappingListContext) Get_mappingExpr() IMappingExprContext { return s._mappingExpr }

func (s *ColMappingListContext) Set_mappingExpr(v IMappingExprContext) { s._mappingExpr = v }

func (s *ColMappingListContext) GetMappingSet() []IMappingExprContext { return s.mappingSet }

func (s *ColMappingListContext) SetMappingSet(v []IMappingExprContext) { s.mappingSet = v }

func (s *ColMappingListContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *ColMappingListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ColMappingListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ColMappingListContext) AllMappingExpr() []IMappingExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMappingExprContext); ok {
			len++
		}
	}

	tst := make([]IMappingExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMappingExprContext); ok {
			tst[i] = t.(IMappingExprContext)
			i++
		}
	}

	return tst
}

func (s *ColMappingListContext) MappingExpr(i int) IMappingExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMappingExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMappingExprContext)
}

func (s *ColMappingListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ColMappingListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ColMappingListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColMappingListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColMappingListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterColMappingList(s)
	}
}

func (s *ColMappingListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitColMappingList(s)
	}
}

func (p *DorisParser) ColMappingList() (localctx IColMappingListContext) {
	localctx = NewColMappingListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, DorisParserRULE_colMappingList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4468)
		p.Match(DorisParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4469)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4470)

		var _x = p.MappingExpr()

		localctx.(*ColMappingListContext)._mappingExpr = _x
	}
	localctx.(*ColMappingListContext).mappingSet = append(localctx.(*ColMappingListContext).mappingSet, localctx.(*ColMappingListContext)._mappingExpr)
	p.SetState(4475)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(4471)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4472)

			var _x = p.MappingExpr()

			localctx.(*ColMappingListContext)._mappingExpr = _x
		}
		localctx.(*ColMappingListContext).mappingSet = append(localctx.(*ColMappingListContext).mappingSet, localctx.(*ColMappingListContext)._mappingExpr)

		p.SetState(4477)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4478)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMappingExprContext is an interface to support dynamic dispatch.
type IMappingExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMappingCol returns the mappingCol rule contexts.
	GetMappingCol() IIdentifierContext

	// SetMappingCol sets the mappingCol rule contexts.
	SetMappingCol(IIdentifierContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	Expression() IExpressionContext
	Identifier() IIdentifierContext

	// IsMappingExprContext differentiates from other interfaces.
	IsMappingExprContext()
}

type MappingExprContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	mappingCol IIdentifierContext
}

func NewEmptyMappingExprContext() *MappingExprContext {
	var p = new(MappingExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_mappingExpr
	return p
}

func InitEmptyMappingExprContext(p *MappingExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_mappingExpr
}

func (*MappingExprContext) IsMappingExprContext() {}

func NewMappingExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MappingExprContext {
	var p = new(MappingExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_mappingExpr

	return p
}

func (s *MappingExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MappingExprContext) GetMappingCol() IIdentifierContext { return s.mappingCol }

func (s *MappingExprContext) SetMappingCol(v IIdentifierContext) { s.mappingCol = v }

func (s *MappingExprContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *MappingExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MappingExprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MappingExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MappingExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MappingExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMappingExpr(s)
	}
}

func (s *MappingExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMappingExpr(s)
	}
}

func (p *DorisParser) MappingExpr() (localctx IMappingExprContext) {
	localctx = NewMappingExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, DorisParserRULE_mappingExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4480)

		var _x = p.Identifier()

		localctx.(*MappingExprContext).mappingCol = _x
	}
	{
		p.SetState(4481)
		p.Match(DorisParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4482)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithRemoteStorageSystemContext is an interface to support dynamic dispatch.
type IWithRemoteStorageSystemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBrokerProperties returns the brokerProperties rule contexts.
	GetBrokerProperties() IPropertyItemListContext

	// GetBrokerName returns the brokerName rule contexts.
	GetBrokerName() IIdentifierOrTextContext

	// SetBrokerProperties sets the brokerProperties rule contexts.
	SetBrokerProperties(IPropertyItemListContext)

	// SetBrokerName sets the brokerName rule contexts.
	SetBrokerName(IIdentifierOrTextContext)

	// Getter signatures
	ResourceDesc() IResourceDescContext
	WITH() antlr.TerminalNode
	S3() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	PropertyItemList() IPropertyItemListContext
	HDFS() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	IdentifierOrText() IIdentifierOrTextContext

	// IsWithRemoteStorageSystemContext differentiates from other interfaces.
	IsWithRemoteStorageSystemContext()
}

type WithRemoteStorageSystemContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	brokerProperties IPropertyItemListContext
	brokerName       IIdentifierOrTextContext
}

func NewEmptyWithRemoteStorageSystemContext() *WithRemoteStorageSystemContext {
	var p = new(WithRemoteStorageSystemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_withRemoteStorageSystem
	return p
}

func InitEmptyWithRemoteStorageSystemContext(p *WithRemoteStorageSystemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_withRemoteStorageSystem
}

func (*WithRemoteStorageSystemContext) IsWithRemoteStorageSystemContext() {}

func NewWithRemoteStorageSystemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithRemoteStorageSystemContext {
	var p = new(WithRemoteStorageSystemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_withRemoteStorageSystem

	return p
}

func (s *WithRemoteStorageSystemContext) GetParser() antlr.Parser { return s.parser }

func (s *WithRemoteStorageSystemContext) GetBrokerProperties() IPropertyItemListContext {
	return s.brokerProperties
}

func (s *WithRemoteStorageSystemContext) GetBrokerName() IIdentifierOrTextContext {
	return s.brokerName
}

func (s *WithRemoteStorageSystemContext) SetBrokerProperties(v IPropertyItemListContext) {
	s.brokerProperties = v
}

func (s *WithRemoteStorageSystemContext) SetBrokerName(v IIdentifierOrTextContext) { s.brokerName = v }

func (s *WithRemoteStorageSystemContext) ResourceDesc() IResourceDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceDescContext)
}

func (s *WithRemoteStorageSystemContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *WithRemoteStorageSystemContext) S3() antlr.TerminalNode {
	return s.GetToken(DorisParserS3, 0)
}

func (s *WithRemoteStorageSystemContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *WithRemoteStorageSystemContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *WithRemoteStorageSystemContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *WithRemoteStorageSystemContext) HDFS() antlr.TerminalNode {
	return s.GetToken(DorisParserHDFS, 0)
}

func (s *WithRemoteStorageSystemContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *WithRemoteStorageSystemContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserBROKER, 0)
}

func (s *WithRemoteStorageSystemContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *WithRemoteStorageSystemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithRemoteStorageSystemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithRemoteStorageSystemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWithRemoteStorageSystem(s)
	}
}

func (s *WithRemoteStorageSystemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWithRemoteStorageSystem(s)
	}
}

func (p *DorisParser) WithRemoteStorageSystem() (localctx IWithRemoteStorageSystemContext) {
	localctx = NewWithRemoteStorageSystemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, DorisParserRULE_withRemoteStorageSystem)
	var _la int

	p.SetState(4512)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 647, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4484)
			p.ResourceDesc()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4485)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4486)
			p.Match(DorisParserS3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4487)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4488)

			var _x = p.PropertyItemList()

			localctx.(*WithRemoteStorageSystemContext).brokerProperties = _x
		}
		{
			p.SetState(4489)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4491)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4492)
			p.Match(DorisParserHDFS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4493)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4494)

			var _x = p.PropertyItemList()

			localctx.(*WithRemoteStorageSystemContext).brokerProperties = _x
		}
		{
			p.SetState(4495)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4497)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4498)
			p.Match(DorisParserLOCAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4499)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4500)

			var _x = p.PropertyItemList()

			localctx.(*WithRemoteStorageSystemContext).brokerProperties = _x
		}
		{
			p.SetState(4501)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4503)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4504)
			p.Match(DorisParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4505)

			var _x = p.IdentifierOrText()

			localctx.(*WithRemoteStorageSystemContext).brokerName = _x
		}
		p.SetState(4510)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(4506)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4507)

				var _x = p.PropertyItemList()

				localctx.(*WithRemoteStorageSystemContext).brokerProperties = _x
			}
			{
				p.SetState(4508)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceDescContext is an interface to support dynamic dispatch.
type IResourceDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResourceName returns the resourceName rule contexts.
	GetResourceName() IIdentifierOrTextContext

	// SetResourceName sets the resourceName rule contexts.
	SetResourceName(IIdentifierOrTextContext)

	// Getter signatures
	WITH() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	IdentifierOrText() IIdentifierOrTextContext
	LEFT_PAREN() antlr.TerminalNode
	PropertyItemList() IPropertyItemListContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsResourceDescContext differentiates from other interfaces.
	IsResourceDescContext()
}

type ResourceDescContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	resourceName IIdentifierOrTextContext
}

func NewEmptyResourceDescContext() *ResourceDescContext {
	var p = new(ResourceDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_resourceDesc
	return p
}

func InitEmptyResourceDescContext(p *ResourceDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_resourceDesc
}

func (*ResourceDescContext) IsResourceDescContext() {}

func NewResourceDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceDescContext {
	var p = new(ResourceDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_resourceDesc

	return p
}

func (s *ResourceDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceDescContext) GetResourceName() IIdentifierOrTextContext { return s.resourceName }

func (s *ResourceDescContext) SetResourceName(v IIdentifierOrTextContext) { s.resourceName = v }

func (s *ResourceDescContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *ResourceDescContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCE, 0)
}

func (s *ResourceDescContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *ResourceDescContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ResourceDescContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *ResourceDescContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ResourceDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterResourceDesc(s)
	}
}

func (s *ResourceDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitResourceDesc(s)
	}
}

func (p *DorisParser) ResourceDesc() (localctx IResourceDescContext) {
	localctx = NewResourceDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, DorisParserRULE_resourceDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4514)
		p.Match(DorisParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4515)
		p.Match(DorisParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4516)

		var _x = p.IdentifierOrText()

		localctx.(*ResourceDescContext).resourceName = _x
	}
	p.SetState(4521)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLEFT_PAREN {
		{
			p.SetState(4517)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4518)
			p.PropertyItemList()
		}
		{
			p.SetState(4519)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMysqlDataDescContext is an interface to support dynamic dispatch.
type IMysqlDataDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFilePath returns the filePath token.
	GetFilePath() antlr.Token

	// GetComma returns the comma token.
	GetComma() antlr.Token

	// GetSeparator returns the separator token.
	GetSeparator() antlr.Token

	// SetFilePath sets the filePath token.
	SetFilePath(antlr.Token)

	// SetComma sets the comma token.
	SetComma(antlr.Token)

	// SetSeparator sets the separator token.
	SetSeparator(antlr.Token)

	// GetTableName returns the tableName rule contexts.
	GetTableName() IMultipartIdentifierContext

	// GetPartition returns the partition rule contexts.
	GetPartition() IIdentifierListContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IIdentifierListContext

	// SetTableName sets the tableName rule contexts.
	SetTableName(IMultipartIdentifierContext)

	// SetPartition sets the partition rule contexts.
	SetPartition(IIdentifierListContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IIdentifierListContext)

	// Getter signatures
	DATA() antlr.TerminalNode
	INFILE() antlr.TerminalNode
	INTO() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext
	LOCAL() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	AllTERMINATED() []antlr.TerminalNode
	TERMINATED(i int) antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	LINES() antlr.TerminalNode
	SkipLines() ISkipLinesContext
	ColMappingList() IColMappingListContext
	PropertyClause() IPropertyClauseContext
	AllIdentifierList() []IIdentifierListContext
	IdentifierList(i int) IIdentifierListContext

	// IsMysqlDataDescContext differentiates from other interfaces.
	IsMysqlDataDescContext()
}

type MysqlDataDescContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	filePath  antlr.Token
	tableName IMultipartIdentifierContext
	partition IIdentifierListContext
	comma     antlr.Token
	separator antlr.Token
	columns   IIdentifierListContext
}

func NewEmptyMysqlDataDescContext() *MysqlDataDescContext {
	var p = new(MysqlDataDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_mysqlDataDesc
	return p
}

func InitEmptyMysqlDataDescContext(p *MysqlDataDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_mysqlDataDesc
}

func (*MysqlDataDescContext) IsMysqlDataDescContext() {}

func NewMysqlDataDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MysqlDataDescContext {
	var p = new(MysqlDataDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_mysqlDataDesc

	return p
}

func (s *MysqlDataDescContext) GetParser() antlr.Parser { return s.parser }

func (s *MysqlDataDescContext) GetFilePath() antlr.Token { return s.filePath }

func (s *MysqlDataDescContext) GetComma() antlr.Token { return s.comma }

func (s *MysqlDataDescContext) GetSeparator() antlr.Token { return s.separator }

func (s *MysqlDataDescContext) SetFilePath(v antlr.Token) { s.filePath = v }

func (s *MysqlDataDescContext) SetComma(v antlr.Token) { s.comma = v }

func (s *MysqlDataDescContext) SetSeparator(v antlr.Token) { s.separator = v }

func (s *MysqlDataDescContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *MysqlDataDescContext) GetPartition() IIdentifierListContext { return s.partition }

func (s *MysqlDataDescContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *MysqlDataDescContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *MysqlDataDescContext) SetPartition(v IIdentifierListContext) { s.partition = v }

func (s *MysqlDataDescContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *MysqlDataDescContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserDATA, 0)
}

func (s *MysqlDataDescContext) INFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserINFILE, 0)
}

func (s *MysqlDataDescContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserINTO, 0)
}

func (s *MysqlDataDescContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *MysqlDataDescContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *MysqlDataDescContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *MysqlDataDescContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *MysqlDataDescContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *MysqlDataDescContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *MysqlDataDescContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMNS, 0)
}

func (s *MysqlDataDescContext) AllTERMINATED() []antlr.TerminalNode {
	return s.GetTokens(DorisParserTERMINATED)
}

func (s *MysqlDataDescContext) TERMINATED(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserTERMINATED, i)
}

func (s *MysqlDataDescContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(DorisParserBY)
}

func (s *MysqlDataDescContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserBY, i)
}

func (s *MysqlDataDescContext) LINES() antlr.TerminalNode {
	return s.GetToken(DorisParserLINES, 0)
}

func (s *MysqlDataDescContext) SkipLines() ISkipLinesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkipLinesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkipLinesContext)
}

func (s *MysqlDataDescContext) ColMappingList() IColMappingListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColMappingListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColMappingListContext)
}

func (s *MysqlDataDescContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *MysqlDataDescContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *MysqlDataDescContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *MysqlDataDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MysqlDataDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MysqlDataDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMysqlDataDesc(s)
	}
}

func (s *MysqlDataDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMysqlDataDesc(s)
	}
}

func (p *DorisParser) MysqlDataDesc() (localctx IMysqlDataDescContext) {
	localctx = NewMysqlDataDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, DorisParserRULE_mysqlDataDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4523)
		p.Match(DorisParserDATA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4525)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLOCAL {
		{
			p.SetState(4524)
			p.Match(DorisParserLOCAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4527)
		p.Match(DorisParserINFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4528)

		var _m = p.Match(DorisParserSTRING_LITERAL)

		localctx.(*MysqlDataDescContext).filePath = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4529)
		p.Match(DorisParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4530)
		p.Match(DorisParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4531)

		var _x = p.MultipartIdentifier()

		localctx.(*MysqlDataDescContext).tableName = _x
	}
	p.SetState(4534)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPARTITION {
		{
			p.SetState(4532)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4533)

			var _x = p.IdentifierList()

			localctx.(*MysqlDataDescContext).partition = _x
		}

	}
	p.SetState(4540)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserCOLUMNS {
		{
			p.SetState(4536)
			p.Match(DorisParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4537)
			p.Match(DorisParserTERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4538)
			p.Match(DorisParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4539)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*MysqlDataDescContext).comma = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4546)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLINES {
		{
			p.SetState(4542)
			p.Match(DorisParserLINES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4543)
			p.Match(DorisParserTERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4544)
			p.Match(DorisParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4545)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*MysqlDataDescContext).separator = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4549)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserIGNORE {
		{
			p.SetState(4548)
			p.SkipLines()
		}

	}
	p.SetState(4552)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLEFT_PAREN {
		{
			p.SetState(4551)

			var _x = p.IdentifierList()

			localctx.(*MysqlDataDescContext).columns = _x
		}

	}
	p.SetState(4555)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserSET {
		{
			p.SetState(4554)
			p.ColMappingList()
		}

	}
	p.SetState(4558)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 656, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4557)
			p.PropertyClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISkipLinesContext is an interface to support dynamic dispatch.
type ISkipLinesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLines returns the lines token.
	GetLines() antlr.Token

	// SetLines sets the lines token.
	SetLines(antlr.Token)

	// Getter signatures
	IGNORE() antlr.TerminalNode
	LINES() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	ROWS() antlr.TerminalNode

	// IsSkipLinesContext differentiates from other interfaces.
	IsSkipLinesContext()
}

type SkipLinesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	lines  antlr.Token
}

func NewEmptySkipLinesContext() *SkipLinesContext {
	var p = new(SkipLinesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_skipLines
	return p
}

func InitEmptySkipLinesContext(p *SkipLinesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_skipLines
}

func (*SkipLinesContext) IsSkipLinesContext() {}

func NewSkipLinesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SkipLinesContext {
	var p = new(SkipLinesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_skipLines

	return p
}

func (s *SkipLinesContext) GetParser() antlr.Parser { return s.parser }

func (s *SkipLinesContext) GetLines() antlr.Token { return s.lines }

func (s *SkipLinesContext) SetLines(v antlr.Token) { s.lines = v }

func (s *SkipLinesContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(DorisParserIGNORE, 0)
}

func (s *SkipLinesContext) LINES() antlr.TerminalNode {
	return s.GetToken(DorisParserLINES, 0)
}

func (s *SkipLinesContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *SkipLinesContext) ROWS() antlr.TerminalNode {
	return s.GetToken(DorisParserROWS, 0)
}

func (s *SkipLinesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SkipLinesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SkipLinesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSkipLines(s)
	}
}

func (s *SkipLinesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSkipLines(s)
	}
}

func (p *DorisParser) SkipLines() (localctx ISkipLinesContext) {
	localctx = NewSkipLinesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, DorisParserRULE_skipLines)
	p.SetState(4566)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 657, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4560)
			p.Match(DorisParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4561)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*SkipLinesContext).lines = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4562)
			p.Match(DorisParserLINES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4563)
			p.Match(DorisParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4564)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*SkipLinesContext).lines = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4565)
			p.Match(DorisParserROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOutFileClauseContext is an interface to support dynamic dispatch.
type IOutFileClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFilePath returns the filePath rule contexts.
	GetFilePath() IConstantContext

	// GetFormat returns the format rule contexts.
	GetFormat() IIdentifierContext

	// SetFilePath sets the filePath rule contexts.
	SetFilePath(IConstantContext)

	// SetFormat sets the format rule contexts.
	SetFormat(IIdentifierContext)

	// Getter signatures
	INTO() antlr.TerminalNode
	OUTFILE() antlr.TerminalNode
	Constant() IConstantContext
	FORMAT() antlr.TerminalNode
	AS() antlr.TerminalNode
	PropertyClause() IPropertyClauseContext
	Identifier() IIdentifierContext

	// IsOutFileClauseContext differentiates from other interfaces.
	IsOutFileClauseContext()
}

type OutFileClauseContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	filePath IConstantContext
	format   IIdentifierContext
}

func NewEmptyOutFileClauseContext() *OutFileClauseContext {
	var p = new(OutFileClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_outFileClause
	return p
}

func InitEmptyOutFileClauseContext(p *OutFileClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_outFileClause
}

func (*OutFileClauseContext) IsOutFileClauseContext() {}

func NewOutFileClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OutFileClauseContext {
	var p = new(OutFileClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_outFileClause

	return p
}

func (s *OutFileClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OutFileClauseContext) GetFilePath() IConstantContext { return s.filePath }

func (s *OutFileClauseContext) GetFormat() IIdentifierContext { return s.format }

func (s *OutFileClauseContext) SetFilePath(v IConstantContext) { s.filePath = v }

func (s *OutFileClauseContext) SetFormat(v IIdentifierContext) { s.format = v }

func (s *OutFileClauseContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserINTO, 0)
}

func (s *OutFileClauseContext) OUTFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserOUTFILE, 0)
}

func (s *OutFileClauseContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *OutFileClauseContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DorisParserFORMAT, 0)
}

func (s *OutFileClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *OutFileClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *OutFileClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *OutFileClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OutFileClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OutFileClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterOutFileClause(s)
	}
}

func (s *OutFileClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitOutFileClause(s)
	}
}

func (p *DorisParser) OutFileClause() (localctx IOutFileClauseContext) {
	localctx = NewOutFileClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, DorisParserRULE_outFileClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4568)
		p.Match(DorisParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4569)
		p.Match(DorisParserOUTFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4570)

		var _x = p.Constant()

		localctx.(*OutFileClauseContext).filePath = _x
	}
	p.SetState(4574)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserFORMAT {
		{
			p.SetState(4571)
			p.Match(DorisParserFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4572)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4573)

			var _x = p.Identifier()

			localctx.(*OutFileClauseContext).format = _x
		}

	}
	p.SetState(4577)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPROPERTIES {
		{
			p.SetState(4576)
			p.PropertyClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryTerm() IQueryTermContext
	QueryOrganization() IQueryOrganizationContext
	Cte() ICteContext

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_query
	return p
}

func InitEmptyQueryContext(p *QueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_query
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) QueryTerm() IQueryTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *QueryContext) QueryOrganization() IQueryOrganizationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryOrganizationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryOrganizationContext)
}

func (s *QueryContext) Cte() ICteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (p *DorisParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, DorisParserRULE_query)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4580)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserWITH {
		{
			p.SetState(4579)
			p.Cte()
		}

	}
	{
		p.SetState(4582)
		p.queryTerm(0)
	}
	{
		p.SetState(4583)
		p.QueryOrganization()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryTermContext is an interface to support dynamic dispatch.
type IQueryTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQueryTermContext differentiates from other interfaces.
	IsQueryTermContext()
}

type QueryTermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryTermContext() *QueryTermContext {
	var p = new(QueryTermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_queryTerm
	return p
}

func InitEmptyQueryTermContext(p *QueryTermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_queryTerm
}

func (*QueryTermContext) IsQueryTermContext() {}

func NewQueryTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryTermContext {
	var p = new(QueryTermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_queryTerm

	return p
}

func (s *QueryTermContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryTermContext) CopyAll(ctx *QueryTermContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QueryTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QueryTermDefaultContext struct {
	QueryTermContext
}

func NewQueryTermDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryTermDefaultContext {
	var p = new(QueryTermDefaultContext)

	InitEmptyQueryTermContext(&p.QueryTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryTermContext))

	return p
}

func (s *QueryTermDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermDefaultContext) QueryPrimary() IQueryPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryPrimaryContext)
}

func (s *QueryTermDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterQueryTermDefault(s)
	}
}

func (s *QueryTermDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitQueryTermDefault(s)
	}
}

type SetOperationContext struct {
	QueryTermContext
	left     IQueryTermContext
	operator antlr.Token
	right    IQueryTermContext
}

func NewSetOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetOperationContext {
	var p = new(SetOperationContext)

	InitEmptyQueryTermContext(&p.QueryTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryTermContext))

	return p
}

func (s *SetOperationContext) GetOperator() antlr.Token { return s.operator }

func (s *SetOperationContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *SetOperationContext) GetLeft() IQueryTermContext { return s.left }

func (s *SetOperationContext) GetRight() IQueryTermContext { return s.right }

func (s *SetOperationContext) SetLeft(v IQueryTermContext) { s.left = v }

func (s *SetOperationContext) SetRight(v IQueryTermContext) { s.right = v }

func (s *SetOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOperationContext) AllQueryTerm() []IQueryTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQueryTermContext); ok {
			len++
		}
	}

	tst := make([]IQueryTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQueryTermContext); ok {
			tst[i] = t.(IQueryTermContext)
			i++
		}
	}

	return tst
}

func (s *SetOperationContext) QueryTerm(i int) IQueryTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *SetOperationContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(DorisParserINTERSECT, 0)
}

func (s *SetOperationContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *SetOperationContext) UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserUNION, 0)
}

func (s *SetOperationContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(DorisParserEXCEPT, 0)
}

func (s *SetOperationContext) MINUS() antlr.TerminalNode {
	return s.GetToken(DorisParserMINUS, 0)
}

func (s *SetOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetOperation(s)
	}
}

func (s *SetOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetOperation(s)
	}
}

func (p *DorisParser) QueryTerm() (localctx IQueryTermContext) {
	return p.queryTerm(0)
}

func (p *DorisParser) queryTerm(_p int) (localctx IQueryTermContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewQueryTermContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IQueryTermContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 226
	p.EnterRecursionRule(localctx, 226, DorisParserRULE_queryTerm, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewQueryTermDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(4586)
		p.QueryPrimary()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(4602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 664, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(4600)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 663, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSetOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_queryTerm)
				p.SetState(4588)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(4589)

					var _m = p.Match(DorisParserINTERSECT)

					localctx.(*SetOperationContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(4591)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisParserALL || _la == DorisParserDISTINCT {
					{
						p.SetState(4590)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(4593)

					var _x = p.queryTerm(3)

					localctx.(*SetOperationContext).right = _x
				}

			case 2:
				localctx = NewSetOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_queryTerm)
				p.SetState(4594)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(4595)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*SetOperationContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisParserEXCEPT || _la == DorisParserMINUS || _la == DorisParserUNION) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*SetOperationContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(4597)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisParserALL || _la == DorisParserDISTINCT {
					{
						p.SetState(4596)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(4599)

					var _x = p.queryTerm(2)

					localctx.(*SetOperationContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(4604)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 664, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetQuantifierContext is an interface to support dynamic dispatch.
type ISetQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTINCT() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsSetQuantifierContext differentiates from other interfaces.
	IsSetQuantifierContext()
}

type SetQuantifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetQuantifierContext() *SetQuantifierContext {
	var p = new(SetQuantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_setQuantifier
	return p
}

func InitEmptySetQuantifierContext(p *SetQuantifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_setQuantifier
}

func (*SetQuantifierContext) IsSetQuantifierContext() {}

func NewSetQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetQuantifierContext {
	var p = new(SetQuantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_setQuantifier

	return p
}

func (s *SetQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SetQuantifierContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTINCT, 0)
}

func (s *SetQuantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *SetQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetQuantifier(s)
	}
}

func (p *DorisParser) SetQuantifier() (localctx ISetQuantifierContext) {
	localctx = NewSetQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, DorisParserRULE_setQuantifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4605)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserALL || _la == DorisParserDISTINCT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryPrimaryContext is an interface to support dynamic dispatch.
type IQueryPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQueryPrimaryContext differentiates from other interfaces.
	IsQueryPrimaryContext()
}

type QueryPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryPrimaryContext() *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_queryPrimary
	return p
}

func InitEmptyQueryPrimaryContext(p *QueryPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_queryPrimary
}

func (*QueryPrimaryContext) IsQueryPrimaryContext() {}

func NewQueryPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_queryPrimary

	return p
}

func (s *QueryPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryPrimaryContext) CopyAll(ctx *QueryPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QueryPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryContext struct {
	QueryPrimaryContext
}

func NewSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryContext {
	var p = new(SubqueryContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *SubqueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *SubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSubquery(s)
	}
}

func (s *SubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSubquery(s)
	}
}

type ValuesTableContext struct {
	QueryPrimaryContext
}

func NewValuesTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValuesTableContext {
	var p = new(ValuesTableContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *ValuesTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesTableContext) InlineTable() IInlineTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineTableContext)
}

func (s *ValuesTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterValuesTable(s)
	}
}

func (s *ValuesTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitValuesTable(s)
	}
}

type QueryPrimaryDefaultContext struct {
	QueryPrimaryContext
}

func NewQueryPrimaryDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryPrimaryDefaultContext {
	var p = new(QueryPrimaryDefaultContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *QueryPrimaryDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryDefaultContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *QueryPrimaryDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterQueryPrimaryDefault(s)
	}
}

func (s *QueryPrimaryDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitQueryPrimaryDefault(s)
	}
}

func (p *DorisParser) QueryPrimary() (localctx IQueryPrimaryContext) {
	localctx = NewQueryPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, DorisParserRULE_queryPrimary)
	p.SetState(4613)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserSELECT:
		localctx = NewQueryPrimaryDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4607)
			p.QuerySpecification()
		}

	case DorisParserLEFT_PAREN:
		localctx = NewSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4608)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4609)
			p.Query()
		}
		{
			p.SetState(4610)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserVALUES:
		localctx = NewValuesTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4612)
			p.InlineTable()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_querySpecification
	return p
}

func InitEmptyQuerySpecificationContext(p *QuerySpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_querySpecification
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) CopyAll(ctx *QuerySpecificationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RegularQuerySpecificationContext struct {
	QuerySpecificationContext
}

func NewRegularQuerySpecificationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegularQuerySpecificationContext {
	var p = new(RegularQuerySpecificationContext)

	InitEmptyQuerySpecificationContext(&p.QuerySpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*QuerySpecificationContext))

	return p
}

func (s *RegularQuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegularQuerySpecificationContext) SelectClause() ISelectClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectClauseContext)
}

func (s *RegularQuerySpecificationContext) QueryOrganization() IQueryOrganizationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryOrganizationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryOrganizationContext)
}

func (s *RegularQuerySpecificationContext) IntoClause() IIntoClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntoClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntoClauseContext)
}

func (s *RegularQuerySpecificationContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *RegularQuerySpecificationContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *RegularQuerySpecificationContext) AggClause() IAggClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggClauseContext)
}

func (s *RegularQuerySpecificationContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *RegularQuerySpecificationContext) QualifyClause() IQualifyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifyClauseContext)
}

func (s *RegularQuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRegularQuerySpecification(s)
	}
}

func (s *RegularQuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRegularQuerySpecification(s)
	}
}

func (p *DorisParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, DorisParserRULE_querySpecification)
	localctx = NewRegularQuerySpecificationContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4615)
		p.SelectClause()
	}
	p.SetState(4617)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 666, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4616)
			p.IntoClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4620)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 667, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4619)
			p.FromClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4623)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 668, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4622)
			p.WhereClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4626)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 669, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4625)
			p.AggClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4629)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 670, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4628)
			p.HavingClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4632)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 671, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4631)
			p.QualifyClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4634)

	if !(doris_legacy_SQL_syntax) {
		p.SetError(antlr.NewFailedPredicateException(p, "doris_legacy_SQL_syntax", ""))
		goto errorExit
	}
	{
		p.SetState(4635)
		p.QueryOrganization()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICteContext is an interface to support dynamic dispatch.
type ICteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	AllAliasQuery() []IAliasQueryContext
	AliasQuery(i int) IAliasQueryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCteContext differentiates from other interfaces.
	IsCteContext()
}

type CteContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCteContext() *CteContext {
	var p = new(CteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_cte
	return p
}

func InitEmptyCteContext(p *CteContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_cte
}

func (*CteContext) IsCteContext() {}

func NewCteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CteContext {
	var p = new(CteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_cte

	return p
}

func (s *CteContext) GetParser() antlr.Parser { return s.parser }

func (s *CteContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *CteContext) AllAliasQuery() []IAliasQueryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAliasQueryContext); ok {
			len++
		}
	}

	tst := make([]IAliasQueryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAliasQueryContext); ok {
			tst[i] = t.(IAliasQueryContext)
			i++
		}
	}

	return tst
}

func (s *CteContext) AliasQuery(i int) IAliasQueryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasQueryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasQueryContext)
}

func (s *CteContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *CteContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *CteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCte(s)
	}
}

func (s *CteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCte(s)
	}
}

func (p *DorisParser) Cte() (localctx ICteContext) {
	localctx = NewCteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, DorisParserRULE_cte)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4637)
		p.Match(DorisParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4638)
		p.AliasQuery()
	}
	p.SetState(4643)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(4639)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4640)
			p.AliasQuery()
		}

		p.SetState(4645)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAliasQueryContext is an interface to support dynamic dispatch.
type IAliasQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AS() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	Query() IQueryContext
	RIGHT_PAREN() antlr.TerminalNode
	ColumnAliases() IColumnAliasesContext

	// IsAliasQueryContext differentiates from other interfaces.
	IsAliasQueryContext()
}

type AliasQueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasQueryContext() *AliasQueryContext {
	var p = new(AliasQueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_aliasQuery
	return p
}

func InitEmptyAliasQueryContext(p *AliasQueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_aliasQuery
}

func (*AliasQueryContext) IsAliasQueryContext() {}

func NewAliasQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasQueryContext {
	var p = new(AliasQueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_aliasQuery

	return p
}

func (s *AliasQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasQueryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AliasQueryContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *AliasQueryContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AliasQueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *AliasQueryContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AliasQueryContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *AliasQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAliasQuery(s)
	}
}

func (s *AliasQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAliasQuery(s)
	}
}

func (p *DorisParser) AliasQuery() (localctx IAliasQueryContext) {
	localctx = NewAliasQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, DorisParserRULE_aliasQuery)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4646)
		p.Identifier()
	}
	p.SetState(4648)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLEFT_PAREN {
		{
			p.SetState(4647)
			p.ColumnAliases()
		}

	}
	{
		p.SetState(4650)
		p.Match(DorisParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4651)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4652)
		p.Query()
	}
	{
		p.SetState(4653)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnAliasesContext is an interface to support dynamic dispatch.
type IColumnAliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnAliasesContext differentiates from other interfaces.
	IsColumnAliasesContext()
}

type ColumnAliasesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnAliasesContext() *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_columnAliases
	return p
}

func InitEmptyColumnAliasesContext(p *ColumnAliasesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_columnAliases
}

func (*ColumnAliasesContext) IsColumnAliasesContext() {}

func NewColumnAliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_columnAliases

	return p
}

func (s *ColumnAliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnAliasesContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ColumnAliasesContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnAliasesContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnAliasesContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ColumnAliasesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ColumnAliasesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ColumnAliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnAliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnAliasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterColumnAliases(s)
	}
}

func (s *ColumnAliasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitColumnAliases(s)
	}
}

func (p *DorisParser) ColumnAliases() (localctx IColumnAliasesContext) {
	localctx = NewColumnAliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, DorisParserRULE_columnAliases)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4655)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4656)
		p.Identifier()
	}
	p.SetState(4661)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(4657)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4658)
			p.Identifier()
		}

		p.SetState(4663)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4664)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectClauseContext is an interface to support dynamic dispatch.
type ISelectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	SelectColumnClause() ISelectColumnClauseContext
	DISTINCT() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsSelectClauseContext differentiates from other interfaces.
	IsSelectClauseContext()
}

type SelectClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectClauseContext() *SelectClauseContext {
	var p = new(SelectClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_selectClause
	return p
}

func InitEmptySelectClauseContext(p *SelectClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_selectClause
}

func (*SelectClauseContext) IsSelectClauseContext() {}

func NewSelectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectClauseContext {
	var p = new(SelectClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_selectClause

	return p
}

func (s *SelectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectClauseContext) SELECT() antlr.TerminalNode {
	return s.GetToken(DorisParserSELECT, 0)
}

func (s *SelectClauseContext) SelectColumnClause() ISelectColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectColumnClauseContext)
}

func (s *SelectClauseContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTINCT, 0)
}

func (s *SelectClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *SelectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSelectClause(s)
	}
}

func (s *SelectClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSelectClause(s)
	}
}

func (p *DorisParser) SelectClause() (localctx ISelectClauseContext) {
	localctx = NewSelectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, DorisParserRULE_selectClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4666)
		p.Match(DorisParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4668)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserALL || _la == DorisParserDISTINCT {
		{
			p.SetState(4667)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserALL || _la == DorisParserDISTINCT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(4670)
		p.SelectColumnClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectColumnClauseContext is an interface to support dynamic dispatch.
type ISelectColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NamedExpressionSeq() INamedExpressionSeqContext

	// IsSelectColumnClauseContext differentiates from other interfaces.
	IsSelectColumnClauseContext()
}

type SelectColumnClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectColumnClauseContext() *SelectColumnClauseContext {
	var p = new(SelectColumnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_selectColumnClause
	return p
}

func InitEmptySelectColumnClauseContext(p *SelectColumnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_selectColumnClause
}

func (*SelectColumnClauseContext) IsSelectColumnClauseContext() {}

func NewSelectColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectColumnClauseContext {
	var p = new(SelectColumnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_selectColumnClause

	return p
}

func (s *SelectColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectColumnClauseContext) NamedExpressionSeq() INamedExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionSeqContext)
}

func (s *SelectColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSelectColumnClause(s)
	}
}

func (s *SelectColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSelectColumnClause(s)
	}
}

func (p *DorisParser) SelectColumnClause() (localctx ISelectColumnClauseContext) {
	localctx = NewSelectColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, DorisParserRULE_selectColumnClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4672)
		p.NamedExpressionSeq()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_whereClause
	return p
}

func InitEmptyWhereClauseContext(p *WhereClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_whereClause
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserWHERE, 0)
}

func (s *WhereClauseContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWhereClause(s)
	}
}

func (s *WhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWhereClause(s)
	}
}

func (p *DorisParser) WhereClause() (localctx IWhereClauseContext) {
	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, DorisParserRULE_whereClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4674)
		p.Match(DorisParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4675)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM() antlr.TerminalNode
	Relations() IRelationsContext

	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_fromClause
	return p
}

func InitEmptyFromClauseContext(p *FromClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_fromClause
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *FromClauseContext) Relations() IRelationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationsContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFromClause(s)
	}
}

func (s *FromClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFromClause(s)
	}
}

func (p *DorisParser) FromClause() (localctx IFromClauseContext) {
	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, DorisParserRULE_fromClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4677)
		p.Match(DorisParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4678)
		p.Relations()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntoClauseContext is an interface to support dynamic dispatch.
type IIntoClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTO() antlr.TerminalNode
	AllTableRow() []ITableRowContext
	TableRow(i int) ITableRowContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	BulkCollectClause() IBulkCollectClauseContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIntoClauseContext differentiates from other interfaces.
	IsIntoClauseContext()
}

type IntoClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntoClauseContext() *IntoClauseContext {
	var p = new(IntoClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_intoClause
	return p
}

func InitEmptyIntoClauseContext(p *IntoClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_intoClause
}

func (*IntoClauseContext) IsIntoClauseContext() {}

func NewIntoClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntoClauseContext {
	var p = new(IntoClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_intoClause

	return p
}

func (s *IntoClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *IntoClauseContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserINTO, 0)
}

func (s *IntoClauseContext) AllTableRow() []ITableRowContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableRowContext); ok {
			len++
		}
	}

	tst := make([]ITableRowContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableRowContext); ok {
			tst[i] = t.(ITableRowContext)
			i++
		}
	}

	return tst
}

func (s *IntoClauseContext) TableRow(i int) ITableRowContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRowContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRowContext)
}

func (s *IntoClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IntoClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IntoClauseContext) BulkCollectClause() IBulkCollectClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBulkCollectClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBulkCollectClauseContext)
}

func (s *IntoClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *IntoClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *IntoClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntoClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntoClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIntoClause(s)
	}
}

func (s *IntoClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIntoClause(s)
	}
}

func (p *DorisParser) IntoClause() (localctx IIntoClauseContext) {
	localctx = NewIntoClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, DorisParserRULE_intoClause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4681)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserBULK {
		{
			p.SetState(4680)
			p.BulkCollectClause()
		}

	}
	{
		p.SetState(4683)
		p.Match(DorisParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 677, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4684)
			p.TableRow()
		}

	case 2:
		{
			p.SetState(4685)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(4695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 679, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4688)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(4691)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 678, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(4689)
					p.TableRow()
				}

			case 2:
				{
					p.SetState(4690)
					p.Identifier()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(4697)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 679, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBulkCollectClauseContext is an interface to support dynamic dispatch.
type IBulkCollectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BULK() antlr.TerminalNode
	COLLECT() antlr.TerminalNode

	// IsBulkCollectClauseContext differentiates from other interfaces.
	IsBulkCollectClauseContext()
}

type BulkCollectClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBulkCollectClauseContext() *BulkCollectClauseContext {
	var p = new(BulkCollectClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_bulkCollectClause
	return p
}

func InitEmptyBulkCollectClauseContext(p *BulkCollectClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_bulkCollectClause
}

func (*BulkCollectClauseContext) IsBulkCollectClauseContext() {}

func NewBulkCollectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BulkCollectClauseContext {
	var p = new(BulkCollectClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_bulkCollectClause

	return p
}

func (s *BulkCollectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *BulkCollectClauseContext) BULK() antlr.TerminalNode {
	return s.GetToken(DorisParserBULK, 0)
}

func (s *BulkCollectClauseContext) COLLECT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLLECT, 0)
}

func (s *BulkCollectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BulkCollectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BulkCollectClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBulkCollectClause(s)
	}
}

func (s *BulkCollectClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBulkCollectClause(s)
	}
}

func (p *DorisParser) BulkCollectClause() (localctx IBulkCollectClauseContext) {
	localctx = NewBulkCollectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, DorisParserRULE_bulkCollectClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4698)
		p.Match(DorisParserBULK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4699)
		p.Match(DorisParserCOLLECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableRowContext is an interface to support dynamic dispatch.
type ITableRowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LEFT_PAREN() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode

	// IsTableRowContext differentiates from other interfaces.
	IsTableRowContext()
}

type TableRowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableRowContext() *TableRowContext {
	var p = new(TableRowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tableRow
	return p
}

func InitEmptyTableRowContext(p *TableRowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tableRow
}

func (*TableRowContext) IsTableRowContext() {}

func NewTableRowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableRowContext {
	var p = new(TableRowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_tableRow

	return p
}

func (s *TableRowContext) GetParser() antlr.Parser { return s.parser }

func (s *TableRowContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableRowContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *TableRowContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *TableRowContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *TableRowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableRowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableRowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTableRow(s)
	}
}

func (s *TableRowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTableRow(s)
	}
}

func (p *DorisParser) TableRow() (localctx ITableRowContext) {
	localctx = NewTableRowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, DorisParserRULE_tableRow)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4701)
		p.Identifier()
	}
	{
		p.SetState(4702)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4703)
		p.Match(DorisParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4704)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationsContext is an interface to support dynamic dispatch.
type IRelationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRelation() []IRelationContext
	Relation(i int) IRelationContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRelationsContext differentiates from other interfaces.
	IsRelationsContext()
}

type RelationsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationsContext() *RelationsContext {
	var p = new(RelationsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_relations
	return p
}

func InitEmptyRelationsContext(p *RelationsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_relations
}

func (*RelationsContext) IsRelationsContext() {}

func NewRelationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationsContext {
	var p = new(RelationsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_relations

	return p
}

func (s *RelationsContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationsContext) AllRelation() []IRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelationContext); ok {
			len++
		}
	}

	tst := make([]IRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelationContext); ok {
			tst[i] = t.(IRelationContext)
			i++
		}
	}

	return tst
}

func (s *RelationsContext) Relation(i int) IRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *RelationsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *RelationsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *RelationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRelations(s)
	}
}

func (s *RelationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRelations(s)
	}
}

func (p *DorisParser) Relations() (localctx IRelationsContext) {
	localctx = NewRelationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, DorisParserRULE_relations)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4706)
		p.Relation()
	}
	p.SetState(4711)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 680, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4707)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4708)
				p.Relation()
			}

		}
		p.SetState(4713)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 680, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RelationPrimary() IRelationPrimaryContext
	AllJoinRelation() []IJoinRelationContext
	JoinRelation(i int) IJoinRelationContext

	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_relation
	return p
}

func InitEmptyRelationContext(p *RelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_relation
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) RelationPrimary() IRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *RelationContext) AllJoinRelation() []IJoinRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinRelationContext); ok {
			len++
		}
	}

	tst := make([]IJoinRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinRelationContext); ok {
			tst[i] = t.(IJoinRelationContext)
			i++
		}
	}

	return tst
}

func (s *RelationContext) JoinRelation(i int) IJoinRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinRelationContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRelation(s)
	}
}

func (s *RelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRelation(s)
	}
}

func (p *DorisParser) Relation() (localctx IRelationContext) {
	localctx = NewRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, DorisParserRULE_relation)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4714)
		p.RelationPrimary()
	}
	p.SetState(4718)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 681, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4715)
				p.JoinRelation()
			}

		}
		p.SetState(4720)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 681, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinRelationContext is an interface to support dynamic dispatch.
type IJoinRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRight returns the right rule contexts.
	GetRight() IRelationPrimaryContext

	// SetRight sets the right rule contexts.
	SetRight(IRelationPrimaryContext)

	// Getter signatures
	JOIN() antlr.TerminalNode
	RelationPrimary() IRelationPrimaryContext
	JoinType() IJoinTypeContext
	DistributeType() IDistributeTypeContext
	JoinCriteria() IJoinCriteriaContext

	// IsJoinRelationContext differentiates from other interfaces.
	IsJoinRelationContext()
}

type JoinRelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	right  IRelationPrimaryContext
}

func NewEmptyJoinRelationContext() *JoinRelationContext {
	var p = new(JoinRelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_joinRelation
	return p
}

func InitEmptyJoinRelationContext(p *JoinRelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_joinRelation
}

func (*JoinRelationContext) IsJoinRelationContext() {}

func NewJoinRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinRelationContext {
	var p = new(JoinRelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_joinRelation

	return p
}

func (s *JoinRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinRelationContext) GetRight() IRelationPrimaryContext { return s.right }

func (s *JoinRelationContext) SetRight(v IRelationPrimaryContext) { s.right = v }

func (s *JoinRelationContext) JOIN() antlr.TerminalNode {
	return s.GetToken(DorisParserJOIN, 0)
}

func (s *JoinRelationContext) RelationPrimary() IRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *JoinRelationContext) JoinType() IJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinTypeContext)
}

func (s *JoinRelationContext) DistributeType() IDistributeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributeTypeContext)
}

func (s *JoinRelationContext) JoinCriteria() IJoinCriteriaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinCriteriaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinCriteriaContext)
}

func (s *JoinRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterJoinRelation(s)
	}
}

func (s *JoinRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitJoinRelation(s)
	}
}

func (p *DorisParser) JoinRelation() (localctx IJoinRelationContext) {
	localctx = NewJoinRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, DorisParserRULE_joinRelation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4721)
		p.JoinType()
	}

	{
		p.SetState(4722)
		p.Match(DorisParserJOIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4724)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 682, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4723)
			p.DistributeType()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4726)

		var _x = p.RelationPrimary()

		localctx.(*JoinRelationContext).right = _x
	}
	p.SetState(4728)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 683, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4727)
			p.JoinCriteria()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDistributeTypeContext is an interface to support dynamic dispatch.
type IDistributeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDistributeTypeContext differentiates from other interfaces.
	IsDistributeTypeContext()
}

type DistributeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistributeTypeContext() *DistributeTypeContext {
	var p = new(DistributeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_distributeType
	return p
}

func InitEmptyDistributeTypeContext(p *DistributeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_distributeType
}

func (*DistributeTypeContext) IsDistributeTypeContext() {}

func NewDistributeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistributeTypeContext {
	var p = new(DistributeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_distributeType

	return p
}

func (s *DistributeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DistributeTypeContext) CopyAll(ctx *DistributeTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DistributeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistributeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CommentDistributeTypeContext struct {
	DistributeTypeContext
}

func NewCommentDistributeTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommentDistributeTypeContext {
	var p = new(CommentDistributeTypeContext)

	InitEmptyDistributeTypeContext(&p.DistributeTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DistributeTypeContext))

	return p
}

func (s *CommentDistributeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentDistributeTypeContext) HINT_START() antlr.TerminalNode {
	return s.GetToken(DorisParserHINT_START, 0)
}

func (s *CommentDistributeTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CommentDistributeTypeContext) HINT_END() antlr.TerminalNode {
	return s.GetToken(DorisParserHINT_END, 0)
}

func (s *CommentDistributeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCommentDistributeType(s)
	}
}

func (s *CommentDistributeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCommentDistributeType(s)
	}
}

type BracketDistributeTypeContext struct {
	DistributeTypeContext
}

func NewBracketDistributeTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BracketDistributeTypeContext {
	var p = new(BracketDistributeTypeContext)

	InitEmptyDistributeTypeContext(&p.DistributeTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DistributeTypeContext))

	return p
}

func (s *BracketDistributeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BracketDistributeTypeContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACKET, 0)
}

func (s *BracketDistributeTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BracketDistributeTypeContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACKET, 0)
}

func (s *BracketDistributeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBracketDistributeType(s)
	}
}

func (s *BracketDistributeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBracketDistributeType(s)
	}
}

func (p *DorisParser) DistributeType() (localctx IDistributeTypeContext) {
	localctx = NewDistributeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, DorisParserRULE_distributeType)
	p.SetState(4738)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACKET:
		localctx = NewBracketDistributeTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4730)
			p.Match(DorisParserLEFT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4731)
			p.Identifier()
		}
		{
			p.SetState(4732)
			p.Match(DorisParserRIGHT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserHINT_START:
		localctx = NewCommentDistributeTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4734)
			p.Match(DorisParserHINT_START)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4735)
			p.Identifier()
		}
		{
			p.SetState(4736)
			p.Match(DorisParserHINT_END)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationHintContext is an interface to support dynamic dispatch.
type IRelationHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationHintContext differentiates from other interfaces.
	IsRelationHintContext()
}

type RelationHintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationHintContext() *RelationHintContext {
	var p = new(RelationHintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_relationHint
	return p
}

func InitEmptyRelationHintContext(p *RelationHintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_relationHint
}

func (*RelationHintContext) IsRelationHintContext() {}

func NewRelationHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationHintContext {
	var p = new(RelationHintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_relationHint

	return p
}

func (s *RelationHintContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationHintContext) CopyAll(ctx *RelationHintContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RelationHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BracketRelationHintContext struct {
	RelationHintContext
}

func NewBracketRelationHintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BracketRelationHintContext {
	var p = new(BracketRelationHintContext)

	InitEmptyRelationHintContext(&p.RelationHintContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationHintContext))

	return p
}

func (s *BracketRelationHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BracketRelationHintContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACKET, 0)
}

func (s *BracketRelationHintContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *BracketRelationHintContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BracketRelationHintContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACKET, 0)
}

func (s *BracketRelationHintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *BracketRelationHintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *BracketRelationHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBracketRelationHint(s)
	}
}

func (s *BracketRelationHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBracketRelationHint(s)
	}
}

type CommentRelationHintContext struct {
	RelationHintContext
}

func NewCommentRelationHintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommentRelationHintContext {
	var p = new(CommentRelationHintContext)

	InitEmptyRelationHintContext(&p.RelationHintContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationHintContext))

	return p
}

func (s *CommentRelationHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentRelationHintContext) HINT_START() antlr.TerminalNode {
	return s.GetToken(DorisParserHINT_START, 0)
}

func (s *CommentRelationHintContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CommentRelationHintContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CommentRelationHintContext) HINT_END() antlr.TerminalNode {
	return s.GetToken(DorisParserHINT_END, 0)
}

func (s *CommentRelationHintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *CommentRelationHintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *CommentRelationHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCommentRelationHint(s)
	}
}

func (s *CommentRelationHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCommentRelationHint(s)
	}
}

func (p *DorisParser) RelationHint() (localctx IRelationHintContext) {
	localctx = NewRelationHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, DorisParserRULE_relationHint)
	var _la int

	p.SetState(4762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACKET:
		localctx = NewBracketRelationHintContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4740)
			p.Match(DorisParserLEFT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4741)
			p.Identifier()
		}
		p.SetState(4746)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(4742)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4743)
				p.Identifier()
			}

			p.SetState(4748)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4749)
			p.Match(DorisParserRIGHT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserHINT_START:
		localctx = NewCommentRelationHintContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4751)
			p.Match(DorisParserHINT_START)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4752)
			p.Identifier()
		}
		p.SetState(4757)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(4753)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4754)
				p.Identifier()
			}

			p.SetState(4759)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4760)
			p.Match(DorisParserHINT_END)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggClauseContext is an interface to support dynamic dispatch.
type IAggClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	GroupingElement() IGroupingElementContext

	// IsAggClauseContext differentiates from other interfaces.
	IsAggClauseContext()
}

type AggClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggClauseContext() *AggClauseContext {
	var p = new(AggClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_aggClause
	return p
}

func InitEmptyAggClauseContext(p *AggClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_aggClause
}

func (*AggClauseContext) IsAggClauseContext() {}

func NewAggClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggClauseContext {
	var p = new(AggClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_aggClause

	return p
}

func (s *AggClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AggClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUP, 0)
}

func (s *AggClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *AggClauseContext) GroupingElement() IGroupingElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingElementContext)
}

func (s *AggClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAggClause(s)
	}
}

func (s *AggClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAggClause(s)
	}
}

func (p *DorisParser) AggClause() (localctx IAggClauseContext) {
	localctx = NewAggClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, DorisParserRULE_aggClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4764)
		p.Match(DorisParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4765)
		p.Match(DorisParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4766)
		p.GroupingElement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingElementContext is an interface to support dynamic dispatch.
type IGroupingElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLLUP() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	CUBE() antlr.TerminalNode
	GROUPING() antlr.TerminalNode
	SETS() antlr.TerminalNode
	AllGroupingSet() []IGroupingSetContext
	GroupingSet(i int) IGroupingSetContext

	// IsGroupingElementContext differentiates from other interfaces.
	IsGroupingElementContext()
}

type GroupingElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingElementContext() *GroupingElementContext {
	var p = new(GroupingElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_groupingElement
	return p
}

func InitEmptyGroupingElementContext(p *GroupingElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_groupingElement
}

func (*GroupingElementContext) IsGroupingElementContext() {}

func NewGroupingElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingElementContext {
	var p = new(GroupingElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_groupingElement

	return p
}

func (s *GroupingElementContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingElementContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *GroupingElementContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *GroupingElementContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *GroupingElementContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupingElementContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingElementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *GroupingElementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *GroupingElementContext) CUBE() antlr.TerminalNode {
	return s.GetToken(DorisParserCUBE, 0)
}

func (s *GroupingElementContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUPING, 0)
}

func (s *GroupingElementContext) SETS() antlr.TerminalNode {
	return s.GetToken(DorisParserSETS, 0)
}

func (s *GroupingElementContext) AllGroupingSet() []IGroupingSetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupingSetContext); ok {
			len++
		}
	}

	tst := make([]IGroupingSetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupingSetContext); ok {
			tst[i] = t.(IGroupingSetContext)
			i++
		}
	}

	return tst
}

func (s *GroupingElementContext) GroupingSet(i int) IGroupingSetContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingSetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *GroupingElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterGroupingElement(s)
	}
}

func (s *GroupingElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitGroupingElement(s)
	}
}

func (p *DorisParser) GroupingElement() (localctx IGroupingElementContext) {
	localctx = NewGroupingElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, DorisParserRULE_groupingElement)
	var _la int

	var _alt int

	p.SetState(4815)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 694, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4768)
			p.Match(DorisParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4769)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4778)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8646890354245592708) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6341351709356361985) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-6232419426235955661) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&9126402704879377875) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-2873932114615608333) != 0) || ((int64((_la-322)) & ^0x3f) == 0 && ((int64(1)<<(_la-322))&-2310602210946850817) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&-2627780018309275847) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&-7818098869825860867) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&56383) != 0) {
			{
				p.SetState(4770)
				p.Expression()
			}
			p.SetState(4775)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(4771)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4772)
					p.Expression()
				}

				p.SetState(4777)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(4780)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4781)
			p.Match(DorisParserCUBE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4782)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4791)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8646890354245592708) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6341351709356361985) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-6232419426235955661) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&9126402704879377875) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-2873932114615608333) != 0) || ((int64((_la-322)) & ^0x3f) == 0 && ((int64(1)<<(_la-322))&-2310602210946850817) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&-2627780018309275847) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&-7818098869825860867) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&56383) != 0) {
			{
				p.SetState(4783)
				p.Expression()
			}
			p.SetState(4788)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(4784)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4785)
					p.Expression()
				}

				p.SetState(4790)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(4793)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4794)
			p.Match(DorisParserGROUPING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4795)
			p.Match(DorisParserSETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4796)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4797)
			p.GroupingSet()
		}
		p.SetState(4802)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(4798)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4799)
				p.GroupingSet()
			}

			p.SetState(4804)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4805)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4807)
			p.Expression()
		}
		p.SetState(4812)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 693, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(4808)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4809)
					p.Expression()
				}

			}
			p.SetState(4814)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 693, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingSetContext is an interface to support dynamic dispatch.
type IGroupingSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGroupingSetContext differentiates from other interfaces.
	IsGroupingSetContext()
}

type GroupingSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingSetContext() *GroupingSetContext {
	var p = new(GroupingSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_groupingSet
	return p
}

func InitEmptyGroupingSetContext(p *GroupingSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_groupingSet
}

func (*GroupingSetContext) IsGroupingSetContext() {}

func NewGroupingSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingSetContext {
	var p = new(GroupingSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_groupingSet

	return p
}

func (s *GroupingSetContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingSetContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *GroupingSetContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *GroupingSetContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupingSetContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingSetContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *GroupingSetContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *GroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterGroupingSet(s)
	}
}

func (s *GroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitGroupingSet(s)
	}
}

func (p *DorisParser) GroupingSet() (localctx IGroupingSetContext) {
	localctx = NewGroupingSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, DorisParserRULE_groupingSet)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4817)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8646890354245592708) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6341351709356361985) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-6232419426235955661) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&9126402704879377875) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-2873932114615608333) != 0) || ((int64((_la-322)) & ^0x3f) == 0 && ((int64(1)<<(_la-322))&-2310602210946850817) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&-2627780018309275847) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&-7818098869825860867) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&56383) != 0) {
		{
			p.SetState(4818)
			p.Expression()
		}
		p.SetState(4823)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(4819)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4820)
				p.Expression()
			}

			p.SetState(4825)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(4828)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHavingClauseContext is an interface to support dynamic dispatch.
type IHavingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HAVING() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsHavingClauseContext differentiates from other interfaces.
	IsHavingClauseContext()
}

type HavingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHavingClauseContext() *HavingClauseContext {
	var p = new(HavingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_havingClause
	return p
}

func InitEmptyHavingClauseContext(p *HavingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_havingClause
}

func (*HavingClauseContext) IsHavingClauseContext() {}

func NewHavingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HavingClauseContext {
	var p = new(HavingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_havingClause

	return p
}

func (s *HavingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *HavingClauseContext) HAVING() antlr.TerminalNode {
	return s.GetToken(DorisParserHAVING, 0)
}

func (s *HavingClauseContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *HavingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HavingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HavingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterHavingClause(s)
	}
}

func (s *HavingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitHavingClause(s)
	}
}

func (p *DorisParser) HavingClause() (localctx IHavingClauseContext) {
	localctx = NewHavingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, DorisParserRULE_havingClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4830)
		p.Match(DorisParserHAVING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4831)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifyClauseContext is an interface to support dynamic dispatch.
type IQualifyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUALIFY() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsQualifyClauseContext differentiates from other interfaces.
	IsQualifyClauseContext()
}

type QualifyClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifyClauseContext() *QualifyClauseContext {
	var p = new(QualifyClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_qualifyClause
	return p
}

func InitEmptyQualifyClauseContext(p *QualifyClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_qualifyClause
}

func (*QualifyClauseContext) IsQualifyClauseContext() {}

func NewQualifyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifyClauseContext {
	var p = new(QualifyClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_qualifyClause

	return p
}

func (s *QualifyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifyClauseContext) QUALIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserQUALIFY, 0)
}

func (s *QualifyClauseContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *QualifyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterQualifyClause(s)
	}
}

func (s *QualifyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitQualifyClause(s)
	}
}

func (p *DorisParser) QualifyClause() (localctx IQualifyClauseContext) {
	localctx = NewQualifyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, DorisParserRULE_qualifyClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4833)
		p.Match(DorisParserQUALIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4834)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectHintContext is an interface to support dynamic dispatch.
type ISelectHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_hintStatement returns the _hintStatement rule contexts.
	Get_hintStatement() IHintStatementContext

	// Set_hintStatement sets the _hintStatement rule contexts.
	Set_hintStatement(IHintStatementContext)

	// GetHintStatements returns the hintStatements rule context list.
	GetHintStatements() []IHintStatementContext

	// SetHintStatements sets the hintStatements rule context list.
	SetHintStatements([]IHintStatementContext)

	// Getter signatures
	HINT_END() antlr.TerminalNode
	AllHintStatement() []IHintStatementContext
	HintStatement(i int) IHintStatementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSelectHintContext differentiates from other interfaces.
	IsSelectHintContext()
}

type SelectHintContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	_hintStatement IHintStatementContext
	hintStatements []IHintStatementContext
}

func NewEmptySelectHintContext() *SelectHintContext {
	var p = new(SelectHintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_selectHint
	return p
}

func InitEmptySelectHintContext(p *SelectHintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_selectHint
}

func (*SelectHintContext) IsSelectHintContext() {}

func NewSelectHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectHintContext {
	var p = new(SelectHintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_selectHint

	return p
}

func (s *SelectHintContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectHintContext) Get_hintStatement() IHintStatementContext { return s._hintStatement }

func (s *SelectHintContext) Set_hintStatement(v IHintStatementContext) { s._hintStatement = v }

func (s *SelectHintContext) GetHintStatements() []IHintStatementContext { return s.hintStatements }

func (s *SelectHintContext) SetHintStatements(v []IHintStatementContext) { s.hintStatements = v }

func (s *SelectHintContext) HINT_END() antlr.TerminalNode {
	return s.GetToken(DorisParserHINT_END, 0)
}

func (s *SelectHintContext) AllHintStatement() []IHintStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHintStatementContext); ok {
			len++
		}
	}

	tst := make([]IHintStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHintStatementContext); ok {
			tst[i] = t.(IHintStatementContext)
			i++
		}
	}

	return tst
}

func (s *SelectHintContext) HintStatement(i int) IHintStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintStatementContext)
}

func (s *SelectHintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *SelectHintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *SelectHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSelectHint(s)
	}
}

func (s *SelectHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSelectHint(s)
	}
}

func (p *DorisParser) SelectHint() (localctx ISelectHintContext) {
	localctx = NewSelectHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, DorisParserRULE_selectHint)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4836)

		var _x = p.HintStatement()

		localctx.(*SelectHintContext)._hintStatement = _x
	}
	localctx.(*SelectHintContext).hintStatements = append(localctx.(*SelectHintContext).hintStatements, localctx.(*SelectHintContext)._hintStatement)
	p.SetState(4843)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 698, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(4838)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserCOMMA {
				{
					p.SetState(4837)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(4840)

				var _x = p.HintStatement()

				localctx.(*SelectHintContext)._hintStatement = _x
			}
			localctx.(*SelectHintContext).hintStatements = append(localctx.(*SelectHintContext).hintStatements, localctx.(*SelectHintContext)._hintStatement)

		}
		p.SetState(4845)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 698, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(4846)
		p.Match(DorisParserHINT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHintStatementContext is an interface to support dynamic dispatch.
type IHintStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetHintName returns the hintName rule contexts.
	GetHintName() IIdentifierContext

	// Get_hintAssignment returns the _hintAssignment rule contexts.
	Get_hintAssignment() IHintAssignmentContext

	// Get_multipartIdentifier returns the _multipartIdentifier rule contexts.
	Get_multipartIdentifier() IMultipartIdentifierContext

	// SetHintName sets the hintName rule contexts.
	SetHintName(IIdentifierContext)

	// Set_hintAssignment sets the _hintAssignment rule contexts.
	Set_hintAssignment(IHintAssignmentContext)

	// Set_multipartIdentifier sets the _multipartIdentifier rule contexts.
	Set_multipartIdentifier(IMultipartIdentifierContext)

	// GetParameters returns the parameters rule context list.
	GetParameters() []IHintAssignmentContext

	// GetTableList returns the tableList rule context list.
	GetTableList() []IMultipartIdentifierContext

	// SetParameters sets the parameters rule context list.
	SetParameters([]IHintAssignmentContext)

	// SetTableList sets the tableList rule context list.
	SetTableList([]IMultipartIdentifierContext)

	// Getter signatures
	Identifier() IIdentifierContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllHintAssignment() []IHintAssignmentContext
	HintAssignment(i int) IHintAssignmentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	USE_MV() antlr.TerminalNode
	NO_USE_MV() antlr.TerminalNode
	AllMultipartIdentifier() []IMultipartIdentifierContext
	MultipartIdentifier(i int) IMultipartIdentifierContext

	// IsHintStatementContext differentiates from other interfaces.
	IsHintStatementContext()
}

type HintStatementContext struct {
	antlr.BaseParserRuleContext
	parser               antlr.Parser
	hintName             IIdentifierContext
	_hintAssignment      IHintAssignmentContext
	parameters           []IHintAssignmentContext
	_multipartIdentifier IMultipartIdentifierContext
	tableList            []IMultipartIdentifierContext
}

func NewEmptyHintStatementContext() *HintStatementContext {
	var p = new(HintStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_hintStatement
	return p
}

func InitEmptyHintStatementContext(p *HintStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_hintStatement
}

func (*HintStatementContext) IsHintStatementContext() {}

func NewHintStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintStatementContext {
	var p = new(HintStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_hintStatement

	return p
}

func (s *HintStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HintStatementContext) GetHintName() IIdentifierContext { return s.hintName }

func (s *HintStatementContext) Get_hintAssignment() IHintAssignmentContext { return s._hintAssignment }

func (s *HintStatementContext) Get_multipartIdentifier() IMultipartIdentifierContext {
	return s._multipartIdentifier
}

func (s *HintStatementContext) SetHintName(v IIdentifierContext) { s.hintName = v }

func (s *HintStatementContext) Set_hintAssignment(v IHintAssignmentContext) { s._hintAssignment = v }

func (s *HintStatementContext) Set_multipartIdentifier(v IMultipartIdentifierContext) {
	s._multipartIdentifier = v
}

func (s *HintStatementContext) GetParameters() []IHintAssignmentContext { return s.parameters }

func (s *HintStatementContext) GetTableList() []IMultipartIdentifierContext { return s.tableList }

func (s *HintStatementContext) SetParameters(v []IHintAssignmentContext) { s.parameters = v }

func (s *HintStatementContext) SetTableList(v []IMultipartIdentifierContext) { s.tableList = v }

func (s *HintStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *HintStatementContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *HintStatementContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *HintStatementContext) AllHintAssignment() []IHintAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHintAssignmentContext); ok {
			len++
		}
	}

	tst := make([]IHintAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHintAssignmentContext); ok {
			tst[i] = t.(IHintAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *HintStatementContext) HintAssignment(i int) IHintAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintAssignmentContext)
}

func (s *HintStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *HintStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *HintStatementContext) USE_MV() antlr.TerminalNode {
	return s.GetToken(DorisParserUSE_MV, 0)
}

func (s *HintStatementContext) NO_USE_MV() antlr.TerminalNode {
	return s.GetToken(DorisParserNO_USE_MV, 0)
}

func (s *HintStatementContext) AllMultipartIdentifier() []IMultipartIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultipartIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipartIdentifierContext); ok {
			tst[i] = t.(IMultipartIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *HintStatementContext) MultipartIdentifier(i int) IMultipartIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *HintStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HintStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterHintStatement(s)
	}
}

func (s *HintStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitHintStatement(s)
	}
}

func (p *DorisParser) HintStatement() (localctx IHintStatementContext) {
	localctx = NewHintStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, DorisParserRULE_hintStatement)
	var _la int

	p.SetState(4878)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4848)

			var _x = p.Identifier()

			localctx.(*HintStatementContext).hintName = _x
		}
		p.SetState(4862)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(4849)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4850)

				var _x = p.HintAssignment()

				localctx.(*HintStatementContext)._hintAssignment = _x
			}
			localctx.(*HintStatementContext).parameters = append(localctx.(*HintStatementContext).parameters, localctx.(*HintStatementContext)._hintAssignment)
			p.SetState(4857)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8646890354245576336) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&3026312906716208575) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-6232420542927452621) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&3937129999880936915) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-2873940910708630541) != 0) || ((int64((_la-322)) & ^0x3f) == 0 && ((int64(1)<<(_la-322))&6912752233721880575) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&-2627780018309275847) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&72207677327248109) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&56359) != 0) {
				p.SetState(4852)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisParserCOMMA {
					{
						p.SetState(4851)
						p.Match(DorisParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(4854)

					var _x = p.HintAssignment()

					localctx.(*HintStatementContext)._hintAssignment = _x
				}
				localctx.(*HintStatementContext).parameters = append(localctx.(*HintStatementContext).parameters, localctx.(*HintStatementContext)._hintAssignment)

				p.SetState(4859)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(4860)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DorisParserNO_USE_MV, DorisParserUSE_MV:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4864)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserNO_USE_MV || _la == DorisParserUSE_MV) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(4876)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(4865)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4866)

				var _x = p.MultipartIdentifier()

				localctx.(*HintStatementContext)._multipartIdentifier = _x
			}
			localctx.(*HintStatementContext).tableList = append(localctx.(*HintStatementContext).tableList, localctx.(*HintStatementContext)._multipartIdentifier)
			p.SetState(4871)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(4867)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4868)

					var _x = p.MultipartIdentifier()

					localctx.(*HintStatementContext)._multipartIdentifier = _x
				}
				localctx.(*HintStatementContext).tableList = append(localctx.(*HintStatementContext).tableList, localctx.(*HintStatementContext)._multipartIdentifier)

				p.SetState(4873)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(4874)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHintAssignmentContext is an interface to support dynamic dispatch.
type IHintAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IIdentifierOrTextContext

	// GetConstantValue returns the constantValue rule contexts.
	GetConstantValue() IConstantContext

	// GetIdentifierValue returns the identifierValue rule contexts.
	GetIdentifierValue() IIdentifierContext

	// SetKey sets the key rule contexts.
	SetKey(IIdentifierOrTextContext)

	// SetConstantValue sets the constantValue rule contexts.
	SetConstantValue(IConstantContext)

	// SetIdentifierValue sets the identifierValue rule contexts.
	SetIdentifierValue(IIdentifierContext)

	// Getter signatures
	IdentifierOrText() IIdentifierOrTextContext
	EQ() antlr.TerminalNode
	Constant() IConstantContext
	Identifier() IIdentifierContext

	// IsHintAssignmentContext differentiates from other interfaces.
	IsHintAssignmentContext()
}

type HintAssignmentContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	key             IIdentifierOrTextContext
	constantValue   IConstantContext
	identifierValue IIdentifierContext
}

func NewEmptyHintAssignmentContext() *HintAssignmentContext {
	var p = new(HintAssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_hintAssignment
	return p
}

func InitEmptyHintAssignmentContext(p *HintAssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_hintAssignment
}

func (*HintAssignmentContext) IsHintAssignmentContext() {}

func NewHintAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintAssignmentContext {
	var p = new(HintAssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_hintAssignment

	return p
}

func (s *HintAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *HintAssignmentContext) GetKey() IIdentifierOrTextContext { return s.key }

func (s *HintAssignmentContext) GetConstantValue() IConstantContext { return s.constantValue }

func (s *HintAssignmentContext) GetIdentifierValue() IIdentifierContext { return s.identifierValue }

func (s *HintAssignmentContext) SetKey(v IIdentifierOrTextContext) { s.key = v }

func (s *HintAssignmentContext) SetConstantValue(v IConstantContext) { s.constantValue = v }

func (s *HintAssignmentContext) SetIdentifierValue(v IIdentifierContext) { s.identifierValue = v }

func (s *HintAssignmentContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *HintAssignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *HintAssignmentContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *HintAssignmentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *HintAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HintAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterHintAssignment(s)
	}
}

func (s *HintAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitHintAssignment(s)
	}
}

func (p *DorisParser) HintAssignment() (localctx IHintAssignmentContext) {
	localctx = NewHintAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, DorisParserRULE_hintAssignment)
	var _la int

	p.SetState(4889)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 707, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4880)

			var _x = p.IdentifierOrText()

			localctx.(*HintAssignmentContext).key = _x
		}
		p.SetState(4886)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserEQ {
			{
				p.SetState(4881)
				p.Match(DorisParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(4884)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 705, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(4882)

					var _x = p.Constant()

					localctx.(*HintAssignmentContext).constantValue = _x
				}

			case 2:
				{
					p.SetState(4883)

					var _x = p.Identifier()

					localctx.(*HintAssignmentContext).identifierValue = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4888)
			p.Constant()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateAssignmentContext is an interface to support dynamic dispatch.
type IUpdateAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCol returns the col rule contexts.
	GetCol() IMultipartIdentifierContext

	// SetCol sets the col rule contexts.
	SetCol(IMultipartIdentifierContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext
	Expression() IExpressionContext
	DEFAULT() antlr.TerminalNode

	// IsUpdateAssignmentContext differentiates from other interfaces.
	IsUpdateAssignmentContext()
}

type UpdateAssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	col    IMultipartIdentifierContext
}

func NewEmptyUpdateAssignmentContext() *UpdateAssignmentContext {
	var p = new(UpdateAssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_updateAssignment
	return p
}

func InitEmptyUpdateAssignmentContext(p *UpdateAssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_updateAssignment
}

func (*UpdateAssignmentContext) IsUpdateAssignmentContext() {}

func NewUpdateAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateAssignmentContext {
	var p = new(UpdateAssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_updateAssignment

	return p
}

func (s *UpdateAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateAssignmentContext) GetCol() IMultipartIdentifierContext { return s.col }

func (s *UpdateAssignmentContext) SetCol(v IMultipartIdentifierContext) { s.col = v }

func (s *UpdateAssignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *UpdateAssignmentContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *UpdateAssignmentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UpdateAssignmentContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *UpdateAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUpdateAssignment(s)
	}
}

func (s *UpdateAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUpdateAssignment(s)
	}
}

func (p *DorisParser) UpdateAssignment() (localctx IUpdateAssignmentContext) {
	localctx = NewUpdateAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, DorisParserRULE_updateAssignment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4891)

		var _x = p.MultipartIdentifier()

		localctx.(*UpdateAssignmentContext).col = _x
	}
	{
		p.SetState(4892)
		p.Match(DorisParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4895)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_PAREN, DorisParserLEFT_BRACKET, DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADD, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBINARY, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCASE, DorisParserCAST, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATABASE, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXISTS, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserEXTRACT, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFALSE, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIF, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINTERVAL, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserKEY, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLEFT, DorisParserLESS, DorisParserLEVEL, DorisParserLIKE, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNOT, DorisParserNULL, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLACEHOLDER, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREGEXP, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRIGHT, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRIM, DorisParserTRUE, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserPLUS, DorisParserSUBTRACT, DorisParserASTERISK, DorisParserTILDE, DorisParserLOGICALNOT, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserATSIGN, DorisParserDOUBLEATSIGN, DorisParserSTRING_LITERAL, DorisParserINTEGER_VALUE, DorisParserEXPONENT_VALUE, DorisParserDECIMAL_VALUE, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		{
			p.SetState(4893)
			p.Expression()
		}

	case DorisParserDEFAULT:
		{
			p.SetState(4894)
			p.Match(DorisParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateAssignmentSeqContext is an interface to support dynamic dispatch.
type IUpdateAssignmentSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_updateAssignment returns the _updateAssignment rule contexts.
	Get_updateAssignment() IUpdateAssignmentContext

	// Set_updateAssignment sets the _updateAssignment rule contexts.
	Set_updateAssignment(IUpdateAssignmentContext)

	// GetAssignments returns the assignments rule context list.
	GetAssignments() []IUpdateAssignmentContext

	// SetAssignments sets the assignments rule context list.
	SetAssignments([]IUpdateAssignmentContext)

	// Getter signatures
	AllUpdateAssignment() []IUpdateAssignmentContext
	UpdateAssignment(i int) IUpdateAssignmentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsUpdateAssignmentSeqContext differentiates from other interfaces.
	IsUpdateAssignmentSeqContext()
}

type UpdateAssignmentSeqContext struct {
	antlr.BaseParserRuleContext
	parser            antlr.Parser
	_updateAssignment IUpdateAssignmentContext
	assignments       []IUpdateAssignmentContext
}

func NewEmptyUpdateAssignmentSeqContext() *UpdateAssignmentSeqContext {
	var p = new(UpdateAssignmentSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_updateAssignmentSeq
	return p
}

func InitEmptyUpdateAssignmentSeqContext(p *UpdateAssignmentSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_updateAssignmentSeq
}

func (*UpdateAssignmentSeqContext) IsUpdateAssignmentSeqContext() {}

func NewUpdateAssignmentSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateAssignmentSeqContext {
	var p = new(UpdateAssignmentSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_updateAssignmentSeq

	return p
}

func (s *UpdateAssignmentSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateAssignmentSeqContext) Get_updateAssignment() IUpdateAssignmentContext {
	return s._updateAssignment
}

func (s *UpdateAssignmentSeqContext) Set_updateAssignment(v IUpdateAssignmentContext) {
	s._updateAssignment = v
}

func (s *UpdateAssignmentSeqContext) GetAssignments() []IUpdateAssignmentContext {
	return s.assignments
}

func (s *UpdateAssignmentSeqContext) SetAssignments(v []IUpdateAssignmentContext) { s.assignments = v }

func (s *UpdateAssignmentSeqContext) AllUpdateAssignment() []IUpdateAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdateAssignmentContext); ok {
			len++
		}
	}

	tst := make([]IUpdateAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdateAssignmentContext); ok {
			tst[i] = t.(IUpdateAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *UpdateAssignmentSeqContext) UpdateAssignment(i int) IUpdateAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateAssignmentContext)
}

func (s *UpdateAssignmentSeqContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *UpdateAssignmentSeqContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *UpdateAssignmentSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateAssignmentSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateAssignmentSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUpdateAssignmentSeq(s)
	}
}

func (s *UpdateAssignmentSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUpdateAssignmentSeq(s)
	}
}

func (p *DorisParser) UpdateAssignmentSeq() (localctx IUpdateAssignmentSeqContext) {
	localctx = NewUpdateAssignmentSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, DorisParserRULE_updateAssignmentSeq)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4897)

		var _x = p.UpdateAssignment()

		localctx.(*UpdateAssignmentSeqContext)._updateAssignment = _x
	}
	localctx.(*UpdateAssignmentSeqContext).assignments = append(localctx.(*UpdateAssignmentSeqContext).assignments, localctx.(*UpdateAssignmentSeqContext)._updateAssignment)
	p.SetState(4902)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(4898)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4899)

			var _x = p.UpdateAssignment()

			localctx.(*UpdateAssignmentSeqContext)._updateAssignment = _x
		}
		localctx.(*UpdateAssignmentSeqContext).assignments = append(localctx.(*UpdateAssignmentSeqContext).assignments, localctx.(*UpdateAssignmentSeqContext)._updateAssignment)

		p.SetState(4904)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILateralViewContext is an interface to support dynamic dispatch.
type ILateralViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFunctionName returns the functionName rule contexts.
	GetFunctionName() IIdentifierContext

	// GetTableName returns the tableName rule contexts.
	GetTableName() IIdentifierContext

	// Get_identifier returns the _identifier rule contexts.
	Get_identifier() IIdentifierContext

	// SetFunctionName sets the functionName rule contexts.
	SetFunctionName(IIdentifierContext)

	// SetTableName sets the tableName rule contexts.
	SetTableName(IIdentifierContext)

	// Set_identifier sets the _identifier rule contexts.
	Set_identifier(IIdentifierContext)

	// GetColumnNames returns the columnNames rule context list.
	GetColumnNames() []IIdentifierContext

	// SetColumnNames sets the columnNames rule context list.
	SetColumnNames([]IIdentifierContext)

	// Getter signatures
	LATERAL() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AS() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLateralViewContext differentiates from other interfaces.
	IsLateralViewContext()
}

type LateralViewContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	functionName IIdentifierContext
	tableName    IIdentifierContext
	_identifier  IIdentifierContext
	columnNames  []IIdentifierContext
}

func NewEmptyLateralViewContext() *LateralViewContext {
	var p = new(LateralViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_lateralView
	return p
}

func InitEmptyLateralViewContext(p *LateralViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_lateralView
}

func (*LateralViewContext) IsLateralViewContext() {}

func NewLateralViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LateralViewContext {
	var p = new(LateralViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_lateralView

	return p
}

func (s *LateralViewContext) GetParser() antlr.Parser { return s.parser }

func (s *LateralViewContext) GetFunctionName() IIdentifierContext { return s.functionName }

func (s *LateralViewContext) GetTableName() IIdentifierContext { return s.tableName }

func (s *LateralViewContext) Get_identifier() IIdentifierContext { return s._identifier }

func (s *LateralViewContext) SetFunctionName(v IIdentifierContext) { s.functionName = v }

func (s *LateralViewContext) SetTableName(v IIdentifierContext) { s.tableName = v }

func (s *LateralViewContext) Set_identifier(v IIdentifierContext) { s._identifier = v }

func (s *LateralViewContext) GetColumnNames() []IIdentifierContext { return s.columnNames }

func (s *LateralViewContext) SetColumnNames(v []IIdentifierContext) { s.columnNames = v }

func (s *LateralViewContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLATERAL, 0)
}

func (s *LateralViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *LateralViewContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *LateralViewContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *LateralViewContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *LateralViewContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *LateralViewContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LateralViewContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LateralViewContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LateralViewContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *LateralViewContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *LateralViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LateralViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LateralViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLateralView(s)
	}
}

func (s *LateralViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLateralView(s)
	}
}

func (p *DorisParser) LateralView() (localctx ILateralViewContext) {
	localctx = NewLateralViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, DorisParserRULE_lateralView)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4905)
		p.Match(DorisParserLATERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4906)
		p.Match(DorisParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4907)

		var _x = p.Identifier()

		localctx.(*LateralViewContext).functionName = _x
	}
	{
		p.SetState(4908)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4917)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8646890354245592708) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6341351709356361985) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-6232419426235955661) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&9126402704879377875) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-2873932114615608333) != 0) || ((int64((_la-322)) & ^0x3f) == 0 && ((int64(1)<<(_la-322))&-2310602210946850817) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&-2627780018309275847) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&-7818098869825860867) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&56383) != 0) {
		{
			p.SetState(4909)
			p.Expression()
		}
		p.SetState(4914)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(4910)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4911)
				p.Expression()
			}

			p.SetState(4916)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(4919)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4920)

		var _x = p.Identifier()

		localctx.(*LateralViewContext).tableName = _x
	}
	{
		p.SetState(4921)
		p.Match(DorisParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4922)

		var _x = p.Identifier()

		localctx.(*LateralViewContext)._identifier = _x
	}
	localctx.(*LateralViewContext).columnNames = append(localctx.(*LateralViewContext).columnNames, localctx.(*LateralViewContext)._identifier)
	p.SetState(4927)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 712, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4923)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4924)

				var _x = p.Identifier()

				localctx.(*LateralViewContext)._identifier = _x
			}
			localctx.(*LateralViewContext).columnNames = append(localctx.(*LateralViewContext).columnNames, localctx.(*LateralViewContext)._identifier)

		}
		p.SetState(4929)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 712, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryOrganizationContext is an interface to support dynamic dispatch.
type IQueryOrganizationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SortClause() ISortClauseContext
	LimitClause() ILimitClauseContext

	// IsQueryOrganizationContext differentiates from other interfaces.
	IsQueryOrganizationContext()
}

type QueryOrganizationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryOrganizationContext() *QueryOrganizationContext {
	var p = new(QueryOrganizationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_queryOrganization
	return p
}

func InitEmptyQueryOrganizationContext(p *QueryOrganizationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_queryOrganization
}

func (*QueryOrganizationContext) IsQueryOrganizationContext() {}

func NewQueryOrganizationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryOrganizationContext {
	var p = new(QueryOrganizationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_queryOrganization

	return p
}

func (s *QueryOrganizationContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryOrganizationContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *QueryOrganizationContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QueryOrganizationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryOrganizationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryOrganizationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterQueryOrganization(s)
	}
}

func (s *QueryOrganizationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitQueryOrganization(s)
	}
}

func (p *DorisParser) QueryOrganization() (localctx IQueryOrganizationContext) {
	localctx = NewQueryOrganizationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, DorisParserRULE_queryOrganization)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4931)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 713, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4930)
			p.SortClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4934)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 714, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4933)
			p.LimitClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortClauseContext is an interface to support dynamic dispatch.
type ISortClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSortClauseContext differentiates from other interfaces.
	IsSortClauseContext()
}

type SortClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortClauseContext() *SortClauseContext {
	var p = new(SortClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sortClause
	return p
}

func InitEmptySortClauseContext(p *SortClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sortClause
}

func (*SortClauseContext) IsSortClauseContext() {}

func NewSortClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortClauseContext {
	var p = new(SortClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_sortClause

	return p
}

func (s *SortClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisParserORDER, 0)
}

func (s *SortClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *SortClauseContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *SortClauseContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *SortClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *SortClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *SortClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSortClause(s)
	}
}

func (s *SortClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSortClause(s)
	}
}

func (p *DorisParser) SortClause() (localctx ISortClauseContext) {
	localctx = NewSortClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, DorisParserRULE_sortClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4936)
		p.Match(DorisParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4937)
		p.Match(DorisParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4938)
		p.SortItem()
	}
	p.SetState(4943)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 715, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4939)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4940)
				p.SortItem()
			}

		}
		p.SetState(4945)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 715, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortItemContext is an interface to support dynamic dispatch.
type ISortItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrdering returns the ordering token.
	GetOrdering() antlr.Token

	// SetOrdering sets the ordering token.
	SetOrdering(antlr.Token)

	// Getter signatures
	Expression() IExpressionContext
	NULLS() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsSortItemContext differentiates from other interfaces.
	IsSortItemContext()
}

type SortItemContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	ordering antlr.Token
}

func NewEmptySortItemContext() *SortItemContext {
	var p = new(SortItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sortItem
	return p
}

func InitEmptySortItemContext(p *SortItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sortItem
}

func (*SortItemContext) IsSortItemContext() {}

func NewSortItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortItemContext {
	var p = new(SortItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_sortItem

	return p
}

func (s *SortItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SortItemContext) GetOrdering() antlr.Token { return s.ordering }

func (s *SortItemContext) SetOrdering(v antlr.Token) { s.ordering = v }

func (s *SortItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SortItemContext) NULLS() antlr.TerminalNode {
	return s.GetToken(DorisParserNULLS, 0)
}

func (s *SortItemContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DorisParserFIRST, 0)
}

func (s *SortItemContext) LAST() antlr.TerminalNode {
	return s.GetToken(DorisParserLAST, 0)
}

func (s *SortItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(DorisParserASC, 0)
}

func (s *SortItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(DorisParserDESC, 0)
}

func (s *SortItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSortItem(s)
	}
}

func (s *SortItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSortItem(s)
	}
}

func (p *DorisParser) SortItem() (localctx ISortItemContext) {
	localctx = NewSortItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, DorisParserRULE_sortItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4946)
		p.Expression()
	}
	p.SetState(4948)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 716, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4947)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).ordering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserASC || _la == DorisParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).ordering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4952)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 717, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4950)
			p.Match(DorisParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4951)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserFIRST || _la == DorisParserLAST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// GetOffset returns the offset token.
	GetOffset() antlr.Token

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// SetOffset sets the offset token.
	SetOffset(antlr.Token)

	// Getter signatures
	LIMIT() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	limit  antlr.Token
	offset antlr.Token
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_limitClause
	return p
}

func InitEmptyLimitClauseContext(p *LimitClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_limitClause
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) GetLimit() antlr.Token { return s.limit }

func (s *LimitClauseContext) GetOffset() antlr.Token { return s.offset }

func (s *LimitClauseContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *LimitClauseContext) SetOffset(v antlr.Token) { s.offset = v }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(DorisParserLIMIT, 0)
}

func (s *LimitClauseContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserINTEGER_VALUE)
}

func (s *LimitClauseContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, i)
}

func (s *LimitClauseContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(DorisParserOFFSET, 0)
}

func (s *LimitClauseContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, 0)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLimitClause(s)
	}
}

func (p *DorisParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, DorisParserRULE_limitClause)
	p.SetState(4964)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 718, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4954)
			p.Match(DorisParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4955)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*LimitClauseContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4956)
			p.Match(DorisParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4957)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*LimitClauseContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4958)
			p.Match(DorisParserOFFSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4959)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*LimitClauseContext).offset = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4960)
			p.Match(DorisParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4961)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*LimitClauseContext).offset = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4962)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4963)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*LimitClauseContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionClauseContext is an interface to support dynamic dispatch.
type IPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionClauseContext differentiates from other interfaces.
	IsPartitionClauseContext()
}

type PartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionClauseContext() *PartitionClauseContext {
	var p = new(PartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionClause
	return p
}

func InitEmptyPartitionClauseContext(p *PartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionClause
}

func (*PartitionClauseContext) IsPartitionClauseContext() {}

func NewPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionClauseContext {
	var p = new(PartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_partitionClause

	return p
}

func (s *PartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *PartitionClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *PartitionClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *PartitionClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *PartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPartitionClause(s)
	}
}

func (s *PartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPartitionClause(s)
	}
}

func (p *DorisParser) PartitionClause() (localctx IPartitionClauseContext) {
	localctx = NewPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, DorisParserRULE_partitionClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4966)
		p.Match(DorisParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4967)
		p.Match(DorisParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4968)
		p.Expression()
	}
	p.SetState(4973)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(4969)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4970)
			p.Expression()
		}

		p.SetState(4975)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinTypeContext is an interface to support dynamic dispatch.
type IJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INNER() antlr.TerminalNode
	CROSS() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	FULL() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	ANTI() antlr.TerminalNode

	// IsJoinTypeContext differentiates from other interfaces.
	IsJoinTypeContext()
}

type JoinTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinTypeContext() *JoinTypeContext {
	var p = new(JoinTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_joinType
	return p
}

func InitEmptyJoinTypeContext(p *JoinTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_joinType
}

func (*JoinTypeContext) IsJoinTypeContext() {}

func NewJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinTypeContext {
	var p = new(JoinTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_joinType

	return p
}

func (s *JoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinTypeContext) INNER() antlr.TerminalNode {
	return s.GetToken(DorisParserINNER, 0)
}

func (s *JoinTypeContext) CROSS() antlr.TerminalNode {
	return s.GetToken(DorisParserCROSS, 0)
}

func (s *JoinTypeContext) LEFT() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT, 0)
}

func (s *JoinTypeContext) OUTER() antlr.TerminalNode {
	return s.GetToken(DorisParserOUTER, 0)
}

func (s *JoinTypeContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT, 0)
}

func (s *JoinTypeContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserFULL, 0)
}

func (s *JoinTypeContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DorisParserSEMI, 0)
}

func (s *JoinTypeContext) ANTI() antlr.TerminalNode {
	return s.GetToken(DorisParserANTI, 0)
}

func (s *JoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterJoinType(s)
	}
}

func (s *JoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitJoinType(s)
	}
}

func (p *DorisParser) JoinType() (localctx IJoinTypeContext) {
	localctx = NewJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, DorisParserRULE_joinType)
	var _la int

	p.SetState(5000)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 724, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4977)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserINNER {
			{
				p.SetState(4976)
				p.Match(DorisParserINNER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4979)
			p.Match(DorisParserCROSS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4980)
			p.Match(DorisParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4982)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserOUTER {
			{
				p.SetState(4981)
				p.Match(DorisParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4984)
			p.Match(DorisParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4986)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserOUTER {
			{
				p.SetState(4985)
				p.Match(DorisParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4988)
			p.Match(DorisParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4990)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserOUTER {
			{
				p.SetState(4989)
				p.Match(DorisParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4992)
			p.Match(DorisParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4993)
			p.Match(DorisParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4994)
			p.Match(DorisParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4995)
			p.Match(DorisParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4996)
			p.Match(DorisParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4997)
			p.Match(DorisParserANTI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4998)
			p.Match(DorisParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4999)
			p.Match(DorisParserANTI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinCriteriaContext is an interface to support dynamic dispatch.
type IJoinCriteriaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext
	USING() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsJoinCriteriaContext differentiates from other interfaces.
	IsJoinCriteriaContext()
}

type JoinCriteriaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinCriteriaContext() *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_joinCriteria
	return p
}

func InitEmptyJoinCriteriaContext(p *JoinCriteriaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_joinCriteria
}

func (*JoinCriteriaContext) IsJoinCriteriaContext() {}

func NewJoinCriteriaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_joinCriteria

	return p
}

func (s *JoinCriteriaContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinCriteriaContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *JoinCriteriaContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *JoinCriteriaContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserUSING, 0)
}

func (s *JoinCriteriaContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *JoinCriteriaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinCriteriaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinCriteriaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitJoinCriteria(s)
	}
}

func (p *DorisParser) JoinCriteria() (localctx IJoinCriteriaContext) {
	localctx = NewJoinCriteriaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, DorisParserRULE_joinCriteria)
	p.SetState(5006)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5002)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5003)
			p.booleanExpression(0)
		}

	case DorisParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5004)
			p.Match(DorisParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5005)
			p.IdentifierList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	IdentifierSeq() IIdentifierSeqContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierList
	return p
}

func InitEmptyIdentifierListContext(p *IdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierList
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *IdentifierListContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *IdentifierListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (p *DorisParser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, DorisParserRULE_identifierList)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5008)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5009)
		p.IdentifierSeq()
	}
	{
		p.SetState(5010)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierSeqContext is an interface to support dynamic dispatch.
type IIdentifierSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_errorCapturingIdentifier returns the _errorCapturingIdentifier rule contexts.
	Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext

	// Set_errorCapturingIdentifier sets the _errorCapturingIdentifier rule contexts.
	Set_errorCapturingIdentifier(IErrorCapturingIdentifierContext)

	// GetIdent returns the ident rule context list.
	GetIdent() []IErrorCapturingIdentifierContext

	// SetIdent sets the ident rule context list.
	SetIdent([]IErrorCapturingIdentifierContext)

	// Getter signatures
	AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext
	ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentifierSeqContext differentiates from other interfaces.
	IsIdentifierSeqContext()
}

type IdentifierSeqContext struct {
	antlr.BaseParserRuleContext
	parser                    antlr.Parser
	_errorCapturingIdentifier IErrorCapturingIdentifierContext
	ident                     []IErrorCapturingIdentifierContext
}

func NewEmptyIdentifierSeqContext() *IdentifierSeqContext {
	var p = new(IdentifierSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierSeq
	return p
}

func InitEmptyIdentifierSeqContext(p *IdentifierSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierSeq
}

func (*IdentifierSeqContext) IsIdentifierSeqContext() {}

func NewIdentifierSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierSeqContext {
	var p = new(IdentifierSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_identifierSeq

	return p
}

func (s *IdentifierSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierSeqContext) Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext {
	return s._errorCapturingIdentifier
}

func (s *IdentifierSeqContext) Set_errorCapturingIdentifier(v IErrorCapturingIdentifierContext) {
	s._errorCapturingIdentifier = v
}

func (s *IdentifierSeqContext) GetIdent() []IErrorCapturingIdentifierContext { return s.ident }

func (s *IdentifierSeqContext) SetIdent(v []IErrorCapturingIdentifierContext) { s.ident = v }

func (s *IdentifierSeqContext) AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IErrorCapturingIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			tst[i] = t.(IErrorCapturingIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierSeqContext) ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *IdentifierSeqContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *IdentifierSeqContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *IdentifierSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIdentifierSeq(s)
	}
}

func (s *IdentifierSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIdentifierSeq(s)
	}
}

func (p *DorisParser) IdentifierSeq() (localctx IIdentifierSeqContext) {
	localctx = NewIdentifierSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, DorisParserRULE_identifierSeq)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5012)

		var _x = p.ErrorCapturingIdentifier()

		localctx.(*IdentifierSeqContext)._errorCapturingIdentifier = _x
	}
	localctx.(*IdentifierSeqContext).ident = append(localctx.(*IdentifierSeqContext).ident, localctx.(*IdentifierSeqContext)._errorCapturingIdentifier)
	p.SetState(5017)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(5013)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5014)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*IdentifierSeqContext)._errorCapturingIdentifier = _x
		}
		localctx.(*IdentifierSeqContext).ident = append(localctx.(*IdentifierSeqContext).ident, localctx.(*IdentifierSeqContext)._errorCapturingIdentifier)

		p.SetState(5019)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptScanParamsContext is an interface to support dynamic dispatch.
type IOptScanParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFuncName returns the funcName rule contexts.
	GetFuncName() IIdentifierContext

	// GetProperties returns the properties rule contexts.
	GetProperties() IPropertyItemListContext

	// SetFuncName sets the funcName rule contexts.
	SetFuncName(IIdentifierContext)

	// SetProperties sets the properties rule contexts.
	SetProperties(IPropertyItemListContext)

	// Getter signatures
	ATSIGN() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	PropertyItemList() IPropertyItemListContext

	// IsOptScanParamsContext differentiates from other interfaces.
	IsOptScanParamsContext()
}

type OptScanParamsContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	funcName   IIdentifierContext
	properties IPropertyItemListContext
}

func NewEmptyOptScanParamsContext() *OptScanParamsContext {
	var p = new(OptScanParamsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_optScanParams
	return p
}

func InitEmptyOptScanParamsContext(p *OptScanParamsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_optScanParams
}

func (*OptScanParamsContext) IsOptScanParamsContext() {}

func NewOptScanParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptScanParamsContext {
	var p = new(OptScanParamsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_optScanParams

	return p
}

func (s *OptScanParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *OptScanParamsContext) GetFuncName() IIdentifierContext { return s.funcName }

func (s *OptScanParamsContext) GetProperties() IPropertyItemListContext { return s.properties }

func (s *OptScanParamsContext) SetFuncName(v IIdentifierContext) { s.funcName = v }

func (s *OptScanParamsContext) SetProperties(v IPropertyItemListContext) { s.properties = v }

func (s *OptScanParamsContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserATSIGN, 0)
}

func (s *OptScanParamsContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *OptScanParamsContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *OptScanParamsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *OptScanParamsContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *OptScanParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptScanParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptScanParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterOptScanParams(s)
	}
}

func (s *OptScanParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitOptScanParams(s)
	}
}

func (p *DorisParser) OptScanParams() (localctx IOptScanParamsContext) {
	localctx = NewOptScanParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, DorisParserRULE_optScanParams)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5020)
		p.Match(DorisParserATSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5021)

		var _x = p.Identifier()

		localctx.(*OptScanParamsContext).funcName = _x
	}
	{
		p.SetState(5022)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5024)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8646890354245576320) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&3026312906716208575) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-6232420542927452621) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&3937129999880936915) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-2873940910708630541) != 0) || ((int64((_la-322)) & ^0x3f) == 0 && ((int64(1)<<(_la-322))&6912752233721880575) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&-2627780018309275847) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&72207677327248109) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&56359) != 0) {
		{
			p.SetState(5023)

			var _x = p.PropertyItemList()

			localctx.(*OptScanParamsContext).properties = _x
		}

	}
	{
		p.SetState(5026)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationPrimaryContext is an interface to support dynamic dispatch.
type IRelationPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationPrimaryContext differentiates from other interfaces.
	IsRelationPrimaryContext()
}

type RelationPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationPrimaryContext() *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_relationPrimary
	return p
}

func InitEmptyRelationPrimaryContext(p *RelationPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_relationPrimary
}

func (*RelationPrimaryContext) IsRelationPrimaryContext() {}

func NewRelationPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_relationPrimary

	return p
}

func (s *RelationPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationPrimaryContext) CopyAll(ctx *RelationPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RelationPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableValuedFunctionContext struct {
	RelationPrimaryContext
	tvfName    IIdentifierContext
	properties IPropertyItemListContext
}

func NewTableValuedFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableValuedFunctionContext {
	var p = new(TableValuedFunctionContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableValuedFunctionContext) GetTvfName() IIdentifierContext { return s.tvfName }

func (s *TableValuedFunctionContext) GetProperties() IPropertyItemListContext { return s.properties }

func (s *TableValuedFunctionContext) SetTvfName(v IIdentifierContext) { s.tvfName = v }

func (s *TableValuedFunctionContext) SetProperties(v IPropertyItemListContext) { s.properties = v }

func (s *TableValuedFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableValuedFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *TableValuedFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *TableValuedFunctionContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *TableValuedFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableValuedFunctionContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *TableValuedFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTableValuedFunction(s)
	}
}

func (s *TableValuedFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTableValuedFunction(s)
	}
}

type RelationListContext struct {
	RelationPrimaryContext
}

func NewRelationListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationListContext {
	var p = new(RelationListContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *RelationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *RelationListContext) Relations() IRelationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationsContext)
}

func (s *RelationListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *RelationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRelationList(s)
	}
}

func (s *RelationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRelationList(s)
	}
}

type AliasedQueryContext struct {
	RelationPrimaryContext
}

func NewAliasedQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AliasedQueryContext {
	var p = new(AliasedQueryContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *AliasedQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasedQueryContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AliasedQueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *AliasedQueryContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AliasedQueryContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *AliasedQueryContext) AllLateralView() []ILateralViewContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILateralViewContext); ok {
			len++
		}
	}

	tst := make([]ILateralViewContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILateralViewContext); ok {
			tst[i] = t.(ILateralViewContext)
			i++
		}
	}

	return tst
}

func (s *AliasedQueryContext) LateralView(i int) ILateralViewContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILateralViewContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILateralViewContext)
}

func (s *AliasedQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAliasedQuery(s)
	}
}

func (s *AliasedQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAliasedQuery(s)
	}
}

type TableNameContext struct {
	RelationPrimaryContext
}

func NewTableNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableNameContext {
	var p = new(TableNameContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *TableNameContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *TableNameContext) OptScanParams() IOptScanParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptScanParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptScanParamsContext)
}

func (s *TableNameContext) MaterializedViewName() IMaterializedViewNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaterializedViewNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaterializedViewNameContext)
}

func (s *TableNameContext) TableSnapshot() ITableSnapshotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSnapshotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSnapshotContext)
}

func (s *TableNameContext) SpecifiedPartition() ISpecifiedPartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecifiedPartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecifiedPartitionContext)
}

func (s *TableNameContext) TabletList() ITabletListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabletListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabletListContext)
}

func (s *TableNameContext) Sample() ISampleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleContext)
}

func (s *TableNameContext) RelationHint() IRelationHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationHintContext)
}

func (s *TableNameContext) AllLateralView() []ILateralViewContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILateralViewContext); ok {
			len++
		}
	}

	tst := make([]ILateralViewContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILateralViewContext); ok {
			tst[i] = t.(ILateralViewContext)
			i++
		}
	}

	return tst
}

func (s *TableNameContext) LateralView(i int) ILateralViewContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILateralViewContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILateralViewContext)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (p *DorisParser) RelationPrimary() (localctx IRelationPrimaryContext) {
	localctx = NewRelationPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, DorisParserRULE_relationPrimary)
	var _la int

	var _alt int

	p.SetState(5079)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 738, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableNameContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5028)
			p.MultipartIdentifier()
		}
		p.SetState(5030)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 728, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5029)
				p.OptScanParams()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5033)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 729, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5032)
				p.MaterializedViewName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5036)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 730, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5035)
				p.TableSnapshot()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5039)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 731, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5038)
				p.SpecifiedPartition()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5042)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 732, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5041)
				p.TabletList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5044)
			p.TableAlias()
		}
		p.SetState(5046)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 733, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5045)
				p.Sample()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5049)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 734, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5048)
				p.RelationHint()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5054)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 735, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(5051)
					p.LateralView()
				}

			}
			p.SetState(5056)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 735, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		localctx = NewAliasedQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5057)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5058)
			p.Query()
		}
		{
			p.SetState(5059)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5060)
			p.TableAlias()
		}
		p.SetState(5064)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 736, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(5061)
					p.LateralView()
				}

			}
			p.SetState(5066)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 736, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 3:
		localctx = NewTableValuedFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5067)

			var _x = p.Identifier()

			localctx.(*TableValuedFunctionContext).tvfName = _x
		}
		{
			p.SetState(5068)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5070)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8646890354245576320) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&3026312906716208575) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-6232420542927452621) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&3937129999880936915) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-2873940910708630541) != 0) || ((int64((_la-322)) & ^0x3f) == 0 && ((int64(1)<<(_la-322))&6912752233721880575) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&-2627780018309275847) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&72207677327248109) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&56359) != 0) {
			{
				p.SetState(5069)

				var _x = p.PropertyItemList()

				localctx.(*TableValuedFunctionContext).properties = _x
			}

		}
		{
			p.SetState(5072)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5073)
			p.TableAlias()
		}

	case 4:
		localctx = NewRelationListContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5075)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5076)
			p.Relations()
		}
		{
			p.SetState(5077)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaterializedViewNameContext is an interface to support dynamic dispatch.
type IMaterializedViewNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// Getter signatures
	INDEX() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsMaterializedViewNameContext differentiates from other interfaces.
	IsMaterializedViewNameContext()
}

type MaterializedViewNameContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	indexName IIdentifierContext
}

func NewEmptyMaterializedViewNameContext() *MaterializedViewNameContext {
	var p = new(MaterializedViewNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_materializedViewName
	return p
}

func InitEmptyMaterializedViewNameContext(p *MaterializedViewNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_materializedViewName
}

func (*MaterializedViewNameContext) IsMaterializedViewNameContext() {}

func NewMaterializedViewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaterializedViewNameContext {
	var p = new(MaterializedViewNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_materializedViewName

	return p
}

func (s *MaterializedViewNameContext) GetParser() antlr.Parser { return s.parser }

func (s *MaterializedViewNameContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *MaterializedViewNameContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *MaterializedViewNameContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *MaterializedViewNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MaterializedViewNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaterializedViewNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaterializedViewNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMaterializedViewName(s)
	}
}

func (s *MaterializedViewNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMaterializedViewName(s)
	}
}

func (p *DorisParser) MaterializedViewName() (localctx IMaterializedViewNameContext) {
	localctx = NewMaterializedViewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, DorisParserRULE_materializedViewName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5081)
		p.Match(DorisParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5082)

		var _x = p.Identifier()

		localctx.(*MaterializedViewNameContext).indexName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyClauseContext is an interface to support dynamic dispatch.
type IPropertyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFileProperties returns the fileProperties rule contexts.
	GetFileProperties() IPropertyItemListContext

	// SetFileProperties sets the fileProperties rule contexts.
	SetFileProperties(IPropertyItemListContext)

	// Getter signatures
	PROPERTIES() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	PropertyItemList() IPropertyItemListContext

	// IsPropertyClauseContext differentiates from other interfaces.
	IsPropertyClauseContext()
}

type PropertyClauseContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	fileProperties IPropertyItemListContext
}

func NewEmptyPropertyClauseContext() *PropertyClauseContext {
	var p = new(PropertyClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyClause
	return p
}

func InitEmptyPropertyClauseContext(p *PropertyClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyClause
}

func (*PropertyClauseContext) IsPropertyClauseContext() {}

func NewPropertyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyClauseContext {
	var p = new(PropertyClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_propertyClause

	return p
}

func (s *PropertyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyClauseContext) GetFileProperties() IPropertyItemListContext { return s.fileProperties }

func (s *PropertyClauseContext) SetFileProperties(v IPropertyItemListContext) { s.fileProperties = v }

func (s *PropertyClauseContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *PropertyClauseContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *PropertyClauseContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *PropertyClauseContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *PropertyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPropertyClause(s)
	}
}

func (s *PropertyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPropertyClause(s)
	}
}

func (p *DorisParser) PropertyClause() (localctx IPropertyClauseContext) {
	localctx = NewPropertyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, DorisParserRULE_propertyClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5084)
		p.Match(DorisParserPROPERTIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5085)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5086)

		var _x = p.PropertyItemList()

		localctx.(*PropertyClauseContext).fileProperties = _x
	}
	{
		p.SetState(5087)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyItemListContext is an interface to support dynamic dispatch.
type IPropertyItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_propertyItem returns the _propertyItem rule contexts.
	Get_propertyItem() IPropertyItemContext

	// Set_propertyItem sets the _propertyItem rule contexts.
	Set_propertyItem(IPropertyItemContext)

	// GetProperties returns the properties rule context list.
	GetProperties() []IPropertyItemContext

	// SetProperties sets the properties rule context list.
	SetProperties([]IPropertyItemContext)

	// Getter signatures
	AllPropertyItem() []IPropertyItemContext
	PropertyItem(i int) IPropertyItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPropertyItemListContext differentiates from other interfaces.
	IsPropertyItemListContext()
}

type PropertyItemListContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	_propertyItem IPropertyItemContext
	properties    []IPropertyItemContext
}

func NewEmptyPropertyItemListContext() *PropertyItemListContext {
	var p = new(PropertyItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyItemList
	return p
}

func InitEmptyPropertyItemListContext(p *PropertyItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyItemList
}

func (*PropertyItemListContext) IsPropertyItemListContext() {}

func NewPropertyItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyItemListContext {
	var p = new(PropertyItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_propertyItemList

	return p
}

func (s *PropertyItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyItemListContext) Get_propertyItem() IPropertyItemContext { return s._propertyItem }

func (s *PropertyItemListContext) Set_propertyItem(v IPropertyItemContext) { s._propertyItem = v }

func (s *PropertyItemListContext) GetProperties() []IPropertyItemContext { return s.properties }

func (s *PropertyItemListContext) SetProperties(v []IPropertyItemContext) { s.properties = v }

func (s *PropertyItemListContext) AllPropertyItem() []IPropertyItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyItemContext); ok {
			len++
		}
	}

	tst := make([]IPropertyItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyItemContext); ok {
			tst[i] = t.(IPropertyItemContext)
			i++
		}
	}

	return tst
}

func (s *PropertyItemListContext) PropertyItem(i int) IPropertyItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemContext)
}

func (s *PropertyItemListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *PropertyItemListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *PropertyItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPropertyItemList(s)
	}
}

func (s *PropertyItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPropertyItemList(s)
	}
}

func (p *DorisParser) PropertyItemList() (localctx IPropertyItemListContext) {
	localctx = NewPropertyItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, DorisParserRULE_propertyItemList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5089)

		var _x = p.PropertyItem()

		localctx.(*PropertyItemListContext)._propertyItem = _x
	}
	localctx.(*PropertyItemListContext).properties = append(localctx.(*PropertyItemListContext).properties, localctx.(*PropertyItemListContext)._propertyItem)
	p.SetState(5094)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(5090)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5091)

			var _x = p.PropertyItem()

			localctx.(*PropertyItemListContext)._propertyItem = _x
		}
		localctx.(*PropertyItemListContext).properties = append(localctx.(*PropertyItemListContext).properties, localctx.(*PropertyItemListContext)._propertyItem)

		p.SetState(5096)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyItemContext is an interface to support dynamic dispatch.
type IPropertyItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IPropertyKeyContext

	// GetValue returns the value rule contexts.
	GetValue() IPropertyValueContext

	// SetKey sets the key rule contexts.
	SetKey(IPropertyKeyContext)

	// SetValue sets the value rule contexts.
	SetValue(IPropertyValueContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	PropertyKey() IPropertyKeyContext
	PropertyValue() IPropertyValueContext

	// IsPropertyItemContext differentiates from other interfaces.
	IsPropertyItemContext()
}

type PropertyItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IPropertyKeyContext
	value  IPropertyValueContext
}

func NewEmptyPropertyItemContext() *PropertyItemContext {
	var p = new(PropertyItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyItem
	return p
}

func InitEmptyPropertyItemContext(p *PropertyItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyItem
}

func (*PropertyItemContext) IsPropertyItemContext() {}

func NewPropertyItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyItemContext {
	var p = new(PropertyItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_propertyItem

	return p
}

func (s *PropertyItemContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyItemContext) GetKey() IPropertyKeyContext { return s.key }

func (s *PropertyItemContext) GetValue() IPropertyValueContext { return s.value }

func (s *PropertyItemContext) SetKey(v IPropertyKeyContext) { s.key = v }

func (s *PropertyItemContext) SetValue(v IPropertyValueContext) { s.value = v }

func (s *PropertyItemContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *PropertyItemContext) PropertyKey() IPropertyKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyKeyContext)
}

func (s *PropertyItemContext) PropertyValue() IPropertyValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyValueContext)
}

func (s *PropertyItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPropertyItem(s)
	}
}

func (s *PropertyItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPropertyItem(s)
	}
}

func (p *DorisParser) PropertyItem() (localctx IPropertyItemContext) {
	localctx = NewPropertyItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, DorisParserRULE_propertyItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5097)

		var _x = p.PropertyKey()

		localctx.(*PropertyItemContext).key = _x
	}
	{
		p.SetState(5098)
		p.Match(DorisParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5099)

		var _x = p.PropertyValue()

		localctx.(*PropertyItemContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyKeyContext is an interface to support dynamic dispatch.
type IPropertyKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Constant() IConstantContext

	// IsPropertyKeyContext differentiates from other interfaces.
	IsPropertyKeyContext()
}

type PropertyKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyKeyContext() *PropertyKeyContext {
	var p = new(PropertyKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyKey
	return p
}

func InitEmptyPropertyKeyContext(p *PropertyKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyKey
}

func (*PropertyKeyContext) IsPropertyKeyContext() {}

func NewPropertyKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyKeyContext {
	var p = new(PropertyKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_propertyKey

	return p
}

func (s *PropertyKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyKeyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyKeyContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *PropertyKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPropertyKey(s)
	}
}

func (s *PropertyKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPropertyKey(s)
	}
}

func (p *DorisParser) PropertyKey() (localctx IPropertyKeyContext) {
	localctx = NewPropertyKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, DorisParserRULE_propertyKey)
	p.SetState(5103)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 740, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5101)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5102)
			p.Constant()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyValueContext is an interface to support dynamic dispatch.
type IPropertyValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Constant() IConstantContext

	// IsPropertyValueContext differentiates from other interfaces.
	IsPropertyValueContext()
}

type PropertyValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyValueContext() *PropertyValueContext {
	var p = new(PropertyValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyValue
	return p
}

func InitEmptyPropertyValueContext(p *PropertyValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyValue
}

func (*PropertyValueContext) IsPropertyValueContext() {}

func NewPropertyValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyValueContext {
	var p = new(PropertyValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_propertyValue

	return p
}

func (s *PropertyValueContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyValueContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyValueContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *PropertyValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPropertyValue(s)
	}
}

func (s *PropertyValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPropertyValue(s)
	}
}

func (p *DorisParser) PropertyValue() (localctx IPropertyValueContext) {
	localctx = NewPropertyValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, DorisParserRULE_propertyValue)
	p.SetState(5107)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 741, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5105)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5106)
			p.Constant()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableAliasContext is an interface to support dynamic dispatch.
type ITableAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StrictIdentifier() IStrictIdentifierContext
	AS() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsTableAliasContext differentiates from other interfaces.
	IsTableAliasContext()
}

type TableAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableAliasContext() *TableAliasContext {
	var p = new(TableAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tableAlias
	return p
}

func InitEmptyTableAliasContext(p *TableAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tableAlias
}

func (*TableAliasContext) IsTableAliasContext() {}

func NewTableAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableAliasContext {
	var p = new(TableAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_tableAlias

	return p
}

func (s *TableAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *TableAliasContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *TableAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *TableAliasContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *TableAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTableAlias(s)
	}
}

func (s *TableAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTableAlias(s)
	}
}

func (p *DorisParser) TableAlias() (localctx ITableAliasContext) {
	localctx = NewTableAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, DorisParserRULE_tableAlias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5116)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 744, p.GetParserRuleContext()) == 1 {
		p.SetState(5110)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAS {
			{
				p.SetState(5109)
				p.Match(DorisParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5112)
			p.StrictIdentifier()
		}
		p.SetState(5114)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 743, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5113)
				p.IdentifierList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultipartIdentifierContext is an interface to support dynamic dispatch.
type IMultipartIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_errorCapturingIdentifier returns the _errorCapturingIdentifier rule contexts.
	Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext

	// Set_errorCapturingIdentifier sets the _errorCapturingIdentifier rule contexts.
	Set_errorCapturingIdentifier(IErrorCapturingIdentifierContext)

	// GetParts returns the parts rule context list.
	GetParts() []IErrorCapturingIdentifierContext

	// SetParts sets the parts rule context list.
	SetParts([]IErrorCapturingIdentifierContext)

	// Getter signatures
	AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext
	ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsMultipartIdentifierContext differentiates from other interfaces.
	IsMultipartIdentifierContext()
}

type MultipartIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser                    antlr.Parser
	_errorCapturingIdentifier IErrorCapturingIdentifierContext
	parts                     []IErrorCapturingIdentifierContext
}

func NewEmptyMultipartIdentifierContext() *MultipartIdentifierContext {
	var p = new(MultipartIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_multipartIdentifier
	return p
}

func InitEmptyMultipartIdentifierContext(p *MultipartIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_multipartIdentifier
}

func (*MultipartIdentifierContext) IsMultipartIdentifierContext() {}

func NewMultipartIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipartIdentifierContext {
	var p = new(MultipartIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_multipartIdentifier

	return p
}

func (s *MultipartIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipartIdentifierContext) Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext {
	return s._errorCapturingIdentifier
}

func (s *MultipartIdentifierContext) Set_errorCapturingIdentifier(v IErrorCapturingIdentifierContext) {
	s._errorCapturingIdentifier = v
}

func (s *MultipartIdentifierContext) GetParts() []IErrorCapturingIdentifierContext { return s.parts }

func (s *MultipartIdentifierContext) SetParts(v []IErrorCapturingIdentifierContext) { s.parts = v }

func (s *MultipartIdentifierContext) AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IErrorCapturingIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			tst[i] = t.(IErrorCapturingIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *MultipartIdentifierContext) ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *MultipartIdentifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(DorisParserDOT)
}

func (s *MultipartIdentifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, i)
}

func (s *MultipartIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipartIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipartIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMultipartIdentifier(s)
	}
}

func (s *MultipartIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMultipartIdentifier(s)
	}
}

func (p *DorisParser) MultipartIdentifier() (localctx IMultipartIdentifierContext) {
	localctx = NewMultipartIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, DorisParserRULE_multipartIdentifier)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5118)

		var _x = p.ErrorCapturingIdentifier()

		localctx.(*MultipartIdentifierContext)._errorCapturingIdentifier = _x
	}
	localctx.(*MultipartIdentifierContext).parts = append(localctx.(*MultipartIdentifierContext).parts, localctx.(*MultipartIdentifierContext)._errorCapturingIdentifier)
	p.SetState(5123)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 745, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5119)
				p.Match(DorisParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5120)

				var _x = p.ErrorCapturingIdentifier()

				localctx.(*MultipartIdentifierContext)._errorCapturingIdentifier = _x
			}
			localctx.(*MultipartIdentifierContext).parts = append(localctx.(*MultipartIdentifierContext).parts, localctx.(*MultipartIdentifierContext)._errorCapturingIdentifier)

		}
		p.SetState(5125)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 745, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleColumnDefsContext is an interface to support dynamic dispatch.
type ISimpleColumnDefsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_simpleColumnDef returns the _simpleColumnDef rule contexts.
	Get_simpleColumnDef() ISimpleColumnDefContext

	// Set_simpleColumnDef sets the _simpleColumnDef rule contexts.
	Set_simpleColumnDef(ISimpleColumnDefContext)

	// GetCols returns the cols rule context list.
	GetCols() []ISimpleColumnDefContext

	// SetCols sets the cols rule context list.
	SetCols([]ISimpleColumnDefContext)

	// Getter signatures
	AllSimpleColumnDef() []ISimpleColumnDefContext
	SimpleColumnDef(i int) ISimpleColumnDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSimpleColumnDefsContext differentiates from other interfaces.
	IsSimpleColumnDefsContext()
}

type SimpleColumnDefsContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	_simpleColumnDef ISimpleColumnDefContext
	cols             []ISimpleColumnDefContext
}

func NewEmptySimpleColumnDefsContext() *SimpleColumnDefsContext {
	var p = new(SimpleColumnDefsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_simpleColumnDefs
	return p
}

func InitEmptySimpleColumnDefsContext(p *SimpleColumnDefsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_simpleColumnDefs
}

func (*SimpleColumnDefsContext) IsSimpleColumnDefsContext() {}

func NewSimpleColumnDefsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleColumnDefsContext {
	var p = new(SimpleColumnDefsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_simpleColumnDefs

	return p
}

func (s *SimpleColumnDefsContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleColumnDefsContext) Get_simpleColumnDef() ISimpleColumnDefContext {
	return s._simpleColumnDef
}

func (s *SimpleColumnDefsContext) Set_simpleColumnDef(v ISimpleColumnDefContext) {
	s._simpleColumnDef = v
}

func (s *SimpleColumnDefsContext) GetCols() []ISimpleColumnDefContext { return s.cols }

func (s *SimpleColumnDefsContext) SetCols(v []ISimpleColumnDefContext) { s.cols = v }

func (s *SimpleColumnDefsContext) AllSimpleColumnDef() []ISimpleColumnDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleColumnDefContext); ok {
			len++
		}
	}

	tst := make([]ISimpleColumnDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleColumnDefContext); ok {
			tst[i] = t.(ISimpleColumnDefContext)
			i++
		}
	}

	return tst
}

func (s *SimpleColumnDefsContext) SimpleColumnDef(i int) ISimpleColumnDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleColumnDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleColumnDefContext)
}

func (s *SimpleColumnDefsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *SimpleColumnDefsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *SimpleColumnDefsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleColumnDefsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleColumnDefsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSimpleColumnDefs(s)
	}
}

func (s *SimpleColumnDefsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSimpleColumnDefs(s)
	}
}

func (p *DorisParser) SimpleColumnDefs() (localctx ISimpleColumnDefsContext) {
	localctx = NewSimpleColumnDefsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, DorisParserRULE_simpleColumnDefs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5126)

		var _x = p.SimpleColumnDef()

		localctx.(*SimpleColumnDefsContext)._simpleColumnDef = _x
	}
	localctx.(*SimpleColumnDefsContext).cols = append(localctx.(*SimpleColumnDefsContext).cols, localctx.(*SimpleColumnDefsContext)._simpleColumnDef)
	p.SetState(5131)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(5127)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5128)

			var _x = p.SimpleColumnDef()

			localctx.(*SimpleColumnDefsContext)._simpleColumnDef = _x
		}
		localctx.(*SimpleColumnDefsContext).cols = append(localctx.(*SimpleColumnDefsContext).cols, localctx.(*SimpleColumnDefsContext)._simpleColumnDef)

		p.SetState(5133)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleColumnDefContext is an interface to support dynamic dispatch.
type ISimpleColumnDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetComment returns the comment token.
	GetComment() antlr.Token

	// SetComment sets the comment token.
	SetComment(antlr.Token)

	// GetColName returns the colName rule contexts.
	GetColName() IIdentifierContext

	// SetColName sets the colName rule contexts.
	SetColName(IIdentifierContext)

	// Getter signatures
	Identifier() IIdentifierContext
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsSimpleColumnDefContext differentiates from other interfaces.
	IsSimpleColumnDefContext()
}

type SimpleColumnDefContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	colName IIdentifierContext
	comment antlr.Token
}

func NewEmptySimpleColumnDefContext() *SimpleColumnDefContext {
	var p = new(SimpleColumnDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_simpleColumnDef
	return p
}

func InitEmptySimpleColumnDefContext(p *SimpleColumnDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_simpleColumnDef
}

func (*SimpleColumnDefContext) IsSimpleColumnDefContext() {}

func NewSimpleColumnDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleColumnDefContext {
	var p = new(SimpleColumnDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_simpleColumnDef

	return p
}

func (s *SimpleColumnDefContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleColumnDefContext) GetComment() antlr.Token { return s.comment }

func (s *SimpleColumnDefContext) SetComment(v antlr.Token) { s.comment = v }

func (s *SimpleColumnDefContext) GetColName() IIdentifierContext { return s.colName }

func (s *SimpleColumnDefContext) SetColName(v IIdentifierContext) { s.colName = v }

func (s *SimpleColumnDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SimpleColumnDefContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *SimpleColumnDefContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *SimpleColumnDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleColumnDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleColumnDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSimpleColumnDef(s)
	}
}

func (s *SimpleColumnDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSimpleColumnDef(s)
	}
}

func (p *DorisParser) SimpleColumnDef() (localctx ISimpleColumnDefContext) {
	localctx = NewSimpleColumnDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, DorisParserRULE_simpleColumnDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5134)

		var _x = p.Identifier()

		localctx.(*SimpleColumnDefContext).colName = _x
	}
	p.SetState(5137)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserCOMMENT {
		{
			p.SetState(5135)
			p.Match(DorisParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5136)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*SimpleColumnDefContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDefsContext is an interface to support dynamic dispatch.
type IColumnDefsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_columnDef returns the _columnDef rule contexts.
	Get_columnDef() IColumnDefContext

	// Set_columnDef sets the _columnDef rule contexts.
	Set_columnDef(IColumnDefContext)

	// GetCols returns the cols rule context list.
	GetCols() []IColumnDefContext

	// SetCols sets the cols rule context list.
	SetCols([]IColumnDefContext)

	// Getter signatures
	AllColumnDef() []IColumnDefContext
	ColumnDef(i int) IColumnDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnDefsContext differentiates from other interfaces.
	IsColumnDefsContext()
}

type ColumnDefsContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	_columnDef IColumnDefContext
	cols       []IColumnDefContext
}

func NewEmptyColumnDefsContext() *ColumnDefsContext {
	var p = new(ColumnDefsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_columnDefs
	return p
}

func InitEmptyColumnDefsContext(p *ColumnDefsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_columnDefs
}

func (*ColumnDefsContext) IsColumnDefsContext() {}

func NewColumnDefsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefsContext {
	var p = new(ColumnDefsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_columnDefs

	return p
}

func (s *ColumnDefsContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefsContext) Get_columnDef() IColumnDefContext { return s._columnDef }

func (s *ColumnDefsContext) Set_columnDef(v IColumnDefContext) { s._columnDef = v }

func (s *ColumnDefsContext) GetCols() []IColumnDefContext { return s.cols }

func (s *ColumnDefsContext) SetCols(v []IColumnDefContext) { s.cols = v }

func (s *ColumnDefsContext) AllColumnDef() []IColumnDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnDefContext); ok {
			len++
		}
	}

	tst := make([]IColumnDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnDefContext); ok {
			tst[i] = t.(IColumnDefContext)
			i++
		}
	}

	return tst
}

func (s *ColumnDefsContext) ColumnDef(i int) IColumnDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefContext)
}

func (s *ColumnDefsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ColumnDefsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ColumnDefsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterColumnDefs(s)
	}
}

func (s *ColumnDefsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitColumnDefs(s)
	}
}

func (p *DorisParser) ColumnDefs() (localctx IColumnDefsContext) {
	localctx = NewColumnDefsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, DorisParserRULE_columnDefs)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5139)

		var _x = p.ColumnDef()

		localctx.(*ColumnDefsContext)._columnDef = _x
	}
	localctx.(*ColumnDefsContext).cols = append(localctx.(*ColumnDefsContext).cols, localctx.(*ColumnDefsContext)._columnDef)
	p.SetState(5144)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 748, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5140)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5141)

				var _x = p.ColumnDef()

				localctx.(*ColumnDefsContext)._columnDef = _x
			}
			localctx.(*ColumnDefsContext).cols = append(localctx.(*ColumnDefsContext).cols, localctx.(*ColumnDefsContext)._columnDef)

		}
		p.SetState(5146)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 748, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDefContext is an interface to support dynamic dispatch.
type IColumnDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNullable returns the nullable token.
	GetNullable() antlr.Token

	// GetNullValue returns the nullValue token.
	GetNullValue() antlr.Token

	// GetStringValue returns the stringValue token.
	GetStringValue() antlr.Token

	// GetDefaultTimestamp returns the defaultTimestamp token.
	GetDefaultTimestamp() antlr.Token

	// GetComment returns the comment token.
	GetComment() antlr.Token

	// SetNullable sets the nullable token.
	SetNullable(antlr.Token)

	// SetNullValue sets the nullValue token.
	SetNullValue(antlr.Token)

	// SetStringValue sets the stringValue token.
	SetStringValue(antlr.Token)

	// SetDefaultTimestamp sets the defaultTimestamp token.
	SetDefaultTimestamp(antlr.Token)

	// SetComment sets the comment token.
	SetComment(antlr.Token)

	// GetColName returns the colName rule contexts.
	GetColName() IIdentifierContext

	// GetType_ returns the type_ rule contexts.
	GetType_() IDataTypeContext

	// GetAggType returns the aggType rule contexts.
	GetAggType() IAggTypeDefContext

	// GetGeneratedExpr returns the generatedExpr rule contexts.
	GetGeneratedExpr() IExpressionContext

	// GetAutoIncInitValue returns the autoIncInitValue rule contexts.
	GetAutoIncInitValue() INumberContext

	// GetDefaultValuePrecision returns the defaultValuePrecision rule contexts.
	GetDefaultValuePrecision() INumberContext

	// GetOnUpdateValuePrecision returns the onUpdateValuePrecision rule contexts.
	GetOnUpdateValuePrecision() INumberContext

	// SetColName sets the colName rule contexts.
	SetColName(IIdentifierContext)

	// SetType_ sets the type_ rule contexts.
	SetType_(IDataTypeContext)

	// SetAggType sets the aggType rule contexts.
	SetAggType(IAggTypeDefContext)

	// SetGeneratedExpr sets the generatedExpr rule contexts.
	SetGeneratedExpr(IExpressionContext)

	// SetAutoIncInitValue sets the autoIncInitValue rule contexts.
	SetAutoIncInitValue(INumberContext)

	// SetDefaultValuePrecision sets the defaultValuePrecision rule contexts.
	SetDefaultValuePrecision(INumberContext)

	// SetOnUpdateValuePrecision sets the onUpdateValuePrecision rule contexts.
	SetOnUpdateValuePrecision(INumberContext)

	// Getter signatures
	Identifier() IIdentifierContext
	DataType() IDataTypeContext
	KEY() antlr.TerminalNode
	AS() antlr.TerminalNode
	AllLEFT_PAREN() []antlr.TerminalNode
	LEFT_PAREN(i int) antlr.TerminalNode
	AllRIGHT_PAREN() []antlr.TerminalNode
	RIGHT_PAREN(i int) antlr.TerminalNode
	AUTO_INCREMENT() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	ON() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	AllCURRENT_TIMESTAMP() []antlr.TerminalNode
	CURRENT_TIMESTAMP(i int) antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	AggTypeDef() IAggTypeDefContext
	Expression() IExpressionContext
	AllNULL() []antlr.TerminalNode
	NULL(i int) antlr.TerminalNode
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	DECIMAL_VALUE() antlr.TerminalNode
	PI() antlr.TerminalNode
	E() antlr.TerminalNode
	BITMAP_EMPTY() antlr.TerminalNode
	CURRENT_DATE() antlr.TerminalNode
	GENERATED() antlr.TerminalNode
	ALWAYS() antlr.TerminalNode
	NOT() antlr.TerminalNode
	AllNumber() []INumberContext
	Number(i int) INumberContext

	// IsColumnDefContext differentiates from other interfaces.
	IsColumnDefContext()
}

type ColumnDefContext struct {
	antlr.BaseParserRuleContext
	parser                 antlr.Parser
	colName                IIdentifierContext
	type_                  IDataTypeContext
	aggType                IAggTypeDefContext
	generatedExpr          IExpressionContext
	nullable               antlr.Token
	autoIncInitValue       INumberContext
	nullValue              antlr.Token
	stringValue            antlr.Token
	defaultTimestamp       antlr.Token
	defaultValuePrecision  INumberContext
	onUpdateValuePrecision INumberContext
	comment                antlr.Token
}

func NewEmptyColumnDefContext() *ColumnDefContext {
	var p = new(ColumnDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_columnDef
	return p
}

func InitEmptyColumnDefContext(p *ColumnDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_columnDef
}

func (*ColumnDefContext) IsColumnDefContext() {}

func NewColumnDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefContext {
	var p = new(ColumnDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_columnDef

	return p
}

func (s *ColumnDefContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefContext) GetNullable() antlr.Token { return s.nullable }

func (s *ColumnDefContext) GetNullValue() antlr.Token { return s.nullValue }

func (s *ColumnDefContext) GetStringValue() antlr.Token { return s.stringValue }

func (s *ColumnDefContext) GetDefaultTimestamp() antlr.Token { return s.defaultTimestamp }

func (s *ColumnDefContext) GetComment() antlr.Token { return s.comment }

func (s *ColumnDefContext) SetNullable(v antlr.Token) { s.nullable = v }

func (s *ColumnDefContext) SetNullValue(v antlr.Token) { s.nullValue = v }

func (s *ColumnDefContext) SetStringValue(v antlr.Token) { s.stringValue = v }

func (s *ColumnDefContext) SetDefaultTimestamp(v antlr.Token) { s.defaultTimestamp = v }

func (s *ColumnDefContext) SetComment(v antlr.Token) { s.comment = v }

func (s *ColumnDefContext) GetColName() IIdentifierContext { return s.colName }

func (s *ColumnDefContext) GetType_() IDataTypeContext { return s.type_ }

func (s *ColumnDefContext) GetAggType() IAggTypeDefContext { return s.aggType }

func (s *ColumnDefContext) GetGeneratedExpr() IExpressionContext { return s.generatedExpr }

func (s *ColumnDefContext) GetAutoIncInitValue() INumberContext { return s.autoIncInitValue }

func (s *ColumnDefContext) GetDefaultValuePrecision() INumberContext { return s.defaultValuePrecision }

func (s *ColumnDefContext) GetOnUpdateValuePrecision() INumberContext {
	return s.onUpdateValuePrecision
}

func (s *ColumnDefContext) SetColName(v IIdentifierContext) { s.colName = v }

func (s *ColumnDefContext) SetType_(v IDataTypeContext) { s.type_ = v }

func (s *ColumnDefContext) SetAggType(v IAggTypeDefContext) { s.aggType = v }

func (s *ColumnDefContext) SetGeneratedExpr(v IExpressionContext) { s.generatedExpr = v }

func (s *ColumnDefContext) SetAutoIncInitValue(v INumberContext) { s.autoIncInitValue = v }

func (s *ColumnDefContext) SetDefaultValuePrecision(v INumberContext) { s.defaultValuePrecision = v }

func (s *ColumnDefContext) SetOnUpdateValuePrecision(v INumberContext) { s.onUpdateValuePrecision = v }

func (s *ColumnDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnDefContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ColumnDefContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserKEY, 0)
}

func (s *ColumnDefContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *ColumnDefContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserLEFT_PAREN)
}

func (s *ColumnDefContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, i)
}

func (s *ColumnDefContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserRIGHT_PAREN)
}

func (s *ColumnDefContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, i)
}

func (s *ColumnDefContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO_INCREMENT, 0)
}

func (s *ColumnDefContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *ColumnDefContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *ColumnDefContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(DorisParserUPDATE, 0)
}

func (s *ColumnDefContext) AllCURRENT_TIMESTAMP() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCURRENT_TIMESTAMP)
}

func (s *ColumnDefContext) CURRENT_TIMESTAMP(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_TIMESTAMP, i)
}

func (s *ColumnDefContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *ColumnDefContext) AggTypeDef() IAggTypeDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggTypeDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggTypeDefContext)
}

func (s *ColumnDefContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ColumnDefContext) AllNULL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserNULL)
}

func (s *ColumnDefContext) NULL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserNULL, i)
}

func (s *ColumnDefContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *ColumnDefContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *ColumnDefContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ColumnDefContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserDECIMAL_VALUE, 0)
}

func (s *ColumnDefContext) PI() antlr.TerminalNode {
	return s.GetToken(DorisParserPI, 0)
}

func (s *ColumnDefContext) E() antlr.TerminalNode {
	return s.GetToken(DorisParserE, 0)
}

func (s *ColumnDefContext) BITMAP_EMPTY() antlr.TerminalNode {
	return s.GetToken(DorisParserBITMAP_EMPTY, 0)
}

func (s *ColumnDefContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_DATE, 0)
}

func (s *ColumnDefContext) GENERATED() antlr.TerminalNode {
	return s.GetToken(DorisParserGENERATED, 0)
}

func (s *ColumnDefContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(DorisParserALWAYS, 0)
}

func (s *ColumnDefContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *ColumnDefContext) AllNumber() []INumberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INumberContext); ok {
			len++
		}
	}

	tst := make([]INumberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INumberContext); ok {
			tst[i] = t.(INumberContext)
			i++
		}
	}

	return tst
}

func (s *ColumnDefContext) Number(i int) INumberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *ColumnDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterColumnDef(s)
	}
}

func (s *ColumnDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitColumnDef(s)
	}
}

func (p *DorisParser) ColumnDef() (localctx IColumnDefContext) {
	localctx = NewColumnDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, DorisParserRULE_columnDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5147)

		var _x = p.Identifier()

		localctx.(*ColumnDefContext).colName = _x
	}
	{
		p.SetState(5148)

		var _x = p.DataType()

		localctx.(*ColumnDefContext).type_ = _x
	}
	p.SetState(5150)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserKEY {
		{
			p.SetState(5149)
			p.Match(DorisParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5153)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserBITMAP_UNION || _la == DorisParserGENERIC || _la == DorisParserHLL_UNION || _la == DorisParserMAX || _la == DorisParserMIN || ((int64((_la-351)) & ^0x3f) == 0 && ((int64(1)<<(_la-351))&3145729) != 0) || _la == DorisParserSUM {
		{
			p.SetState(5152)

			var _x = p.AggTypeDef()

			localctx.(*ColumnDefContext).aggType = _x
		}

	}
	p.SetState(5164)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserAS || _la == DorisParserGENERATED {
		p.SetState(5157)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserGENERATED {
			{
				p.SetState(5155)
				p.Match(DorisParserGENERATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5156)
				p.Match(DorisParserALWAYS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5159)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5160)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5161)

			var _x = p.Expression()

			localctx.(*ColumnDefContext).generatedExpr = _x
		}
		{
			p.SetState(5162)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5170)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserNOT || _la == DorisParserNULL {
		p.SetState(5167)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(5166)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5169)

			var _m = p.Match(DorisParserNULL)

			localctx.(*ColumnDefContext).nullable = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5179)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserAUTO_INCREMENT {
		{
			p.SetState(5172)
			p.Match(DorisParserAUTO_INCREMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5177)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(5173)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5174)

				var _x = p.Number()

				localctx.(*ColumnDefContext).autoIncInitValue = _x
			}
			{
				p.SetState(5175)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	p.SetState(5199)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserDEFAULT {
		{
			p.SetState(5181)
			p.Match(DorisParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5197)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserNULL:
			{
				p.SetState(5182)

				var _m = p.Match(DorisParserNULL)

				localctx.(*ColumnDefContext).nullValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserINTEGER_VALUE:
			{
				p.SetState(5183)
				p.Match(DorisParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserDECIMAL_VALUE:
			{
				p.SetState(5184)
				p.Match(DorisParserDECIMAL_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserPI:
			{
				p.SetState(5185)
				p.Match(DorisParserPI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserE:
			{
				p.SetState(5186)
				p.Match(DorisParserE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserBITMAP_EMPTY:
			{
				p.SetState(5187)
				p.Match(DorisParserBITMAP_EMPTY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserSTRING_LITERAL:
			{
				p.SetState(5188)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*ColumnDefContext).stringValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCURRENT_DATE:
			{
				p.SetState(5189)
				p.Match(DorisParserCURRENT_DATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCURRENT_TIMESTAMP:
			{
				p.SetState(5190)

				var _m = p.Match(DorisParserCURRENT_TIMESTAMP)

				localctx.(*ColumnDefContext).defaultTimestamp = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5195)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserLEFT_PAREN {
				{
					p.SetState(5191)
					p.Match(DorisParserLEFT_PAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5192)

					var _x = p.Number()

					localctx.(*ColumnDefContext).defaultValuePrecision = _x
				}
				{
					p.SetState(5193)
					p.Match(DorisParserRIGHT_PAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(5210)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserON {
		{
			p.SetState(5201)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5202)
			p.Match(DorisParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5203)
			p.Match(DorisParserCURRENT_TIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5208)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(5204)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5205)

				var _x = p.Number()

				localctx.(*ColumnDefContext).onUpdateValuePrecision = _x
			}
			{
				p.SetState(5206)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	p.SetState(5214)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserCOMMENT {
		{
			p.SetState(5212)
			p.Match(DorisParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5213)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ColumnDefContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexDefsContext is an interface to support dynamic dispatch.
type IIndexDefsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_indexDef returns the _indexDef rule contexts.
	Get_indexDef() IIndexDefContext

	// Set_indexDef sets the _indexDef rule contexts.
	Set_indexDef(IIndexDefContext)

	// GetIndexes returns the indexes rule context list.
	GetIndexes() []IIndexDefContext

	// SetIndexes sets the indexes rule context list.
	SetIndexes([]IIndexDefContext)

	// Getter signatures
	AllIndexDef() []IIndexDefContext
	IndexDef(i int) IIndexDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIndexDefsContext differentiates from other interfaces.
	IsIndexDefsContext()
}

type IndexDefsContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	_indexDef IIndexDefContext
	indexes   []IIndexDefContext
}

func NewEmptyIndexDefsContext() *IndexDefsContext {
	var p = new(IndexDefsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_indexDefs
	return p
}

func InitEmptyIndexDefsContext(p *IndexDefsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_indexDefs
}

func (*IndexDefsContext) IsIndexDefsContext() {}

func NewIndexDefsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexDefsContext {
	var p = new(IndexDefsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_indexDefs

	return p
}

func (s *IndexDefsContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexDefsContext) Get_indexDef() IIndexDefContext { return s._indexDef }

func (s *IndexDefsContext) Set_indexDef(v IIndexDefContext) { s._indexDef = v }

func (s *IndexDefsContext) GetIndexes() []IIndexDefContext { return s.indexes }

func (s *IndexDefsContext) SetIndexes(v []IIndexDefContext) { s.indexes = v }

func (s *IndexDefsContext) AllIndexDef() []IIndexDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexDefContext); ok {
			len++
		}
	}

	tst := make([]IIndexDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexDefContext); ok {
			tst[i] = t.(IIndexDefContext)
			i++
		}
	}

	return tst
}

func (s *IndexDefsContext) IndexDef(i int) IIndexDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexDefContext)
}

func (s *IndexDefsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *IndexDefsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *IndexDefsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexDefsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexDefsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIndexDefs(s)
	}
}

func (s *IndexDefsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIndexDefs(s)
	}
}

func (p *DorisParser) IndexDefs() (localctx IIndexDefsContext) {
	localctx = NewIndexDefsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, DorisParserRULE_indexDefs)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5216)

		var _x = p.IndexDef()

		localctx.(*IndexDefsContext)._indexDef = _x
	}
	localctx.(*IndexDefsContext).indexes = append(localctx.(*IndexDefsContext).indexes, localctx.(*IndexDefsContext)._indexDef)
	p.SetState(5221)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 763, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5217)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5218)

				var _x = p.IndexDef()

				localctx.(*IndexDefsContext)._indexDef = _x
			}
			localctx.(*IndexDefsContext).indexes = append(localctx.(*IndexDefsContext).indexes, localctx.(*IndexDefsContext)._indexDef)

		}
		p.SetState(5223)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 763, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexDefContext is an interface to support dynamic dispatch.
type IIndexDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIfNotExists returns the ifNotExists token.
	GetIfNotExists() antlr.Token

	// GetIndexType returns the indexType token.
	GetIndexType() antlr.Token

	// GetComment returns the comment token.
	GetComment() antlr.Token

	// SetIfNotExists sets the ifNotExists token.
	SetIfNotExists(antlr.Token)

	// SetIndexType sets the indexType token.
	SetIndexType(antlr.Token)

	// SetComment sets the comment token.
	SetComment(antlr.Token)

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// GetCols returns the cols rule contexts.
	GetCols() IIdentifierListContext

	// GetProperties returns the properties rule contexts.
	GetProperties() IPropertyItemListContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// SetCols sets the cols rule contexts.
	SetCols(IIdentifierListContext)

	// SetProperties sets the properties rule contexts.
	SetProperties(IPropertyItemListContext)

	// Getter signatures
	INDEX() antlr.TerminalNode
	Identifier() IIdentifierContext
	IdentifierList() IIdentifierListContext
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	USING() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	IF() antlr.TerminalNode
	PropertyItemList() IPropertyItemListContext
	STRING_LITERAL() antlr.TerminalNode
	BITMAP() antlr.TerminalNode
	INVERTED() antlr.TerminalNode
	NGRAM_BF() antlr.TerminalNode

	// IsIndexDefContext differentiates from other interfaces.
	IsIndexDefContext()
}

type IndexDefContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	ifNotExists antlr.Token
	indexName   IIdentifierContext
	cols        IIdentifierListContext
	indexType   antlr.Token
	properties  IPropertyItemListContext
	comment     antlr.Token
}

func NewEmptyIndexDefContext() *IndexDefContext {
	var p = new(IndexDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_indexDef
	return p
}

func InitEmptyIndexDefContext(p *IndexDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_indexDef
}

func (*IndexDefContext) IsIndexDefContext() {}

func NewIndexDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexDefContext {
	var p = new(IndexDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_indexDef

	return p
}

func (s *IndexDefContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexDefContext) GetIfNotExists() antlr.Token { return s.ifNotExists }

func (s *IndexDefContext) GetIndexType() antlr.Token { return s.indexType }

func (s *IndexDefContext) GetComment() antlr.Token { return s.comment }

func (s *IndexDefContext) SetIfNotExists(v antlr.Token) { s.ifNotExists = v }

func (s *IndexDefContext) SetIndexType(v antlr.Token) { s.indexType = v }

func (s *IndexDefContext) SetComment(v antlr.Token) { s.comment = v }

func (s *IndexDefContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *IndexDefContext) GetCols() IIdentifierListContext { return s.cols }

func (s *IndexDefContext) GetProperties() IPropertyItemListContext { return s.properties }

func (s *IndexDefContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *IndexDefContext) SetCols(v IIdentifierListContext) { s.cols = v }

func (s *IndexDefContext) SetProperties(v IPropertyItemListContext) { s.properties = v }

func (s *IndexDefContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *IndexDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IndexDefContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *IndexDefContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *IndexDefContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *IndexDefContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserUSING, 0)
}

func (s *IndexDefContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *IndexDefContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *IndexDefContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *IndexDefContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *IndexDefContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *IndexDefContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *IndexDefContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *IndexDefContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(DorisParserBITMAP, 0)
}

func (s *IndexDefContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserINVERTED, 0)
}

func (s *IndexDefContext) NGRAM_BF() antlr.TerminalNode {
	return s.GetToken(DorisParserNGRAM_BF, 0)
}

func (s *IndexDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIndexDef(s)
	}
}

func (s *IndexDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIndexDef(s)
	}
}

func (p *DorisParser) IndexDef() (localctx IIndexDefContext) {
	localctx = NewIndexDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, DorisParserRULE_indexDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5224)
		p.Match(DorisParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5228)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserIF {
		{
			p.SetState(5225)

			var _m = p.Match(DorisParserIF)

			localctx.(*IndexDefContext).ifNotExists = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5226)
			p.Match(DorisParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5227)
			p.Match(DorisParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5230)

		var _x = p.Identifier()

		localctx.(*IndexDefContext).indexName = _x
	}
	{
		p.SetState(5231)

		var _x = p.IdentifierList()

		localctx.(*IndexDefContext).cols = _x
	}
	p.SetState(5234)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserUSING {
		{
			p.SetState(5232)
			p.Match(DorisParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5233)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IndexDefContext).indexType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserBITMAP || _la == DorisParserINVERTED || _la == DorisParserNGRAM_BF) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IndexDefContext).indexType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(5241)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPROPERTIES {
		{
			p.SetState(5236)
			p.Match(DorisParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5237)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5238)

			var _x = p.PropertyItemList()

			localctx.(*IndexDefContext).properties = _x
		}
		{
			p.SetState(5239)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5245)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserCOMMENT {
		{
			p.SetState(5243)
			p.Match(DorisParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5244)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*IndexDefContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionsDefContext is an interface to support dynamic dispatch.
type IPartitionsDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_partitionDef returns the _partitionDef rule contexts.
	Get_partitionDef() IPartitionDefContext

	// Set_partitionDef sets the _partitionDef rule contexts.
	Set_partitionDef(IPartitionDefContext)

	// GetPartitions returns the partitions rule context list.
	GetPartitions() []IPartitionDefContext

	// SetPartitions sets the partitions rule context list.
	SetPartitions([]IPartitionDefContext)

	// Getter signatures
	AllPartitionDef() []IPartitionDefContext
	PartitionDef(i int) IPartitionDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionsDefContext differentiates from other interfaces.
	IsPartitionsDefContext()
}

type PartitionsDefContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	_partitionDef IPartitionDefContext
	partitions    []IPartitionDefContext
}

func NewEmptyPartitionsDefContext() *PartitionsDefContext {
	var p = new(PartitionsDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionsDef
	return p
}

func InitEmptyPartitionsDefContext(p *PartitionsDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionsDef
}

func (*PartitionsDefContext) IsPartitionsDefContext() {}

func NewPartitionsDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionsDefContext {
	var p = new(PartitionsDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_partitionsDef

	return p
}

func (s *PartitionsDefContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionsDefContext) Get_partitionDef() IPartitionDefContext { return s._partitionDef }

func (s *PartitionsDefContext) Set_partitionDef(v IPartitionDefContext) { s._partitionDef = v }

func (s *PartitionsDefContext) GetPartitions() []IPartitionDefContext { return s.partitions }

func (s *PartitionsDefContext) SetPartitions(v []IPartitionDefContext) { s.partitions = v }

func (s *PartitionsDefContext) AllPartitionDef() []IPartitionDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefContext); ok {
			tst[i] = t.(IPartitionDefContext)
			i++
		}
	}

	return tst
}

func (s *PartitionsDefContext) PartitionDef(i int) IPartitionDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefContext)
}

func (s *PartitionsDefContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *PartitionsDefContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *PartitionsDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionsDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionsDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPartitionsDef(s)
	}
}

func (s *PartitionsDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPartitionsDef(s)
	}
}

func (p *DorisParser) PartitionsDef() (localctx IPartitionsDefContext) {
	localctx = NewPartitionsDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, DorisParserRULE_partitionsDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5247)

		var _x = p.PartitionDef()

		localctx.(*PartitionsDefContext)._partitionDef = _x
	}
	localctx.(*PartitionsDefContext).partitions = append(localctx.(*PartitionsDefContext).partitions, localctx.(*PartitionsDefContext)._partitionDef)
	p.SetState(5252)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(5248)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5249)

			var _x = p.PartitionDef()

			localctx.(*PartitionsDefContext)._partitionDef = _x
		}
		localctx.(*PartitionsDefContext).partitions = append(localctx.(*PartitionsDefContext).partitions, localctx.(*PartitionsDefContext)._partitionDef)

		p.SetState(5254)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDefContext is an interface to support dynamic dispatch.
type IPartitionDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionProperties returns the partitionProperties rule contexts.
	GetPartitionProperties() IPropertyItemListContext

	// SetPartitionProperties sets the partitionProperties rule contexts.
	SetPartitionProperties(IPropertyItemListContext)

	// Getter signatures
	LessThanPartitionDef() ILessThanPartitionDefContext
	FixedPartitionDef() IFixedPartitionDefContext
	StepPartitionDef() IStepPartitionDefContext
	InPartitionDef() IInPartitionDefContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	PropertyItemList() IPropertyItemListContext

	// IsPartitionDefContext differentiates from other interfaces.
	IsPartitionDefContext()
}

type PartitionDefContext struct {
	antlr.BaseParserRuleContext
	parser              antlr.Parser
	partitionProperties IPropertyItemListContext
}

func NewEmptyPartitionDefContext() *PartitionDefContext {
	var p = new(PartitionDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionDef
	return p
}

func InitEmptyPartitionDefContext(p *PartitionDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionDef
}

func (*PartitionDefContext) IsPartitionDefContext() {}

func NewPartitionDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefContext {
	var p = new(PartitionDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_partitionDef

	return p
}

func (s *PartitionDefContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefContext) GetPartitionProperties() IPropertyItemListContext {
	return s.partitionProperties
}

func (s *PartitionDefContext) SetPartitionProperties(v IPropertyItemListContext) {
	s.partitionProperties = v
}

func (s *PartitionDefContext) LessThanPartitionDef() ILessThanPartitionDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILessThanPartitionDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILessThanPartitionDefContext)
}

func (s *PartitionDefContext) FixedPartitionDef() IFixedPartitionDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFixedPartitionDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFixedPartitionDefContext)
}

func (s *PartitionDefContext) StepPartitionDef() IStepPartitionDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStepPartitionDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStepPartitionDefContext)
}

func (s *PartitionDefContext) InPartitionDef() IInPartitionDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInPartitionDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInPartitionDefContext)
}

func (s *PartitionDefContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *PartitionDefContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *PartitionDefContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *PartitionDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPartitionDef(s)
	}
}

func (s *PartitionDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPartitionDef(s)
	}
}

func (p *DorisParser) PartitionDef() (localctx IPartitionDefContext) {
	localctx = NewPartitionDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, DorisParserRULE_partitionDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5259)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 769, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5255)
			p.LessThanPartitionDef()
		}

	case 2:
		{
			p.SetState(5256)
			p.FixedPartitionDef()
		}

	case 3:
		{
			p.SetState(5257)
			p.StepPartitionDef()
		}

	case 4:
		{
			p.SetState(5258)
			p.InPartitionDef()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(5265)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLEFT_PAREN {
		{
			p.SetState(5261)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5262)

			var _x = p.PropertyItemList()

			localctx.(*PartitionDefContext).partitionProperties = _x
		}
		{
			p.SetState(5263)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILessThanPartitionDefContext is an interface to support dynamic dispatch.
type ILessThanPartitionDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionName returns the partitionName rule contexts.
	GetPartitionName() IIdentifierContext

	// SetPartitionName sets the partitionName rule contexts.
	SetPartitionName(IIdentifierContext)

	// Getter signatures
	PARTITION() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	LESS() antlr.TerminalNode
	THAN() antlr.TerminalNode
	Identifier() IIdentifierContext
	MAXVALUE() antlr.TerminalNode
	PartitionValueList() IPartitionValueListContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsLessThanPartitionDefContext differentiates from other interfaces.
	IsLessThanPartitionDefContext()
}

type LessThanPartitionDefContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	partitionName IIdentifierContext
}

func NewEmptyLessThanPartitionDefContext() *LessThanPartitionDefContext {
	var p = new(LessThanPartitionDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_lessThanPartitionDef
	return p
}

func InitEmptyLessThanPartitionDefContext(p *LessThanPartitionDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_lessThanPartitionDef
}

func (*LessThanPartitionDefContext) IsLessThanPartitionDefContext() {}

func NewLessThanPartitionDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LessThanPartitionDefContext {
	var p = new(LessThanPartitionDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_lessThanPartitionDef

	return p
}

func (s *LessThanPartitionDefContext) GetParser() antlr.Parser { return s.parser }

func (s *LessThanPartitionDefContext) GetPartitionName() IIdentifierContext { return s.partitionName }

func (s *LessThanPartitionDefContext) SetPartitionName(v IIdentifierContext) { s.partitionName = v }

func (s *LessThanPartitionDefContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *LessThanPartitionDefContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisParserVALUES, 0)
}

func (s *LessThanPartitionDefContext) LESS() antlr.TerminalNode {
	return s.GetToken(DorisParserLESS, 0)
}

func (s *LessThanPartitionDefContext) THAN() antlr.TerminalNode {
	return s.GetToken(DorisParserTHAN, 0)
}

func (s *LessThanPartitionDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LessThanPartitionDefContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserMAXVALUE, 0)
}

func (s *LessThanPartitionDefContext) PartitionValueList() IPartitionValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueListContext)
}

func (s *LessThanPartitionDefContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *LessThanPartitionDefContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *LessThanPartitionDefContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *LessThanPartitionDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LessThanPartitionDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LessThanPartitionDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLessThanPartitionDef(s)
	}
}

func (s *LessThanPartitionDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLessThanPartitionDef(s)
	}
}

func (p *DorisParser) LessThanPartitionDef() (localctx ILessThanPartitionDefContext) {
	localctx = NewLessThanPartitionDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, DorisParserRULE_lessThanPartitionDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5267)
		p.Match(DorisParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5271)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserIF {
		{
			p.SetState(5268)
			p.Match(DorisParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5269)
			p.Match(DorisParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5270)
			p.Match(DorisParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5273)

		var _x = p.Identifier()

		localctx.(*LessThanPartitionDefContext).partitionName = _x
	}
	{
		p.SetState(5274)
		p.Match(DorisParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5275)
		p.Match(DorisParserLESS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5276)
		p.Match(DorisParserTHAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5279)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserMAXVALUE:
		{
			p.SetState(5277)
			p.Match(DorisParserMAXVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserLEFT_PAREN:
		{
			p.SetState(5278)
			p.PartitionValueList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFixedPartitionDefContext is an interface to support dynamic dispatch.
type IFixedPartitionDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionName returns the partitionName rule contexts.
	GetPartitionName() IIdentifierContext

	// GetLower returns the lower rule contexts.
	GetLower() IPartitionValueListContext

	// GetUpper returns the upper rule contexts.
	GetUpper() IPartitionValueListContext

	// SetPartitionName sets the partitionName rule contexts.
	SetPartitionName(IIdentifierContext)

	// SetLower sets the lower rule contexts.
	SetLower(IPartitionValueListContext)

	// SetUpper sets the upper rule contexts.
	SetUpper(IPartitionValueListContext)

	// Getter signatures
	PARTITION() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	LEFT_BRACKET() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	AllPartitionValueList() []IPartitionValueListContext
	PartitionValueList(i int) IPartitionValueListContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsFixedPartitionDefContext differentiates from other interfaces.
	IsFixedPartitionDefContext()
}

type FixedPartitionDefContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	partitionName IIdentifierContext
	lower         IPartitionValueListContext
	upper         IPartitionValueListContext
}

func NewEmptyFixedPartitionDefContext() *FixedPartitionDefContext {
	var p = new(FixedPartitionDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_fixedPartitionDef
	return p
}

func InitEmptyFixedPartitionDefContext(p *FixedPartitionDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_fixedPartitionDef
}

func (*FixedPartitionDefContext) IsFixedPartitionDefContext() {}

func NewFixedPartitionDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FixedPartitionDefContext {
	var p = new(FixedPartitionDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_fixedPartitionDef

	return p
}

func (s *FixedPartitionDefContext) GetParser() antlr.Parser { return s.parser }

func (s *FixedPartitionDefContext) GetPartitionName() IIdentifierContext { return s.partitionName }

func (s *FixedPartitionDefContext) GetLower() IPartitionValueListContext { return s.lower }

func (s *FixedPartitionDefContext) GetUpper() IPartitionValueListContext { return s.upper }

func (s *FixedPartitionDefContext) SetPartitionName(v IIdentifierContext) { s.partitionName = v }

func (s *FixedPartitionDefContext) SetLower(v IPartitionValueListContext) { s.lower = v }

func (s *FixedPartitionDefContext) SetUpper(v IPartitionValueListContext) { s.upper = v }

func (s *FixedPartitionDefContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *FixedPartitionDefContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisParserVALUES, 0)
}

func (s *FixedPartitionDefContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACKET, 0)
}

func (s *FixedPartitionDefContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, 0)
}

func (s *FixedPartitionDefContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *FixedPartitionDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FixedPartitionDefContext) AllPartitionValueList() []IPartitionValueListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueListContext); ok {
			tst[i] = t.(IPartitionValueListContext)
			i++
		}
	}

	return tst
}

func (s *FixedPartitionDefContext) PartitionValueList(i int) IPartitionValueListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueListContext)
}

func (s *FixedPartitionDefContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *FixedPartitionDefContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *FixedPartitionDefContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *FixedPartitionDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FixedPartitionDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FixedPartitionDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFixedPartitionDef(s)
	}
}

func (s *FixedPartitionDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFixedPartitionDef(s)
	}
}

func (p *DorisParser) FixedPartitionDef() (localctx IFixedPartitionDefContext) {
	localctx = NewFixedPartitionDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, DorisParserRULE_fixedPartitionDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5281)
		p.Match(DorisParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5285)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserIF {
		{
			p.SetState(5282)
			p.Match(DorisParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5283)
			p.Match(DorisParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5284)
			p.Match(DorisParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5287)

		var _x = p.Identifier()

		localctx.(*FixedPartitionDefContext).partitionName = _x
	}
	{
		p.SetState(5288)
		p.Match(DorisParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5289)
		p.Match(DorisParserLEFT_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5290)

		var _x = p.PartitionValueList()

		localctx.(*FixedPartitionDefContext).lower = _x
	}
	{
		p.SetState(5291)
		p.Match(DorisParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5292)

		var _x = p.PartitionValueList()

		localctx.(*FixedPartitionDefContext).upper = _x
	}
	{
		p.SetState(5293)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStepPartitionDefContext is an interface to support dynamic dispatch.
type IStepPartitionDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnitsAmount returns the unitsAmount token.
	GetUnitsAmount() antlr.Token

	// SetUnitsAmount sets the unitsAmount token.
	SetUnitsAmount(antlr.Token)

	// GetFrom returns the from rule contexts.
	GetFrom() IPartitionValueListContext

	// GetTo returns the to rule contexts.
	GetTo() IPartitionValueListContext

	// GetUnit returns the unit rule contexts.
	GetUnit() IUnitIdentifierContext

	// SetFrom sets the from rule contexts.
	SetFrom(IPartitionValueListContext)

	// SetTo sets the to rule contexts.
	SetTo(IPartitionValueListContext)

	// SetUnit sets the unit rule contexts.
	SetUnit(IUnitIdentifierContext)

	// Getter signatures
	FROM() antlr.TerminalNode
	TO() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	AllPartitionValueList() []IPartitionValueListContext
	PartitionValueList(i int) IPartitionValueListContext
	INTEGER_VALUE() antlr.TerminalNode
	UnitIdentifier() IUnitIdentifierContext

	// IsStepPartitionDefContext differentiates from other interfaces.
	IsStepPartitionDefContext()
}

type StepPartitionDefContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	from        IPartitionValueListContext
	to          IPartitionValueListContext
	unitsAmount antlr.Token
	unit        IUnitIdentifierContext
}

func NewEmptyStepPartitionDefContext() *StepPartitionDefContext {
	var p = new(StepPartitionDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_stepPartitionDef
	return p
}

func InitEmptyStepPartitionDefContext(p *StepPartitionDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_stepPartitionDef
}

func (*StepPartitionDefContext) IsStepPartitionDefContext() {}

func NewStepPartitionDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StepPartitionDefContext {
	var p = new(StepPartitionDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_stepPartitionDef

	return p
}

func (s *StepPartitionDefContext) GetParser() antlr.Parser { return s.parser }

func (s *StepPartitionDefContext) GetUnitsAmount() antlr.Token { return s.unitsAmount }

func (s *StepPartitionDefContext) SetUnitsAmount(v antlr.Token) { s.unitsAmount = v }

func (s *StepPartitionDefContext) GetFrom() IPartitionValueListContext { return s.from }

func (s *StepPartitionDefContext) GetTo() IPartitionValueListContext { return s.to }

func (s *StepPartitionDefContext) GetUnit() IUnitIdentifierContext { return s.unit }

func (s *StepPartitionDefContext) SetFrom(v IPartitionValueListContext) { s.from = v }

func (s *StepPartitionDefContext) SetTo(v IPartitionValueListContext) { s.to = v }

func (s *StepPartitionDefContext) SetUnit(v IUnitIdentifierContext) { s.unit = v }

func (s *StepPartitionDefContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *StepPartitionDefContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *StepPartitionDefContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DorisParserINTERVAL, 0)
}

func (s *StepPartitionDefContext) AllPartitionValueList() []IPartitionValueListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueListContext); ok {
			tst[i] = t.(IPartitionValueListContext)
			i++
		}
	}

	return tst
}

func (s *StepPartitionDefContext) PartitionValueList(i int) IPartitionValueListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueListContext)
}

func (s *StepPartitionDefContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *StepPartitionDefContext) UnitIdentifier() IUnitIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitIdentifierContext)
}

func (s *StepPartitionDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StepPartitionDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StepPartitionDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStepPartitionDef(s)
	}
}

func (s *StepPartitionDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStepPartitionDef(s)
	}
}

func (p *DorisParser) StepPartitionDef() (localctx IStepPartitionDefContext) {
	localctx = NewStepPartitionDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, DorisParserRULE_stepPartitionDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5295)
		p.Match(DorisParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5296)

		var _x = p.PartitionValueList()

		localctx.(*StepPartitionDefContext).from = _x
	}
	{
		p.SetState(5297)
		p.Match(DorisParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5298)

		var _x = p.PartitionValueList()

		localctx.(*StepPartitionDefContext).to = _x
	}
	{
		p.SetState(5299)
		p.Match(DorisParserINTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5300)

		var _m = p.Match(DorisParserINTEGER_VALUE)

		localctx.(*StepPartitionDefContext).unitsAmount = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5302)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserDAY || _la == DorisParserHOUR || _la == DorisParserMINUTE || _la == DorisParserMONTH || _la == DorisParserQUARTER || _la == DorisParserSECOND || _la == DorisParserWEEK || _la == DorisParserYEAR {
		{
			p.SetState(5301)

			var _x = p.UnitIdentifier()

			localctx.(*StepPartitionDefContext).unit = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInPartitionDefContext is an interface to support dynamic dispatch.
type IInPartitionDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionName returns the partitionName rule contexts.
	GetPartitionName() IIdentifierContext

	// Get_partitionValueList returns the _partitionValueList rule contexts.
	Get_partitionValueList() IPartitionValueListContext

	// GetConstants returns the constants rule contexts.
	GetConstants() IPartitionValueListContext

	// SetPartitionName sets the partitionName rule contexts.
	SetPartitionName(IIdentifierContext)

	// Set_partitionValueList sets the _partitionValueList rule contexts.
	Set_partitionValueList(IPartitionValueListContext)

	// SetConstants sets the constants rule contexts.
	SetConstants(IPartitionValueListContext)

	// GetPartitionValueLists returns the partitionValueLists rule context list.
	GetPartitionValueLists() []IPartitionValueListContext

	// SetPartitionValueLists sets the partitionValueLists rule context list.
	SetPartitionValueLists([]IPartitionValueListContext)

	// Getter signatures
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	IN() antlr.TerminalNode
	AllPartitionValueList() []IPartitionValueListContext
	PartitionValueList(i int) IPartitionValueListContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsInPartitionDefContext differentiates from other interfaces.
	IsInPartitionDefContext()
}

type InPartitionDefContext struct {
	antlr.BaseParserRuleContext
	parser              antlr.Parser
	partitionName       IIdentifierContext
	_partitionValueList IPartitionValueListContext
	partitionValueLists []IPartitionValueListContext
	constants           IPartitionValueListContext
}

func NewEmptyInPartitionDefContext() *InPartitionDefContext {
	var p = new(InPartitionDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_inPartitionDef
	return p
}

func InitEmptyInPartitionDefContext(p *InPartitionDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_inPartitionDef
}

func (*InPartitionDefContext) IsInPartitionDefContext() {}

func NewInPartitionDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InPartitionDefContext {
	var p = new(InPartitionDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_inPartitionDef

	return p
}

func (s *InPartitionDefContext) GetParser() antlr.Parser { return s.parser }

func (s *InPartitionDefContext) GetPartitionName() IIdentifierContext { return s.partitionName }

func (s *InPartitionDefContext) Get_partitionValueList() IPartitionValueListContext {
	return s._partitionValueList
}

func (s *InPartitionDefContext) GetConstants() IPartitionValueListContext { return s.constants }

func (s *InPartitionDefContext) SetPartitionName(v IIdentifierContext) { s.partitionName = v }

func (s *InPartitionDefContext) Set_partitionValueList(v IPartitionValueListContext) {
	s._partitionValueList = v
}

func (s *InPartitionDefContext) SetConstants(v IPartitionValueListContext) { s.constants = v }

func (s *InPartitionDefContext) GetPartitionValueLists() []IPartitionValueListContext {
	return s.partitionValueLists
}

func (s *InPartitionDefContext) SetPartitionValueLists(v []IPartitionValueListContext) {
	s.partitionValueLists = v
}

func (s *InPartitionDefContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *InPartitionDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InPartitionDefContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *InPartitionDefContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *InPartitionDefContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *InPartitionDefContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisParserVALUES, 0)
}

func (s *InPartitionDefContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *InPartitionDefContext) AllPartitionValueList() []IPartitionValueListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueListContext); ok {
			tst[i] = t.(IPartitionValueListContext)
			i++
		}
	}

	return tst
}

func (s *InPartitionDefContext) PartitionValueList(i int) IPartitionValueListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueListContext)
}

func (s *InPartitionDefContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *InPartitionDefContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *InPartitionDefContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *InPartitionDefContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *InPartitionDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InPartitionDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InPartitionDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterInPartitionDef(s)
	}
}

func (s *InPartitionDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitInPartitionDef(s)
	}
}

func (p *DorisParser) InPartitionDef() (localctx IInPartitionDefContext) {
	localctx = NewInPartitionDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, DorisParserRULE_inPartitionDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5304)
		p.Match(DorisParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5308)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserIF {
		{
			p.SetState(5305)
			p.Match(DorisParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5306)
			p.Match(DorisParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5307)
			p.Match(DorisParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5310)

		var _x = p.Identifier()

		localctx.(*InPartitionDefContext).partitionName = _x
	}
	p.SetState(5327)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserVALUES {
		{
			p.SetState(5311)
			p.Match(DorisParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5312)
			p.Match(DorisParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5325)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 777, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5313)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5314)

				var _x = p.PartitionValueList()

				localctx.(*InPartitionDefContext)._partitionValueList = _x
			}
			localctx.(*InPartitionDefContext).partitionValueLists = append(localctx.(*InPartitionDefContext).partitionValueLists, localctx.(*InPartitionDefContext)._partitionValueList)
			p.SetState(5319)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(5315)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5316)

					var _x = p.PartitionValueList()

					localctx.(*InPartitionDefContext)._partitionValueList = _x
				}
				localctx.(*InPartitionDefContext).partitionValueLists = append(localctx.(*InPartitionDefContext).partitionValueLists, localctx.(*InPartitionDefContext)._partitionValueList)

				p.SetState(5321)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(5322)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(5324)

				var _x = p.PartitionValueList()

				localctx.(*InPartitionDefContext).constants = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionValueListContext is an interface to support dynamic dispatch.
type IPartitionValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_partitionValueDef returns the _partitionValueDef rule contexts.
	Get_partitionValueDef() IPartitionValueDefContext

	// Set_partitionValueDef sets the _partitionValueDef rule contexts.
	Set_partitionValueDef(IPartitionValueDefContext)

	// GetValues returns the values rule context list.
	GetValues() []IPartitionValueDefContext

	// SetValues sets the values rule context list.
	SetValues([]IPartitionValueDefContext)

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllPartitionValueDef() []IPartitionValueDefContext
	PartitionValueDef(i int) IPartitionValueDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionValueListContext differentiates from other interfaces.
	IsPartitionValueListContext()
}

type PartitionValueListContext struct {
	antlr.BaseParserRuleContext
	parser             antlr.Parser
	_partitionValueDef IPartitionValueDefContext
	values             []IPartitionValueDefContext
}

func NewEmptyPartitionValueListContext() *PartitionValueListContext {
	var p = new(PartitionValueListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionValueList
	return p
}

func InitEmptyPartitionValueListContext(p *PartitionValueListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionValueList
}

func (*PartitionValueListContext) IsPartitionValueListContext() {}

func NewPartitionValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValueListContext {
	var p = new(PartitionValueListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_partitionValueList

	return p
}

func (s *PartitionValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValueListContext) Get_partitionValueDef() IPartitionValueDefContext {
	return s._partitionValueDef
}

func (s *PartitionValueListContext) Set_partitionValueDef(v IPartitionValueDefContext) {
	s._partitionValueDef = v
}

func (s *PartitionValueListContext) GetValues() []IPartitionValueDefContext { return s.values }

func (s *PartitionValueListContext) SetValues(v []IPartitionValueDefContext) { s.values = v }

func (s *PartitionValueListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *PartitionValueListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *PartitionValueListContext) AllPartitionValueDef() []IPartitionValueDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueDefContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueDefContext); ok {
			tst[i] = t.(IPartitionValueDefContext)
			i++
		}
	}

	return tst
}

func (s *PartitionValueListContext) PartitionValueDef(i int) IPartitionValueDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueDefContext)
}

func (s *PartitionValueListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *PartitionValueListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *PartitionValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionValueListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPartitionValueList(s)
	}
}

func (s *PartitionValueListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPartitionValueList(s)
	}
}

func (p *DorisParser) PartitionValueList() (localctx IPartitionValueListContext) {
	localctx = NewPartitionValueListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, DorisParserRULE_partitionValueList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5329)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5330)

		var _x = p.PartitionValueDef()

		localctx.(*PartitionValueListContext)._partitionValueDef = _x
	}
	localctx.(*PartitionValueListContext).values = append(localctx.(*PartitionValueListContext).values, localctx.(*PartitionValueListContext)._partitionValueDef)
	p.SetState(5335)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(5331)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5332)

			var _x = p.PartitionValueDef()

			localctx.(*PartitionValueListContext)._partitionValueDef = _x
		}
		localctx.(*PartitionValueListContext).values = append(localctx.(*PartitionValueListContext).values, localctx.(*PartitionValueListContext)._partitionValueDef)

		p.SetState(5337)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5338)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionValueDefContext is an interface to support dynamic dispatch.
type IPartitionValueDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER_VALUE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	MAXVALUE() antlr.TerminalNode
	NULL() antlr.TerminalNode

	// IsPartitionValueDefContext differentiates from other interfaces.
	IsPartitionValueDefContext()
}

type PartitionValueDefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionValueDefContext() *PartitionValueDefContext {
	var p = new(PartitionValueDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionValueDef
	return p
}

func InitEmptyPartitionValueDefContext(p *PartitionValueDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionValueDef
}

func (*PartitionValueDefContext) IsPartitionValueDefContext() {}

func NewPartitionValueDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValueDefContext {
	var p = new(PartitionValueDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_partitionValueDef

	return p
}

func (s *PartitionValueDefContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValueDefContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *PartitionValueDefContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *PartitionValueDefContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserMAXVALUE, 0)
}

func (s *PartitionValueDefContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisParserNULL, 0)
}

func (s *PartitionValueDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValueDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionValueDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPartitionValueDef(s)
	}
}

func (s *PartitionValueDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPartitionValueDef(s)
	}
}

func (p *DorisParser) PartitionValueDef() (localctx IPartitionValueDefContext) {
	localctx = NewPartitionValueDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, DorisParserRULE_partitionValueDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5340)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserMAXVALUE || _la == DorisParserNULL || _la == DorisParserSTRING_LITERAL || _la == DorisParserINTEGER_VALUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollupDefsContext is an interface to support dynamic dispatch.
type IRollupDefsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_rollupDef returns the _rollupDef rule contexts.
	Get_rollupDef() IRollupDefContext

	// Set_rollupDef sets the _rollupDef rule contexts.
	Set_rollupDef(IRollupDefContext)

	// GetRollups returns the rollups rule context list.
	GetRollups() []IRollupDefContext

	// SetRollups sets the rollups rule context list.
	SetRollups([]IRollupDefContext)

	// Getter signatures
	AllRollupDef() []IRollupDefContext
	RollupDef(i int) IRollupDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRollupDefsContext differentiates from other interfaces.
	IsRollupDefsContext()
}

type RollupDefsContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	_rollupDef IRollupDefContext
	rollups    []IRollupDefContext
}

func NewEmptyRollupDefsContext() *RollupDefsContext {
	var p = new(RollupDefsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_rollupDefs
	return p
}

func InitEmptyRollupDefsContext(p *RollupDefsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_rollupDefs
}

func (*RollupDefsContext) IsRollupDefsContext() {}

func NewRollupDefsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollupDefsContext {
	var p = new(RollupDefsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_rollupDefs

	return p
}

func (s *RollupDefsContext) GetParser() antlr.Parser { return s.parser }

func (s *RollupDefsContext) Get_rollupDef() IRollupDefContext { return s._rollupDef }

func (s *RollupDefsContext) Set_rollupDef(v IRollupDefContext) { s._rollupDef = v }

func (s *RollupDefsContext) GetRollups() []IRollupDefContext { return s.rollups }

func (s *RollupDefsContext) SetRollups(v []IRollupDefContext) { s.rollups = v }

func (s *RollupDefsContext) AllRollupDef() []IRollupDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRollupDefContext); ok {
			len++
		}
	}

	tst := make([]IRollupDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRollupDefContext); ok {
			tst[i] = t.(IRollupDefContext)
			i++
		}
	}

	return tst
}

func (s *RollupDefsContext) RollupDef(i int) IRollupDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupDefContext)
}

func (s *RollupDefsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *RollupDefsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *RollupDefsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupDefsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollupDefsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRollupDefs(s)
	}
}

func (s *RollupDefsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRollupDefs(s)
	}
}

func (p *DorisParser) RollupDefs() (localctx IRollupDefsContext) {
	localctx = NewRollupDefsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, DorisParserRULE_rollupDefs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5342)

		var _x = p.RollupDef()

		localctx.(*RollupDefsContext)._rollupDef = _x
	}
	localctx.(*RollupDefsContext).rollups = append(localctx.(*RollupDefsContext).rollups, localctx.(*RollupDefsContext)._rollupDef)
	p.SetState(5347)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(5343)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5344)

			var _x = p.RollupDef()

			localctx.(*RollupDefsContext)._rollupDef = _x
		}
		localctx.(*RollupDefsContext).rollups = append(localctx.(*RollupDefsContext).rollups, localctx.(*RollupDefsContext)._rollupDef)

		p.SetState(5349)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollupDefContext is an interface to support dynamic dispatch.
type IRollupDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// GetRollupCols returns the rollupCols rule contexts.
	GetRollupCols() IIdentifierListContext

	// GetDupKeys returns the dupKeys rule contexts.
	GetDupKeys() IIdentifierListContext

	// GetProperties returns the properties rule contexts.
	GetProperties() IPropertyClauseContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// SetRollupCols sets the rollupCols rule contexts.
	SetRollupCols(IIdentifierListContext)

	// SetDupKeys sets the dupKeys rule contexts.
	SetDupKeys(IIdentifierListContext)

	// SetProperties sets the properties rule contexts.
	SetProperties(IPropertyClauseContext)

	// Getter signatures
	Identifier() IIdentifierContext
	AllIdentifierList() []IIdentifierListContext
	IdentifierList(i int) IIdentifierListContext
	DUPLICATE() antlr.TerminalNode
	KEY() antlr.TerminalNode
	PropertyClause() IPropertyClauseContext

	// IsRollupDefContext differentiates from other interfaces.
	IsRollupDefContext()
}

type RollupDefContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
	rollupCols IIdentifierListContext
	dupKeys    IIdentifierListContext
	properties IPropertyClauseContext
}

func NewEmptyRollupDefContext() *RollupDefContext {
	var p = new(RollupDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_rollupDef
	return p
}

func InitEmptyRollupDefContext(p *RollupDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_rollupDef
}

func (*RollupDefContext) IsRollupDefContext() {}

func NewRollupDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollupDefContext {
	var p = new(RollupDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_rollupDef

	return p
}

func (s *RollupDefContext) GetParser() antlr.Parser { return s.parser }

func (s *RollupDefContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *RollupDefContext) GetRollupCols() IIdentifierListContext { return s.rollupCols }

func (s *RollupDefContext) GetDupKeys() IIdentifierListContext { return s.dupKeys }

func (s *RollupDefContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *RollupDefContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *RollupDefContext) SetRollupCols(v IIdentifierListContext) { s.rollupCols = v }

func (s *RollupDefContext) SetDupKeys(v IIdentifierListContext) { s.dupKeys = v }

func (s *RollupDefContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *RollupDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RollupDefContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *RollupDefContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *RollupDefContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(DorisParserDUPLICATE, 0)
}

func (s *RollupDefContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserKEY, 0)
}

func (s *RollupDefContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *RollupDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollupDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRollupDef(s)
	}
}

func (s *RollupDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRollupDef(s)
	}
}

func (p *DorisParser) RollupDef() (localctx IRollupDefContext) {
	localctx = NewRollupDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, DorisParserRULE_rollupDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5350)

		var _x = p.Identifier()

		localctx.(*RollupDefContext).rollupName = _x
	}
	{
		p.SetState(5351)

		var _x = p.IdentifierList()

		localctx.(*RollupDefContext).rollupCols = _x
	}
	p.SetState(5355)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserDUPLICATE {
		{
			p.SetState(5352)
			p.Match(DorisParserDUPLICATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5353)
			p.Match(DorisParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5354)

			var _x = p.IdentifierList()

			localctx.(*RollupDefContext).dupKeys = _x
		}

	}
	p.SetState(5358)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPROPERTIES {
		{
			p.SetState(5357)

			var _x = p.PropertyClause()

			localctx.(*RollupDefContext).properties = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggTypeDefContext is an interface to support dynamic dispatch.
type IAggTypeDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAX() antlr.TerminalNode
	MIN() antlr.TerminalNode
	SUM() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	REPLACE_IF_NOT_NULL() antlr.TerminalNode
	HLL_UNION() antlr.TerminalNode
	BITMAP_UNION() antlr.TerminalNode
	QUANTILE_UNION() antlr.TerminalNode
	GENERIC() antlr.TerminalNode

	// IsAggTypeDefContext differentiates from other interfaces.
	IsAggTypeDefContext()
}

type AggTypeDefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggTypeDefContext() *AggTypeDefContext {
	var p = new(AggTypeDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_aggTypeDef
	return p
}

func InitEmptyAggTypeDefContext(p *AggTypeDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_aggTypeDef
}

func (*AggTypeDefContext) IsAggTypeDefContext() {}

func NewAggTypeDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggTypeDefContext {
	var p = new(AggTypeDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_aggTypeDef

	return p
}

func (s *AggTypeDefContext) GetParser() antlr.Parser { return s.parser }

func (s *AggTypeDefContext) MAX() antlr.TerminalNode {
	return s.GetToken(DorisParserMAX, 0)
}

func (s *AggTypeDefContext) MIN() antlr.TerminalNode {
	return s.GetToken(DorisParserMIN, 0)
}

func (s *AggTypeDefContext) SUM() antlr.TerminalNode {
	return s.GetToken(DorisParserSUM, 0)
}

func (s *AggTypeDefContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *AggTypeDefContext) REPLACE_IF_NOT_NULL() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE_IF_NOT_NULL, 0)
}

func (s *AggTypeDefContext) HLL_UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserHLL_UNION, 0)
}

func (s *AggTypeDefContext) BITMAP_UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserBITMAP_UNION, 0)
}

func (s *AggTypeDefContext) QUANTILE_UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserQUANTILE_UNION, 0)
}

func (s *AggTypeDefContext) GENERIC() antlr.TerminalNode {
	return s.GetToken(DorisParserGENERIC, 0)
}

func (s *AggTypeDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggTypeDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggTypeDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAggTypeDef(s)
	}
}

func (s *AggTypeDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAggTypeDef(s)
	}
}

func (p *DorisParser) AggTypeDef() (localctx IAggTypeDefContext) {
	localctx = NewAggTypeDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, DorisParserRULE_aggTypeDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5360)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserBITMAP_UNION || _la == DorisParserGENERIC || _la == DorisParserHLL_UNION || _la == DorisParserMAX || _la == DorisParserMIN || ((int64((_la-351)) & ^0x3f) == 0 && ((int64(1)<<(_la-351))&3145729) != 0) || _la == DorisParserSUM) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITabletListContext is an interface to support dynamic dispatch.
type ITabletListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_INTEGER_VALUE returns the _INTEGER_VALUE token.
	Get_INTEGER_VALUE() antlr.Token

	// Set_INTEGER_VALUE sets the _INTEGER_VALUE token.
	Set_INTEGER_VALUE(antlr.Token)

	// GetTabletIdList returns the tabletIdList token list.
	GetTabletIdList() []antlr.Token

	// SetTabletIdList sets the tabletIdList token list.
	SetTabletIdList([]antlr.Token)

	// Getter signatures
	TABLET() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTabletListContext differentiates from other interfaces.
	IsTabletListContext()
}

type TabletListContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	_INTEGER_VALUE antlr.Token
	tabletIdList   []antlr.Token
}

func NewEmptyTabletListContext() *TabletListContext {
	var p = new(TabletListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tabletList
	return p
}

func InitEmptyTabletListContext(p *TabletListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tabletList
}

func (*TabletListContext) IsTabletListContext() {}

func NewTabletListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TabletListContext {
	var p = new(TabletListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_tabletList

	return p
}

func (s *TabletListContext) GetParser() antlr.Parser { return s.parser }

func (s *TabletListContext) Get_INTEGER_VALUE() antlr.Token { return s._INTEGER_VALUE }

func (s *TabletListContext) Set_INTEGER_VALUE(v antlr.Token) { s._INTEGER_VALUE = v }

func (s *TabletListContext) GetTabletIdList() []antlr.Token { return s.tabletIdList }

func (s *TabletListContext) SetTabletIdList(v []antlr.Token) { s.tabletIdList = v }

func (s *TabletListContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLET, 0)
}

func (s *TabletListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *TabletListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *TabletListContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserINTEGER_VALUE)
}

func (s *TabletListContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, i)
}

func (s *TabletListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *TabletListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *TabletListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TabletListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TabletListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTabletList(s)
	}
}

func (s *TabletListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTabletList(s)
	}
}

func (p *DorisParser) TabletList() (localctx ITabletListContext) {
	localctx = NewTabletListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, DorisParserRULE_tabletList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5362)
		p.Match(DorisParserTABLET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5363)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5364)

		var _m = p.Match(DorisParserINTEGER_VALUE)

		localctx.(*TabletListContext)._INTEGER_VALUE = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	localctx.(*TabletListContext).tabletIdList = append(localctx.(*TabletListContext).tabletIdList, localctx.(*TabletListContext)._INTEGER_VALUE)
	p.SetState(5369)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(5365)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5366)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*TabletListContext)._INTEGER_VALUE = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*TabletListContext).tabletIdList = append(localctx.(*TabletListContext).tabletIdList, localctx.(*TabletListContext)._INTEGER_VALUE)

		p.SetState(5371)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5372)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlineTableContext is an interface to support dynamic dispatch.
type IInlineTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALUES() antlr.TerminalNode
	AllRowConstructor() []IRowConstructorContext
	RowConstructor(i int) IRowConstructorContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsInlineTableContext differentiates from other interfaces.
	IsInlineTableContext()
}

type InlineTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineTableContext() *InlineTableContext {
	var p = new(InlineTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_inlineTable
	return p
}

func InitEmptyInlineTableContext(p *InlineTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_inlineTable
}

func (*InlineTableContext) IsInlineTableContext() {}

func NewInlineTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineTableContext {
	var p = new(InlineTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_inlineTable

	return p
}

func (s *InlineTableContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineTableContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisParserVALUES, 0)
}

func (s *InlineTableContext) AllRowConstructor() []IRowConstructorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRowConstructorContext); ok {
			len++
		}
	}

	tst := make([]IRowConstructorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRowConstructorContext); ok {
			tst[i] = t.(IRowConstructorContext)
			i++
		}
	}

	return tst
}

func (s *InlineTableContext) RowConstructor(i int) IRowConstructorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowConstructorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowConstructorContext)
}

func (s *InlineTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *InlineTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *InlineTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterInlineTable(s)
	}
}

func (s *InlineTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitInlineTable(s)
	}
}

func (p *DorisParser) InlineTable() (localctx IInlineTableContext) {
	localctx = NewInlineTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, DorisParserRULE_inlineTable)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5374)
		p.Match(DorisParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5375)
		p.RowConstructor()
	}
	p.SetState(5380)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 784, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5376)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5377)
				p.RowConstructor()
			}

		}
		p.SetState(5382)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 784, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedExpressionContext is an interface to support dynamic dispatch.
type INamedExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	IdentifierOrText() IIdentifierOrTextContext
	AS() antlr.TerminalNode

	// IsNamedExpressionContext differentiates from other interfaces.
	IsNamedExpressionContext()
}

type NamedExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedExpressionContext() *NamedExpressionContext {
	var p = new(NamedExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_namedExpression
	return p
}

func InitEmptyNamedExpressionContext(p *NamedExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_namedExpression
}

func (*NamedExpressionContext) IsNamedExpressionContext() {}

func NewNamedExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedExpressionContext {
	var p = new(NamedExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_namedExpression

	return p
}

func (s *NamedExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NamedExpressionContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *NamedExpressionContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *NamedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterNamedExpression(s)
	}
}

func (s *NamedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitNamedExpression(s)
	}
}

func (p *DorisParser) NamedExpression() (localctx INamedExpressionContext) {
	localctx = NewNamedExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, DorisParserRULE_namedExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5383)
		p.Expression()
	}
	p.SetState(5388)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 786, p.GetParserRuleContext()) == 1 {
		p.SetState(5385)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAS {
			{
				p.SetState(5384)
				p.Match(DorisParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

		{
			p.SetState(5387)
			p.IdentifierOrText()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedExpressionSeqContext is an interface to support dynamic dispatch.
type INamedExpressionSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNamedExpression() []INamedExpressionContext
	NamedExpression(i int) INamedExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsNamedExpressionSeqContext differentiates from other interfaces.
	IsNamedExpressionSeqContext()
}

type NamedExpressionSeqContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedExpressionSeqContext() *NamedExpressionSeqContext {
	var p = new(NamedExpressionSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_namedExpressionSeq
	return p
}

func InitEmptyNamedExpressionSeqContext(p *NamedExpressionSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_namedExpressionSeq
}

func (*NamedExpressionSeqContext) IsNamedExpressionSeqContext() {}

func NewNamedExpressionSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedExpressionSeqContext {
	var p = new(NamedExpressionSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_namedExpressionSeq

	return p
}

func (s *NamedExpressionSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedExpressionSeqContext) AllNamedExpression() []INamedExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedExpressionContext); ok {
			len++
		}
	}

	tst := make([]INamedExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedExpressionContext); ok {
			tst[i] = t.(INamedExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NamedExpressionSeqContext) NamedExpression(i int) INamedExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionContext)
}

func (s *NamedExpressionSeqContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *NamedExpressionSeqContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *NamedExpressionSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedExpressionSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedExpressionSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterNamedExpressionSeq(s)
	}
}

func (s *NamedExpressionSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitNamedExpressionSeq(s)
	}
}

func (p *DorisParser) NamedExpressionSeq() (localctx INamedExpressionSeqContext) {
	localctx = NewNamedExpressionSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, DorisParserRULE_namedExpressionSeq)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5390)
		p.NamedExpression()
	}
	p.SetState(5395)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 787, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5391)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5392)
				p.NamedExpression()
			}

		}
		p.SetState(5397)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 787, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BooleanExpression() IBooleanExpressionContext
	LambdaExpression() ILambdaExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ExpressionContext) LambdaExpression() ILambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *DorisParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, DorisParserRULE_expression)
	p.SetState(5400)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 788, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5398)
			p.booleanExpression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5399)
			p.LambdaExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaExpressionContext is an interface to support dynamic dispatch.
type ILambdaExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_errorCapturingIdentifier returns the _errorCapturingIdentifier rule contexts.
	Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext

	// GetBody returns the body rule contexts.
	GetBody() IBooleanExpressionContext

	// Set_errorCapturingIdentifier sets the _errorCapturingIdentifier rule contexts.
	Set_errorCapturingIdentifier(IErrorCapturingIdentifierContext)

	// SetBody sets the body rule contexts.
	SetBody(IBooleanExpressionContext)

	// GetArgs returns the args rule context list.
	GetArgs() []IErrorCapturingIdentifierContext

	// SetArgs sets the args rule context list.
	SetArgs([]IErrorCapturingIdentifierContext)

	// Getter signatures
	ARROW() antlr.TerminalNode
	AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext
	ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext
	BooleanExpression() IBooleanExpressionContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLambdaExpressionContext differentiates from other interfaces.
	IsLambdaExpressionContext()
}

type LambdaExpressionContext struct {
	antlr.BaseParserRuleContext
	parser                    antlr.Parser
	_errorCapturingIdentifier IErrorCapturingIdentifierContext
	args                      []IErrorCapturingIdentifierContext
	body                      IBooleanExpressionContext
}

func NewEmptyLambdaExpressionContext() *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_lambdaExpression
	return p
}

func InitEmptyLambdaExpressionContext(p *LambdaExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_lambdaExpression
}

func (*LambdaExpressionContext) IsLambdaExpressionContext() {}

func NewLambdaExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_lambdaExpression

	return p
}

func (s *LambdaExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaExpressionContext) Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext {
	return s._errorCapturingIdentifier
}

func (s *LambdaExpressionContext) GetBody() IBooleanExpressionContext { return s.body }

func (s *LambdaExpressionContext) Set_errorCapturingIdentifier(v IErrorCapturingIdentifierContext) {
	s._errorCapturingIdentifier = v
}

func (s *LambdaExpressionContext) SetBody(v IBooleanExpressionContext) { s.body = v }

func (s *LambdaExpressionContext) GetArgs() []IErrorCapturingIdentifierContext { return s.args }

func (s *LambdaExpressionContext) SetArgs(v []IErrorCapturingIdentifierContext) { s.args = v }

func (s *LambdaExpressionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(DorisParserARROW, 0)
}

func (s *LambdaExpressionContext) AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IErrorCapturingIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			tst[i] = t.(IErrorCapturingIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *LambdaExpressionContext) ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *LambdaExpressionContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LambdaExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *LambdaExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *LambdaExpressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *LambdaExpressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *LambdaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLambdaExpression(s)
	}
}

func (s *LambdaExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLambdaExpression(s)
	}
}

func (p *DorisParser) LambdaExpression() (localctx ILambdaExpressionContext) {
	localctx = NewLambdaExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, DorisParserRULE_lambdaExpression)
	var _la int

	p.SetState(5418)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5402)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*LambdaExpressionContext)._errorCapturingIdentifier = _x
		}
		localctx.(*LambdaExpressionContext).args = append(localctx.(*LambdaExpressionContext).args, localctx.(*LambdaExpressionContext)._errorCapturingIdentifier)
		{
			p.SetState(5403)
			p.Match(DorisParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5404)

			var _x = p.booleanExpression(0)

			localctx.(*LambdaExpressionContext).body = _x
		}

	case DorisParserLEFT_PAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5406)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5407)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*LambdaExpressionContext)._errorCapturingIdentifier = _x
		}
		localctx.(*LambdaExpressionContext).args = append(localctx.(*LambdaExpressionContext).args, localctx.(*LambdaExpressionContext)._errorCapturingIdentifier)
		p.SetState(5410)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == DorisParserCOMMA {
			{
				p.SetState(5408)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5409)

				var _x = p.ErrorCapturingIdentifier()

				localctx.(*LambdaExpressionContext)._errorCapturingIdentifier = _x
			}
			localctx.(*LambdaExpressionContext).args = append(localctx.(*LambdaExpressionContext).args, localctx.(*LambdaExpressionContext)._errorCapturingIdentifier)

			p.SetState(5412)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5414)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5415)
			p.Match(DorisParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5416)

			var _x = p.booleanExpression(0)

			localctx.(*LambdaExpressionContext).body = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanExpressionContext is an interface to support dynamic dispatch.
type IBooleanExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBooleanExpressionContext differentiates from other interfaces.
	IsBooleanExpressionContext()
}

type BooleanExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanExpressionContext() *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_booleanExpression
	return p
}

func InitEmptyBooleanExpressionContext(p *BooleanExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_booleanExpression
}

func (*BooleanExpressionContext) IsBooleanExpressionContext() {}

func NewBooleanExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_booleanExpression

	return p
}

func (s *BooleanExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanExpressionContext) CopyAll(ctx *BooleanExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BooleanExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExistContext struct {
	BooleanExpressionContext
}

func NewExistContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistContext {
	var p = new(ExistContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *ExistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *ExistContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ExistContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *ExistContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ExistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterExist(s)
	}
}

func (s *ExistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitExist(s)
	}
}

type LogicalNotContext struct {
	BooleanExpressionContext
}

func NewLogicalNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalNotContext {
	var p = new(LogicalNotContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalNotContext) LOGICALNOT() antlr.TerminalNode {
	return s.GetToken(DorisParserLOGICALNOT, 0)
}

func (s *LogicalNotContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *LogicalNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLogicalNot(s)
	}
}

func (s *LogicalNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLogicalNot(s)
	}
}

type PredicatedContext struct {
	BooleanExpressionContext
}

func NewPredicatedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicatedContext {
	var p = new(PredicatedContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *PredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicatedContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicatedContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPredicated(s)
	}
}

func (s *PredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPredicated(s)
	}
}

type IsnullContext struct {
	BooleanExpressionContext
}

func NewIsnullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsnullContext {
	var p = new(IsnullContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *IsnullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsnullContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *IsnullContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *IsnullContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *IsnullContext) ISNULL() antlr.TerminalNode {
	return s.GetToken(DorisParserISNULL, 0)
}

func (s *IsnullContext) IS_NULL_PRED() antlr.TerminalNode {
	return s.GetToken(DorisParserIS_NULL_PRED, 0)
}

func (s *IsnullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIsnull(s)
	}
}

func (s *IsnullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIsnull(s)
	}
}

type Is_not_null_predContext struct {
	BooleanExpressionContext
}

func NewIs_not_null_predContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Is_not_null_predContext {
	var p = new(Is_not_null_predContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *Is_not_null_predContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Is_not_null_predContext) IS_NOT_NULL_PRED() antlr.TerminalNode {
	return s.GetToken(DorisParserIS_NOT_NULL_PRED, 0)
}

func (s *Is_not_null_predContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *Is_not_null_predContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *Is_not_null_predContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *Is_not_null_predContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIs_not_null_pred(s)
	}
}

func (s *Is_not_null_predContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIs_not_null_pred(s)
	}
}

type LogicalBinaryContext struct {
	BooleanExpressionContext
	left     IBooleanExpressionContext
	operator antlr.Token
	right    IBooleanExpressionContext
}

func NewLogicalBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalBinaryContext {
	var p = new(LogicalBinaryContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *LogicalBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *LogicalBinaryContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *LogicalBinaryContext) GetRight() IBooleanExpressionContext { return s.right }

func (s *LogicalBinaryContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *LogicalBinaryContext) SetRight(v IBooleanExpressionContext) { s.right = v }

func (s *LogicalBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalBinaryContext) AllBooleanExpression() []IBooleanExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			len++
		}
	}

	tst := make([]IBooleanExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBooleanExpressionContext); ok {
			tst[i] = t.(IBooleanExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalBinaryContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalBinaryContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisParserAND, 0)
}

func (s *LogicalBinaryContext) LOGICALAND() antlr.TerminalNode {
	return s.GetToken(DorisParserLOGICALAND, 0)
}

func (s *LogicalBinaryContext) XOR() antlr.TerminalNode {
	return s.GetToken(DorisParserXOR, 0)
}

func (s *LogicalBinaryContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisParserOR, 0)
}

func (s *LogicalBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLogicalBinary(s)
	}
}

type DoublePipesContext struct {
	BooleanExpressionContext
	left     IBooleanExpressionContext
	operator antlr.Token
	right    IBooleanExpressionContext
}

func NewDoublePipesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoublePipesContext {
	var p = new(DoublePipesContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *DoublePipesContext) GetOperator() antlr.Token { return s.operator }

func (s *DoublePipesContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *DoublePipesContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *DoublePipesContext) GetRight() IBooleanExpressionContext { return s.right }

func (s *DoublePipesContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *DoublePipesContext) SetRight(v IBooleanExpressionContext) { s.right = v }

func (s *DoublePipesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoublePipesContext) AllBooleanExpression() []IBooleanExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			len++
		}
	}

	tst := make([]IBooleanExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBooleanExpressionContext); ok {
			tst[i] = t.(IBooleanExpressionContext)
			i++
		}
	}

	return tst
}

func (s *DoublePipesContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *DoublePipesContext) DOUBLEPIPES() antlr.TerminalNode {
	return s.GetToken(DorisParserDOUBLEPIPES, 0)
}

func (s *DoublePipesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDoublePipes(s)
	}
}

func (s *DoublePipesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDoublePipes(s)
	}
}

func (p *DorisParser) BooleanExpression() (localctx IBooleanExpressionContext) {
	return p.booleanExpression(0)
}

func (p *DorisParser) booleanExpression(_p int) (localctx IBooleanExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBooleanExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBooleanExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 370
	p.EnterRecursionRule(localctx, 370, DorisParserRULE_booleanExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5444)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 792, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(5421)
			p.Match(DorisParserLOGICALNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5422)
			p.booleanExpression(10)
		}

	case 2:
		localctx = NewExistContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5423)
			p.Match(DorisParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5424)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5425)
			p.Query()
		}
		{
			p.SetState(5426)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewIsnullContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5428)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserIS_NULL_PRED || _la == DorisParserISNULL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5429)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5430)
			p.valueExpression(0)
		}
		{
			p.SetState(5431)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewIs_not_null_predContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5433)
			p.Match(DorisParserIS_NOT_NULL_PRED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5434)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5435)
			p.valueExpression(0)
		}
		{
			p.SetState(5436)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewPredicatedContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5438)
			p.valueExpression(0)
		}
		p.SetState(5440)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 791, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5439)
				p.Predicate()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5442)
			p.Match(DorisParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5443)
			p.booleanExpression(5)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(5460)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 794, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(5458)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 793, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_booleanExpression)
				p.SetState(5446)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(5447)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*LogicalBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisParserAND || _la == DorisParserLOGICALAND) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*LogicalBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(5448)

					var _x = p.booleanExpression(5)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 2:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_booleanExpression)
				p.SetState(5449)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(5450)

					var _m = p.Match(DorisParserXOR)

					localctx.(*LogicalBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5451)

					var _x = p.booleanExpression(4)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 3:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_booleanExpression)
				p.SetState(5452)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(5453)

					var _m = p.Match(DorisParserOR)

					localctx.(*LogicalBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5454)

					var _x = p.booleanExpression(3)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 4:
				localctx = NewDoublePipesContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*DoublePipesContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_booleanExpression)
				p.SetState(5455)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(5456)

					var _m = p.Match(DorisParserDOUBLEPIPES)

					localctx.(*DoublePipesContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5457)

					var _x = p.booleanExpression(2)

					localctx.(*DoublePipesContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(5462)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 794, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowConstructorContext is an interface to support dynamic dispatch.
type IRowConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllRowConstructorItem() []IRowConstructorItemContext
	RowConstructorItem(i int) IRowConstructorItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRowConstructorContext differentiates from other interfaces.
	IsRowConstructorContext()
}

type RowConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowConstructorContext() *RowConstructorContext {
	var p = new(RowConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_rowConstructor
	return p
}

func InitEmptyRowConstructorContext(p *RowConstructorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_rowConstructor
}

func (*RowConstructorContext) IsRowConstructorContext() {}

func NewRowConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowConstructorContext {
	var p = new(RowConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_rowConstructor

	return p
}

func (s *RowConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *RowConstructorContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *RowConstructorContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *RowConstructorContext) AllRowConstructorItem() []IRowConstructorItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRowConstructorItemContext); ok {
			len++
		}
	}

	tst := make([]IRowConstructorItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRowConstructorItemContext); ok {
			tst[i] = t.(IRowConstructorItemContext)
			i++
		}
	}

	return tst
}

func (s *RowConstructorContext) RowConstructorItem(i int) IRowConstructorItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowConstructorItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowConstructorItemContext)
}

func (s *RowConstructorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *RowConstructorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *RowConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRowConstructor(s)
	}
}

func (s *RowConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRowConstructor(s)
	}
}

func (p *DorisParser) RowConstructor() (localctx IRowConstructorContext) {
	localctx = NewRowConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, DorisParserRULE_rowConstructor)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5463)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8646890354245592708) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-5188430204749515009) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-6232419426235955661) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&9126402704879377875) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-2873932114615608333) != 0) || ((int64((_la-322)) & ^0x3f) == 0 && ((int64(1)<<(_la-322))&-2310602210946850817) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&-2627780018309275847) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&-7818098869825860867) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&56383) != 0) {
		{
			p.SetState(5464)
			p.RowConstructorItem()
		}
		p.SetState(5469)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(5465)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5466)
				p.RowConstructorItem()
			}

			p.SetState(5471)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(5474)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowConstructorItemContext is an interface to support dynamic dispatch.
type IRowConstructorItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext
	DEFAULT() antlr.TerminalNode
	NamedExpression() INamedExpressionContext

	// IsRowConstructorItemContext differentiates from other interfaces.
	IsRowConstructorItemContext()
}

type RowConstructorItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowConstructorItemContext() *RowConstructorItemContext {
	var p = new(RowConstructorItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_rowConstructorItem
	return p
}

func InitEmptyRowConstructorItemContext(p *RowConstructorItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_rowConstructorItem
}

func (*RowConstructorItemContext) IsRowConstructorItemContext() {}

func NewRowConstructorItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowConstructorItemContext {
	var p = new(RowConstructorItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_rowConstructorItem

	return p
}

func (s *RowConstructorItemContext) GetParser() antlr.Parser { return s.parser }

func (s *RowConstructorItemContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *RowConstructorItemContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *RowConstructorItemContext) NamedExpression() INamedExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionContext)
}

func (s *RowConstructorItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowConstructorItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowConstructorItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRowConstructorItem(s)
	}
}

func (s *RowConstructorItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRowConstructorItem(s)
	}
}

func (p *DorisParser) RowConstructorItem() (localctx IRowConstructorItemContext) {
	localctx = NewRowConstructorItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, DorisParserRULE_rowConstructorItem)
	p.SetState(5479)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 797, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5476)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5477)
			p.Match(DorisParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5478)
			p.NamedExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKind returns the kind token.
	GetKind() antlr.Token

	// SetKind sets the kind token.
	SetKind(antlr.Token)

	// GetLower returns the lower rule contexts.
	GetLower() IValueExpressionContext

	// GetUpper returns the upper rule contexts.
	GetUpper() IValueExpressionContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IValueExpressionContext

	// SetLower sets the lower rule contexts.
	SetLower(IValueExpressionContext)

	// SetUpper sets the upper rule contexts.
	SetUpper(IValueExpressionContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IValueExpressionContext)

	// Getter signatures
	AND() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	AllValueExpression() []IValueExpressionContext
	ValueExpression(i int) IValueExpressionContext
	NOT() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	REGEXP() antlr.TerminalNode
	RLIKE() antlr.TerminalNode
	MATCH() antlr.TerminalNode
	MATCH_ANY() antlr.TerminalNode
	MATCH_ALL() antlr.TerminalNode
	MATCH_PHRASE() antlr.TerminalNode
	MATCH_PHRASE_PREFIX() antlr.TerminalNode
	MATCH_REGEXP() antlr.TerminalNode
	MATCH_PHRASE_EDGE() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	Query() IQueryContext
	RIGHT_PAREN() antlr.TerminalNode
	IN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	IS() antlr.TerminalNode
	NULL() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	kind    antlr.Token
	lower   IValueExpressionContext
	upper   IValueExpressionContext
	pattern IValueExpressionContext
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_predicate
	return p
}

func InitEmptyPredicateContext(p *PredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_predicate
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) GetKind() antlr.Token { return s.kind }

func (s *PredicateContext) SetKind(v antlr.Token) { s.kind = v }

func (s *PredicateContext) GetLower() IValueExpressionContext { return s.lower }

func (s *PredicateContext) GetUpper() IValueExpressionContext { return s.upper }

func (s *PredicateContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *PredicateContext) SetLower(v IValueExpressionContext) { s.lower = v }

func (s *PredicateContext) SetUpper(v IValueExpressionContext) { s.upper = v }

func (s *PredicateContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *PredicateContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisParserAND, 0)
}

func (s *PredicateContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(DorisParserBETWEEN, 0)
}

func (s *PredicateContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PredicateContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *PredicateContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *PredicateContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(DorisParserREGEXP, 0)
}

func (s *PredicateContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserRLIKE, 0)
}

func (s *PredicateContext) MATCH() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH, 0)
}

func (s *PredicateContext) MATCH_ANY() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_ANY, 0)
}

func (s *PredicateContext) MATCH_ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_ALL, 0)
}

func (s *PredicateContext) MATCH_PHRASE() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_PHRASE, 0)
}

func (s *PredicateContext) MATCH_PHRASE_PREFIX() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_PHRASE_PREFIX, 0)
}

func (s *PredicateContext) MATCH_REGEXP() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_REGEXP, 0)
}

func (s *PredicateContext) MATCH_PHRASE_EDGE() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_PHRASE_EDGE, 0)
}

func (s *PredicateContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *PredicateContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *PredicateContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *PredicateContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *PredicateContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PredicateContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PredicateContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *PredicateContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *PredicateContext) IS() antlr.TerminalNode {
	return s.GetToken(DorisParserIS, 0)
}

func (s *PredicateContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisParserNULL, 0)
}

func (s *PredicateContext) TRUE() antlr.TerminalNode {
	return s.GetToken(DorisParserTRUE, 0)
}

func (s *PredicateContext) FALSE() antlr.TerminalNode {
	return s.GetToken(DorisParserFALSE, 0)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPredicate(s)
	}
}

func (s *PredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPredicate(s)
	}
}

func (p *DorisParser) Predicate() (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, DorisParserRULE_predicate)
	var _la int

	p.SetState(5532)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 806, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5482)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(5481)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5484)

			var _m = p.Match(DorisParserBETWEEN)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5485)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).lower = _x
		}
		{
			p.SetState(5486)
			p.Match(DorisParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5487)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).upper = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5490)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(5489)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5492)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PredicateContext).kind = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserLIKE || _la == DorisParserREGEXP || _la == DorisParserRLIKE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PredicateContext).kind = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5493)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).pattern = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(5495)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(5494)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5497)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PredicateContext).kind = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-271)) & ^0x3f) == 0 && ((int64(1)<<(_la-271))&127) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PredicateContext).kind = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5498)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).pattern = _x
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(5500)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(5499)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5502)

			var _m = p.Match(DorisParserIN)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5503)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5504)
			p.Query()
		}
		{
			p.SetState(5505)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(5508)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(5507)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5510)

			var _m = p.Match(DorisParserIN)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5511)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5512)
			p.Expression()
		}
		p.SetState(5517)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(5513)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5514)
				p.Expression()
			}

			p.SetState(5519)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5520)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5522)
			p.Match(DorisParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5524)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(5523)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5526)

			var _m = p.Match(DorisParserNULL)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5527)
			p.Match(DorisParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5529)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(5528)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5531)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PredicateContext).kind = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserFALSE || _la == DorisParserTRUE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PredicateContext).kind = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueExpressionContext is an interface to support dynamic dispatch.
type IValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsValueExpressionContext differentiates from other interfaces.
	IsValueExpressionContext()
}

type ValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExpressionContext() *ValueExpressionContext {
	var p = new(ValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_valueExpression
	return p
}

func InitEmptyValueExpressionContext(p *ValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_valueExpression
}

func (*ValueExpressionContext) IsValueExpressionContext() {}

func NewValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExpressionContext {
	var p = new(ValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_valueExpression

	return p
}

func (s *ValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExpressionContext) CopyAll(ctx *ValueExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ValueExpressionDefaultContext struct {
	ValueExpressionContext
}

func NewValueExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValueExpressionDefaultContext {
	var p = new(ValueExpressionDefaultContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ValueExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionDefaultContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ValueExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitValueExpressionDefault(s)
	}
}

type ComparisonContext struct {
	ValueExpressionContext
	left  IValueExpressionContext
	right IValueExpressionContext
}

func NewComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonContext {
	var p = new(ComparisonContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ComparisonContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ComparisonContext) GetRight() IValueExpressionContext { return s.right }

func (s *ComparisonContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ComparisonContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitComparison(s)
	}
}

type ArithmeticBinaryContext struct {
	ValueExpressionContext
	left     IValueExpressionContext
	operator antlr.Token
	right    IValueExpressionContext
}

func NewArithmeticBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticBinaryContext {
	var p = new(ArithmeticBinaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticBinaryContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ArithmeticBinaryContext) GetRight() IValueExpressionContext { return s.right }

func (s *ArithmeticBinaryContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ArithmeticBinaryContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ArithmeticBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticBinaryContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArithmeticBinaryContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticBinaryContext) HAT() antlr.TerminalNode {
	return s.GetToken(DorisParserHAT, 0)
}

func (s *ArithmeticBinaryContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserASTERISK, 0)
}

func (s *ArithmeticBinaryContext) SLASH() antlr.TerminalNode {
	return s.GetToken(DorisParserSLASH, 0)
}

func (s *ArithmeticBinaryContext) MOD() antlr.TerminalNode {
	return s.GetToken(DorisParserMOD, 0)
}

func (s *ArithmeticBinaryContext) DIV() antlr.TerminalNode {
	return s.GetToken(DorisParserDIV, 0)
}

func (s *ArithmeticBinaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(DorisParserPLUS, 0)
}

func (s *ArithmeticBinaryContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(DorisParserSUBTRACT, 0)
}

func (s *ArithmeticBinaryContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(DorisParserAMPERSAND, 0)
}

func (s *ArithmeticBinaryContext) PIPE() antlr.TerminalNode {
	return s.GetToken(DorisParserPIPE, 0)
}

func (s *ArithmeticBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitArithmeticBinary(s)
	}
}

type ArithmeticUnaryContext struct {
	ValueExpressionContext
	operator antlr.Token
}

func NewArithmeticUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticUnaryContext {
	var p = new(ArithmeticUnaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticUnaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticUnaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticUnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticUnaryContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticUnaryContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(DorisParserSUBTRACT, 0)
}

func (s *ArithmeticUnaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(DorisParserPLUS, 0)
}

func (s *ArithmeticUnaryContext) TILDE() antlr.TerminalNode {
	return s.GetToken(DorisParserTILDE, 0)
}

func (s *ArithmeticUnaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitArithmeticUnary(s)
	}
}

func (p *DorisParser) ValueExpression() (localctx IValueExpressionContext) {
	return p.valueExpression(0)
}

func (p *DorisParser) valueExpression(_p int) (localctx IValueExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewValueExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 378
	p.EnterRecursionRule(localctx, 378, DorisParserRULE_valueExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5538)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 807, p.GetParserRuleContext()) {
	case 1:
		localctx = NewValueExpressionDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(5535)
			p.primaryExpression(0)
		}

	case 2:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5536)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ArithmeticUnaryContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-507)) & ^0x3f) == 0 && ((int64(1)<<(_la-507))&35) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ArithmeticUnaryContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5537)
			p.valueExpression(7)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(5561)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 809, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(5559)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 808, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_valueExpression)
				p.SetState(5540)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(5541)

					var _m = p.Match(DorisParserHAT)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5542)

					var _x = p.valueExpression(7)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 2:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_valueExpression)
				p.SetState(5543)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(5544)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisParserDIV || ((int64((_la-509)) & ^0x3f) == 0 && ((int64(1)<<(_la-509))&7) != 0)) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(5545)

					var _x = p.valueExpression(6)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 3:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_valueExpression)
				p.SetState(5546)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(5547)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisParserPLUS || _la == DorisParserSUBTRACT) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(5548)

					var _x = p.valueExpression(5)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 4:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_valueExpression)
				p.SetState(5549)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(5550)

					var _m = p.Match(DorisParserAMPERSAND)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5551)

					var _x = p.valueExpression(4)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 5:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_valueExpression)
				p.SetState(5552)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(5553)

					var _m = p.Match(DorisParserPIPE)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5554)

					var _x = p.valueExpression(3)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 6:
				localctx = NewComparisonContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ComparisonContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_valueExpression)
				p.SetState(5555)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(5556)
					p.ComparisonOperator()
				}
				{
					p.SetState(5557)

					var _x = p.valueExpression(2)

					localctx.(*ComparisonContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(5563)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 809, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_primaryExpression
	return p
}

func InitEmptyPrimaryExpressionContext(p *PrimaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_primaryExpression
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) CopyAll(ctx *PrimaryExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DereferenceContext struct {
	PrimaryExpressionContext
	base      IPrimaryExpressionContext
	fieldName IIdentifierContext
}

func NewDereferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DereferenceContext {
	var p = new(DereferenceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DereferenceContext) GetBase() IPrimaryExpressionContext { return s.base }

func (s *DereferenceContext) GetFieldName() IIdentifierContext { return s.fieldName }

func (s *DereferenceContext) SetBase(v IPrimaryExpressionContext) { s.base = v }

func (s *DereferenceContext) SetFieldName(v IIdentifierContext) { s.fieldName = v }

func (s *DereferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DereferenceContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *DereferenceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *DereferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DereferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDereference(s)
	}
}

func (s *DereferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDereference(s)
	}
}

type CurrentDateContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentDateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentDateContext {
	var p = new(CurrentDateContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentDateContext) GetName() antlr.Token { return s.name }

func (s *CurrentDateContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentDateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentDateContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_DATE, 0)
}

func (s *CurrentDateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCurrentDate(s)
	}
}

func (s *CurrentDateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCurrentDate(s)
	}
}

type CastContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastContext {
	var p = new(CastContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CastContext) GetName() antlr.Token { return s.name }

func (s *CastContext) SetName(v antlr.Token) { s.name = v }

func (s *CastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CastContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *CastContext) CastDataType() ICastDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastDataTypeContext)
}

func (s *CastContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CastContext) CAST() antlr.TerminalNode {
	return s.GetToken(DorisParserCAST, 0)
}

func (s *CastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCast(s)
	}
}

func (s *CastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCast(s)
	}
}

type ParenthesizedExpressionContext struct {
	PrimaryExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

type UserVariableContext struct {
	PrimaryExpressionContext
}

func NewUserVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserVariableContext {
	var p = new(UserVariableContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *UserVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserVariableContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserATSIGN, 0)
}

func (s *UserVariableContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *UserVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUserVariable(s)
	}
}

func (s *UserVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUserVariable(s)
	}
}

type ElementAtContext struct {
	PrimaryExpressionContext
	value IPrimaryExpressionContext
	index IValueExpressionContext
}

func NewElementAtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ElementAtContext {
	var p = new(ElementAtContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ElementAtContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *ElementAtContext) GetIndex() IValueExpressionContext { return s.index }

func (s *ElementAtContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *ElementAtContext) SetIndex(v IValueExpressionContext) { s.index = v }

func (s *ElementAtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementAtContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACKET, 0)
}

func (s *ElementAtContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACKET, 0)
}

func (s *ElementAtContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ElementAtContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ElementAtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterElementAt(s)
	}
}

func (s *ElementAtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitElementAt(s)
	}
}

type LocalTimestampContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewLocalTimestampContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LocalTimestampContext {
	var p = new(LocalTimestampContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LocalTimestampContext) GetName() antlr.Token { return s.name }

func (s *LocalTimestampContext) SetName(v antlr.Token) { s.name = v }

func (s *LocalTimestampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalTimestampContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCALTIMESTAMP, 0)
}

func (s *LocalTimestampContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLocalTimestamp(s)
	}
}

func (s *LocalTimestampContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLocalTimestamp(s)
	}
}

type CharFunctionContext struct {
	PrimaryExpressionContext
	_expression IExpressionContext
	arguments   []IExpressionContext
	charSet     IIdentifierOrTextContext
}

func NewCharFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CharFunctionContext {
	var p = new(CharFunctionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CharFunctionContext) Get_expression() IExpressionContext { return s._expression }

func (s *CharFunctionContext) GetCharSet() IIdentifierOrTextContext { return s.charSet }

func (s *CharFunctionContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *CharFunctionContext) SetCharSet(v IIdentifierOrTextContext) { s.charSet = v }

func (s *CharFunctionContext) GetArguments() []IExpressionContext { return s.arguments }

func (s *CharFunctionContext) SetArguments(v []IExpressionContext) { s.arguments = v }

func (s *CharFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharFunctionContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserCHAR, 0)
}

func (s *CharFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CharFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CharFunctionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CharFunctionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CharFunctionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *CharFunctionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *CharFunctionContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserUSING, 0)
}

func (s *CharFunctionContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CharFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCharFunction(s)
	}
}

func (s *CharFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCharFunction(s)
	}
}

type IntervalLiteralContext struct {
	PrimaryExpressionContext
}

func NewIntervalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalLiteralContext {
	var p = new(IntervalLiteralContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *IntervalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalLiteralContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *IntervalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIntervalLiteral(s)
	}
}

func (s *IntervalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIntervalLiteral(s)
	}
}

type SimpleCaseContext struct {
	PrimaryExpressionContext
	value          IExpressionContext
	elseExpression IExpressionContext
}

func NewSimpleCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleCaseContext {
	var p = new(SimpleCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SimpleCaseContext) GetValue() IExpressionContext { return s.value }

func (s *SimpleCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SimpleCaseContext) SetValue(v IExpressionContext) { s.value = v }

func (s *SimpleCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SimpleCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(DorisParserCASE, 0)
}

func (s *SimpleCaseContext) END() antlr.TerminalNode {
	return s.GetToken(DorisParserEND, 0)
}

func (s *SimpleCaseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SimpleCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(DorisParserELSE, 0)
}

func (s *SimpleCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSimpleCase(s)
	}
}

func (s *SimpleCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSimpleCase(s)
	}
}

type ColumnReferenceContext struct {
	PrimaryExpressionContext
}

func NewColumnReferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnReferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnReferenceContext) BINARY() antlr.TerminalNode {
	return s.GetToken(DorisParserBINARY, 0)
}

func (s *ColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterColumnReference(s)
	}
}

func (s *ColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitColumnReference(s)
	}
}

type StarContext struct {
	PrimaryExpressionContext
}

func NewStarContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StarContext {
	var p = new(StarContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *StarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StarContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserASTERISK, 0)
}

func (s *StarContext) AllExceptOrReplace() []IExceptOrReplaceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExceptOrReplaceContext); ok {
			len++
		}
	}

	tst := make([]IExceptOrReplaceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExceptOrReplaceContext); ok {
			tst[i] = t.(IExceptOrReplaceContext)
			i++
		}
	}

	return tst
}

func (s *StarContext) ExceptOrReplace(i int) IExceptOrReplaceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExceptOrReplaceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExceptOrReplaceContext)
}

func (s *StarContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *StarContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *StarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStar(s)
	}
}

func (s *StarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStar(s)
	}
}

type SessionUserContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewSessionUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SessionUserContext {
	var p = new(SessionUserContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SessionUserContext) GetName() antlr.Token { return s.name }

func (s *SessionUserContext) SetName(v antlr.Token) { s.name = v }

func (s *SessionUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SessionUserContext) SESSION_USER() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION_USER, 0)
}

func (s *SessionUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSessionUser(s)
	}
}

func (s *SessionUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSessionUser(s)
	}
}

type ConvertTypeContext struct {
	PrimaryExpressionContext
	argument IExpressionContext
}

func NewConvertTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConvertTypeContext {
	var p = new(ConvertTypeContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ConvertTypeContext) GetArgument() IExpressionContext { return s.argument }

func (s *ConvertTypeContext) SetArgument(v IExpressionContext) { s.argument = v }

func (s *ConvertTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertTypeContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(DorisParserCONVERT, 0)
}

func (s *ConvertTypeContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ConvertTypeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, 0)
}

func (s *ConvertTypeContext) CastDataType() ICastDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastDataTypeContext)
}

func (s *ConvertTypeContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ConvertTypeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConvertTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterConvertType(s)
	}
}

func (s *ConvertTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitConvertType(s)
	}
}

type ConvertCharSetContext struct {
	PrimaryExpressionContext
	argument IExpressionContext
	charSet  IIdentifierOrTextContext
}

func NewConvertCharSetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConvertCharSetContext {
	var p = new(ConvertCharSetContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ConvertCharSetContext) GetArgument() IExpressionContext { return s.argument }

func (s *ConvertCharSetContext) GetCharSet() IIdentifierOrTextContext { return s.charSet }

func (s *ConvertCharSetContext) SetArgument(v IExpressionContext) { s.argument = v }

func (s *ConvertCharSetContext) SetCharSet(v IIdentifierOrTextContext) { s.charSet = v }

func (s *ConvertCharSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertCharSetContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(DorisParserCONVERT, 0)
}

func (s *ConvertCharSetContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ConvertCharSetContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserUSING, 0)
}

func (s *ConvertCharSetContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ConvertCharSetContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConvertCharSetContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *ConvertCharSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterConvertCharSet(s)
	}
}

func (s *ConvertCharSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitConvertCharSet(s)
	}
}

type SubqueryExpressionContext struct {
	PrimaryExpressionContext
}

func NewSubqueryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryExpressionContext {
	var p = new(SubqueryExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubqueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *SubqueryExpressionContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *SubqueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSubqueryExpression(s)
	}
}

func (s *SubqueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSubqueryExpression(s)
	}
}

type EncryptKeyContext struct {
	PrimaryExpressionContext
	dbName  IIdentifierContext
	keyName IIdentifierContext
}

func NewEncryptKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EncryptKeyContext {
	var p = new(EncryptKeyContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *EncryptKeyContext) GetDbName() IIdentifierContext { return s.dbName }

func (s *EncryptKeyContext) GetKeyName() IIdentifierContext { return s.keyName }

func (s *EncryptKeyContext) SetDbName(v IIdentifierContext) { s.dbName = v }

func (s *EncryptKeyContext) SetKeyName(v IIdentifierContext) { s.keyName = v }

func (s *EncryptKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EncryptKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserKEY, 0)
}

func (s *EncryptKeyContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *EncryptKeyContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EncryptKeyContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *EncryptKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterEncryptKey(s)
	}
}

func (s *EncryptKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitEncryptKey(s)
	}
}

type CurrentTimeContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentTimeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentTimeContext {
	var p = new(CurrentTimeContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentTimeContext) GetName() antlr.Token { return s.name }

func (s *CurrentTimeContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentTimeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentTimeContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_TIME, 0)
}

func (s *CurrentTimeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCurrentTime(s)
	}
}

func (s *CurrentTimeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCurrentTime(s)
	}
}

type LocalTimeContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewLocalTimeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LocalTimeContext {
	var p = new(LocalTimeContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LocalTimeContext) GetName() antlr.Token { return s.name }

func (s *LocalTimeContext) SetName(v antlr.Token) { s.name = v }

func (s *LocalTimeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalTimeContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCALTIME, 0)
}

func (s *LocalTimeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLocalTime(s)
	}
}

func (s *LocalTimeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLocalTime(s)
	}
}

type SystemVariableContext struct {
	PrimaryExpressionContext
	kind antlr.Token
}

func NewSystemVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SystemVariableContext {
	var p = new(SystemVariableContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SystemVariableContext) GetKind() antlr.Token { return s.kind }

func (s *SystemVariableContext) SetKind(v antlr.Token) { s.kind = v }

func (s *SystemVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SystemVariableContext) DOUBLEATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserDOUBLEATSIGN, 0)
}

func (s *SystemVariableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SystemVariableContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *SystemVariableContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *SystemVariableContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION, 0)
}

func (s *SystemVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSystemVariable(s)
	}
}

func (s *SystemVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSystemVariable(s)
	}
}

type CollateContext struct {
	PrimaryExpressionContext
}

func NewCollateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollateContext {
	var p = new(CollateContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *CollateContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLLATE, 0)
}

func (s *CollateContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CollateContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CollateContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *CollateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCollate(s)
	}
}

func (s *CollateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCollate(s)
	}
}

type CurrentUserContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentUserContext {
	var p = new(CurrentUserContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentUserContext) GetName() antlr.Token { return s.name }

func (s *CurrentUserContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentUserContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_USER, 0)
}

func (s *CurrentUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCurrentUser(s)
	}
}

func (s *CurrentUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCurrentUser(s)
	}
}

type ConstantDefaultContext struct {
	PrimaryExpressionContext
}

func NewConstantDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstantDefaultContext {
	var p = new(ConstantDefaultContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ConstantDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantDefaultContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterConstantDefault(s)
	}
}

func (s *ConstantDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitConstantDefault(s)
	}
}

type ExtractContext struct {
	PrimaryExpressionContext
	field  IIdentifierContext
	source IValueExpressionContext
}

func NewExtractContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExtractContext {
	var p = new(ExtractContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ExtractContext) GetField() IIdentifierContext { return s.field }

func (s *ExtractContext) GetSource() IValueExpressionContext { return s.source }

func (s *ExtractContext) SetField(v IIdentifierContext) { s.field = v }

func (s *ExtractContext) SetSource(v IValueExpressionContext) { s.source = v }

func (s *ExtractContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(DorisParserEXTRACT, 0)
}

func (s *ExtractContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ExtractContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ExtractContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ExtractContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExtractContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ExtractContext) DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATE, 0)
}

func (s *ExtractContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserTIMESTAMP, 0)
}

func (s *ExtractContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterExtract(s)
	}
}

func (s *ExtractContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitExtract(s)
	}
}

type CurrentTimestampContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentTimestampContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentTimestampContext {
	var p = new(CurrentTimestampContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentTimestampContext) GetName() antlr.Token { return s.name }

func (s *CurrentTimestampContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentTimestampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentTimestampContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_TIMESTAMP, 0)
}

func (s *CurrentTimestampContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCurrentTimestamp(s)
	}
}

func (s *CurrentTimestampContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCurrentTimestamp(s)
	}
}

type FunctionCallContext struct {
	PrimaryExpressionContext
}

func NewFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallContext {
	var p = new(FunctionCallContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) FunctionCallExpression() IFunctionCallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallExpressionContext)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

type ArraySliceContext struct {
	PrimaryExpressionContext
	value IPrimaryExpressionContext
	begin IValueExpressionContext
	end   IValueExpressionContext
}

func NewArraySliceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArraySliceContext {
	var p = new(ArraySliceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArraySliceContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *ArraySliceContext) GetBegin() IValueExpressionContext { return s.begin }

func (s *ArraySliceContext) GetEnd() IValueExpressionContext { return s.end }

func (s *ArraySliceContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *ArraySliceContext) SetBegin(v IValueExpressionContext) { s.begin = v }

func (s *ArraySliceContext) SetEnd(v IValueExpressionContext) { s.end = v }

func (s *ArraySliceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArraySliceContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACKET, 0)
}

func (s *ArraySliceContext) COLON() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLON, 0)
}

func (s *ArraySliceContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACKET, 0)
}

func (s *ArraySliceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ArraySliceContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArraySliceContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArraySliceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterArraySlice(s)
	}
}

func (s *ArraySliceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitArraySlice(s)
	}
}

type SearchedCaseContext struct {
	PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSearchedCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SearchedCaseContext {
	var p = new(SearchedCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SearchedCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SearchedCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SearchedCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(DorisParserCASE, 0)
}

func (s *SearchedCaseContext) END() antlr.TerminalNode {
	return s.GetToken(DorisParserEND, 0)
}

func (s *SearchedCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SearchedCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SearchedCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(DorisParserELSE, 0)
}

func (s *SearchedCaseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SearchedCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSearchedCase(s)
	}
}

func (s *SearchedCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSearchedCase(s)
	}
}

func (p *DorisParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	return p.primaryExpression(0)
}

func (p *DorisParser) primaryExpression(_p int) (localctx IPrimaryExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 380
	p.EnterRecursionRule(localctx, 380, DorisParserRULE_primaryExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5690)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 822, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCurrentDateContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(5565)

			var _m = p.Match(DorisParserCURRENT_DATE)

			localctx.(*CurrentDateContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewCurrentTimeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5566)

			var _m = p.Match(DorisParserCURRENT_TIME)

			localctx.(*CurrentTimeContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewCurrentTimestampContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5567)

			var _m = p.Match(DorisParserCURRENT_TIMESTAMP)

			localctx.(*CurrentTimestampContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewLocalTimeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5568)

			var _m = p.Match(DorisParserLOCALTIME)

			localctx.(*LocalTimeContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewLocalTimestampContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5569)

			var _m = p.Match(DorisParserLOCALTIMESTAMP)

			localctx.(*LocalTimestampContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewCurrentUserContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5570)

			var _m = p.Match(DorisParserCURRENT_USER)

			localctx.(*CurrentUserContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewSessionUserContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5571)

			var _m = p.Match(DorisParserSESSION_USER)

			localctx.(*SessionUserContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewSearchedCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5572)
			p.Match(DorisParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5574)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == DorisParserWHEN {
			{
				p.SetState(5573)
				p.WhenClause()
			}

			p.SetState(5576)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5580)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserELSE {
			{
				p.SetState(5578)
				p.Match(DorisParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5579)

				var _x = p.Expression()

				localctx.(*SearchedCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(5582)
			p.Match(DorisParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewSimpleCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5584)
			p.Match(DorisParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5585)

			var _x = p.Expression()

			localctx.(*SimpleCaseContext).value = _x
		}
		p.SetState(5587)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == DorisParserWHEN {
			{
				p.SetState(5586)
				p.WhenClause()
			}

			p.SetState(5589)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5593)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserELSE {
			{
				p.SetState(5591)
				p.Match(DorisParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5592)

				var _x = p.Expression()

				localctx.(*SimpleCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(5595)
			p.Match(DorisParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5597)

			var _m = p.Match(DorisParserCAST)

			localctx.(*CastContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5598)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5599)
			p.Expression()
		}
		{
			p.SetState(5600)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5601)
			p.CastDataType()
		}
		{
			p.SetState(5602)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewConstantDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5604)
			p.Constant()
		}

	case 12:
		localctx = NewIntervalLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5605)
			p.Interval()
		}

	case 13:
		localctx = NewStarContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5606)
			p.Match(DorisParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5610)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 814, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(5607)
					p.ExceptOrReplace()
				}

			}
			p.SetState(5612)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 814, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 14:
		localctx = NewStarContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5613)
			p.QualifiedName()
		}
		{
			p.SetState(5614)
			p.Match(DorisParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5615)
			p.Match(DorisParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5619)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 815, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(5616)
					p.ExceptOrReplace()
				}

			}
			p.SetState(5621)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 815, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 15:
		localctx = NewCharFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5622)
			p.Match(DorisParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5623)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5624)

			var _x = p.Expression()

			localctx.(*CharFunctionContext)._expression = _x
		}
		localctx.(*CharFunctionContext).arguments = append(localctx.(*CharFunctionContext).arguments, localctx.(*CharFunctionContext)._expression)
		p.SetState(5629)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(5625)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5626)

				var _x = p.Expression()

				localctx.(*CharFunctionContext)._expression = _x
			}
			localctx.(*CharFunctionContext).arguments = append(localctx.(*CharFunctionContext).arguments, localctx.(*CharFunctionContext)._expression)

			p.SetState(5631)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5634)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserUSING {
			{
				p.SetState(5632)
				p.Match(DorisParserUSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5633)

				var _x = p.IdentifierOrText()

				localctx.(*CharFunctionContext).charSet = _x
			}

		}
		{
			p.SetState(5636)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		localctx = NewConvertCharSetContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5638)
			p.Match(DorisParserCONVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5639)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5640)

			var _x = p.Expression()

			localctx.(*ConvertCharSetContext).argument = _x
		}
		{
			p.SetState(5641)
			p.Match(DorisParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5642)

			var _x = p.IdentifierOrText()

			localctx.(*ConvertCharSetContext).charSet = _x
		}
		{
			p.SetState(5643)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		localctx = NewConvertTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5645)
			p.Match(DorisParserCONVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5646)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5647)

			var _x = p.Expression()

			localctx.(*ConvertTypeContext).argument = _x
		}
		{
			p.SetState(5648)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5649)
			p.CastDataType()
		}
		{
			p.SetState(5650)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5652)
			p.FunctionCallExpression()
		}

	case 19:
		localctx = NewSubqueryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5653)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5654)
			p.Query()
		}
		{
			p.SetState(5655)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		localctx = NewUserVariableContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5657)
			p.Match(DorisParserATSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5658)
			p.IdentifierOrText()
		}

	case 21:
		localctx = NewSystemVariableContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5659)
			p.Match(DorisParserDOUBLEATSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5662)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 818, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5660)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*SystemVariableContext).kind = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserGLOBAL || _la == DorisParserSESSION) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*SystemVariableContext).kind = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5661)
				p.Match(DorisParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5664)
			p.Identifier()
		}

	case 22:
		localctx = NewColumnReferenceContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(5666)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserBINARY {
			{
				p.SetState(5665)
				p.Match(DorisParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5668)
			p.Identifier()
		}

	case 23:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5669)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5670)
			p.Expression()
		}
		{
			p.SetState(5671)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		localctx = NewEncryptKeyContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5673)
			p.Match(DorisParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5677)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 820, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5674)

				var _x = p.Identifier()

				localctx.(*EncryptKeyContext).dbName = _x
			}
			{
				p.SetState(5675)
				p.Match(DorisParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5679)

			var _x = p.Identifier()

			localctx.(*EncryptKeyContext).keyName = _x
		}

	case 25:
		localctx = NewExtractContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5680)
			p.Match(DorisParserEXTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5681)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5682)

			var _x = p.Identifier()

			localctx.(*ExtractContext).field = _x
		}
		{
			p.SetState(5683)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5685)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 821, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5684)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserDATE || _la == DorisParserTIMESTAMP) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5687)

			var _x = p.valueExpression(0)

			localctx.(*ExtractContext).source = _x
		}
		{
			p.SetState(5688)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(5718)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 826, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(5716)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 825, p.GetParserRuleContext()) {
			case 1:
				localctx = NewElementAtContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*ElementAtContext).value = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_primaryExpression)
				p.SetState(5692)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
					goto errorExit
				}
				{
					p.SetState(5693)
					p.Match(DorisParserLEFT_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5694)

					var _x = p.valueExpression(0)

					localctx.(*ElementAtContext).index = _x
				}
				{
					p.SetState(5695)
					p.Match(DorisParserRIGHT_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				localctx = NewArraySliceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArraySliceContext).value = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_primaryExpression)
				p.SetState(5697)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
					goto errorExit
				}
				{
					p.SetState(5698)
					p.Match(DorisParserLEFT_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5699)

					var _x = p.valueExpression(0)

					localctx.(*ArraySliceContext).begin = _x
				}
				{
					p.SetState(5700)
					p.Match(DorisParserCOLON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(5702)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8646890354245592708) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6341351709356361985) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-6232419443415824845) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&9126402704879377875) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-2873940910708630541) != 0) || ((int64((_la-322)) & ^0x3f) == 0 && ((int64(1)<<(_la-322))&-2310602210946850817) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&-2627780018309275847) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&1405273167028914941) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&56383) != 0) {
					{
						p.SetState(5701)

						var _x = p.valueExpression(0)

						localctx.(*ArraySliceContext).end = _x
					}

				}
				{
					p.SetState(5704)
					p.Match(DorisParserRIGHT_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 3:
				localctx = NewDereferenceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*DereferenceContext).base = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_primaryExpression)
				p.SetState(5706)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(5707)
					p.Match(DorisParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5708)

					var _x = p.Identifier()

					localctx.(*DereferenceContext).fieldName = _x
				}

			case 4:
				localctx = NewCollateContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_primaryExpression)
				p.SetState(5709)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(5710)
					p.Match(DorisParserCOLLATE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(5714)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
					{
						p.SetState(5711)
						p.Identifier()
					}

				case DorisParserSTRING_LITERAL:
					{
						p.SetState(5712)
						p.Match(DorisParserSTRING_LITERAL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case DorisParserDEFAULT:
					{
						p.SetState(5713)
						p.Match(DorisParserDEFAULT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(5720)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 826, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExceptOrReplaceContext is an interface to support dynamic dispatch.
type IExceptOrReplaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExceptOrReplaceContext differentiates from other interfaces.
	IsExceptOrReplaceContext()
}

type ExceptOrReplaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExceptOrReplaceContext() *ExceptOrReplaceContext {
	var p = new(ExceptOrReplaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_exceptOrReplace
	return p
}

func InitEmptyExceptOrReplaceContext(p *ExceptOrReplaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_exceptOrReplace
}

func (*ExceptOrReplaceContext) IsExceptOrReplaceContext() {}

func NewExceptOrReplaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptOrReplaceContext {
	var p = new(ExceptOrReplaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_exceptOrReplace

	return p
}

func (s *ExceptOrReplaceContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptOrReplaceContext) CopyAll(ctx *ExceptOrReplaceContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExceptOrReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptOrReplaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ReplaceContext struct {
	ExceptOrReplaceContext
}

func NewReplaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReplaceContext {
	var p = new(ReplaceContext)

	InitEmptyExceptOrReplaceContext(&p.ExceptOrReplaceContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExceptOrReplaceContext))

	return p
}

func (s *ReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplaceContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *ReplaceContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ReplaceContext) NamedExpressionSeq() INamedExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionSeqContext)
}

func (s *ReplaceContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ReplaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterReplace(s)
	}
}

func (s *ReplaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitReplace(s)
	}
}

type ExceptContext struct {
	ExceptOrReplaceContext
}

func NewExceptContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExceptContext {
	var p = new(ExceptContext)

	InitEmptyExceptOrReplaceContext(&p.ExceptOrReplaceContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExceptOrReplaceContext))

	return p
}

func (s *ExceptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(DorisParserEXCEPT, 0)
}

func (s *ExceptContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ExceptContext) NamedExpressionSeq() INamedExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionSeqContext)
}

func (s *ExceptContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ExceptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterExcept(s)
	}
}

func (s *ExceptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitExcept(s)
	}
}

func (p *DorisParser) ExceptOrReplace() (localctx IExceptOrReplaceContext) {
	localctx = NewExceptOrReplaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, DorisParserRULE_exceptOrReplace)
	p.SetState(5731)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserEXCEPT:
		localctx = NewExceptContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5721)
			p.Match(DorisParserEXCEPT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5722)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5723)
			p.NamedExpressionSeq()
		}
		{
			p.SetState(5724)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserREPLACE:
		localctx = NewReplaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5726)
			p.Match(DorisParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5727)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5728)
			p.NamedExpressionSeq()
		}
		{
			p.SetState(5729)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastDataTypeContext is an interface to support dynamic dispatch.
type ICastDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DataType() IDataTypeContext
	SIGNED() antlr.TerminalNode
	UNSIGNED() antlr.TerminalNode
	INT() antlr.TerminalNode
	INTEGER() antlr.TerminalNode

	// IsCastDataTypeContext differentiates from other interfaces.
	IsCastDataTypeContext()
}

type CastDataTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastDataTypeContext() *CastDataTypeContext {
	var p = new(CastDataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_castDataType
	return p
}

func InitEmptyCastDataTypeContext(p *CastDataTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_castDataType
}

func (*CastDataTypeContext) IsCastDataTypeContext() {}

func NewCastDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastDataTypeContext {
	var p = new(CastDataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_castDataType

	return p
}

func (s *CastDataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CastDataTypeContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CastDataTypeContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(DorisParserSIGNED, 0)
}

func (s *CastDataTypeContext) UNSIGNED() antlr.TerminalNode {
	return s.GetToken(DorisParserUNSIGNED, 0)
}

func (s *CastDataTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(DorisParserINT, 0)
}

func (s *CastDataTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER, 0)
}

func (s *CastDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastDataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCastDataType(s)
	}
}

func (s *CastDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCastDataType(s)
	}
}

func (p *DorisParser) CastDataType() (localctx ICastDataTypeContext) {
	localctx = NewCastDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, DorisParserRULE_castDataType)
	var _la int

	p.SetState(5738)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserAGG_STATE, DorisParserALL, DorisParserARRAY, DorisParserBIGINT, DorisParserBITMAP, DorisParserBOOLEAN, DorisParserCHAR, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDOUBLE, DorisParserFLOAT, DorisParserHLL, DorisParserINT, DorisParserINTEGER, DorisParserIPV4, DorisParserIPV6, DorisParserJSON, DorisParserJSONB, DorisParserLARGEINT, DorisParserMAP, DorisParserQUANTILE_STATE, DorisParserSMALLINT, DorisParserSTRING, DorisParserSTRUCT, DorisParserTEXT, DorisParserTIME, DorisParserTINYINT, DorisParserVARCHAR, DorisParserVARIANT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5733)
			p.DataType()
		}

	case DorisParserSIGNED, DorisParserUNSIGNED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5734)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserSIGNED || _la == DorisParserUNSIGNED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(5736)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserINT || _la == DorisParserINTEGER {
			{
				p.SetState(5735)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserINT || _la == DorisParserINTEGER) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallExpressionContext is an interface to support dynamic dispatch.
type IFunctionCallExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetArguments returns the arguments rule context list.
	GetArguments() []IExpressionContext

	// SetArguments sets the arguments rule context list.
	SetArguments([]IExpressionContext)

	// Getter signatures
	FunctionIdentifier() IFunctionIdentifierContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	OVER() antlr.TerminalNode
	WindowSpec() IWindowSpecContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	DISTINCT() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsFunctionCallExpressionContext differentiates from other interfaces.
	IsFunctionCallExpressionContext()
}

type FunctionCallExpressionContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	_expression IExpressionContext
	arguments   []IExpressionContext
}

func NewEmptyFunctionCallExpressionContext() *FunctionCallExpressionContext {
	var p = new(FunctionCallExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionCallExpression
	return p
}

func InitEmptyFunctionCallExpressionContext(p *FunctionCallExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionCallExpression
}

func (*FunctionCallExpressionContext) IsFunctionCallExpressionContext() {}

func NewFunctionCallExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallExpressionContext {
	var p = new(FunctionCallExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_functionCallExpression

	return p
}

func (s *FunctionCallExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallExpressionContext) Get_expression() IExpressionContext { return s._expression }

func (s *FunctionCallExpressionContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *FunctionCallExpressionContext) GetArguments() []IExpressionContext { return s.arguments }

func (s *FunctionCallExpressionContext) SetArguments(v []IExpressionContext) { s.arguments = v }

func (s *FunctionCallExpressionContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *FunctionCallExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *FunctionCallExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *FunctionCallExpressionContext) OVER() antlr.TerminalNode {
	return s.GetToken(DorisParserOVER, 0)
}

func (s *FunctionCallExpressionContext) WindowSpec() IWindowSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecContext)
}

func (s *FunctionCallExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *FunctionCallExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionCallExpressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *FunctionCallExpressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *FunctionCallExpressionContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisParserORDER, 0)
}

func (s *FunctionCallExpressionContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *FunctionCallExpressionContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *FunctionCallExpressionContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *FunctionCallExpressionContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTINCT, 0)
}

func (s *FunctionCallExpressionContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *FunctionCallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFunctionCallExpression(s)
	}
}

func (s *FunctionCallExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFunctionCallExpression(s)
	}
}

func (p *DorisParser) FunctionCallExpression() (localctx IFunctionCallExpressionContext) {
	localctx = NewFunctionCallExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, DorisParserRULE_functionCallExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5740)
		p.FunctionIdentifier()
	}
	{
		p.SetState(5741)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5765)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8646890354246641284) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6341351709356361985) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-6232419426235955653) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&9126402704879377875) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-2873932114615608333) != 0) || ((int64((_la-322)) & ^0x3f) == 0 && ((int64(1)<<(_la-322))&-2310602210946850817) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&-2627780018309275847) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&-7818098869825860867) != 0) || ((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&56383) != 0) {
		p.SetState(5743)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserALL || _la == DorisParserDISTINCT {
			{
				p.SetState(5742)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserALL || _la == DorisParserDISTINCT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(5745)

			var _x = p.Expression()

			localctx.(*FunctionCallExpressionContext)._expression = _x
		}
		localctx.(*FunctionCallExpressionContext).arguments = append(localctx.(*FunctionCallExpressionContext).arguments, localctx.(*FunctionCallExpressionContext)._expression)
		p.SetState(5750)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(5746)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5747)

				var _x = p.Expression()

				localctx.(*FunctionCallExpressionContext)._expression = _x
			}
			localctx.(*FunctionCallExpressionContext).arguments = append(localctx.(*FunctionCallExpressionContext).arguments, localctx.(*FunctionCallExpressionContext)._expression)

			p.SetState(5752)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5763)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserORDER {
			{
				p.SetState(5753)
				p.Match(DorisParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5754)
				p.Match(DorisParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5755)
				p.SortItem()
			}
			p.SetState(5760)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(5756)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5757)
					p.SortItem()
				}

				p.SetState(5762)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}

	}
	{
		p.SetState(5767)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5770)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 835, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5768)
			p.Match(DorisParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5769)
			p.WindowSpec()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionIdentifierContext is an interface to support dynamic dispatch.
type IFunctionIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDbName returns the dbName rule contexts.
	GetDbName() IIdentifierContext

	// SetDbName sets the dbName rule contexts.
	SetDbName(IIdentifierContext)

	// Getter signatures
	FunctionNameIdentifier() IFunctionNameIdentifierContext
	DOT() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsFunctionIdentifierContext differentiates from other interfaces.
	IsFunctionIdentifierContext()
}

type FunctionIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	dbName IIdentifierContext
}

func NewEmptyFunctionIdentifierContext() *FunctionIdentifierContext {
	var p = new(FunctionIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionIdentifier
	return p
}

func InitEmptyFunctionIdentifierContext(p *FunctionIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionIdentifier
}

func (*FunctionIdentifierContext) IsFunctionIdentifierContext() {}

func NewFunctionIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionIdentifierContext {
	var p = new(FunctionIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_functionIdentifier

	return p
}

func (s *FunctionIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionIdentifierContext) GetDbName() IIdentifierContext { return s.dbName }

func (s *FunctionIdentifierContext) SetDbName(v IIdentifierContext) { s.dbName = v }

func (s *FunctionIdentifierContext) FunctionNameIdentifier() IFunctionNameIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameIdentifierContext)
}

func (s *FunctionIdentifierContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *FunctionIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFunctionIdentifier(s)
	}
}

func (s *FunctionIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFunctionIdentifier(s)
	}
}

func (p *DorisParser) FunctionIdentifier() (localctx IFunctionIdentifierContext) {
	localctx = NewFunctionIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, DorisParserRULE_functionIdentifier)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(5775)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 836, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5772)

			var _x = p.Identifier()

			localctx.(*FunctionIdentifierContext).dbName = _x
		}
		{
			p.SetState(5773)
			p.Match(DorisParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(5777)
		p.FunctionNameIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionNameIdentifierContext is an interface to support dynamic dispatch.
type IFunctionNameIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ADD() antlr.TerminalNode
	CONNECTION_ID() antlr.TerminalNode
	CURRENT_CATALOG() antlr.TerminalNode
	CURRENT_USER() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	IF() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	REGEXP() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	SESSION_USER() antlr.TerminalNode
	TRIM() antlr.TerminalNode
	USER() antlr.TerminalNode

	// IsFunctionNameIdentifierContext differentiates from other interfaces.
	IsFunctionNameIdentifierContext()
}

type FunctionNameIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameIdentifierContext() *FunctionNameIdentifierContext {
	var p = new(FunctionNameIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionNameIdentifier
	return p
}

func InitEmptyFunctionNameIdentifierContext(p *FunctionNameIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionNameIdentifier
}

func (*FunctionNameIdentifierContext) IsFunctionNameIdentifierContext() {}

func NewFunctionNameIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameIdentifierContext {
	var p = new(FunctionNameIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_functionNameIdentifier

	return p
}

func (s *FunctionNameIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionNameIdentifierContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *FunctionNameIdentifierContext) CONNECTION_ID() antlr.TerminalNode {
	return s.GetToken(DorisParserCONNECTION_ID, 0)
}

func (s *FunctionNameIdentifierContext) CURRENT_CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_CATALOG, 0)
}

func (s *FunctionNameIdentifierContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_USER, 0)
}

func (s *FunctionNameIdentifierContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *FunctionNameIdentifierContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *FunctionNameIdentifierContext) LEFT() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT, 0)
}

func (s *FunctionNameIdentifierContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *FunctionNameIdentifierContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD, 0)
}

func (s *FunctionNameIdentifierContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(DorisParserREGEXP, 0)
}

func (s *FunctionNameIdentifierContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT, 0)
}

func (s *FunctionNameIdentifierContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEMA, 0)
}

func (s *FunctionNameIdentifierContext) SESSION_USER() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION_USER, 0)
}

func (s *FunctionNameIdentifierContext) TRIM() antlr.TerminalNode {
	return s.GetToken(DorisParserTRIM, 0)
}

func (s *FunctionNameIdentifierContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisParserUSER, 0)
}

func (s *FunctionNameIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFunctionNameIdentifier(s)
	}
}

func (s *FunctionNameIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFunctionNameIdentifier(s)
	}
}

func (p *DorisParser) FunctionNameIdentifier() (localctx IFunctionNameIdentifierContext) {
	localctx = NewFunctionNameIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, DorisParserRULE_functionNameIdentifier)
	p.SetState(5795)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 837, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5779)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5780)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5781)
			p.Match(DorisParserCONNECTION_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5782)
			p.Match(DorisParserCURRENT_CATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5783)
			p.Match(DorisParserCURRENT_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5784)
			p.Match(DorisParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5785)
			p.Match(DorisParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5786)
			p.Match(DorisParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5787)
			p.Match(DorisParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5788)
			p.Match(DorisParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5789)
			p.Match(DorisParserREGEXP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5790)
			p.Match(DorisParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5791)
			p.Match(DorisParserSCHEMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5792)
			p.Match(DorisParserSESSION_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(5793)
			p.Match(DorisParserTRIM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(5794)
			p.Match(DorisParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowSpecContext is an interface to support dynamic dispatch.
type IWindowSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	PartitionClause() IPartitionClauseContext
	SortClause() ISortClauseContext
	WindowFrame() IWindowFrameContext

	// IsWindowSpecContext differentiates from other interfaces.
	IsWindowSpecContext()
}

type WindowSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowSpecContext() *WindowSpecContext {
	var p = new(WindowSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_windowSpec
	return p
}

func InitEmptyWindowSpecContext(p *WindowSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_windowSpec
}

func (*WindowSpecContext) IsWindowSpecContext() {}

func NewWindowSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowSpecContext {
	var p = new(WindowSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_windowSpec

	return p
}

func (s *WindowSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowSpecContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *WindowSpecContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *WindowSpecContext) PartitionClause() IPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *WindowSpecContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *WindowSpecContext) WindowFrame() IWindowFrameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameContext)
}

func (s *WindowSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWindowSpec(s)
	}
}

func (s *WindowSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWindowSpec(s)
	}
}

func (p *DorisParser) WindowSpec() (localctx IWindowSpecContext) {
	localctx = NewWindowSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, DorisParserRULE_windowSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5797)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5799)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPARTITION {
		{
			p.SetState(5798)
			p.PartitionClause()
		}

	}
	p.SetState(5802)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserORDER {
		{
			p.SetState(5801)
			p.SortClause()
		}

	}
	p.SetState(5805)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserRANGE || _la == DorisParserROWS {
		{
			p.SetState(5804)
			p.WindowFrame()
		}

	}
	{
		p.SetState(5807)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameContext is an interface to support dynamic dispatch.
type IWindowFrameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStart_ returns the start_ rule contexts.
	GetStart_() IFrameBoundaryContext

	// GetEnd returns the end rule contexts.
	GetEnd() IFrameBoundaryContext

	// SetStart_ sets the start_ rule contexts.
	SetStart_(IFrameBoundaryContext)

	// SetEnd sets the end rule contexts.
	SetEnd(IFrameBoundaryContext)

	// Getter signatures
	FrameUnits() IFrameUnitsContext
	AllFrameBoundary() []IFrameBoundaryContext
	FrameBoundary(i int) IFrameBoundaryContext
	BETWEEN() antlr.TerminalNode
	AND() antlr.TerminalNode

	// IsWindowFrameContext differentiates from other interfaces.
	IsWindowFrameContext()
}

type WindowFrameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	start_ IFrameBoundaryContext
	end    IFrameBoundaryContext
}

func NewEmptyWindowFrameContext() *WindowFrameContext {
	var p = new(WindowFrameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_windowFrame
	return p
}

func InitEmptyWindowFrameContext(p *WindowFrameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_windowFrame
}

func (*WindowFrameContext) IsWindowFrameContext() {}

func NewWindowFrameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameContext {
	var p = new(WindowFrameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_windowFrame

	return p
}

func (s *WindowFrameContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameContext) GetStart_() IFrameBoundaryContext { return s.start_ }

func (s *WindowFrameContext) GetEnd() IFrameBoundaryContext { return s.end }

func (s *WindowFrameContext) SetStart_(v IFrameBoundaryContext) { s.start_ = v }

func (s *WindowFrameContext) SetEnd(v IFrameBoundaryContext) { s.end = v }

func (s *WindowFrameContext) FrameUnits() IFrameUnitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameUnitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameUnitsContext)
}

func (s *WindowFrameContext) AllFrameBoundary() []IFrameBoundaryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrameBoundaryContext); ok {
			len++
		}
	}

	tst := make([]IFrameBoundaryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrameBoundaryContext); ok {
			tst[i] = t.(IFrameBoundaryContext)
			i++
		}
	}

	return tst
}

func (s *WindowFrameContext) FrameBoundary(i int) IFrameBoundaryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameBoundaryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameBoundaryContext)
}

func (s *WindowFrameContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(DorisParserBETWEEN, 0)
}

func (s *WindowFrameContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisParserAND, 0)
}

func (s *WindowFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWindowFrame(s)
	}
}

func (s *WindowFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWindowFrame(s)
	}
}

func (p *DorisParser) WindowFrame() (localctx IWindowFrameContext) {
	localctx = NewWindowFrameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, DorisParserRULE_windowFrame)
	p.SetState(5818)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 841, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5809)
			p.FrameUnits()
		}
		{
			p.SetState(5810)

			var _x = p.FrameBoundary()

			localctx.(*WindowFrameContext).start_ = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5812)
			p.FrameUnits()
		}
		{
			p.SetState(5813)
			p.Match(DorisParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5814)

			var _x = p.FrameBoundary()

			localctx.(*WindowFrameContext).start_ = _x
		}
		{
			p.SetState(5815)
			p.Match(DorisParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5816)

			var _x = p.FrameBoundary()

			localctx.(*WindowFrameContext).end = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameUnitsContext is an interface to support dynamic dispatch.
type IFrameUnitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROWS() antlr.TerminalNode
	RANGE() antlr.TerminalNode

	// IsFrameUnitsContext differentiates from other interfaces.
	IsFrameUnitsContext()
}

type FrameUnitsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameUnitsContext() *FrameUnitsContext {
	var p = new(FrameUnitsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_frameUnits
	return p
}

func InitEmptyFrameUnitsContext(p *FrameUnitsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_frameUnits
}

func (*FrameUnitsContext) IsFrameUnitsContext() {}

func NewFrameUnitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameUnitsContext {
	var p = new(FrameUnitsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_frameUnits

	return p
}

func (s *FrameUnitsContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameUnitsContext) ROWS() antlr.TerminalNode {
	return s.GetToken(DorisParserROWS, 0)
}

func (s *FrameUnitsContext) RANGE() antlr.TerminalNode {
	return s.GetToken(DorisParserRANGE, 0)
}

func (s *FrameUnitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameUnitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameUnitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFrameUnits(s)
	}
}

func (s *FrameUnitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFrameUnits(s)
	}
}

func (p *DorisParser) FrameUnits() (localctx IFrameUnitsContext) {
	localctx = NewFrameUnitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, DorisParserRULE_frameUnits)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5820)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserRANGE || _la == DorisParserROWS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameBoundaryContext is an interface to support dynamic dispatch.
type IFrameBoundaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBoundType returns the boundType token.
	GetBoundType() antlr.Token

	// SetBoundType sets the boundType token.
	SetBoundType(antlr.Token)

	// Getter signatures
	UNBOUNDED() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	ROW() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	Expression() IExpressionContext

	// IsFrameBoundaryContext differentiates from other interfaces.
	IsFrameBoundaryContext()
}

type FrameBoundaryContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	boundType antlr.Token
}

func NewEmptyFrameBoundaryContext() *FrameBoundaryContext {
	var p = new(FrameBoundaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_frameBoundary
	return p
}

func InitEmptyFrameBoundaryContext(p *FrameBoundaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_frameBoundary
}

func (*FrameBoundaryContext) IsFrameBoundaryContext() {}

func NewFrameBoundaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameBoundaryContext {
	var p = new(FrameBoundaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_frameBoundary

	return p
}

func (s *FrameBoundaryContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameBoundaryContext) GetBoundType() antlr.Token { return s.boundType }

func (s *FrameBoundaryContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *FrameBoundaryContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(DorisParserUNBOUNDED, 0)
}

func (s *FrameBoundaryContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(DorisParserPRECEDING, 0)
}

func (s *FrameBoundaryContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(DorisParserFOLLOWING, 0)
}

func (s *FrameBoundaryContext) ROW() antlr.TerminalNode {
	return s.GetToken(DorisParserROW, 0)
}

func (s *FrameBoundaryContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT, 0)
}

func (s *FrameBoundaryContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FrameBoundaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameBoundaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameBoundaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFrameBoundary(s)
	}
}

func (s *FrameBoundaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFrameBoundary(s)
	}
}

func (p *DorisParser) FrameBoundary() (localctx IFrameBoundaryContext) {
	localctx = NewFrameBoundaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, DorisParserRULE_frameBoundary)
	var _la int

	p.SetState(5829)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserUNBOUNDED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5822)
			p.Match(DorisParserUNBOUNDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5823)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FrameBoundaryContext).boundType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserFOLLOWING || _la == DorisParserPRECEDING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FrameBoundaryContext).boundType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case DorisParserCURRENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5824)

			var _m = p.Match(DorisParserCURRENT)

			localctx.(*FrameBoundaryContext).boundType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5825)
			p.Match(DorisParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserLEFT_PAREN, DorisParserLEFT_BRACKET, DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADD, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBINARY, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCASE, DorisParserCAST, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATABASE, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXISTS, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserEXTRACT, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFALSE, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIF, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINTERVAL, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserKEY, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLEFT, DorisParserLESS, DorisParserLEVEL, DorisParserLIKE, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNOT, DorisParserNULL, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLACEHOLDER, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREGEXP, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRIGHT, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRIM, DorisParserTRUE, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserPLUS, DorisParserSUBTRACT, DorisParserASTERISK, DorisParserTILDE, DorisParserLOGICALNOT, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserATSIGN, DorisParserDOUBLEATSIGN, DorisParserSTRING_LITERAL, DorisParserINTEGER_VALUE, DorisParserEXPONENT_VALUE, DorisParserDECIMAL_VALUE, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5826)
			p.Expression()
		}
		{
			p.SetState(5827)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FrameBoundaryContext).boundType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserFOLLOWING || _la == DorisParserPRECEDING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FrameBoundaryContext).boundType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_qualifiedName
	return p
}

func InitEmptyQualifiedNameContext(p *QualifiedNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_qualifiedName
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(DorisParserDOT)
}

func (s *QualifiedNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, i)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterQualifiedName(s)
	}
}

func (s *QualifiedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitQualifiedName(s)
	}
}

func (p *DorisParser) QualifiedName() (localctx IQualifiedNameContext) {
	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, DorisParserRULE_qualifiedName)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5831)
		p.Identifier()
	}
	p.SetState(5836)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 843, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5832)
				p.Match(DorisParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5833)
				p.Identifier()
			}

		}
		p.SetState(5838)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 843, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpecifiedPartitionContext is an interface to support dynamic dispatch.
type ISpecifiedPartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	IdentifierList() IIdentifierListContext
	TEMPORARY() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode

	// IsSpecifiedPartitionContext differentiates from other interfaces.
	IsSpecifiedPartitionContext()
}

type SpecifiedPartitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecifiedPartitionContext() *SpecifiedPartitionContext {
	var p = new(SpecifiedPartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_specifiedPartition
	return p
}

func InitEmptySpecifiedPartitionContext(p *SpecifiedPartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_specifiedPartition
}

func (*SpecifiedPartitionContext) IsSpecifiedPartitionContext() {}

func NewSpecifiedPartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecifiedPartitionContext {
	var p = new(SpecifiedPartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_specifiedPartition

	return p
}

func (s *SpecifiedPartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecifiedPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *SpecifiedPartitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SpecifiedPartitionContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *SpecifiedPartitionContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *SpecifiedPartitionContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITIONS, 0)
}

func (s *SpecifiedPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecifiedPartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecifiedPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSpecifiedPartition(s)
	}
}

func (s *SpecifiedPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSpecifiedPartition(s)
	}
}

func (p *DorisParser) SpecifiedPartition() (localctx ISpecifiedPartitionContext) {
	localctx = NewSpecifiedPartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, DorisParserRULE_specifiedPartition)
	var _la int

	p.SetState(5852)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 847, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5840)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(5839)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5842)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5845)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(5843)
				p.Identifier()
			}

		case DorisParserLEFT_PAREN:
			{
				p.SetState(5844)
				p.IdentifierList()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5848)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(5847)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5850)
			p.Match(DorisParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5851)
			p.IdentifierList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_constant
	return p
}

func InitEmptyConstantContext(p *ConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_constant
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) CopyAll(ctx *ConstantContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StructLiteralContext struct {
	ConstantContext
	_constant IConstantContext
	items     []IConstantContext
}

func NewStructLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StructLiteralContext {
	var p = new(StructLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *StructLiteralContext) Get_constant() IConstantContext { return s._constant }

func (s *StructLiteralContext) Set_constant(v IConstantContext) { s._constant = v }

func (s *StructLiteralContext) GetItems() []IConstantContext { return s.items }

func (s *StructLiteralContext) SetItems(v []IConstantContext) { s.items = v }

func (s *StructLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructLiteralContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACE, 0)
}

func (s *StructLiteralContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACE, 0)
}

func (s *StructLiteralContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *StructLiteralContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *StructLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *StructLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *StructLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStructLiteral(s)
	}
}

func (s *StructLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStructLiteral(s)
	}
}

type NullLiteralContext struct {
	ConstantContext
}

func NewNullLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralContext {
	var p = new(NullLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisParserNULL, 0)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

type StringLiteralContext struct {
	ConstantContext
}

func NewStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralContext {
	var p = new(StringLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *StringLiteralContext) BINARY() antlr.TerminalNode {
	return s.GetToken(DorisParserBINARY, 0)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

type TypeConstructorContext struct {
	ConstantContext
	type_ antlr.Token
}

func NewTypeConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeConstructorContext {
	var p = new(TypeConstructorContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *TypeConstructorContext) GetType_() antlr.Token { return s.type_ }

func (s *TypeConstructorContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *TypeConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConstructorContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *TypeConstructorContext) DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATE, 0)
}

func (s *TypeConstructorContext) DATEV1() antlr.TerminalNode {
	return s.GetToken(DorisParserDATEV1, 0)
}

func (s *TypeConstructorContext) DATEV2() antlr.TerminalNode {
	return s.GetToken(DorisParserDATEV2, 0)
}

func (s *TypeConstructorContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserTIMESTAMP, 0)
}

func (s *TypeConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTypeConstructor(s)
	}
}

func (s *TypeConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTypeConstructor(s)
	}
}

type ArrayLiteralContext struct {
	ConstantContext
	_constant IConstantContext
	items     []IConstantContext
}

func NewArrayLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *ArrayLiteralContext) Get_constant() IConstantContext { return s._constant }

func (s *ArrayLiteralContext) Set_constant(v IConstantContext) { s._constant = v }

func (s *ArrayLiteralContext) GetItems() []IConstantContext { return s.items }

func (s *ArrayLiteralContext) SetItems(v []IConstantContext) { s.items = v }

func (s *ArrayLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACKET, 0)
}

func (s *ArrayLiteralContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACKET, 0)
}

func (s *ArrayLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ArrayLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ArrayLiteralContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *ArrayLiteralContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ArrayLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitArrayLiteral(s)
	}
}

type PlaceholderContext struct {
	ConstantContext
}

func NewPlaceholderContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PlaceholderContext {
	var p = new(PlaceholderContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *PlaceholderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PlaceholderContext) PLACEHOLDER() antlr.TerminalNode {
	return s.GetToken(DorisParserPLACEHOLDER, 0)
}

func (s *PlaceholderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPlaceholder(s)
	}
}

func (s *PlaceholderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPlaceholder(s)
	}
}

type MapLiteralContext struct {
	ConstantContext
	_constant IConstantContext
	items     []IConstantContext
}

func NewMapLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MapLiteralContext {
	var p = new(MapLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *MapLiteralContext) Get_constant() IConstantContext { return s._constant }

func (s *MapLiteralContext) Set_constant(v IConstantContext) { s._constant = v }

func (s *MapLiteralContext) GetItems() []IConstantContext { return s.items }

func (s *MapLiteralContext) SetItems(v []IConstantContext) { s.items = v }

func (s *MapLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapLiteralContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACE, 0)
}

func (s *MapLiteralContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACE, 0)
}

func (s *MapLiteralContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOLON)
}

func (s *MapLiteralContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOLON, i)
}

func (s *MapLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *MapLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *MapLiteralContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *MapLiteralContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *MapLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMapLiteral(s)
	}
}

func (s *MapLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMapLiteral(s)
	}
}

type NumericLiteralContext struct {
	ConstantContext
}

func NewNumericLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

type BooleanLiteralContext struct {
	ConstantContext
}

func NewBooleanLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) BooleanValue() IBooleanValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (p *DorisParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, DorisParserRULE_constant)
	var _la int

	p.SetState(5905)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 854, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNullLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5854)
			p.Match(DorisParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewTypeConstructorContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5855)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TypeConstructorContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-113)) & ^0x3f) == 0 && ((int64(1)<<(_la-113))&41) != 0) || _la == DorisParserTIMESTAMP) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TypeConstructorContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5856)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewNumericLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5857)
			p.Number()
		}

	case 4:
		localctx = NewBooleanLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5858)
			p.BooleanValue()
		}

	case 5:
		localctx = NewStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(5860)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserBINARY {
			{
				p.SetState(5859)
				p.Match(DorisParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5862)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewArrayLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5863)
			p.Match(DorisParserLEFT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5865)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8796093022848) != 0) || ((int64((_la-113)) & ^0x3f) == 0 && ((int64(1)<<(_la-113))&576460752303423529) != 0) || _la == DorisParserNULL || _la == DorisParserPLACEHOLDER || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&576460752303423745) != 0) || ((int64((_la-526)) & ^0x3f) == 0 && ((int64(1)<<(_la-526))&225) != 0) {
			{
				p.SetState(5864)

				var _x = p.Constant()

				localctx.(*ArrayLiteralContext)._constant = _x
			}
			localctx.(*ArrayLiteralContext).items = append(localctx.(*ArrayLiteralContext).items, localctx.(*ArrayLiteralContext)._constant)

		}
		p.SetState(5871)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(5867)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5868)

				var _x = p.Constant()

				localctx.(*ArrayLiteralContext)._constant = _x
			}
			localctx.(*ArrayLiteralContext).items = append(localctx.(*ArrayLiteralContext).items, localctx.(*ArrayLiteralContext)._constant)

			p.SetState(5873)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5874)
			p.Match(DorisParserRIGHT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewMapLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5875)
			p.Match(DorisParserLEFT_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5880)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8796093022848) != 0) || ((int64((_la-113)) & ^0x3f) == 0 && ((int64(1)<<(_la-113))&576460752303423529) != 0) || _la == DorisParserNULL || _la == DorisParserPLACEHOLDER || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&576460752303423745) != 0) || ((int64((_la-526)) & ^0x3f) == 0 && ((int64(1)<<(_la-526))&225) != 0) {
			{
				p.SetState(5876)

				var _x = p.Constant()

				localctx.(*MapLiteralContext)._constant = _x
			}
			localctx.(*MapLiteralContext).items = append(localctx.(*MapLiteralContext).items, localctx.(*MapLiteralContext)._constant)
			{
				p.SetState(5877)
				p.Match(DorisParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5878)

				var _x = p.Constant()

				localctx.(*MapLiteralContext)._constant = _x
			}
			localctx.(*MapLiteralContext).items = append(localctx.(*MapLiteralContext).items, localctx.(*MapLiteralContext)._constant)

		}
		p.SetState(5889)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(5882)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5883)

				var _x = p.Constant()

				localctx.(*MapLiteralContext)._constant = _x
			}
			localctx.(*MapLiteralContext).items = append(localctx.(*MapLiteralContext).items, localctx.(*MapLiteralContext)._constant)
			{
				p.SetState(5884)
				p.Match(DorisParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5885)

				var _x = p.Constant()

				localctx.(*MapLiteralContext)._constant = _x
			}
			localctx.(*MapLiteralContext).items = append(localctx.(*MapLiteralContext).items, localctx.(*MapLiteralContext)._constant)

			p.SetState(5891)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5892)
			p.Match(DorisParserRIGHT_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewStructLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5893)
			p.Match(DorisParserLEFT_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5894)

			var _x = p.Constant()

			localctx.(*StructLiteralContext)._constant = _x
		}
		localctx.(*StructLiteralContext).items = append(localctx.(*StructLiteralContext).items, localctx.(*StructLiteralContext)._constant)
		p.SetState(5899)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(5895)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5896)

				var _x = p.Constant()

				localctx.(*StructLiteralContext)._constant = _x
			}
			localctx.(*StructLiteralContext).items = append(localctx.(*StructLiteralContext).items, localctx.(*StructLiteralContext)._constant)

			p.SetState(5901)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5902)
			p.Match(DorisParserRIGHT_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewPlaceholderContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5904)
			p.Match(DorisParserPLACEHOLDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQ() antlr.TerminalNode
	NEQ() antlr.TerminalNode
	LT() antlr.TerminalNode
	LTE() antlr.TerminalNode
	GT() antlr.TerminalNode
	GTE() antlr.TerminalNode
	NSEQ() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_comparisonOperator
	return p
}

func InitEmptyComparisonOperatorContext(p *ComparisonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_comparisonOperator
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *ComparisonOperatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(DorisParserNEQ, 0)
}

func (s *ComparisonOperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(DorisParserLT, 0)
}

func (s *ComparisonOperatorContext) LTE() antlr.TerminalNode {
	return s.GetToken(DorisParserLTE, 0)
}

func (s *ComparisonOperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(DorisParserGT, 0)
}

func (s *ComparisonOperatorContext) GTE() antlr.TerminalNode {
	return s.GetToken(DorisParserGTE, 0)
}

func (s *ComparisonOperatorContext) NSEQ() antlr.TerminalNode {
	return s.GetToken(DorisParserNSEQ, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (p *DorisParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, DorisParserRULE_comparisonOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5907)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-500)) & ^0x3f) == 0 && ((int64(1)<<(_la-500))&127) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanValueContext is an interface to support dynamic dispatch.
type IBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBooleanValueContext differentiates from other interfaces.
	IsBooleanValueContext()
}

type BooleanValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueContext() *BooleanValueContext {
	var p = new(BooleanValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_booleanValue
	return p
}

func InitEmptyBooleanValueContext(p *BooleanValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_booleanValue
}

func (*BooleanValueContext) IsBooleanValueContext() {}

func NewBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueContext {
	var p = new(BooleanValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_booleanValue

	return p
}

func (s *BooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(DorisParserTRUE, 0)
}

func (s *BooleanValueContext) FALSE() antlr.TerminalNode {
	return s.GetToken(DorisParserFALSE, 0)
}

func (s *BooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBooleanValue(s)
	}
}

func (s *BooleanValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBooleanValue(s)
	}
}

func (p *DorisParser) BooleanValue() (localctx IBooleanValueContext) {
	localctx = NewBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, DorisParserRULE_booleanValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5909)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserFALSE || _la == DorisParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetResult returns the result rule contexts.
	GetResult() IExpressionContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetResult sets the result rule contexts.
	SetResult(IExpressionContext)

	// Getter signatures
	WHEN() antlr.TerminalNode
	THEN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExpressionContext
	result    IExpressionContext
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_whenClause
	return p
}

func InitEmptyWhenClauseContext(p *WhenClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_whenClause
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) GetCondition() IExpressionContext { return s.condition }

func (s *WhenClauseContext) GetResult() IExpressionContext { return s.result }

func (s *WhenClauseContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *WhenClauseContext) SetResult(v IExpressionContext) { s.result = v }

func (s *WhenClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(DorisParserWHEN, 0)
}

func (s *WhenClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(DorisParserTHEN, 0)
}

func (s *WhenClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WhenClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWhenClause(s)
	}
}

func (s *WhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWhenClause(s)
	}
}

func (p *DorisParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, DorisParserRULE_whenClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5911)
		p.Match(DorisParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5912)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).condition = _x
	}
	{
		p.SetState(5913)
		p.Match(DorisParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5914)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).result = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalContext is an interface to support dynamic dispatch.
type IIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value rule contexts.
	GetValue() IExpressionContext

	// GetUnit returns the unit rule contexts.
	GetUnit() IUnitIdentifierContext

	// SetValue sets the value rule contexts.
	SetValue(IExpressionContext)

	// SetUnit sets the unit rule contexts.
	SetUnit(IUnitIdentifierContext)

	// Getter signatures
	INTERVAL() antlr.TerminalNode
	Expression() IExpressionContext
	UnitIdentifier() IUnitIdentifierContext

	// IsIntervalContext differentiates from other interfaces.
	IsIntervalContext()
}

type IntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  IExpressionContext
	unit   IUnitIdentifierContext
}

func NewEmptyIntervalContext() *IntervalContext {
	var p = new(IntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_interval
	return p
}

func InitEmptyIntervalContext(p *IntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_interval
}

func (*IntervalContext) IsIntervalContext() {}

func NewIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalContext {
	var p = new(IntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_interval

	return p
}

func (s *IntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalContext) GetValue() IExpressionContext { return s.value }

func (s *IntervalContext) GetUnit() IUnitIdentifierContext { return s.unit }

func (s *IntervalContext) SetValue(v IExpressionContext) { s.value = v }

func (s *IntervalContext) SetUnit(v IUnitIdentifierContext) { s.unit = v }

func (s *IntervalContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DorisParserINTERVAL, 0)
}

func (s *IntervalContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalContext) UnitIdentifier() IUnitIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitIdentifierContext)
}

func (s *IntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterInterval(s)
	}
}

func (s *IntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitInterval(s)
	}
}

func (p *DorisParser) Interval() (localctx IIntervalContext) {
	localctx = NewIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, DorisParserRULE_interval)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5916)
		p.Match(DorisParserINTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5917)

		var _x = p.Expression()

		localctx.(*IntervalContext).value = _x
	}
	{
		p.SetState(5918)

		var _x = p.UnitIdentifier()

		localctx.(*IntervalContext).unit = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitIdentifierContext is an interface to support dynamic dispatch.
type IUnitIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YEAR() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	SECOND() antlr.TerminalNode

	// IsUnitIdentifierContext differentiates from other interfaces.
	IsUnitIdentifierContext()
}

type UnitIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitIdentifierContext() *UnitIdentifierContext {
	var p = new(UnitIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unitIdentifier
	return p
}

func InitEmptyUnitIdentifierContext(p *UnitIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unitIdentifier
}

func (*UnitIdentifierContext) IsUnitIdentifierContext() {}

func NewUnitIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitIdentifierContext {
	var p = new(UnitIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unitIdentifier

	return p
}

func (s *UnitIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitIdentifierContext) YEAR() antlr.TerminalNode {
	return s.GetToken(DorisParserYEAR, 0)
}

func (s *UnitIdentifierContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(DorisParserQUARTER, 0)
}

func (s *UnitIdentifierContext) MONTH() antlr.TerminalNode {
	return s.GetToken(DorisParserMONTH, 0)
}

func (s *UnitIdentifierContext) WEEK() antlr.TerminalNode {
	return s.GetToken(DorisParserWEEK, 0)
}

func (s *UnitIdentifierContext) DAY() antlr.TerminalNode {
	return s.GetToken(DorisParserDAY, 0)
}

func (s *UnitIdentifierContext) HOUR() antlr.TerminalNode {
	return s.GetToken(DorisParserHOUR, 0)
}

func (s *UnitIdentifierContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(DorisParserMINUTE, 0)
}

func (s *UnitIdentifierContext) SECOND() antlr.TerminalNode {
	return s.GetToken(DorisParserSECOND, 0)
}

func (s *UnitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUnitIdentifier(s)
	}
}

func (s *UnitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUnitIdentifier(s)
	}
}

func (p *DorisParser) UnitIdentifier() (localctx IUnitIdentifierContext) {
	localctx = NewUnitIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, DorisParserRULE_unitIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5920)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserDAY || _la == DorisParserHOUR || _la == DorisParserMINUTE || _la == DorisParserMONTH || _la == DorisParserQUARTER || _la == DorisParserSECOND || _la == DorisParserWEEK || _la == DorisParserYEAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeWithNullableContext is an interface to support dynamic dispatch.
type IDataTypeWithNullableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DataType() IDataTypeContext
	NULL() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsDataTypeWithNullableContext differentiates from other interfaces.
	IsDataTypeWithNullableContext()
}

type DataTypeWithNullableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeWithNullableContext() *DataTypeWithNullableContext {
	var p = new(DataTypeWithNullableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dataTypeWithNullable
	return p
}

func InitEmptyDataTypeWithNullableContext(p *DataTypeWithNullableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dataTypeWithNullable
}

func (*DataTypeWithNullableContext) IsDataTypeWithNullableContext() {}

func NewDataTypeWithNullableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeWithNullableContext {
	var p = new(DataTypeWithNullableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_dataTypeWithNullable

	return p
}

func (s *DataTypeWithNullableContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeWithNullableContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *DataTypeWithNullableContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisParserNULL, 0)
}

func (s *DataTypeWithNullableContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *DataTypeWithNullableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeWithNullableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeWithNullableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDataTypeWithNullable(s)
	}
}

func (s *DataTypeWithNullableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDataTypeWithNullable(s)
	}
}

func (p *DorisParser) DataTypeWithNullable() (localctx IDataTypeWithNullableContext) {
	localctx = NewDataTypeWithNullableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, DorisParserRULE_dataTypeWithNullable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5922)
		p.DataType()
	}
	p.SetState(5927)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserNOT || _la == DorisParserNULL {
		p.SetState(5924)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(5923)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5926)
			p.Match(DorisParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeContext is an interface to support dynamic dispatch.
type IDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDataTypeContext differentiates from other interfaces.
	IsDataTypeContext()
}

type DataTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeContext() *DataTypeContext {
	var p = new(DataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dataType
	return p
}

func InitEmptyDataTypeContext(p *DataTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dataType
}

func (*DataTypeContext) IsDataTypeContext() {}

func NewDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeContext {
	var p = new(DataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_dataType

	return p
}

func (s *DataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeContext) CopyAll(ctx *DataTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ComplexDataTypeContext struct {
	DataTypeContext
	complex_ antlr.Token
}

func NewComplexDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComplexDataTypeContext {
	var p = new(ComplexDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *ComplexDataTypeContext) GetComplex_() antlr.Token { return s.complex_ }

func (s *ComplexDataTypeContext) SetComplex_(v antlr.Token) { s.complex_ = v }

func (s *ComplexDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComplexDataTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(DorisParserLT, 0)
}

func (s *ComplexDataTypeContext) AllDataType() []IDataTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeContext); ok {
			tst[i] = t.(IDataTypeContext)
			i++
		}
	}

	return tst
}

func (s *ComplexDataTypeContext) DataType(i int) IDataTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ComplexDataTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(DorisParserGT, 0)
}

func (s *ComplexDataTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(DorisParserARRAY, 0)
}

func (s *ComplexDataTypeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, 0)
}

func (s *ComplexDataTypeContext) MAP() antlr.TerminalNode {
	return s.GetToken(DorisParserMAP, 0)
}

func (s *ComplexDataTypeContext) ComplexColTypeList() IComplexColTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComplexColTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComplexColTypeListContext)
}

func (s *ComplexDataTypeContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRUCT, 0)
}

func (s *ComplexDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterComplexDataType(s)
	}
}

func (s *ComplexDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitComplexDataType(s)
	}
}

type AggStateDataTypeContext struct {
	DataTypeContext
	_dataTypeWithNullable IDataTypeWithNullableContext
	dataTypes             []IDataTypeWithNullableContext
}

func NewAggStateDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AggStateDataTypeContext {
	var p = new(AggStateDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *AggStateDataTypeContext) Get_dataTypeWithNullable() IDataTypeWithNullableContext {
	return s._dataTypeWithNullable
}

func (s *AggStateDataTypeContext) Set_dataTypeWithNullable(v IDataTypeWithNullableContext) {
	s._dataTypeWithNullable = v
}

func (s *AggStateDataTypeContext) GetDataTypes() []IDataTypeWithNullableContext { return s.dataTypes }

func (s *AggStateDataTypeContext) SetDataTypes(v []IDataTypeWithNullableContext) { s.dataTypes = v }

func (s *AggStateDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggStateDataTypeContext) AGG_STATE() antlr.TerminalNode {
	return s.GetToken(DorisParserAGG_STATE, 0)
}

func (s *AggStateDataTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(DorisParserLT, 0)
}

func (s *AggStateDataTypeContext) FunctionNameIdentifier() IFunctionNameIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameIdentifierContext)
}

func (s *AggStateDataTypeContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AggStateDataTypeContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AggStateDataTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(DorisParserGT, 0)
}

func (s *AggStateDataTypeContext) AllDataTypeWithNullable() []IDataTypeWithNullableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeWithNullableContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeWithNullableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeWithNullableContext); ok {
			tst[i] = t.(IDataTypeWithNullableContext)
			i++
		}
	}

	return tst
}

func (s *AggStateDataTypeContext) DataTypeWithNullable(i int) IDataTypeWithNullableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeWithNullableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeWithNullableContext)
}

func (s *AggStateDataTypeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AggStateDataTypeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AggStateDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAggStateDataType(s)
	}
}

func (s *AggStateDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAggStateDataType(s)
	}
}

type PrimitiveDataTypeContext struct {
	DataTypeContext
}

func NewPrimitiveDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimitiveDataTypeContext {
	var p = new(PrimitiveDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *PrimitiveDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveDataTypeContext) PrimitiveColType() IPrimitiveColTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveColTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveColTypeContext)
}

func (s *PrimitiveDataTypeContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *PrimitiveDataTypeContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *PrimitiveDataTypeContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserINTEGER_VALUE)
}

func (s *PrimitiveDataTypeContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, i)
}

func (s *PrimitiveDataTypeContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserASTERISK, 0)
}

func (s *PrimitiveDataTypeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *PrimitiveDataTypeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *PrimitiveDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPrimitiveDataType(s)
	}
}

func (s *PrimitiveDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPrimitiveDataType(s)
	}
}

func (p *DorisParser) DataType() (localctx IDataTypeContext) {
	localctx = NewDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, DorisParserRULE_dataType)
	var _la int

	p.SetState(5974)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 860, p.GetParserRuleContext()) {
	case 1:
		localctx = NewComplexDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5929)

			var _m = p.Match(DorisParserARRAY)

			localctx.(*ComplexDataTypeContext).complex_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5930)
			p.Match(DorisParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5931)
			p.DataType()
		}
		{
			p.SetState(5932)
			p.Match(DorisParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewComplexDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5934)

			var _m = p.Match(DorisParserMAP)

			localctx.(*ComplexDataTypeContext).complex_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5935)
			p.Match(DorisParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5936)
			p.DataType()
		}
		{
			p.SetState(5937)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5938)
			p.DataType()
		}
		{
			p.SetState(5939)
			p.Match(DorisParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewComplexDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5941)

			var _m = p.Match(DorisParserSTRUCT)

			localctx.(*ComplexDataTypeContext).complex_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5942)
			p.Match(DorisParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5943)
			p.ComplexColTypeList()
		}
		{
			p.SetState(5944)
			p.Match(DorisParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewAggStateDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5946)
			p.Match(DorisParserAGG_STATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5947)
			p.Match(DorisParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5948)
			p.FunctionNameIdentifier()
		}
		{
			p.SetState(5949)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5950)

			var _x = p.DataTypeWithNullable()

			localctx.(*AggStateDataTypeContext)._dataTypeWithNullable = _x
		}
		localctx.(*AggStateDataTypeContext).dataTypes = append(localctx.(*AggStateDataTypeContext).dataTypes, localctx.(*AggStateDataTypeContext)._dataTypeWithNullable)
		p.SetState(5955)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(5951)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5952)

				var _x = p.DataTypeWithNullable()

				localctx.(*AggStateDataTypeContext)._dataTypeWithNullable = _x
			}
			localctx.(*AggStateDataTypeContext).dataTypes = append(localctx.(*AggStateDataTypeContext).dataTypes, localctx.(*AggStateDataTypeContext)._dataTypeWithNullable)

			p.SetState(5957)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5958)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5959)
			p.Match(DorisParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewPrimitiveDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5961)
			p.PrimitiveColType()
		}
		p.SetState(5972)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(5962)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5963)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserASTERISK || _la == DorisParserINTEGER_VALUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(5968)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(5964)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5965)
					p.Match(DorisParserINTEGER_VALUE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(5970)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(5971)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimitiveColTypeContext is an interface to support dynamic dispatch.
type IPrimitiveColTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	TINYINT() antlr.TerminalNode
	SMALLINT() antlr.TerminalNode
	INT() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	BIGINT() antlr.TerminalNode
	LARGEINT() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	TIME() antlr.TerminalNode
	DATEV2() antlr.TerminalNode
	DATETIMEV2() antlr.TerminalNode
	DATEV1() antlr.TerminalNode
	DATETIMEV1() antlr.TerminalNode
	BITMAP() antlr.TerminalNode
	QUANTILE_STATE() antlr.TerminalNode
	HLL() antlr.TerminalNode
	AGG_STATE() antlr.TerminalNode
	STRING() antlr.TerminalNode
	JSON() antlr.TerminalNode
	JSONB() antlr.TerminalNode
	TEXT() antlr.TerminalNode
	VARCHAR() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	DECIMALV2() antlr.TerminalNode
	DECIMALV3() antlr.TerminalNode
	IPV4() antlr.TerminalNode
	IPV6() antlr.TerminalNode
	VARIANT() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsPrimitiveColTypeContext differentiates from other interfaces.
	IsPrimitiveColTypeContext()
}

type PrimitiveColTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyPrimitiveColTypeContext() *PrimitiveColTypeContext {
	var p = new(PrimitiveColTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_primitiveColType
	return p
}

func InitEmptyPrimitiveColTypeContext(p *PrimitiveColTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_primitiveColType
}

func (*PrimitiveColTypeContext) IsPrimitiveColTypeContext() {}

func NewPrimitiveColTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveColTypeContext {
	var p = new(PrimitiveColTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_primitiveColType

	return p
}

func (s *PrimitiveColTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveColTypeContext) GetType_() antlr.Token { return s.type_ }

func (s *PrimitiveColTypeContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *PrimitiveColTypeContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(DorisParserTINYINT, 0)
}

func (s *PrimitiveColTypeContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(DorisParserSMALLINT, 0)
}

func (s *PrimitiveColTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(DorisParserINT, 0)
}

func (s *PrimitiveColTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER, 0)
}

func (s *PrimitiveColTypeContext) BIGINT() antlr.TerminalNode {
	return s.GetToken(DorisParserBIGINT, 0)
}

func (s *PrimitiveColTypeContext) LARGEINT() antlr.TerminalNode {
	return s.GetToken(DorisParserLARGEINT, 0)
}

func (s *PrimitiveColTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(DorisParserBOOLEAN, 0)
}

func (s *PrimitiveColTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(DorisParserFLOAT, 0)
}

func (s *PrimitiveColTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(DorisParserDOUBLE, 0)
}

func (s *PrimitiveColTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATE, 0)
}

func (s *PrimitiveColTypeContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(DorisParserDATETIME, 0)
}

func (s *PrimitiveColTypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserTIME, 0)
}

func (s *PrimitiveColTypeContext) DATEV2() antlr.TerminalNode {
	return s.GetToken(DorisParserDATEV2, 0)
}

func (s *PrimitiveColTypeContext) DATETIMEV2() antlr.TerminalNode {
	return s.GetToken(DorisParserDATETIMEV2, 0)
}

func (s *PrimitiveColTypeContext) DATEV1() antlr.TerminalNode {
	return s.GetToken(DorisParserDATEV1, 0)
}

func (s *PrimitiveColTypeContext) DATETIMEV1() antlr.TerminalNode {
	return s.GetToken(DorisParserDATETIMEV1, 0)
}

func (s *PrimitiveColTypeContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(DorisParserBITMAP, 0)
}

func (s *PrimitiveColTypeContext) QUANTILE_STATE() antlr.TerminalNode {
	return s.GetToken(DorisParserQUANTILE_STATE, 0)
}

func (s *PrimitiveColTypeContext) HLL() antlr.TerminalNode {
	return s.GetToken(DorisParserHLL, 0)
}

func (s *PrimitiveColTypeContext) AGG_STATE() antlr.TerminalNode {
	return s.GetToken(DorisParserAGG_STATE, 0)
}

func (s *PrimitiveColTypeContext) STRING() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING, 0)
}

func (s *PrimitiveColTypeContext) JSON() antlr.TerminalNode {
	return s.GetToken(DorisParserJSON, 0)
}

func (s *PrimitiveColTypeContext) JSONB() antlr.TerminalNode {
	return s.GetToken(DorisParserJSONB, 0)
}

func (s *PrimitiveColTypeContext) TEXT() antlr.TerminalNode {
	return s.GetToken(DorisParserTEXT, 0)
}

func (s *PrimitiveColTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserVARCHAR, 0)
}

func (s *PrimitiveColTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserCHAR, 0)
}

func (s *PrimitiveColTypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(DorisParserDECIMAL, 0)
}

func (s *PrimitiveColTypeContext) DECIMALV2() antlr.TerminalNode {
	return s.GetToken(DorisParserDECIMALV2, 0)
}

func (s *PrimitiveColTypeContext) DECIMALV3() antlr.TerminalNode {
	return s.GetToken(DorisParserDECIMALV3, 0)
}

func (s *PrimitiveColTypeContext) IPV4() antlr.TerminalNode {
	return s.GetToken(DorisParserIPV4, 0)
}

func (s *PrimitiveColTypeContext) IPV6() antlr.TerminalNode {
	return s.GetToken(DorisParserIPV6, 0)
}

func (s *PrimitiveColTypeContext) VARIANT() antlr.TerminalNode {
	return s.GetToken(DorisParserVARIANT, 0)
}

func (s *PrimitiveColTypeContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *PrimitiveColTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveColTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveColTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPrimitiveColType(s)
	}
}

func (s *PrimitiveColTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPrimitiveColType(s)
	}
}

func (p *DorisParser) PrimitiveColType() (localctx IPrimitiveColTypeContext) {
	localctx = NewPrimitiveColTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, DorisParserRULE_primitiveColType)
	var _la int

	p.SetState(6008)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserTINYINT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5976)

			var _m = p.Match(DorisParserTINYINT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserSMALLINT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5977)

			var _m = p.Match(DorisParserSMALLINT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserINT, DorisParserINTEGER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5978)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PrimitiveColTypeContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserINT || _la == DorisParserINTEGER) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PrimitiveColTypeContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case DorisParserBIGINT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5979)

			var _m = p.Match(DorisParserBIGINT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserLARGEINT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5980)

			var _m = p.Match(DorisParserLARGEINT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserBOOLEAN:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5981)

			var _m = p.Match(DorisParserBOOLEAN)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserFLOAT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5982)

			var _m = p.Match(DorisParserFLOAT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDOUBLE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5983)

			var _m = p.Match(DorisParserDOUBLE)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDATE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5984)

			var _m = p.Match(DorisParserDATE)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDATETIME:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5985)

			var _m = p.Match(DorisParserDATETIME)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserTIME:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5986)

			var _m = p.Match(DorisParserTIME)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDATEV2:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5987)

			var _m = p.Match(DorisParserDATEV2)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDATETIMEV2:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5988)

			var _m = p.Match(DorisParserDATETIMEV2)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDATEV1:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5989)

			var _m = p.Match(DorisParserDATEV1)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDATETIMEV1:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(5990)

			var _m = p.Match(DorisParserDATETIMEV1)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserBITMAP:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(5991)

			var _m = p.Match(DorisParserBITMAP)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserQUANTILE_STATE:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(5992)

			var _m = p.Match(DorisParserQUANTILE_STATE)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserHLL:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(5993)

			var _m = p.Match(DorisParserHLL)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserAGG_STATE:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(5994)

			var _m = p.Match(DorisParserAGG_STATE)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserSTRING:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(5995)

			var _m = p.Match(DorisParserSTRING)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserJSON:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(5996)

			var _m = p.Match(DorisParserJSON)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserJSONB:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(5997)

			var _m = p.Match(DorisParserJSONB)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserTEXT:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(5998)

			var _m = p.Match(DorisParserTEXT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserVARCHAR:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(5999)

			var _m = p.Match(DorisParserVARCHAR)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserCHAR:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(6000)

			var _m = p.Match(DorisParserCHAR)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDECIMAL:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(6001)

			var _m = p.Match(DorisParserDECIMAL)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDECIMALV2:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(6002)

			var _m = p.Match(DorisParserDECIMALV2)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDECIMALV3:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(6003)

			var _m = p.Match(DorisParserDECIMALV3)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserIPV4:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(6004)

			var _m = p.Match(DorisParserIPV4)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserIPV6:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(6005)

			var _m = p.Match(DorisParserIPV6)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserVARIANT:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(6006)

			var _m = p.Match(DorisParserVARIANT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserALL:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(6007)

			var _m = p.Match(DorisParserALL)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComplexColTypeListContext is an interface to support dynamic dispatch.
type IComplexColTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllComplexColType() []IComplexColTypeContext
	ComplexColType(i int) IComplexColTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsComplexColTypeListContext differentiates from other interfaces.
	IsComplexColTypeListContext()
}

type ComplexColTypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComplexColTypeListContext() *ComplexColTypeListContext {
	var p = new(ComplexColTypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_complexColTypeList
	return p
}

func InitEmptyComplexColTypeListContext(p *ComplexColTypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_complexColTypeList
}

func (*ComplexColTypeListContext) IsComplexColTypeListContext() {}

func NewComplexColTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComplexColTypeListContext {
	var p = new(ComplexColTypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_complexColTypeList

	return p
}

func (s *ComplexColTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *ComplexColTypeListContext) AllComplexColType() []IComplexColTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IComplexColTypeContext); ok {
			len++
		}
	}

	tst := make([]IComplexColTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IComplexColTypeContext); ok {
			tst[i] = t.(IComplexColTypeContext)
			i++
		}
	}

	return tst
}

func (s *ComplexColTypeListContext) ComplexColType(i int) IComplexColTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComplexColTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComplexColTypeContext)
}

func (s *ComplexColTypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ComplexColTypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ComplexColTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComplexColTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComplexColTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterComplexColTypeList(s)
	}
}

func (s *ComplexColTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitComplexColTypeList(s)
	}
}

func (p *DorisParser) ComplexColTypeList() (localctx IComplexColTypeListContext) {
	localctx = NewComplexColTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, DorisParserRULE_complexColTypeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6010)
		p.ComplexColType()
	}
	p.SetState(6015)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(6011)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6012)
			p.ComplexColType()
		}

		p.SetState(6017)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComplexColTypeContext is an interface to support dynamic dispatch.
type IComplexColTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	DataType() IDataTypeContext
	CommentSpec() ICommentSpecContext

	// IsComplexColTypeContext differentiates from other interfaces.
	IsComplexColTypeContext()
}

type ComplexColTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComplexColTypeContext() *ComplexColTypeContext {
	var p = new(ComplexColTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_complexColType
	return p
}

func InitEmptyComplexColTypeContext(p *ComplexColTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_complexColType
}

func (*ComplexColTypeContext) IsComplexColTypeContext() {}

func NewComplexColTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComplexColTypeContext {
	var p = new(ComplexColTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_complexColType

	return p
}

func (s *ComplexColTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ComplexColTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ComplexColTypeContext) COLON() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLON, 0)
}

func (s *ComplexColTypeContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ComplexColTypeContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *ComplexColTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComplexColTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComplexColTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterComplexColType(s)
	}
}

func (s *ComplexColTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitComplexColType(s)
	}
}

func (p *DorisParser) ComplexColType() (localctx IComplexColTypeContext) {
	localctx = NewComplexColTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, DorisParserRULE_complexColType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6018)
		p.Identifier()
	}
	{
		p.SetState(6019)
		p.Match(DorisParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6020)
		p.DataType()
	}
	p.SetState(6022)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserCOMMENT {
		{
			p.SetState(6021)
			p.CommentSpec()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommentSpecContext is an interface to support dynamic dispatch.
type ICommentSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsCommentSpecContext differentiates from other interfaces.
	IsCommentSpecContext()
}

type CommentSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentSpecContext() *CommentSpecContext {
	var p = new(CommentSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_commentSpec
	return p
}

func InitEmptyCommentSpecContext(p *CommentSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_commentSpec
}

func (*CommentSpecContext) IsCommentSpecContext() {}

func NewCommentSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentSpecContext {
	var p = new(CommentSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_commentSpec

	return p
}

func (s *CommentSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentSpecContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *CommentSpecContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CommentSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCommentSpec(s)
	}
}

func (s *CommentSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCommentSpec(s)
	}
}

func (p *DorisParser) CommentSpec() (localctx ICommentSpecContext) {
	localctx = NewCommentSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, DorisParserRULE_commentSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6024)
		p.Match(DorisParserCOMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6025)
		p.Match(DorisParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampleContext is an interface to support dynamic dispatch.
type ISampleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSeed returns the seed token.
	GetSeed() antlr.Token

	// SetSeed sets the seed token.
	SetSeed(antlr.Token)

	// Getter signatures
	TABLESAMPLE() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	SampleMethod() ISampleMethodContext
	REPEATABLE() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsSampleContext differentiates from other interfaces.
	IsSampleContext()
}

type SampleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	seed   antlr.Token
}

func NewEmptySampleContext() *SampleContext {
	var p = new(SampleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sample
	return p
}

func InitEmptySampleContext(p *SampleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sample
}

func (*SampleContext) IsSampleContext() {}

func NewSampleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleContext {
	var p = new(SampleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_sample

	return p
}

func (s *SampleContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleContext) GetSeed() antlr.Token { return s.seed }

func (s *SampleContext) SetSeed(v antlr.Token) { s.seed = v }

func (s *SampleContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLESAMPLE, 0)
}

func (s *SampleContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *SampleContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *SampleContext) SampleMethod() ISampleMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleMethodContext)
}

func (s *SampleContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPEATABLE, 0)
}

func (s *SampleContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *SampleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSample(s)
	}
}

func (s *SampleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSample(s)
	}
}

func (p *DorisParser) Sample() (localctx ISampleContext) {
	localctx = NewSampleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, DorisParserRULE_sample)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6027)
		p.Match(DorisParserTABLESAMPLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6028)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6030)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserINTEGER_VALUE {
		{
			p.SetState(6029)
			p.SampleMethod()
		}

	}
	{
		p.SetState(6032)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6035)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 865, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6033)
			p.Match(DorisParserREPEATABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6034)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*SampleContext).seed = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampleMethodContext is an interface to support dynamic dispatch.
type ISampleMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSampleMethodContext differentiates from other interfaces.
	IsSampleMethodContext()
}

type SampleMethodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampleMethodContext() *SampleMethodContext {
	var p = new(SampleMethodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sampleMethod
	return p
}

func InitEmptySampleMethodContext(p *SampleMethodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sampleMethod
}

func (*SampleMethodContext) IsSampleMethodContext() {}

func NewSampleMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleMethodContext {
	var p = new(SampleMethodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_sampleMethod

	return p
}

func (s *SampleMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleMethodContext) CopyAll(ctx *SampleMethodContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SampleMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SampleByRowsContext struct {
	SampleMethodContext
}

func NewSampleByRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SampleByRowsContext {
	var p = new(SampleByRowsContext)

	InitEmptySampleMethodContext(&p.SampleMethodContext)
	p.parser = parser
	p.CopyAll(ctx.(*SampleMethodContext))

	return p
}

func (s *SampleByRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleByRowsContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *SampleByRowsContext) ROWS() antlr.TerminalNode {
	return s.GetToken(DorisParserROWS, 0)
}

func (s *SampleByRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSampleByRows(s)
	}
}

func (s *SampleByRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSampleByRows(s)
	}
}

type SampleByPercentileContext struct {
	SampleMethodContext
	percentage antlr.Token
}

func NewSampleByPercentileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SampleByPercentileContext {
	var p = new(SampleByPercentileContext)

	InitEmptySampleMethodContext(&p.SampleMethodContext)
	p.parser = parser
	p.CopyAll(ctx.(*SampleMethodContext))

	return p
}

func (s *SampleByPercentileContext) GetPercentage() antlr.Token { return s.percentage }

func (s *SampleByPercentileContext) SetPercentage(v antlr.Token) { s.percentage = v }

func (s *SampleByPercentileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleByPercentileContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(DorisParserPERCENT, 0)
}

func (s *SampleByPercentileContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *SampleByPercentileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSampleByPercentile(s)
	}
}

func (s *SampleByPercentileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSampleByPercentile(s)
	}
}

func (p *DorisParser) SampleMethod() (localctx ISampleMethodContext) {
	localctx = NewSampleMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, DorisParserRULE_sampleMethod)
	p.SetState(6041)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 866, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSampleByPercentileContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6037)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*SampleByPercentileContext).percentage = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6038)
			p.Match(DorisParserPERCENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewSampleByRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6039)
			p.Match(DorisParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6040)
			p.Match(DorisParserROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableSnapshotContext is an interface to support dynamic dispatch.
type ITableSnapshotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetVersion returns the version token.
	GetVersion() antlr.Token

	// GetTime returns the time token.
	GetTime() antlr.Token

	// SetVersion sets the version token.
	SetVersion(antlr.Token)

	// SetTime sets the time token.
	SetTime(antlr.Token)

	// Getter signatures
	FOR() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	TIME() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsTableSnapshotContext differentiates from other interfaces.
	IsTableSnapshotContext()
}

type TableSnapshotContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	version antlr.Token
	time    antlr.Token
}

func NewEmptyTableSnapshotContext() *TableSnapshotContext {
	var p = new(TableSnapshotContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tableSnapshot
	return p
}

func InitEmptyTableSnapshotContext(p *TableSnapshotContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tableSnapshot
}

func (*TableSnapshotContext) IsTableSnapshotContext() {}

func NewTableSnapshotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSnapshotContext {
	var p = new(TableSnapshotContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_tableSnapshot

	return p
}

func (s *TableSnapshotContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSnapshotContext) GetVersion() antlr.Token { return s.version }

func (s *TableSnapshotContext) GetTime() antlr.Token { return s.time }

func (s *TableSnapshotContext) SetVersion(v antlr.Token) { s.version = v }

func (s *TableSnapshotContext) SetTime(v antlr.Token) { s.time = v }

func (s *TableSnapshotContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *TableSnapshotContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisParserVERSION, 0)
}

func (s *TableSnapshotContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *TableSnapshotContext) OF() antlr.TerminalNode {
	return s.GetToken(DorisParserOF, 0)
}

func (s *TableSnapshotContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *TableSnapshotContext) TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserTIME, 0)
}

func (s *TableSnapshotContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *TableSnapshotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSnapshotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableSnapshotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTableSnapshot(s)
	}
}

func (s *TableSnapshotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTableSnapshot(s)
	}
}

func (p *DorisParser) TableSnapshot() (localctx ITableSnapshotContext) {
	localctx = NewTableSnapshotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, DorisParserRULE_tableSnapshot)
	p.SetState(6053)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 867, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6043)
			p.Match(DorisParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6044)
			p.Match(DorisParserVERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6045)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6046)
			p.Match(DorisParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6047)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*TableSnapshotContext).version = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6048)
			p.Match(DorisParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6049)
			p.Match(DorisParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6050)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6051)
			p.Match(DorisParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6052)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*TableSnapshotContext).time = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorCapturingIdentifierContext is an interface to support dynamic dispatch.
type IErrorCapturingIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ErrorCapturingIdentifierExtra() IErrorCapturingIdentifierExtraContext

	// IsErrorCapturingIdentifierContext differentiates from other interfaces.
	IsErrorCapturingIdentifierContext()
}

type ErrorCapturingIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorCapturingIdentifierContext() *ErrorCapturingIdentifierContext {
	var p = new(ErrorCapturingIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_errorCapturingIdentifier
	return p
}

func InitEmptyErrorCapturingIdentifierContext(p *ErrorCapturingIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_errorCapturingIdentifier
}

func (*ErrorCapturingIdentifierContext) IsErrorCapturingIdentifierContext() {}

func NewErrorCapturingIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorCapturingIdentifierContext {
	var p = new(ErrorCapturingIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_errorCapturingIdentifier

	return p
}

func (s *ErrorCapturingIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorCapturingIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ErrorCapturingIdentifierContext) ErrorCapturingIdentifierExtra() IErrorCapturingIdentifierExtraContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierExtraContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierExtraContext)
}

func (s *ErrorCapturingIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorCapturingIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorCapturingIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterErrorCapturingIdentifier(s)
	}
}

func (s *ErrorCapturingIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitErrorCapturingIdentifier(s)
	}
}

func (p *DorisParser) ErrorCapturingIdentifier() (localctx IErrorCapturingIdentifierContext) {
	localctx = NewErrorCapturingIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, DorisParserRULE_errorCapturingIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6055)
		p.Identifier()
	}
	{
		p.SetState(6056)
		p.ErrorCapturingIdentifierExtra()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorCapturingIdentifierExtraContext is an interface to support dynamic dispatch.
type IErrorCapturingIdentifierExtraContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsErrorCapturingIdentifierExtraContext differentiates from other interfaces.
	IsErrorCapturingIdentifierExtraContext()
}

type ErrorCapturingIdentifierExtraContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorCapturingIdentifierExtraContext() *ErrorCapturingIdentifierExtraContext {
	var p = new(ErrorCapturingIdentifierExtraContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_errorCapturingIdentifierExtra
	return p
}

func InitEmptyErrorCapturingIdentifierExtraContext(p *ErrorCapturingIdentifierExtraContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_errorCapturingIdentifierExtra
}

func (*ErrorCapturingIdentifierExtraContext) IsErrorCapturingIdentifierExtraContext() {}

func NewErrorCapturingIdentifierExtraContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorCapturingIdentifierExtraContext {
	var p = new(ErrorCapturingIdentifierExtraContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_errorCapturingIdentifierExtra

	return p
}

func (s *ErrorCapturingIdentifierExtraContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorCapturingIdentifierExtraContext) CopyAll(ctx *ErrorCapturingIdentifierExtraContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ErrorCapturingIdentifierExtraContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorCapturingIdentifierExtraContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ErrorIdentContext struct {
	ErrorCapturingIdentifierExtraContext
}

func NewErrorIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ErrorIdentContext {
	var p = new(ErrorIdentContext)

	InitEmptyErrorCapturingIdentifierExtraContext(&p.ErrorCapturingIdentifierExtraContext)
	p.parser = parser
	p.CopyAll(ctx.(*ErrorCapturingIdentifierExtraContext))

	return p
}

func (s *ErrorIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorIdentContext) AllSUBTRACT() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSUBTRACT)
}

func (s *ErrorIdentContext) SUBTRACT(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSUBTRACT, i)
}

func (s *ErrorIdentContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ErrorIdentContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ErrorIdentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterErrorIdent(s)
	}
}

func (s *ErrorIdentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitErrorIdent(s)
	}
}

type RealIdentContext struct {
	ErrorCapturingIdentifierExtraContext
}

func NewRealIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RealIdentContext {
	var p = new(RealIdentContext)

	InitEmptyErrorCapturingIdentifierExtraContext(&p.ErrorCapturingIdentifierExtraContext)
	p.parser = parser
	p.CopyAll(ctx.(*ErrorCapturingIdentifierExtraContext))

	return p
}

func (s *RealIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RealIdentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRealIdent(s)
	}
}

func (s *RealIdentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRealIdent(s)
	}
}

func (p *DorisParser) ErrorCapturingIdentifierExtra() (localctx IErrorCapturingIdentifierExtraContext) {
	localctx = NewErrorCapturingIdentifierExtraContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, DorisParserRULE_errorCapturingIdentifierExtra)
	var _alt int

	p.SetState(6065)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 869, p.GetParserRuleContext()) {
	case 1:
		localctx = NewErrorIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6060)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(6058)
					p.Match(DorisParserSUBTRACT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6059)
					p.Identifier()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(6062)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 868, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		localctx = NewRealIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StrictIdentifier() IStrictIdentifierContext

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *DorisParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, DorisParserRULE_identifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6067)
		p.StrictIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStrictIdentifierContext is an interface to support dynamic dispatch.
type IStrictIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStrictIdentifierContext differentiates from other interfaces.
	IsStrictIdentifierContext()
}

type StrictIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrictIdentifierContext() *StrictIdentifierContext {
	var p = new(StrictIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_strictIdentifier
	return p
}

func InitEmptyStrictIdentifierContext(p *StrictIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_strictIdentifier
}

func (*StrictIdentifierContext) IsStrictIdentifierContext() {}

func NewStrictIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StrictIdentifierContext {
	var p = new(StrictIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_strictIdentifier

	return p
}

func (s *StrictIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *StrictIdentifierContext) CopyAll(ctx *StrictIdentifierContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StrictIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StrictIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QuotedIdentifierAlternativeContext struct {
	StrictIdentifierContext
}

func NewQuotedIdentifierAlternativeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuotedIdentifierAlternativeContext {
	var p = new(QuotedIdentifierAlternativeContext)

	InitEmptyStrictIdentifierContext(&p.StrictIdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*StrictIdentifierContext))

	return p
}

func (s *QuotedIdentifierAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierAlternativeContext) QuotedIdentifier() IQuotedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuotedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuotedIdentifierContext)
}

func (s *QuotedIdentifierAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterQuotedIdentifierAlternative(s)
	}
}

func (s *QuotedIdentifierAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitQuotedIdentifierAlternative(s)
	}
}

type UnquotedIdentifierContext struct {
	StrictIdentifierContext
}

func NewUnquotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnquotedIdentifierContext {
	var p = new(UnquotedIdentifierContext)

	InitEmptyStrictIdentifierContext(&p.StrictIdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*StrictIdentifierContext))

	return p
}

func (s *UnquotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnquotedIdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(DorisParserIDENTIFIER, 0)
}

func (s *UnquotedIdentifierContext) NonReserved() INonReservedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonReservedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonReservedContext)
}

func (s *UnquotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUnquotedIdentifier(s)
	}
}

func (p *DorisParser) StrictIdentifier() (localctx IStrictIdentifierContext) {
	localctx = NewStrictIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, DorisParserRULE_strictIdentifier)
	p.SetState(6072)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserIDENTIFIER:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6069)
			p.Match(DorisParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserBACKQUOTED_IDENTIFIER:
		localctx = NewQuotedIdentifierAlternativeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6070)
			p.QuotedIdentifier()
		}

	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6071)
			p.NonReserved()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuotedIdentifierContext is an interface to support dynamic dispatch.
type IQuotedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BACKQUOTED_IDENTIFIER() antlr.TerminalNode

	// IsQuotedIdentifierContext differentiates from other interfaces.
	IsQuotedIdentifierContext()
}

type QuotedIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuotedIdentifierContext() *QuotedIdentifierContext {
	var p = new(QuotedIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_quotedIdentifier
	return p
}

func InitEmptyQuotedIdentifierContext(p *QuotedIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_quotedIdentifier
}

func (*QuotedIdentifierContext) IsQuotedIdentifierContext() {}

func NewQuotedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuotedIdentifierContext {
	var p = new(QuotedIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_quotedIdentifier

	return p
}

func (s *QuotedIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *QuotedIdentifierContext) BACKQUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKQUOTED_IDENTIFIER, 0)
}

func (s *QuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterQuotedIdentifier(s)
	}
}

func (s *QuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitQuotedIdentifier(s)
	}
}

func (p *DorisParser) QuotedIdentifier() (localctx IQuotedIdentifierContext) {
	localctx = NewQuotedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, DorisParserRULE_quotedIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6074)
		p.Match(DorisParserBACKQUOTED_IDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_number
	return p
}

func InitEmptyNumberContext(p *NumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_number
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) CopyAll(ctx *NumberContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DecimalLiteralContext struct {
	NumberContext
}

func NewDecimalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) EXPONENT_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserEXPONENT_VALUE, 0)
}

func (s *DecimalLiteralContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserDECIMAL_VALUE, 0)
}

func (s *DecimalLiteralContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(DorisParserSUBTRACT, 0)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

type IntegerLiteralContext struct {
	NumberContext
}

func NewIntegerLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *IntegerLiteralContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(DorisParserSUBTRACT, 0)
}

func (s *IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIntegerLiteral(s)
	}
}

func (p *DorisParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, DorisParserRULE_number)
	var _la int

	p.SetState(6084)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 873, p.GetParserRuleContext()) {
	case 1:
		localctx = NewIntegerLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6077)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserSUBTRACT {
			{
				p.SetState(6076)
				p.Match(DorisParserSUBTRACT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6079)
			p.Match(DorisParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewDecimalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(6081)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserSUBTRACT {
			{
				p.SetState(6080)
				p.Match(DorisParserSUBTRACT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6083)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserEXPONENT_VALUE || _la == DorisParserDECIMAL_VALUE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonReservedContext is an interface to support dynamic dispatch.
type INonReservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACTIONS() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	AGG_STATE() antlr.TerminalNode
	AGGREGATE() antlr.TerminalNode
	ALIAS() antlr.TerminalNode
	ALWAYS() antlr.TerminalNode
	ANALYZED() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	AT() antlr.TerminalNode
	AUTHORS() antlr.TerminalNode
	AUTO_INCREMENT() antlr.TerminalNode
	BACKENDS() antlr.TerminalNode
	BACKUP() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	BELONG() antlr.TerminalNode
	BIN() antlr.TerminalNode
	BITAND() antlr.TerminalNode
	BITMAP() antlr.TerminalNode
	BITMAP_EMPTY() antlr.TerminalNode
	BITMAP_UNION() antlr.TerminalNode
	BITOR() antlr.TerminalNode
	BITXOR() antlr.TerminalNode
	BLOB() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	BRIEF() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	BUILD() antlr.TerminalNode
	BUILTIN() antlr.TerminalNode
	BULK() antlr.TerminalNode
	CACHE() antlr.TerminalNode
	CACHED() antlr.TerminalNode
	CALL() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	CATALOGS() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	CLUSTERS() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	COLLECT() antlr.TerminalNode
	COLOCATE() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	COMMENT_START() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	COMPACT() antlr.TerminalNode
	COMPLETE() antlr.TerminalNode
	COMPRESS_TYPE() antlr.TerminalNode
	COMPUTE() antlr.TerminalNode
	CONDITIONS() antlr.TerminalNode
	CONFIG() antlr.TerminalNode
	CONNECTION() antlr.TerminalNode
	CONNECTION_ID() antlr.TerminalNode
	CONSISTENT() antlr.TerminalNode
	CONSTRAINTS() antlr.TerminalNode
	CONVERT() antlr.TerminalNode
	CONVERT_LSC() antlr.TerminalNode
	COPY() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	CREATION() antlr.TerminalNode
	CRON() antlr.TerminalNode
	CURRENT_CATALOG() antlr.TerminalNode
	CURRENT_DATE() antlr.TerminalNode
	CURRENT_TIME() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	CURRENT_USER() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	DATETIMEV1() antlr.TerminalNode
	DATETIMEV2() antlr.TerminalNode
	DATEV1() antlr.TerminalNode
	DATEV2() antlr.TerminalNode
	DAY() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	DECIMALV2() antlr.TerminalNode
	DECIMALV3() antlr.TerminalNode
	DEFERRED() antlr.TerminalNode
	DEMAND() antlr.TerminalNode
	DIAGNOSE() antlr.TerminalNode
	DIAGNOSIS() antlr.TerminalNode
	DISTINCTPC() antlr.TerminalNode
	DISTINCTPCSA() antlr.TerminalNode
	DO() antlr.TerminalNode
	DORIS_INTERNAL_TABLE_ID() antlr.TerminalNode
	DUAL() antlr.TerminalNode
	DYNAMIC() antlr.TerminalNode
	E() antlr.TerminalNode
	ENABLE() antlr.TerminalNode
	ENCRYPTKEY() antlr.TerminalNode
	ENCRYPTKEYS() antlr.TerminalNode
	END() antlr.TerminalNode
	ENDS() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	ENGINES() antlr.TerminalNode
	ERRORS() antlr.TerminalNode
	EVENTS() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	EXCLUDE() antlr.TerminalNode
	EXPIRED() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode
	FAST() antlr.TerminalNode
	FEATURE() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	FILE() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	FREE() antlr.TerminalNode
	FRONTENDS() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	GENERATED() antlr.TerminalNode
	GENERIC() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	GRAPH() antlr.TerminalNode
	GROUPING() antlr.TerminalNode
	GROUPS() antlr.TerminalNode
	HASH() antlr.TerminalNode
	HDFS() antlr.TerminalNode
	HELP() antlr.TerminalNode
	HINT_END() antlr.TerminalNode
	HINT_START() antlr.TerminalNode
	HISTOGRAM() antlr.TerminalNode
	HLL_UNION() antlr.TerminalNode
	HOSTNAME() antlr.TerminalNode
	HOTSPOT() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	HUB() antlr.TerminalNode
	IDENTIFIED() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	IMMEDIATE() antlr.TerminalNode
	INCREMENTAL() antlr.TerminalNode
	INDEXES() antlr.TerminalNode
	INVERTED() antlr.TerminalNode
	IPV4() antlr.TerminalNode
	IPV6() antlr.TerminalNode
	IS_NOT_NULL_PRED() antlr.TerminalNode
	IS_NULL_PRED() antlr.TerminalNode
	ISNULL() antlr.TerminalNode
	ISOLATION() antlr.TerminalNode
	JOB() antlr.TerminalNode
	JOBS() antlr.TerminalNode
	JSON() antlr.TerminalNode
	JSONB() antlr.TerminalNode
	LABEL() antlr.TerminalNode
	LAST() antlr.TerminalNode
	LDAP() antlr.TerminalNode
	LDAP_ADMIN_PASSWORD() antlr.TerminalNode
	LEFT_BRACE() antlr.TerminalNode
	LESS() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	LINES() antlr.TerminalNode
	LINK() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	LOCALTIME() antlr.TerminalNode
	LOCALTIMESTAMP() antlr.TerminalNode
	LOCATION() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	LOGICAL() antlr.TerminalNode
	MANUAL() antlr.TerminalNode
	MAP() antlr.TerminalNode
	MATCH_ALL() antlr.TerminalNode
	MATCH_ANY() antlr.TerminalNode
	MATCH_PHRASE() antlr.TerminalNode
	MATCH_PHRASE_EDGE() antlr.TerminalNode
	MATCH_PHRASE_PREFIX() antlr.TerminalNode
	MATCH_REGEXP() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MEMO() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	MIGRATE() antlr.TerminalNode
	MIGRATIONS() antlr.TerminalNode
	MIN() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	MTMV() antlr.TerminalNode
	NAME() antlr.TerminalNode
	NAMES() antlr.TerminalNode
	NEGATIVE() antlr.TerminalNode
	NEVER() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	NGRAM_BF() antlr.TerminalNode
	NO() antlr.TerminalNode
	NON_NULLABLE() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	OF() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	OPTIMIZED() antlr.TerminalNode
	PARAMETER() antlr.TerminalNode
	PARSED() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	PASSWORD_EXPIRE() antlr.TerminalNode
	PASSWORD_HISTORY() antlr.TerminalNode
	PASSWORD_LOCK_TIME() antlr.TerminalNode
	PASSWORD_REUSE() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	PATH() antlr.TerminalNode
	PAUSE() antlr.TerminalNode
	PERCENT() antlr.TerminalNode
	PERIOD() antlr.TerminalNode
	PERMISSIVE() antlr.TerminalNode
	PHYSICAL() antlr.TerminalNode
	PI() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	PLUGINS() antlr.TerminalNode
	POLICY() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	PROC() antlr.TerminalNode
	PROCESS() antlr.TerminalNode
	PROCESSLIST() antlr.TerminalNode
	PROFILE() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode
	QUANTILE_STATE() antlr.TerminalNode
	QUANTILE_UNION() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	QUOTA() antlr.TerminalNode
	QUALIFY() antlr.TerminalNode
	RANDOM() antlr.TerminalNode
	RECENT() antlr.TerminalNode
	RECOVER() antlr.TerminalNode
	RECYCLE() antlr.TerminalNode
	REFRESH() antlr.TerminalNode
	REPEATABLE() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	REPLACE_IF_NOT_NULL() antlr.TerminalNode
	REPLAYER() antlr.TerminalNode
	REPOSITORIES() antlr.TerminalNode
	REPOSITORY() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	RESOURCES() antlr.TerminalNode
	RESTORE() antlr.TerminalNode
	RESTRICTIVE() antlr.TerminalNode
	RESUME() antlr.TerminalNode
	RETURNS() antlr.TerminalNode
	REWRITTEN() antlr.TerminalNode
	RIGHT_BRACE() antlr.TerminalNode
	RLIKE() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	S3() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	SCHEDULER() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode
	SET_SESSION_VARIABLE() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	SESSION_USER() antlr.TerminalNode
	SHAPE() antlr.TerminalNode
	SKEW() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	SONAME() antlr.TerminalNode
	SPLIT() antlr.TerminalNode
	SQL() antlr.TerminalNode
	STAGE() antlr.TerminalNode
	STAGES() antlr.TerminalNode
	START() antlr.TerminalNode
	STARTS() antlr.TerminalNode
	STATS() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	STOP() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	STREAM() antlr.TerminalNode
	STREAMING() antlr.TerminalNode
	STRING() antlr.TerminalNode
	STRUCT() antlr.TerminalNode
	SUM() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	TASK() antlr.TerminalNode
	TASKS() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TEXT() antlr.TerminalNode
	THAN() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	TREE() antlr.TerminalNode
	TRIGGERS() antlr.TerminalNode
	TRUNCATE() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	TYPES() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	UNLOCK() antlr.TerminalNode
	UNSET() antlr.TerminalNode
	UP() antlr.TerminalNode
	USER() antlr.TerminalNode
	VALUE() antlr.TerminalNode
	VARCHAR() antlr.TerminalNode
	VARIABLE() antlr.TerminalNode
	VARIABLES() antlr.TerminalNode
	VARIANT() antlr.TerminalNode
	VAULT() antlr.TerminalNode
	VAULTS() antlr.TerminalNode
	VERBOSE() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	VIEWS() antlr.TerminalNode
	WARM() antlr.TerminalNode
	WARNINGS() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	WORK() antlr.TerminalNode
	YEAR() antlr.TerminalNode

	// IsNonReservedContext differentiates from other interfaces.
	IsNonReservedContext()
}

type NonReservedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedContext() *NonReservedContext {
	var p = new(NonReservedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_nonReserved
	return p
}

func InitEmptyNonReservedContext(p *NonReservedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_nonReserved
}

func (*NonReservedContext) IsNonReservedContext() {}

func NewNonReservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedContext {
	var p = new(NonReservedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_nonReserved

	return p
}

func (s *NonReservedContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedContext) ACTIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserACTIONS, 0)
}

func (s *NonReservedContext) AFTER() antlr.TerminalNode {
	return s.GetToken(DorisParserAFTER, 0)
}

func (s *NonReservedContext) AGG_STATE() antlr.TerminalNode {
	return s.GetToken(DorisParserAGG_STATE, 0)
}

func (s *NonReservedContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(DorisParserAGGREGATE, 0)
}

func (s *NonReservedContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(DorisParserALIAS, 0)
}

func (s *NonReservedContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(DorisParserALWAYS, 0)
}

func (s *NonReservedContext) ANALYZED() antlr.TerminalNode {
	return s.GetToken(DorisParserANALYZED, 0)
}

func (s *NonReservedContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(DorisParserARRAY, 0)
}

func (s *NonReservedContext) AT() antlr.TerminalNode {
	return s.GetToken(DorisParserAT, 0)
}

func (s *NonReservedContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTHORS, 0)
}

func (s *NonReservedContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO_INCREMENT, 0)
}

func (s *NonReservedContext) BACKENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKENDS, 0)
}

func (s *NonReservedContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKUP, 0)
}

func (s *NonReservedContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(DorisParserBEGIN, 0)
}

func (s *NonReservedContext) BELONG() antlr.TerminalNode {
	return s.GetToken(DorisParserBELONG, 0)
}

func (s *NonReservedContext) BIN() antlr.TerminalNode {
	return s.GetToken(DorisParserBIN, 0)
}

func (s *NonReservedContext) BITAND() antlr.TerminalNode {
	return s.GetToken(DorisParserBITAND, 0)
}

func (s *NonReservedContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(DorisParserBITMAP, 0)
}

func (s *NonReservedContext) BITMAP_EMPTY() antlr.TerminalNode {
	return s.GetToken(DorisParserBITMAP_EMPTY, 0)
}

func (s *NonReservedContext) BITMAP_UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserBITMAP_UNION, 0)
}

func (s *NonReservedContext) BITOR() antlr.TerminalNode {
	return s.GetToken(DorisParserBITOR, 0)
}

func (s *NonReservedContext) BITXOR() antlr.TerminalNode {
	return s.GetToken(DorisParserBITXOR, 0)
}

func (s *NonReservedContext) BLOB() antlr.TerminalNode {
	return s.GetToken(DorisParserBLOB, 0)
}

func (s *NonReservedContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(DorisParserBOOLEAN, 0)
}

func (s *NonReservedContext) BRIEF() antlr.TerminalNode {
	return s.GetToken(DorisParserBRIEF, 0)
}

func (s *NonReservedContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserBROKER, 0)
}

func (s *NonReservedContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisParserBUCKETS, 0)
}

func (s *NonReservedContext) BUILD() antlr.TerminalNode {
	return s.GetToken(DorisParserBUILD, 0)
}

func (s *NonReservedContext) BUILTIN() antlr.TerminalNode {
	return s.GetToken(DorisParserBUILTIN, 0)
}

func (s *NonReservedContext) BULK() antlr.TerminalNode {
	return s.GetToken(DorisParserBULK, 0)
}

func (s *NonReservedContext) CACHE() antlr.TerminalNode {
	return s.GetToken(DorisParserCACHE, 0)
}

func (s *NonReservedContext) CACHED() antlr.TerminalNode {
	return s.GetToken(DorisParserCACHED, 0)
}

func (s *NonReservedContext) CALL() antlr.TerminalNode {
	return s.GetToken(DorisParserCALL, 0)
}

func (s *NonReservedContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *NonReservedContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOGS, 0)
}

func (s *NonReservedContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(DorisParserCHAIN, 0)
}

func (s *NonReservedContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserCHAR, 0)
}

func (s *NonReservedContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(DorisParserCHARSET, 0)
}

func (s *NonReservedContext) CHECK() antlr.TerminalNode {
	return s.GetToken(DorisParserCHECK, 0)
}

func (s *NonReservedContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(DorisParserCLUSTER, 0)
}

func (s *NonReservedContext) CLUSTERS() antlr.TerminalNode {
	return s.GetToken(DorisParserCLUSTERS, 0)
}

func (s *NonReservedContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLLATION, 0)
}

func (s *NonReservedContext) COLLECT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLLECT, 0)
}

func (s *NonReservedContext) COLOCATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLOCATE, 0)
}

func (s *NonReservedContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMNS, 0)
}

func (s *NonReservedContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *NonReservedContext) COMMENT_START() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT_START, 0)
}

func (s *NonReservedContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMIT, 0)
}

func (s *NonReservedContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMITTED, 0)
}

func (s *NonReservedContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPACT, 0)
}

func (s *NonReservedContext) COMPLETE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPLETE, 0)
}

func (s *NonReservedContext) COMPRESS_TYPE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPRESS_TYPE, 0)
}

func (s *NonReservedContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPUTE, 0)
}

func (s *NonReservedContext) CONDITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserCONDITIONS, 0)
}

func (s *NonReservedContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(DorisParserCONFIG, 0)
}

func (s *NonReservedContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(DorisParserCONNECTION, 0)
}

func (s *NonReservedContext) CONNECTION_ID() antlr.TerminalNode {
	return s.GetToken(DorisParserCONNECTION_ID, 0)
}

func (s *NonReservedContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCONSISTENT, 0)
}

func (s *NonReservedContext) CONSTRAINTS() antlr.TerminalNode {
	return s.GetToken(DorisParserCONSTRAINTS, 0)
}

func (s *NonReservedContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(DorisParserCONVERT, 0)
}

func (s *NonReservedContext) CONVERT_LSC() antlr.TerminalNode {
	return s.GetToken(DorisParserCONVERT_LSC, 0)
}

func (s *NonReservedContext) COPY() antlr.TerminalNode {
	return s.GetToken(DorisParserCOPY, 0)
}

func (s *NonReservedContext) COUNT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOUNT, 0)
}

func (s *NonReservedContext) CREATION() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATION, 0)
}

func (s *NonReservedContext) CRON() antlr.TerminalNode {
	return s.GetToken(DorisParserCRON, 0)
}

func (s *NonReservedContext) CURRENT_CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_CATALOG, 0)
}

func (s *NonReservedContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_DATE, 0)
}

func (s *NonReservedContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_TIME, 0)
}

func (s *NonReservedContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_TIMESTAMP, 0)
}

func (s *NonReservedContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_USER, 0)
}

func (s *NonReservedContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserDATA, 0)
}

func (s *NonReservedContext) DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATE, 0)
}

func (s *NonReservedContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(DorisParserDATETIME, 0)
}

func (s *NonReservedContext) DATETIMEV1() antlr.TerminalNode {
	return s.GetToken(DorisParserDATETIMEV1, 0)
}

func (s *NonReservedContext) DATETIMEV2() antlr.TerminalNode {
	return s.GetToken(DorisParserDATETIMEV2, 0)
}

func (s *NonReservedContext) DATEV1() antlr.TerminalNode {
	return s.GetToken(DorisParserDATEV1, 0)
}

func (s *NonReservedContext) DATEV2() antlr.TerminalNode {
	return s.GetToken(DorisParserDATEV2, 0)
}

func (s *NonReservedContext) DAY() antlr.TerminalNode {
	return s.GetToken(DorisParserDAY, 0)
}

func (s *NonReservedContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(DorisParserDECIMAL, 0)
}

func (s *NonReservedContext) DECIMALV2() antlr.TerminalNode {
	return s.GetToken(DorisParserDECIMALV2, 0)
}

func (s *NonReservedContext) DECIMALV3() antlr.TerminalNode {
	return s.GetToken(DorisParserDECIMALV3, 0)
}

func (s *NonReservedContext) DEFERRED() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFERRED, 0)
}

func (s *NonReservedContext) DEMAND() antlr.TerminalNode {
	return s.GetToken(DorisParserDEMAND, 0)
}

func (s *NonReservedContext) DIAGNOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserDIAGNOSE, 0)
}

func (s *NonReservedContext) DIAGNOSIS() antlr.TerminalNode {
	return s.GetToken(DorisParserDIAGNOSIS, 0)
}

func (s *NonReservedContext) DISTINCTPC() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTINCTPC, 0)
}

func (s *NonReservedContext) DISTINCTPCSA() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTINCTPCSA, 0)
}

func (s *NonReservedContext) DO() antlr.TerminalNode {
	return s.GetToken(DorisParserDO, 0)
}

func (s *NonReservedContext) DORIS_INTERNAL_TABLE_ID() antlr.TerminalNode {
	return s.GetToken(DorisParserDORIS_INTERNAL_TABLE_ID, 0)
}

func (s *NonReservedContext) DUAL() antlr.TerminalNode {
	return s.GetToken(DorisParserDUAL, 0)
}

func (s *NonReservedContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(DorisParserDYNAMIC, 0)
}

func (s *NonReservedContext) E() antlr.TerminalNode {
	return s.GetToken(DorisParserE, 0)
}

func (s *NonReservedContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserENABLE, 0)
}

func (s *NonReservedContext) ENCRYPTKEY() antlr.TerminalNode {
	return s.GetToken(DorisParserENCRYPTKEY, 0)
}

func (s *NonReservedContext) ENCRYPTKEYS() antlr.TerminalNode {
	return s.GetToken(DorisParserENCRYPTKEYS, 0)
}

func (s *NonReservedContext) END() antlr.TerminalNode {
	return s.GetToken(DorisParserEND, 0)
}

func (s *NonReservedContext) ENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserENDS, 0)
}

func (s *NonReservedContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(DorisParserENGINE, 0)
}

func (s *NonReservedContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(DorisParserENGINES, 0)
}

func (s *NonReservedContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(DorisParserERRORS, 0)
}

func (s *NonReservedContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEVENTS, 0)
}

func (s *NonReservedContext) EVERY() antlr.TerminalNode {
	return s.GetToken(DorisParserEVERY, 0)
}

func (s *NonReservedContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(DorisParserEXCLUDE, 0)
}

func (s *NonReservedContext) EXPIRED() antlr.TerminalNode {
	return s.GetToken(DorisParserEXPIRED, 0)
}

func (s *NonReservedContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisParserEXTERNAL, 0)
}

func (s *NonReservedContext) FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode {
	return s.GetToken(DorisParserFAILED_LOGIN_ATTEMPTS, 0)
}

func (s *NonReservedContext) FAST() antlr.TerminalNode {
	return s.GetToken(DorisParserFAST, 0)
}

func (s *NonReservedContext) FEATURE() antlr.TerminalNode {
	return s.GetToken(DorisParserFEATURE, 0)
}

func (s *NonReservedContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(DorisParserFIELDS, 0)
}

func (s *NonReservedContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisParserFILE, 0)
}

func (s *NonReservedContext) FILTER() antlr.TerminalNode {
	return s.GetToken(DorisParserFILTER, 0)
}

func (s *NonReservedContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DorisParserFIRST, 0)
}

func (s *NonReservedContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DorisParserFORMAT, 0)
}

func (s *NonReservedContext) FREE() antlr.TerminalNode {
	return s.GetToken(DorisParserFREE, 0)
}

func (s *NonReservedContext) FRONTENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserFRONTENDS, 0)
}

func (s *NonReservedContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserFUNCTION, 0)
}

func (s *NonReservedContext) GENERATED() antlr.TerminalNode {
	return s.GetToken(DorisParserGENERATED, 0)
}

func (s *NonReservedContext) GENERIC() antlr.TerminalNode {
	return s.GetToken(DorisParserGENERIC, 0)
}

func (s *NonReservedContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *NonReservedContext) GRAPH() antlr.TerminalNode {
	return s.GetToken(DorisParserGRAPH, 0)
}

func (s *NonReservedContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUPING, 0)
}

func (s *NonReservedContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUPS, 0)
}

func (s *NonReservedContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisParserHASH, 0)
}

func (s *NonReservedContext) HDFS() antlr.TerminalNode {
	return s.GetToken(DorisParserHDFS, 0)
}

func (s *NonReservedContext) HELP() antlr.TerminalNode {
	return s.GetToken(DorisParserHELP, 0)
}

func (s *NonReservedContext) HINT_END() antlr.TerminalNode {
	return s.GetToken(DorisParserHINT_END, 0)
}

func (s *NonReservedContext) HINT_START() antlr.TerminalNode {
	return s.GetToken(DorisParserHINT_START, 0)
}

func (s *NonReservedContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(DorisParserHISTOGRAM, 0)
}

func (s *NonReservedContext) HLL_UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserHLL_UNION, 0)
}

func (s *NonReservedContext) HOSTNAME() antlr.TerminalNode {
	return s.GetToken(DorisParserHOSTNAME, 0)
}

func (s *NonReservedContext) HOTSPOT() antlr.TerminalNode {
	return s.GetToken(DorisParserHOTSPOT, 0)
}

func (s *NonReservedContext) HOUR() antlr.TerminalNode {
	return s.GetToken(DorisParserHOUR, 0)
}

func (s *NonReservedContext) HUB() antlr.TerminalNode {
	return s.GetToken(DorisParserHUB, 0)
}

func (s *NonReservedContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(DorisParserIDENTIFIED, 0)
}

func (s *NonReservedContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(DorisParserIGNORE, 0)
}

func (s *NonReservedContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(DorisParserIMMEDIATE, 0)
}

func (s *NonReservedContext) INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(DorisParserINCREMENTAL, 0)
}

func (s *NonReservedContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEXES, 0)
}

func (s *NonReservedContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserINVERTED, 0)
}

func (s *NonReservedContext) IPV4() antlr.TerminalNode {
	return s.GetToken(DorisParserIPV4, 0)
}

func (s *NonReservedContext) IPV6() antlr.TerminalNode {
	return s.GetToken(DorisParserIPV6, 0)
}

func (s *NonReservedContext) IS_NOT_NULL_PRED() antlr.TerminalNode {
	return s.GetToken(DorisParserIS_NOT_NULL_PRED, 0)
}

func (s *NonReservedContext) IS_NULL_PRED() antlr.TerminalNode {
	return s.GetToken(DorisParserIS_NULL_PRED, 0)
}

func (s *NonReservedContext) ISNULL() antlr.TerminalNode {
	return s.GetToken(DorisParserISNULL, 0)
}

func (s *NonReservedContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(DorisParserISOLATION, 0)
}

func (s *NonReservedContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *NonReservedContext) JOBS() antlr.TerminalNode {
	return s.GetToken(DorisParserJOBS, 0)
}

func (s *NonReservedContext) JSON() antlr.TerminalNode {
	return s.GetToken(DorisParserJSON, 0)
}

func (s *NonReservedContext) JSONB() antlr.TerminalNode {
	return s.GetToken(DorisParserJSONB, 0)
}

func (s *NonReservedContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisParserLABEL, 0)
}

func (s *NonReservedContext) LAST() antlr.TerminalNode {
	return s.GetToken(DorisParserLAST, 0)
}

func (s *NonReservedContext) LDAP() antlr.TerminalNode {
	return s.GetToken(DorisParserLDAP, 0)
}

func (s *NonReservedContext) LDAP_ADMIN_PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisParserLDAP_ADMIN_PASSWORD, 0)
}

func (s *NonReservedContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACE, 0)
}

func (s *NonReservedContext) LESS() antlr.TerminalNode {
	return s.GetToken(DorisParserLESS, 0)
}

func (s *NonReservedContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(DorisParserLEVEL, 0)
}

func (s *NonReservedContext) LINES() antlr.TerminalNode {
	return s.GetToken(DorisParserLINES, 0)
}

func (s *NonReservedContext) LINK() antlr.TerminalNode {
	return s.GetToken(DorisParserLINK, 0)
}

func (s *NonReservedContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *NonReservedContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCALTIME, 0)
}

func (s *NonReservedContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCALTIMESTAMP, 0)
}

func (s *NonReservedContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCATION, 0)
}

func (s *NonReservedContext) LOCK() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCK, 0)
}

func (s *NonReservedContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOGICAL, 0)
}

func (s *NonReservedContext) MANUAL() antlr.TerminalNode {
	return s.GetToken(DorisParserMANUAL, 0)
}

func (s *NonReservedContext) MAP() antlr.TerminalNode {
	return s.GetToken(DorisParserMAP, 0)
}

func (s *NonReservedContext) MATCH_ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_ALL, 0)
}

func (s *NonReservedContext) MATCH_ANY() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_ANY, 0)
}

func (s *NonReservedContext) MATCH_PHRASE() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_PHRASE, 0)
}

func (s *NonReservedContext) MATCH_PHRASE_EDGE() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_PHRASE_EDGE, 0)
}

func (s *NonReservedContext) MATCH_PHRASE_PREFIX() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_PHRASE_PREFIX, 0)
}

func (s *NonReservedContext) MATCH_REGEXP() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_REGEXP, 0)
}

func (s *NonReservedContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *NonReservedContext) MAX() antlr.TerminalNode {
	return s.GetToken(DorisParserMAX, 0)
}

func (s *NonReservedContext) MEMO() antlr.TerminalNode {
	return s.GetToken(DorisParserMEMO, 0)
}

func (s *NonReservedContext) MERGE() antlr.TerminalNode {
	return s.GetToken(DorisParserMERGE, 0)
}

func (s *NonReservedContext) MIGRATE() antlr.TerminalNode {
	return s.GetToken(DorisParserMIGRATE, 0)
}

func (s *NonReservedContext) MIGRATIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserMIGRATIONS, 0)
}

func (s *NonReservedContext) MIN() antlr.TerminalNode {
	return s.GetToken(DorisParserMIN, 0)
}

func (s *NonReservedContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(DorisParserMINUTE, 0)
}

func (s *NonReservedContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *NonReservedContext) MONTH() antlr.TerminalNode {
	return s.GetToken(DorisParserMONTH, 0)
}

func (s *NonReservedContext) MTMV() antlr.TerminalNode {
	return s.GetToken(DorisParserMTMV, 0)
}

func (s *NonReservedContext) NAME() antlr.TerminalNode {
	return s.GetToken(DorisParserNAME, 0)
}

func (s *NonReservedContext) NAMES() antlr.TerminalNode {
	return s.GetToken(DorisParserNAMES, 0)
}

func (s *NonReservedContext) NEGATIVE() antlr.TerminalNode {
	return s.GetToken(DorisParserNEGATIVE, 0)
}

func (s *NonReservedContext) NEVER() antlr.TerminalNode {
	return s.GetToken(DorisParserNEVER, 0)
}

func (s *NonReservedContext) NEXT() antlr.TerminalNode {
	return s.GetToken(DorisParserNEXT, 0)
}

func (s *NonReservedContext) NGRAM_BF() antlr.TerminalNode {
	return s.GetToken(DorisParserNGRAM_BF, 0)
}

func (s *NonReservedContext) NO() antlr.TerminalNode {
	return s.GetToken(DorisParserNO, 0)
}

func (s *NonReservedContext) NON_NULLABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserNON_NULLABLE, 0)
}

func (s *NonReservedContext) NULLS() antlr.TerminalNode {
	return s.GetToken(DorisParserNULLS, 0)
}

func (s *NonReservedContext) OF() antlr.TerminalNode {
	return s.GetToken(DorisParserOF, 0)
}

func (s *NonReservedContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(DorisParserOFFSET, 0)
}

func (s *NonReservedContext) ONLY() antlr.TerminalNode {
	return s.GetToken(DorisParserONLY, 0)
}

func (s *NonReservedContext) OPEN() antlr.TerminalNode {
	return s.GetToken(DorisParserOPEN, 0)
}

func (s *NonReservedContext) OPTIMIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserOPTIMIZED, 0)
}

func (s *NonReservedContext) PARAMETER() antlr.TerminalNode {
	return s.GetToken(DorisParserPARAMETER, 0)
}

func (s *NonReservedContext) PARSED() antlr.TerminalNode {
	return s.GetToken(DorisParserPARSED, 0)
}

func (s *NonReservedContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD, 0)
}

func (s *NonReservedContext) PASSWORD_EXPIRE() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD_EXPIRE, 0)
}

func (s *NonReservedContext) PASSWORD_HISTORY() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD_HISTORY, 0)
}

func (s *NonReservedContext) PASSWORD_LOCK_TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD_LOCK_TIME, 0)
}

func (s *NonReservedContext) PASSWORD_REUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD_REUSE, 0)
}

func (s *NonReservedContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITIONS, 0)
}

func (s *NonReservedContext) PATH() antlr.TerminalNode {
	return s.GetToken(DorisParserPATH, 0)
}

func (s *NonReservedContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserPAUSE, 0)
}

func (s *NonReservedContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(DorisParserPERCENT, 0)
}

func (s *NonReservedContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(DorisParserPERIOD, 0)
}

func (s *NonReservedContext) PERMISSIVE() antlr.TerminalNode {
	return s.GetToken(DorisParserPERMISSIVE, 0)
}

func (s *NonReservedContext) PHYSICAL() antlr.TerminalNode {
	return s.GetToken(DorisParserPHYSICAL, 0)
}

func (s *NonReservedContext) PI() antlr.TerminalNode {
	return s.GetToken(DorisParserPI, 0)
}

func (s *NonReservedContext) PLAN() antlr.TerminalNode {
	return s.GetToken(DorisParserPLAN, 0)
}

func (s *NonReservedContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(DorisParserPLUGIN, 0)
}

func (s *NonReservedContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(DorisParserPLUGINS, 0)
}

func (s *NonReservedContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *NonReservedContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(DorisParserPRIVILEGES, 0)
}

func (s *NonReservedContext) PROC() antlr.TerminalNode {
	return s.GetToken(DorisParserPROC, 0)
}

func (s *NonReservedContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(DorisParserPROCESS, 0)
}

func (s *NonReservedContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(DorisParserPROCESSLIST, 0)
}

func (s *NonReservedContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserPROFILE, 0)
}

func (s *NonReservedContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *NonReservedContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTY, 0)
}

func (s *NonReservedContext) QUANTILE_STATE() antlr.TerminalNode {
	return s.GetToken(DorisParserQUANTILE_STATE, 0)
}

func (s *NonReservedContext) QUANTILE_UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserQUANTILE_UNION, 0)
}

func (s *NonReservedContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(DorisParserQUARTER, 0)
}

func (s *NonReservedContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DorisParserQUERY, 0)
}

func (s *NonReservedContext) QUOTA() antlr.TerminalNode {
	return s.GetToken(DorisParserQUOTA, 0)
}

func (s *NonReservedContext) QUALIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserQUALIFY, 0)
}

func (s *NonReservedContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(DorisParserRANDOM, 0)
}

func (s *NonReservedContext) RECENT() antlr.TerminalNode {
	return s.GetToken(DorisParserRECENT, 0)
}

func (s *NonReservedContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(DorisParserRECOVER, 0)
}

func (s *NonReservedContext) RECYCLE() antlr.TerminalNode {
	return s.GetToken(DorisParserRECYCLE, 0)
}

func (s *NonReservedContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserREFRESH, 0)
}

func (s *NonReservedContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPEATABLE, 0)
}

func (s *NonReservedContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *NonReservedContext) REPLACE_IF_NOT_NULL() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE_IF_NOT_NULL, 0)
}

func (s *NonReservedContext) REPLAYER() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLAYER, 0)
}

func (s *NonReservedContext) REPOSITORIES() antlr.TerminalNode {
	return s.GetToken(DorisParserREPOSITORIES, 0)
}

func (s *NonReservedContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisParserREPOSITORY, 0)
}

func (s *NonReservedContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCE, 0)
}

func (s *NonReservedContext) RESOURCES() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCES, 0)
}

func (s *NonReservedContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESTORE, 0)
}

func (s *NonReservedContext) RESTRICTIVE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESTRICTIVE, 0)
}

func (s *NonReservedContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisParserRESUME, 0)
}

func (s *NonReservedContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(DorisParserRETURNS, 0)
}

func (s *NonReservedContext) REWRITTEN() antlr.TerminalNode {
	return s.GetToken(DorisParserREWRITTEN, 0)
}

func (s *NonReservedContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACE, 0)
}

func (s *NonReservedContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserRLIKE, 0)
}

func (s *NonReservedContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLBACK, 0)
}

func (s *NonReservedContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *NonReservedContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserROUTINE, 0)
}

func (s *NonReservedContext) S3() antlr.TerminalNode {
	return s.GetToken(DorisParserS3, 0)
}

func (s *NonReservedContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(DorisParserSAMPLE, 0)
}

func (s *NonReservedContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEDULE, 0)
}

func (s *NonReservedContext) SCHEDULER() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEDULER, 0)
}

func (s *NonReservedContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEMA, 0)
}

func (s *NonReservedContext) SECOND() antlr.TerminalNode {
	return s.GetToken(DorisParserSECOND, 0)
}

func (s *NonReservedContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserSERIALIZABLE, 0)
}

func (s *NonReservedContext) SET_SESSION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserSET_SESSION_VARIABLE, 0)
}

func (s *NonReservedContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION, 0)
}

func (s *NonReservedContext) SESSION_USER() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION_USER, 0)
}

func (s *NonReservedContext) SHAPE() antlr.TerminalNode {
	return s.GetToken(DorisParserSHAPE, 0)
}

func (s *NonReservedContext) SKEW() antlr.TerminalNode {
	return s.GetToken(DorisParserSKEW, 0)
}

func (s *NonReservedContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisParserSNAPSHOT, 0)
}

func (s *NonReservedContext) SONAME() antlr.TerminalNode {
	return s.GetToken(DorisParserSONAME, 0)
}

func (s *NonReservedContext) SPLIT() antlr.TerminalNode {
	return s.GetToken(DorisParserSPLIT, 0)
}

func (s *NonReservedContext) SQL() antlr.TerminalNode {
	return s.GetToken(DorisParserSQL, 0)
}

func (s *NonReservedContext) STAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTAGE, 0)
}

func (s *NonReservedContext) STAGES() antlr.TerminalNode {
	return s.GetToken(DorisParserSTAGES, 0)
}

func (s *NonReservedContext) START() antlr.TerminalNode {
	return s.GetToken(DorisParserSTART, 0)
}

func (s *NonReservedContext) STARTS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTARTS, 0)
}

func (s *NonReservedContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *NonReservedContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATUS, 0)
}

func (s *NonReservedContext) STOP() antlr.TerminalNode {
	return s.GetToken(DorisParserSTOP, 0)
}

func (s *NonReservedContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *NonReservedContext) STREAM() antlr.TerminalNode {
	return s.GetToken(DorisParserSTREAM, 0)
}

func (s *NonReservedContext) STREAMING() antlr.TerminalNode {
	return s.GetToken(DorisParserSTREAMING, 0)
}

func (s *NonReservedContext) STRING() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING, 0)
}

func (s *NonReservedContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRUCT, 0)
}

func (s *NonReservedContext) SUM() antlr.TerminalNode {
	return s.GetToken(DorisParserSUM, 0)
}

func (s *NonReservedContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLES, 0)
}

func (s *NonReservedContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisParserTASK, 0)
}

func (s *NonReservedContext) TASKS() antlr.TerminalNode {
	return s.GetToken(DorisParserTASKS, 0)
}

func (s *NonReservedContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *NonReservedContext) TEXT() antlr.TerminalNode {
	return s.GetToken(DorisParserTEXT, 0)
}

func (s *NonReservedContext) THAN() antlr.TerminalNode {
	return s.GetToken(DorisParserTHAN, 0)
}

func (s *NonReservedContext) TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserTIME, 0)
}

func (s *NonReservedContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserTIMESTAMP, 0)
}

func (s *NonReservedContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisParserTRANSACTION, 0)
}

func (s *NonReservedContext) TREE() antlr.TerminalNode {
	return s.GetToken(DorisParserTREE, 0)
}

func (s *NonReservedContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(DorisParserTRIGGERS, 0)
}

func (s *NonReservedContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(DorisParserTRUNCATE, 0)
}

func (s *NonReservedContext) TYPE() antlr.TerminalNode {
	return s.GetToken(DorisParserTYPE, 0)
}

func (s *NonReservedContext) TYPES() antlr.TerminalNode {
	return s.GetToken(DorisParserTYPES, 0)
}

func (s *NonReservedContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(DorisParserUNCOMMITTED, 0)
}

func (s *NonReservedContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(DorisParserUNLOCK, 0)
}

func (s *NonReservedContext) UNSET() antlr.TerminalNode {
	return s.GetToken(DorisParserUNSET, 0)
}

func (s *NonReservedContext) UP() antlr.TerminalNode {
	return s.GetToken(DorisParserUP, 0)
}

func (s *NonReservedContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisParserUSER, 0)
}

func (s *NonReservedContext) VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserVALUE, 0)
}

func (s *NonReservedContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserVARCHAR, 0)
}

func (s *NonReservedContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserVARIABLE, 0)
}

func (s *NonReservedContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserVARIABLES, 0)
}

func (s *NonReservedContext) VARIANT() antlr.TerminalNode {
	return s.GetToken(DorisParserVARIANT, 0)
}

func (s *NonReservedContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULT, 0)
}

func (s *NonReservedContext) VAULTS() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULTS, 0)
}

func (s *NonReservedContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserVERBOSE, 0)
}

func (s *NonReservedContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisParserVERSION, 0)
}

func (s *NonReservedContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *NonReservedContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEWS, 0)
}

func (s *NonReservedContext) WARM() antlr.TerminalNode {
	return s.GetToken(DorisParserWARM, 0)
}

func (s *NonReservedContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(DorisParserWARNINGS, 0)
}

func (s *NonReservedContext) WEEK() antlr.TerminalNode {
	return s.GetToken(DorisParserWEEK, 0)
}

func (s *NonReservedContext) WORK() antlr.TerminalNode {
	return s.GetToken(DorisParserWORK, 0)
}

func (s *NonReservedContext) YEAR() antlr.TerminalNode {
	return s.GetToken(DorisParserYEAR, 0)
}

func (s *NonReservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonReservedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterNonReserved(s)
	}
}

func (s *NonReservedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitNonReserved(s)
	}
}

func (p *DorisParser) NonReserved() (localctx INonReservedContext) {
	localctx = NewNonReservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, DorisParserRULE_nonReserved)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6086)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-9)) & ^0x3f) == 0 && ((int64(1)<<(_la-9))&9096145289322186643) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&7373517661452369851) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&-1597439773797254365) != 0) || ((int64((_la-204)) & ^0x3f) == 0 && ((int64(1)<<(_la-204))&-230342327107757065) != 0) || ((int64((_la-269)) & ^0x3f) == 0 && ((int64(1)<<(_la-269))&-1403300050241541) != 0) || ((int64((_la-334)) & ^0x3f) == 0 && ((int64(1)<<(_la-334))&-894528642195917699) != 0) || ((int64((_la-398)) & ^0x3f) == 0 && ((int64(1)<<(_la-398))&-5526558290639631131) != 0) || ((int64((_la-463)) & ^0x3f) == 0 && ((int64(1)<<(_la-463))&2017612706344838321) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *DorisParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 113:
		var t *QueryTermContext = nil
		if localctx != nil {
			t = localctx.(*QueryTermContext)
		}
		return p.QueryTerm_Sempred(t, predIndex)

	case 116:
		var t *QuerySpecificationContext = nil
		if localctx != nil {
			t = localctx.(*QuerySpecificationContext)
		}
		return p.QuerySpecification_Sempred(t, predIndex)

	case 185:
		var t *BooleanExpressionContext = nil
		if localctx != nil {
			t = localctx.(*BooleanExpressionContext)
		}
		return p.BooleanExpression_Sempred(t, predIndex)

	case 189:
		var t *ValueExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ValueExpressionContext)
		}
		return p.ValueExpression_Sempred(t, predIndex)

	case 190:
		var t *PrimaryExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryExpressionContext)
		}
		return p.PrimaryExpression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *DorisParser) QueryTerm_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DorisParser) QuerySpecification_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return doris_legacy_SQL_syntax

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DorisParser) BooleanExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DorisParser) ValueExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DorisParser) PrimaryExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 13:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
