// Code generated from DorisParser.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // DorisParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type DorisParser struct {
	*antlr.BaseParser
}

var DorisParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func dorisparserParserInit() {
	staticData := &DorisParserParserStaticData
	staticData.LiteralNames = []string{
		"", "';'", "'('", "')'", "','", "'.'", "'...'", "'['", "']'", "'{'",
		"'}'", "'ACCOUNT_LOCK'", "'ACCOUNT_UNLOCK'", "'ACTIONS'", "'ADD'", "'ADDDATE'",
		"'ADMIN'", "'AFTER'", "'AGG_STATE'", "'AGGREGATE'", "'ALIAS'", "'ALL'",
		"'ALTER'", "'ANALYZE'", "'ANALYZED'", "'AND'", "'ANTI'", "'APPEND'",
		"'ARRAY'", "'ARRAY_RANGE'", "'AS'", "'ASC'", "'AT'", "'AUTHORS'", "'AUTO'",
		"'AUTO_INCREMENT'", "'ALWAYS'", "'BACKEND'", "'BACKENDS'", "'BACKUP'",
		"'BEGIN'", "'BELONG'", "'BETWEEN'", "'BIGINT'", "'BIN'", "'BINARY'",
		"'BINLOG'", "'BITAND'", "'BITMAP'", "'BITMAP_UNION'", "'BITOR'", "'BITXOR'",
		"'BLOB'", "'BOOLEAN'", "'BRIEF'", "'BROKER'", "'BUCKETS'", "'BUILD'",
		"'BUILTIN'", "'BULK'", "'BY'", "'CACHE'", "'CACHED'", "'CALL'", "'CANCEL'",
		"'CASE'", "'CAST'", "'CATALOG'", "'CATALOGS'", "'CHAIN'", "", "'CHARSET'",
		"'CHECK'", "'CLEAN'", "'CLUSTER'", "'CLUSTERS'", "'COLLATE'", "'COLLATION'",
		"'COLLECT'", "'COLOCATE'", "'COLUMN'", "'COLUMNS'", "'COMMENT'", "'COMMIT'",
		"'COMMITTED'", "'COMPACT'", "'COMPLETE'", "'COMPRESS_TYPE'", "'CONDITIONS'",
		"'CONFIG'", "'CONNECTION'", "'CONNECTION_ID'", "'CONSISTENT'", "'CONSTRAINT'",
		"'CONSTRAINTS'", "'CONVERT'", "'CONVERT_LSC'", "'COPY'", "'COUNT'",
		"'CREATE'", "'CREATION'", "'CRON'", "'CROSS'", "'CUBE'", "'CURRENT'",
		"'CURRENT_CATALOG'", "'CURRENT_DATE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'",
		"'CURRENT_USER'", "'DATA'", "'DATABASE'", "'DATABASES'", "'DATE'", "'DATE_ADD'",
		"'DATE_CEIL'", "'DATE_DIFF'", "'DATE_FLOOR'", "'DATE_SUB'", "'DATEADD'",
		"'DATEDIFF'", "'DATETIME'", "'DATETIMEV2'", "'DATEV2'", "'DATETIMEV1'",
		"'DATEV1'", "'DAY'", "'DAYS_ADD'", "'DAYS_SUB'", "'DECIMAL'", "'DECIMALV2'",
		"'DECIMALV3'", "'DECOMMISSION'", "'DEFAULT'", "'DEFERRED'", "'DELETE'",
		"'DEMAND'", "'DESC'", "'DESCRIBE'", "'DIAGNOSE'", "'DISK'", "'DISTINCT'",
		"'DISTINCTPC'", "'DISTINCTPCSA'", "'DISTRIBUTED'", "'DISTRIBUTION'",
		"'DIV'", "'DO'", "'DORIS_INTERNAL_TABLE_ID'", "'DOUBLE'", "'DROP'",
		"'DROPP'", "'DUAL'", "'DUPLICATE'", "'DYNAMIC'", "'ELSE'", "'ENABLE'",
		"'ENCRYPTKEY'", "'ENCRYPTKEYS'", "'END'", "'ENDS'", "'ENGINE'", "'ENGINES'",
		"'ENTER'", "'ERRORS'", "'EVENTS'", "'EVERY'", "'EXCEPT'", "'EXCLUDE'",
		"'EXECUTE'", "'EXISTS'", "'EXPIRED'", "'EXPLAIN'", "'EXPORT'", "'EXTENDED'",
		"'EXTERNAL'", "'EXTRACT'", "'FAILED_LOGIN_ATTEMPTS'", "'FALSE'", "'FAST'",
		"'FEATURE'", "'FIELDS'", "'FILE'", "'FILTER'", "'FIRST'", "'FLOAT'",
		"'FOLLOWER'", "'FOLLOWING'", "'FOR'", "'FOREIGN'", "'FORCE'", "'FORMAT'",
		"'FREE'", "'FROM'", "'FRONTEND'", "'FRONTENDS'", "'FULL'", "'FUNCTION'",
		"'FUNCTIONS'", "'GENERATED'", "'GENERIC'", "'GLOBAL'", "'GRANT'", "'GRANTS'",
		"'GRAPH'", "'GROUP'", "'GROUPING'", "'GROUPS'", "'HASH'", "'HAVING'",
		"'HDFS'", "'HELP'", "'HISTOGRAM'", "'HLL'", "'HLL_UNION'", "'HOSTNAME'",
		"'HOTSPOT'", "'HOUR'", "'HUB'", "'IDENTIFIED'", "'IF'", "'IGNORE'",
		"'IMMEDIATE'", "'IN'", "'INCREMENTAL'", "'INDEX'", "'INDEXES'", "'INFILE'",
		"'INNER'", "'INSERT'", "'INSTALL'", "'INT'", "'INTEGER'", "'INTERMEDIATE'",
		"'INTERSECT'", "'INTERVAL'", "'INTO'", "'INVERTED'", "'IPV4'", "'IPV6'",
		"'IS'", "'IS_NOT_NULL_PRED'", "'IS_NULL_PRED'", "'ISNULL'", "'ISOLATION'",
		"'JOB'", "'JOBS'", "'JOIN'", "'JSON'", "'JSONB'", "'KEY'", "'KEYS'",
		"'KILL'", "'LABEL'", "'LARGEINT'", "'LAST'", "'LATERAL'", "'LDAP'",
		"'LDAP_ADMIN_PASSWORD'", "'LEFT'", "'LESS'", "'LEVEL'", "'LIKE'", "'LIMIT'",
		"'LINES'", "'LINK'", "'LIST'", "'LOAD'", "'LOCAL'", "'LOCALTIME'", "'LOCALTIMESTAMP'",
		"'LOCATION'", "'LOCK'", "'LOGICAL'", "'LOW_PRIORITY'", "'MANUAL'", "'MAP'",
		"'MATCH'", "'MATCH_ALL'", "'MATCH_ANY'", "'MATCH_PHRASE'", "'MATCH_PHRASE_EDGE'",
		"'MATCH_PHRASE_PREFIX'", "'MATCH_REGEXP'", "'MATERIALIZED'", "'MAX'",
		"'MAXVALUE'", "'MEMO'", "'MERGE'", "'MIGRATE'", "'MIGRATIONS'", "'MIN'",
		"'MINUS'", "'MINUTE'", "'MODIFY'", "'MONTH'", "'MTMV'", "'NAME'", "'NAMES'",
		"'NATURAL'", "'NEGATIVE'", "'NEVER'", "'NEXT'", "'NGRAM_BF'", "'NO'",
		"'NON_NULLABLE'", "'NOT'", "'NULL'", "'NULLS'", "'OBSERVER'", "'OF'",
		"'OFFSET'", "'ON'", "'ONLY'", "'OPEN'", "'OPTIMIZED'", "'OR'", "'ORDER'",
		"'OUTER'", "'OUTFILE'", "'OVER'", "'OVERWRITE'", "'PARAMETER'", "'PARSED'",
		"'PARTITION'", "'PARTITIONS'", "'PASSWORD'", "'PASSWORD_EXPIRE'", "'PASSWORD_HISTORY'",
		"'PASSWORD_LOCK_TIME'", "'PASSWORD_REUSE'", "'PATH'", "'PAUSE'", "'PERCENT'",
		"'PERIOD'", "'PERMISSIVE'", "'PHYSICAL'", "'PI'", "'?'", "'PLAN'", "'PRIVILEGES'",
		"'PROCESS'", "'PLUGIN'", "'PLUGINS'", "'POLICY'", "'PRECEDING'", "'PREPARE'",
		"'PRIMARY'", "'PROC'", "'PROCEDURE'", "'PROCESSLIST'", "'PROFILE'",
		"'PROPERTIES'", "'PROPERTY'", "'QUANTILE_STATE'", "'QUANTILE_UNION'",
		"'QUERY'", "'QUOTA'", "'RANDOM'", "'RANGE'", "'READ'", "'REAL'", "'REBALANCE'",
		"'RECENT'", "'RECOVER'", "'RECYCLE'", "'REFRESH'", "'REFERENCES'", "'REGEXP'",
		"'RELEASE'", "'RENAME'", "'REPAIR'", "'REPEATABLE'", "'REPLACE'", "'REPLACE_IF_NOT_NULL'",
		"'REPLICA'", "'REPOSITORIES'", "'REPOSITORY'", "'RESOURCE'", "'RESOURCES'",
		"'RESTORE'", "'RESTRICTIVE'", "'RESUME'", "'RETURNS'", "'REVOKE'", "'REWRITTEN'",
		"'RIGHT'", "'RLIKE'", "'ROLE'", "'ROLES'", "'ROLLBACK'", "'ROLLUP'",
		"'ROUTINE'", "'ROW'", "'ROWS'", "'S3'", "'SAMPLE'", "'SCHEDULE'", "'SCHEDULER'",
		"'SCHEMA'", "'SCHEMAS'", "'SECOND'", "'SELECT'", "'SEMI'", "'SEQUENCE'",
		"'SERIALIZABLE'", "'SESSION'", "'SET'", "'SETS'", "'SET_SESSION_VARIABLE'",
		"'SHAPE'", "'SHOW'", "'SIGNED'", "'SKEW'", "'SMALLINT'", "'SNAPSHOT'",
		"'SONAME'", "'SPLIT'", "'SQL'", "'SQL_BLOCK_RULE'", "'STAGE'", "'STAGES'",
		"'START'", "'STARTS'", "'STATS'", "'STATUS'", "'STOP'", "'STORAGE'",
		"'STREAM'", "'STREAMING'", "'STRING'", "'STRUCT'", "'SUBDATE'", "'SUM'",
		"'SUPERUSER'", "'SWITCH'", "'SYNC'", "'SYSTEM'", "'TABLE'", "'TABLES'",
		"'TABLESAMPLE'", "'TABLET'", "'TABLETS'", "'TASK'", "'TASKS'", "'TEMPORARY'",
		"'TERMINATED'", "'TEXT'", "'THAN'", "'THEN'", "'TIME'", "'TIMESTAMP'",
		"'TIMESTAMPADD'", "'TIMESTAMPDIFF'", "'TINYINT'", "'TO'", "'TRANSACTION'",
		"'TRASH'", "'TREE'", "'TRIGGERS'", "'TRIM'", "'TRUE'", "'TRUNCATE'",
		"'TYPE'", "'TYPE_CAST'", "'TYPES'", "'UNBOUNDED'", "'UNCOMMITTED'",
		"'UNINSTALL'", "'UNION'", "'UNIQUE'", "'UNLOCK'", "'UNSET'", "'UNSIGNED'",
		"'UP'", "'UPDATE'", "'USE'", "'USER'", "'USING'", "'VALUE'", "'VALUES'",
		"'VARCHAR'", "'VARIABLE'", "'VARIABLES'", "'VARIANT'", "'VAULT'", "'VERBOSE'",
		"'VERSION'", "'VIEW'", "'WARM'", "'WARNINGS'", "'WEEK'", "'WHEN'", "'WHERE'",
		"'WHITELIST'", "'WITH'", "'WORK'", "'WORKLOAD'", "'WRITE'", "'XOR'",
		"'YEAR'", "", "'<=>'", "", "'<'", "", "'>'", "", "'+'", "'-'", "'*'",
		"'/'", "'%'", "'~'", "'&'", "'&&'", "'!'", "'|'", "'||'", "'^'", "':'",
		"'->'", "'/*+'", "'*/'", "'/*'", "'@'", "'@@'",
	}
	staticData.SymbolicNames = []string{
		"", "SEMICOLON", "LEFT_PAREN", "RIGHT_PAREN", "COMMA", "DOT", "DOTDOTDOT",
		"LEFT_BRACKET", "RIGHT_BRACKET", "LEFT_BRACE", "RIGHT_BRACE", "ACCOUNT_LOCK",
		"ACCOUNT_UNLOCK", "ACTIONS", "ADD", "ADDDATE", "ADMIN", "AFTER", "AGG_STATE",
		"AGGREGATE", "ALIAS", "ALL", "ALTER", "ANALYZE", "ANALYZED", "AND",
		"ANTI", "APPEND", "ARRAY", "ARRAY_RANGE", "AS", "ASC", "AT", "AUTHORS",
		"AUTO", "AUTO_INCREMENT", "ALWAYS", "BACKEND", "BACKENDS", "BACKUP",
		"BEGIN", "BELONG", "BETWEEN", "BIGINT", "BIN", "BINARY", "BINLOG", "BITAND",
		"BITMAP", "BITMAP_UNION", "BITOR", "BITXOR", "BLOB", "BOOLEAN", "BRIEF",
		"BROKER", "BUCKETS", "BUILD", "BUILTIN", "BULK", "BY", "CACHE", "CACHED",
		"CALL", "CANCEL", "CASE", "CAST", "CATALOG", "CATALOGS", "CHAIN", "CHAR",
		"CHARSET", "CHECK", "CLEAN", "CLUSTER", "CLUSTERS", "COLLATE", "COLLATION",
		"COLLECT", "COLOCATE", "COLUMN", "COLUMNS", "COMMENT", "COMMIT", "COMMITTED",
		"COMPACT", "COMPLETE", "COMPRESS_TYPE", "CONDITIONS", "CONFIG", "CONNECTION",
		"CONNECTION_ID", "CONSISTENT", "CONSTRAINT", "CONSTRAINTS", "CONVERT",
		"CONVERT_LSC", "COPY", "COUNT", "CREATE", "CREATION", "CRON", "CROSS",
		"CUBE", "CURRENT", "CURRENT_CATALOG", "CURRENT_DATE", "CURRENT_TIME",
		"CURRENT_TIMESTAMP", "CURRENT_USER", "DATA", "DATABASE", "DATABASES",
		"DATE", "DATE_ADD", "DATE_CEIL", "DATE_DIFF", "DATE_FLOOR", "DATE_SUB",
		"DATEADD", "DATEDIFF", "DATETIME", "DATETIMEV2", "DATEV2", "DATETIMEV1",
		"DATEV1", "DAY", "DAYS_ADD", "DAYS_SUB", "DECIMAL", "DECIMALV2", "DECIMALV3",
		"DECOMMISSION", "DEFAULT", "DEFERRED", "DELETE", "DEMAND", "DESC", "DESCRIBE",
		"DIAGNOSE", "DISK", "DISTINCT", "DISTINCTPC", "DISTINCTPCSA", "DISTRIBUTED",
		"DISTRIBUTION", "DIV", "DO", "DORIS_INTERNAL_TABLE_ID", "DOUBLE", "DROP",
		"DROPP", "DUAL", "DUPLICATE", "DYNAMIC", "ELSE", "ENABLE", "ENCRYPTKEY",
		"ENCRYPTKEYS", "END", "ENDS", "ENGINE", "ENGINES", "ENTER", "ERRORS",
		"EVENTS", "EVERY", "EXCEPT", "EXCLUDE", "EXECUTE", "EXISTS", "EXPIRED",
		"EXPLAIN", "EXPORT", "EXTENDED", "EXTERNAL", "EXTRACT", "FAILED_LOGIN_ATTEMPTS",
		"FALSE", "FAST", "FEATURE", "FIELDS", "FILE", "FILTER", "FIRST", "FLOAT",
		"FOLLOWER", "FOLLOWING", "FOR", "FOREIGN", "FORCE", "FORMAT", "FREE",
		"FROM", "FRONTEND", "FRONTENDS", "FULL", "FUNCTION", "FUNCTIONS", "GENERATED",
		"GENERIC", "GLOBAL", "GRANT", "GRANTS", "GRAPH", "GROUP", "GROUPING",
		"GROUPS", "HASH", "HAVING", "HDFS", "HELP", "HISTOGRAM", "HLL", "HLL_UNION",
		"HOSTNAME", "HOTSPOT", "HOUR", "HUB", "IDENTIFIED", "IF", "IGNORE",
		"IMMEDIATE", "IN", "INCREMENTAL", "INDEX", "INDEXES", "INFILE", "INNER",
		"INSERT", "INSTALL", "INT", "INTEGER", "INTERMEDIATE", "INTERSECT",
		"INTERVAL", "INTO", "INVERTED", "IPV4", "IPV6", "IS", "IS_NOT_NULL_PRED",
		"IS_NULL_PRED", "ISNULL", "ISOLATION", "JOB", "JOBS", "JOIN", "JSON",
		"JSONB", "KEY", "KEYS", "KILL", "LABEL", "LARGEINT", "LAST", "LATERAL",
		"LDAP", "LDAP_ADMIN_PASSWORD", "LEFT", "LESS", "LEVEL", "LIKE", "LIMIT",
		"LINES", "LINK", "LIST", "LOAD", "LOCAL", "LOCALTIME", "LOCALTIMESTAMP",
		"LOCATION", "LOCK", "LOGICAL", "LOW_PRIORITY", "MANUAL", "MAP", "MATCH",
		"MATCH_ALL", "MATCH_ANY", "MATCH_PHRASE", "MATCH_PHRASE_EDGE", "MATCH_PHRASE_PREFIX",
		"MATCH_REGEXP", "MATERIALIZED", "MAX", "MAXVALUE", "MEMO", "MERGE",
		"MIGRATE", "MIGRATIONS", "MIN", "MINUS", "MINUTE", "MODIFY", "MONTH",
		"MTMV", "NAME", "NAMES", "NATURAL", "NEGATIVE", "NEVER", "NEXT", "NGRAM_BF",
		"NO", "NON_NULLABLE", "NOT", "NULL", "NULLS", "OBSERVER", "OF", "OFFSET",
		"ON", "ONLY", "OPEN", "OPTIMIZED", "OR", "ORDER", "OUTER", "OUTFILE",
		"OVER", "OVERWRITE", "PARAMETER", "PARSED", "PARTITION", "PARTITIONS",
		"PASSWORD", "PASSWORD_EXPIRE", "PASSWORD_HISTORY", "PASSWORD_LOCK_TIME",
		"PASSWORD_REUSE", "PATH", "PAUSE", "PERCENT", "PERIOD", "PERMISSIVE",
		"PHYSICAL", "PI", "PLACEHOLDER", "PLAN", "PRIVILEGES", "PROCESS", "PLUGIN",
		"PLUGINS", "POLICY", "PRECEDING", "PREPARE", "PRIMARY", "PROC", "PROCEDURE",
		"PROCESSLIST", "PROFILE", "PROPERTIES", "PROPERTY", "QUANTILE_STATE",
		"QUANTILE_UNION", "QUERY", "QUOTA", "RANDOM", "RANGE", "READ", "REAL",
		"REBALANCE", "RECENT", "RECOVER", "RECYCLE", "REFRESH", "REFERENCES",
		"REGEXP", "RELEASE", "RENAME", "REPAIR", "REPEATABLE", "REPLACE", "REPLACE_IF_NOT_NULL",
		"REPLICA", "REPOSITORIES", "REPOSITORY", "RESOURCE", "RESOURCES", "RESTORE",
		"RESTRICTIVE", "RESUME", "RETURNS", "REVOKE", "REWRITTEN", "RIGHT",
		"RLIKE", "ROLE", "ROLES", "ROLLBACK", "ROLLUP", "ROUTINE", "ROW", "ROWS",
		"S3", "SAMPLE", "SCHEDULE", "SCHEDULER", "SCHEMA", "SCHEMAS", "SECOND",
		"SELECT", "SEMI", "SEQUENCE", "SERIALIZABLE", "SESSION", "SET", "SETS",
		"SET_SESSION_VARIABLE", "SHAPE", "SHOW", "SIGNED", "SKEW", "SMALLINT",
		"SNAPSHOT", "SONAME", "SPLIT", "SQL", "SQL_BLOCK_RULE", "STAGE", "STAGES",
		"START", "STARTS", "STATS", "STATUS", "STOP", "STORAGE", "STREAM", "STREAMING",
		"STRING", "STRUCT", "SUBDATE", "SUM", "SUPERUSER", "SWITCH", "SYNC",
		"SYSTEM", "TABLE", "TABLES", "TABLESAMPLE", "TABLET", "TABLETS", "TASK",
		"TASKS", "TEMPORARY", "TERMINATED", "TEXT", "THAN", "THEN", "TIME",
		"TIMESTAMP", "TIMESTAMPADD", "TIMESTAMPDIFF", "TINYINT", "TO", "TRANSACTION",
		"TRASH", "TREE", "TRIGGERS", "TRIM", "TRUE", "TRUNCATE", "TYPE", "TYPECAST",
		"TYPES", "UNBOUNDED", "UNCOMMITTED", "UNINSTALL", "UNION", "UNIQUE",
		"UNLOCK", "UNSET", "UNSIGNED", "UP", "UPDATE", "USE", "USER", "USING",
		"VALUE", "VALUES", "VARCHAR", "VARIABLE", "VARIABLES", "VARIANT", "VAULT",
		"VERBOSE", "VERSION", "VIEW", "WARM", "WARNINGS", "WEEK", "WHEN", "WHERE",
		"WHITELIST", "WITH", "WORK", "WORKLOAD", "WRITE", "XOR", "YEAR", "EQ",
		"NSEQ", "NEQ", "LT", "LTE", "GT", "GTE", "PLUS", "SUBTRACT", "ASTERISK",
		"SLASH", "MOD", "TILDE", "AMPERSAND", "LOGICALAND", "LOGICALNOT", "PIPE",
		"DOUBLEPIPES", "HAT", "COLON", "ARROW", "HINT_START", "HINT_END", "COMMENT_START",
		"ATSIGN", "DOUBLEATSIGN", "STRING_LITERAL", "LEADING_STRING", "BIGINT_LITERAL",
		"SMALLINT_LITERAL", "TINYINT_LITERAL", "INTEGER_VALUE", "EXPONENT_VALUE",
		"DECIMAL_VALUE", "BIGDECIMAL_LITERAL", "IDENTIFIER", "BACKQUOTED_IDENTIFIER",
		"SIMPLE_COMMENT", "BRACKETED_COMMENT", "FROM_DUAL", "WS", "UNRECOGNIZED",
	}
	staticData.RuleNames = []string{
		"multiStatements", "singleStatement", "statement", "statementBase",
		"unsupportedStatement", "materailizedViewStatement", "constraintStatement",
		"supportedDmlStatement", "supportedCreateStatement", "supportedAlterStatement",
		"supportedDropStatement", "unsupportedAdminStatement", "baseTableRef",
		"wildWhere", "unsupportedTransactionStatement", "unsupportedGrantRevokeStatement",
		"privilege", "privilegeList", "unsupportedAlterStatement", "alterSystemClause",
		"dropRollupClause", "addRollupClause", "alterTableClause", "columnPosition",
		"toRollup", "fromRollup", "unsupportedDropStatement", "unsupportedStatsStatement",
		"unsupportedCreateStatement", "channelDescriptions", "channelDescription",
		"workloadPolicyActions", "workloadPolicyAction", "workloadPolicyConditions",
		"workloadPolicyCondition", "storageBackend", "passwordOption", "functionArguments",
		"functionArgument", "unsupportedSetStatement", "optionWithType", "optionWithoutType",
		"variable", "transactionAccessMode", "isolationLevel", "unsupoortedUnsetStatement",
		"unsupportedUseStatement", "unsupportedDmlStatement", "unsupportedKillStatement",
		"unsupportedDescribeStatement", "constraint", "partitionSpec", "partitionTable",
		"identityOrFunctionList", "identityOrFunction", "dataDesc", "buildMode",
		"refreshTrigger", "refreshSchedule", "refreshMethod", "mvPartition",
		"identifierOrText", "identifierOrTextOrAsterisk", "multipartIdentifierOrAsterisk",
		"identifierOrAsterisk", "userIdentify", "grantUserIdentify", "explain",
		"explainCommand", "planType", "mergeType", "preFilterClause", "deleteOnClause",
		"sequenceColClause", "colFromPath", "colMappingList", "mappingExpr",
		"withRemoteStorageSystem", "resourceDesc", "mysqlDataDesc", "skipLines",
		"outFileClause", "query", "queryTerm", "setQuantifier", "queryPrimary",
		"querySpecification", "cte", "aliasQuery", "columnAliases", "selectClause",
		"selectColumnClause", "whereClause", "fromClause", "intoClause", "bulkCollectClause",
		"tableRow", "relations", "relation", "joinRelation", "distributeType",
		"relationHint", "aggClause", "groupingElement", "groupingSet", "havingClause",
		"selectHint", "hintStatement", "hintAssignment", "updateAssignment",
		"updateAssignmentSeq", "lateralView", "queryOrganization", "sortClause",
		"sortItem", "limitClause", "partitionClause", "joinType", "joinCriteria",
		"identifierList", "identifierSeq", "optScanParams", "relationPrimary",
		"materializedViewName", "propertyClause", "propertyItemList", "propertyItem",
		"propertyKey", "propertyValue", "tableAlias", "multipartIdentifier",
		"simpleColumnDefs", "simpleColumnDef", "columnDefs", "columnDef", "indexDefs",
		"indexDef", "partitionsDef", "partitionDef", "lessThanPartitionDef",
		"fixedPartitionDef", "stepPartitionDef", "inPartitionDef", "partitionValueList",
		"partitionValueDef", "rollupDefs", "rollupDef", "aggTypeDef", "tabletList",
		"inlineTable", "namedExpression", "namedExpressionSeq", "expression",
		"lambdaExpression", "booleanExpression", "rowConstructor", "rowConstructorItem",
		"predicate", "valueExpression", "datetimeUnit", "primaryExpression",
		"exceptOrReplace", "castDataType", "functionCallExpression", "functionIdentifier",
		"functionNameIdentifier", "windowSpec", "windowFrame", "frameUnits",
		"frameBoundary", "qualifiedName", "specifiedPartition", "constant",
		"comparisonOperator", "booleanValue", "whenClause", "interval", "unitIdentifier",
		"dataTypeWithNullable", "dataType", "primitiveColType", "complexColTypeList",
		"complexColType", "commentSpec", "sample", "sampleMethod", "tableSnapshot",
		"errorCapturingIdentifier", "errorCapturingIdentifierExtra", "identifier",
		"strictIdentifier", "quotedIdentifier", "number", "nonReserved",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 542, 4626, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 1,
		0, 5, 0, 390, 8, 0, 10, 0, 12, 0, 393, 9, 0, 1, 0, 3, 0, 396, 8, 0, 1,
		0, 4, 0, 399, 8, 0, 11, 0, 12, 0, 400, 1, 0, 5, 0, 404, 8, 0, 10, 0, 12,
		0, 407, 9, 0, 1, 0, 5, 0, 410, 8, 0, 10, 0, 12, 0, 413, 9, 0, 1, 0, 1,
		0, 1, 1, 5, 1, 418, 8, 1, 10, 1, 12, 1, 421, 9, 1, 1, 1, 3, 1, 424, 8,
		1, 1, 1, 5, 1, 427, 8, 1, 10, 1, 12, 1, 430, 9, 1, 1, 1, 1, 1, 1, 2, 1,
		2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 5, 2, 441, 8, 2, 10, 2, 12, 2, 444, 9,
		2, 3, 2, 446, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 454, 8, 2,
		1, 2, 3, 2, 457, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 5, 2, 463, 8, 2, 10, 2,
		12, 2, 466, 9, 2, 1, 2, 1, 2, 5, 2, 470, 8, 2, 10, 2, 12, 2, 473, 9, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 479, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		1, 2, 1, 2, 3, 2, 488, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 495, 8,
		2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 502, 8, 2, 1, 2, 1, 2, 3, 2, 506,
		8, 2, 3, 2, 508, 8, 2, 1, 3, 3, 3, 511, 8, 3, 1, 3, 1, 3, 3, 3, 515, 8,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 524, 8, 3, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3,
		4, 539, 8, 4, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 547, 8, 5, 1, 5,
		1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 554, 8, 5, 1, 5, 3, 5, 557, 8, 5, 1, 5, 1,
		5, 3, 5, 561, 8, 5, 1, 5, 3, 5, 564, 8, 5, 3, 5, 566, 8, 5, 1, 5, 3, 5,
		569, 8, 5, 1, 5, 1, 5, 3, 5, 573, 8, 5, 1, 5, 1, 5, 3, 5, 577, 8, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 585, 8, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 3, 5, 592, 8, 5, 1, 5, 1, 5, 3, 5, 596, 8, 5, 3, 5, 598, 8, 5,
		1, 5, 3, 5, 601, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5,
		1, 5, 1, 5, 3, 5, 613, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5,
		1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 627, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5,
		1, 5, 1, 5, 3, 5, 635, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 642, 8,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 649, 8, 5, 1, 5, 1, 5, 1, 5, 3,
		5, 654, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 3, 5, 680, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1,
		6, 3, 6, 701, 8, 6, 1, 7, 3, 7, 704, 8, 7, 1, 7, 3, 7, 707, 8, 7, 1, 7,
		1, 7, 1, 7, 1, 7, 3, 7, 713, 8, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7,
		720, 8, 7, 1, 7, 3, 7, 723, 8, 7, 1, 7, 1, 7, 1, 7, 3, 7, 728, 8, 7, 1,
		7, 3, 7, 731, 8, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 737, 8, 7, 1, 7, 1, 7,
		3, 7, 741, 8, 7, 1, 7, 3, 7, 744, 8, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1,
		7, 3, 7, 752, 8, 7, 1, 7, 3, 7, 755, 8, 7, 1, 7, 3, 7, 758, 8, 7, 1, 7,
		3, 7, 761, 8, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 767, 8, 7, 1, 7, 1, 7, 1,
		7, 3, 7, 772, 8, 7, 1, 7, 3, 7, 775, 8, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7,
		1, 7, 1, 7, 5, 7, 784, 8, 7, 10, 7, 12, 7, 787, 9, 7, 1, 7, 1, 7, 3, 7,
		791, 8, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 798, 8, 7, 1, 7, 3, 7, 801,
		8, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 810, 8, 7, 1, 7,
		3, 7, 813, 8, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 820, 8, 7, 1, 7, 3,
		7, 823, 8, 7, 1, 7, 1, 7, 1, 7, 3, 7, 828, 8, 7, 1, 7, 3, 7, 831, 8, 7,
		3, 7, 833, 8, 7, 1, 8, 1, 8, 3, 8, 837, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3,
		8, 843, 8, 8, 1, 8, 1, 8, 3, 8, 847, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8,
		853, 8, 8, 1, 8, 3, 8, 856, 8, 8, 1, 8, 1, 8, 3, 8, 860, 8, 8, 1, 8, 1,
		8, 1, 8, 3, 8, 865, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 873,
		8, 8, 3, 8, 875, 8, 8, 1, 8, 1, 8, 3, 8, 879, 8, 8, 1, 8, 3, 8, 882, 8,
		8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 889, 8, 8, 1, 8, 1, 8, 1, 8, 3,
		8, 894, 8, 8, 3, 8, 896, 8, 8, 3, 8, 898, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 3, 8, 905, 8, 8, 1, 8, 3, 8, 908, 8, 8, 1, 8, 1, 8, 3, 8, 912, 8,
		8, 1, 8, 1, 8, 3, 8, 916, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 923,
		8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 930, 8, 8, 1, 8, 1, 8, 3, 8,
		934, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 941, 8, 8, 1, 8, 1, 8, 1,
		8, 1, 8, 3, 8, 947, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 955,
		8, 8, 3, 8, 957, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 965, 8,
		8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 976, 8,
		8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 983, 8, 8, 1, 9, 1, 9, 1, 9, 1,
		9, 1, 9, 1, 9, 1, 9, 3, 9, 992, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1,
		9, 1, 9, 1, 9, 1, 9, 3, 9, 1003, 8, 9, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1,
		11, 3, 11, 1021, 8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11,
		1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1,
		11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11,
		1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3,
		11, 1061, 8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 1068, 8, 11,
		1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 1075, 8, 11, 1, 11, 3, 11, 1078,
		8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 1084, 8, 11, 1, 11, 1, 11, 1,
		11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 1096, 8, 11,
		1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1,
		11, 3, 11, 1109, 8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11,
		1, 11, 1, 11, 1, 11, 3, 11, 1121, 8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1,
		11, 1, 11, 1, 11, 3, 11, 1130, 8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11,
		1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 1142, 8, 11, 1, 11, 1, 11, 1,
		11, 1, 11, 1, 11, 3, 11, 1149, 8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11,
		1, 11, 3, 11, 1157, 8, 11, 3, 11, 1159, 8, 11, 1, 12, 1, 12, 3, 12, 1163,
		8, 12, 1, 12, 3, 12, 1166, 8, 12, 1, 12, 3, 12, 1169, 8, 12, 1, 12, 3,
		12, 1172, 8, 12, 1, 12, 1, 12, 3, 12, 1176, 8, 12, 1, 12, 3, 12, 1179,
		8, 12, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1185, 8, 13, 1, 14, 1, 14, 1,
		14, 1, 14, 3, 14, 1191, 8, 14, 3, 14, 1193, 8, 14, 1, 14, 1, 14, 3, 14,
		1197, 8, 14, 1, 14, 1, 14, 3, 14, 1201, 8, 14, 1, 14, 3, 14, 1204, 8, 14,
		1, 14, 3, 14, 1207, 8, 14, 1, 14, 3, 14, 1210, 8, 14, 1, 14, 1, 14, 3,
		14, 1214, 8, 14, 1, 14, 1, 14, 3, 14, 1218, 8, 14, 1, 14, 3, 14, 1221,
		8, 14, 1, 14, 3, 14, 1224, 8, 14, 1, 14, 3, 14, 1227, 8, 14, 3, 14, 1229,
		8, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 1239,
		8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1,
		15, 3, 15, 1251, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 1258,
		8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 5, 15, 1264, 8, 15, 10, 15, 12, 15,
		1267, 9, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1,
		15, 1, 15, 3, 15, 1279, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15,
		1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 1291, 8, 15, 1, 15, 1, 15, 1, 15, 1,
		15, 1, 15, 3, 15, 1298, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 5, 15, 1304,
		8, 15, 10, 15, 12, 15, 1307, 9, 15, 1, 15, 1, 15, 3, 15, 1311, 8, 15, 1,
		16, 1, 16, 3, 16, 1315, 8, 16, 1, 16, 3, 16, 1318, 8, 16, 1, 17, 1, 17,
		1, 17, 5, 17, 1323, 8, 17, 10, 17, 12, 17, 1326, 9, 17, 1, 18, 1, 18, 1,
		18, 1, 18, 1, 18, 1, 18, 5, 18, 1334, 8, 18, 10, 18, 12, 18, 1337, 9, 18,
		1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 5, 18, 1347, 8,
		18, 10, 18, 12, 18, 1350, 9, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 1, 18, 1, 18, 5, 18, 1360, 8, 18, 10, 18, 12, 18, 1363, 9, 18, 1, 18,
		1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3,
		18, 1376, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18,
		1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18,
		1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 1, 18, 3, 18, 1419, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18,
		1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 1435, 8,
		18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 1442, 8, 18, 1, 18, 1, 18,
		1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 1450, 8, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 1, 18, 1, 18, 3, 18, 1458, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18,
		1464, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18,
		1484, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 1490, 8, 18, 1, 18, 1,
		18, 1, 18, 1, 18, 3, 18, 1496, 8, 18, 3, 18, 1498, 8, 18, 1, 19, 1, 19,
		1, 19, 1, 19, 1, 19, 5, 19, 1505, 8, 19, 10, 19, 12, 19, 1508, 9, 19, 1,
		19, 3, 19, 1511, 8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 5, 19, 1518,
		8, 19, 10, 19, 12, 19, 1521, 9, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19,
		5, 19, 1528, 8, 19, 10, 19, 12, 19, 1531, 9, 19, 1, 19, 1, 19, 1, 19, 1,
		19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19,
		1, 19, 1, 19, 1, 19, 1, 19, 5, 19, 1551, 8, 19, 10, 19, 12, 19, 1554, 9,
		19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 5, 19, 1562, 8, 19, 10, 19,
		12, 19, 1565, 9, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1,
		19, 1, 19, 3, 19, 1576, 8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 5, 19,
		1583, 8, 19, 10, 19, 12, 19, 1586, 9, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1,
		19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 1598, 8, 19, 1, 20, 1, 20,
		3, 20, 1602, 8, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 3, 21, 1609, 8,
		21, 1, 21, 3, 21, 1612, 8, 21, 1, 21, 3, 21, 1615, 8, 21, 1, 22, 1, 22,
		1, 22, 1, 22, 3, 22, 1621, 8, 22, 1, 22, 3, 22, 1624, 8, 22, 1, 22, 3,
		22, 1627, 8, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 5, 22, 1635,
		8, 22, 10, 22, 12, 22, 1638, 9, 22, 1, 22, 1, 22, 3, 22, 1642, 8, 22, 1,
		22, 3, 22, 1645, 8, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 1651, 8, 22,
		1, 22, 3, 22, 1654, 8, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 1660, 8,
		22, 1, 22, 3, 22, 1663, 8, 22, 1, 22, 3, 22, 1666, 8, 22, 1, 22, 1, 22,
		1, 22, 1, 22, 3, 22, 1672, 8, 22, 1, 22, 3, 22, 1675, 8, 22, 1, 22, 1,
		22, 3, 22, 1679, 8, 22, 1, 22, 1, 22, 1, 22, 3, 22, 1684, 8, 22, 1, 22,
		1, 22, 1, 22, 1, 22, 3, 22, 1690, 8, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1,
		22, 3, 22, 1697, 8, 22, 1, 22, 1, 22, 1, 22, 3, 22, 1702, 8, 22, 3, 22,
		1704, 8, 22, 3, 22, 1706, 8, 22, 1, 22, 3, 22, 1709, 8, 22, 1, 22, 1, 22,
		3, 22, 1713, 8, 22, 1, 22, 1, 22, 1, 22, 3, 22, 1718, 8, 22, 1, 22, 1,
		22, 3, 22, 1722, 8, 22, 1, 22, 1, 22, 1, 22, 3, 22, 1727, 8, 22, 1, 22,
		1, 22, 3, 22, 1731, 8, 22, 1, 22, 1, 22, 1, 22, 3, 22, 1736, 8, 22, 1,
		22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 1743, 8, 22, 1, 22, 1, 22, 1, 22,
		1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 1752, 8, 22, 1, 22, 1, 22, 3, 22, 1756,
		8, 22, 1, 22, 3, 22, 1759, 8, 22, 1, 22, 3, 22, 1762, 8, 22, 1, 22, 1,
		22, 1, 22, 1, 22, 1, 22, 3, 22, 1769, 8, 22, 1, 22, 1, 22, 1, 22, 1, 22,
		1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1,
		22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 1794,
		8, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 1802, 8, 22, 1,
		22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 1811, 8, 22, 1, 22,
		1, 22, 1, 22, 3, 22, 1816, 8, 22, 3, 22, 1818, 8, 22, 3, 22, 1820, 8, 22,
		1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1,
		22, 1, 22, 1, 22, 1, 22, 3, 22, 1836, 8, 22, 1, 22, 1, 22, 3, 22, 1840,
		8, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 1850,
		8, 22, 1, 22, 3, 22, 1853, 8, 22, 3, 22, 1855, 8, 22, 1, 23, 1, 23, 1,
		23, 3, 23, 1860, 8, 23, 1, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1, 25, 1, 26,
		1, 26, 1, 26, 1, 26, 3, 26, 1872, 8, 26, 1, 26, 1, 26, 3, 26, 1876, 8,
		26, 1, 26, 1, 26, 1, 26, 1, 26, 3, 26, 1882, 8, 26, 1, 26, 1, 26, 1, 26,
		3, 26, 1887, 8, 26, 1, 26, 1, 26, 1, 26, 3, 26, 1892, 8, 26, 1, 26, 1,
		26, 1, 26, 3, 26, 1897, 8, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26,
		3, 26, 1905, 8, 26, 1, 26, 1, 26, 3, 26, 1909, 8, 26, 1, 26, 1, 26, 1,
		26, 1, 26, 3, 26, 1915, 8, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 3, 26,
		1922, 8, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 3,
		26, 1932, 8, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 3, 26, 1940,
		8, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 3, 26, 1947, 8, 26, 1, 26, 1,
		26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 3, 26, 1957, 8, 26, 1, 26,
		1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 3, 26, 1965, 8, 26, 1, 26, 1, 26, 1,
		26, 1, 26, 1, 26, 1, 26, 3, 26, 1973, 8, 26, 1, 26, 1, 26, 1, 26, 1, 26,
		1, 26, 3, 26, 1980, 8, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 3, 26, 1987,
		8, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 3, 26, 1995, 8, 26, 1,
		26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 3, 26, 2004, 8, 26, 3, 26,
		2006, 8, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 3, 26, 2013, 8, 26, 1,
		26, 1, 26, 1, 26, 1, 26, 1, 26, 3, 26, 2020, 8, 26, 1, 26, 3, 26, 2023,
		8, 26, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 3,
		27, 2034, 8, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 3, 27, 2041, 8, 27,
		1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 3, 27, 2052,
		8, 27, 1, 27, 1, 27, 1, 27, 1, 27, 3, 27, 2058, 8, 27, 1, 27, 3, 27, 2061,
		8, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1,
		27, 1, 27, 3, 27, 2074, 8, 27, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28,
		2081, 8, 28, 1, 28, 1, 28, 3, 28, 2085, 8, 28, 1, 28, 1, 28, 1, 28, 1,
		28, 1, 28, 3, 28, 2092, 8, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 2098,
		8, 28, 1, 28, 1, 28, 3, 28, 2102, 8, 28, 1, 28, 3, 28, 2105, 8, 28, 1,
		28, 1, 28, 3, 28, 2109, 8, 28, 1, 28, 3, 28, 2112, 8, 28, 1, 28, 1, 28,
		1, 28, 1, 28, 3, 28, 2118, 8, 28, 1, 28, 1, 28, 1, 28, 3, 28, 2123, 8,
		28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 2130, 8, 28, 1, 28, 3, 28,
		2133, 8, 28, 1, 28, 1, 28, 3, 28, 2137, 8, 28, 1, 28, 1, 28, 1, 28, 1,
		28, 1, 28, 3, 28, 2144, 8, 28, 1, 28, 1, 28, 1, 28, 3, 28, 2149, 8, 28,
		1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 2156, 8, 28, 1, 28, 1, 28, 1,
		28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 2167, 8, 28, 1, 28,
		1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 2174, 8, 28, 1, 28, 1, 28, 1, 28, 3,
		28, 2179, 8, 28, 1, 28, 1, 28, 1, 28, 3, 28, 2184, 8, 28, 1, 28, 1, 28,
		1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 2196, 8,
		28, 1, 28, 1, 28, 1, 28, 3, 28, 2201, 8, 28, 1, 28, 1, 28, 1, 28, 1, 28,
		1, 28, 3, 28, 2208, 8, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3,
		28, 2216, 8, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 2224,
		8, 28, 1, 28, 3, 28, 2227, 8, 28, 1, 28, 1, 28, 3, 28, 2231, 8, 28, 1,
		28, 1, 28, 3, 28, 2235, 8, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 2241,
		8, 28, 1, 28, 1, 28, 3, 28, 2245, 8, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1,
		28, 1, 28, 3, 28, 2253, 8, 28, 1, 28, 1, 28, 3, 28, 2257, 8, 28, 1, 28,
		1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 2265, 8, 28, 1, 28, 1, 28, 3,
		28, 2269, 8, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 2277,
		8, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 2285, 8, 28, 1,
		28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 2292, 8, 28, 1, 28, 3, 28, 2295,
		8, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 2302, 8, 28, 1, 28, 1,
		28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28,
		1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 2322, 8, 28, 1, 28, 1,
		28, 1, 28, 1, 28, 1, 28, 3, 28, 2329, 8, 28, 1, 28, 1, 28, 3, 28, 2333,
		8, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 2341, 8, 28, 1,
		28, 1, 28, 3, 28, 2345, 8, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28,
		3, 28, 2353, 8, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 2360, 8,
		28, 1, 28, 1, 28, 3, 28, 2364, 8, 28, 3, 28, 2366, 8, 28, 1, 29, 1, 29,
		1, 29, 5, 29, 2371, 8, 29, 10, 29, 12, 29, 2374, 9, 29, 1, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 3, 30, 2381, 8, 30, 1, 30, 3, 30, 2384, 8, 30, 1, 31,
		1, 31, 1, 31, 5, 31, 2389, 8, 31, 10, 31, 12, 31, 2392, 9, 31, 1, 32, 1,
		32, 1, 32, 1, 32, 3, 32, 2398, 8, 32, 3, 32, 2400, 8, 32, 1, 33, 1, 33,
		1, 33, 5, 33, 2405, 8, 33, 10, 33, 12, 33, 2408, 9, 33, 1, 34, 1, 34, 1,
		34, 1, 34, 3, 34, 2414, 8, 34, 1, 35, 1, 35, 3, 35, 2418, 8, 35, 1, 35,
		1, 35, 1, 35, 1, 35, 3, 35, 2424, 8, 35, 1, 36, 1, 36, 1, 36, 3, 36, 2429,
		8, 36, 3, 36, 2431, 8, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 3,
		36, 2439, 8, 36, 3, 36, 2441, 8, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36,
		3, 36, 2448, 8, 36, 3, 36, 2450, 8, 36, 1, 36, 1, 36, 3, 36, 2454, 8, 36,
		1, 36, 1, 36, 1, 36, 1, 36, 3, 36, 2460, 8, 36, 3, 36, 2462, 8, 36, 1,
		36, 3, 36, 2465, 8, 36, 1, 37, 1, 37, 1, 37, 5, 37, 2470, 8, 37, 10, 37,
		12, 37, 2473, 9, 37, 1, 38, 1, 38, 3, 38, 2477, 8, 38, 1, 39, 1, 39, 1,
		39, 3, 39, 2482, 8, 39, 1, 39, 1, 39, 1, 39, 3, 39, 2487, 8, 39, 5, 39,
		2489, 8, 39, 10, 39, 12, 39, 2492, 9, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1,
		39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 3, 39, 2505, 8, 39, 1, 39,
		1, 39, 1, 39, 3, 39, 2510, 8, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1,
		39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 3, 39, 2523, 8, 39, 3, 39, 2525,
		8, 39, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 2532, 8, 40, 1, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 2540, 8, 41, 1, 41, 1, 41, 3, 41,
		2544, 8, 41, 1, 41, 1, 41, 1, 41, 3, 41, 2549, 8, 41, 1, 41, 1, 41, 1,
		41, 3, 41, 2554, 8, 41, 1, 41, 1, 41, 1, 41, 3, 41, 2559, 8, 41, 1, 41,
		1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 2567, 8, 41, 1, 41, 1, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 2576, 8, 41, 1, 41, 3, 41, 2579,
		8, 41, 1, 42, 1, 42, 1, 42, 3, 42, 2584, 8, 42, 3, 42, 2586, 8, 42, 1,
		42, 1, 42, 1, 42, 1, 42, 3, 42, 2592, 8, 42, 1, 42, 1, 42, 1, 42, 1, 42,
		1, 42, 3, 42, 2599, 8, 42, 1, 43, 1, 43, 1, 43, 1, 44, 1, 44, 1, 44, 1,
		44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 3, 44, 2613, 8, 44, 1, 45, 1, 45,
		3, 45, 2617, 8, 45, 1, 45, 1, 45, 1, 45, 3, 45, 2622, 8, 45, 1, 45, 1,
		45, 1, 45, 1, 45, 3, 45, 2628, 8, 45, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46,
		2634, 8, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 2641, 8, 46, 1,
		46, 3, 46, 2644, 8, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 2650, 8, 46,
		1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 2656, 8, 47, 1, 48, 1, 48, 3, 48, 2660,
		8, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 2666, 8, 48, 1, 49, 1, 49, 1,
		49, 1, 49, 1, 49, 3, 49, 2673, 8, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49,
		1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 2685, 8, 49, 3, 49, 2687, 8,
		49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50,
		1, 50, 1, 50, 3, 50, 2701, 8, 50, 1, 51, 3, 51, 2704, 8, 51, 1, 51, 1,
		51, 1, 51, 3, 51, 2709, 8, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51,
		3, 51, 2717, 8, 51, 1, 52, 3, 52, 2720, 8, 52, 1, 52, 1, 52, 1, 52, 3,
		52, 2725, 8, 52, 1, 52, 1, 52, 1, 52, 3, 52, 2730, 8, 52, 1, 52, 1, 52,
		1, 53, 1, 53, 1, 53, 1, 53, 5, 53, 2738, 8, 53, 10, 53, 12, 53, 2741, 9,
		53, 1, 53, 1, 53, 1, 54, 1, 54, 3, 54, 2747, 8, 54, 1, 55, 3, 55, 2750,
		8, 55, 1, 55, 3, 55, 2753, 8, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1,
		55, 5, 55, 2761, 8, 55, 10, 55, 12, 55, 2764, 9, 55, 1, 55, 1, 55, 1, 55,
		1, 55, 1, 55, 1, 55, 3, 55, 2772, 8, 55, 1, 55, 1, 55, 1, 55, 1, 55, 3,
		55, 2778, 8, 55, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 2784, 8, 55, 1, 55,
		1, 55, 1, 55, 3, 55, 2789, 8, 55, 1, 55, 3, 55, 2792, 8, 55, 1, 55, 3,
		55, 2795, 8, 55, 1, 55, 3, 55, 2798, 8, 55, 1, 55, 3, 55, 2801, 8, 55,
		1, 55, 3, 55, 2804, 8, 55, 1, 55, 3, 55, 2807, 8, 55, 1, 55, 3, 55, 2810,
		8, 55, 1, 55, 3, 55, 2813, 8, 55, 1, 55, 3, 55, 2816, 8, 55, 1, 55, 3,
		55, 2819, 8, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55,
		1, 55, 3, 55, 2830, 8, 55, 1, 55, 3, 55, 2833, 8, 55, 1, 55, 3, 55, 2836,
		8, 55, 1, 55, 3, 55, 2839, 8, 55, 1, 55, 3, 55, 2842, 8, 55, 3, 55, 2844,
		8, 55, 1, 56, 1, 56, 1, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1,
		57, 3, 57, 2856, 8, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 2863,
		8, 58, 1, 59, 1, 59, 1, 60, 1, 60, 3, 60, 2869, 8, 60, 1, 61, 1, 61, 3,
		61, 2873, 8, 61, 1, 62, 1, 62, 1, 62, 3, 62, 2878, 8, 62, 1, 63, 1, 63,
		1, 63, 5, 63, 2883, 8, 63, 10, 63, 12, 63, 2886, 9, 63, 1, 64, 1, 64, 3,
		64, 2890, 8, 64, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65,
		2899, 8, 65, 3, 65, 2901, 8, 65, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66, 2907,
		8, 66, 1, 66, 3, 66, 2910, 8, 66, 1, 67, 1, 67, 3, 67, 2914, 8, 67, 1,
		67, 3, 67, 2917, 8, 67, 1, 67, 3, 67, 2920, 8, 67, 1, 68, 1, 68, 1, 69,
		1, 69, 1, 70, 1, 70, 1, 71, 1, 71, 1, 71, 1, 71, 1, 72, 1, 72, 1, 72, 1,
		72, 1, 73, 1, 73, 1, 73, 1, 73, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74,
		1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 5, 75, 2951, 8, 75, 10, 75, 12, 75,
		2954, 9, 75, 1, 75, 1, 75, 1, 76, 1, 76, 1, 76, 1, 76, 1, 77, 1, 77, 1,
		77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77,
		1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1,
		77, 1, 77, 1, 77, 3, 77, 2988, 8, 77, 3, 77, 2990, 8, 77, 1, 78, 1, 78,
		1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 2999, 8, 78, 1, 79, 1, 79, 1,
		79, 3, 79, 3004, 8, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79,
		3, 79, 3013, 8, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 3019, 8, 79, 1,
		79, 1, 79, 1, 79, 1, 79, 3, 79, 3025, 8, 79, 1, 79, 3, 79, 3028, 8, 79,
		1, 79, 3, 79, 3031, 8, 79, 1, 79, 3, 79, 3034, 8, 79, 1, 79, 3, 79, 3037,
		8, 79, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 3, 80, 3045, 8, 80, 1,
		81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 3, 81, 3053, 8, 81, 1, 81, 3, 81,
		3056, 8, 81, 1, 82, 3, 82, 3059, 8, 82, 1, 82, 1, 82, 1, 82, 1, 83, 1,
		83, 1, 83, 1, 83, 1, 83, 1, 83, 3, 83, 3070, 8, 83, 1, 83, 1, 83, 1, 83,
		1, 83, 3, 83, 3076, 8, 83, 1, 83, 5, 83, 3079, 8, 83, 10, 83, 12, 83, 3082,
		9, 83, 1, 84, 1, 84, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 3, 85, 3092,
		8, 85, 1, 86, 1, 86, 3, 86, 3096, 8, 86, 1, 86, 3, 86, 3099, 8, 86, 1,
		86, 3, 86, 3102, 8, 86, 1, 86, 3, 86, 3105, 8, 86, 1, 86, 3, 86, 3108,
		8, 86, 1, 86, 1, 86, 1, 86, 1, 87, 1, 87, 1, 87, 1, 87, 5, 87, 3117, 8,
		87, 10, 87, 12, 87, 3120, 9, 87, 1, 88, 1, 88, 3, 88, 3124, 8, 88, 1, 88,
		1, 88, 1, 88, 1, 88, 1, 88, 1, 89, 1, 89, 1, 89, 1, 89, 5, 89, 3135, 8,
		89, 10, 89, 12, 89, 3138, 9, 89, 1, 89, 1, 89, 1, 90, 1, 90, 3, 90, 3144,
		8, 90, 1, 90, 3, 90, 3147, 8, 90, 1, 90, 1, 90, 1, 91, 1, 91, 1, 92, 1,
		92, 1, 92, 1, 93, 1, 93, 1, 93, 1, 94, 3, 94, 3160, 8, 94, 1, 94, 1, 94,
		1, 94, 3, 94, 3165, 8, 94, 1, 94, 1, 94, 1, 94, 3, 94, 3170, 8, 94, 5,
		94, 3172, 8, 94, 10, 94, 12, 94, 3175, 9, 94, 1, 95, 1, 95, 1, 95, 1, 96,
		1, 96, 1, 96, 1, 96, 1, 96, 1, 97, 1, 97, 1, 97, 5, 97, 3188, 8, 97, 10,
		97, 12, 97, 3191, 9, 97, 1, 98, 1, 98, 5, 98, 3195, 8, 98, 10, 98, 12,
		98, 3198, 9, 98, 1, 99, 1, 99, 1, 99, 3, 99, 3203, 8, 99, 1, 99, 1, 99,
		3, 99, 3207, 8, 99, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1,
		100, 1, 100, 3, 100, 3217, 8, 100, 1, 101, 1, 101, 1, 101, 1, 101, 5, 101,
		3223, 8, 101, 10, 101, 12, 101, 3226, 9, 101, 1, 101, 1, 101, 1, 101, 1,
		101, 1, 101, 1, 101, 5, 101, 3234, 8, 101, 10, 101, 12, 101, 3237, 9, 101,
		1, 101, 1, 101, 3, 101, 3241, 8, 101, 1, 102, 1, 102, 1, 102, 1, 102, 1,
		103, 1, 103, 1, 103, 1, 103, 1, 103, 5, 103, 3252, 8, 103, 10, 103, 12,
		103, 3255, 9, 103, 3, 103, 3257, 8, 103, 1, 103, 1, 103, 1, 103, 1, 103,
		1, 103, 1, 103, 5, 103, 3265, 8, 103, 10, 103, 12, 103, 3268, 9, 103, 3,
		103, 3270, 8, 103, 1, 103, 1, 103, 1, 103, 1, 103, 1, 103, 1, 103, 1, 103,
		5, 103, 3279, 8, 103, 10, 103, 12, 103, 3282, 9, 103, 1, 103, 1, 103, 1,
		103, 1, 103, 1, 103, 5, 103, 3289, 8, 103, 10, 103, 12, 103, 3292, 9, 103,
		3, 103, 3294, 8, 103, 1, 104, 1, 104, 1, 104, 1, 104, 5, 104, 3300, 8,
		104, 10, 104, 12, 104, 3303, 9, 104, 3, 104, 3305, 8, 104, 1, 104, 1, 104,
		1, 105, 1, 105, 1, 105, 1, 106, 1, 106, 3, 106, 3314, 8, 106, 1, 106, 5,
		106, 3317, 8, 106, 10, 106, 12, 106, 3320, 9, 106, 1, 106, 1, 106, 1, 107,
		1, 107, 1, 107, 1, 107, 3, 107, 3328, 8, 107, 1, 107, 5, 107, 3331, 8,
		107, 10, 107, 12, 107, 3334, 9, 107, 1, 107, 1, 107, 3, 107, 3338, 8, 107,
		1, 108, 1, 108, 1, 108, 1, 108, 3, 108, 3344, 8, 108, 3, 108, 3346, 8,
		108, 1, 108, 3, 108, 3349, 8, 108, 1, 109, 1, 109, 1, 109, 1, 109, 3, 109,
		3355, 8, 109, 1, 110, 1, 110, 1, 110, 5, 110, 3360, 8, 110, 10, 110, 12,
		110, 3363, 9, 110, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111,
		5, 111, 3372, 8, 111, 10, 111, 12, 111, 3375, 9, 111, 3, 111, 3377, 8,
		111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 5, 111, 3385, 8, 111,
		10, 111, 12, 111, 3388, 9, 111, 1, 112, 3, 112, 3391, 8, 112, 1, 112, 3,
		112, 3394, 8, 112, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 5, 113, 3401,
		8, 113, 10, 113, 12, 113, 3404, 9, 113, 1, 114, 1, 114, 3, 114, 3408, 8,
		114, 1, 114, 1, 114, 3, 114, 3412, 8, 114, 1, 115, 1, 115, 1, 115, 1, 115,
		1, 115, 1, 115, 1, 115, 1, 115, 1, 115, 1, 115, 3, 115, 3424, 8, 115, 1,
		116, 1, 116, 1, 116, 1, 116, 1, 116, 5, 116, 3431, 8, 116, 10, 116, 12,
		116, 3434, 9, 116, 1, 117, 3, 117, 3437, 8, 117, 1, 117, 1, 117, 1, 117,
		3, 117, 3442, 8, 117, 1, 117, 1, 117, 3, 117, 3446, 8, 117, 1, 117, 1,
		117, 3, 117, 3450, 8, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117,
		1, 117, 1, 117, 3, 117, 3460, 8, 117, 1, 118, 1, 118, 1, 118, 1, 118, 3,
		118, 3466, 8, 118, 1, 119, 1, 119, 1, 119, 1, 119, 1, 120, 1, 120, 1, 120,
		5, 120, 3475, 8, 120, 10, 120, 12, 120, 3478, 9, 120, 1, 121, 1, 121, 1,
		121, 1, 121, 3, 121, 3484, 8, 121, 1, 121, 1, 121, 1, 122, 1, 122, 3, 122,
		3490, 8, 122, 1, 122, 3, 122, 3493, 8, 122, 1, 122, 3, 122, 3496, 8, 122,
		1, 122, 3, 122, 3499, 8, 122, 1, 122, 3, 122, 3502, 8, 122, 1, 122, 1,
		122, 3, 122, 3506, 8, 122, 1, 122, 3, 122, 3509, 8, 122, 1, 122, 5, 122,
		3512, 8, 122, 10, 122, 12, 122, 3515, 9, 122, 1, 122, 1, 122, 1, 122, 1,
		122, 1, 122, 5, 122, 3522, 8, 122, 10, 122, 12, 122, 3525, 9, 122, 1, 122,
		1, 122, 1, 122, 3, 122, 3530, 8, 122, 1, 122, 1, 122, 1, 122, 1, 122, 1,
		122, 1, 122, 1, 122, 3, 122, 3539, 8, 122, 1, 123, 1, 123, 1, 123, 1, 124,
		1, 124, 1, 124, 1, 124, 1, 124, 1, 125, 1, 125, 1, 125, 5, 125, 3552, 8,
		125, 10, 125, 12, 125, 3555, 9, 125, 1, 126, 1, 126, 1, 126, 1, 126, 1,
		127, 1, 127, 3, 127, 3563, 8, 127, 1, 128, 1, 128, 3, 128, 3567, 8, 128,
		1, 129, 3, 129, 3570, 8, 129, 1, 129, 1, 129, 3, 129, 3574, 8, 129, 3,
		129, 3576, 8, 129, 1, 130, 1, 130, 1, 130, 5, 130, 3581, 8, 130, 10, 130,
		12, 130, 3584, 9, 130, 1, 131, 1, 131, 1, 131, 5, 131, 3589, 8, 131, 10,
		131, 12, 131, 3592, 9, 131, 1, 132, 1, 132, 1, 132, 3, 132, 3597, 8, 132,
		1, 133, 1, 133, 1, 133, 5, 133, 3602, 8, 133, 10, 133, 12, 133, 3605, 9,
		133, 1, 134, 1, 134, 1, 134, 3, 134, 3610, 8, 134, 1, 134, 3, 134, 3613,
		8, 134, 1, 134, 1, 134, 3, 134, 3617, 8, 134, 1, 134, 1, 134, 1, 134, 1,
		134, 1, 134, 3, 134, 3624, 8, 134, 1, 134, 3, 134, 3627, 8, 134, 1, 134,
		3, 134, 3630, 8, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 3, 134, 3637,
		8, 134, 3, 134, 3639, 8, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1,
		134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 3, 134, 3653, 8, 134,
		3, 134, 3655, 8, 134, 3, 134, 3657, 8, 134, 1, 134, 1, 134, 1, 134, 1,
		134, 1, 134, 1, 134, 1, 134, 3, 134, 3666, 8, 134, 3, 134, 3668, 8, 134,
		1, 134, 1, 134, 3, 134, 3672, 8, 134, 1, 135, 1, 135, 1, 135, 5, 135, 3677,
		8, 135, 10, 135, 12, 135, 3680, 9, 135, 1, 136, 1, 136, 1, 136, 1, 136,
		3, 136, 3686, 8, 136, 1, 136, 1, 136, 1, 136, 1, 136, 3, 136, 3692, 8,
		136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 3, 136, 3699, 8, 136, 1, 136,
		1, 136, 3, 136, 3703, 8, 136, 1, 137, 1, 137, 1, 137, 5, 137, 3708, 8,
		137, 10, 137, 12, 137, 3711, 9, 137, 1, 138, 1, 138, 1, 138, 1, 138, 3,
		138, 3717, 8, 138, 1, 138, 1, 138, 1, 138, 1, 138, 3, 138, 3723, 8, 138,
		1, 139, 1, 139, 1, 139, 1, 139, 3, 139, 3729, 8, 139, 1, 139, 1, 139, 1,
		139, 1, 139, 1, 139, 1, 139, 3, 139, 3737, 8, 139, 1, 140, 1, 140, 1, 140,
		1, 140, 3, 140, 3743, 8, 140, 1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 1,
		140, 1, 140, 1, 140, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1,
		141, 3, 141, 3760, 8, 141, 1, 142, 1, 142, 1, 142, 1, 142, 3, 142, 3766,
		8, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 5, 142,
		3775, 8, 142, 10, 142, 12, 142, 3778, 9, 142, 1, 142, 1, 142, 1, 142, 3,
		142, 3783, 8, 142, 3, 142, 3785, 8, 142, 1, 143, 1, 143, 1, 143, 1, 143,
		5, 143, 3791, 8, 143, 10, 143, 12, 143, 3794, 9, 143, 1, 143, 1, 143, 1,
		144, 1, 144, 1, 145, 1, 145, 1, 145, 5, 145, 3803, 8, 145, 10, 145, 12,
		145, 3806, 9, 145, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 3, 146, 3813,
		8, 146, 1, 146, 3, 146, 3816, 8, 146, 1, 147, 1, 147, 1, 148, 1, 148, 1,
		148, 1, 148, 1, 148, 5, 148, 3825, 8, 148, 10, 148, 12, 148, 3828, 9, 148,
		1, 148, 1, 148, 1, 149, 1, 149, 1, 149, 1, 149, 5, 149, 3836, 8, 149, 10,
		149, 12, 149, 3839, 9, 149, 1, 150, 1, 150, 3, 150, 3843, 8, 150, 1, 150,
		3, 150, 3846, 8, 150, 1, 151, 1, 151, 1, 151, 5, 151, 3851, 8, 151, 10,
		151, 12, 151, 3854, 9, 151, 1, 152, 1, 152, 3, 152, 3858, 8, 152, 1, 153,
		1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 4, 153, 3868, 8,
		153, 11, 153, 12, 153, 3869, 1, 153, 1, 153, 1, 153, 1, 153, 3, 153, 3876,
		8, 153, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154,
		1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154,
		1, 154, 1, 154, 1, 154, 3, 154, 3898, 8, 154, 3, 154, 3900, 8, 154, 1,
		154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1,
		154, 1, 154, 1, 154, 5, 154, 3914, 8, 154, 10, 154, 12, 154, 3917, 9, 154,
		1, 155, 1, 155, 1, 155, 1, 155, 5, 155, 3923, 8, 155, 10, 155, 12, 155,
		3926, 9, 155, 3, 155, 3928, 8, 155, 1, 155, 1, 155, 1, 156, 1, 156, 3,
		156, 3934, 8, 156, 1, 157, 3, 157, 3937, 8, 157, 1, 157, 1, 157, 1, 157,
		1, 157, 1, 157, 1, 157, 3, 157, 3945, 8, 157, 1, 157, 1, 157, 1, 157, 3,
		157, 3950, 8, 157, 1, 157, 1, 157, 1, 157, 3, 157, 3955, 8, 157, 1, 157,
		1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 3, 157, 3963, 8, 157, 1, 157, 1,
		157, 1, 157, 1, 157, 1, 157, 5, 157, 3970, 8, 157, 10, 157, 12, 157, 3973,
		9, 157, 1, 157, 1, 157, 1, 157, 1, 157, 3, 157, 3979, 8, 157, 1, 157, 1,
		157, 1, 157, 3, 157, 3984, 8, 157, 1, 157, 3, 157, 3987, 8, 157, 1, 158,
		1, 158, 1, 158, 1, 158, 1, 158, 1, 158, 1, 158, 1, 158, 1, 158, 1, 158,
		1, 158, 3, 158, 4000, 8, 158, 1, 158, 1, 158, 1, 158, 1, 158, 1, 158, 1,
		158, 1, 158, 1, 158, 1, 158, 1, 158, 5, 158, 4012, 8, 158, 10, 158, 12,
		158, 4015, 9, 158, 1, 159, 1, 159, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160,
		1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160,
		1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160,
		1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 3, 160, 4047, 8, 160, 1, 160, 1,
		160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1,
		160, 3, 160, 4060, 8, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160,
		1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 3, 160, 4073, 8, 160, 1, 160, 1,
		160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1,
		160, 3, 160, 4086, 8, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160,
		1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 3, 160, 4101, 8,
		160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1,
		160, 1, 160, 4, 160, 4113, 8, 160, 11, 160, 12, 160, 4114, 1, 160, 1, 160,
		3, 160, 4119, 8, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 4, 160, 4126,
		8, 160, 11, 160, 12, 160, 4127, 1, 160, 1, 160, 3, 160, 4132, 8, 160, 1,
		160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1,
		160, 1, 160, 1, 160, 1, 160, 5, 160, 4147, 8, 160, 10, 160, 12, 160, 4150,
		9, 160, 1, 160, 1, 160, 1, 160, 1, 160, 5, 160, 4156, 8, 160, 10, 160,
		12, 160, 4159, 9, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 5, 160,
		4166, 8, 160, 10, 160, 12, 160, 4169, 9, 160, 1, 160, 1, 160, 3, 160, 4173,
		8, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160,
		1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160,
		1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160,
		3, 160, 4201, 8, 160, 1, 160, 1, 160, 3, 160, 4205, 8, 160, 1, 160, 1,
		160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 3, 160, 4216,
		8, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 3, 160, 4224, 8,
		160, 1, 160, 1, 160, 1, 160, 3, 160, 4229, 8, 160, 1, 160, 1, 160, 1, 160,
		1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 3, 160, 4241, 8,
		160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1,
		160, 1, 160, 3, 160, 4253, 8, 160, 5, 160, 4255, 8, 160, 10, 160, 12, 160,
		4258, 9, 160, 1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 1,
		161, 1, 161, 1, 161, 3, 161, 4270, 8, 161, 1, 162, 1, 162, 1, 162, 3, 162,
		4275, 8, 162, 3, 162, 4277, 8, 162, 1, 163, 1, 163, 1, 163, 3, 163, 4282,
		8, 163, 1, 163, 1, 163, 1, 163, 5, 163, 4287, 8, 163, 10, 163, 12, 163,
		4290, 9, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 5, 163, 4297, 8,
		163, 10, 163, 12, 163, 4300, 9, 163, 3, 163, 4302, 8, 163, 3, 163, 4304,
		8, 163, 1, 163, 1, 163, 1, 163, 3, 163, 4309, 8, 163, 1, 164, 1, 164, 1,
		164, 3, 164, 4314, 8, 164, 1, 164, 1, 164, 1, 165, 1, 165, 1, 165, 1, 165,
		1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165,
		1, 165, 1, 165, 3, 165, 4333, 8, 165, 1, 166, 1, 166, 3, 166, 4337, 8,
		166, 1, 166, 3, 166, 4340, 8, 166, 1, 166, 3, 166, 4343, 8, 166, 1, 166,
		1, 166, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167,
		1, 167, 3, 167, 4356, 8, 167, 1, 168, 1, 168, 1, 169, 1, 169, 1, 169, 1,
		169, 1, 169, 1, 169, 1, 169, 3, 169, 4367, 8, 169, 1, 170, 1, 170, 1, 170,
		5, 170, 4372, 8, 170, 10, 170, 12, 170, 4375, 9, 170, 1, 171, 3, 171, 4378,
		8, 171, 1, 171, 1, 171, 1, 171, 3, 171, 4383, 8, 171, 1, 171, 3, 171, 4386,
		8, 171, 1, 171, 1, 171, 3, 171, 4390, 8, 171, 1, 172, 1, 172, 1, 172, 1,
		172, 1, 172, 1, 172, 3, 172, 4398, 8, 172, 1, 172, 1, 172, 1, 172, 3, 172,
		4403, 8, 172, 1, 172, 1, 172, 5, 172, 4407, 8, 172, 10, 172, 12, 172, 4410,
		9, 172, 1, 172, 1, 172, 1, 172, 1, 172, 1, 172, 1, 172, 3, 172, 4418, 8,
		172, 1, 172, 1, 172, 1, 172, 1, 172, 1, 172, 5, 172, 4425, 8, 172, 10,
		172, 12, 172, 4428, 9, 172, 1, 172, 1, 172, 1, 172, 1, 172, 1, 172, 5,
		172, 4435, 8, 172, 10, 172, 12, 172, 4438, 9, 172, 1, 172, 1, 172, 1, 172,
		3, 172, 4443, 8, 172, 1, 173, 1, 173, 1, 174, 1, 174, 1, 175, 1, 175, 1,
		175, 1, 175, 1, 175, 1, 176, 1, 176, 1, 176, 1, 176, 1, 177, 1, 177, 1,
		178, 1, 178, 3, 178, 4462, 8, 178, 1, 178, 3, 178, 4465, 8, 178, 1, 179,
		1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179,
		1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179,
		1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 5, 179, 4491, 8, 179, 10, 179,
		12, 179, 4494, 9, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179,
		1, 179, 1, 179, 5, 179, 4504, 8, 179, 10, 179, 12, 179, 4507, 9, 179, 1,
		179, 3, 179, 4510, 8, 179, 3, 179, 4512, 8, 179, 1, 180, 1, 180, 1, 180,
		1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180,
		1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180,
		1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180,
		1, 180, 1, 180, 3, 180, 4546, 8, 180, 1, 181, 1, 181, 1, 181, 5, 181, 4551,
		8, 181, 10, 181, 12, 181, 4554, 9, 181, 1, 182, 1, 182, 1, 182, 1, 182,
		3, 182, 4560, 8, 182, 1, 183, 1, 183, 1, 183, 1, 184, 1, 184, 1, 184, 3,
		184, 4568, 8, 184, 1, 184, 1, 184, 1, 184, 3, 184, 4573, 8, 184, 1, 185,
		1, 185, 1, 185, 1, 185, 3, 185, 4579, 8, 185, 1, 186, 1, 186, 1, 186, 1,
		186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 3, 186, 4591, 8, 186,
		1, 187, 1, 187, 1, 187, 1, 188, 1, 188, 4, 188, 4598, 8, 188, 11, 188,
		12, 188, 4599, 1, 188, 3, 188, 4603, 8, 188, 1, 189, 1, 189, 1, 190, 1,
		190, 1, 190, 3, 190, 4610, 8, 190, 1, 191, 1, 191, 1, 192, 3, 192, 4615,
		8, 192, 1, 192, 1, 192, 3, 192, 4619, 8, 192, 1, 192, 3, 192, 4622, 8,
		192, 1, 193, 1, 193, 1, 193, 2, 464, 471, 4, 166, 308, 316, 320, 194, 0,
		2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,
		40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
		76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108,
		110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138,
		140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168,
		170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198,
		200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228,
		230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258,
		260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288,
		290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318,
		320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348,
		350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378,
		380, 382, 384, 386, 0, 59, 1, 0, 348, 349, 2, 0, 37, 37, 194, 194, 2, 0,
		34, 34, 532, 532, 3, 0, 19, 19, 153, 153, 470, 470, 2, 0, 335, 335, 381,
		381, 3, 0, 110, 110, 375, 375, 456, 456, 1, 0, 150, 151, 2, 0, 223, 223,
		455, 455, 2, 0, 111, 111, 399, 399, 3, 0, 201, 201, 268, 268, 406, 406,
		2, 0, 193, 193, 223, 223, 2, 0, 19, 19, 439, 439, 3, 0, 48, 48, 237, 237,
		303, 303, 4, 0, 55, 55, 210, 210, 268, 268, 395, 395, 3, 0, 126, 126, 217,
		217, 401, 401, 1, 0, 11, 12, 2, 0, 313, 313, 498, 498, 2, 0, 527, 527,
		532, 532, 1, 0, 324, 325, 2, 0, 266, 266, 359, 359, 2, 0, 134, 134, 222,
		222, 2, 0, 34, 34, 86, 86, 4, 0, 204, 204, 339, 339, 458, 458, 486, 486,
		2, 0, 137, 138, 172, 172, 10, 0, 21, 21, 24, 24, 144, 144, 273, 273, 287,
		287, 315, 315, 323, 323, 336, 336, 385, 385, 410, 410, 3, 0, 27, 27, 135,
		135, 288, 288, 3, 0, 167, 167, 292, 292, 469, 469, 2, 0, 21, 21, 141, 141,
		2, 0, 31, 31, 137, 137, 2, 0, 184, 184, 255, 255, 4, 0, 286, 286, 307,
		307, 527, 527, 532, 532, 8, 0, 49, 49, 200, 200, 214, 214, 285, 285, 291,
		291, 355, 355, 373, 374, 433, 433, 2, 0, 306, 306, 516, 516, 1, 0, 242,
		243, 2, 0, 25, 25, 515, 515, 3, 0, 262, 262, 368, 368, 387, 387, 1, 0,
		277, 283, 2, 0, 178, 178, 461, 461, 2, 0, 508, 509, 513, 513, 2, 0, 47,
		47, 50, 51, 2, 0, 146, 146, 510, 512, 4, 0, 508, 509, 514, 514, 517, 517,
		519, 519, 7, 0, 126, 126, 217, 217, 293, 293, 295, 295, 401, 401, 491,
		491, 500, 500, 2, 0, 120, 120, 453, 453, 2, 0, 119, 119, 452, 452, 3, 0,
		15, 15, 114, 114, 127, 127, 3, 0, 118, 118, 128, 128, 432, 432, 2, 0, 29,
		29, 404, 404, 2, 0, 201, 201, 406, 406, 2, 0, 113, 113, 451, 451, 2, 0,
		412, 412, 473, 473, 1, 0, 231, 232, 2, 0, 359, 359, 394, 394, 2, 0, 187,
		187, 345, 345, 4, 0, 113, 113, 123, 123, 125, 125, 451, 451, 1, 0, 501,
		507, 2, 0, 510, 510, 532, 532, 1, 0, 533, 534, 97, 0, 9, 10, 13, 13, 15,
		15, 17, 20, 24, 24, 28, 29, 32, 33, 35, 36, 38, 41, 44, 44, 47, 59, 61,
		63, 67, 72, 74, 75, 77, 79, 81, 92, 94, 98, 100, 101, 105, 110, 113, 131,
		134, 134, 136, 136, 139, 139, 142, 143, 147, 148, 152, 152, 154, 154, 156,
		162, 164, 166, 168, 168, 171, 171, 175, 175, 177, 177, 179, 184, 191, 192,
		195, 195, 197, 197, 199, 201, 204, 204, 206, 208, 210, 212, 214, 219, 221,
		222, 224, 224, 226, 226, 237, 239, 241, 246, 248, 249, 253, 253, 255, 255,
		257, 258, 260, 261, 264, 265, 268, 273, 275, 276, 278, 285, 287, 291, 293,
		298, 300, 305, 308, 308, 310, 311, 313, 315, 322, 323, 325, 337, 339, 344,
		348, 348, 350, 358, 363, 366, 372, 374, 376, 383, 385, 385, 387, 387, 390,
		392, 395, 399, 401, 401, 404, 406, 409, 410, 413, 413, 415, 418, 420, 433,
		439, 439, 443, 445, 447, 448, 450, 453, 456, 456, 458, 459, 462, 463, 465,
		465, 467, 467, 471, 472, 474, 474, 477, 477, 479, 479, 481, 491, 496, 496,
		500, 500, 522, 524, 5361, 0, 391, 1, 0, 0, 0, 2, 419, 1, 0, 0, 0, 4, 507,
		1, 0, 0, 0, 6, 523, 1, 0, 0, 0, 8, 538, 1, 0, 0, 0, 10, 679, 1, 0, 0, 0,
		12, 700, 1, 0, 0, 0, 14, 832, 1, 0, 0, 0, 16, 982, 1, 0, 0, 0, 18, 1002,
		1, 0, 0, 0, 20, 1004, 1, 0, 0, 0, 22, 1158, 1, 0, 0, 0, 24, 1160, 1, 0,
		0, 0, 26, 1184, 1, 0, 0, 0, 28, 1228, 1, 0, 0, 0, 30, 1310, 1, 0, 0, 0,
		32, 1317, 1, 0, 0, 0, 34, 1319, 1, 0, 0, 0, 36, 1497, 1, 0, 0, 0, 38, 1597,
		1, 0, 0, 0, 40, 1599, 1, 0, 0, 0, 42, 1603, 1, 0, 0, 0, 44, 1854, 1, 0,
		0, 0, 46, 1859, 1, 0, 0, 0, 48, 1861, 1, 0, 0, 0, 50, 1864, 1, 0, 0, 0,
		52, 2022, 1, 0, 0, 0, 54, 2073, 1, 0, 0, 0, 56, 2365, 1, 0, 0, 0, 58, 2367,
		1, 0, 0, 0, 60, 2375, 1, 0, 0, 0, 62, 2385, 1, 0, 0, 0, 64, 2399, 1, 0,
		0, 0, 66, 2401, 1, 0, 0, 0, 68, 2409, 1, 0, 0, 0, 70, 2415, 1, 0, 0, 0,
		72, 2430, 1, 0, 0, 0, 74, 2466, 1, 0, 0, 0, 76, 2476, 1, 0, 0, 0, 78, 2524,
		1, 0, 0, 0, 80, 2526, 1, 0, 0, 0, 82, 2578, 1, 0, 0, 0, 84, 2598, 1, 0,
		0, 0, 86, 2600, 1, 0, 0, 0, 88, 2603, 1, 0, 0, 0, 90, 2627, 1, 0, 0, 0,
		92, 2649, 1, 0, 0, 0, 94, 2651, 1, 0, 0, 0, 96, 2665, 1, 0, 0, 0, 98, 2686,
		1, 0, 0, 0, 100, 2700, 1, 0, 0, 0, 102, 2716, 1, 0, 0, 0, 104, 2719, 1,
		0, 0, 0, 106, 2733, 1, 0, 0, 0, 108, 2746, 1, 0, 0, 0, 110, 2843, 1, 0,
		0, 0, 112, 2845, 1, 0, 0, 0, 114, 2855, 1, 0, 0, 0, 116, 2857, 1, 0, 0,
		0, 118, 2864, 1, 0, 0, 0, 120, 2868, 1, 0, 0, 0, 122, 2872, 1, 0, 0, 0,
		124, 2877, 1, 0, 0, 0, 126, 2879, 1, 0, 0, 0, 128, 2889, 1, 0, 0, 0, 130,
		2891, 1, 0, 0, 0, 132, 2902, 1, 0, 0, 0, 134, 2911, 1, 0, 0, 0, 136, 2921,
		1, 0, 0, 0, 138, 2923, 1, 0, 0, 0, 140, 2925, 1, 0, 0, 0, 142, 2927, 1,
		0, 0, 0, 144, 2931, 1, 0, 0, 0, 146, 2935, 1, 0, 0, 0, 148, 2939, 1, 0,
		0, 0, 150, 2945, 1, 0, 0, 0, 152, 2957, 1, 0, 0, 0, 154, 2989, 1, 0, 0,
		0, 156, 2991, 1, 0, 0, 0, 158, 3000, 1, 0, 0, 0, 160, 3044, 1, 0, 0, 0,
		162, 3046, 1, 0, 0, 0, 164, 3058, 1, 0, 0, 0, 166, 3063, 1, 0, 0, 0, 168,
		3083, 1, 0, 0, 0, 170, 3091, 1, 0, 0, 0, 172, 3093, 1, 0, 0, 0, 174, 3112,
		1, 0, 0, 0, 176, 3121, 1, 0, 0, 0, 178, 3130, 1, 0, 0, 0, 180, 3141, 1,
		0, 0, 0, 182, 3150, 1, 0, 0, 0, 184, 3152, 1, 0, 0, 0, 186, 3155, 1, 0,
		0, 0, 188, 3159, 1, 0, 0, 0, 190, 3176, 1, 0, 0, 0, 192, 3179, 1, 0, 0,
		0, 194, 3184, 1, 0, 0, 0, 196, 3192, 1, 0, 0, 0, 198, 3199, 1, 0, 0, 0,
		200, 3216, 1, 0, 0, 0, 202, 3240, 1, 0, 0, 0, 204, 3242, 1, 0, 0, 0, 206,
		3293, 1, 0, 0, 0, 208, 3295, 1, 0, 0, 0, 210, 3308, 1, 0, 0, 0, 212, 3311,
		1, 0, 0, 0, 214, 3323, 1, 0, 0, 0, 216, 3348, 1, 0, 0, 0, 218, 3350, 1,
		0, 0, 0, 220, 3356, 1, 0, 0, 0, 222, 3364, 1, 0, 0, 0, 224, 3390, 1, 0,
		0, 0, 226, 3395, 1, 0, 0, 0, 228, 3405, 1, 0, 0, 0, 230, 3423, 1, 0, 0,
		0, 232, 3425, 1, 0, 0, 0, 234, 3459, 1, 0, 0, 0, 236, 3465, 1, 0, 0, 0,
		238, 3467, 1, 0, 0, 0, 240, 3471, 1, 0, 0, 0, 242, 3479, 1, 0, 0, 0, 244,
		3538, 1, 0, 0, 0, 246, 3540, 1, 0, 0, 0, 248, 3543, 1, 0, 0, 0, 250, 3548,
		1, 0, 0, 0, 252, 3556, 1, 0, 0, 0, 254, 3562, 1, 0, 0, 0, 256, 3566, 1,
		0, 0, 0, 258, 3575, 1, 0, 0, 0, 260, 3577, 1, 0, 0, 0, 262, 3585, 1, 0,
		0, 0, 264, 3593, 1, 0, 0, 0, 266, 3598, 1, 0, 0, 0, 268, 3606, 1, 0, 0,
		0, 270, 3673, 1, 0, 0, 0, 272, 3681, 1, 0, 0, 0, 274, 3704, 1, 0, 0, 0,
		276, 3716, 1, 0, 0, 0, 278, 3724, 1, 0, 0, 0, 280, 3738, 1, 0, 0, 0, 282,
		3752, 1, 0, 0, 0, 284, 3761, 1, 0, 0, 0, 286, 3786, 1, 0, 0, 0, 288, 3797,
		1, 0, 0, 0, 290, 3799, 1, 0, 0, 0, 292, 3807, 1, 0, 0, 0, 294, 3817, 1,
		0, 0, 0, 296, 3819, 1, 0, 0, 0, 298, 3831, 1, 0, 0, 0, 300, 3840, 1, 0,
		0, 0, 302, 3847, 1, 0, 0, 0, 304, 3857, 1, 0, 0, 0, 306, 3875, 1, 0, 0,
		0, 308, 3899, 1, 0, 0, 0, 310, 3918, 1, 0, 0, 0, 312, 3933, 1, 0, 0, 0,
		314, 3986, 1, 0, 0, 0, 316, 3999, 1, 0, 0, 0, 318, 4016, 1, 0, 0, 0, 320,
		4228, 1, 0, 0, 0, 322, 4269, 1, 0, 0, 0, 324, 4276, 1, 0, 0, 0, 326, 4278,
		1, 0, 0, 0, 328, 4313, 1, 0, 0, 0, 330, 4332, 1, 0, 0, 0, 332, 4334, 1,
		0, 0, 0, 334, 4355, 1, 0, 0, 0, 336, 4357, 1, 0, 0, 0, 338, 4366, 1, 0,
		0, 0, 340, 4368, 1, 0, 0, 0, 342, 4389, 1, 0, 0, 0, 344, 4442, 1, 0, 0,
		0, 346, 4444, 1, 0, 0, 0, 348, 4446, 1, 0, 0, 0, 350, 4448, 1, 0, 0, 0,
		352, 4453, 1, 0, 0, 0, 354, 4457, 1, 0, 0, 0, 356, 4459, 1, 0, 0, 0, 358,
		4511, 1, 0, 0, 0, 360, 4545, 1, 0, 0, 0, 362, 4547, 1, 0, 0, 0, 364, 4555,
		1, 0, 0, 0, 366, 4561, 1, 0, 0, 0, 368, 4564, 1, 0, 0, 0, 370, 4578, 1,
		0, 0, 0, 372, 4590, 1, 0, 0, 0, 374, 4592, 1, 0, 0, 0, 376, 4602, 1, 0,
		0, 0, 378, 4604, 1, 0, 0, 0, 380, 4609, 1, 0, 0, 0, 382, 4611, 1, 0, 0,
		0, 384, 4621, 1, 0, 0, 0, 386, 4623, 1, 0, 0, 0, 388, 390, 5, 1, 0, 0,
		389, 388, 1, 0, 0, 0, 390, 393, 1, 0, 0, 0, 391, 389, 1, 0, 0, 0, 391,
		392, 1, 0, 0, 0, 392, 395, 1, 0, 0, 0, 393, 391, 1, 0, 0, 0, 394, 396,
		3, 4, 2, 0, 395, 394, 1, 0, 0, 0, 395, 396, 1, 0, 0, 0, 396, 405, 1, 0,
		0, 0, 397, 399, 5, 1, 0, 0, 398, 397, 1, 0, 0, 0, 399, 400, 1, 0, 0, 0,
		400, 398, 1, 0, 0, 0, 400, 401, 1, 0, 0, 0, 401, 402, 1, 0, 0, 0, 402,
		404, 3, 4, 2, 0, 403, 398, 1, 0, 0, 0, 404, 407, 1, 0, 0, 0, 405, 403,
		1, 0, 0, 0, 405, 406, 1, 0, 0, 0, 406, 411, 1, 0, 0, 0, 407, 405, 1, 0,
		0, 0, 408, 410, 5, 1, 0, 0, 409, 408, 1, 0, 0, 0, 410, 413, 1, 0, 0, 0,
		411, 409, 1, 0, 0, 0, 411, 412, 1, 0, 0, 0, 412, 414, 1, 0, 0, 0, 413,
		411, 1, 0, 0, 0, 414, 415, 5, 0, 0, 1, 415, 1, 1, 0, 0, 0, 416, 418, 5,
		1, 0, 0, 417, 416, 1, 0, 0, 0, 418, 421, 1, 0, 0, 0, 419, 417, 1, 0, 0,
		0, 419, 420, 1, 0, 0, 0, 420, 423, 1, 0, 0, 0, 421, 419, 1, 0, 0, 0, 422,
		424, 3, 4, 2, 0, 423, 422, 1, 0, 0, 0, 423, 424, 1, 0, 0, 0, 424, 428,
		1, 0, 0, 0, 425, 427, 5, 1, 0, 0, 426, 425, 1, 0, 0, 0, 427, 430, 1, 0,
		0, 0, 428, 426, 1, 0, 0, 0, 428, 429, 1, 0, 0, 0, 429, 431, 1, 0, 0, 0,
		430, 428, 1, 0, 0, 0, 431, 432, 5, 0, 0, 1, 432, 3, 1, 0, 0, 0, 433, 508,
		3, 6, 3, 0, 434, 435, 5, 63, 0, 0, 435, 436, 3, 260, 130, 0, 436, 445,
		5, 2, 0, 0, 437, 442, 3, 304, 152, 0, 438, 439, 5, 4, 0, 0, 439, 441, 3,
		304, 152, 0, 440, 438, 1, 0, 0, 0, 441, 444, 1, 0, 0, 0, 442, 440, 1, 0,
		0, 0, 442, 443, 1, 0, 0, 0, 443, 446, 1, 0, 0, 0, 444, 442, 1, 0, 0, 0,
		445, 437, 1, 0, 0, 0, 445, 446, 1, 0, 0, 0, 446, 447, 1, 0, 0, 0, 447,
		448, 5, 3, 0, 0, 448, 508, 1, 0, 0, 0, 449, 457, 5, 22, 0, 0, 450, 453,
		5, 99, 0, 0, 451, 452, 5, 316, 0, 0, 452, 454, 5, 373, 0, 0, 453, 451,
		1, 0, 0, 0, 453, 454, 1, 0, 0, 0, 454, 457, 1, 0, 0, 0, 455, 457, 5, 373,
		0, 0, 456, 449, 1, 0, 0, 0, 456, 450, 1, 0, 0, 0, 456, 455, 1, 0, 0, 0,
		457, 458, 1, 0, 0, 0, 458, 459, 7, 0, 0, 0, 459, 460, 3, 260, 130, 0, 460,
		464, 5, 2, 0, 0, 461, 463, 9, 0, 0, 0, 462, 461, 1, 0, 0, 0, 463, 466,
		1, 0, 0, 0, 464, 465, 1, 0, 0, 0, 464, 462, 1, 0, 0, 0, 465, 467, 1, 0,
		0, 0, 466, 464, 1, 0, 0, 0, 467, 471, 5, 3, 0, 0, 468, 470, 9, 0, 0, 0,
		469, 468, 1, 0, 0, 0, 470, 473, 1, 0, 0, 0, 471, 472, 1, 0, 0, 0, 471,
		469, 1, 0, 0, 0, 472, 508, 1, 0, 0, 0, 473, 471, 1, 0, 0, 0, 474, 475,
		5, 150, 0, 0, 475, 478, 7, 0, 0, 0, 476, 477, 5, 220, 0, 0, 477, 479, 5,
		170, 0, 0, 478, 476, 1, 0, 0, 0, 478, 479, 1, 0, 0, 0, 479, 480, 1, 0,
		0, 0, 480, 508, 3, 260, 130, 0, 481, 482, 5, 411, 0, 0, 482, 483, 5, 349,
		0, 0, 483, 487, 5, 425, 0, 0, 484, 485, 5, 262, 0, 0, 485, 488, 3, 316,
		158, 0, 486, 488, 3, 184, 92, 0, 487, 484, 1, 0, 0, 0, 487, 486, 1, 0,
		0, 0, 487, 488, 1, 0, 0, 0, 488, 508, 1, 0, 0, 0, 489, 490, 5, 411, 0,
		0, 490, 491, 5, 99, 0, 0, 491, 492, 5, 349, 0, 0, 492, 508, 3, 260, 130,
		0, 493, 495, 5, 16, 0, 0, 494, 493, 1, 0, 0, 0, 494, 495, 1, 0, 0, 0, 495,
		496, 1, 0, 0, 0, 496, 497, 5, 411, 0, 0, 497, 498, 7, 1, 0, 0, 498, 501,
		5, 89, 0, 0, 499, 500, 5, 262, 0, 0, 500, 502, 3, 316, 158, 0, 501, 499,
		1, 0, 0, 0, 501, 502, 1, 0, 0, 0, 502, 505, 1, 0, 0, 0, 503, 504, 5, 193,
		0, 0, 504, 506, 5, 532, 0, 0, 505, 503, 1, 0, 0, 0, 505, 506, 1, 0, 0,
		0, 506, 508, 1, 0, 0, 0, 507, 433, 1, 0, 0, 0, 507, 434, 1, 0, 0, 0, 507,
		456, 1, 0, 0, 0, 507, 474, 1, 0, 0, 0, 507, 481, 1, 0, 0, 0, 507, 489,
		1, 0, 0, 0, 507, 494, 1, 0, 0, 0, 508, 5, 1, 0, 0, 0, 509, 511, 3, 134,
		67, 0, 510, 509, 1, 0, 0, 0, 510, 511, 1, 0, 0, 0, 511, 512, 1, 0, 0, 0,
		512, 514, 3, 164, 82, 0, 513, 515, 3, 162, 81, 0, 514, 513, 1, 0, 0, 0,
		514, 515, 1, 0, 0, 0, 515, 524, 1, 0, 0, 0, 516, 524, 3, 14, 7, 0, 517,
		524, 3, 16, 8, 0, 518, 524, 3, 18, 9, 0, 519, 524, 3, 10, 5, 0, 520, 524,
		3, 12, 6, 0, 521, 524, 3, 20, 10, 0, 522, 524, 3, 8, 4, 0, 523, 510, 1,
		0, 0, 0, 523, 516, 1, 0, 0, 0, 523, 517, 1, 0, 0, 0, 523, 518, 1, 0, 0,
		0, 523, 519, 1, 0, 0, 0, 523, 520, 1, 0, 0, 0, 523, 521, 1, 0, 0, 0, 523,
		522, 1, 0, 0, 0, 524, 7, 1, 0, 0, 0, 525, 539, 3, 78, 39, 0, 526, 539,
		3, 90, 45, 0, 527, 539, 3, 92, 46, 0, 528, 539, 3, 94, 47, 0, 529, 539,
		3, 96, 48, 0, 530, 539, 3, 98, 49, 0, 531, 539, 3, 56, 28, 0, 532, 539,
		3, 52, 26, 0, 533, 539, 3, 54, 27, 0, 534, 539, 3, 36, 18, 0, 535, 539,
		3, 30, 15, 0, 536, 539, 3, 22, 11, 0, 537, 539, 3, 28, 14, 0, 538, 525,
		1, 0, 0, 0, 538, 526, 1, 0, 0, 0, 538, 527, 1, 0, 0, 0, 538, 528, 1, 0,
		0, 0, 538, 529, 1, 0, 0, 0, 538, 530, 1, 0, 0, 0, 538, 531, 1, 0, 0, 0,
		538, 532, 1, 0, 0, 0, 538, 533, 1, 0, 0, 0, 538, 534, 1, 0, 0, 0, 538,
		535, 1, 0, 0, 0, 538, 536, 1, 0, 0, 0, 538, 537, 1, 0, 0, 0, 539, 9, 1,
		0, 0, 0, 540, 541, 5, 99, 0, 0, 541, 542, 5, 284, 0, 0, 542, 546, 5, 488,
		0, 0, 543, 544, 5, 220, 0, 0, 544, 545, 5, 306, 0, 0, 545, 547, 5, 170,
		0, 0, 546, 543, 1, 0, 0, 0, 546, 547, 1, 0, 0, 0, 547, 548, 1, 0, 0, 0,
		548, 553, 3, 260, 130, 0, 549, 550, 5, 2, 0, 0, 550, 551, 3, 262, 131,
		0, 551, 552, 5, 3, 0, 0, 552, 554, 1, 0, 0, 0, 553, 549, 1, 0, 0, 0, 553,
		554, 1, 0, 0, 0, 554, 556, 1, 0, 0, 0, 555, 557, 3, 112, 56, 0, 556, 555,
		1, 0, 0, 0, 556, 557, 1, 0, 0, 0, 557, 565, 1, 0, 0, 0, 558, 560, 5, 366,
		0, 0, 559, 561, 3, 118, 59, 0, 560, 559, 1, 0, 0, 0, 560, 561, 1, 0, 0,
		0, 561, 563, 1, 0, 0, 0, 562, 564, 3, 114, 57, 0, 563, 562, 1, 0, 0, 0,
		563, 564, 1, 0, 0, 0, 564, 566, 1, 0, 0, 0, 565, 558, 1, 0, 0, 0, 565,
		566, 1, 0, 0, 0, 566, 572, 1, 0, 0, 0, 567, 569, 5, 153, 0, 0, 568, 567,
		1, 0, 0, 0, 568, 569, 1, 0, 0, 0, 569, 570, 1, 0, 0, 0, 570, 571, 5, 250,
		0, 0, 571, 573, 3, 238, 119, 0, 572, 568, 1, 0, 0, 0, 572, 573, 1, 0, 0,
		0, 573, 576, 1, 0, 0, 0, 574, 575, 5, 82, 0, 0, 575, 577, 5, 527, 0, 0,
		576, 574, 1, 0, 0, 0, 576, 577, 1, 0, 0, 0, 577, 584, 1, 0, 0, 0, 578,
		579, 5, 324, 0, 0, 579, 580, 5, 60, 0, 0, 580, 581, 5, 2, 0, 0, 581, 582,
		3, 120, 60, 0, 582, 583, 5, 3, 0, 0, 583, 585, 1, 0, 0, 0, 584, 578, 1,
		0, 0, 0, 584, 585, 1, 0, 0, 0, 585, 597, 1, 0, 0, 0, 586, 587, 5, 144,
		0, 0, 587, 591, 5, 60, 0, 0, 588, 589, 5, 208, 0, 0, 589, 592, 3, 238,
		119, 0, 590, 592, 5, 358, 0, 0, 591, 588, 1, 0, 0, 0, 591, 590, 1, 0, 0,
		0, 592, 595, 1, 0, 0, 0, 593, 594, 5, 56, 0, 0, 594, 596, 7, 2, 0, 0, 595,
		593, 1, 0, 0, 0, 595, 596, 1, 0, 0, 0, 596, 598, 1, 0, 0, 0, 597, 586,
		1, 0, 0, 0, 597, 598, 1, 0, 0, 0, 598, 600, 1, 0, 0, 0, 599, 601, 3, 248,
		124, 0, 600, 599, 1, 0, 0, 0, 600, 601, 1, 0, 0, 0, 601, 602, 1, 0, 0,
		0, 602, 603, 5, 30, 0, 0, 603, 604, 3, 164, 82, 0, 604, 680, 1, 0, 0, 0,
		605, 606, 5, 366, 0, 0, 606, 607, 5, 284, 0, 0, 607, 608, 5, 488, 0, 0,
		608, 612, 3, 260, 130, 0, 609, 613, 3, 102, 51, 0, 610, 613, 5, 86, 0,
		0, 611, 613, 5, 34, 0, 0, 612, 609, 1, 0, 0, 0, 612, 610, 1, 0, 0, 0, 612,
		611, 1, 0, 0, 0, 613, 680, 1, 0, 0, 0, 614, 615, 5, 22, 0, 0, 615, 616,
		5, 284, 0, 0, 616, 617, 5, 488, 0, 0, 617, 641, 3, 260, 130, 0, 618, 619,
		5, 370, 0, 0, 619, 642, 3, 378, 189, 0, 620, 626, 5, 366, 0, 0, 621, 627,
		3, 118, 59, 0, 622, 627, 3, 114, 57, 0, 623, 624, 3, 118, 59, 0, 624, 625,
		3, 114, 57, 0, 625, 627, 1, 0, 0, 0, 626, 621, 1, 0, 0, 0, 626, 622, 1,
		0, 0, 0, 626, 623, 1, 0, 0, 0, 627, 642, 1, 0, 0, 0, 628, 629, 5, 373,
		0, 0, 629, 630, 5, 495, 0, 0, 630, 631, 5, 284, 0, 0, 631, 632, 5, 488,
		0, 0, 632, 634, 3, 378, 189, 0, 633, 635, 3, 248, 124, 0, 634, 633, 1,
		0, 0, 0, 634, 635, 1, 0, 0, 0, 635, 642, 1, 0, 0, 0, 636, 637, 5, 407,
		0, 0, 637, 638, 5, 2, 0, 0, 638, 639, 3, 250, 125, 0, 639, 640, 5, 3, 0,
		0, 640, 642, 1, 0, 0, 0, 641, 618, 1, 0, 0, 0, 641, 620, 1, 0, 0, 0, 641,
		628, 1, 0, 0, 0, 641, 636, 1, 0, 0, 0, 642, 680, 1, 0, 0, 0, 643, 644,
		5, 150, 0, 0, 644, 645, 5, 284, 0, 0, 645, 648, 5, 488, 0, 0, 646, 647,
		5, 220, 0, 0, 647, 649, 5, 170, 0, 0, 648, 646, 1, 0, 0, 0, 648, 649, 1,
		0, 0, 0, 649, 650, 1, 0, 0, 0, 650, 653, 3, 260, 130, 0, 651, 652, 5, 312,
		0, 0, 652, 654, 3, 260, 130, 0, 653, 651, 1, 0, 0, 0, 653, 654, 1, 0, 0,
		0, 654, 680, 1, 0, 0, 0, 655, 656, 5, 332, 0, 0, 656, 657, 5, 284, 0, 0,
		657, 658, 5, 488, 0, 0, 658, 659, 5, 245, 0, 0, 659, 660, 5, 312, 0, 0,
		660, 680, 3, 260, 130, 0, 661, 662, 5, 382, 0, 0, 662, 663, 5, 284, 0,
		0, 663, 664, 5, 488, 0, 0, 664, 665, 5, 245, 0, 0, 665, 666, 5, 312, 0,
		0, 666, 680, 3, 260, 130, 0, 667, 668, 5, 64, 0, 0, 668, 669, 5, 284, 0,
		0, 669, 670, 5, 488, 0, 0, 670, 671, 5, 443, 0, 0, 671, 672, 5, 532, 0,
		0, 672, 673, 5, 312, 0, 0, 673, 680, 3, 260, 130, 0, 674, 675, 5, 411,
		0, 0, 675, 676, 5, 99, 0, 0, 676, 677, 5, 284, 0, 0, 677, 678, 5, 488,
		0, 0, 678, 680, 3, 260, 130, 0, 679, 540, 1, 0, 0, 0, 679, 605, 1, 0, 0,
		0, 679, 614, 1, 0, 0, 0, 679, 643, 1, 0, 0, 0, 679, 655, 1, 0, 0, 0, 679,
		661, 1, 0, 0, 0, 679, 667, 1, 0, 0, 0, 679, 674, 1, 0, 0, 0, 680, 11, 1,
		0, 0, 0, 681, 682, 5, 22, 0, 0, 682, 683, 5, 438, 0, 0, 683, 684, 3, 260,
		130, 0, 684, 685, 5, 14, 0, 0, 685, 686, 5, 93, 0, 0, 686, 687, 3, 374,
		187, 0, 687, 688, 3, 100, 50, 0, 688, 701, 1, 0, 0, 0, 689, 690, 5, 22,
		0, 0, 690, 691, 5, 438, 0, 0, 691, 692, 3, 260, 130, 0, 692, 693, 5, 150,
		0, 0, 693, 694, 5, 93, 0, 0, 694, 695, 3, 374, 187, 0, 695, 701, 1, 0,
		0, 0, 696, 697, 5, 411, 0, 0, 697, 698, 5, 94, 0, 0, 698, 699, 5, 193,
		0, 0, 699, 701, 3, 260, 130, 0, 700, 681, 1, 0, 0, 0, 700, 689, 1, 0, 0,
		0, 700, 696, 1, 0, 0, 0, 701, 13, 1, 0, 0, 0, 702, 704, 3, 134, 67, 0,
		703, 702, 1, 0, 0, 0, 703, 704, 1, 0, 0, 0, 704, 706, 1, 0, 0, 0, 705,
		707, 3, 174, 87, 0, 706, 705, 1, 0, 0, 0, 706, 707, 1, 0, 0, 0, 707, 708,
		1, 0, 0, 0, 708, 712, 5, 229, 0, 0, 709, 713, 5, 236, 0, 0, 710, 711, 5,
		321, 0, 0, 711, 713, 5, 438, 0, 0, 712, 709, 1, 0, 0, 0, 712, 710, 1, 0,
		0, 0, 713, 719, 1, 0, 0, 0, 714, 720, 3, 260, 130, 0, 715, 716, 5, 148,
		0, 0, 716, 717, 5, 2, 0, 0, 717, 718, 5, 532, 0, 0, 718, 720, 5, 3, 0,
		0, 719, 714, 1, 0, 0, 0, 719, 715, 1, 0, 0, 0, 720, 722, 1, 0, 0, 0, 721,
		723, 3, 102, 51, 0, 722, 721, 1, 0, 0, 0, 722, 723, 1, 0, 0, 0, 723, 727,
		1, 0, 0, 0, 724, 725, 5, 495, 0, 0, 725, 726, 5, 253, 0, 0, 726, 728, 3,
		378, 189, 0, 727, 724, 1, 0, 0, 0, 727, 728, 1, 0, 0, 0, 728, 730, 1, 0,
		0, 0, 729, 731, 3, 238, 119, 0, 730, 729, 1, 0, 0, 0, 730, 731, 1, 0, 0,
		0, 731, 736, 1, 0, 0, 0, 732, 733, 5, 7, 0, 0, 733, 734, 3, 240, 120, 0,
		734, 735, 5, 8, 0, 0, 735, 737, 1, 0, 0, 0, 736, 732, 1, 0, 0, 0, 736,
		737, 1, 0, 0, 0, 737, 738, 1, 0, 0, 0, 738, 833, 3, 164, 82, 0, 739, 741,
		3, 134, 67, 0, 740, 739, 1, 0, 0, 0, 740, 741, 1, 0, 0, 0, 741, 743, 1,
		0, 0, 0, 742, 744, 3, 174, 87, 0, 743, 742, 1, 0, 0, 0, 743, 744, 1, 0,
		0, 0, 744, 745, 1, 0, 0, 0, 745, 746, 5, 475, 0, 0, 746, 747, 3, 260, 130,
		0, 747, 748, 3, 258, 129, 0, 748, 749, 5, 407, 0, 0, 749, 751, 3, 220,
		110, 0, 750, 752, 3, 186, 93, 0, 751, 750, 1, 0, 0, 0, 751, 752, 1, 0,
		0, 0, 752, 754, 1, 0, 0, 0, 753, 755, 3, 184, 92, 0, 754, 753, 1, 0, 0,
		0, 754, 755, 1, 0, 0, 0, 755, 833, 1, 0, 0, 0, 756, 758, 3, 134, 67, 0,
		757, 756, 1, 0, 0, 0, 757, 758, 1, 0, 0, 0, 758, 760, 1, 0, 0, 0, 759,
		761, 3, 174, 87, 0, 760, 759, 1, 0, 0, 0, 760, 761, 1, 0, 0, 0, 761, 762,
		1, 0, 0, 0, 762, 763, 5, 135, 0, 0, 763, 764, 5, 193, 0, 0, 764, 766, 3,
		260, 130, 0, 765, 767, 3, 102, 51, 0, 766, 765, 1, 0, 0, 0, 766, 767, 1,
		0, 0, 0, 767, 768, 1, 0, 0, 0, 768, 771, 3, 258, 129, 0, 769, 770, 5, 478,
		0, 0, 770, 772, 3, 194, 97, 0, 771, 769, 1, 0, 0, 0, 771, 772, 1, 0, 0,
		0, 772, 774, 1, 0, 0, 0, 773, 775, 3, 184, 92, 0, 774, 773, 1, 0, 0, 0,
		774, 775, 1, 0, 0, 0, 775, 833, 1, 0, 0, 0, 776, 777, 5, 267, 0, 0, 777,
		778, 5, 253, 0, 0, 778, 779, 3, 378, 189, 0, 779, 780, 5, 2, 0, 0, 780,
		785, 3, 110, 55, 0, 781, 782, 5, 4, 0, 0, 782, 784, 3, 110, 55, 0, 783,
		781, 1, 0, 0, 0, 784, 787, 1, 0, 0, 0, 785, 783, 1, 0, 0, 0, 785, 786,
		1, 0, 0, 0, 786, 788, 1, 0, 0, 0, 787, 785, 1, 0, 0, 0, 788, 790, 5, 3,
		0, 0, 789, 791, 3, 154, 77, 0, 790, 789, 1, 0, 0, 0, 790, 791, 1, 0, 0,
		0, 791, 797, 1, 0, 0, 0, 792, 793, 5, 352, 0, 0, 793, 794, 5, 2, 0, 0,
		794, 795, 3, 250, 125, 0, 795, 796, 5, 3, 0, 0, 796, 798, 1, 0, 0, 0, 797,
		792, 1, 0, 0, 0, 797, 798, 1, 0, 0, 0, 798, 800, 1, 0, 0, 0, 799, 801,
		3, 366, 183, 0, 800, 799, 1, 0, 0, 0, 800, 801, 1, 0, 0, 0, 801, 833, 1,
		0, 0, 0, 802, 803, 5, 267, 0, 0, 803, 809, 3, 158, 79, 0, 804, 805, 5,
		352, 0, 0, 805, 806, 5, 2, 0, 0, 806, 807, 3, 250, 125, 0, 807, 808, 5,
		3, 0, 0, 808, 810, 1, 0, 0, 0, 809, 804, 1, 0, 0, 0, 809, 810, 1, 0, 0,
		0, 810, 812, 1, 0, 0, 0, 811, 813, 3, 366, 183, 0, 812, 811, 1, 0, 0, 0,
		812, 813, 1, 0, 0, 0, 813, 833, 1, 0, 0, 0, 814, 815, 5, 173, 0, 0, 815,
		816, 5, 438, 0, 0, 816, 819, 3, 260, 130, 0, 817, 818, 5, 324, 0, 0, 818,
		820, 3, 238, 119, 0, 819, 817, 1, 0, 0, 0, 819, 820, 1, 0, 0, 0, 820, 822,
		1, 0, 0, 0, 821, 823, 3, 184, 92, 0, 822, 821, 1, 0, 0, 0, 822, 823, 1,
		0, 0, 0, 823, 824, 1, 0, 0, 0, 824, 825, 5, 455, 0, 0, 825, 827, 5, 527,
		0, 0, 826, 828, 3, 248, 124, 0, 827, 826, 1, 0, 0, 0, 827, 828, 1, 0, 0,
		0, 828, 830, 1, 0, 0, 0, 829, 831, 3, 154, 77, 0, 830, 829, 1, 0, 0, 0,
		830, 831, 1, 0, 0, 0, 831, 833, 1, 0, 0, 0, 832, 703, 1, 0, 0, 0, 832,
		740, 1, 0, 0, 0, 832, 757, 1, 0, 0, 0, 832, 776, 1, 0, 0, 0, 832, 802,
		1, 0, 0, 0, 832, 814, 1, 0, 0, 0, 833, 15, 1, 0, 0, 0, 834, 836, 5, 99,
		0, 0, 835, 837, 5, 175, 0, 0, 836, 835, 1, 0, 0, 0, 836, 837, 1, 0, 0,
		0, 837, 838, 1, 0, 0, 0, 838, 842, 5, 438, 0, 0, 839, 840, 5, 220, 0, 0,
		840, 841, 5, 306, 0, 0, 841, 843, 5, 170, 0, 0, 842, 839, 1, 0, 0, 0, 842,
		843, 1, 0, 0, 0, 843, 844, 1, 0, 0, 0, 844, 859, 3, 260, 130, 0, 845, 847,
		3, 238, 119, 0, 846, 845, 1, 0, 0, 0, 846, 847, 1, 0, 0, 0, 847, 860, 1,
		0, 0, 0, 848, 849, 5, 2, 0, 0, 849, 852, 3, 266, 133, 0, 850, 851, 5, 4,
		0, 0, 851, 853, 3, 270, 135, 0, 852, 850, 1, 0, 0, 0, 852, 853, 1, 0, 0,
		0, 853, 855, 1, 0, 0, 0, 854, 856, 5, 4, 0, 0, 855, 854, 1, 0, 0, 0, 855,
		856, 1, 0, 0, 0, 856, 857, 1, 0, 0, 0, 857, 858, 5, 3, 0, 0, 858, 860,
		1, 0, 0, 0, 859, 846, 1, 0, 0, 0, 859, 848, 1, 0, 0, 0, 860, 864, 1, 0,
		0, 0, 861, 862, 5, 161, 0, 0, 862, 863, 5, 501, 0, 0, 863, 865, 3, 378,
		189, 0, 864, 861, 1, 0, 0, 0, 864, 865, 1, 0, 0, 0, 865, 874, 1, 0, 0,
		0, 866, 867, 7, 3, 0, 0, 867, 868, 5, 250, 0, 0, 868, 872, 3, 238, 119,
		0, 869, 870, 5, 74, 0, 0, 870, 871, 5, 60, 0, 0, 871, 873, 3, 238, 119,
		0, 872, 869, 1, 0, 0, 0, 872, 873, 1, 0, 0, 0, 873, 875, 1, 0, 0, 0, 874,
		866, 1, 0, 0, 0, 874, 875, 1, 0, 0, 0, 875, 878, 1, 0, 0, 0, 876, 877,
		5, 82, 0, 0, 877, 879, 5, 527, 0, 0, 878, 876, 1, 0, 0, 0, 878, 879, 1,
		0, 0, 0, 879, 881, 1, 0, 0, 0, 880, 882, 3, 104, 52, 0, 881, 880, 1, 0,
		0, 0, 881, 882, 1, 0, 0, 0, 882, 897, 1, 0, 0, 0, 883, 884, 5, 144, 0,
		0, 884, 888, 5, 60, 0, 0, 885, 886, 5, 208, 0, 0, 886, 889, 3, 238, 119,
		0, 887, 889, 5, 358, 0, 0, 888, 885, 1, 0, 0, 0, 888, 887, 1, 0, 0, 0,
		889, 895, 1, 0, 0, 0, 890, 893, 5, 56, 0, 0, 891, 894, 5, 532, 0, 0, 892,
		894, 5, 34, 0, 0, 893, 891, 1, 0, 0, 0, 893, 892, 1, 0, 0, 0, 894, 896,
		1, 0, 0, 0, 895, 890, 1, 0, 0, 0, 895, 896, 1, 0, 0, 0, 896, 898, 1, 0,
		0, 0, 897, 883, 1, 0, 0, 0, 897, 898, 1, 0, 0, 0, 898, 904, 1, 0, 0, 0,
		899, 900, 5, 391, 0, 0, 900, 901, 5, 2, 0, 0, 901, 902, 3, 290, 145, 0,
		902, 903, 5, 3, 0, 0, 903, 905, 1, 0, 0, 0, 904, 899, 1, 0, 0, 0, 904,
		905, 1, 0, 0, 0, 905, 907, 1, 0, 0, 0, 906, 908, 3, 248, 124, 0, 907, 906,
		1, 0, 0, 0, 907, 908, 1, 0, 0, 0, 908, 911, 1, 0, 0, 0, 909, 910, 5, 55,
		0, 0, 910, 912, 3, 248, 124, 0, 911, 909, 1, 0, 0, 0, 911, 912, 1, 0, 0,
		0, 912, 915, 1, 0, 0, 0, 913, 914, 5, 30, 0, 0, 914, 916, 3, 164, 82, 0,
		915, 913, 1, 0, 0, 0, 915, 916, 1, 0, 0, 0, 916, 983, 1, 0, 0, 0, 917,
		918, 5, 99, 0, 0, 918, 922, 5, 488, 0, 0, 919, 920, 5, 220, 0, 0, 920,
		921, 5, 306, 0, 0, 921, 923, 5, 170, 0, 0, 922, 919, 1, 0, 0, 0, 922, 923,
		1, 0, 0, 0, 923, 924, 1, 0, 0, 0, 924, 929, 3, 260, 130, 0, 925, 926, 5,
		2, 0, 0, 926, 927, 3, 262, 131, 0, 927, 928, 5, 3, 0, 0, 928, 930, 1, 0,
		0, 0, 929, 925, 1, 0, 0, 0, 929, 930, 1, 0, 0, 0, 930, 933, 1, 0, 0, 0,
		931, 932, 5, 82, 0, 0, 932, 934, 5, 527, 0, 0, 933, 931, 1, 0, 0, 0, 933,
		934, 1, 0, 0, 0, 934, 935, 1, 0, 0, 0, 935, 936, 5, 30, 0, 0, 936, 937,
		3, 164, 82, 0, 937, 983, 1, 0, 0, 0, 938, 940, 5, 99, 0, 0, 939, 941, 5,
		175, 0, 0, 940, 939, 1, 0, 0, 0, 940, 941, 1, 0, 0, 0, 941, 942, 1, 0,
		0, 0, 942, 946, 5, 438, 0, 0, 943, 944, 5, 220, 0, 0, 944, 945, 5, 306,
		0, 0, 945, 947, 5, 170, 0, 0, 946, 943, 1, 0, 0, 0, 946, 947, 1, 0, 0,
		0, 947, 948, 1, 0, 0, 0, 948, 949, 3, 260, 130, 0, 949, 950, 5, 262, 0,
		0, 950, 956, 3, 260, 130, 0, 951, 952, 5, 495, 0, 0, 952, 954, 5, 391,
		0, 0, 953, 955, 3, 238, 119, 0, 954, 953, 1, 0, 0, 0, 954, 955, 1, 0, 0,
		0, 955, 957, 1, 0, 0, 0, 956, 951, 1, 0, 0, 0, 956, 957, 1, 0, 0, 0, 957,
		983, 1, 0, 0, 0, 958, 959, 5, 99, 0, 0, 959, 960, 5, 393, 0, 0, 960, 964,
		5, 344, 0, 0, 961, 962, 5, 220, 0, 0, 962, 963, 5, 306, 0, 0, 963, 965,
		5, 170, 0, 0, 964, 961, 1, 0, 0, 0, 964, 965, 1, 0, 0, 0, 965, 966, 1,
		0, 0, 0, 966, 967, 3, 378, 189, 0, 967, 968, 5, 312, 0, 0, 968, 969, 3,
		260, 130, 0, 969, 970, 5, 30, 0, 0, 970, 971, 7, 4, 0, 0, 971, 975, 5,
		455, 0, 0, 972, 976, 3, 130, 65, 0, 973, 974, 5, 388, 0, 0, 974, 976, 3,
		378, 189, 0, 975, 972, 1, 0, 0, 0, 975, 973, 1, 0, 0, 0, 976, 977, 1, 0,
		0, 0, 977, 978, 5, 478, 0, 0, 978, 979, 5, 2, 0, 0, 979, 980, 3, 308, 154,
		0, 980, 981, 5, 3, 0, 0, 981, 983, 1, 0, 0, 0, 982, 834, 1, 0, 0, 0, 982,
		917, 1, 0, 0, 0, 982, 938, 1, 0, 0, 0, 982, 958, 1, 0, 0, 0, 983, 17, 1,
		0, 0, 0, 984, 985, 5, 22, 0, 0, 985, 986, 5, 488, 0, 0, 986, 991, 3, 260,
		130, 0, 987, 988, 5, 2, 0, 0, 988, 989, 3, 262, 131, 0, 989, 990, 5, 3,
		0, 0, 990, 992, 1, 0, 0, 0, 991, 987, 1, 0, 0, 0, 991, 992, 1, 0, 0, 0,
		992, 993, 1, 0, 0, 0, 993, 994, 5, 30, 0, 0, 994, 995, 3, 164, 82, 0, 995,
		1003, 1, 0, 0, 0, 996, 997, 5, 22, 0, 0, 997, 998, 5, 427, 0, 0, 998, 999,
		5, 485, 0, 0, 999, 1000, 3, 260, 130, 0, 1000, 1001, 3, 248, 124, 0, 1001,
		1003, 1, 0, 0, 0, 1002, 984, 1, 0, 0, 0, 1002, 996, 1, 0, 0, 0, 1003, 19,
		1, 0, 0, 0, 1004, 1005, 5, 150, 0, 0, 1005, 1006, 5, 67, 0, 0, 1006, 1007,
		5, 365, 0, 0, 1007, 1008, 5, 44, 0, 0, 1008, 1009, 5, 493, 0, 0, 1009,
		1010, 5, 527, 0, 0, 1010, 1011, 5, 501, 0, 0, 1011, 1012, 5, 532, 0, 0,
		1012, 21, 1, 0, 0, 0, 1013, 1014, 5, 16, 0, 0, 1014, 1015, 5, 411, 0, 0,
		1015, 1016, 5, 375, 0, 0, 1016, 1017, 5, 425, 0, 0, 1017, 1018, 5, 193,
		0, 0, 1018, 1020, 3, 24, 12, 0, 1019, 1021, 3, 26, 13, 0, 1020, 1019, 1,
		0, 0, 0, 1020, 1021, 1, 0, 0, 0, 1021, 1159, 1, 0, 0, 0, 1022, 1023, 5,
		16, 0, 0, 1023, 1024, 5, 411, 0, 0, 1024, 1025, 5, 375, 0, 0, 1025, 1026,
		5, 145, 0, 0, 1026, 1027, 5, 193, 0, 0, 1027, 1159, 3, 24, 12, 0, 1028,
		1029, 5, 16, 0, 0, 1029, 1030, 5, 407, 0, 0, 1030, 1031, 5, 375, 0, 0,
		1031, 1032, 5, 425, 0, 0, 1032, 1033, 5, 352, 0, 0, 1033, 1034, 5, 2, 0,
		0, 1034, 1035, 3, 250, 125, 0, 1035, 1036, 5, 3, 0, 0, 1036, 1159, 1, 0,
		0, 0, 1037, 1038, 5, 16, 0, 0, 1038, 1039, 5, 407, 0, 0, 1039, 1040, 5,
		375, 0, 0, 1040, 1041, 5, 487, 0, 0, 1041, 1042, 5, 352, 0, 0, 1042, 1043,
		5, 2, 0, 0, 1043, 1044, 3, 250, 125, 0, 1044, 1045, 5, 3, 0, 0, 1045, 1159,
		1, 0, 0, 0, 1046, 1047, 5, 16, 0, 0, 1047, 1048, 5, 371, 0, 0, 1048, 1049,
		5, 438, 0, 0, 1049, 1159, 3, 24, 12, 0, 1050, 1051, 5, 16, 0, 0, 1051,
		1052, 5, 64, 0, 0, 1052, 1053, 5, 371, 0, 0, 1053, 1054, 5, 438, 0, 0,
		1054, 1159, 3, 24, 12, 0, 1055, 1056, 5, 16, 0, 0, 1056, 1057, 5, 85, 0,
		0, 1057, 1058, 5, 438, 0, 0, 1058, 1060, 3, 24, 12, 0, 1059, 1061, 3, 26,
		13, 0, 1060, 1059, 1, 0, 0, 0, 1060, 1061, 1, 0, 0, 0, 1061, 1159, 1, 0,
		0, 0, 1062, 1063, 5, 16, 0, 0, 1063, 1067, 5, 407, 0, 0, 1064, 1068, 5,
		194, 0, 0, 1065, 1066, 5, 21, 0, 0, 1066, 1068, 5, 195, 0, 0, 1067, 1064,
		1, 0, 0, 0, 1067, 1065, 1, 0, 0, 0, 1068, 1069, 1, 0, 0, 0, 1069, 1074,
		5, 89, 0, 0, 1070, 1071, 5, 2, 0, 0, 1071, 1072, 3, 250, 125, 0, 1072,
		1073, 5, 3, 0, 0, 1073, 1075, 1, 0, 0, 0, 1074, 1070, 1, 0, 0, 0, 1074,
		1075, 1, 0, 0, 0, 1075, 1077, 1, 0, 0, 0, 1076, 1078, 5, 21, 0, 0, 1077,
		1076, 1, 0, 0, 0, 1077, 1078, 1, 0, 0, 0, 1078, 1159, 1, 0, 0, 0, 1079,
		1080, 5, 16, 0, 0, 1080, 1081, 5, 72, 0, 0, 1081, 1083, 3, 296, 148, 0,
		1082, 1084, 3, 248, 124, 0, 1083, 1082, 1, 0, 0, 0, 1083, 1084, 1, 0, 0,
		0, 1084, 1159, 1, 0, 0, 0, 1085, 1086, 5, 16, 0, 0, 1086, 1087, 5, 362,
		0, 0, 1087, 1095, 5, 140, 0, 0, 1088, 1089, 5, 312, 0, 0, 1089, 1090, 5,
		2, 0, 0, 1090, 1091, 5, 527, 0, 0, 1091, 1092, 5, 4, 0, 0, 1092, 1093,
		5, 527, 0, 0, 1093, 1094, 1, 0, 0, 0, 1094, 1096, 5, 3, 0, 0, 1095, 1088,
		1, 0, 0, 0, 1095, 1096, 1, 0, 0, 0, 1096, 1159, 1, 0, 0, 0, 1097, 1098,
		5, 16, 0, 0, 1098, 1099, 5, 64, 0, 0, 1099, 1100, 5, 362, 0, 0, 1100, 1108,
		5, 140, 0, 0, 1101, 1102, 5, 312, 0, 0, 1102, 1103, 5, 2, 0, 0, 1103, 1104,
		5, 527, 0, 0, 1104, 1105, 5, 4, 0, 0, 1105, 1106, 5, 527, 0, 0, 1106, 1107,
		1, 0, 0, 0, 1107, 1109, 5, 3, 0, 0, 1108, 1101, 1, 0, 0, 0, 1108, 1109,
		1, 0, 0, 0, 1109, 1159, 1, 0, 0, 0, 1110, 1111, 5, 16, 0, 0, 1111, 1112,
		5, 73, 0, 0, 1112, 1120, 5, 457, 0, 0, 1113, 1114, 5, 312, 0, 0, 1114,
		1115, 5, 2, 0, 0, 1115, 1116, 5, 527, 0, 0, 1116, 1117, 5, 4, 0, 0, 1117,
		1118, 5, 527, 0, 0, 1118, 1119, 1, 0, 0, 0, 1119, 1121, 5, 3, 0, 0, 1120,
		1113, 1, 0, 0, 0, 1120, 1121, 1, 0, 0, 0, 1121, 1159, 1, 0, 0, 0, 1122,
		1123, 5, 16, 0, 0, 1123, 1124, 5, 407, 0, 0, 1124, 1125, 5, 438, 0, 0,
		1125, 1126, 3, 260, 130, 0, 1126, 1127, 5, 324, 0, 0, 1127, 1129, 5, 487,
		0, 0, 1128, 1130, 3, 248, 124, 0, 1129, 1128, 1, 0, 0, 0, 1129, 1130, 1,
		0, 0, 0, 1130, 1159, 1, 0, 0, 0, 1131, 1132, 5, 16, 0, 0, 1132, 1133, 5,
		139, 0, 0, 1133, 1134, 5, 441, 0, 0, 1134, 1159, 5, 532, 0, 0, 1135, 1136,
		5, 16, 0, 0, 1136, 1137, 5, 411, 0, 0, 1137, 1138, 5, 441, 0, 0, 1138,
		1139, 5, 427, 0, 0, 1139, 1141, 5, 191, 0, 0, 1140, 1142, 5, 486, 0, 0,
		1141, 1140, 1, 0, 0, 0, 1141, 1142, 1, 0, 0, 0, 1142, 1159, 1, 0, 0, 0,
		1143, 1144, 5, 16, 0, 0, 1144, 1145, 5, 97, 0, 0, 1145, 1146, 5, 441, 0,
		0, 1146, 1148, 5, 532, 0, 0, 1147, 1149, 3, 248, 124, 0, 1148, 1147, 1,
		0, 0, 0, 1148, 1149, 1, 0, 0, 0, 1149, 1159, 1, 0, 0, 0, 1150, 1151, 5,
		16, 0, 0, 1151, 1152, 5, 407, 0, 0, 1152, 1153, 5, 438, 0, 0, 1153, 1154,
		3, 260, 130, 0, 1154, 1156, 5, 425, 0, 0, 1155, 1157, 3, 248, 124, 0, 1156,
		1155, 1, 0, 0, 0, 1156, 1157, 1, 0, 0, 0, 1157, 1159, 1, 0, 0, 0, 1158,
		1013, 1, 0, 0, 0, 1158, 1022, 1, 0, 0, 0, 1158, 1028, 1, 0, 0, 0, 1158,
		1037, 1, 0, 0, 0, 1158, 1046, 1, 0, 0, 0, 1158, 1050, 1, 0, 0, 0, 1158,
		1055, 1, 0, 0, 0, 1158, 1062, 1, 0, 0, 0, 1158, 1079, 1, 0, 0, 0, 1158,
		1085, 1, 0, 0, 0, 1158, 1097, 1, 0, 0, 0, 1158, 1110, 1, 0, 0, 0, 1158,
		1122, 1, 0, 0, 0, 1158, 1131, 1, 0, 0, 0, 1158, 1135, 1, 0, 0, 0, 1158,
		1143, 1, 0, 0, 0, 1158, 1150, 1, 0, 0, 0, 1159, 23, 1, 0, 0, 0, 1160, 1162,
		3, 260, 130, 0, 1161, 1163, 3, 242, 121, 0, 1162, 1161, 1, 0, 0, 0, 1162,
		1163, 1, 0, 0, 0, 1163, 1165, 1, 0, 0, 0, 1164, 1166, 3, 372, 186, 0, 1165,
		1164, 1, 0, 0, 0, 1165, 1166, 1, 0, 0, 0, 1166, 1168, 1, 0, 0, 0, 1167,
		1169, 3, 342, 171, 0, 1168, 1167, 1, 0, 0, 0, 1168, 1169, 1, 0, 0, 0, 1169,
		1171, 1, 0, 0, 0, 1170, 1172, 3, 296, 148, 0, 1171, 1170, 1, 0, 0, 0, 1171,
		1172, 1, 0, 0, 0, 1172, 1173, 1, 0, 0, 0, 1173, 1175, 3, 258, 129, 0, 1174,
		1176, 3, 368, 184, 0, 1175, 1174, 1, 0, 0, 0, 1175, 1176, 1, 0, 0, 0, 1176,
		1178, 1, 0, 0, 0, 1177, 1179, 3, 202, 101, 0, 1178, 1177, 1, 0, 0, 0, 1178,
		1179, 1, 0, 0, 0, 1179, 25, 1, 0, 0, 0, 1180, 1181, 5, 262, 0, 0, 1181,
		1185, 5, 527, 0, 0, 1182, 1183, 5, 493, 0, 0, 1183, 1185, 3, 304, 152,
		0, 1184, 1180, 1, 0, 0, 0, 1184, 1182, 1, 0, 0, 0, 1185, 27, 1, 0, 0, 0,
		1186, 1192, 5, 40, 0, 0, 1187, 1188, 5, 495, 0, 0, 1188, 1190, 5, 253,
		0, 0, 1189, 1191, 3, 378, 189, 0, 1190, 1189, 1, 0, 0, 0, 1190, 1191, 1,
		0, 0, 0, 1191, 1193, 1, 0, 0, 0, 1192, 1187, 1, 0, 0, 0, 1192, 1193, 1,
		0, 0, 0, 1193, 1229, 1, 0, 0, 0, 1194, 1196, 5, 83, 0, 0, 1195, 1197, 5,
		496, 0, 0, 1196, 1195, 1, 0, 0, 0, 1196, 1197, 1, 0, 0, 0, 1197, 1203,
		1, 0, 0, 0, 1198, 1200, 5, 25, 0, 0, 1199, 1201, 5, 304, 0, 0, 1200, 1199,
		1, 0, 0, 0, 1200, 1201, 1, 0, 0, 0, 1201, 1202, 1, 0, 0, 0, 1202, 1204,
		5, 69, 0, 0, 1203, 1198, 1, 0, 0, 0, 1203, 1204, 1, 0, 0, 0, 1204, 1209,
		1, 0, 0, 0, 1205, 1207, 5, 304, 0, 0, 1206, 1205, 1, 0, 0, 0, 1206, 1207,
		1, 0, 0, 0, 1207, 1208, 1, 0, 0, 0, 1208, 1210, 5, 369, 0, 0, 1209, 1206,
		1, 0, 0, 0, 1209, 1210, 1, 0, 0, 0, 1210, 1229, 1, 0, 0, 0, 1211, 1213,
		5, 390, 0, 0, 1212, 1214, 5, 496, 0, 0, 1213, 1212, 1, 0, 0, 0, 1213, 1214,
		1, 0, 0, 0, 1214, 1220, 1, 0, 0, 0, 1215, 1217, 5, 25, 0, 0, 1216, 1218,
		5, 304, 0, 0, 1217, 1216, 1, 0, 0, 0, 1217, 1218, 1, 0, 0, 0, 1218, 1219,
		1, 0, 0, 0, 1219, 1221, 5, 69, 0, 0, 1220, 1215, 1, 0, 0, 0, 1220, 1221,
		1, 0, 0, 0, 1221, 1226, 1, 0, 0, 0, 1222, 1224, 5, 304, 0, 0, 1223, 1222,
		1, 0, 0, 0, 1223, 1224, 1, 0, 0, 0, 1224, 1225, 1, 0, 0, 0, 1225, 1227,
		5, 369, 0, 0, 1226, 1223, 1, 0, 0, 0, 1226, 1227, 1, 0, 0, 0, 1227, 1229,
		1, 0, 0, 0, 1228, 1186, 1, 0, 0, 0, 1228, 1194, 1, 0, 0, 0, 1228, 1211,
		1, 0, 0, 0, 1229, 29, 1, 0, 0, 0, 1230, 1231, 5, 202, 0, 0, 1231, 1232,
		3, 34, 17, 0, 1232, 1233, 5, 312, 0, 0, 1233, 1234, 3, 126, 63, 0, 1234,
		1238, 5, 455, 0, 0, 1235, 1239, 3, 130, 65, 0, 1236, 1237, 5, 388, 0, 0,
		1237, 1239, 5, 527, 0, 0, 1238, 1235, 1, 0, 0, 0, 1238, 1236, 1, 0, 0,
		0, 1239, 1311, 1, 0, 0, 0, 1240, 1241, 5, 202, 0, 0, 1241, 1242, 3, 34,
		17, 0, 1242, 1250, 5, 312, 0, 0, 1243, 1251, 5, 378, 0, 0, 1244, 1251,
		5, 74, 0, 0, 1245, 1251, 5, 420, 0, 0, 1246, 1247, 5, 427, 0, 0, 1247,
		1251, 5, 485, 0, 0, 1248, 1249, 5, 497, 0, 0, 1249, 1251, 5, 205, 0, 0,
		1250, 1243, 1, 0, 0, 0, 1250, 1244, 1, 0, 0, 0, 1250, 1245, 1, 0, 0, 0,
		1250, 1246, 1, 0, 0, 0, 1250, 1248, 1, 0, 0, 0, 1251, 1252, 1, 0, 0, 0,
		1252, 1253, 3, 124, 62, 0, 1253, 1257, 5, 455, 0, 0, 1254, 1258, 3, 130,
		65, 0, 1255, 1256, 5, 388, 0, 0, 1256, 1258, 5, 527, 0, 0, 1257, 1254,
		1, 0, 0, 0, 1257, 1255, 1, 0, 0, 0, 1258, 1311, 1, 0, 0, 0, 1259, 1260,
		5, 202, 0, 0, 1260, 1265, 5, 527, 0, 0, 1261, 1262, 5, 4, 0, 0, 1262, 1264,
		5, 527, 0, 0, 1263, 1261, 1, 0, 0, 0, 1264, 1267, 1, 0, 0, 0, 1265, 1263,
		1, 0, 0, 0, 1265, 1266, 1, 0, 0, 0, 1266, 1268, 1, 0, 0, 0, 1267, 1265,
		1, 0, 0, 0, 1268, 1269, 5, 455, 0, 0, 1269, 1311, 3, 130, 65, 0, 1270,
		1271, 5, 384, 0, 0, 1271, 1272, 3, 34, 17, 0, 1272, 1273, 5, 312, 0, 0,
		1273, 1274, 3, 126, 63, 0, 1274, 1278, 5, 193, 0, 0, 1275, 1279, 3, 130,
		65, 0, 1276, 1277, 5, 388, 0, 0, 1277, 1279, 5, 527, 0, 0, 1278, 1275,
		1, 0, 0, 0, 1278, 1276, 1, 0, 0, 0, 1279, 1311, 1, 0, 0, 0, 1280, 1281,
		5, 384, 0, 0, 1281, 1282, 3, 34, 17, 0, 1282, 1290, 5, 312, 0, 0, 1283,
		1291, 5, 378, 0, 0, 1284, 1291, 5, 74, 0, 0, 1285, 1291, 5, 420, 0, 0,
		1286, 1287, 5, 427, 0, 0, 1287, 1291, 5, 485, 0, 0, 1288, 1289, 5, 497,
		0, 0, 1289, 1291, 5, 205, 0, 0, 1290, 1283, 1, 0, 0, 0, 1290, 1284, 1,
		0, 0, 0, 1290, 1285, 1, 0, 0, 0, 1290, 1286, 1, 0, 0, 0, 1290, 1288, 1,
		0, 0, 0, 1291, 1292, 1, 0, 0, 0, 1292, 1293, 3, 124, 62, 0, 1293, 1297,
		5, 193, 0, 0, 1294, 1298, 3, 130, 65, 0, 1295, 1296, 5, 388, 0, 0, 1296,
		1298, 5, 527, 0, 0, 1297, 1294, 1, 0, 0, 0, 1297, 1295, 1, 0, 0, 0, 1298,
		1311, 1, 0, 0, 0, 1299, 1300, 5, 384, 0, 0, 1300, 1305, 5, 527, 0, 0, 1301,
		1302, 5, 4, 0, 0, 1302, 1304, 5, 527, 0, 0, 1303, 1301, 1, 0, 0, 0, 1304,
		1307, 1, 0, 0, 0, 1305, 1303, 1, 0, 0, 0, 1305, 1306, 1, 0, 0, 0, 1306,
		1308, 1, 0, 0, 0, 1307, 1305, 1, 0, 0, 0, 1308, 1309, 5, 193, 0, 0, 1309,
		1311, 3, 130, 65, 0, 1310, 1230, 1, 0, 0, 0, 1310, 1240, 1, 0, 0, 0, 1310,
		1259, 1, 0, 0, 0, 1310, 1270, 1, 0, 0, 0, 1310, 1280, 1, 0, 0, 0, 1310,
		1299, 1, 0, 0, 0, 1311, 31, 1, 0, 0, 0, 1312, 1314, 3, 378, 189, 0, 1313,
		1315, 3, 238, 119, 0, 1314, 1313, 1, 0, 0, 0, 1314, 1315, 1, 0, 0, 0, 1315,
		1318, 1, 0, 0, 0, 1316, 1318, 5, 21, 0, 0, 1317, 1312, 1, 0, 0, 0, 1317,
		1316, 1, 0, 0, 0, 1318, 33, 1, 0, 0, 0, 1319, 1324, 3, 32, 16, 0, 1320,
		1321, 5, 4, 0, 0, 1321, 1323, 3, 32, 16, 0, 1322, 1320, 1, 0, 0, 0, 1323,
		1326, 1, 0, 0, 0, 1324, 1322, 1, 0, 0, 0, 1324, 1325, 1, 0, 0, 0, 1325,
		35, 1, 0, 0, 0, 1326, 1324, 1, 0, 0, 0, 1327, 1328, 5, 22, 0, 0, 1328,
		1329, 5, 438, 0, 0, 1329, 1330, 3, 260, 130, 0, 1330, 1335, 3, 44, 22,
		0, 1331, 1332, 5, 4, 0, 0, 1332, 1334, 3, 44, 22, 0, 1333, 1331, 1, 0,
		0, 0, 1334, 1337, 1, 0, 0, 0, 1335, 1333, 1, 0, 0, 0, 1335, 1336, 1, 0,
		0, 0, 1336, 1498, 1, 0, 0, 0, 1337, 1335, 1, 0, 0, 0, 1338, 1339, 5, 22,
		0, 0, 1339, 1340, 5, 438, 0, 0, 1340, 1341, 3, 260, 130, 0, 1341, 1342,
		5, 14, 0, 0, 1342, 1343, 5, 391, 0, 0, 1343, 1348, 3, 42, 21, 0, 1344,
		1345, 5, 4, 0, 0, 1345, 1347, 3, 42, 21, 0, 1346, 1344, 1, 0, 0, 0, 1347,
		1350, 1, 0, 0, 0, 1348, 1346, 1, 0, 0, 0, 1348, 1349, 1, 0, 0, 0, 1349,
		1498, 1, 0, 0, 0, 1350, 1348, 1, 0, 0, 0, 1351, 1352, 5, 22, 0, 0, 1352,
		1353, 5, 438, 0, 0, 1353, 1354, 3, 260, 130, 0, 1354, 1355, 5, 150, 0,
		0, 1355, 1356, 5, 391, 0, 0, 1356, 1361, 3, 40, 20, 0, 1357, 1358, 5, 4,
		0, 0, 1358, 1360, 3, 40, 20, 0, 1359, 1357, 1, 0, 0, 0, 1360, 1363, 1,
		0, 0, 0, 1361, 1359, 1, 0, 0, 0, 1361, 1362, 1, 0, 0, 0, 1362, 1498, 1,
		0, 0, 0, 1363, 1361, 1, 0, 0, 0, 1364, 1365, 5, 22, 0, 0, 1365, 1366, 5,
		437, 0, 0, 1366, 1498, 3, 38, 19, 0, 1367, 1368, 5, 22, 0, 0, 1368, 1369,
		5, 111, 0, 0, 1369, 1370, 3, 378, 189, 0, 1370, 1371, 5, 407, 0, 0, 1371,
		1372, 7, 5, 0, 0, 1372, 1373, 5, 357, 0, 0, 1373, 1375, 5, 532, 0, 0, 1374,
		1376, 3, 378, 189, 0, 1375, 1374, 1, 0, 0, 0, 1375, 1376, 1, 0, 0, 0, 1376,
		1498, 1, 0, 0, 0, 1377, 1378, 5, 22, 0, 0, 1378, 1379, 5, 111, 0, 0, 1379,
		1380, 3, 378, 189, 0, 1380, 1381, 5, 370, 0, 0, 1381, 1382, 3, 378, 189,
		0, 1382, 1498, 1, 0, 0, 0, 1383, 1384, 5, 22, 0, 0, 1384, 1385, 5, 111,
		0, 0, 1385, 1386, 3, 378, 189, 0, 1386, 1387, 5, 407, 0, 0, 1387, 1388,
		5, 352, 0, 0, 1388, 1389, 5, 2, 0, 0, 1389, 1390, 3, 250, 125, 0, 1390,
		1391, 5, 3, 0, 0, 1391, 1498, 1, 0, 0, 0, 1392, 1393, 5, 22, 0, 0, 1393,
		1394, 5, 67, 0, 0, 1394, 1395, 3, 378, 189, 0, 1395, 1396, 5, 370, 0, 0,
		1396, 1397, 3, 378, 189, 0, 1397, 1498, 1, 0, 0, 0, 1398, 1399, 5, 22,
		0, 0, 1399, 1400, 5, 67, 0, 0, 1400, 1401, 3, 378, 189, 0, 1401, 1402,
		5, 407, 0, 0, 1402, 1403, 5, 352, 0, 0, 1403, 1404, 5, 2, 0, 0, 1404, 1405,
		3, 250, 125, 0, 1405, 1406, 5, 3, 0, 0, 1406, 1498, 1, 0, 0, 0, 1407, 1408,
		5, 22, 0, 0, 1408, 1409, 5, 67, 0, 0, 1409, 1410, 3, 378, 189, 0, 1410,
		1411, 5, 294, 0, 0, 1411, 1412, 5, 82, 0, 0, 1412, 1413, 5, 527, 0, 0,
		1413, 1498, 1, 0, 0, 0, 1414, 1415, 5, 22, 0, 0, 1415, 1416, 5, 378, 0,
		0, 1416, 1418, 3, 122, 61, 0, 1417, 1419, 3, 248, 124, 0, 1418, 1417, 1,
		0, 0, 0, 1418, 1419, 1, 0, 0, 0, 1419, 1498, 1, 0, 0, 0, 1420, 1421, 5,
		22, 0, 0, 1421, 1422, 5, 79, 0, 0, 1422, 1423, 5, 205, 0, 0, 1423, 1424,
		3, 260, 130, 0, 1424, 1425, 5, 407, 0, 0, 1425, 1426, 5, 2, 0, 0, 1426,
		1427, 3, 250, 125, 0, 1427, 1428, 5, 3, 0, 0, 1428, 1498, 1, 0, 0, 0, 1429,
		1430, 5, 22, 0, 0, 1430, 1431, 5, 497, 0, 0, 1431, 1432, 5, 205, 0, 0,
		1432, 1434, 3, 122, 61, 0, 1433, 1435, 3, 248, 124, 0, 1434, 1433, 1, 0,
		0, 0, 1434, 1435, 1, 0, 0, 0, 1435, 1498, 1, 0, 0, 0, 1436, 1437, 5, 22,
		0, 0, 1437, 1438, 5, 497, 0, 0, 1438, 1439, 5, 344, 0, 0, 1439, 1441, 3,
		122, 61, 0, 1440, 1442, 3, 248, 124, 0, 1441, 1440, 1, 0, 0, 0, 1441, 1442,
		1, 0, 0, 0, 1442, 1498, 1, 0, 0, 0, 1443, 1444, 5, 22, 0, 0, 1444, 1445,
		5, 392, 0, 0, 1445, 1446, 5, 267, 0, 0, 1446, 1447, 5, 188, 0, 0, 1447,
		1449, 3, 260, 130, 0, 1448, 1450, 3, 248, 124, 0, 1449, 1448, 1, 0, 0,
		0, 1449, 1450, 1, 0, 0, 0, 1450, 1457, 1, 0, 0, 0, 1451, 1452, 5, 193,
		0, 0, 1452, 1453, 3, 378, 189, 0, 1453, 1454, 5, 2, 0, 0, 1454, 1455, 3,
		250, 125, 0, 1455, 1456, 5, 3, 0, 0, 1456, 1458, 1, 0, 0, 0, 1457, 1451,
		1, 0, 0, 0, 1457, 1458, 1, 0, 0, 0, 1458, 1498, 1, 0, 0, 0, 1459, 1460,
		5, 22, 0, 0, 1460, 1461, 5, 419, 0, 0, 1461, 1463, 3, 378, 189, 0, 1462,
		1464, 3, 248, 124, 0, 1463, 1462, 1, 0, 0, 0, 1463, 1464, 1, 0, 0, 0, 1464,
		1498, 1, 0, 0, 0, 1465, 1466, 5, 22, 0, 0, 1466, 1467, 5, 438, 0, 0, 1467,
		1468, 3, 260, 130, 0, 1468, 1469, 5, 407, 0, 0, 1469, 1470, 5, 2, 0, 0,
		1470, 1471, 3, 250, 125, 0, 1471, 1472, 5, 3, 0, 0, 1472, 1498, 1, 0, 0,
		0, 1473, 1474, 5, 22, 0, 0, 1474, 1475, 5, 427, 0, 0, 1475, 1476, 5, 344,
		0, 0, 1476, 1477, 3, 122, 61, 0, 1477, 1478, 3, 248, 124, 0, 1478, 1498,
		1, 0, 0, 0, 1479, 1480, 5, 22, 0, 0, 1480, 1483, 5, 477, 0, 0, 1481, 1482,
		5, 220, 0, 0, 1482, 1484, 5, 170, 0, 0, 1483, 1481, 1, 0, 0, 0, 1483, 1484,
		1, 0, 0, 0, 1484, 1485, 1, 0, 0, 0, 1485, 1486, 3, 132, 66, 0, 1486, 1489,
		3, 72, 36, 0, 1487, 1488, 5, 82, 0, 0, 1488, 1490, 5, 527, 0, 0, 1489,
		1487, 1, 0, 0, 0, 1489, 1490, 1, 0, 0, 0, 1490, 1498, 1, 0, 0, 0, 1491,
		1492, 5, 22, 0, 0, 1492, 1493, 5, 377, 0, 0, 1493, 1495, 3, 378, 189, 0,
		1494, 1496, 3, 248, 124, 0, 1495, 1494, 1, 0, 0, 0, 1495, 1496, 1, 0, 0,
		0, 1496, 1498, 1, 0, 0, 0, 1497, 1327, 1, 0, 0, 0, 1497, 1338, 1, 0, 0,
		0, 1497, 1351, 1, 0, 0, 0, 1497, 1364, 1, 0, 0, 0, 1497, 1367, 1, 0, 0,
		0, 1497, 1377, 1, 0, 0, 0, 1497, 1383, 1, 0, 0, 0, 1497, 1392, 1, 0, 0,
		0, 1497, 1398, 1, 0, 0, 0, 1497, 1407, 1, 0, 0, 0, 1497, 1414, 1, 0, 0,
		0, 1497, 1420, 1, 0, 0, 0, 1497, 1429, 1, 0, 0, 0, 1497, 1436, 1, 0, 0,
		0, 1497, 1443, 1, 0, 0, 0, 1497, 1459, 1, 0, 0, 0, 1497, 1465, 1, 0, 0,
		0, 1497, 1473, 1, 0, 0, 0, 1497, 1479, 1, 0, 0, 0, 1497, 1491, 1, 0, 0,
		0, 1498, 37, 1, 0, 0, 0, 1499, 1500, 5, 14, 0, 0, 1500, 1501, 5, 37, 0,
		0, 1501, 1506, 5, 527, 0, 0, 1502, 1503, 5, 4, 0, 0, 1503, 1505, 5, 527,
		0, 0, 1504, 1502, 1, 0, 0, 0, 1505, 1508, 1, 0, 0, 0, 1506, 1504, 1, 0,
		0, 0, 1506, 1507, 1, 0, 0, 0, 1507, 1510, 1, 0, 0, 0, 1508, 1506, 1, 0,
		0, 0, 1509, 1511, 3, 248, 124, 0, 1510, 1509, 1, 0, 0, 0, 1510, 1511, 1,
		0, 0, 0, 1511, 1598, 1, 0, 0, 0, 1512, 1513, 7, 6, 0, 0, 1513, 1514, 5,
		37, 0, 0, 1514, 1519, 5, 527, 0, 0, 1515, 1516, 5, 4, 0, 0, 1516, 1518,
		5, 527, 0, 0, 1517, 1515, 1, 0, 0, 0, 1518, 1521, 1, 0, 0, 0, 1519, 1517,
		1, 0, 0, 0, 1519, 1520, 1, 0, 0, 0, 1520, 1598, 1, 0, 0, 0, 1521, 1519,
		1, 0, 0, 0, 1522, 1523, 5, 132, 0, 0, 1523, 1524, 5, 37, 0, 0, 1524, 1529,
		5, 527, 0, 0, 1525, 1526, 5, 4, 0, 0, 1526, 1528, 5, 527, 0, 0, 1527, 1525,
		1, 0, 0, 0, 1528, 1531, 1, 0, 0, 0, 1529, 1527, 1, 0, 0, 0, 1529, 1530,
		1, 0, 0, 0, 1530, 1598, 1, 0, 0, 0, 1531, 1529, 1, 0, 0, 0, 1532, 1533,
		5, 14, 0, 0, 1533, 1534, 5, 309, 0, 0, 1534, 1598, 5, 527, 0, 0, 1535,
		1536, 5, 150, 0, 0, 1536, 1537, 5, 309, 0, 0, 1537, 1598, 5, 527, 0, 0,
		1538, 1539, 5, 14, 0, 0, 1539, 1540, 5, 186, 0, 0, 1540, 1598, 5, 527,
		0, 0, 1541, 1542, 5, 150, 0, 0, 1542, 1543, 5, 186, 0, 0, 1543, 1598, 5,
		527, 0, 0, 1544, 1545, 5, 14, 0, 0, 1545, 1546, 5, 55, 0, 0, 1546, 1547,
		3, 122, 61, 0, 1547, 1552, 5, 527, 0, 0, 1548, 1549, 5, 4, 0, 0, 1549,
		1551, 5, 527, 0, 0, 1550, 1548, 1, 0, 0, 0, 1551, 1554, 1, 0, 0, 0, 1552,
		1550, 1, 0, 0, 0, 1552, 1553, 1, 0, 0, 0, 1553, 1598, 1, 0, 0, 0, 1554,
		1552, 1, 0, 0, 0, 1555, 1556, 5, 150, 0, 0, 1556, 1557, 5, 55, 0, 0, 1557,
		1558, 3, 122, 61, 0, 1558, 1563, 5, 527, 0, 0, 1559, 1560, 5, 4, 0, 0,
		1560, 1562, 5, 527, 0, 0, 1561, 1559, 1, 0, 0, 0, 1562, 1565, 1, 0, 0,
		0, 1563, 1561, 1, 0, 0, 0, 1563, 1564, 1, 0, 0, 0, 1564, 1598, 1, 0, 0,
		0, 1565, 1563, 1, 0, 0, 0, 1566, 1567, 5, 150, 0, 0, 1567, 1568, 5, 21,
		0, 0, 1568, 1569, 5, 55, 0, 0, 1569, 1598, 3, 122, 61, 0, 1570, 1571, 5,
		407, 0, 0, 1571, 1572, 5, 267, 0, 0, 1572, 1573, 5, 164, 0, 0, 1573, 1575,
		5, 218, 0, 0, 1574, 1576, 3, 248, 124, 0, 1575, 1574, 1, 0, 0, 0, 1575,
		1576, 1, 0, 0, 0, 1576, 1598, 1, 0, 0, 0, 1577, 1578, 5, 294, 0, 0, 1578,
		1579, 5, 37, 0, 0, 1579, 1584, 5, 527, 0, 0, 1580, 1581, 5, 4, 0, 0, 1581,
		1583, 5, 527, 0, 0, 1582, 1580, 1, 0, 0, 0, 1583, 1586, 1, 0, 0, 0, 1584,
		1582, 1, 0, 0, 0, 1584, 1585, 1, 0, 0, 0, 1585, 1587, 1, 0, 0, 0, 1586,
		1584, 1, 0, 0, 0, 1587, 1588, 5, 407, 0, 0, 1588, 1589, 5, 2, 0, 0, 1589,
		1590, 3, 250, 125, 0, 1590, 1591, 5, 3, 0, 0, 1591, 1598, 1, 0, 0, 0, 1592,
		1593, 5, 294, 0, 0, 1593, 1594, 7, 1, 0, 0, 1594, 1595, 5, 527, 0, 0, 1595,
		1596, 5, 215, 0, 0, 1596, 1598, 5, 527, 0, 0, 1597, 1499, 1, 0, 0, 0, 1597,
		1512, 1, 0, 0, 0, 1597, 1522, 1, 0, 0, 0, 1597, 1532, 1, 0, 0, 0, 1597,
		1535, 1, 0, 0, 0, 1597, 1538, 1, 0, 0, 0, 1597, 1541, 1, 0, 0, 0, 1597,
		1544, 1, 0, 0, 0, 1597, 1555, 1, 0, 0, 0, 1597, 1566, 1, 0, 0, 0, 1597,
		1570, 1, 0, 0, 0, 1597, 1577, 1, 0, 0, 0, 1597, 1592, 1, 0, 0, 0, 1598,
		39, 1, 0, 0, 0, 1599, 1601, 3, 378, 189, 0, 1600, 1602, 3, 248, 124, 0,
		1601, 1600, 1, 0, 0, 0, 1601, 1602, 1, 0, 0, 0, 1602, 41, 1, 0, 0, 0, 1603,
		1604, 3, 378, 189, 0, 1604, 1608, 3, 238, 119, 0, 1605, 1606, 5, 153, 0,
		0, 1606, 1607, 5, 250, 0, 0, 1607, 1609, 3, 238, 119, 0, 1608, 1605, 1,
		0, 0, 0, 1608, 1609, 1, 0, 0, 0, 1609, 1611, 1, 0, 0, 0, 1610, 1612, 3,
		50, 25, 0, 1611, 1610, 1, 0, 0, 0, 1611, 1612, 1, 0, 0, 0, 1612, 1614,
		1, 0, 0, 0, 1613, 1615, 3, 248, 124, 0, 1614, 1613, 1, 0, 0, 0, 1614, 1615,
		1, 0, 0, 0, 1615, 43, 1, 0, 0, 0, 1616, 1617, 5, 14, 0, 0, 1617, 1618,
		5, 80, 0, 0, 1618, 1620, 3, 268, 134, 0, 1619, 1621, 3, 46, 23, 0, 1620,
		1619, 1, 0, 0, 0, 1620, 1621, 1, 0, 0, 0, 1621, 1623, 1, 0, 0, 0, 1622,
		1624, 3, 48, 24, 0, 1623, 1622, 1, 0, 0, 0, 1623, 1624, 1, 0, 0, 0, 1624,
		1626, 1, 0, 0, 0, 1625, 1627, 3, 248, 124, 0, 1626, 1625, 1, 0, 0, 0, 1626,
		1627, 1, 0, 0, 0, 1627, 1855, 1, 0, 0, 0, 1628, 1629, 5, 14, 0, 0, 1629,
		1630, 5, 80, 0, 0, 1630, 1631, 5, 2, 0, 0, 1631, 1636, 3, 268, 134, 0,
		1632, 1633, 5, 4, 0, 0, 1633, 1635, 3, 268, 134, 0, 1634, 1632, 1, 0, 0,
		0, 1635, 1638, 1, 0, 0, 0, 1636, 1634, 1, 0, 0, 0, 1636, 1637, 1, 0, 0,
		0, 1637, 1639, 1, 0, 0, 0, 1638, 1636, 1, 0, 0, 0, 1639, 1641, 5, 3, 0,
		0, 1640, 1642, 3, 48, 24, 0, 1641, 1640, 1, 0, 0, 0, 1641, 1642, 1, 0,
		0, 0, 1642, 1644, 1, 0, 0, 0, 1643, 1645, 3, 248, 124, 0, 1644, 1643, 1,
		0, 0, 0, 1644, 1645, 1, 0, 0, 0, 1645, 1855, 1, 0, 0, 0, 1646, 1647, 5,
		150, 0, 0, 1647, 1648, 5, 80, 0, 0, 1648, 1650, 3, 378, 189, 0, 1649, 1651,
		3, 50, 25, 0, 1650, 1649, 1, 0, 0, 0, 1650, 1651, 1, 0, 0, 0, 1651, 1653,
		1, 0, 0, 0, 1652, 1654, 3, 248, 124, 0, 1653, 1652, 1, 0, 0, 0, 1653, 1654,
		1, 0, 0, 0, 1654, 1855, 1, 0, 0, 0, 1655, 1656, 5, 294, 0, 0, 1656, 1657,
		5, 80, 0, 0, 1657, 1659, 3, 268, 134, 0, 1658, 1660, 3, 46, 23, 0, 1659,
		1658, 1, 0, 0, 0, 1659, 1660, 1, 0, 0, 0, 1660, 1662, 1, 0, 0, 0, 1661,
		1663, 3, 50, 25, 0, 1662, 1661, 1, 0, 0, 0, 1662, 1663, 1, 0, 0, 0, 1663,
		1665, 1, 0, 0, 0, 1664, 1666, 3, 248, 124, 0, 1665, 1664, 1, 0, 0, 0, 1665,
		1666, 1, 0, 0, 0, 1666, 1855, 1, 0, 0, 0, 1667, 1668, 5, 317, 0, 0, 1668,
		1669, 5, 60, 0, 0, 1669, 1671, 3, 238, 119, 0, 1670, 1672, 3, 50, 25, 0,
		1671, 1670, 1, 0, 0, 0, 1671, 1672, 1, 0, 0, 0, 1672, 1674, 1, 0, 0, 0,
		1673, 1675, 3, 248, 124, 0, 1674, 1673, 1, 0, 0, 0, 1674, 1675, 1, 0, 0,
		0, 1675, 1855, 1, 0, 0, 0, 1676, 1678, 5, 14, 0, 0, 1677, 1679, 5, 445,
		0, 0, 1678, 1677, 1, 0, 0, 0, 1678, 1679, 1, 0, 0, 0, 1679, 1683, 1, 0,
		0, 0, 1680, 1684, 3, 278, 139, 0, 1681, 1684, 3, 280, 140, 0, 1682, 1684,
		3, 284, 142, 0, 1683, 1680, 1, 0, 0, 0, 1683, 1681, 1, 0, 0, 0, 1683, 1682,
		1, 0, 0, 0, 1684, 1689, 1, 0, 0, 0, 1685, 1686, 5, 2, 0, 0, 1686, 1687,
		3, 250, 125, 0, 1687, 1688, 5, 3, 0, 0, 1688, 1690, 1, 0, 0, 0, 1689, 1685,
		1, 0, 0, 0, 1689, 1690, 1, 0, 0, 0, 1690, 1705, 1, 0, 0, 0, 1691, 1692,
		5, 144, 0, 0, 1692, 1696, 5, 60, 0, 0, 1693, 1694, 5, 208, 0, 0, 1694,
		1697, 3, 238, 119, 0, 1695, 1697, 5, 358, 0, 0, 1696, 1693, 1, 0, 0, 0,
		1696, 1695, 1, 0, 0, 0, 1697, 1703, 1, 0, 0, 0, 1698, 1701, 5, 56, 0, 0,
		1699, 1702, 5, 532, 0, 0, 1700, 1702, 5, 34, 0, 0, 1701, 1699, 1, 0, 0,
		0, 1701, 1700, 1, 0, 0, 0, 1702, 1704, 1, 0, 0, 0, 1703, 1698, 1, 0, 0,
		0, 1703, 1704, 1, 0, 0, 0, 1704, 1706, 1, 0, 0, 0, 1705, 1691, 1, 0, 0,
		0, 1705, 1706, 1, 0, 0, 0, 1706, 1708, 1, 0, 0, 0, 1707, 1709, 3, 248,
		124, 0, 1708, 1707, 1, 0, 0, 0, 1708, 1709, 1, 0, 0, 0, 1709, 1855, 1,
		0, 0, 0, 1710, 1712, 5, 150, 0, 0, 1711, 1713, 5, 445, 0, 0, 1712, 1711,
		1, 0, 0, 0, 1712, 1713, 1, 0, 0, 0, 1713, 1714, 1, 0, 0, 0, 1714, 1717,
		5, 324, 0, 0, 1715, 1716, 5, 220, 0, 0, 1716, 1718, 5, 170, 0, 0, 1717,
		1715, 1, 0, 0, 0, 1717, 1718, 1, 0, 0, 0, 1718, 1719, 1, 0, 0, 0, 1719,
		1721, 3, 378, 189, 0, 1720, 1722, 5, 190, 0, 0, 1721, 1720, 1, 0, 0, 0,
		1721, 1722, 1, 0, 0, 0, 1722, 1726, 1, 0, 0, 0, 1723, 1724, 5, 193, 0,
		0, 1724, 1725, 5, 225, 0, 0, 1725, 1727, 3, 378, 189, 0, 1726, 1723, 1,
		0, 0, 0, 1726, 1727, 1, 0, 0, 0, 1727, 1855, 1, 0, 0, 0, 1728, 1730, 5,
		294, 0, 0, 1729, 1731, 5, 445, 0, 0, 1730, 1729, 1, 0, 0, 0, 1730, 1731,
		1, 0, 0, 0, 1731, 1732, 1, 0, 0, 0, 1732, 1735, 5, 324, 0, 0, 1733, 1734,
		5, 220, 0, 0, 1734, 1736, 5, 170, 0, 0, 1735, 1733, 1, 0, 0, 0, 1735, 1736,
		1, 0, 0, 0, 1736, 1742, 1, 0, 0, 0, 1737, 1743, 3, 378, 189, 0, 1738, 1743,
		3, 238, 119, 0, 1739, 1740, 5, 2, 0, 0, 1740, 1741, 5, 510, 0, 0, 1741,
		1743, 5, 3, 0, 0, 1742, 1737, 1, 0, 0, 0, 1742, 1738, 1, 0, 0, 0, 1742,
		1739, 1, 0, 0, 0, 1743, 1744, 1, 0, 0, 0, 1744, 1745, 5, 407, 0, 0, 1745,
		1746, 5, 2, 0, 0, 1746, 1747, 3, 250, 125, 0, 1747, 1748, 5, 3, 0, 0, 1748,
		1855, 1, 0, 0, 0, 1749, 1751, 5, 373, 0, 0, 1750, 1752, 3, 102, 51, 0,
		1751, 1750, 1, 0, 0, 0, 1751, 1752, 1, 0, 0, 0, 1752, 1753, 1, 0, 0, 0,
		1753, 1755, 5, 495, 0, 0, 1754, 1756, 3, 102, 51, 0, 1755, 1754, 1, 0,
		0, 0, 1755, 1756, 1, 0, 0, 0, 1756, 1758, 1, 0, 0, 0, 1757, 1759, 5, 190,
		0, 0, 1758, 1757, 1, 0, 0, 0, 1758, 1759, 1, 0, 0, 0, 1759, 1761, 1, 0,
		0, 0, 1760, 1762, 3, 248, 124, 0, 1761, 1760, 1, 0, 0, 0, 1761, 1762, 1,
		0, 0, 0, 1762, 1855, 1, 0, 0, 0, 1763, 1764, 5, 373, 0, 0, 1764, 1765,
		5, 495, 0, 0, 1765, 1766, 5, 438, 0, 0, 1766, 1768, 3, 378, 189, 0, 1767,
		1769, 3, 248, 124, 0, 1768, 1767, 1, 0, 0, 0, 1768, 1769, 1, 0, 0, 0, 1769,
		1855, 1, 0, 0, 0, 1770, 1771, 5, 370, 0, 0, 1771, 1855, 3, 378, 189, 0,
		1772, 1773, 5, 370, 0, 0, 1773, 1774, 5, 391, 0, 0, 1774, 1775, 3, 378,
		189, 0, 1775, 1776, 3, 378, 189, 0, 1776, 1855, 1, 0, 0, 0, 1777, 1778,
		5, 370, 0, 0, 1778, 1779, 5, 324, 0, 0, 1779, 1780, 3, 378, 189, 0, 1780,
		1781, 3, 378, 189, 0, 1781, 1855, 1, 0, 0, 0, 1782, 1783, 5, 370, 0, 0,
		1783, 1784, 5, 80, 0, 0, 1784, 1785, 3, 378, 189, 0, 1785, 1786, 3, 378,
		189, 0, 1786, 1855, 1, 0, 0, 0, 1787, 1788, 5, 14, 0, 0, 1788, 1855, 3,
		272, 136, 0, 1789, 1790, 5, 150, 0, 0, 1790, 1793, 5, 225, 0, 0, 1791,
		1792, 5, 220, 0, 0, 1792, 1794, 5, 170, 0, 0, 1793, 1791, 1, 0, 0, 0, 1793,
		1794, 1, 0, 0, 0, 1794, 1795, 1, 0, 0, 0, 1795, 1855, 3, 378, 189, 0, 1796,
		1797, 5, 156, 0, 0, 1797, 1798, 5, 180, 0, 0, 1798, 1801, 5, 527, 0, 0,
		1799, 1800, 5, 495, 0, 0, 1800, 1802, 3, 248, 124, 0, 1801, 1799, 1, 0,
		0, 0, 1801, 1802, 1, 0, 0, 0, 1802, 1855, 1, 0, 0, 0, 1803, 1804, 5, 294,
		0, 0, 1804, 1819, 5, 145, 0, 0, 1805, 1806, 5, 144, 0, 0, 1806, 1810, 5,
		60, 0, 0, 1807, 1808, 5, 208, 0, 0, 1808, 1811, 3, 238, 119, 0, 1809, 1811,
		5, 358, 0, 0, 1810, 1807, 1, 0, 0, 0, 1810, 1809, 1, 0, 0, 0, 1811, 1817,
		1, 0, 0, 0, 1812, 1815, 5, 56, 0, 0, 1813, 1816, 5, 532, 0, 0, 1814, 1816,
		5, 34, 0, 0, 1815, 1813, 1, 0, 0, 0, 1815, 1814, 1, 0, 0, 0, 1816, 1818,
		1, 0, 0, 0, 1817, 1812, 1, 0, 0, 0, 1817, 1818, 1, 0, 0, 0, 1818, 1820,
		1, 0, 0, 0, 1819, 1805, 1, 0, 0, 0, 1819, 1820, 1, 0, 0, 0, 1820, 1855,
		1, 0, 0, 0, 1821, 1822, 5, 294, 0, 0, 1822, 1823, 5, 82, 0, 0, 1823, 1855,
		5, 527, 0, 0, 1824, 1825, 5, 294, 0, 0, 1825, 1826, 5, 80, 0, 0, 1826,
		1827, 3, 378, 189, 0, 1827, 1828, 5, 82, 0, 0, 1828, 1829, 5, 527, 0, 0,
		1829, 1855, 1, 0, 0, 0, 1830, 1831, 5, 294, 0, 0, 1831, 1832, 5, 161, 0,
		0, 1832, 1833, 5, 455, 0, 0, 1833, 1835, 3, 378, 189, 0, 1834, 1836, 3,
		248, 124, 0, 1835, 1834, 1, 0, 0, 0, 1835, 1836, 1, 0, 0, 0, 1836, 1855,
		1, 0, 0, 0, 1837, 1839, 5, 14, 0, 0, 1838, 1840, 5, 445, 0, 0, 1839, 1838,
		1, 0, 0, 0, 1839, 1840, 1, 0, 0, 0, 1840, 1841, 1, 0, 0, 0, 1841, 1842,
		5, 325, 0, 0, 1842, 1843, 5, 193, 0, 0, 1843, 1844, 3, 286, 143, 0, 1844,
		1845, 5, 455, 0, 0, 1845, 1846, 3, 286, 143, 0, 1846, 1847, 5, 235, 0,
		0, 1847, 1849, 5, 532, 0, 0, 1848, 1850, 3, 378, 189, 0, 1849, 1848, 1,
		0, 0, 0, 1849, 1850, 1, 0, 0, 0, 1850, 1852, 1, 0, 0, 0, 1851, 1853, 3,
		248, 124, 0, 1852, 1851, 1, 0, 0, 0, 1852, 1853, 1, 0, 0, 0, 1853, 1855,
		1, 0, 0, 0, 1854, 1616, 1, 0, 0, 0, 1854, 1628, 1, 0, 0, 0, 1854, 1646,
		1, 0, 0, 0, 1854, 1655, 1, 0, 0, 0, 1854, 1667, 1, 0, 0, 0, 1854, 1676,
		1, 0, 0, 0, 1854, 1710, 1, 0, 0, 0, 1854, 1728, 1, 0, 0, 0, 1854, 1749,
		1, 0, 0, 0, 1854, 1763, 1, 0, 0, 0, 1854, 1770, 1, 0, 0, 0, 1854, 1772,
		1, 0, 0, 0, 1854, 1777, 1, 0, 0, 0, 1854, 1782, 1, 0, 0, 0, 1854, 1787,
		1, 0, 0, 0, 1854, 1789, 1, 0, 0, 0, 1854, 1796, 1, 0, 0, 0, 1854, 1803,
		1, 0, 0, 0, 1854, 1821, 1, 0, 0, 0, 1854, 1824, 1, 0, 0, 0, 1854, 1830,
		1, 0, 0, 0, 1854, 1837, 1, 0, 0, 0, 1855, 45, 1, 0, 0, 0, 1856, 1860, 5,
		184, 0, 0, 1857, 1858, 5, 17, 0, 0, 1858, 1860, 3, 378, 189, 0, 1859, 1856,
		1, 0, 0, 0, 1859, 1857, 1, 0, 0, 0, 1860, 47, 1, 0, 0, 0, 1861, 1862, 7,
		7, 0, 0, 1862, 1863, 3, 378, 189, 0, 1863, 49, 1, 0, 0, 0, 1864, 1865,
		5, 193, 0, 0, 1865, 1866, 3, 378, 189, 0, 1866, 51, 1, 0, 0, 0, 1867, 1868,
		5, 150, 0, 0, 1868, 1871, 7, 8, 0, 0, 1869, 1870, 5, 220, 0, 0, 1870, 1872,
		5, 170, 0, 0, 1871, 1869, 1, 0, 0, 0, 1871, 1872, 1, 0, 0, 0, 1872, 1873,
		1, 0, 0, 0, 1873, 1875, 3, 260, 130, 0, 1874, 1876, 5, 190, 0, 0, 1875,
		1874, 1, 0, 0, 0, 1875, 1876, 1, 0, 0, 0, 1876, 2023, 1, 0, 0, 0, 1877,
		1878, 5, 150, 0, 0, 1878, 1881, 5, 67, 0, 0, 1879, 1880, 5, 220, 0, 0,
		1880, 1882, 5, 170, 0, 0, 1881, 1879, 1, 0, 0, 0, 1881, 1882, 1, 0, 0,
		0, 1882, 1883, 1, 0, 0, 0, 1883, 2023, 3, 378, 189, 0, 1884, 1886, 5, 150,
		0, 0, 1885, 1887, 7, 9, 0, 0, 1886, 1885, 1, 0, 0, 0, 1886, 1887, 1, 0,
		0, 0, 1887, 1888, 1, 0, 0, 0, 1888, 1891, 5, 197, 0, 0, 1889, 1890, 5,
		220, 0, 0, 1890, 1892, 5, 170, 0, 0, 1891, 1889, 1, 0, 0, 0, 1891, 1892,
		1, 0, 0, 0, 1892, 1893, 1, 0, 0, 0, 1893, 1894, 3, 328, 164, 0, 1894, 1896,
		5, 2, 0, 0, 1895, 1897, 3, 74, 37, 0, 1896, 1895, 1, 0, 0, 0, 1896, 1897,
		1, 0, 0, 0, 1897, 1898, 1, 0, 0, 0, 1898, 1899, 5, 3, 0, 0, 1899, 2023,
		1, 0, 0, 0, 1900, 1901, 5, 150, 0, 0, 1901, 1904, 5, 438, 0, 0, 1902, 1903,
		5, 220, 0, 0, 1903, 1905, 5, 170, 0, 0, 1904, 1902, 1, 0, 0, 0, 1904, 1905,
		1, 0, 0, 0, 1905, 1906, 1, 0, 0, 0, 1906, 1908, 3, 260, 130, 0, 1907, 1909,
		5, 190, 0, 0, 1908, 1907, 1, 0, 0, 0, 1908, 1909, 1, 0, 0, 0, 1909, 2023,
		1, 0, 0, 0, 1910, 1911, 5, 150, 0, 0, 1911, 1914, 5, 477, 0, 0, 1912, 1913,
		5, 220, 0, 0, 1913, 1915, 5, 170, 0, 0, 1914, 1912, 1, 0, 0, 0, 1914, 1915,
		1, 0, 0, 0, 1915, 1916, 1, 0, 0, 0, 1916, 2023, 3, 130, 65, 0, 1917, 1918,
		5, 150, 0, 0, 1918, 1921, 5, 488, 0, 0, 1919, 1920, 5, 220, 0, 0, 1920,
		1922, 5, 170, 0, 0, 1921, 1919, 1, 0, 0, 0, 1921, 1922, 1, 0, 0, 0, 1922,
		1923, 1, 0, 0, 0, 1923, 2023, 3, 260, 130, 0, 1924, 1925, 5, 150, 0, 0,
		1925, 1926, 5, 377, 0, 0, 1926, 2023, 3, 378, 189, 0, 1927, 1928, 5, 150,
		0, 0, 1928, 1931, 5, 388, 0, 0, 1929, 1930, 5, 220, 0, 0, 1930, 1932, 5,
		170, 0, 0, 1931, 1929, 1, 0, 0, 0, 1931, 1932, 1, 0, 0, 0, 1932, 1933,
		1, 0, 0, 0, 1933, 2023, 3, 378, 189, 0, 1934, 1935, 5, 150, 0, 0, 1935,
		1936, 5, 182, 0, 0, 1936, 1939, 5, 527, 0, 0, 1937, 1938, 7, 10, 0, 0,
		1938, 1940, 3, 378, 189, 0, 1939, 1937, 1, 0, 0, 0, 1939, 1940, 1, 0, 0,
		0, 1940, 1941, 1, 0, 0, 0, 1941, 2023, 3, 248, 124, 0, 1942, 1943, 5, 150,
		0, 0, 1943, 1946, 5, 225, 0, 0, 1944, 1945, 5, 220, 0, 0, 1945, 1947, 5,
		170, 0, 0, 1946, 1944, 1, 0, 0, 0, 1946, 1947, 1, 0, 0, 0, 1947, 1948,
		1, 0, 0, 0, 1948, 1949, 3, 378, 189, 0, 1949, 1950, 5, 312, 0, 0, 1950,
		1951, 3, 260, 130, 0, 1951, 2023, 1, 0, 0, 0, 1952, 1953, 5, 150, 0, 0,
		1953, 1956, 5, 378, 0, 0, 1954, 1955, 5, 220, 0, 0, 1955, 1957, 5, 170,
		0, 0, 1956, 1954, 1, 0, 0, 0, 1956, 1957, 1, 0, 0, 0, 1957, 1958, 1, 0,
		0, 0, 1958, 2023, 3, 122, 61, 0, 1959, 1960, 5, 150, 0, 0, 1960, 1961,
		5, 497, 0, 0, 1961, 1964, 5, 205, 0, 0, 1962, 1963, 5, 220, 0, 0, 1963,
		1965, 5, 170, 0, 0, 1964, 1962, 1, 0, 0, 0, 1964, 1965, 1, 0, 0, 0, 1965,
		1966, 1, 0, 0, 0, 1966, 2023, 3, 122, 61, 0, 1967, 1968, 5, 150, 0, 0,
		1968, 1969, 5, 497, 0, 0, 1969, 1972, 5, 344, 0, 0, 1970, 1971, 5, 220,
		0, 0, 1971, 1973, 5, 170, 0, 0, 1972, 1970, 1, 0, 0, 0, 1972, 1973, 1,
		0, 0, 0, 1973, 1974, 1, 0, 0, 0, 1974, 2023, 3, 122, 61, 0, 1975, 1976,
		5, 150, 0, 0, 1976, 1979, 5, 157, 0, 0, 1977, 1978, 5, 220, 0, 0, 1978,
		1980, 5, 170, 0, 0, 1979, 1977, 1, 0, 0, 0, 1979, 1980, 1, 0, 0, 0, 1980,
		1981, 1, 0, 0, 0, 1981, 2023, 3, 260, 130, 0, 1982, 1983, 5, 150, 0, 0,
		1983, 1986, 5, 419, 0, 0, 1984, 1985, 5, 220, 0, 0, 1985, 1987, 5, 170,
		0, 0, 1986, 1984, 1, 0, 0, 0, 1986, 1987, 1, 0, 0, 0, 1987, 1988, 1, 0,
		0, 0, 1988, 2023, 3, 240, 120, 0, 1989, 1990, 5, 150, 0, 0, 1990, 1991,
		5, 393, 0, 0, 1991, 1994, 5, 344, 0, 0, 1992, 1993, 5, 220, 0, 0, 1993,
		1995, 5, 170, 0, 0, 1994, 1992, 1, 0, 0, 0, 1994, 1995, 1, 0, 0, 0, 1995,
		1996, 1, 0, 0, 0, 1996, 1997, 3, 378, 189, 0, 1997, 1998, 5, 312, 0, 0,
		1998, 2005, 3, 260, 130, 0, 1999, 2003, 5, 188, 0, 0, 2000, 2004, 3, 130,
		65, 0, 2001, 2002, 5, 388, 0, 0, 2002, 2004, 3, 378, 189, 0, 2003, 2000,
		1, 0, 0, 0, 2003, 2001, 1, 0, 0, 0, 2004, 2006, 1, 0, 0, 0, 2005, 1999,
		1, 0, 0, 0, 2005, 2006, 1, 0, 0, 0, 2006, 2023, 1, 0, 0, 0, 2007, 2008,
		5, 150, 0, 0, 2008, 2009, 5, 427, 0, 0, 2009, 2012, 5, 344, 0, 0, 2010,
		2011, 5, 220, 0, 0, 2011, 2013, 5, 170, 0, 0, 2012, 2010, 1, 0, 0, 0, 2012,
		2013, 1, 0, 0, 0, 2013, 2014, 1, 0, 0, 0, 2014, 2023, 3, 378, 189, 0, 2015,
		2016, 5, 150, 0, 0, 2016, 2019, 5, 420, 0, 0, 2017, 2018, 5, 220, 0, 0,
		2018, 2020, 5, 170, 0, 0, 2019, 2017, 1, 0, 0, 0, 2019, 2020, 1, 0, 0,
		0, 2020, 2021, 1, 0, 0, 0, 2021, 2023, 3, 378, 189, 0, 2022, 1867, 1, 0,
		0, 0, 2022, 1877, 1, 0, 0, 0, 2022, 1884, 1, 0, 0, 0, 2022, 1900, 1, 0,
		0, 0, 2022, 1910, 1, 0, 0, 0, 2022, 1917, 1, 0, 0, 0, 2022, 1924, 1, 0,
		0, 0, 2022, 1927, 1, 0, 0, 0, 2022, 1934, 1, 0, 0, 0, 2022, 1942, 1, 0,
		0, 0, 2022, 1952, 1, 0, 0, 0, 2022, 1959, 1, 0, 0, 0, 2022, 1967, 1, 0,
		0, 0, 2022, 1975, 1, 0, 0, 0, 2022, 1982, 1, 0, 0, 0, 2022, 1989, 1, 0,
		0, 0, 2022, 2007, 1, 0, 0, 0, 2022, 2015, 1, 0, 0, 0, 2023, 53, 1, 0, 0,
		0, 2024, 2025, 5, 22, 0, 0, 2025, 2026, 5, 438, 0, 0, 2026, 2027, 3, 260,
		130, 0, 2027, 2028, 5, 407, 0, 0, 2028, 2029, 5, 424, 0, 0, 2029, 2030,
		5, 2, 0, 0, 2030, 2031, 3, 250, 125, 0, 2031, 2033, 5, 3, 0, 0, 2032, 2034,
		3, 102, 51, 0, 2033, 2032, 1, 0, 0, 0, 2033, 2034, 1, 0, 0, 0, 2034, 2074,
		1, 0, 0, 0, 2035, 2036, 5, 22, 0, 0, 2036, 2037, 5, 438, 0, 0, 2037, 2040,
		3, 260, 130, 0, 2038, 2039, 5, 225, 0, 0, 2039, 2041, 3, 378, 189, 0, 2040,
		2038, 1, 0, 0, 0, 2040, 2041, 1, 0, 0, 0, 2041, 2042, 1, 0, 0, 0, 2042,
		2043, 5, 294, 0, 0, 2043, 2044, 5, 80, 0, 0, 2044, 2045, 3, 378, 189, 0,
		2045, 2046, 5, 407, 0, 0, 2046, 2047, 5, 424, 0, 0, 2047, 2048, 5, 2, 0,
		0, 2048, 2049, 3, 250, 125, 0, 2049, 2051, 5, 3, 0, 0, 2050, 2052, 3, 102,
		51, 0, 2051, 2050, 1, 0, 0, 0, 2051, 2052, 1, 0, 0, 0, 2052, 2074, 1, 0,
		0, 0, 2053, 2054, 5, 150, 0, 0, 2054, 2055, 5, 424, 0, 0, 2055, 2057, 3,
		260, 130, 0, 2056, 2058, 3, 238, 119, 0, 2057, 2056, 1, 0, 0, 0, 2057,
		2058, 1, 0, 0, 0, 2058, 2060, 1, 0, 0, 0, 2059, 2061, 3, 102, 51, 0, 2060,
		2059, 1, 0, 0, 0, 2060, 2061, 1, 0, 0, 0, 2061, 2074, 1, 0, 0, 0, 2062,
		2063, 5, 150, 0, 0, 2063, 2064, 5, 62, 0, 0, 2064, 2065, 5, 424, 0, 0,
		2065, 2074, 3, 260, 130, 0, 2066, 2067, 5, 150, 0, 0, 2067, 2068, 5, 171,
		0, 0, 2068, 2074, 5, 424, 0, 0, 2069, 2070, 5, 150, 0, 0, 2070, 2071, 5,
		23, 0, 0, 2071, 2072, 5, 245, 0, 0, 2072, 2074, 5, 532, 0, 0, 2073, 2024,
		1, 0, 0, 0, 2073, 2035, 1, 0, 0, 0, 2073, 2053, 1, 0, 0, 0, 2073, 2062,
		1, 0, 0, 0, 2073, 2066, 1, 0, 0, 0, 2073, 2069, 1, 0, 0, 0, 2074, 55, 1,
		0, 0, 0, 2075, 2076, 5, 99, 0, 0, 2076, 2080, 7, 8, 0, 0, 2077, 2078, 5,
		220, 0, 0, 2078, 2079, 5, 306, 0, 0, 2079, 2081, 5, 170, 0, 0, 2080, 2077,
		1, 0, 0, 0, 2080, 2081, 1, 0, 0, 0, 2081, 2082, 1, 0, 0, 0, 2082, 2084,
		3, 260, 130, 0, 2083, 2085, 3, 248, 124, 0, 2084, 2083, 1, 0, 0, 0, 2084,
		2085, 1, 0, 0, 0, 2085, 2366, 1, 0, 0, 0, 2086, 2087, 5, 99, 0, 0, 2087,
		2091, 5, 67, 0, 0, 2088, 2089, 5, 220, 0, 0, 2089, 2090, 5, 306, 0, 0,
		2090, 2092, 5, 170, 0, 0, 2091, 2088, 1, 0, 0, 0, 2091, 2092, 1, 0, 0,
		0, 2092, 2093, 1, 0, 0, 0, 2093, 2097, 3, 378, 189, 0, 2094, 2095, 5, 495,
		0, 0, 2095, 2096, 5, 378, 0, 0, 2096, 2098, 3, 378, 189, 0, 2097, 2094,
		1, 0, 0, 0, 2097, 2098, 1, 0, 0, 0, 2098, 2101, 1, 0, 0, 0, 2099, 2100,
		5, 82, 0, 0, 2100, 2102, 5, 527, 0, 0, 2101, 2099, 1, 0, 0, 0, 2101, 2102,
		1, 0, 0, 0, 2102, 2104, 1, 0, 0, 0, 2103, 2105, 3, 248, 124, 0, 2104, 2103,
		1, 0, 0, 0, 2104, 2105, 1, 0, 0, 0, 2105, 2366, 1, 0, 0, 0, 2106, 2108,
		5, 99, 0, 0, 2107, 2109, 7, 9, 0, 0, 2108, 2107, 1, 0, 0, 0, 2108, 2109,
		1, 0, 0, 0, 2109, 2111, 1, 0, 0, 0, 2110, 2112, 7, 11, 0, 0, 2111, 2110,
		1, 0, 0, 0, 2111, 2112, 1, 0, 0, 0, 2112, 2113, 1, 0, 0, 0, 2113, 2117,
		5, 197, 0, 0, 2114, 2115, 5, 220, 0, 0, 2115, 2116, 5, 306, 0, 0, 2116,
		2118, 5, 170, 0, 0, 2117, 2114, 1, 0, 0, 0, 2117, 2118, 1, 0, 0, 0, 2118,
		2119, 1, 0, 0, 0, 2119, 2120, 3, 328, 164, 0, 2120, 2122, 5, 2, 0, 0, 2121,
		2123, 3, 74, 37, 0, 2122, 2121, 1, 0, 0, 0, 2122, 2123, 1, 0, 0, 0, 2123,
		2124, 1, 0, 0, 0, 2124, 2125, 5, 3, 0, 0, 2125, 2126, 5, 383, 0, 0, 2126,
		2129, 3, 358, 179, 0, 2127, 2128, 5, 233, 0, 0, 2128, 2130, 3, 358, 179,
		0, 2129, 2127, 1, 0, 0, 0, 2129, 2130, 1, 0, 0, 0, 2130, 2132, 1, 0, 0,
		0, 2131, 2133, 3, 248, 124, 0, 2132, 2131, 1, 0, 0, 0, 2132, 2133, 1, 0,
		0, 0, 2133, 2366, 1, 0, 0, 0, 2134, 2136, 5, 99, 0, 0, 2135, 2137, 7, 9,
		0, 0, 2136, 2135, 1, 0, 0, 0, 2136, 2137, 1, 0, 0, 0, 2137, 2138, 1, 0,
		0, 0, 2138, 2139, 5, 20, 0, 0, 2139, 2143, 5, 197, 0, 0, 2140, 2141, 5,
		220, 0, 0, 2141, 2142, 5, 306, 0, 0, 2142, 2144, 5, 170, 0, 0, 2143, 2140,
		1, 0, 0, 0, 2143, 2144, 1, 0, 0, 0, 2144, 2145, 1, 0, 0, 0, 2145, 2146,
		3, 328, 164, 0, 2146, 2148, 5, 2, 0, 0, 2147, 2149, 3, 74, 37, 0, 2148,
		2147, 1, 0, 0, 0, 2148, 2149, 1, 0, 0, 0, 2149, 2150, 1, 0, 0, 0, 2150,
		2151, 5, 3, 0, 0, 2151, 2152, 5, 495, 0, 0, 2152, 2153, 5, 322, 0, 0, 2153,
		2155, 5, 2, 0, 0, 2154, 2156, 3, 240, 120, 0, 2155, 2154, 1, 0, 0, 0, 2155,
		2156, 1, 0, 0, 0, 2156, 2157, 1, 0, 0, 0, 2157, 2158, 5, 3, 0, 0, 2158,
		2159, 5, 30, 0, 0, 2159, 2160, 3, 304, 152, 0, 2160, 2366, 1, 0, 0, 0,
		2161, 2162, 5, 99, 0, 0, 2162, 2166, 5, 477, 0, 0, 2163, 2164, 5, 220,
		0, 0, 2164, 2165, 5, 306, 0, 0, 2165, 2167, 5, 170, 0, 0, 2166, 2163, 1,
		0, 0, 0, 2166, 2167, 1, 0, 0, 0, 2167, 2168, 1, 0, 0, 0, 2168, 2173, 3,
		132, 66, 0, 2169, 2174, 5, 434, 0, 0, 2170, 2171, 5, 133, 0, 0, 2171, 2172,
		5, 388, 0, 0, 2172, 2174, 5, 527, 0, 0, 2173, 2169, 1, 0, 0, 0, 2173, 2170,
		1, 0, 0, 0, 2173, 2174, 1, 0, 0, 0, 2174, 2175, 1, 0, 0, 0, 2175, 2178,
		3, 72, 36, 0, 2176, 2177, 5, 82, 0, 0, 2177, 2179, 5, 527, 0, 0, 2178,
		2176, 1, 0, 0, 0, 2178, 2179, 1, 0, 0, 0, 2179, 2366, 1, 0, 0, 0, 2180,
		2183, 5, 99, 0, 0, 2181, 2182, 5, 360, 0, 0, 2182, 2184, 5, 313, 0, 0,
		2183, 2181, 1, 0, 0, 0, 2183, 2184, 1, 0, 0, 0, 2184, 2185, 1, 0, 0, 0,
		2185, 2186, 5, 377, 0, 0, 2186, 2187, 3, 378, 189, 0, 2187, 2188, 5, 495,
		0, 0, 2188, 2189, 3, 70, 35, 0, 2189, 2366, 1, 0, 0, 0, 2190, 2191, 5,
		99, 0, 0, 2191, 2195, 5, 388, 0, 0, 2192, 2193, 5, 220, 0, 0, 2193, 2194,
		5, 306, 0, 0, 2194, 2196, 5, 170, 0, 0, 2195, 2192, 1, 0, 0, 0, 2195, 2196,
		1, 0, 0, 0, 2196, 2197, 1, 0, 0, 0, 2197, 2200, 3, 378, 189, 0, 2198, 2199,
		5, 82, 0, 0, 2199, 2201, 5, 527, 0, 0, 2200, 2198, 1, 0, 0, 0, 2200, 2201,
		1, 0, 0, 0, 2201, 2366, 1, 0, 0, 0, 2202, 2203, 5, 99, 0, 0, 2203, 2204,
		5, 182, 0, 0, 2204, 2207, 5, 527, 0, 0, 2205, 2206, 7, 10, 0, 0, 2206,
		2208, 3, 378, 189, 0, 2207, 2205, 1, 0, 0, 0, 2207, 2208, 1, 0, 0, 0, 2208,
		2209, 1, 0, 0, 0, 2209, 2366, 3, 248, 124, 0, 2210, 2211, 5, 99, 0, 0,
		2211, 2215, 5, 225, 0, 0, 2212, 2213, 5, 220, 0, 0, 2213, 2214, 5, 306,
		0, 0, 2214, 2216, 5, 170, 0, 0, 2215, 2212, 1, 0, 0, 0, 2215, 2216, 1,
		0, 0, 0, 2216, 2217, 1, 0, 0, 0, 2217, 2218, 3, 378, 189, 0, 2218, 2219,
		5, 312, 0, 0, 2219, 2220, 3, 260, 130, 0, 2220, 2223, 3, 238, 119, 0, 2221,
		2222, 5, 478, 0, 0, 2222, 2224, 7, 12, 0, 0, 2223, 2221, 1, 0, 0, 0, 2223,
		2224, 1, 0, 0, 0, 2224, 2226, 1, 0, 0, 0, 2225, 2227, 3, 248, 124, 0, 2226,
		2225, 1, 0, 0, 0, 2226, 2227, 1, 0, 0, 0, 2227, 2230, 1, 0, 0, 0, 2228,
		2229, 5, 82, 0, 0, 2229, 2231, 5, 527, 0, 0, 2230, 2228, 1, 0, 0, 0, 2230,
		2231, 1, 0, 0, 0, 2231, 2366, 1, 0, 0, 0, 2232, 2234, 5, 99, 0, 0, 2233,
		2235, 5, 175, 0, 0, 2234, 2233, 1, 0, 0, 0, 2234, 2235, 1, 0, 0, 0, 2235,
		2236, 1, 0, 0, 0, 2236, 2240, 5, 378, 0, 0, 2237, 2238, 5, 220, 0, 0, 2238,
		2239, 5, 306, 0, 0, 2239, 2241, 5, 170, 0, 0, 2240, 2237, 1, 0, 0, 0, 2240,
		2241, 1, 0, 0, 0, 2241, 2242, 1, 0, 0, 0, 2242, 2244, 3, 122, 61, 0, 2243,
		2245, 3, 248, 124, 0, 2244, 2243, 1, 0, 0, 0, 2244, 2245, 1, 0, 0, 0, 2245,
		2366, 1, 0, 0, 0, 2246, 2247, 5, 99, 0, 0, 2247, 2248, 5, 427, 0, 0, 2248,
		2252, 5, 485, 0, 0, 2249, 2250, 5, 220, 0, 0, 2250, 2251, 5, 306, 0, 0,
		2251, 2253, 5, 170, 0, 0, 2252, 2249, 1, 0, 0, 0, 2252, 2253, 1, 0, 0,
		0, 2253, 2254, 1, 0, 0, 0, 2254, 2256, 3, 122, 61, 0, 2255, 2257, 3, 248,
		124, 0, 2256, 2255, 1, 0, 0, 0, 2256, 2257, 1, 0, 0, 0, 2257, 2366, 1,
		0, 0, 0, 2258, 2259, 5, 99, 0, 0, 2259, 2260, 5, 497, 0, 0, 2260, 2264,
		5, 205, 0, 0, 2261, 2262, 5, 220, 0, 0, 2262, 2263, 5, 306, 0, 0, 2263,
		2265, 5, 170, 0, 0, 2264, 2261, 1, 0, 0, 0, 2264, 2265, 1, 0, 0, 0, 2265,
		2266, 1, 0, 0, 0, 2266, 2268, 3, 122, 61, 0, 2267, 2269, 3, 248, 124, 0,
		2268, 2267, 1, 0, 0, 0, 2268, 2269, 1, 0, 0, 0, 2269, 2366, 1, 0, 0, 0,
		2270, 2271, 5, 99, 0, 0, 2271, 2272, 5, 497, 0, 0, 2272, 2276, 5, 344,
		0, 0, 2273, 2274, 5, 220, 0, 0, 2274, 2275, 5, 306, 0, 0, 2275, 2277, 5,
		170, 0, 0, 2276, 2273, 1, 0, 0, 0, 2276, 2277, 1, 0, 0, 0, 2277, 2278,
		1, 0, 0, 0, 2278, 2284, 3, 122, 61, 0, 2279, 2280, 5, 88, 0, 0, 2280, 2281,
		5, 2, 0, 0, 2281, 2282, 3, 66, 33, 0, 2282, 2283, 5, 3, 0, 0, 2283, 2285,
		1, 0, 0, 0, 2284, 2279, 1, 0, 0, 0, 2284, 2285, 1, 0, 0, 0, 2285, 2291,
		1, 0, 0, 0, 2286, 2287, 5, 13, 0, 0, 2287, 2288, 5, 2, 0, 0, 2288, 2289,
		3, 62, 31, 0, 2289, 2290, 5, 3, 0, 0, 2290, 2292, 1, 0, 0, 0, 2291, 2286,
		1, 0, 0, 0, 2291, 2292, 1, 0, 0, 0, 2292, 2294, 1, 0, 0, 0, 2293, 2295,
		3, 248, 124, 0, 2294, 2293, 1, 0, 0, 0, 2294, 2295, 1, 0, 0, 0, 2295, 2366,
		1, 0, 0, 0, 2296, 2297, 5, 99, 0, 0, 2297, 2301, 5, 157, 0, 0, 2298, 2299,
		5, 220, 0, 0, 2299, 2300, 5, 306, 0, 0, 2300, 2302, 5, 170, 0, 0, 2301,
		2298, 1, 0, 0, 0, 2301, 2302, 1, 0, 0, 0, 2302, 2303, 1, 0, 0, 0, 2303,
		2304, 3, 260, 130, 0, 2304, 2305, 5, 30, 0, 0, 2305, 2306, 5, 527, 0, 0,
		2306, 2366, 1, 0, 0, 0, 2307, 2308, 5, 99, 0, 0, 2308, 2309, 5, 436, 0,
		0, 2309, 2310, 3, 378, 189, 0, 2310, 2311, 5, 5, 0, 0, 2311, 2312, 3, 122,
		61, 0, 2312, 2313, 5, 2, 0, 0, 2313, 2314, 3, 58, 29, 0, 2314, 2315, 5,
		3, 0, 0, 2315, 2316, 5, 193, 0, 0, 2316, 2317, 5, 46, 0, 0, 2317, 2318,
		5, 2, 0, 0, 2318, 2319, 3, 250, 125, 0, 2319, 2321, 5, 3, 0, 0, 2320, 2322,
		3, 248, 124, 0, 2321, 2320, 1, 0, 0, 0, 2321, 2322, 1, 0, 0, 0, 2322, 2366,
		1, 0, 0, 0, 2323, 2324, 5, 99, 0, 0, 2324, 2328, 5, 419, 0, 0, 2325, 2326,
		5, 220, 0, 0, 2326, 2327, 5, 306, 0, 0, 2327, 2329, 5, 170, 0, 0, 2328,
		2325, 1, 0, 0, 0, 2328, 2329, 1, 0, 0, 0, 2329, 2330, 1, 0, 0, 0, 2330,
		2332, 3, 378, 189, 0, 2331, 2333, 3, 248, 124, 0, 2332, 2331, 1, 0, 0,
		0, 2332, 2333, 1, 0, 0, 0, 2333, 2366, 1, 0, 0, 0, 2334, 2335, 5, 99, 0,
		0, 2335, 2336, 5, 427, 0, 0, 2336, 2340, 5, 344, 0, 0, 2337, 2338, 5, 220,
		0, 0, 2338, 2339, 5, 306, 0, 0, 2339, 2341, 5, 170, 0, 0, 2340, 2337, 1,
		0, 0, 0, 2340, 2341, 1, 0, 0, 0, 2341, 2342, 1, 0, 0, 0, 2342, 2344, 3,
		378, 189, 0, 2343, 2345, 3, 248, 124, 0, 2344, 2343, 1, 0, 0, 0, 2344,
		2345, 1, 0, 0, 0, 2345, 2366, 1, 0, 0, 0, 2346, 2347, 5, 57, 0, 0, 2347,
		2348, 5, 225, 0, 0, 2348, 2349, 3, 378, 189, 0, 2349, 2350, 5, 312, 0,
		0, 2350, 2352, 3, 260, 130, 0, 2351, 2353, 3, 102, 51, 0, 2352, 2351, 1,
		0, 0, 0, 2352, 2353, 1, 0, 0, 0, 2353, 2366, 1, 0, 0, 0, 2354, 2355, 5,
		99, 0, 0, 2355, 2359, 5, 420, 0, 0, 2356, 2357, 5, 220, 0, 0, 2357, 2358,
		5, 306, 0, 0, 2358, 2360, 5, 170, 0, 0, 2359, 2356, 1, 0, 0, 0, 2359, 2360,
		1, 0, 0, 0, 2360, 2361, 1, 0, 0, 0, 2361, 2363, 3, 378, 189, 0, 2362, 2364,
		3, 248, 124, 0, 2363, 2362, 1, 0, 0, 0, 2363, 2364, 1, 0, 0, 0, 2364, 2366,
		1, 0, 0, 0, 2365, 2075, 1, 0, 0, 0, 2365, 2086, 1, 0, 0, 0, 2365, 2106,
		1, 0, 0, 0, 2365, 2134, 1, 0, 0, 0, 2365, 2161, 1, 0, 0, 0, 2365, 2180,
		1, 0, 0, 0, 2365, 2190, 1, 0, 0, 0, 2365, 2202, 1, 0, 0, 0, 2365, 2210,
		1, 0, 0, 0, 2365, 2232, 1, 0, 0, 0, 2365, 2246, 1, 0, 0, 0, 2365, 2258,
		1, 0, 0, 0, 2365, 2270, 1, 0, 0, 0, 2365, 2296, 1, 0, 0, 0, 2365, 2307,
		1, 0, 0, 0, 2365, 2323, 1, 0, 0, 0, 2365, 2334, 1, 0, 0, 0, 2365, 2346,
		1, 0, 0, 0, 2365, 2354, 1, 0, 0, 0, 2366, 57, 1, 0, 0, 0, 2367, 2372, 3,
		60, 30, 0, 2368, 2369, 5, 4, 0, 0, 2369, 2371, 3, 60, 30, 0, 2370, 2368,
		1, 0, 0, 0, 2371, 2374, 1, 0, 0, 0, 2372, 2370, 1, 0, 0, 0, 2372, 2373,
		1, 0, 0, 0, 2373, 59, 1, 0, 0, 0, 2374, 2372, 1, 0, 0, 0, 2375, 2376, 5,
		193, 0, 0, 2376, 2377, 3, 260, 130, 0, 2377, 2378, 5, 236, 0, 0, 2378,
		2380, 3, 260, 130, 0, 2379, 2381, 3, 102, 51, 0, 2380, 2379, 1, 0, 0, 0,
		2380, 2381, 1, 0, 0, 0, 2381, 2383, 1, 0, 0, 0, 2382, 2384, 3, 238, 119,
		0, 2383, 2382, 1, 0, 0, 0, 2383, 2384, 1, 0, 0, 0, 2384, 61, 1, 0, 0, 0,
		2385, 2390, 3, 64, 32, 0, 2386, 2387, 5, 4, 0, 0, 2387, 2389, 3, 64, 32,
		0, 2388, 2386, 1, 0, 0, 0, 2389, 2392, 1, 0, 0, 0, 2390, 2388, 1, 0, 0,
		0, 2390, 2391, 1, 0, 0, 0, 2391, 63, 1, 0, 0, 0, 2392, 2390, 1, 0, 0, 0,
		2393, 2394, 5, 409, 0, 0, 2394, 2400, 5, 527, 0, 0, 2395, 2397, 3, 378,
		189, 0, 2396, 2398, 5, 527, 0, 0, 2397, 2396, 1, 0, 0, 0, 2397, 2398, 1,
		0, 0, 0, 2398, 2400, 1, 0, 0, 0, 2399, 2393, 1, 0, 0, 0, 2399, 2395, 1,
		0, 0, 0, 2400, 65, 1, 0, 0, 0, 2401, 2406, 3, 68, 34, 0, 2402, 2403, 5,
		4, 0, 0, 2403, 2405, 3, 68, 34, 0, 2404, 2402, 1, 0, 0, 0, 2405, 2408,
		1, 0, 0, 0, 2406, 2404, 1, 0, 0, 0, 2406, 2407, 1, 0, 0, 0, 2407, 67, 1,
		0, 0, 0, 2408, 2406, 1, 0, 0, 0, 2409, 2410, 3, 378, 189, 0, 2410, 2413,
		3, 346, 173, 0, 2411, 2414, 3, 384, 192, 0, 2412, 2414, 5, 527, 0, 0, 2413,
		2411, 1, 0, 0, 0, 2413, 2412, 1, 0, 0, 0, 2414, 69, 1, 0, 0, 0, 2415, 2417,
		7, 13, 0, 0, 2416, 2418, 3, 378, 189, 0, 2417, 2416, 1, 0, 0, 0, 2417,
		2418, 1, 0, 0, 0, 2418, 2419, 1, 0, 0, 0, 2419, 2420, 5, 312, 0, 0, 2420,
		2421, 5, 271, 0, 0, 2421, 2423, 5, 527, 0, 0, 2422, 2424, 3, 248, 124,
		0, 2423, 2422, 1, 0, 0, 0, 2423, 2424, 1, 0, 0, 0, 2424, 71, 1, 0, 0, 0,
		2425, 2428, 5, 328, 0, 0, 2426, 2429, 5, 133, 0, 0, 2427, 2429, 5, 532,
		0, 0, 2428, 2426, 1, 0, 0, 0, 2428, 2427, 1, 0, 0, 0, 2429, 2431, 1, 0,
		0, 0, 2430, 2425, 1, 0, 0, 0, 2430, 2431, 1, 0, 0, 0, 2431, 2440, 1, 0,
		0, 0, 2432, 2438, 5, 327, 0, 0, 2433, 2439, 5, 133, 0, 0, 2434, 2439, 5,
		301, 0, 0, 2435, 2436, 5, 235, 0, 0, 2436, 2437, 5, 532, 0, 0, 2437, 2439,
		7, 14, 0, 0, 2438, 2433, 1, 0, 0, 0, 2438, 2434, 1, 0, 0, 0, 2438, 2435,
		1, 0, 0, 0, 2439, 2441, 1, 0, 0, 0, 2440, 2432, 1, 0, 0, 0, 2440, 2441,
		1, 0, 0, 0, 2441, 2449, 1, 0, 0, 0, 2442, 2443, 5, 330, 0, 0, 2443, 2447,
		5, 235, 0, 0, 2444, 2448, 5, 133, 0, 0, 2445, 2446, 5, 532, 0, 0, 2446,
		2448, 5, 126, 0, 0, 2447, 2444, 1, 0, 0, 0, 2447, 2445, 1, 0, 0, 0, 2448,
		2450, 1, 0, 0, 0, 2449, 2442, 1, 0, 0, 0, 2449, 2450, 1, 0, 0, 0, 2450,
		2453, 1, 0, 0, 0, 2451, 2452, 5, 177, 0, 0, 2452, 2454, 5, 532, 0, 0, 2453,
		2451, 1, 0, 0, 0, 2453, 2454, 1, 0, 0, 0, 2454, 2461, 1, 0, 0, 0, 2455,
		2459, 5, 329, 0, 0, 2456, 2460, 5, 466, 0, 0, 2457, 2458, 5, 532, 0, 0,
		2458, 2460, 7, 14, 0, 0, 2459, 2456, 1, 0, 0, 0, 2459, 2457, 1, 0, 0, 0,
		2460, 2462, 1, 0, 0, 0, 2461, 2455, 1, 0, 0, 0, 2461, 2462, 1, 0, 0, 0,
		2462, 2464, 1, 0, 0, 0, 2463, 2465, 7, 15, 0, 0, 2464, 2463, 1, 0, 0, 0,
		2464, 2465, 1, 0, 0, 0, 2465, 73, 1, 0, 0, 0, 2466, 2471, 3, 76, 38, 0,
		2467, 2468, 5, 4, 0, 0, 2468, 2470, 3, 76, 38, 0, 2469, 2467, 1, 0, 0,
		0, 2470, 2473, 1, 0, 0, 0, 2471, 2469, 1, 0, 0, 0, 2471, 2472, 1, 0, 0,
		0, 2472, 75, 1, 0, 0, 0, 2473, 2471, 1, 0, 0, 0, 2474, 2477, 5, 6, 0, 0,
		2475, 2477, 3, 358, 179, 0, 2476, 2474, 1, 0, 0, 0, 2476, 2475, 1, 0, 0,
		0, 2477, 77, 1, 0, 0, 0, 2478, 2481, 5, 407, 0, 0, 2479, 2482, 3, 80, 40,
		0, 2480, 2482, 3, 82, 41, 0, 2481, 2479, 1, 0, 0, 0, 2481, 2480, 1, 0,
		0, 0, 2482, 2490, 1, 0, 0, 0, 2483, 2486, 5, 4, 0, 0, 2484, 2487, 3, 80,
		40, 0, 2485, 2487, 3, 82, 41, 0, 2486, 2484, 1, 0, 0, 0, 2486, 2485, 1,
		0, 0, 0, 2487, 2489, 1, 0, 0, 0, 2488, 2483, 1, 0, 0, 0, 2489, 2492, 1,
		0, 0, 0, 2490, 2488, 1, 0, 0, 0, 2490, 2491, 1, 0, 0, 0, 2491, 2525, 1,
		0, 0, 0, 2492, 2490, 1, 0, 0, 0, 2493, 2494, 5, 407, 0, 0, 2494, 2495,
		3, 378, 189, 0, 2495, 2496, 5, 30, 0, 0, 2496, 2497, 5, 133, 0, 0, 2497,
		2498, 5, 427, 0, 0, 2498, 2499, 5, 485, 0, 0, 2499, 2525, 1, 0, 0, 0, 2500,
		2501, 5, 407, 0, 0, 2501, 2504, 5, 353, 0, 0, 2502, 2503, 5, 188, 0, 0,
		2503, 2505, 3, 122, 61, 0, 2504, 2502, 1, 0, 0, 0, 2504, 2505, 1, 0, 0,
		0, 2505, 2506, 1, 0, 0, 0, 2506, 2525, 3, 250, 125, 0, 2507, 2509, 5, 407,
		0, 0, 2508, 2510, 7, 9, 0, 0, 2509, 2508, 1, 0, 0, 0, 2509, 2510, 1, 0,
		0, 0, 2510, 2511, 1, 0, 0, 0, 2511, 2522, 5, 456, 0, 0, 2512, 2523, 3,
		86, 43, 0, 2513, 2523, 3, 88, 44, 0, 2514, 2515, 3, 86, 43, 0, 2515, 2516,
		5, 4, 0, 0, 2516, 2517, 3, 88, 44, 0, 2517, 2523, 1, 0, 0, 0, 2518, 2519,
		3, 88, 44, 0, 2519, 2520, 5, 4, 0, 0, 2520, 2521, 3, 86, 43, 0, 2521, 2523,
		1, 0, 0, 0, 2522, 2512, 1, 0, 0, 0, 2522, 2513, 1, 0, 0, 0, 2522, 2514,
		1, 0, 0, 0, 2522, 2518, 1, 0, 0, 0, 2523, 2525, 1, 0, 0, 0, 2524, 2478,
		1, 0, 0, 0, 2524, 2493, 1, 0, 0, 0, 2524, 2500, 1, 0, 0, 0, 2524, 2507,
		1, 0, 0, 0, 2525, 79, 1, 0, 0, 0, 2526, 2527, 7, 9, 0, 0, 2527, 2528, 3,
		378, 189, 0, 2528, 2531, 5, 501, 0, 0, 2529, 2532, 3, 304, 152, 0, 2530,
		2532, 5, 133, 0, 0, 2531, 2529, 1, 0, 0, 0, 2531, 2530, 1, 0, 0, 0, 2532,
		81, 1, 0, 0, 0, 2533, 2534, 5, 298, 0, 0, 2534, 2535, 5, 501, 0, 0, 2535,
		2579, 3, 304, 152, 0, 2536, 2537, 5, 70, 0, 0, 2537, 2540, 5, 407, 0, 0,
		2538, 2540, 5, 71, 0, 0, 2539, 2536, 1, 0, 0, 0, 2539, 2538, 1, 0, 0, 0,
		2540, 2543, 1, 0, 0, 0, 2541, 2544, 3, 122, 61, 0, 2542, 2544, 5, 133,
		0, 0, 2543, 2541, 1, 0, 0, 0, 2543, 2542, 1, 0, 0, 0, 2544, 2579, 1, 0,
		0, 0, 2545, 2548, 5, 298, 0, 0, 2546, 2549, 3, 122, 61, 0, 2547, 2549,
		5, 133, 0, 0, 2548, 2546, 1, 0, 0, 0, 2548, 2547, 1, 0, 0, 0, 2549, 2553,
		1, 0, 0, 0, 2550, 2551, 5, 76, 0, 0, 2551, 2554, 3, 122, 61, 0, 2552, 2554,
		5, 133, 0, 0, 2553, 2550, 1, 0, 0, 0, 2553, 2552, 1, 0, 0, 0, 2553, 2554,
		1, 0, 0, 0, 2554, 2579, 1, 0, 0, 0, 2555, 2558, 5, 326, 0, 0, 2556, 2557,
		5, 188, 0, 0, 2557, 2559, 3, 130, 65, 0, 2558, 2556, 1, 0, 0, 0, 2558,
		2559, 1, 0, 0, 0, 2559, 2560, 1, 0, 0, 0, 2560, 2566, 5, 501, 0, 0, 2561,
		2567, 5, 527, 0, 0, 2562, 2563, 5, 326, 0, 0, 2563, 2564, 5, 2, 0, 0, 2564,
		2565, 5, 527, 0, 0, 2565, 2567, 5, 3, 0, 0, 2566, 2561, 1, 0, 0, 0, 2566,
		2562, 1, 0, 0, 0, 2567, 2579, 1, 0, 0, 0, 2568, 2569, 5, 258, 0, 0, 2569,
		2575, 5, 501, 0, 0, 2570, 2576, 5, 527, 0, 0, 2571, 2572, 5, 326, 0, 0,
		2572, 2573, 5, 2, 0, 0, 2573, 2574, 5, 527, 0, 0, 2574, 2576, 5, 3, 0,
		0, 2575, 2570, 1, 0, 0, 0, 2575, 2571, 1, 0, 0, 0, 2576, 2579, 1, 0, 0,
		0, 2577, 2579, 3, 84, 42, 0, 2578, 2533, 1, 0, 0, 0, 2578, 2539, 1, 0,
		0, 0, 2578, 2545, 1, 0, 0, 0, 2578, 2555, 1, 0, 0, 0, 2578, 2568, 1, 0,
		0, 0, 2578, 2577, 1, 0, 0, 0, 2579, 83, 1, 0, 0, 0, 2580, 2583, 5, 526,
		0, 0, 2581, 2582, 7, 9, 0, 0, 2582, 2584, 5, 5, 0, 0, 2583, 2581, 1, 0,
		0, 0, 2583, 2584, 1, 0, 0, 0, 2584, 2586, 1, 0, 0, 0, 2585, 2580, 1, 0,
		0, 0, 2585, 2586, 1, 0, 0, 0, 2586, 2587, 1, 0, 0, 0, 2587, 2588, 3, 378,
		189, 0, 2588, 2591, 5, 501, 0, 0, 2589, 2592, 3, 304, 152, 0, 2590, 2592,
		5, 133, 0, 0, 2591, 2589, 1, 0, 0, 0, 2591, 2590, 1, 0, 0, 0, 2592, 2599,
		1, 0, 0, 0, 2593, 2594, 5, 525, 0, 0, 2594, 2595, 3, 378, 189, 0, 2595,
		2596, 5, 501, 0, 0, 2596, 2597, 3, 304, 152, 0, 2597, 2599, 1, 0, 0, 0,
		2598, 2585, 1, 0, 0, 0, 2598, 2593, 1, 0, 0, 0, 2599, 85, 1, 0, 0, 0, 2600,
		2601, 5, 360, 0, 0, 2601, 2602, 7, 16, 0, 0, 2602, 87, 1, 0, 0, 0, 2603,
		2604, 5, 244, 0, 0, 2604, 2612, 5, 261, 0, 0, 2605, 2606, 5, 360, 0, 0,
		2606, 2613, 5, 467, 0, 0, 2607, 2608, 5, 360, 0, 0, 2608, 2613, 5, 84,
		0, 0, 2609, 2610, 5, 372, 0, 0, 2610, 2613, 5, 360, 0, 0, 2611, 2613, 5,
		405, 0, 0, 2612, 2605, 1, 0, 0, 0, 2612, 2607, 1, 0, 0, 0, 2612, 2609,
		1, 0, 0, 0, 2612, 2611, 1, 0, 0, 0, 2613, 89, 1, 0, 0, 0, 2614, 2616, 5,
		472, 0, 0, 2615, 2617, 7, 9, 0, 0, 2616, 2615, 1, 0, 0, 0, 2616, 2617,
		1, 0, 0, 0, 2617, 2618, 1, 0, 0, 0, 2618, 2621, 5, 482, 0, 0, 2619, 2622,
		5, 21, 0, 0, 2620, 2622, 3, 378, 189, 0, 2621, 2619, 1, 0, 0, 0, 2621,
		2620, 1, 0, 0, 0, 2622, 2628, 1, 0, 0, 0, 2623, 2624, 5, 472, 0, 0, 2624,
		2625, 5, 133, 0, 0, 2625, 2626, 5, 427, 0, 0, 2626, 2628, 5, 485, 0, 0,
		2627, 2614, 1, 0, 0, 0, 2627, 2623, 1, 0, 0, 0, 2628, 91, 1, 0, 0, 0, 2629,
		2633, 5, 476, 0, 0, 2630, 2631, 3, 378, 189, 0, 2631, 2632, 5, 5, 0, 0,
		2632, 2634, 1, 0, 0, 0, 2633, 2630, 1, 0, 0, 0, 2633, 2634, 1, 0, 0, 0,
		2634, 2635, 1, 0, 0, 0, 2635, 2650, 3, 378, 189, 0, 2636, 2643, 5, 476,
		0, 0, 2637, 2638, 3, 378, 189, 0, 2638, 2639, 5, 5, 0, 0, 2639, 2641, 1,
		0, 0, 0, 2640, 2637, 1, 0, 0, 0, 2640, 2641, 1, 0, 0, 0, 2641, 2642, 1,
		0, 0, 0, 2642, 2644, 3, 378, 189, 0, 2643, 2640, 1, 0, 0, 0, 2643, 2644,
		1, 0, 0, 0, 2644, 2645, 1, 0, 0, 0, 2645, 2646, 5, 525, 0, 0, 2646, 2650,
		3, 378, 189, 0, 2647, 2648, 5, 435, 0, 0, 2648, 2650, 3, 378, 189, 0, 2649,
		2629, 1, 0, 0, 0, 2649, 2636, 1, 0, 0, 0, 2649, 2647, 1, 0, 0, 0, 2650,
		93, 1, 0, 0, 0, 2651, 2652, 5, 462, 0, 0, 2652, 2653, 5, 438, 0, 0, 2653,
		2655, 3, 260, 130, 0, 2654, 2656, 3, 342, 171, 0, 2655, 2654, 1, 0, 0,
		0, 2655, 2656, 1, 0, 0, 0, 2656, 95, 1, 0, 0, 0, 2657, 2659, 5, 252, 0,
		0, 2658, 2660, 5, 90, 0, 0, 2659, 2658, 1, 0, 0, 0, 2659, 2660, 1, 0, 0,
		0, 2660, 2661, 1, 0, 0, 0, 2661, 2666, 5, 532, 0, 0, 2662, 2663, 5, 252,
		0, 0, 2663, 2664, 5, 356, 0, 0, 2664, 2666, 7, 17, 0, 0, 2665, 2657, 1,
		0, 0, 0, 2665, 2662, 1, 0, 0, 0, 2666, 97, 1, 0, 0, 0, 2667, 2668, 3, 136,
		68, 0, 2668, 2669, 5, 197, 0, 0, 2669, 2670, 3, 378, 189, 0, 2670, 2672,
		5, 2, 0, 0, 2671, 2673, 3, 250, 125, 0, 2672, 2671, 1, 0, 0, 0, 2672, 2673,
		1, 0, 0, 0, 2673, 2674, 1, 0, 0, 0, 2674, 2675, 5, 3, 0, 0, 2675, 2676,
		3, 258, 129, 0, 2676, 2687, 1, 0, 0, 0, 2677, 2678, 3, 136, 68, 0, 2678,
		2679, 3, 260, 130, 0, 2679, 2680, 5, 21, 0, 0, 2680, 2687, 1, 0, 0, 0,
		2681, 2682, 3, 136, 68, 0, 2682, 2684, 3, 260, 130, 0, 2683, 2685, 3, 342,
		171, 0, 2684, 2683, 1, 0, 0, 0, 2684, 2685, 1, 0, 0, 0, 2685, 2687, 1,
		0, 0, 0, 2686, 2667, 1, 0, 0, 0, 2686, 2677, 1, 0, 0, 0, 2686, 2681, 1,
		0, 0, 0, 2687, 99, 1, 0, 0, 0, 2688, 2689, 5, 347, 0, 0, 2689, 2690, 5,
		250, 0, 0, 2690, 2701, 3, 238, 119, 0, 2691, 2692, 5, 470, 0, 0, 2692,
		2701, 3, 238, 119, 0, 2693, 2694, 5, 189, 0, 0, 2694, 2695, 5, 250, 0,
		0, 2695, 2696, 3, 238, 119, 0, 2696, 2697, 5, 367, 0, 0, 2697, 2698, 3,
		260, 130, 0, 2698, 2699, 3, 238, 119, 0, 2699, 2701, 1, 0, 0, 0, 2700,
		2688, 1, 0, 0, 0, 2700, 2691, 1, 0, 0, 0, 2700, 2693, 1, 0, 0, 0, 2701,
		101, 1, 0, 0, 0, 2702, 2704, 5, 445, 0, 0, 2703, 2702, 1, 0, 0, 0, 2703,
		2704, 1, 0, 0, 0, 2704, 2705, 1, 0, 0, 0, 2705, 2706, 7, 18, 0, 0, 2706,
		2717, 3, 238, 119, 0, 2707, 2709, 5, 445, 0, 0, 2708, 2707, 1, 0, 0, 0,
		2708, 2709, 1, 0, 0, 0, 2709, 2710, 1, 0, 0, 0, 2710, 2711, 5, 324, 0,
		0, 2711, 2717, 3, 374, 187, 0, 2712, 2713, 7, 18, 0, 0, 2713, 2714, 5,
		2, 0, 0, 2714, 2715, 5, 510, 0, 0, 2715, 2717, 5, 3, 0, 0, 2716, 2703,
		1, 0, 0, 0, 2716, 2708, 1, 0, 0, 0, 2716, 2712, 1, 0, 0, 0, 2717, 103,
		1, 0, 0, 0, 2718, 2720, 5, 34, 0, 0, 2719, 2718, 1, 0, 0, 0, 2719, 2720,
		1, 0, 0, 0, 2720, 2721, 1, 0, 0, 0, 2721, 2722, 5, 324, 0, 0, 2722, 2724,
		5, 60, 0, 0, 2723, 2725, 7, 19, 0, 0, 2724, 2723, 1, 0, 0, 0, 2724, 2725,
		1, 0, 0, 0, 2725, 2726, 1, 0, 0, 0, 2726, 2727, 3, 106, 53, 0, 2727, 2729,
		5, 2, 0, 0, 2728, 2730, 3, 274, 137, 0, 2729, 2728, 1, 0, 0, 0, 2729, 2730,
		1, 0, 0, 0, 2730, 2731, 1, 0, 0, 0, 2731, 2732, 5, 3, 0, 0, 2732, 105,
		1, 0, 0, 0, 2733, 2734, 5, 2, 0, 0, 2734, 2739, 3, 108, 54, 0, 2735, 2736,
		5, 4, 0, 0, 2736, 2738, 3, 108, 54, 0, 2737, 2735, 1, 0, 0, 0, 2738, 2741,
		1, 0, 0, 0, 2739, 2737, 1, 0, 0, 0, 2739, 2740, 1, 0, 0, 0, 2740, 2742,
		1, 0, 0, 0, 2741, 2739, 1, 0, 0, 0, 2742, 2743, 5, 3, 0, 0, 2743, 107,
		1, 0, 0, 0, 2744, 2747, 3, 378, 189, 0, 2745, 2747, 3, 326, 163, 0, 2746,
		2744, 1, 0, 0, 0, 2746, 2745, 1, 0, 0, 0, 2747, 109, 1, 0, 0, 0, 2748,
		2750, 5, 495, 0, 0, 2749, 2748, 1, 0, 0, 0, 2749, 2750, 1, 0, 0, 0, 2750,
		2751, 1, 0, 0, 0, 2751, 2753, 3, 140, 70, 0, 2752, 2749, 1, 0, 0, 0, 2752,
		2753, 1, 0, 0, 0, 2753, 2754, 1, 0, 0, 0, 2754, 2755, 5, 110, 0, 0, 2755,
		2756, 5, 227, 0, 0, 2756, 2757, 5, 2, 0, 0, 2757, 2762, 5, 527, 0, 0, 2758,
		2759, 5, 4, 0, 0, 2759, 2761, 5, 527, 0, 0, 2760, 2758, 1, 0, 0, 0, 2761,
		2764, 1, 0, 0, 0, 2762, 2760, 1, 0, 0, 0, 2762, 2763, 1, 0, 0, 0, 2763,
		2765, 1, 0, 0, 0, 2764, 2762, 1, 0, 0, 0, 2765, 2766, 5, 3, 0, 0, 2766,
		2767, 5, 236, 0, 0, 2767, 2768, 5, 438, 0, 0, 2768, 2771, 3, 260, 130,
		0, 2769, 2770, 5, 324, 0, 0, 2770, 2772, 3, 238, 119, 0, 2771, 2769, 1,
		0, 0, 0, 2771, 2772, 1, 0, 0, 0, 2772, 2777, 1, 0, 0, 0, 2773, 2774, 5,
		81, 0, 0, 2774, 2775, 5, 446, 0, 0, 2775, 2776, 5, 60, 0, 0, 2776, 2778,
		5, 527, 0, 0, 2777, 2773, 1, 0, 0, 0, 2777, 2778, 1, 0, 0, 0, 2778, 2783,
		1, 0, 0, 0, 2779, 2780, 5, 264, 0, 0, 2780, 2781, 5, 446, 0, 0, 2781, 2782,
		5, 60, 0, 0, 2782, 2784, 5, 527, 0, 0, 2783, 2779, 1, 0, 0, 0, 2783, 2784,
		1, 0, 0, 0, 2784, 2788, 1, 0, 0, 0, 2785, 2786, 5, 191, 0, 0, 2786, 2787,
		5, 30, 0, 0, 2787, 2789, 3, 122, 61, 0, 2788, 2785, 1, 0, 0, 0, 2788, 2789,
		1, 0, 0, 0, 2789, 2791, 1, 0, 0, 0, 2790, 2792, 3, 238, 119, 0, 2791, 2790,
		1, 0, 0, 0, 2791, 2792, 1, 0, 0, 0, 2792, 2794, 1, 0, 0, 0, 2793, 2795,
		3, 148, 74, 0, 2794, 2793, 1, 0, 0, 0, 2794, 2795, 1, 0, 0, 0, 2795, 2797,
		1, 0, 0, 0, 2796, 2798, 3, 150, 75, 0, 2797, 2796, 1, 0, 0, 0, 2797, 2798,
		1, 0, 0, 0, 2798, 2800, 1, 0, 0, 0, 2799, 2801, 3, 142, 71, 0, 2800, 2799,
		1, 0, 0, 0, 2800, 2801, 1, 0, 0, 0, 2801, 2803, 1, 0, 0, 0, 2802, 2804,
		3, 184, 92, 0, 2803, 2802, 1, 0, 0, 0, 2803, 2804, 1, 0, 0, 0, 2804, 2806,
		1, 0, 0, 0, 2805, 2807, 3, 144, 72, 0, 2806, 2805, 1, 0, 0, 0, 2806, 2807,
		1, 0, 0, 0, 2807, 2809, 1, 0, 0, 0, 2808, 2810, 3, 146, 73, 0, 2809, 2808,
		1, 0, 0, 0, 2809, 2810, 1, 0, 0, 0, 2810, 2812, 1, 0, 0, 0, 2811, 2813,
		3, 248, 124, 0, 2812, 2811, 1, 0, 0, 0, 2812, 2813, 1, 0, 0, 0, 2813, 2844,
		1, 0, 0, 0, 2814, 2816, 5, 495, 0, 0, 2815, 2814, 1, 0, 0, 0, 2815, 2816,
		1, 0, 0, 0, 2816, 2817, 1, 0, 0, 0, 2817, 2819, 3, 140, 70, 0, 2818, 2815,
		1, 0, 0, 0, 2818, 2819, 1, 0, 0, 0, 2819, 2820, 1, 0, 0, 0, 2820, 2821,
		5, 110, 0, 0, 2821, 2822, 5, 193, 0, 0, 2822, 2823, 5, 438, 0, 0, 2823,
		2824, 3, 260, 130, 0, 2824, 2825, 5, 236, 0, 0, 2825, 2826, 5, 438, 0,
		0, 2826, 2829, 3, 260, 130, 0, 2827, 2828, 5, 324, 0, 0, 2828, 2830, 3,
		238, 119, 0, 2829, 2827, 1, 0, 0, 0, 2829, 2830, 1, 0, 0, 0, 2830, 2832,
		1, 0, 0, 0, 2831, 2833, 3, 150, 75, 0, 2832, 2831, 1, 0, 0, 0, 2832, 2833,
		1, 0, 0, 0, 2833, 2835, 1, 0, 0, 0, 2834, 2836, 3, 184, 92, 0, 2835, 2834,
		1, 0, 0, 0, 2835, 2836, 1, 0, 0, 0, 2836, 2838, 1, 0, 0, 0, 2837, 2839,
		3, 144, 72, 0, 2838, 2837, 1, 0, 0, 0, 2838, 2839, 1, 0, 0, 0, 2839, 2841,
		1, 0, 0, 0, 2840, 2842, 3, 248, 124, 0, 2841, 2840, 1, 0, 0, 0, 2841, 2842,
		1, 0, 0, 0, 2842, 2844, 1, 0, 0, 0, 2843, 2752, 1, 0, 0, 0, 2843, 2818,
		1, 0, 0, 0, 2844, 111, 1, 0, 0, 0, 2845, 2846, 5, 57, 0, 0, 2846, 2847,
		7, 20, 0, 0, 2847, 113, 1, 0, 0, 0, 2848, 2849, 5, 312, 0, 0, 2849, 2856,
		5, 275, 0, 0, 2850, 2851, 5, 312, 0, 0, 2851, 2852, 5, 397, 0, 0, 2852,
		2856, 3, 116, 58, 0, 2853, 2854, 5, 312, 0, 0, 2854, 2856, 5, 83, 0, 0,
		2855, 2848, 1, 0, 0, 0, 2855, 2850, 1, 0, 0, 0, 2855, 2853, 1, 0, 0, 0,
		2856, 115, 1, 0, 0, 0, 2857, 2858, 5, 166, 0, 0, 2858, 2859, 5, 532, 0,
		0, 2859, 2862, 3, 378, 189, 0, 2860, 2861, 5, 423, 0, 0, 2861, 2863, 5,
		527, 0, 0, 2862, 2860, 1, 0, 0, 0, 2862, 2863, 1, 0, 0, 0, 2863, 117, 1,
		0, 0, 0, 2864, 2865, 7, 21, 0, 0, 2865, 119, 1, 0, 0, 0, 2866, 2869, 3,
		378, 189, 0, 2867, 2869, 3, 326, 163, 0, 2868, 2866, 1, 0, 0, 0, 2868,
		2867, 1, 0, 0, 0, 2869, 121, 1, 0, 0, 0, 2870, 2873, 3, 378, 189, 0, 2871,
		2873, 5, 527, 0, 0, 2872, 2870, 1, 0, 0, 0, 2872, 2871, 1, 0, 0, 0, 2873,
		123, 1, 0, 0, 0, 2874, 2878, 3, 378, 189, 0, 2875, 2878, 5, 527, 0, 0,
		2876, 2878, 5, 510, 0, 0, 2877, 2874, 1, 0, 0, 0, 2877, 2875, 1, 0, 0,
		0, 2877, 2876, 1, 0, 0, 0, 2878, 125, 1, 0, 0, 0, 2879, 2884, 3, 128, 64,
		0, 2880, 2881, 5, 5, 0, 0, 2881, 2883, 3, 128, 64, 0, 2882, 2880, 1, 0,
		0, 0, 2883, 2886, 1, 0, 0, 0, 2884, 2882, 1, 0, 0, 0, 2884, 2885, 1, 0,
		0, 0, 2885, 127, 1, 0, 0, 0, 2886, 2884, 1, 0, 0, 0, 2887, 2890, 3, 122,
		61, 0, 2888, 2890, 5, 510, 0, 0, 2889, 2887, 1, 0, 0, 0, 2889, 2888, 1,
		0, 0, 0, 2890, 129, 1, 0, 0, 0, 2891, 2900, 3, 122, 61, 0, 2892, 2898,
		5, 525, 0, 0, 2893, 2899, 3, 122, 61, 0, 2894, 2895, 5, 2, 0, 0, 2895,
		2896, 3, 122, 61, 0, 2896, 2897, 5, 3, 0, 0, 2897, 2899, 1, 0, 0, 0, 2898,
		2893, 1, 0, 0, 0, 2898, 2894, 1, 0, 0, 0, 2899, 2901, 1, 0, 0, 0, 2900,
		2892, 1, 0, 0, 0, 2900, 2901, 1, 0, 0, 0, 2901, 131, 1, 0, 0, 0, 2902,
		2909, 3, 130, 65, 0, 2903, 2904, 5, 219, 0, 0, 2904, 2906, 5, 60, 0, 0,
		2905, 2907, 5, 326, 0, 0, 2906, 2905, 1, 0, 0, 0, 2906, 2907, 1, 0, 0,
		0, 2907, 2908, 1, 0, 0, 0, 2908, 2910, 5, 527, 0, 0, 2909, 2903, 1, 0,
		0, 0, 2909, 2910, 1, 0, 0, 0, 2910, 133, 1, 0, 0, 0, 2911, 2913, 3, 136,
		68, 0, 2912, 2914, 3, 138, 69, 0, 2913, 2912, 1, 0, 0, 0, 2913, 2914, 1,
		0, 0, 0, 2914, 2916, 1, 0, 0, 0, 2915, 2917, 7, 22, 0, 0, 2916, 2915, 1,
		0, 0, 0, 2916, 2917, 1, 0, 0, 0, 2917, 2919, 1, 0, 0, 0, 2918, 2920, 5,
		341, 0, 0, 2919, 2918, 1, 0, 0, 0, 2919, 2920, 1, 0, 0, 0, 2920, 135, 1,
		0, 0, 0, 2921, 2922, 7, 23, 0, 0, 2922, 137, 1, 0, 0, 0, 2923, 2924, 7,
		24, 0, 0, 2924, 139, 1, 0, 0, 0, 2925, 2926, 7, 25, 0, 0, 2926, 141, 1,
		0, 0, 0, 2927, 2928, 5, 345, 0, 0, 2928, 2929, 5, 183, 0, 0, 2929, 2930,
		3, 304, 152, 0, 2930, 143, 1, 0, 0, 0, 2931, 2932, 5, 135, 0, 0, 2932,
		2933, 5, 312, 0, 0, 2933, 2934, 3, 304, 152, 0, 2934, 145, 1, 0, 0, 0,
		2935, 2936, 5, 317, 0, 0, 2936, 2937, 5, 60, 0, 0, 2937, 2938, 3, 378,
		189, 0, 2938, 147, 1, 0, 0, 0, 2939, 2940, 5, 81, 0, 0, 2940, 2941, 5,
		193, 0, 0, 2941, 2942, 5, 331, 0, 0, 2942, 2943, 5, 30, 0, 0, 2943, 2944,
		3, 238, 119, 0, 2944, 149, 1, 0, 0, 0, 2945, 2946, 5, 407, 0, 0, 2946,
		2947, 5, 2, 0, 0, 2947, 2952, 3, 152, 76, 0, 2948, 2949, 5, 4, 0, 0, 2949,
		2951, 3, 152, 76, 0, 2950, 2948, 1, 0, 0, 0, 2951, 2954, 1, 0, 0, 0, 2952,
		2950, 1, 0, 0, 0, 2952, 2953, 1, 0, 0, 0, 2953, 2955, 1, 0, 0, 0, 2954,
		2952, 1, 0, 0, 0, 2955, 2956, 5, 3, 0, 0, 2956, 151, 1, 0, 0, 0, 2957,
		2958, 3, 378, 189, 0, 2958, 2959, 5, 501, 0, 0, 2959, 2960, 3, 304, 152,
		0, 2960, 153, 1, 0, 0, 0, 2961, 2990, 3, 156, 78, 0, 2962, 2963, 5, 495,
		0, 0, 2963, 2964, 5, 395, 0, 0, 2964, 2965, 5, 2, 0, 0, 2965, 2966, 3,
		250, 125, 0, 2966, 2967, 5, 3, 0, 0, 2967, 2990, 1, 0, 0, 0, 2968, 2969,
		5, 495, 0, 0, 2969, 2970, 5, 210, 0, 0, 2970, 2971, 5, 2, 0, 0, 2971, 2972,
		3, 250, 125, 0, 2972, 2973, 5, 3, 0, 0, 2973, 2990, 1, 0, 0, 0, 2974, 2975,
		5, 495, 0, 0, 2975, 2976, 5, 268, 0, 0, 2976, 2977, 5, 2, 0, 0, 2977, 2978,
		3, 250, 125, 0, 2978, 2979, 5, 3, 0, 0, 2979, 2990, 1, 0, 0, 0, 2980, 2981,
		5, 495, 0, 0, 2981, 2982, 5, 55, 0, 0, 2982, 2987, 3, 122, 61, 0, 2983,
		2984, 5, 2, 0, 0, 2984, 2985, 3, 250, 125, 0, 2985, 2986, 5, 3, 0, 0, 2986,
		2988, 1, 0, 0, 0, 2987, 2983, 1, 0, 0, 0, 2987, 2988, 1, 0, 0, 0, 2988,
		2990, 1, 0, 0, 0, 2989, 2961, 1, 0, 0, 0, 2989, 2962, 1, 0, 0, 0, 2989,
		2968, 1, 0, 0, 0, 2989, 2974, 1, 0, 0, 0, 2989, 2980, 1, 0, 0, 0, 2990,
		155, 1, 0, 0, 0, 2991, 2992, 5, 495, 0, 0, 2992, 2993, 5, 378, 0, 0, 2993,
		2998, 3, 122, 61, 0, 2994, 2995, 5, 2, 0, 0, 2995, 2996, 3, 250, 125, 0,
		2996, 2997, 5, 3, 0, 0, 2997, 2999, 1, 0, 0, 0, 2998, 2994, 1, 0, 0, 0,
		2998, 2999, 1, 0, 0, 0, 2999, 157, 1, 0, 0, 0, 3000, 3003, 5, 110, 0, 0,
		3001, 3002, 5, 268, 0, 0, 3002, 3004, 3, 348, 174, 0, 3003, 3001, 1, 0,
		0, 0, 3003, 3004, 1, 0, 0, 0, 3004, 3005, 1, 0, 0, 0, 3005, 3006, 5, 227,
		0, 0, 3006, 3007, 5, 527, 0, 0, 3007, 3008, 5, 236, 0, 0, 3008, 3009, 5,
		438, 0, 0, 3009, 3012, 3, 260, 130, 0, 3010, 3011, 5, 324, 0, 0, 3011,
		3013, 3, 238, 119, 0, 3012, 3010, 1, 0, 0, 0, 3012, 3013, 1, 0, 0, 0, 3013,
		3018, 1, 0, 0, 0, 3014, 3015, 5, 81, 0, 0, 3015, 3016, 5, 446, 0, 0, 3016,
		3017, 5, 60, 0, 0, 3017, 3019, 5, 527, 0, 0, 3018, 3014, 1, 0, 0, 0, 3018,
		3019, 1, 0, 0, 0, 3019, 3024, 1, 0, 0, 0, 3020, 3021, 5, 264, 0, 0, 3021,
		3022, 5, 446, 0, 0, 3022, 3023, 5, 60, 0, 0, 3023, 3025, 5, 527, 0, 0,
		3024, 3020, 1, 0, 0, 0, 3024, 3025, 1, 0, 0, 0, 3025, 3027, 1, 0, 0, 0,
		3026, 3028, 3, 160, 80, 0, 3027, 3026, 1, 0, 0, 0, 3027, 3028, 1, 0, 0,
		0, 3028, 3030, 1, 0, 0, 0, 3029, 3031, 3, 238, 119, 0, 3030, 3029, 1, 0,
		0, 0, 3030, 3031, 1, 0, 0, 0, 3031, 3033, 1, 0, 0, 0, 3032, 3034, 3, 150,
		75, 0, 3033, 3032, 1, 0, 0, 0, 3033, 3034, 1, 0, 0, 0, 3034, 3036, 1, 0,
		0, 0, 3035, 3037, 3, 248, 124, 0, 3036, 3035, 1, 0, 0, 0, 3036, 3037, 1,
		0, 0, 0, 3037, 159, 1, 0, 0, 0, 3038, 3039, 5, 221, 0, 0, 3039, 3040, 5,
		532, 0, 0, 3040, 3045, 5, 264, 0, 0, 3041, 3042, 5, 221, 0, 0, 3042, 3043,
		5, 532, 0, 0, 3043, 3045, 5, 394, 0, 0, 3044, 3038, 1, 0, 0, 0, 3044, 3041,
		1, 0, 0, 0, 3045, 161, 1, 0, 0, 0, 3046, 3047, 5, 236, 0, 0, 3047, 3048,
		5, 319, 0, 0, 3048, 3052, 3, 344, 172, 0, 3049, 3050, 5, 191, 0, 0, 3050,
		3051, 5, 30, 0, 0, 3051, 3053, 3, 378, 189, 0, 3052, 3049, 1, 0, 0, 0,
		3052, 3053, 1, 0, 0, 0, 3053, 3055, 1, 0, 0, 0, 3054, 3056, 3, 248, 124,
		0, 3055, 3054, 1, 0, 0, 0, 3055, 3056, 1, 0, 0, 0, 3056, 163, 1, 0, 0,
		0, 3057, 3059, 3, 174, 87, 0, 3058, 3057, 1, 0, 0, 0, 3058, 3059, 1, 0,
		0, 0, 3059, 3060, 1, 0, 0, 0, 3060, 3061, 3, 166, 83, 0, 3061, 3062, 3,
		224, 112, 0, 3062, 165, 1, 0, 0, 0, 3063, 3064, 6, 83, -1, 0, 3064, 3065,
		3, 170, 85, 0, 3065, 3080, 1, 0, 0, 0, 3066, 3067, 10, 2, 0, 0, 3067, 3069,
		5, 234, 0, 0, 3068, 3070, 3, 168, 84, 0, 3069, 3068, 1, 0, 0, 0, 3069,
		3070, 1, 0, 0, 0, 3070, 3071, 1, 0, 0, 0, 3071, 3079, 3, 166, 83, 3, 3072,
		3073, 10, 1, 0, 0, 3073, 3075, 7, 26, 0, 0, 3074, 3076, 3, 168, 84, 0,
		3075, 3074, 1, 0, 0, 0, 3075, 3076, 1, 0, 0, 0, 3076, 3077, 1, 0, 0, 0,
		3077, 3079, 3, 166, 83, 2, 3078, 3066, 1, 0, 0, 0, 3078, 3072, 1, 0, 0,
		0, 3079, 3082, 1, 0, 0, 0, 3080, 3078, 1, 0, 0, 0, 3080, 3081, 1, 0, 0,
		0, 3081, 167, 1, 0, 0, 0, 3082, 3080, 1, 0, 0, 0, 3083, 3084, 7, 27, 0,
		0, 3084, 169, 1, 0, 0, 0, 3085, 3092, 3, 172, 86, 0, 3086, 3087, 5, 2,
		0, 0, 3087, 3088, 3, 164, 82, 0, 3088, 3089, 5, 3, 0, 0, 3089, 3092, 1,
		0, 0, 0, 3090, 3092, 3, 298, 149, 0, 3091, 3085, 1, 0, 0, 0, 3091, 3086,
		1, 0, 0, 0, 3091, 3090, 1, 0, 0, 0, 3092, 171, 1, 0, 0, 0, 3093, 3095,
		3, 180, 90, 0, 3094, 3096, 3, 188, 94, 0, 3095, 3094, 1, 0, 0, 0, 3095,
		3096, 1, 0, 0, 0, 3096, 3098, 1, 0, 0, 0, 3097, 3099, 3, 186, 93, 0, 3098,
		3097, 1, 0, 0, 0, 3098, 3099, 1, 0, 0, 0, 3099, 3101, 1, 0, 0, 0, 3100,
		3102, 3, 184, 92, 0, 3101, 3100, 1, 0, 0, 0, 3101, 3102, 1, 0, 0, 0, 3102,
		3104, 1, 0, 0, 0, 3103, 3105, 3, 204, 102, 0, 3104, 3103, 1, 0, 0, 0, 3104,
		3105, 1, 0, 0, 0, 3105, 3107, 1, 0, 0, 0, 3106, 3108, 3, 210, 105, 0, 3107,
		3106, 1, 0, 0, 0, 3107, 3108, 1, 0, 0, 0, 3108, 3109, 1, 0, 0, 0, 3109,
		3110, 4, 86, 2, 0, 3110, 3111, 3, 224, 112, 0, 3111, 173, 1, 0, 0, 0, 3112,
		3113, 5, 495, 0, 0, 3113, 3118, 3, 176, 88, 0, 3114, 3115, 5, 4, 0, 0,
		3115, 3117, 3, 176, 88, 0, 3116, 3114, 1, 0, 0, 0, 3117, 3120, 1, 0, 0,
		0, 3118, 3116, 1, 0, 0, 0, 3118, 3119, 1, 0, 0, 0, 3119, 175, 1, 0, 0,
		0, 3120, 3118, 1, 0, 0, 0, 3121, 3123, 3, 378, 189, 0, 3122, 3124, 3, 178,
		89, 0, 3123, 3122, 1, 0, 0, 0, 3123, 3124, 1, 0, 0, 0, 3124, 3125, 1, 0,
		0, 0, 3125, 3126, 5, 30, 0, 0, 3126, 3127, 5, 2, 0, 0, 3127, 3128, 3, 164,
		82, 0, 3128, 3129, 5, 3, 0, 0, 3129, 177, 1, 0, 0, 0, 3130, 3131, 5, 2,
		0, 0, 3131, 3136, 3, 378, 189, 0, 3132, 3133, 5, 4, 0, 0, 3133, 3135, 3,
		378, 189, 0, 3134, 3132, 1, 0, 0, 0, 3135, 3138, 1, 0, 0, 0, 3136, 3134,
		1, 0, 0, 0, 3136, 3137, 1, 0, 0, 0, 3137, 3139, 1, 0, 0, 0, 3138, 3136,
		1, 0, 0, 0, 3139, 3140, 5, 3, 0, 0, 3140, 179, 1, 0, 0, 0, 3141, 3143,
		5, 402, 0, 0, 3142, 3144, 3, 212, 106, 0, 3143, 3142, 1, 0, 0, 0, 3143,
		3144, 1, 0, 0, 0, 3144, 3146, 1, 0, 0, 0, 3145, 3147, 7, 27, 0, 0, 3146,
		3145, 1, 0, 0, 0, 3146, 3147, 1, 0, 0, 0, 3147, 3148, 1, 0, 0, 0, 3148,
		3149, 3, 182, 91, 0, 3149, 181, 1, 0, 0, 0, 3150, 3151, 3, 302, 151, 0,
		3151, 183, 1, 0, 0, 0, 3152, 3153, 5, 493, 0, 0, 3153, 3154, 3, 308, 154,
		0, 3154, 185, 1, 0, 0, 0, 3155, 3156, 5, 193, 0, 0, 3156, 3157, 3, 194,
		97, 0, 3157, 187, 1, 0, 0, 0, 3158, 3160, 3, 190, 95, 0, 3159, 3158, 1,
		0, 0, 0, 3159, 3160, 1, 0, 0, 0, 3160, 3161, 1, 0, 0, 0, 3161, 3164, 5,
		236, 0, 0, 3162, 3165, 3, 192, 96, 0, 3163, 3165, 3, 378, 189, 0, 3164,
		3162, 1, 0, 0, 0, 3164, 3163, 1, 0, 0, 0, 3165, 3173, 1, 0, 0, 0, 3166,
		3169, 5, 4, 0, 0, 3167, 3170, 3, 192, 96, 0, 3168, 3170, 3, 378, 189, 0,
		3169, 3167, 1, 0, 0, 0, 3169, 3168, 1, 0, 0, 0, 3170, 3172, 1, 0, 0, 0,
		3171, 3166, 1, 0, 0, 0, 3172, 3175, 1, 0, 0, 0, 3173, 3171, 1, 0, 0, 0,
		3173, 3174, 1, 0, 0, 0, 3174, 189, 1, 0, 0, 0, 3175, 3173, 1, 0, 0, 0,
		3176, 3177, 5, 59, 0, 0, 3177, 3178, 5, 78, 0, 0, 3178, 191, 1, 0, 0, 0,
		3179, 3180, 3, 378, 189, 0, 3180, 3181, 5, 2, 0, 0, 3181, 3182, 5, 532,
		0, 0, 3182, 3183, 5, 3, 0, 0, 3183, 193, 1, 0, 0, 0, 3184, 3189, 3, 196,
		98, 0, 3185, 3186, 5, 4, 0, 0, 3186, 3188, 3, 196, 98, 0, 3187, 3185, 1,
		0, 0, 0, 3188, 3191, 1, 0, 0, 0, 3189, 3187, 1, 0, 0, 0, 3189, 3190, 1,
		0, 0, 0, 3190, 195, 1, 0, 0, 0, 3191, 3189, 1, 0, 0, 0, 3192, 3196, 3,
		244, 122, 0, 3193, 3195, 3, 198, 99, 0, 3194, 3193, 1, 0, 0, 0, 3195, 3198,
		1, 0, 0, 0, 3196, 3194, 1, 0, 0, 0, 3196, 3197, 1, 0, 0, 0, 3197, 197,
		1, 0, 0, 0, 3198, 3196, 1, 0, 0, 0, 3199, 3200, 3, 234, 117, 0, 3200, 3202,
		5, 247, 0, 0, 3201, 3203, 3, 200, 100, 0, 3202, 3201, 1, 0, 0, 0, 3202,
		3203, 1, 0, 0, 0, 3203, 3204, 1, 0, 0, 0, 3204, 3206, 3, 244, 122, 0, 3205,
		3207, 3, 236, 118, 0, 3206, 3205, 1, 0, 0, 0, 3206, 3207, 1, 0, 0, 0, 3207,
		199, 1, 0, 0, 0, 3208, 3209, 5, 7, 0, 0, 3209, 3210, 3, 378, 189, 0, 3210,
		3211, 5, 8, 0, 0, 3211, 3217, 1, 0, 0, 0, 3212, 3213, 5, 522, 0, 0, 3213,
		3214, 3, 378, 189, 0, 3214, 3215, 5, 523, 0, 0, 3215, 3217, 1, 0, 0, 0,
		3216, 3208, 1, 0, 0, 0, 3216, 3212, 1, 0, 0, 0, 3217, 201, 1, 0, 0, 0,
		3218, 3219, 5, 7, 0, 0, 3219, 3224, 3, 378, 189, 0, 3220, 3221, 5, 4, 0,
		0, 3221, 3223, 3, 378, 189, 0, 3222, 3220, 1, 0, 0, 0, 3223, 3226, 1, 0,
		0, 0, 3224, 3222, 1, 0, 0, 0, 3224, 3225, 1, 0, 0, 0, 3225, 3227, 1, 0,
		0, 0, 3226, 3224, 1, 0, 0, 0, 3227, 3228, 5, 8, 0, 0, 3228, 3241, 1, 0,
		0, 0, 3229, 3230, 5, 522, 0, 0, 3230, 3235, 3, 378, 189, 0, 3231, 3232,
		5, 4, 0, 0, 3232, 3234, 3, 378, 189, 0, 3233, 3231, 1, 0, 0, 0, 3234, 3237,
		1, 0, 0, 0, 3235, 3233, 1, 0, 0, 0, 3235, 3236, 1, 0, 0, 0, 3236, 3238,
		1, 0, 0, 0, 3237, 3235, 1, 0, 0, 0, 3238, 3239, 5, 523, 0, 0, 3239, 3241,
		1, 0, 0, 0, 3240, 3218, 1, 0, 0, 0, 3240, 3229, 1, 0, 0, 0, 3241, 203,
		1, 0, 0, 0, 3242, 3243, 5, 205, 0, 0, 3243, 3244, 5, 60, 0, 0, 3244, 3245,
		3, 206, 103, 0, 3245, 205, 1, 0, 0, 0, 3246, 3247, 5, 391, 0, 0, 3247,
		3256, 5, 2, 0, 0, 3248, 3253, 3, 304, 152, 0, 3249, 3250, 5, 4, 0, 0, 3250,
		3252, 3, 304, 152, 0, 3251, 3249, 1, 0, 0, 0, 3252, 3255, 1, 0, 0, 0, 3253,
		3251, 1, 0, 0, 0, 3253, 3254, 1, 0, 0, 0, 3254, 3257, 1, 0, 0, 0, 3255,
		3253, 1, 0, 0, 0, 3256, 3248, 1, 0, 0, 0, 3256, 3257, 1, 0, 0, 0, 3257,
		3258, 1, 0, 0, 0, 3258, 3294, 5, 3, 0, 0, 3259, 3260, 5, 103, 0, 0, 3260,
		3269, 5, 2, 0, 0, 3261, 3266, 3, 304, 152, 0, 3262, 3263, 5, 4, 0, 0, 3263,
		3265, 3, 304, 152, 0, 3264, 3262, 1, 0, 0, 0, 3265, 3268, 1, 0, 0, 0, 3266,
		3264, 1, 0, 0, 0, 3266, 3267, 1, 0, 0, 0, 3267, 3270, 1, 0, 0, 0, 3268,
		3266, 1, 0, 0, 0, 3269, 3261, 1, 0, 0, 0, 3269, 3270, 1, 0, 0, 0, 3270,
		3271, 1, 0, 0, 0, 3271, 3294, 5, 3, 0, 0, 3272, 3273, 5, 206, 0, 0, 3273,
		3274, 5, 408, 0, 0, 3274, 3275, 5, 2, 0, 0, 3275, 3280, 3, 208, 104, 0,
		3276, 3277, 5, 4, 0, 0, 3277, 3279, 3, 208, 104, 0, 3278, 3276, 1, 0, 0,
		0, 3279, 3282, 1, 0, 0, 0, 3280, 3278, 1, 0, 0, 0, 3280, 3281, 1, 0, 0,
		0, 3281, 3283, 1, 0, 0, 0, 3282, 3280, 1, 0, 0, 0, 3283, 3284, 5, 3, 0,
		0, 3284, 3294, 1, 0, 0, 0, 3285, 3290, 3, 304, 152, 0, 3286, 3287, 5, 4,
		0, 0, 3287, 3289, 3, 304, 152, 0, 3288, 3286, 1, 0, 0, 0, 3289, 3292, 1,
		0, 0, 0, 3290, 3288, 1, 0, 0, 0, 3290, 3291, 1, 0, 0, 0, 3291, 3294, 1,
		0, 0, 0, 3292, 3290, 1, 0, 0, 0, 3293, 3246, 1, 0, 0, 0, 3293, 3259, 1,
		0, 0, 0, 3293, 3272, 1, 0, 0, 0, 3293, 3285, 1, 0, 0, 0, 3294, 207, 1,
		0, 0, 0, 3295, 3304, 5, 2, 0, 0, 3296, 3301, 3, 304, 152, 0, 3297, 3298,
		5, 4, 0, 0, 3298, 3300, 3, 304, 152, 0, 3299, 3297, 1, 0, 0, 0, 3300, 3303,
		1, 0, 0, 0, 3301, 3299, 1, 0, 0, 0, 3301, 3302, 1, 0, 0, 0, 3302, 3305,
		1, 0, 0, 0, 3303, 3301, 1, 0, 0, 0, 3304, 3296, 1, 0, 0, 0, 3304, 3305,
		1, 0, 0, 0, 3305, 3306, 1, 0, 0, 0, 3306, 3307, 5, 3, 0, 0, 3307, 209,
		1, 0, 0, 0, 3308, 3309, 5, 209, 0, 0, 3309, 3310, 3, 308, 154, 0, 3310,
		211, 1, 0, 0, 0, 3311, 3318, 3, 214, 107, 0, 3312, 3314, 5, 4, 0, 0, 3313,
		3312, 1, 0, 0, 0, 3313, 3314, 1, 0, 0, 0, 3314, 3315, 1, 0, 0, 0, 3315,
		3317, 3, 214, 107, 0, 3316, 3313, 1, 0, 0, 0, 3317, 3320, 1, 0, 0, 0, 3318,
		3316, 1, 0, 0, 0, 3318, 3319, 1, 0, 0, 0, 3319, 3321, 1, 0, 0, 0, 3320,
		3318, 1, 0, 0, 0, 3321, 3322, 5, 523, 0, 0, 3322, 213, 1, 0, 0, 0, 3323,
		3337, 3, 378, 189, 0, 3324, 3325, 5, 2, 0, 0, 3325, 3332, 3, 216, 108,
		0, 3326, 3328, 5, 4, 0, 0, 3327, 3326, 1, 0, 0, 0, 3327, 3328, 1, 0, 0,
		0, 3328, 3329, 1, 0, 0, 0, 3329, 3331, 3, 216, 108, 0, 3330, 3327, 1, 0,
		0, 0, 3331, 3334, 1, 0, 0, 0, 3332, 3330, 1, 0, 0, 0, 3332, 3333, 1, 0,
		0, 0, 3333, 3335, 1, 0, 0, 0, 3334, 3332, 1, 0, 0, 0, 3335, 3336, 5, 3,
		0, 0, 3336, 3338, 1, 0, 0, 0, 3337, 3324, 1, 0, 0, 0, 3337, 3338, 1, 0,
		0, 0, 3338, 215, 1, 0, 0, 0, 3339, 3345, 3, 122, 61, 0, 3340, 3343, 5,
		501, 0, 0, 3341, 3344, 3, 344, 172, 0, 3342, 3344, 3, 378, 189, 0, 3343,
		3341, 1, 0, 0, 0, 3343, 3342, 1, 0, 0, 0, 3344, 3346, 1, 0, 0, 0, 3345,
		3340, 1, 0, 0, 0, 3345, 3346, 1, 0, 0, 0, 3346, 3349, 1, 0, 0, 0, 3347,
		3349, 3, 344, 172, 0, 3348, 3339, 1, 0, 0, 0, 3348, 3347, 1, 0, 0, 0, 3349,
		217, 1, 0, 0, 0, 3350, 3351, 3, 260, 130, 0, 3351, 3354, 5, 501, 0, 0,
		3352, 3355, 3, 304, 152, 0, 3353, 3355, 5, 133, 0, 0, 3354, 3352, 1, 0,
		0, 0, 3354, 3353, 1, 0, 0, 0, 3355, 219, 1, 0, 0, 0, 3356, 3361, 3, 218,
		109, 0, 3357, 3358, 5, 4, 0, 0, 3358, 3360, 3, 218, 109, 0, 3359, 3357,
		1, 0, 0, 0, 3360, 3363, 1, 0, 0, 0, 3361, 3359, 1, 0, 0, 0, 3361, 3362,
		1, 0, 0, 0, 3362, 221, 1, 0, 0, 0, 3363, 3361, 1, 0, 0, 0, 3364, 3365,
		5, 256, 0, 0, 3365, 3366, 5, 488, 0, 0, 3366, 3367, 3, 378, 189, 0, 3367,
		3376, 5, 2, 0, 0, 3368, 3373, 3, 304, 152, 0, 3369, 3370, 5, 4, 0, 0, 3370,
		3372, 3, 304, 152, 0, 3371, 3369, 1, 0, 0, 0, 3372, 3375, 1, 0, 0, 0, 3373,
		3371, 1, 0, 0, 0, 3373, 3374, 1, 0, 0, 0, 3374, 3377, 1, 0, 0, 0, 3375,
		3373, 1, 0, 0, 0, 3376, 3368, 1, 0, 0, 0, 3376, 3377, 1, 0, 0, 0, 3377,
		3378, 1, 0, 0, 0, 3378, 3379, 5, 3, 0, 0, 3379, 3380, 3, 378, 189, 0, 3380,
		3381, 5, 30, 0, 0, 3381, 3386, 3, 378, 189, 0, 3382, 3383, 5, 4, 0, 0,
		3383, 3385, 3, 378, 189, 0, 3384, 3382, 1, 0, 0, 0, 3385, 3388, 1, 0, 0,
		0, 3386, 3384, 1, 0, 0, 0, 3386, 3387, 1, 0, 0, 0, 3387, 223, 1, 0, 0,
		0, 3388, 3386, 1, 0, 0, 0, 3389, 3391, 3, 226, 113, 0, 3390, 3389, 1, 0,
		0, 0, 3390, 3391, 1, 0, 0, 0, 3391, 3393, 1, 0, 0, 0, 3392, 3394, 3, 230,
		115, 0, 3393, 3392, 1, 0, 0, 0, 3393, 3394, 1, 0, 0, 0, 3394, 225, 1, 0,
		0, 0, 3395, 3396, 5, 317, 0, 0, 3396, 3397, 5, 60, 0, 0, 3397, 3402, 3,
		228, 114, 0, 3398, 3399, 5, 4, 0, 0, 3399, 3401, 3, 228, 114, 0, 3400,
		3398, 1, 0, 0, 0, 3401, 3404, 1, 0, 0, 0, 3402, 3400, 1, 0, 0, 0, 3402,
		3403, 1, 0, 0, 0, 3403, 227, 1, 0, 0, 0, 3404, 3402, 1, 0, 0, 0, 3405,
		3407, 3, 304, 152, 0, 3406, 3408, 7, 28, 0, 0, 3407, 3406, 1, 0, 0, 0,
		3407, 3408, 1, 0, 0, 0, 3408, 3411, 1, 0, 0, 0, 3409, 3410, 5, 308, 0,
		0, 3410, 3412, 7, 29, 0, 0, 3411, 3409, 1, 0, 0, 0, 3411, 3412, 1, 0, 0,
		0, 3412, 229, 1, 0, 0, 0, 3413, 3414, 5, 263, 0, 0, 3414, 3424, 5, 532,
		0, 0, 3415, 3416, 5, 263, 0, 0, 3416, 3417, 5, 532, 0, 0, 3417, 3418, 5,
		311, 0, 0, 3418, 3424, 5, 532, 0, 0, 3419, 3420, 5, 263, 0, 0, 3420, 3421,
		5, 532, 0, 0, 3421, 3422, 5, 4, 0, 0, 3422, 3424, 5, 532, 0, 0, 3423, 3413,
		1, 0, 0, 0, 3423, 3415, 1, 0, 0, 0, 3423, 3419, 1, 0, 0, 0, 3424, 231,
		1, 0, 0, 0, 3425, 3426, 5, 324, 0, 0, 3426, 3427, 5, 60, 0, 0, 3427, 3432,
		3, 304, 152, 0, 3428, 3429, 5, 4, 0, 0, 3429, 3431, 3, 304, 152, 0, 3430,
		3428, 1, 0, 0, 0, 3431, 3434, 1, 0, 0, 0, 3432, 3430, 1, 0, 0, 0, 3432,
		3433, 1, 0, 0, 0, 3433, 233, 1, 0, 0, 0, 3434, 3432, 1, 0, 0, 0, 3435,
		3437, 5, 228, 0, 0, 3436, 3435, 1, 0, 0, 0, 3436, 3437, 1, 0, 0, 0, 3437,
		3460, 1, 0, 0, 0, 3438, 3460, 5, 102, 0, 0, 3439, 3441, 5, 259, 0, 0, 3440,
		3442, 5, 318, 0, 0, 3441, 3440, 1, 0, 0, 0, 3441, 3442, 1, 0, 0, 0, 3442,
		3460, 1, 0, 0, 0, 3443, 3445, 5, 386, 0, 0, 3444, 3446, 5, 318, 0, 0, 3445,
		3444, 1, 0, 0, 0, 3445, 3446, 1, 0, 0, 0, 3446, 3460, 1, 0, 0, 0, 3447,
		3449, 5, 196, 0, 0, 3448, 3450, 5, 318, 0, 0, 3449, 3448, 1, 0, 0, 0, 3449,
		3450, 1, 0, 0, 0, 3450, 3460, 1, 0, 0, 0, 3451, 3452, 5, 259, 0, 0, 3452,
		3460, 5, 403, 0, 0, 3453, 3454, 5, 386, 0, 0, 3454, 3460, 5, 403, 0, 0,
		3455, 3456, 5, 259, 0, 0, 3456, 3460, 5, 26, 0, 0, 3457, 3458, 5, 386,
		0, 0, 3458, 3460, 5, 26, 0, 0, 3459, 3436, 1, 0, 0, 0, 3459, 3438, 1, 0,
		0, 0, 3459, 3439, 1, 0, 0, 0, 3459, 3443, 1, 0, 0, 0, 3459, 3447, 1, 0,
		0, 0, 3459, 3451, 1, 0, 0, 0, 3459, 3453, 1, 0, 0, 0, 3459, 3455, 1, 0,
		0, 0, 3459, 3457, 1, 0, 0, 0, 3460, 235, 1, 0, 0, 0, 3461, 3462, 5, 312,
		0, 0, 3462, 3466, 3, 308, 154, 0, 3463, 3464, 5, 478, 0, 0, 3464, 3466,
		3, 238, 119, 0, 3465, 3461, 1, 0, 0, 0, 3465, 3463, 1, 0, 0, 0, 3466, 237,
		1, 0, 0, 0, 3467, 3468, 5, 2, 0, 0, 3468, 3469, 3, 240, 120, 0, 3469, 3470,
		5, 3, 0, 0, 3470, 239, 1, 0, 0, 0, 3471, 3476, 3, 374, 187, 0, 3472, 3473,
		5, 4, 0, 0, 3473, 3475, 3, 374, 187, 0, 3474, 3472, 1, 0, 0, 0, 3475, 3478,
		1, 0, 0, 0, 3476, 3474, 1, 0, 0, 0, 3476, 3477, 1, 0, 0, 0, 3477, 241,
		1, 0, 0, 0, 3478, 3476, 1, 0, 0, 0, 3479, 3480, 5, 525, 0, 0, 3480, 3481,
		3, 378, 189, 0, 3481, 3483, 5, 2, 0, 0, 3482, 3484, 3, 250, 125, 0, 3483,
		3482, 1, 0, 0, 0, 3483, 3484, 1, 0, 0, 0, 3484, 3485, 1, 0, 0, 0, 3485,
		3486, 5, 3, 0, 0, 3486, 243, 1, 0, 0, 0, 3487, 3489, 3, 260, 130, 0, 3488,
		3490, 3, 242, 121, 0, 3489, 3488, 1, 0, 0, 0, 3489, 3490, 1, 0, 0, 0, 3490,
		3492, 1, 0, 0, 0, 3491, 3493, 3, 246, 123, 0, 3492, 3491, 1, 0, 0, 0, 3492,
		3493, 1, 0, 0, 0, 3493, 3495, 1, 0, 0, 0, 3494, 3496, 3, 372, 186, 0, 3495,
		3494, 1, 0, 0, 0, 3495, 3496, 1, 0, 0, 0, 3496, 3498, 1, 0, 0, 0, 3497,
		3499, 3, 342, 171, 0, 3498, 3497, 1, 0, 0, 0, 3498, 3499, 1, 0, 0, 0, 3499,
		3501, 1, 0, 0, 0, 3500, 3502, 3, 296, 148, 0, 3501, 3500, 1, 0, 0, 0, 3501,
		3502, 1, 0, 0, 0, 3502, 3503, 1, 0, 0, 0, 3503, 3505, 3, 258, 129, 0, 3504,
		3506, 3, 368, 184, 0, 3505, 3504, 1, 0, 0, 0, 3505, 3506, 1, 0, 0, 0, 3506,
		3508, 1, 0, 0, 0, 3507, 3509, 3, 202, 101, 0, 3508, 3507, 1, 0, 0, 0, 3508,
		3509, 1, 0, 0, 0, 3509, 3513, 1, 0, 0, 0, 3510, 3512, 3, 222, 111, 0, 3511,
		3510, 1, 0, 0, 0, 3512, 3515, 1, 0, 0, 0, 3513, 3511, 1, 0, 0, 0, 3513,
		3514, 1, 0, 0, 0, 3514, 3539, 1, 0, 0, 0, 3515, 3513, 1, 0, 0, 0, 3516,
		3517, 5, 2, 0, 0, 3517, 3518, 3, 164, 82, 0, 3518, 3519, 5, 3, 0, 0, 3519,
		3523, 3, 258, 129, 0, 3520, 3522, 3, 222, 111, 0, 3521, 3520, 1, 0, 0,
		0, 3522, 3525, 1, 0, 0, 0, 3523, 3521, 1, 0, 0, 0, 3523, 3524, 1, 0, 0,
		0, 3524, 3539, 1, 0, 0, 0, 3525, 3523, 1, 0, 0, 0, 3526, 3527, 3, 378,
		189, 0, 3527, 3529, 5, 2, 0, 0, 3528, 3530, 3, 250, 125, 0, 3529, 3528,
		1, 0, 0, 0, 3529, 3530, 1, 0, 0, 0, 3530, 3531, 1, 0, 0, 0, 3531, 3532,
		5, 3, 0, 0, 3532, 3533, 3, 258, 129, 0, 3533, 3539, 1, 0, 0, 0, 3534, 3535,
		5, 2, 0, 0, 3535, 3536, 3, 194, 97, 0, 3536, 3537, 5, 3, 0, 0, 3537, 3539,
		1, 0, 0, 0, 3538, 3487, 1, 0, 0, 0, 3538, 3516, 1, 0, 0, 0, 3538, 3526,
		1, 0, 0, 0, 3538, 3534, 1, 0, 0, 0, 3539, 245, 1, 0, 0, 0, 3540, 3541,
		5, 225, 0, 0, 3541, 3542, 3, 378, 189, 0, 3542, 247, 1, 0, 0, 0, 3543,
		3544, 5, 352, 0, 0, 3544, 3545, 5, 2, 0, 0, 3545, 3546, 3, 250, 125, 0,
		3546, 3547, 5, 3, 0, 0, 3547, 249, 1, 0, 0, 0, 3548, 3553, 3, 252, 126,
		0, 3549, 3550, 5, 4, 0, 0, 3550, 3552, 3, 252, 126, 0, 3551, 3549, 1, 0,
		0, 0, 3552, 3555, 1, 0, 0, 0, 3553, 3551, 1, 0, 0, 0, 3553, 3554, 1, 0,
		0, 0, 3554, 251, 1, 0, 0, 0, 3555, 3553, 1, 0, 0, 0, 3556, 3557, 3, 254,
		127, 0, 3557, 3558, 5, 501, 0, 0, 3558, 3559, 3, 256, 128, 0, 3559, 253,
		1, 0, 0, 0, 3560, 3563, 3, 378, 189, 0, 3561, 3563, 3, 344, 172, 0, 3562,
		3560, 1, 0, 0, 0, 3562, 3561, 1, 0, 0, 0, 3563, 255, 1, 0, 0, 0, 3564,
		3567, 3, 378, 189, 0, 3565, 3567, 3, 344, 172, 0, 3566, 3564, 1, 0, 0,
		0, 3566, 3565, 1, 0, 0, 0, 3567, 257, 1, 0, 0, 0, 3568, 3570, 5, 30, 0,
		0, 3569, 3568, 1, 0, 0, 0, 3569, 3570, 1, 0, 0, 0, 3570, 3571, 1, 0, 0,
		0, 3571, 3573, 3, 380, 190, 0, 3572, 3574, 3, 238, 119, 0, 3573, 3572,
		1, 0, 0, 0, 3573, 3574, 1, 0, 0, 0, 3574, 3576, 1, 0, 0, 0, 3575, 3569,
		1, 0, 0, 0, 3575, 3576, 1, 0, 0, 0, 3576, 259, 1, 0, 0, 0, 3577, 3582,
		3, 374, 187, 0, 3578, 3579, 5, 5, 0, 0, 3579, 3581, 3, 374, 187, 0, 3580,
		3578, 1, 0, 0, 0, 3581, 3584, 1, 0, 0, 0, 3582, 3580, 1, 0, 0, 0, 3582,
		3583, 1, 0, 0, 0, 3583, 261, 1, 0, 0, 0, 3584, 3582, 1, 0, 0, 0, 3585,
		3590, 3, 264, 132, 0, 3586, 3587, 5, 4, 0, 0, 3587, 3589, 3, 264, 132,
		0, 3588, 3586, 1, 0, 0, 0, 3589, 3592, 1, 0, 0, 0, 3590, 3588, 1, 0, 0,
		0, 3590, 3591, 1, 0, 0, 0, 3591, 263, 1, 0, 0, 0, 3592, 3590, 1, 0, 0,
		0, 3593, 3596, 3, 378, 189, 0, 3594, 3595, 5, 82, 0, 0, 3595, 3597, 5,
		527, 0, 0, 3596, 3594, 1, 0, 0, 0, 3596, 3597, 1, 0, 0, 0, 3597, 265, 1,
		0, 0, 0, 3598, 3603, 3, 268, 134, 0, 3599, 3600, 5, 4, 0, 0, 3600, 3602,
		3, 268, 134, 0, 3601, 3599, 1, 0, 0, 0, 3602, 3605, 1, 0, 0, 0, 3603, 3601,
		1, 0, 0, 0, 3603, 3604, 1, 0, 0, 0, 3604, 267, 1, 0, 0, 0, 3605, 3603,
		1, 0, 0, 0, 3606, 3607, 3, 378, 189, 0, 3607, 3609, 3, 358, 179, 0, 3608,
		3610, 5, 250, 0, 0, 3609, 3608, 1, 0, 0, 0, 3609, 3610, 1, 0, 0, 0, 3610,
		3612, 1, 0, 0, 0, 3611, 3613, 3, 294, 147, 0, 3612, 3611, 1, 0, 0, 0, 3612,
		3613, 1, 0, 0, 0, 3613, 3623, 1, 0, 0, 0, 3614, 3615, 5, 199, 0, 0, 3615,
		3617, 5, 36, 0, 0, 3616, 3614, 1, 0, 0, 0, 3616, 3617, 1, 0, 0, 0, 3617,
		3618, 1, 0, 0, 0, 3618, 3619, 5, 30, 0, 0, 3619, 3620, 5, 2, 0, 0, 3620,
		3621, 3, 304, 152, 0, 3621, 3622, 5, 3, 0, 0, 3622, 3624, 1, 0, 0, 0, 3623,
		3616, 1, 0, 0, 0, 3623, 3624, 1, 0, 0, 0, 3624, 3629, 1, 0, 0, 0, 3625,
		3627, 5, 306, 0, 0, 3626, 3625, 1, 0, 0, 0, 3626, 3627, 1, 0, 0, 0, 3627,
		3628, 1, 0, 0, 0, 3628, 3630, 5, 307, 0, 0, 3629, 3626, 1, 0, 0, 0, 3629,
		3630, 1, 0, 0, 0, 3630, 3638, 1, 0, 0, 0, 3631, 3636, 5, 35, 0, 0, 3632,
		3633, 5, 2, 0, 0, 3633, 3634, 3, 384, 192, 0, 3634, 3635, 5, 3, 0, 0, 3635,
		3637, 1, 0, 0, 0, 3636, 3632, 1, 0, 0, 0, 3636, 3637, 1, 0, 0, 0, 3637,
		3639, 1, 0, 0, 0, 3638, 3631, 1, 0, 0, 0, 3638, 3639, 1, 0, 0, 0, 3639,
		3656, 1, 0, 0, 0, 3640, 3654, 5, 133, 0, 0, 3641, 3655, 5, 307, 0, 0, 3642,
		3655, 5, 532, 0, 0, 3643, 3655, 5, 534, 0, 0, 3644, 3655, 5, 337, 0, 0,
		3645, 3655, 5, 527, 0, 0, 3646, 3655, 5, 106, 0, 0, 3647, 3652, 5, 108,
		0, 0, 3648, 3649, 5, 2, 0, 0, 3649, 3650, 3, 384, 192, 0, 3650, 3651, 5,
		3, 0, 0, 3651, 3653, 1, 0, 0, 0, 3652, 3648, 1, 0, 0, 0, 3652, 3653, 1,
		0, 0, 0, 3653, 3655, 1, 0, 0, 0, 3654, 3641, 1, 0, 0, 0, 3654, 3642, 1,
		0, 0, 0, 3654, 3643, 1, 0, 0, 0, 3654, 3644, 1, 0, 0, 0, 3654, 3645, 1,
		0, 0, 0, 3654, 3646, 1, 0, 0, 0, 3654, 3647, 1, 0, 0, 0, 3655, 3657, 1,
		0, 0, 0, 3656, 3640, 1, 0, 0, 0, 3656, 3657, 1, 0, 0, 0, 3657, 3667, 1,
		0, 0, 0, 3658, 3659, 5, 312, 0, 0, 3659, 3660, 5, 475, 0, 0, 3660, 3665,
		5, 108, 0, 0, 3661, 3662, 5, 2, 0, 0, 3662, 3663, 3, 384, 192, 0, 3663,
		3664, 5, 3, 0, 0, 3664, 3666, 1, 0, 0, 0, 3665, 3661, 1, 0, 0, 0, 3665,
		3666, 1, 0, 0, 0, 3666, 3668, 1, 0, 0, 0, 3667, 3658, 1, 0, 0, 0, 3667,
		3668, 1, 0, 0, 0, 3668, 3671, 1, 0, 0, 0, 3669, 3670, 5, 82, 0, 0, 3670,
		3672, 5, 527, 0, 0, 3671, 3669, 1, 0, 0, 0, 3671, 3672, 1, 0, 0, 0, 3672,
		269, 1, 0, 0, 0, 3673, 3678, 3, 272, 136, 0, 3674, 3675, 5, 4, 0, 0, 3675,
		3677, 3, 272, 136, 0, 3676, 3674, 1, 0, 0, 0, 3677, 3680, 1, 0, 0, 0, 3678,
		3676, 1, 0, 0, 0, 3678, 3679, 1, 0, 0, 0, 3679, 271, 1, 0, 0, 0, 3680,
		3678, 1, 0, 0, 0, 3681, 3685, 5, 225, 0, 0, 3682, 3683, 5, 220, 0, 0, 3683,
		3684, 5, 306, 0, 0, 3684, 3686, 5, 170, 0, 0, 3685, 3682, 1, 0, 0, 0, 3685,
		3686, 1, 0, 0, 0, 3686, 3687, 1, 0, 0, 0, 3687, 3688, 3, 378, 189, 0, 3688,
		3691, 3, 238, 119, 0, 3689, 3690, 5, 478, 0, 0, 3690, 3692, 7, 12, 0, 0,
		3691, 3689, 1, 0, 0, 0, 3691, 3692, 1, 0, 0, 0, 3692, 3698, 1, 0, 0, 0,
		3693, 3694, 5, 352, 0, 0, 3694, 3695, 5, 2, 0, 0, 3695, 3696, 3, 250, 125,
		0, 3696, 3697, 5, 3, 0, 0, 3697, 3699, 1, 0, 0, 0, 3698, 3693, 1, 0, 0,
		0, 3698, 3699, 1, 0, 0, 0, 3699, 3702, 1, 0, 0, 0, 3700, 3701, 5, 82, 0,
		0, 3701, 3703, 5, 527, 0, 0, 3702, 3700, 1, 0, 0, 0, 3702, 3703, 1, 0,
		0, 0, 3703, 273, 1, 0, 0, 0, 3704, 3709, 3, 276, 138, 0, 3705, 3706, 5,
		4, 0, 0, 3706, 3708, 3, 276, 138, 0, 3707, 3705, 1, 0, 0, 0, 3708, 3711,
		1, 0, 0, 0, 3709, 3707, 1, 0, 0, 0, 3709, 3710, 1, 0, 0, 0, 3710, 275,
		1, 0, 0, 0, 3711, 3709, 1, 0, 0, 0, 3712, 3717, 3, 278, 139, 0, 3713, 3717,
		3, 280, 140, 0, 3714, 3717, 3, 282, 141, 0, 3715, 3717, 3, 284, 142, 0,
		3716, 3712, 1, 0, 0, 0, 3716, 3713, 1, 0, 0, 0, 3716, 3714, 1, 0, 0, 0,
		3716, 3715, 1, 0, 0, 0, 3717, 3722, 1, 0, 0, 0, 3718, 3719, 5, 2, 0, 0,
		3719, 3720, 3, 250, 125, 0, 3720, 3721, 5, 3, 0, 0, 3721, 3723, 1, 0, 0,
		0, 3722, 3718, 1, 0, 0, 0, 3722, 3723, 1, 0, 0, 0, 3723, 277, 1, 0, 0,
		0, 3724, 3728, 5, 324, 0, 0, 3725, 3726, 5, 220, 0, 0, 3726, 3727, 5, 306,
		0, 0, 3727, 3729, 5, 170, 0, 0, 3728, 3725, 1, 0, 0, 0, 3728, 3729, 1,
		0, 0, 0, 3729, 3730, 1, 0, 0, 0, 3730, 3731, 3, 378, 189, 0, 3731, 3732,
		5, 480, 0, 0, 3732, 3733, 5, 260, 0, 0, 3733, 3736, 5, 448, 0, 0, 3734,
		3737, 5, 286, 0, 0, 3735, 3737, 3, 286, 143, 0, 3736, 3734, 1, 0, 0, 0,
		3736, 3735, 1, 0, 0, 0, 3737, 279, 1, 0, 0, 0, 3738, 3742, 5, 324, 0, 0,
		3739, 3740, 5, 220, 0, 0, 3740, 3741, 5, 306, 0, 0, 3741, 3743, 5, 170,
		0, 0, 3742, 3739, 1, 0, 0, 0, 3742, 3743, 1, 0, 0, 0, 3743, 3744, 1, 0,
		0, 0, 3744, 3745, 3, 378, 189, 0, 3745, 3746, 5, 480, 0, 0, 3746, 3747,
		5, 7, 0, 0, 3747, 3748, 3, 286, 143, 0, 3748, 3749, 5, 4, 0, 0, 3749, 3750,
		3, 286, 143, 0, 3750, 3751, 5, 3, 0, 0, 3751, 281, 1, 0, 0, 0, 3752, 3753,
		5, 193, 0, 0, 3753, 3754, 3, 286, 143, 0, 3754, 3755, 5, 455, 0, 0, 3755,
		3756, 3, 286, 143, 0, 3756, 3757, 5, 235, 0, 0, 3757, 3759, 5, 532, 0,
		0, 3758, 3760, 3, 318, 159, 0, 3759, 3758, 1, 0, 0, 0, 3759, 3760, 1, 0,
		0, 0, 3760, 283, 1, 0, 0, 0, 3761, 3765, 5, 324, 0, 0, 3762, 3763, 5, 220,
		0, 0, 3763, 3764, 5, 306, 0, 0, 3764, 3766, 5, 170, 0, 0, 3765, 3762, 1,
		0, 0, 0, 3765, 3766, 1, 0, 0, 0, 3766, 3767, 1, 0, 0, 0, 3767, 3784, 3,
		378, 189, 0, 3768, 3769, 5, 480, 0, 0, 3769, 3782, 5, 223, 0, 0, 3770,
		3771, 5, 2, 0, 0, 3771, 3776, 3, 286, 143, 0, 3772, 3773, 5, 4, 0, 0, 3773,
		3775, 3, 286, 143, 0, 3774, 3772, 1, 0, 0, 0, 3775, 3778, 1, 0, 0, 0, 3776,
		3774, 1, 0, 0, 0, 3776, 3777, 1, 0, 0, 0, 3777, 3779, 1, 0, 0, 0, 3778,
		3776, 1, 0, 0, 0, 3779, 3780, 5, 3, 0, 0, 3780, 3783, 1, 0, 0, 0, 3781,
		3783, 3, 286, 143, 0, 3782, 3770, 1, 0, 0, 0, 3782, 3781, 1, 0, 0, 0, 3783,
		3785, 1, 0, 0, 0, 3784, 3768, 1, 0, 0, 0, 3784, 3785, 1, 0, 0, 0, 3785,
		285, 1, 0, 0, 0, 3786, 3787, 5, 2, 0, 0, 3787, 3792, 3, 288, 144, 0, 3788,
		3789, 5, 4, 0, 0, 3789, 3791, 3, 288, 144, 0, 3790, 3788, 1, 0, 0, 0, 3791,
		3794, 1, 0, 0, 0, 3792, 3790, 1, 0, 0, 0, 3792, 3793, 1, 0, 0, 0, 3793,
		3795, 1, 0, 0, 0, 3794, 3792, 1, 0, 0, 0, 3795, 3796, 5, 3, 0, 0, 3796,
		287, 1, 0, 0, 0, 3797, 3798, 7, 30, 0, 0, 3798, 289, 1, 0, 0, 0, 3799,
		3804, 3, 292, 146, 0, 3800, 3801, 5, 4, 0, 0, 3801, 3803, 3, 292, 146,
		0, 3802, 3800, 1, 0, 0, 0, 3803, 3806, 1, 0, 0, 0, 3804, 3802, 1, 0, 0,
		0, 3804, 3805, 1, 0, 0, 0, 3805, 291, 1, 0, 0, 0, 3806, 3804, 1, 0, 0,
		0, 3807, 3808, 3, 378, 189, 0, 3808, 3812, 3, 238, 119, 0, 3809, 3810,
		5, 153, 0, 0, 3810, 3811, 5, 250, 0, 0, 3811, 3813, 3, 238, 119, 0, 3812,
		3809, 1, 0, 0, 0, 3812, 3813, 1, 0, 0, 0, 3813, 3815, 1, 0, 0, 0, 3814,
		3816, 3, 248, 124, 0, 3815, 3814, 1, 0, 0, 0, 3815, 3816, 1, 0, 0, 0, 3816,
		293, 1, 0, 0, 0, 3817, 3818, 7, 31, 0, 0, 3818, 295, 1, 0, 0, 0, 3819,
		3820, 5, 441, 0, 0, 3820, 3821, 5, 2, 0, 0, 3821, 3826, 5, 532, 0, 0, 3822,
		3823, 5, 4, 0, 0, 3823, 3825, 5, 532, 0, 0, 3824, 3822, 1, 0, 0, 0, 3825,
		3828, 1, 0, 0, 0, 3826, 3824, 1, 0, 0, 0, 3826, 3827, 1, 0, 0, 0, 3827,
		3829, 1, 0, 0, 0, 3828, 3826, 1, 0, 0, 0, 3829, 3830, 5, 3, 0, 0, 3830,
		297, 1, 0, 0, 0, 3831, 3832, 5, 480, 0, 0, 3832, 3837, 3, 310, 155, 0,
		3833, 3834, 5, 4, 0, 0, 3834, 3836, 3, 310, 155, 0, 3835, 3833, 1, 0, 0,
		0, 3836, 3839, 1, 0, 0, 0, 3837, 3835, 1, 0, 0, 0, 3837, 3838, 1, 0, 0,
		0, 3838, 299, 1, 0, 0, 0, 3839, 3837, 1, 0, 0, 0, 3840, 3845, 3, 304, 152,
		0, 3841, 3843, 5, 30, 0, 0, 3842, 3841, 1, 0, 0, 0, 3842, 3843, 1, 0, 0,
		0, 3843, 3844, 1, 0, 0, 0, 3844, 3846, 3, 122, 61, 0, 3845, 3842, 1, 0,
		0, 0, 3845, 3846, 1, 0, 0, 0, 3846, 301, 1, 0, 0, 0, 3847, 3852, 3, 300,
		150, 0, 3848, 3849, 5, 4, 0, 0, 3849, 3851, 3, 300, 150, 0, 3850, 3848,
		1, 0, 0, 0, 3851, 3854, 1, 0, 0, 0, 3852, 3850, 1, 0, 0, 0, 3852, 3853,
		1, 0, 0, 0, 3853, 303, 1, 0, 0, 0, 3854, 3852, 1, 0, 0, 0, 3855, 3858,
		3, 308, 154, 0, 3856, 3858, 3, 306, 153, 0, 3857, 3855, 1, 0, 0, 0, 3857,
		3856, 1, 0, 0, 0, 3858, 305, 1, 0, 0, 0, 3859, 3860, 3, 374, 187, 0, 3860,
		3861, 5, 521, 0, 0, 3861, 3862, 3, 308, 154, 0, 3862, 3876, 1, 0, 0, 0,
		3863, 3864, 5, 2, 0, 0, 3864, 3867, 3, 374, 187, 0, 3865, 3866, 5, 4, 0,
		0, 3866, 3868, 3, 374, 187, 0, 3867, 3865, 1, 0, 0, 0, 3868, 3869, 1, 0,
		0, 0, 3869, 3867, 1, 0, 0, 0, 3869, 3870, 1, 0, 0, 0, 3870, 3871, 1, 0,
		0, 0, 3871, 3872, 5, 3, 0, 0, 3872, 3873, 5, 521, 0, 0, 3873, 3874, 3,
		308, 154, 0, 3874, 3876, 1, 0, 0, 0, 3875, 3859, 1, 0, 0, 0, 3875, 3863,
		1, 0, 0, 0, 3876, 307, 1, 0, 0, 0, 3877, 3878, 6, 154, -1, 0, 3878, 3879,
		7, 32, 0, 0, 3879, 3900, 3, 308, 154, 9, 3880, 3881, 5, 170, 0, 0, 3881,
		3882, 5, 2, 0, 0, 3882, 3883, 3, 164, 82, 0, 3883, 3884, 5, 3, 0, 0, 3884,
		3900, 1, 0, 0, 0, 3885, 3886, 7, 33, 0, 0, 3886, 3887, 5, 2, 0, 0, 3887,
		3888, 3, 316, 158, 0, 3888, 3889, 5, 3, 0, 0, 3889, 3900, 1, 0, 0, 0, 3890,
		3891, 5, 241, 0, 0, 3891, 3892, 5, 2, 0, 0, 3892, 3893, 3, 316, 158, 0,
		3893, 3894, 5, 3, 0, 0, 3894, 3900, 1, 0, 0, 0, 3895, 3897, 3, 316, 158,
		0, 3896, 3898, 3, 314, 157, 0, 3897, 3896, 1, 0, 0, 0, 3897, 3898, 1, 0,
		0, 0, 3898, 3900, 1, 0, 0, 0, 3899, 3877, 1, 0, 0, 0, 3899, 3880, 1, 0,
		0, 0, 3899, 3885, 1, 0, 0, 0, 3899, 3890, 1, 0, 0, 0, 3899, 3895, 1, 0,
		0, 0, 3900, 3915, 1, 0, 0, 0, 3901, 3902, 10, 4, 0, 0, 3902, 3903, 7, 34,
		0, 0, 3903, 3914, 3, 308, 154, 5, 3904, 3905, 10, 3, 0, 0, 3905, 3906,
		5, 499, 0, 0, 3906, 3914, 3, 308, 154, 4, 3907, 3908, 10, 2, 0, 0, 3908,
		3909, 5, 316, 0, 0, 3909, 3914, 3, 308, 154, 3, 3910, 3911, 10, 1, 0, 0,
		3911, 3912, 5, 518, 0, 0, 3912, 3914, 3, 308, 154, 2, 3913, 3901, 1, 0,
		0, 0, 3913, 3904, 1, 0, 0, 0, 3913, 3907, 1, 0, 0, 0, 3913, 3910, 1, 0,
		0, 0, 3914, 3917, 1, 0, 0, 0, 3915, 3913, 1, 0, 0, 0, 3915, 3916, 1, 0,
		0, 0, 3916, 309, 1, 0, 0, 0, 3917, 3915, 1, 0, 0, 0, 3918, 3927, 5, 2,
		0, 0, 3919, 3924, 3, 312, 156, 0, 3920, 3921, 5, 4, 0, 0, 3921, 3923, 3,
		312, 156, 0, 3922, 3920, 1, 0, 0, 0, 3923, 3926, 1, 0, 0, 0, 3924, 3922,
		1, 0, 0, 0, 3924, 3925, 1, 0, 0, 0, 3925, 3928, 1, 0, 0, 0, 3926, 3924,
		1, 0, 0, 0, 3927, 3919, 1, 0, 0, 0, 3927, 3928, 1, 0, 0, 0, 3928, 3929,
		1, 0, 0, 0, 3929, 3930, 5, 3, 0, 0, 3930, 311, 1, 0, 0, 0, 3931, 3934,
		3, 300, 150, 0, 3932, 3934, 5, 133, 0, 0, 3933, 3931, 1, 0, 0, 0, 3933,
		3932, 1, 0, 0, 0, 3934, 313, 1, 0, 0, 0, 3935, 3937, 5, 306, 0, 0, 3936,
		3935, 1, 0, 0, 0, 3936, 3937, 1, 0, 0, 0, 3937, 3938, 1, 0, 0, 0, 3938,
		3939, 5, 42, 0, 0, 3939, 3940, 3, 316, 158, 0, 3940, 3941, 5, 25, 0, 0,
		3941, 3942, 3, 316, 158, 0, 3942, 3987, 1, 0, 0, 0, 3943, 3945, 5, 306,
		0, 0, 3944, 3943, 1, 0, 0, 0, 3944, 3945, 1, 0, 0, 0, 3945, 3946, 1, 0,
		0, 0, 3946, 3947, 7, 35, 0, 0, 3947, 3987, 3, 316, 158, 0, 3948, 3950,
		5, 306, 0, 0, 3949, 3948, 1, 0, 0, 0, 3949, 3950, 1, 0, 0, 0, 3950, 3951,
		1, 0, 0, 0, 3951, 3952, 7, 36, 0, 0, 3952, 3987, 3, 316, 158, 0, 3953,
		3955, 5, 306, 0, 0, 3954, 3953, 1, 0, 0, 0, 3954, 3955, 1, 0, 0, 0, 3955,
		3956, 1, 0, 0, 0, 3956, 3957, 5, 223, 0, 0, 3957, 3958, 5, 2, 0, 0, 3958,
		3959, 3, 164, 82, 0, 3959, 3960, 5, 3, 0, 0, 3960, 3987, 1, 0, 0, 0, 3961,
		3963, 5, 306, 0, 0, 3962, 3961, 1, 0, 0, 0, 3962, 3963, 1, 0, 0, 0, 3963,
		3964, 1, 0, 0, 0, 3964, 3965, 5, 223, 0, 0, 3965, 3966, 5, 2, 0, 0, 3966,
		3971, 3, 304, 152, 0, 3967, 3968, 5, 4, 0, 0, 3968, 3970, 3, 304, 152,
		0, 3969, 3967, 1, 0, 0, 0, 3970, 3973, 1, 0, 0, 0, 3971, 3969, 1, 0, 0,
		0, 3971, 3972, 1, 0, 0, 0, 3972, 3974, 1, 0, 0, 0, 3973, 3971, 1, 0, 0,
		0, 3974, 3975, 5, 3, 0, 0, 3975, 3987, 1, 0, 0, 0, 3976, 3978, 5, 240,
		0, 0, 3977, 3979, 5, 306, 0, 0, 3978, 3977, 1, 0, 0, 0, 3978, 3979, 1,
		0, 0, 0, 3979, 3980, 1, 0, 0, 0, 3980, 3987, 5, 307, 0, 0, 3981, 3983,
		5, 240, 0, 0, 3982, 3984, 5, 306, 0, 0, 3983, 3982, 1, 0, 0, 0, 3983, 3984,
		1, 0, 0, 0, 3984, 3985, 1, 0, 0, 0, 3985, 3987, 7, 37, 0, 0, 3986, 3936,
		1, 0, 0, 0, 3986, 3944, 1, 0, 0, 0, 3986, 3949, 1, 0, 0, 0, 3986, 3954,
		1, 0, 0, 0, 3986, 3962, 1, 0, 0, 0, 3986, 3976, 1, 0, 0, 0, 3986, 3981,
		1, 0, 0, 0, 3987, 315, 1, 0, 0, 0, 3988, 3989, 6, 158, -1, 0, 3989, 4000,
		3, 320, 160, 0, 3990, 3991, 7, 38, 0, 0, 3991, 4000, 3, 316, 158, 5, 3992,
		3993, 7, 39, 0, 0, 3993, 3994, 5, 2, 0, 0, 3994, 3995, 3, 316, 158, 0,
		3995, 3996, 5, 4, 0, 0, 3996, 3997, 3, 316, 158, 0, 3997, 3998, 5, 3, 0,
		0, 3998, 4000, 1, 0, 0, 0, 3999, 3988, 1, 0, 0, 0, 3999, 3990, 1, 0, 0,
		0, 3999, 3992, 1, 0, 0, 0, 4000, 4013, 1, 0, 0, 0, 4001, 4002, 10, 4, 0,
		0, 4002, 4003, 7, 40, 0, 0, 4003, 4012, 3, 316, 158, 5, 4004, 4005, 10,
		3, 0, 0, 4005, 4006, 7, 41, 0, 0, 4006, 4012, 3, 316, 158, 4, 4007, 4008,
		10, 2, 0, 0, 4008, 4009, 3, 346, 173, 0, 4009, 4010, 3, 316, 158, 3, 4010,
		4012, 1, 0, 0, 0, 4011, 4001, 1, 0, 0, 0, 4011, 4004, 1, 0, 0, 0, 4011,
		4007, 1, 0, 0, 0, 4012, 4015, 1, 0, 0, 0, 4013, 4011, 1, 0, 0, 0, 4013,
		4014, 1, 0, 0, 0, 4014, 317, 1, 0, 0, 0, 4015, 4013, 1, 0, 0, 0, 4016,
		4017, 7, 42, 0, 0, 4017, 319, 1, 0, 0, 0, 4018, 4019, 6, 160, -1, 0, 4019,
		4020, 7, 43, 0, 0, 4020, 4021, 5, 2, 0, 0, 4021, 4022, 3, 318, 159, 0,
		4022, 4023, 5, 4, 0, 0, 4023, 4024, 3, 316, 158, 0, 4024, 4025, 5, 4, 0,
		0, 4025, 4026, 3, 316, 158, 0, 4026, 4027, 5, 3, 0, 0, 4027, 4229, 1, 0,
		0, 0, 4028, 4029, 7, 44, 0, 0, 4029, 4030, 5, 2, 0, 0, 4030, 4031, 3, 318,
		159, 0, 4031, 4032, 5, 4, 0, 0, 4032, 4033, 3, 316, 158, 0, 4033, 4034,
		5, 4, 0, 0, 4034, 4035, 3, 316, 158, 0, 4035, 4036, 5, 3, 0, 0, 4036, 4229,
		1, 0, 0, 0, 4037, 4038, 7, 45, 0, 0, 4038, 4039, 5, 2, 0, 0, 4039, 4040,
		3, 316, 158, 0, 4040, 4046, 5, 4, 0, 0, 4041, 4042, 5, 235, 0, 0, 4042,
		4043, 3, 316, 158, 0, 4043, 4044, 3, 318, 159, 0, 4044, 4047, 1, 0, 0,
		0, 4045, 4047, 3, 316, 158, 0, 4046, 4041, 1, 0, 0, 0, 4046, 4045, 1, 0,
		0, 0, 4047, 4048, 1, 0, 0, 0, 4048, 4049, 5, 3, 0, 0, 4049, 4229, 1, 0,
		0, 0, 4050, 4051, 7, 46, 0, 0, 4051, 4052, 5, 2, 0, 0, 4052, 4053, 3, 316,
		158, 0, 4053, 4059, 5, 4, 0, 0, 4054, 4055, 5, 235, 0, 0, 4055, 4056, 3,
		316, 158, 0, 4056, 4057, 3, 318, 159, 0, 4057, 4060, 1, 0, 0, 0, 4058,
		4060, 3, 316, 158, 0, 4059, 4054, 1, 0, 0, 0, 4059, 4058, 1, 0, 0, 0, 4060,
		4061, 1, 0, 0, 0, 4061, 4062, 5, 3, 0, 0, 4062, 4229, 1, 0, 0, 0, 4063,
		4064, 5, 117, 0, 0, 4064, 4065, 5, 2, 0, 0, 4065, 4066, 3, 316, 158, 0,
		4066, 4072, 5, 4, 0, 0, 4067, 4068, 5, 235, 0, 0, 4068, 4069, 3, 316, 158,
		0, 4069, 4070, 3, 318, 159, 0, 4070, 4073, 1, 0, 0, 0, 4071, 4073, 3, 316,
		158, 0, 4072, 4067, 1, 0, 0, 0, 4072, 4071, 1, 0, 0, 0, 4073, 4074, 1,
		0, 0, 0, 4074, 4075, 5, 3, 0, 0, 4075, 4229, 1, 0, 0, 0, 4076, 4077, 5,
		115, 0, 0, 4077, 4078, 5, 2, 0, 0, 4078, 4079, 3, 316, 158, 0, 4079, 4085,
		5, 4, 0, 0, 4080, 4081, 5, 235, 0, 0, 4081, 4082, 3, 316, 158, 0, 4082,
		4083, 3, 318, 159, 0, 4083, 4086, 1, 0, 0, 0, 4084, 4086, 3, 316, 158,
		0, 4085, 4080, 1, 0, 0, 0, 4085, 4084, 1, 0, 0, 0, 4086, 4087, 1, 0, 0,
		0, 4087, 4088, 5, 3, 0, 0, 4088, 4229, 1, 0, 0, 0, 4089, 4090, 7, 47, 0,
		0, 4090, 4091, 5, 2, 0, 0, 4091, 4092, 3, 316, 158, 0, 4092, 4093, 5, 4,
		0, 0, 4093, 4094, 3, 316, 158, 0, 4094, 4100, 5, 4, 0, 0, 4095, 4096, 5,
		235, 0, 0, 4096, 4097, 3, 316, 158, 0, 4097, 4098, 3, 318, 159, 0, 4098,
		4101, 1, 0, 0, 0, 4099, 4101, 3, 316, 158, 0, 4100, 4095, 1, 0, 0, 0, 4100,
		4099, 1, 0, 0, 0, 4101, 4102, 1, 0, 0, 0, 4102, 4103, 5, 3, 0, 0, 4103,
		4229, 1, 0, 0, 0, 4104, 4229, 5, 106, 0, 0, 4105, 4229, 5, 107, 0, 0, 4106,
		4229, 5, 108, 0, 0, 4107, 4229, 5, 269, 0, 0, 4108, 4229, 5, 270, 0, 0,
		4109, 4229, 5, 109, 0, 0, 4110, 4112, 5, 65, 0, 0, 4111, 4113, 3, 350,
		175, 0, 4112, 4111, 1, 0, 0, 0, 4113, 4114, 1, 0, 0, 0, 4114, 4112, 1,
		0, 0, 0, 4114, 4115, 1, 0, 0, 0, 4115, 4118, 1, 0, 0, 0, 4116, 4117, 5,
		155, 0, 0, 4117, 4119, 3, 304, 152, 0, 4118, 4116, 1, 0, 0, 0, 4118, 4119,
		1, 0, 0, 0, 4119, 4120, 1, 0, 0, 0, 4120, 4121, 5, 159, 0, 0, 4121, 4229,
		1, 0, 0, 0, 4122, 4123, 5, 65, 0, 0, 4123, 4125, 3, 304, 152, 0, 4124,
		4126, 3, 350, 175, 0, 4125, 4124, 1, 0, 0, 0, 4126, 4127, 1, 0, 0, 0, 4127,
		4125, 1, 0, 0, 0, 4127, 4128, 1, 0, 0, 0, 4128, 4131, 1, 0, 0, 0, 4129,
		4130, 5, 155, 0, 0, 4130, 4132, 3, 304, 152, 0, 4131, 4129, 1, 0, 0, 0,
		4131, 4132, 1, 0, 0, 0, 4132, 4133, 1, 0, 0, 0, 4133, 4134, 5, 159, 0,
		0, 4134, 4229, 1, 0, 0, 0, 4135, 4136, 5, 66, 0, 0, 4136, 4137, 5, 2, 0,
		0, 4137, 4138, 3, 304, 152, 0, 4138, 4139, 5, 30, 0, 0, 4139, 4140, 3,
		324, 162, 0, 4140, 4141, 5, 3, 0, 0, 4141, 4229, 1, 0, 0, 0, 4142, 4229,
		3, 344, 172, 0, 4143, 4229, 3, 352, 176, 0, 4144, 4148, 5, 510, 0, 0, 4145,
		4147, 3, 322, 161, 0, 4146, 4145, 1, 0, 0, 0, 4147, 4150, 1, 0, 0, 0, 4148,
		4146, 1, 0, 0, 0, 4148, 4149, 1, 0, 0, 0, 4149, 4229, 1, 0, 0, 0, 4150,
		4148, 1, 0, 0, 0, 4151, 4152, 3, 340, 170, 0, 4152, 4153, 5, 5, 0, 0, 4153,
		4157, 5, 510, 0, 0, 4154, 4156, 3, 322, 161, 0, 4155, 4154, 1, 0, 0, 0,
		4156, 4159, 1, 0, 0, 0, 4157, 4155, 1, 0, 0, 0, 4157, 4158, 1, 0, 0, 0,
		4158, 4229, 1, 0, 0, 0, 4159, 4157, 1, 0, 0, 0, 4160, 4161, 5, 70, 0, 0,
		4161, 4162, 5, 2, 0, 0, 4162, 4167, 3, 304, 152, 0, 4163, 4164, 5, 4, 0,
		0, 4164, 4166, 3, 304, 152, 0, 4165, 4163, 1, 0, 0, 0, 4166, 4169, 1, 0,
		0, 0, 4167, 4165, 1, 0, 0, 0, 4167, 4168, 1, 0, 0, 0, 4168, 4172, 1, 0,
		0, 0, 4169, 4167, 1, 0, 0, 0, 4170, 4171, 5, 478, 0, 0, 4171, 4173, 3,
		122, 61, 0, 4172, 4170, 1, 0, 0, 0, 4172, 4173, 1, 0, 0, 0, 4173, 4174,
		1, 0, 0, 0, 4174, 4175, 5, 3, 0, 0, 4175, 4229, 1, 0, 0, 0, 4176, 4177,
		5, 95, 0, 0, 4177, 4178, 5, 2, 0, 0, 4178, 4179, 3, 304, 152, 0, 4179,
		4180, 5, 478, 0, 0, 4180, 4181, 3, 122, 61, 0, 4181, 4182, 5, 3, 0, 0,
		4182, 4229, 1, 0, 0, 0, 4183, 4184, 5, 95, 0, 0, 4184, 4185, 5, 2, 0, 0,
		4185, 4186, 3, 304, 152, 0, 4186, 4187, 5, 4, 0, 0, 4187, 4188, 3, 324,
		162, 0, 4188, 4189, 5, 3, 0, 0, 4189, 4229, 1, 0, 0, 0, 4190, 4229, 3,
		326, 163, 0, 4191, 4192, 5, 2, 0, 0, 4192, 4193, 3, 164, 82, 0, 4193, 4194,
		5, 3, 0, 0, 4194, 4229, 1, 0, 0, 0, 4195, 4196, 5, 525, 0, 0, 4196, 4229,
		3, 122, 61, 0, 4197, 4200, 5, 526, 0, 0, 4198, 4199, 7, 48, 0, 0, 4199,
		4201, 5, 5, 0, 0, 4200, 4198, 1, 0, 0, 0, 4200, 4201, 1, 0, 0, 0, 4201,
		4202, 1, 0, 0, 0, 4202, 4229, 3, 378, 189, 0, 4203, 4205, 5, 45, 0, 0,
		4204, 4203, 1, 0, 0, 0, 4204, 4205, 1, 0, 0, 0, 4205, 4206, 1, 0, 0, 0,
		4206, 4229, 3, 378, 189, 0, 4207, 4208, 5, 2, 0, 0, 4208, 4209, 3, 304,
		152, 0, 4209, 4210, 5, 3, 0, 0, 4210, 4229, 1, 0, 0, 0, 4211, 4215, 5,
		250, 0, 0, 4212, 4213, 3, 378, 189, 0, 4213, 4214, 5, 5, 0, 0, 4214, 4216,
		1, 0, 0, 0, 4215, 4212, 1, 0, 0, 0, 4215, 4216, 1, 0, 0, 0, 4216, 4217,
		1, 0, 0, 0, 4217, 4229, 3, 378, 189, 0, 4218, 4219, 5, 176, 0, 0, 4219,
		4220, 5, 2, 0, 0, 4220, 4221, 3, 378, 189, 0, 4221, 4223, 5, 193, 0, 0,
		4222, 4224, 7, 49, 0, 0, 4223, 4222, 1, 0, 0, 0, 4223, 4224, 1, 0, 0, 0,
		4224, 4225, 1, 0, 0, 0, 4225, 4226, 3, 316, 158, 0, 4226, 4227, 5, 3, 0,
		0, 4227, 4229, 1, 0, 0, 0, 4228, 4018, 1, 0, 0, 0, 4228, 4028, 1, 0, 0,
		0, 4228, 4037, 1, 0, 0, 0, 4228, 4050, 1, 0, 0, 0, 4228, 4063, 1, 0, 0,
		0, 4228, 4076, 1, 0, 0, 0, 4228, 4089, 1, 0, 0, 0, 4228, 4104, 1, 0, 0,
		0, 4228, 4105, 1, 0, 0, 0, 4228, 4106, 1, 0, 0, 0, 4228, 4107, 1, 0, 0,
		0, 4228, 4108, 1, 0, 0, 0, 4228, 4109, 1, 0, 0, 0, 4228, 4110, 1, 0, 0,
		0, 4228, 4122, 1, 0, 0, 0, 4228, 4135, 1, 0, 0, 0, 4228, 4142, 1, 0, 0,
		0, 4228, 4143, 1, 0, 0, 0, 4228, 4144, 1, 0, 0, 0, 4228, 4151, 1, 0, 0,
		0, 4228, 4160, 1, 0, 0, 0, 4228, 4176, 1, 0, 0, 0, 4228, 4183, 1, 0, 0,
		0, 4228, 4190, 1, 0, 0, 0, 4228, 4191, 1, 0, 0, 0, 4228, 4195, 1, 0, 0,
		0, 4228, 4197, 1, 0, 0, 0, 4228, 4204, 1, 0, 0, 0, 4228, 4207, 1, 0, 0,
		0, 4228, 4211, 1, 0, 0, 0, 4228, 4218, 1, 0, 0, 0, 4229, 4256, 1, 0, 0,
		0, 4230, 4231, 10, 11, 0, 0, 4231, 4232, 5, 7, 0, 0, 4232, 4233, 3, 316,
		158, 0, 4233, 4234, 5, 8, 0, 0, 4234, 4255, 1, 0, 0, 0, 4235, 4236, 10,
		10, 0, 0, 4236, 4237, 5, 7, 0, 0, 4237, 4238, 3, 316, 158, 0, 4238, 4240,
		5, 520, 0, 0, 4239, 4241, 3, 316, 158, 0, 4240, 4239, 1, 0, 0, 0, 4240,
		4241, 1, 0, 0, 0, 4241, 4242, 1, 0, 0, 0, 4242, 4243, 5, 8, 0, 0, 4243,
		4255, 1, 0, 0, 0, 4244, 4245, 10, 5, 0, 0, 4245, 4246, 5, 5, 0, 0, 4246,
		4255, 3, 378, 189, 0, 4247, 4248, 10, 1, 0, 0, 4248, 4252, 5, 76, 0, 0,
		4249, 4253, 3, 378, 189, 0, 4250, 4253, 5, 527, 0, 0, 4251, 4253, 5, 133,
		0, 0, 4252, 4249, 1, 0, 0, 0, 4252, 4250, 1, 0, 0, 0, 4252, 4251, 1, 0,
		0, 0, 4253, 4255, 1, 0, 0, 0, 4254, 4230, 1, 0, 0, 0, 4254, 4235, 1, 0,
		0, 0, 4254, 4244, 1, 0, 0, 0, 4254, 4247, 1, 0, 0, 0, 4255, 4258, 1, 0,
		0, 0, 4256, 4254, 1, 0, 0, 0, 4256, 4257, 1, 0, 0, 0, 4257, 321, 1, 0,
		0, 0, 4258, 4256, 1, 0, 0, 0, 4259, 4260, 5, 167, 0, 0, 4260, 4261, 5,
		2, 0, 0, 4261, 4262, 3, 302, 151, 0, 4262, 4263, 5, 3, 0, 0, 4263, 4270,
		1, 0, 0, 0, 4264, 4265, 5, 373, 0, 0, 4265, 4266, 5, 2, 0, 0, 4266, 4267,
		3, 302, 151, 0, 4267, 4268, 5, 3, 0, 0, 4268, 4270, 1, 0, 0, 0, 4269, 4259,
		1, 0, 0, 0, 4269, 4264, 1, 0, 0, 0, 4270, 323, 1, 0, 0, 0, 4271, 4277,
		3, 358, 179, 0, 4272, 4274, 7, 50, 0, 0, 4273, 4275, 7, 51, 0, 0, 4274,
		4273, 1, 0, 0, 0, 4274, 4275, 1, 0, 0, 0, 4275, 4277, 1, 0, 0, 0, 4276,
		4271, 1, 0, 0, 0, 4276, 4272, 1, 0, 0, 0, 4277, 325, 1, 0, 0, 0, 4278,
		4279, 3, 328, 164, 0, 4279, 4303, 5, 2, 0, 0, 4280, 4282, 7, 27, 0, 0,
		4281, 4280, 1, 0, 0, 0, 4281, 4282, 1, 0, 0, 0, 4282, 4283, 1, 0, 0, 0,
		4283, 4288, 3, 304, 152, 0, 4284, 4285, 5, 4, 0, 0, 4285, 4287, 3, 304,
		152, 0, 4286, 4284, 1, 0, 0, 0, 4287, 4290, 1, 0, 0, 0, 4288, 4286, 1,
		0, 0, 0, 4288, 4289, 1, 0, 0, 0, 4289, 4301, 1, 0, 0, 0, 4290, 4288, 1,
		0, 0, 0, 4291, 4292, 5, 317, 0, 0, 4292, 4293, 5, 60, 0, 0, 4293, 4298,
		3, 228, 114, 0, 4294, 4295, 5, 4, 0, 0, 4295, 4297, 3, 228, 114, 0, 4296,
		4294, 1, 0, 0, 0, 4297, 4300, 1, 0, 0, 0, 4298, 4296, 1, 0, 0, 0, 4298,
		4299, 1, 0, 0, 0, 4299, 4302, 1, 0, 0, 0, 4300, 4298, 1, 0, 0, 0, 4301,
		4291, 1, 0, 0, 0, 4301, 4302, 1, 0, 0, 0, 4302, 4304, 1, 0, 0, 0, 4303,
		4281, 1, 0, 0, 0, 4303, 4304, 1, 0, 0, 0, 4304, 4305, 1, 0, 0, 0, 4305,
		4308, 5, 3, 0, 0, 4306, 4307, 5, 320, 0, 0, 4307, 4309, 3, 332, 166, 0,
		4308, 4306, 1, 0, 0, 0, 4308, 4309, 1, 0, 0, 0, 4309, 327, 1, 0, 0, 0,
		4310, 4311, 3, 378, 189, 0, 4311, 4312, 5, 5, 0, 0, 4312, 4314, 1, 0, 0,
		0, 4313, 4310, 1, 0, 0, 0, 4313, 4314, 1, 0, 0, 0, 4314, 4315, 1, 0, 0,
		0, 4315, 4316, 3, 330, 165, 0, 4316, 329, 1, 0, 0, 0, 4317, 4333, 3, 378,
		189, 0, 4318, 4333, 5, 14, 0, 0, 4319, 4333, 5, 91, 0, 0, 4320, 4333, 5,
		105, 0, 0, 4321, 4333, 5, 109, 0, 0, 4322, 4333, 5, 111, 0, 0, 4323, 4333,
		5, 220, 0, 0, 4324, 4333, 5, 259, 0, 0, 4325, 4333, 5, 262, 0, 0, 4326,
		4333, 5, 326, 0, 0, 4327, 4333, 5, 368, 0, 0, 4328, 4333, 5, 386, 0, 0,
		4329, 4333, 5, 399, 0, 0, 4330, 4333, 5, 460, 0, 0, 4331, 4333, 5, 477,
		0, 0, 4332, 4317, 1, 0, 0, 0, 4332, 4318, 1, 0, 0, 0, 4332, 4319, 1, 0,
		0, 0, 4332, 4320, 1, 0, 0, 0, 4332, 4321, 1, 0, 0, 0, 4332, 4322, 1, 0,
		0, 0, 4332, 4323, 1, 0, 0, 0, 4332, 4324, 1, 0, 0, 0, 4332, 4325, 1, 0,
		0, 0, 4332, 4326, 1, 0, 0, 0, 4332, 4327, 1, 0, 0, 0, 4332, 4328, 1, 0,
		0, 0, 4332, 4329, 1, 0, 0, 0, 4332, 4330, 1, 0, 0, 0, 4332, 4331, 1, 0,
		0, 0, 4333, 331, 1, 0, 0, 0, 4334, 4336, 5, 2, 0, 0, 4335, 4337, 3, 232,
		116, 0, 4336, 4335, 1, 0, 0, 0, 4336, 4337, 1, 0, 0, 0, 4337, 4339, 1,
		0, 0, 0, 4338, 4340, 3, 226, 113, 0, 4339, 4338, 1, 0, 0, 0, 4339, 4340,
		1, 0, 0, 0, 4340, 4342, 1, 0, 0, 0, 4341, 4343, 3, 334, 167, 0, 4342, 4341,
		1, 0, 0, 0, 4342, 4343, 1, 0, 0, 0, 4343, 4344, 1, 0, 0, 0, 4344, 4345,
		5, 3, 0, 0, 4345, 333, 1, 0, 0, 0, 4346, 4347, 3, 336, 168, 0, 4347, 4348,
		3, 338, 169, 0, 4348, 4356, 1, 0, 0, 0, 4349, 4350, 3, 336, 168, 0, 4350,
		4351, 5, 42, 0, 0, 4351, 4352, 3, 338, 169, 0, 4352, 4353, 5, 25, 0, 0,
		4353, 4354, 3, 338, 169, 0, 4354, 4356, 1, 0, 0, 0, 4355, 4346, 1, 0, 0,
		0, 4355, 4349, 1, 0, 0, 0, 4356, 335, 1, 0, 0, 0, 4357, 4358, 7, 52, 0,
		0, 4358, 337, 1, 0, 0, 0, 4359, 4360, 5, 466, 0, 0, 4360, 4367, 7, 53,
		0, 0, 4361, 4362, 5, 104, 0, 0, 4362, 4367, 5, 393, 0, 0, 4363, 4364, 3,
		304, 152, 0, 4364, 4365, 7, 53, 0, 0, 4365, 4367, 1, 0, 0, 0, 4366, 4359,
		1, 0, 0, 0, 4366, 4361, 1, 0, 0, 0, 4366, 4363, 1, 0, 0, 0, 4367, 339,
		1, 0, 0, 0, 4368, 4373, 3, 378, 189, 0, 4369, 4370, 5, 5, 0, 0, 4370, 4372,
		3, 378, 189, 0, 4371, 4369, 1, 0, 0, 0, 4372, 4375, 1, 0, 0, 0, 4373, 4371,
		1, 0, 0, 0, 4373, 4374, 1, 0, 0, 0, 4374, 341, 1, 0, 0, 0, 4375, 4373,
		1, 0, 0, 0, 4376, 4378, 5, 445, 0, 0, 4377, 4376, 1, 0, 0, 0, 4377, 4378,
		1, 0, 0, 0, 4378, 4379, 1, 0, 0, 0, 4379, 4382, 5, 324, 0, 0, 4380, 4383,
		3, 378, 189, 0, 4381, 4383, 3, 238, 119, 0, 4382, 4380, 1, 0, 0, 0, 4382,
		4381, 1, 0, 0, 0, 4383, 4390, 1, 0, 0, 0, 4384, 4386, 5, 445, 0, 0, 4385,
		4384, 1, 0, 0, 0, 4385, 4386, 1, 0, 0, 0, 4386, 4387, 1, 0, 0, 0, 4387,
		4388, 5, 325, 0, 0, 4388, 4390, 3, 238, 119, 0, 4389, 4377, 1, 0, 0, 0,
		4389, 4385, 1, 0, 0, 0, 4390, 343, 1, 0, 0, 0, 4391, 4443, 5, 307, 0, 0,
		4392, 4393, 7, 54, 0, 0, 4393, 4443, 5, 527, 0, 0, 4394, 4443, 3, 384,
		192, 0, 4395, 4443, 3, 348, 174, 0, 4396, 4398, 5, 45, 0, 0, 4397, 4396,
		1, 0, 0, 0, 4397, 4398, 1, 0, 0, 0, 4398, 4399, 1, 0, 0, 0, 4399, 4443,
		5, 527, 0, 0, 4400, 4402, 5, 7, 0, 0, 4401, 4403, 3, 344, 172, 0, 4402,
		4401, 1, 0, 0, 0, 4402, 4403, 1, 0, 0, 0, 4403, 4408, 1, 0, 0, 0, 4404,
		4405, 5, 4, 0, 0, 4405, 4407, 3, 344, 172, 0, 4406, 4404, 1, 0, 0, 0, 4407,
		4410, 1, 0, 0, 0, 4408, 4406, 1, 0, 0, 0, 4408, 4409, 1, 0, 0, 0, 4409,
		4411, 1, 0, 0, 0, 4410, 4408, 1, 0, 0, 0, 4411, 4443, 5, 8, 0, 0, 4412,
		4417, 5, 9, 0, 0, 4413, 4414, 3, 344, 172, 0, 4414, 4415, 5, 520, 0, 0,
		4415, 4416, 3, 344, 172, 0, 4416, 4418, 1, 0, 0, 0, 4417, 4413, 1, 0, 0,
		0, 4417, 4418, 1, 0, 0, 0, 4418, 4426, 1, 0, 0, 0, 4419, 4420, 5, 4, 0,
		0, 4420, 4421, 3, 344, 172, 0, 4421, 4422, 5, 520, 0, 0, 4422, 4423, 3,
		344, 172, 0, 4423, 4425, 1, 0, 0, 0, 4424, 4419, 1, 0, 0, 0, 4425, 4428,
		1, 0, 0, 0, 4426, 4424, 1, 0, 0, 0, 4426, 4427, 1, 0, 0, 0, 4427, 4429,
		1, 0, 0, 0, 4428, 4426, 1, 0, 0, 0, 4429, 4443, 5, 10, 0, 0, 4430, 4431,
		5, 9, 0, 0, 4431, 4436, 3, 344, 172, 0, 4432, 4433, 5, 4, 0, 0, 4433, 4435,
		3, 344, 172, 0, 4434, 4432, 1, 0, 0, 0, 4435, 4438, 1, 0, 0, 0, 4436, 4434,
		1, 0, 0, 0, 4436, 4437, 1, 0, 0, 0, 4437, 4439, 1, 0, 0, 0, 4438, 4436,
		1, 0, 0, 0, 4439, 4440, 5, 10, 0, 0, 4440, 4443, 1, 0, 0, 0, 4441, 4443,
		5, 338, 0, 0, 4442, 4391, 1, 0, 0, 0, 4442, 4392, 1, 0, 0, 0, 4442, 4394,
		1, 0, 0, 0, 4442, 4395, 1, 0, 0, 0, 4442, 4397, 1, 0, 0, 0, 4442, 4400,
		1, 0, 0, 0, 4442, 4412, 1, 0, 0, 0, 4442, 4430, 1, 0, 0, 0, 4442, 4441,
		1, 0, 0, 0, 4443, 345, 1, 0, 0, 0, 4444, 4445, 7, 55, 0, 0, 4445, 347,
		1, 0, 0, 0, 4446, 4447, 7, 37, 0, 0, 4447, 349, 1, 0, 0, 0, 4448, 4449,
		5, 492, 0, 0, 4449, 4450, 3, 304, 152, 0, 4450, 4451, 5, 449, 0, 0, 4451,
		4452, 3, 304, 152, 0, 4452, 351, 1, 0, 0, 0, 4453, 4454, 5, 235, 0, 0,
		4454, 4455, 3, 304, 152, 0, 4455, 4456, 3, 354, 177, 0, 4456, 353, 1, 0,
		0, 0, 4457, 4458, 7, 42, 0, 0, 4458, 355, 1, 0, 0, 0, 4459, 4464, 3, 358,
		179, 0, 4460, 4462, 5, 306, 0, 0, 4461, 4460, 1, 0, 0, 0, 4461, 4462, 1,
		0, 0, 0, 4462, 4463, 1, 0, 0, 0, 4463, 4465, 5, 307, 0, 0, 4464, 4461,
		1, 0, 0, 0, 4464, 4465, 1, 0, 0, 0, 4465, 357, 1, 0, 0, 0, 4466, 4467,
		5, 28, 0, 0, 4467, 4468, 5, 504, 0, 0, 4468, 4469, 3, 358, 179, 0, 4469,
		4470, 5, 506, 0, 0, 4470, 4512, 1, 0, 0, 0, 4471, 4472, 5, 276, 0, 0, 4472,
		4473, 5, 504, 0, 0, 4473, 4474, 3, 358, 179, 0, 4474, 4475, 5, 4, 0, 0,
		4475, 4476, 3, 358, 179, 0, 4476, 4477, 5, 506, 0, 0, 4477, 4512, 1, 0,
		0, 0, 4478, 4479, 5, 431, 0, 0, 4479, 4480, 5, 504, 0, 0, 4480, 4481, 3,
		362, 181, 0, 4481, 4482, 5, 506, 0, 0, 4482, 4512, 1, 0, 0, 0, 4483, 4484,
		5, 18, 0, 0, 4484, 4485, 5, 504, 0, 0, 4485, 4486, 3, 330, 165, 0, 4486,
		4487, 5, 2, 0, 0, 4487, 4492, 3, 356, 178, 0, 4488, 4489, 5, 4, 0, 0, 4489,
		4491, 3, 356, 178, 0, 4490, 4488, 1, 0, 0, 0, 4491, 4494, 1, 0, 0, 0, 4492,
		4490, 1, 0, 0, 0, 4492, 4493, 1, 0, 0, 0, 4493, 4495, 1, 0, 0, 0, 4494,
		4492, 1, 0, 0, 0, 4495, 4496, 5, 3, 0, 0, 4496, 4497, 5, 506, 0, 0, 4497,
		4512, 1, 0, 0, 0, 4498, 4509, 3, 360, 180, 0, 4499, 4500, 5, 2, 0, 0, 4500,
		4505, 7, 56, 0, 0, 4501, 4502, 5, 4, 0, 0, 4502, 4504, 5, 532, 0, 0, 4503,
		4501, 1, 0, 0, 0, 4504, 4507, 1, 0, 0, 0, 4505, 4503, 1, 0, 0, 0, 4505,
		4506, 1, 0, 0, 0, 4506, 4508, 1, 0, 0, 0, 4507, 4505, 1, 0, 0, 0, 4508,
		4510, 5, 3, 0, 0, 4509, 4499, 1, 0, 0, 0, 4509, 4510, 1, 0, 0, 0, 4510,
		4512, 1, 0, 0, 0, 4511, 4466, 1, 0, 0, 0, 4511, 4471, 1, 0, 0, 0, 4511,
		4478, 1, 0, 0, 0, 4511, 4483, 1, 0, 0, 0, 4511, 4498, 1, 0, 0, 0, 4512,
		359, 1, 0, 0, 0, 4513, 4546, 5, 454, 0, 0, 4514, 4546, 5, 414, 0, 0, 4515,
		4546, 7, 51, 0, 0, 4516, 4546, 5, 43, 0, 0, 4517, 4546, 5, 254, 0, 0, 4518,
		4546, 5, 53, 0, 0, 4519, 4546, 5, 185, 0, 0, 4520, 4546, 5, 149, 0, 0,
		4521, 4546, 5, 113, 0, 0, 4522, 4546, 5, 121, 0, 0, 4523, 4546, 5, 450,
		0, 0, 4524, 4546, 5, 123, 0, 0, 4525, 4546, 5, 122, 0, 0, 4526, 4546, 5,
		125, 0, 0, 4527, 4546, 5, 124, 0, 0, 4528, 4546, 5, 48, 0, 0, 4529, 4546,
		5, 354, 0, 0, 4530, 4546, 5, 213, 0, 0, 4531, 4546, 5, 18, 0, 0, 4532,
		4546, 5, 430, 0, 0, 4533, 4546, 5, 248, 0, 0, 4534, 4546, 5, 249, 0, 0,
		4535, 4546, 5, 447, 0, 0, 4536, 4546, 5, 481, 0, 0, 4537, 4546, 5, 70,
		0, 0, 4538, 4546, 5, 129, 0, 0, 4539, 4546, 5, 130, 0, 0, 4540, 4546, 5,
		131, 0, 0, 4541, 4546, 5, 238, 0, 0, 4542, 4546, 5, 239, 0, 0, 4543, 4546,
		5, 484, 0, 0, 4544, 4546, 5, 21, 0, 0, 4545, 4513, 1, 0, 0, 0, 4545, 4514,
		1, 0, 0, 0, 4545, 4515, 1, 0, 0, 0, 4545, 4516, 1, 0, 0, 0, 4545, 4517,
		1, 0, 0, 0, 4545, 4518, 1, 0, 0, 0, 4545, 4519, 1, 0, 0, 0, 4545, 4520,
		1, 0, 0, 0, 4545, 4521, 1, 0, 0, 0, 4545, 4522, 1, 0, 0, 0, 4545, 4523,
		1, 0, 0, 0, 4545, 4524, 1, 0, 0, 0, 4545, 4525, 1, 0, 0, 0, 4545, 4526,
		1, 0, 0, 0, 4545, 4527, 1, 0, 0, 0, 4545, 4528, 1, 0, 0, 0, 4545, 4529,
		1, 0, 0, 0, 4545, 4530, 1, 0, 0, 0, 4545, 4531, 1, 0, 0, 0, 4545, 4532,
		1, 0, 0, 0, 4545, 4533, 1, 0, 0, 0, 4545, 4534, 1, 0, 0, 0, 4545, 4535,
		1, 0, 0, 0, 4545, 4536, 1, 0, 0, 0, 4545, 4537, 1, 0, 0, 0, 4545, 4538,
		1, 0, 0, 0, 4545, 4539, 1, 0, 0, 0, 4545, 4540, 1, 0, 0, 0, 4545, 4541,
		1, 0, 0, 0, 4545, 4542, 1, 0, 0, 0, 4545, 4543, 1, 0, 0, 0, 4545, 4544,
		1, 0, 0, 0, 4546, 361, 1, 0, 0, 0, 4547, 4552, 3, 364, 182, 0, 4548, 4549,
		5, 4, 0, 0, 4549, 4551, 3, 364, 182, 0, 4550, 4548, 1, 0, 0, 0, 4551, 4554,
		1, 0, 0, 0, 4552, 4550, 1, 0, 0, 0, 4552, 4553, 1, 0, 0, 0, 4553, 363,
		1, 0, 0, 0, 4554, 4552, 1, 0, 0, 0, 4555, 4556, 3, 378, 189, 0, 4556, 4557,
		5, 520, 0, 0, 4557, 4559, 3, 358, 179, 0, 4558, 4560, 3, 366, 183, 0, 4559,
		4558, 1, 0, 0, 0, 4559, 4560, 1, 0, 0, 0, 4560, 365, 1, 0, 0, 0, 4561,
		4562, 5, 82, 0, 0, 4562, 4563, 5, 527, 0, 0, 4563, 367, 1, 0, 0, 0, 4564,
		4565, 5, 440, 0, 0, 4565, 4567, 5, 2, 0, 0, 4566, 4568, 3, 370, 185, 0,
		4567, 4566, 1, 0, 0, 0, 4567, 4568, 1, 0, 0, 0, 4568, 4569, 1, 0, 0, 0,
		4569, 4572, 5, 3, 0, 0, 4570, 4571, 5, 372, 0, 0, 4571, 4573, 5, 532, 0,
		0, 4572, 4570, 1, 0, 0, 0, 4572, 4573, 1, 0, 0, 0, 4573, 369, 1, 0, 0,
		0, 4574, 4575, 5, 532, 0, 0, 4575, 4579, 5, 333, 0, 0, 4576, 4577, 5, 532,
		0, 0, 4577, 4579, 5, 394, 0, 0, 4578, 4574, 1, 0, 0, 0, 4578, 4576, 1,
		0, 0, 0, 4579, 371, 1, 0, 0, 0, 4580, 4581, 5, 188, 0, 0, 4581, 4582, 5,
		487, 0, 0, 4582, 4583, 5, 30, 0, 0, 4583, 4584, 5, 310, 0, 0, 4584, 4591,
		5, 532, 0, 0, 4585, 4586, 5, 188, 0, 0, 4586, 4587, 5, 450, 0, 0, 4587,
		4588, 5, 30, 0, 0, 4588, 4589, 5, 310, 0, 0, 4589, 4591, 5, 527, 0, 0,
		4590, 4580, 1, 0, 0, 0, 4590, 4585, 1, 0, 0, 0, 4591, 373, 1, 0, 0, 0,
		4592, 4593, 3, 378, 189, 0, 4593, 4594, 3, 376, 188, 0, 4594, 375, 1, 0,
		0, 0, 4595, 4596, 5, 509, 0, 0, 4596, 4598, 3, 378, 189, 0, 4597, 4595,
		1, 0, 0, 0, 4598, 4599, 1, 0, 0, 0, 4599, 4597, 1, 0, 0, 0, 4599, 4600,
		1, 0, 0, 0, 4600, 4603, 1, 0, 0, 0, 4601, 4603, 1, 0, 0, 0, 4602, 4597,
		1, 0, 0, 0, 4602, 4601, 1, 0, 0, 0, 4603, 377, 1, 0, 0, 0, 4604, 4605,
		3, 380, 190, 0, 4605, 379, 1, 0, 0, 0, 4606, 4610, 5, 536, 0, 0, 4607,
		4610, 3, 382, 191, 0, 4608, 4610, 3, 386, 193, 0, 4609, 4606, 1, 0, 0,
		0, 4609, 4607, 1, 0, 0, 0, 4609, 4608, 1, 0, 0, 0, 4610, 381, 1, 0, 0,
		0, 4611, 4612, 5, 537, 0, 0, 4612, 383, 1, 0, 0, 0, 4613, 4615, 5, 509,
		0, 0, 4614, 4613, 1, 0, 0, 0, 4614, 4615, 1, 0, 0, 0, 4615, 4616, 1, 0,
		0, 0, 4616, 4622, 5, 532, 0, 0, 4617, 4619, 5, 509, 0, 0, 4618, 4617, 1,
		0, 0, 0, 4618, 4619, 1, 0, 0, 0, 4619, 4620, 1, 0, 0, 0, 4620, 4622, 7,
		57, 0, 0, 4621, 4614, 1, 0, 0, 0, 4621, 4618, 1, 0, 0, 0, 4622, 385, 1,
		0, 0, 0, 4623, 4624, 7, 58, 0, 0, 4624, 387, 1, 0, 0, 0, 634, 391, 395,
		400, 405, 411, 419, 423, 428, 442, 445, 453, 456, 464, 471, 478, 487, 494,
		501, 505, 507, 510, 514, 523, 538, 546, 553, 556, 560, 563, 565, 568, 572,
		576, 584, 591, 595, 597, 600, 612, 626, 634, 641, 648, 653, 679, 700, 703,
		706, 712, 719, 722, 727, 730, 736, 740, 743, 751, 754, 757, 760, 766, 771,
		774, 785, 790, 797, 800, 809, 812, 819, 822, 827, 830, 832, 836, 842, 846,
		852, 855, 859, 864, 872, 874, 878, 881, 888, 893, 895, 897, 904, 907, 911,
		915, 922, 929, 933, 940, 946, 954, 956, 964, 975, 982, 991, 1002, 1020,
		1060, 1067, 1074, 1077, 1083, 1095, 1108, 1120, 1129, 1141, 1148, 1156,
		1158, 1162, 1165, 1168, 1171, 1175, 1178, 1184, 1190, 1192, 1196, 1200,
		1203, 1206, 1209, 1213, 1217, 1220, 1223, 1226, 1228, 1238, 1250, 1257,
		1265, 1278, 1290, 1297, 1305, 1310, 1314, 1317, 1324, 1335, 1348, 1361,
		1375, 1418, 1434, 1441, 1449, 1457, 1463, 1483, 1489, 1495, 1497, 1506,
		1510, 1519, 1529, 1552, 1563, 1575, 1584, 1597, 1601, 1608, 1611, 1614,
		1620, 1623, 1626, 1636, 1641, 1644, 1650, 1653, 1659, 1662, 1665, 1671,
		1674, 1678, 1683, 1689, 1696, 1701, 1703, 1705, 1708, 1712, 1717, 1721,
		1726, 1730, 1735, 1742, 1751, 1755, 1758, 1761, 1768, 1793, 1801, 1810,
		1815, 1817, 1819, 1835, 1839, 1849, 1852, 1854, 1859, 1871, 1875, 1881,
		1886, 1891, 1896, 1904, 1908, 1914, 1921, 1931, 1939, 1946, 1956, 1964,
		1972, 1979, 1986, 1994, 2003, 2005, 2012, 2019, 2022, 2033, 2040, 2051,
		2057, 2060, 2073, 2080, 2084, 2091, 2097, 2101, 2104, 2108, 2111, 2117,
		2122, 2129, 2132, 2136, 2143, 2148, 2155, 2166, 2173, 2178, 2183, 2195,
		2200, 2207, 2215, 2223, 2226, 2230, 2234, 2240, 2244, 2252, 2256, 2264,
		2268, 2276, 2284, 2291, 2294, 2301, 2321, 2328, 2332, 2340, 2344, 2352,
		2359, 2363, 2365, 2372, 2380, 2383, 2390, 2397, 2399, 2406, 2413, 2417,
		2423, 2428, 2430, 2438, 2440, 2447, 2449, 2453, 2459, 2461, 2464, 2471,
		2476, 2481, 2486, 2490, 2504, 2509, 2522, 2524, 2531, 2539, 2543, 2548,
		2553, 2558, 2566, 2575, 2578, 2583, 2585, 2591, 2598, 2612, 2616, 2621,
		2627, 2633, 2640, 2643, 2649, 2655, 2659, 2665, 2672, 2684, 2686, 2700,
		2703, 2708, 2716, 2719, 2724, 2729, 2739, 2746, 2749, 2752, 2762, 2771,
		2777, 2783, 2788, 2791, 2794, 2797, 2800, 2803, 2806, 2809, 2812, 2815,
		2818, 2829, 2832, 2835, 2838, 2841, 2843, 2855, 2862, 2868, 2872, 2877,
		2884, 2889, 2898, 2900, 2906, 2909, 2913, 2916, 2919, 2952, 2987, 2989,
		2998, 3003, 3012, 3018, 3024, 3027, 3030, 3033, 3036, 3044, 3052, 3055,
		3058, 3069, 3075, 3078, 3080, 3091, 3095, 3098, 3101, 3104, 3107, 3118,
		3123, 3136, 3143, 3146, 3159, 3164, 3169, 3173, 3189, 3196, 3202, 3206,
		3216, 3224, 3235, 3240, 3253, 3256, 3266, 3269, 3280, 3290, 3293, 3301,
		3304, 3313, 3318, 3327, 3332, 3337, 3343, 3345, 3348, 3354, 3361, 3373,
		3376, 3386, 3390, 3393, 3402, 3407, 3411, 3423, 3432, 3436, 3441, 3445,
		3449, 3459, 3465, 3476, 3483, 3489, 3492, 3495, 3498, 3501, 3505, 3508,
		3513, 3523, 3529, 3538, 3553, 3562, 3566, 3569, 3573, 3575, 3582, 3590,
		3596, 3603, 3609, 3612, 3616, 3623, 3626, 3629, 3636, 3638, 3652, 3654,
		3656, 3665, 3667, 3671, 3678, 3685, 3691, 3698, 3702, 3709, 3716, 3722,
		3728, 3736, 3742, 3759, 3765, 3776, 3782, 3784, 3792, 3804, 3812, 3815,
		3826, 3837, 3842, 3845, 3852, 3857, 3869, 3875, 3897, 3899, 3913, 3915,
		3924, 3927, 3933, 3936, 3944, 3949, 3954, 3962, 3971, 3978, 3983, 3986,
		3999, 4011, 4013, 4046, 4059, 4072, 4085, 4100, 4114, 4118, 4127, 4131,
		4148, 4157, 4167, 4172, 4200, 4204, 4215, 4223, 4228, 4240, 4252, 4254,
		4256, 4269, 4274, 4276, 4281, 4288, 4298, 4301, 4303, 4308, 4313, 4332,
		4336, 4339, 4342, 4355, 4366, 4373, 4377, 4382, 4385, 4389, 4397, 4402,
		4408, 4417, 4426, 4436, 4442, 4461, 4464, 4492, 4505, 4509, 4511, 4545,
		4552, 4559, 4567, 4572, 4578, 4590, 4599, 4602, 4609, 4614, 4618, 4621,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// DorisParserInit initializes any static state used to implement DorisParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewDorisParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func DorisParserInit() {
	staticData := &DorisParserParserStaticData
	staticData.once.Do(dorisparserParserInit)
}

// NewDorisParser produces a new parser instance for the optional input antlr.TokenStream.
func NewDorisParser(input antlr.TokenStream) *DorisParser {
	DorisParserInit()
	this := new(DorisParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &DorisParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "DorisParser.g4"

	return this
}

// Note that '@members' cannot be changed now, but this should have been 'globals'
// If you are looking to have variables for each instance, use '@structmembers'

var doris_legacy_SQL_syntax = true

// DorisParser tokens.
const (
	DorisParserEOF                     = antlr.TokenEOF
	DorisParserSEMICOLON               = 1
	DorisParserLEFT_PAREN              = 2
	DorisParserRIGHT_PAREN             = 3
	DorisParserCOMMA                   = 4
	DorisParserDOT                     = 5
	DorisParserDOTDOTDOT               = 6
	DorisParserLEFT_BRACKET            = 7
	DorisParserRIGHT_BRACKET           = 8
	DorisParserLEFT_BRACE              = 9
	DorisParserRIGHT_BRACE             = 10
	DorisParserACCOUNT_LOCK            = 11
	DorisParserACCOUNT_UNLOCK          = 12
	DorisParserACTIONS                 = 13
	DorisParserADD                     = 14
	DorisParserADDDATE                 = 15
	DorisParserADMIN                   = 16
	DorisParserAFTER                   = 17
	DorisParserAGG_STATE               = 18
	DorisParserAGGREGATE               = 19
	DorisParserALIAS                   = 20
	DorisParserALL                     = 21
	DorisParserALTER                   = 22
	DorisParserANALYZE                 = 23
	DorisParserANALYZED                = 24
	DorisParserAND                     = 25
	DorisParserANTI                    = 26
	DorisParserAPPEND                  = 27
	DorisParserARRAY                   = 28
	DorisParserARRAY_RANGE             = 29
	DorisParserAS                      = 30
	DorisParserASC                     = 31
	DorisParserAT                      = 32
	DorisParserAUTHORS                 = 33
	DorisParserAUTO                    = 34
	DorisParserAUTO_INCREMENT          = 35
	DorisParserALWAYS                  = 36
	DorisParserBACKEND                 = 37
	DorisParserBACKENDS                = 38
	DorisParserBACKUP                  = 39
	DorisParserBEGIN                   = 40
	DorisParserBELONG                  = 41
	DorisParserBETWEEN                 = 42
	DorisParserBIGINT                  = 43
	DorisParserBIN                     = 44
	DorisParserBINARY                  = 45
	DorisParserBINLOG                  = 46
	DorisParserBITAND                  = 47
	DorisParserBITMAP                  = 48
	DorisParserBITMAP_UNION            = 49
	DorisParserBITOR                   = 50
	DorisParserBITXOR                  = 51
	DorisParserBLOB                    = 52
	DorisParserBOOLEAN                 = 53
	DorisParserBRIEF                   = 54
	DorisParserBROKER                  = 55
	DorisParserBUCKETS                 = 56
	DorisParserBUILD                   = 57
	DorisParserBUILTIN                 = 58
	DorisParserBULK                    = 59
	DorisParserBY                      = 60
	DorisParserCACHE                   = 61
	DorisParserCACHED                  = 62
	DorisParserCALL                    = 63
	DorisParserCANCEL                  = 64
	DorisParserCASE                    = 65
	DorisParserCAST                    = 66
	DorisParserCATALOG                 = 67
	DorisParserCATALOGS                = 68
	DorisParserCHAIN                   = 69
	DorisParserCHAR                    = 70
	DorisParserCHARSET                 = 71
	DorisParserCHECK                   = 72
	DorisParserCLEAN                   = 73
	DorisParserCLUSTER                 = 74
	DorisParserCLUSTERS                = 75
	DorisParserCOLLATE                 = 76
	DorisParserCOLLATION               = 77
	DorisParserCOLLECT                 = 78
	DorisParserCOLOCATE                = 79
	DorisParserCOLUMN                  = 80
	DorisParserCOLUMNS                 = 81
	DorisParserCOMMENT                 = 82
	DorisParserCOMMIT                  = 83
	DorisParserCOMMITTED               = 84
	DorisParserCOMPACT                 = 85
	DorisParserCOMPLETE                = 86
	DorisParserCOMPRESS_TYPE           = 87
	DorisParserCONDITIONS              = 88
	DorisParserCONFIG                  = 89
	DorisParserCONNECTION              = 90
	DorisParserCONNECTION_ID           = 91
	DorisParserCONSISTENT              = 92
	DorisParserCONSTRAINT              = 93
	DorisParserCONSTRAINTS             = 94
	DorisParserCONVERT                 = 95
	DorisParserCONVERT_LSC             = 96
	DorisParserCOPY                    = 97
	DorisParserCOUNT                   = 98
	DorisParserCREATE                  = 99
	DorisParserCREATION                = 100
	DorisParserCRON                    = 101
	DorisParserCROSS                   = 102
	DorisParserCUBE                    = 103
	DorisParserCURRENT                 = 104
	DorisParserCURRENT_CATALOG         = 105
	DorisParserCURRENT_DATE            = 106
	DorisParserCURRENT_TIME            = 107
	DorisParserCURRENT_TIMESTAMP       = 108
	DorisParserCURRENT_USER            = 109
	DorisParserDATA                    = 110
	DorisParserDATABASE                = 111
	DorisParserDATABASES               = 112
	DorisParserDATE                    = 113
	DorisParserDATE_ADD                = 114
	DorisParserDATE_CEIL               = 115
	DorisParserDATE_DIFF               = 116
	DorisParserDATE_FLOOR              = 117
	DorisParserDATE_SUB                = 118
	DorisParserDATEADD                 = 119
	DorisParserDATEDIFF                = 120
	DorisParserDATETIME                = 121
	DorisParserDATETIMEV2              = 122
	DorisParserDATEV2                  = 123
	DorisParserDATETIMEV1              = 124
	DorisParserDATEV1                  = 125
	DorisParserDAY                     = 126
	DorisParserDAYS_ADD                = 127
	DorisParserDAYS_SUB                = 128
	DorisParserDECIMAL                 = 129
	DorisParserDECIMALV2               = 130
	DorisParserDECIMALV3               = 131
	DorisParserDECOMMISSION            = 132
	DorisParserDEFAULT                 = 133
	DorisParserDEFERRED                = 134
	DorisParserDELETE                  = 135
	DorisParserDEMAND                  = 136
	DorisParserDESC                    = 137
	DorisParserDESCRIBE                = 138
	DorisParserDIAGNOSE                = 139
	DorisParserDISK                    = 140
	DorisParserDISTINCT                = 141
	DorisParserDISTINCTPC              = 142
	DorisParserDISTINCTPCSA            = 143
	DorisParserDISTRIBUTED             = 144
	DorisParserDISTRIBUTION            = 145
	DorisParserDIV                     = 146
	DorisParserDO                      = 147
	DorisParserDORIS_INTERNAL_TABLE_ID = 148
	DorisParserDOUBLE                  = 149
	DorisParserDROP                    = 150
	DorisParserDROPP                   = 151
	DorisParserDUAL                    = 152
	DorisParserDUPLICATE               = 153
	DorisParserDYNAMIC                 = 154
	DorisParserELSE                    = 155
	DorisParserENABLE                  = 156
	DorisParserENCRYPTKEY              = 157
	DorisParserENCRYPTKEYS             = 158
	DorisParserEND                     = 159
	DorisParserENDS                    = 160
	DorisParserENGINE                  = 161
	DorisParserENGINES                 = 162
	DorisParserENTER                   = 163
	DorisParserERRORS                  = 164
	DorisParserEVENTS                  = 165
	DorisParserEVERY                   = 166
	DorisParserEXCEPT                  = 167
	DorisParserEXCLUDE                 = 168
	DorisParserEXECUTE                 = 169
	DorisParserEXISTS                  = 170
	DorisParserEXPIRED                 = 171
	DorisParserEXPLAIN                 = 172
	DorisParserEXPORT                  = 173
	DorisParserEXTENDED                = 174
	DorisParserEXTERNAL                = 175
	DorisParserEXTRACT                 = 176
	DorisParserFAILED_LOGIN_ATTEMPTS   = 177
	DorisParserFALSE                   = 178
	DorisParserFAST                    = 179
	DorisParserFEATURE                 = 180
	DorisParserFIELDS                  = 181
	DorisParserFILE                    = 182
	DorisParserFILTER                  = 183
	DorisParserFIRST                   = 184
	DorisParserFLOAT                   = 185
	DorisParserFOLLOWER                = 186
	DorisParserFOLLOWING               = 187
	DorisParserFOR                     = 188
	DorisParserFOREIGN                 = 189
	DorisParserFORCE                   = 190
	DorisParserFORMAT                  = 191
	DorisParserFREE                    = 192
	DorisParserFROM                    = 193
	DorisParserFRONTEND                = 194
	DorisParserFRONTENDS               = 195
	DorisParserFULL                    = 196
	DorisParserFUNCTION                = 197
	DorisParserFUNCTIONS               = 198
	DorisParserGENERATED               = 199
	DorisParserGENERIC                 = 200
	DorisParserGLOBAL                  = 201
	DorisParserGRANT                   = 202
	DorisParserGRANTS                  = 203
	DorisParserGRAPH                   = 204
	DorisParserGROUP                   = 205
	DorisParserGROUPING                = 206
	DorisParserGROUPS                  = 207
	DorisParserHASH                    = 208
	DorisParserHAVING                  = 209
	DorisParserHDFS                    = 210
	DorisParserHELP                    = 211
	DorisParserHISTOGRAM               = 212
	DorisParserHLL                     = 213
	DorisParserHLL_UNION               = 214
	DorisParserHOSTNAME                = 215
	DorisParserHOTSPOT                 = 216
	DorisParserHOUR                    = 217
	DorisParserHUB                     = 218
	DorisParserIDENTIFIED              = 219
	DorisParserIF                      = 220
	DorisParserIGNORE                  = 221
	DorisParserIMMEDIATE               = 222
	DorisParserIN                      = 223
	DorisParserINCREMENTAL             = 224
	DorisParserINDEX                   = 225
	DorisParserINDEXES                 = 226
	DorisParserINFILE                  = 227
	DorisParserINNER                   = 228
	DorisParserINSERT                  = 229
	DorisParserINSTALL                 = 230
	DorisParserINT                     = 231
	DorisParserINTEGER                 = 232
	DorisParserINTERMEDIATE            = 233
	DorisParserINTERSECT               = 234
	DorisParserINTERVAL                = 235
	DorisParserINTO                    = 236
	DorisParserINVERTED                = 237
	DorisParserIPV4                    = 238
	DorisParserIPV6                    = 239
	DorisParserIS                      = 240
	DorisParserIS_NOT_NULL_PRED        = 241
	DorisParserIS_NULL_PRED            = 242
	DorisParserISNULL                  = 243
	DorisParserISOLATION               = 244
	DorisParserJOB                     = 245
	DorisParserJOBS                    = 246
	DorisParserJOIN                    = 247
	DorisParserJSON                    = 248
	DorisParserJSONB                   = 249
	DorisParserKEY                     = 250
	DorisParserKEYS                    = 251
	DorisParserKILL                    = 252
	DorisParserLABEL                   = 253
	DorisParserLARGEINT                = 254
	DorisParserLAST                    = 255
	DorisParserLATERAL                 = 256
	DorisParserLDAP                    = 257
	DorisParserLDAP_ADMIN_PASSWORD     = 258
	DorisParserLEFT                    = 259
	DorisParserLESS                    = 260
	DorisParserLEVEL                   = 261
	DorisParserLIKE                    = 262
	DorisParserLIMIT                   = 263
	DorisParserLINES                   = 264
	DorisParserLINK                    = 265
	DorisParserLIST                    = 266
	DorisParserLOAD                    = 267
	DorisParserLOCAL                   = 268
	DorisParserLOCALTIME               = 269
	DorisParserLOCALTIMESTAMP          = 270
	DorisParserLOCATION                = 271
	DorisParserLOCK                    = 272
	DorisParserLOGICAL                 = 273
	DorisParserLOW_PRIORITY            = 274
	DorisParserMANUAL                  = 275
	DorisParserMAP                     = 276
	DorisParserMATCH                   = 277
	DorisParserMATCH_ALL               = 278
	DorisParserMATCH_ANY               = 279
	DorisParserMATCH_PHRASE            = 280
	DorisParserMATCH_PHRASE_EDGE       = 281
	DorisParserMATCH_PHRASE_PREFIX     = 282
	DorisParserMATCH_REGEXP            = 283
	DorisParserMATERIALIZED            = 284
	DorisParserMAX                     = 285
	DorisParserMAXVALUE                = 286
	DorisParserMEMO                    = 287
	DorisParserMERGE                   = 288
	DorisParserMIGRATE                 = 289
	DorisParserMIGRATIONS              = 290
	DorisParserMIN                     = 291
	DorisParserMINUS                   = 292
	DorisParserMINUTE                  = 293
	DorisParserMODIFY                  = 294
	DorisParserMONTH                   = 295
	DorisParserMTMV                    = 296
	DorisParserNAME                    = 297
	DorisParserNAMES                   = 298
	DorisParserNATURAL                 = 299
	DorisParserNEGATIVE                = 300
	DorisParserNEVER                   = 301
	DorisParserNEXT                    = 302
	DorisParserNGRAM_BF                = 303
	DorisParserNO                      = 304
	DorisParserNON_NULLABLE            = 305
	DorisParserNOT                     = 306
	DorisParserNULL                    = 307
	DorisParserNULLS                   = 308
	DorisParserOBSERVER                = 309
	DorisParserOF                      = 310
	DorisParserOFFSET                  = 311
	DorisParserON                      = 312
	DorisParserONLY                    = 313
	DorisParserOPEN                    = 314
	DorisParserOPTIMIZED               = 315
	DorisParserOR                      = 316
	DorisParserORDER                   = 317
	DorisParserOUTER                   = 318
	DorisParserOUTFILE                 = 319
	DorisParserOVER                    = 320
	DorisParserOVERWRITE               = 321
	DorisParserPARAMETER               = 322
	DorisParserPARSED                  = 323
	DorisParserPARTITION               = 324
	DorisParserPARTITIONS              = 325
	DorisParserPASSWORD                = 326
	DorisParserPASSWORD_EXPIRE         = 327
	DorisParserPASSWORD_HISTORY        = 328
	DorisParserPASSWORD_LOCK_TIME      = 329
	DorisParserPASSWORD_REUSE          = 330
	DorisParserPATH                    = 331
	DorisParserPAUSE                   = 332
	DorisParserPERCENT                 = 333
	DorisParserPERIOD                  = 334
	DorisParserPERMISSIVE              = 335
	DorisParserPHYSICAL                = 336
	DorisParserPI                      = 337
	DorisParserPLACEHOLDER             = 338
	DorisParserPLAN                    = 339
	DorisParserPRIVILEGES              = 340
	DorisParserPROCESS                 = 341
	DorisParserPLUGIN                  = 342
	DorisParserPLUGINS                 = 343
	DorisParserPOLICY                  = 344
	DorisParserPRECEDING               = 345
	DorisParserPREPARE                 = 346
	DorisParserPRIMARY                 = 347
	DorisParserPROC                    = 348
	DorisParserPROCEDURE               = 349
	DorisParserPROCESSLIST             = 350
	DorisParserPROFILE                 = 351
	DorisParserPROPERTIES              = 352
	DorisParserPROPERTY                = 353
	DorisParserQUANTILE_STATE          = 354
	DorisParserQUANTILE_UNION          = 355
	DorisParserQUERY                   = 356
	DorisParserQUOTA                   = 357
	DorisParserRANDOM                  = 358
	DorisParserRANGE                   = 359
	DorisParserREAD                    = 360
	DorisParserREAL                    = 361
	DorisParserREBALANCE               = 362
	DorisParserRECENT                  = 363
	DorisParserRECOVER                 = 364
	DorisParserRECYCLE                 = 365
	DorisParserREFRESH                 = 366
	DorisParserREFERENCES              = 367
	DorisParserREGEXP                  = 368
	DorisParserRELEASE                 = 369
	DorisParserRENAME                  = 370
	DorisParserREPAIR                  = 371
	DorisParserREPEATABLE              = 372
	DorisParserREPLACE                 = 373
	DorisParserREPLACE_IF_NOT_NULL     = 374
	DorisParserREPLICA                 = 375
	DorisParserREPOSITORIES            = 376
	DorisParserREPOSITORY              = 377
	DorisParserRESOURCE                = 378
	DorisParserRESOURCES               = 379
	DorisParserRESTORE                 = 380
	DorisParserRESTRICTIVE             = 381
	DorisParserRESUME                  = 382
	DorisParserRETURNS                 = 383
	DorisParserREVOKE                  = 384
	DorisParserREWRITTEN               = 385
	DorisParserRIGHT                   = 386
	DorisParserRLIKE                   = 387
	DorisParserROLE                    = 388
	DorisParserROLES                   = 389
	DorisParserROLLBACK                = 390
	DorisParserROLLUP                  = 391
	DorisParserROUTINE                 = 392
	DorisParserROW                     = 393
	DorisParserROWS                    = 394
	DorisParserS3                      = 395
	DorisParserSAMPLE                  = 396
	DorisParserSCHEDULE                = 397
	DorisParserSCHEDULER               = 398
	DorisParserSCHEMA                  = 399
	DorisParserSCHEMAS                 = 400
	DorisParserSECOND                  = 401
	DorisParserSELECT                  = 402
	DorisParserSEMI                    = 403
	DorisParserSEQUENCE                = 404
	DorisParserSERIALIZABLE            = 405
	DorisParserSESSION                 = 406
	DorisParserSET                     = 407
	DorisParserSETS                    = 408
	DorisParserSET_SESSION_VARIABLE    = 409
	DorisParserSHAPE                   = 410
	DorisParserSHOW                    = 411
	DorisParserSIGNED                  = 412
	DorisParserSKEW                    = 413
	DorisParserSMALLINT                = 414
	DorisParserSNAPSHOT                = 415
	DorisParserSONAME                  = 416
	DorisParserSPLIT                   = 417
	DorisParserSQL                     = 418
	DorisParserSQL_BLOCK_RULE          = 419
	DorisParserSTAGE                   = 420
	DorisParserSTAGES                  = 421
	DorisParserSTART                   = 422
	DorisParserSTARTS                  = 423
	DorisParserSTATS                   = 424
	DorisParserSTATUS                  = 425
	DorisParserSTOP                    = 426
	DorisParserSTORAGE                 = 427
	DorisParserSTREAM                  = 428
	DorisParserSTREAMING               = 429
	DorisParserSTRING                  = 430
	DorisParserSTRUCT                  = 431
	DorisParserSUBDATE                 = 432
	DorisParserSUM                     = 433
	DorisParserSUPERUSER               = 434
	DorisParserSWITCH                  = 435
	DorisParserSYNC                    = 436
	DorisParserSYSTEM                  = 437
	DorisParserTABLE                   = 438
	DorisParserTABLES                  = 439
	DorisParserTABLESAMPLE             = 440
	DorisParserTABLET                  = 441
	DorisParserTABLETS                 = 442
	DorisParserTASK                    = 443
	DorisParserTASKS                   = 444
	DorisParserTEMPORARY               = 445
	DorisParserTERMINATED              = 446
	DorisParserTEXT                    = 447
	DorisParserTHAN                    = 448
	DorisParserTHEN                    = 449
	DorisParserTIME                    = 450
	DorisParserTIMESTAMP               = 451
	DorisParserTIMESTAMPADD            = 452
	DorisParserTIMESTAMPDIFF           = 453
	DorisParserTINYINT                 = 454
	DorisParserTO                      = 455
	DorisParserTRANSACTION             = 456
	DorisParserTRASH                   = 457
	DorisParserTREE                    = 458
	DorisParserTRIGGERS                = 459
	DorisParserTRIM                    = 460
	DorisParserTRUE                    = 461
	DorisParserTRUNCATE                = 462
	DorisParserTYPE                    = 463
	DorisParserTYPECAST                = 464
	DorisParserTYPES                   = 465
	DorisParserUNBOUNDED               = 466
	DorisParserUNCOMMITTED             = 467
	DorisParserUNINSTALL               = 468
	DorisParserUNION                   = 469
	DorisParserUNIQUE                  = 470
	DorisParserUNLOCK                  = 471
	DorisParserUNSET                   = 472
	DorisParserUNSIGNED                = 473
	DorisParserUP                      = 474
	DorisParserUPDATE                  = 475
	DorisParserUSE                     = 476
	DorisParserUSER                    = 477
	DorisParserUSING                   = 478
	DorisParserVALUE                   = 479
	DorisParserVALUES                  = 480
	DorisParserVARCHAR                 = 481
	DorisParserVARIABLE                = 482
	DorisParserVARIABLES               = 483
	DorisParserVARIANT                 = 484
	DorisParserVAULT                   = 485
	DorisParserVERBOSE                 = 486
	DorisParserVERSION                 = 487
	DorisParserVIEW                    = 488
	DorisParserWARM                    = 489
	DorisParserWARNINGS                = 490
	DorisParserWEEK                    = 491
	DorisParserWHEN                    = 492
	DorisParserWHERE                   = 493
	DorisParserWHITELIST               = 494
	DorisParserWITH                    = 495
	DorisParserWORK                    = 496
	DorisParserWORKLOAD                = 497
	DorisParserWRITE                   = 498
	DorisParserXOR                     = 499
	DorisParserYEAR                    = 500
	DorisParserEQ                      = 501
	DorisParserNSEQ                    = 502
	DorisParserNEQ                     = 503
	DorisParserLT                      = 504
	DorisParserLTE                     = 505
	DorisParserGT                      = 506
	DorisParserGTE                     = 507
	DorisParserPLUS                    = 508
	DorisParserSUBTRACT                = 509
	DorisParserASTERISK                = 510
	DorisParserSLASH                   = 511
	DorisParserMOD                     = 512
	DorisParserTILDE                   = 513
	DorisParserAMPERSAND               = 514
	DorisParserLOGICALAND              = 515
	DorisParserLOGICALNOT              = 516
	DorisParserPIPE                    = 517
	DorisParserDOUBLEPIPES             = 518
	DorisParserHAT                     = 519
	DorisParserCOLON                   = 520
	DorisParserARROW                   = 521
	DorisParserHINT_START              = 522
	DorisParserHINT_END                = 523
	DorisParserCOMMENT_START           = 524
	DorisParserATSIGN                  = 525
	DorisParserDOUBLEATSIGN            = 526
	DorisParserSTRING_LITERAL          = 527
	DorisParserLEADING_STRING          = 528
	DorisParserBIGINT_LITERAL          = 529
	DorisParserSMALLINT_LITERAL        = 530
	DorisParserTINYINT_LITERAL         = 531
	DorisParserINTEGER_VALUE           = 532
	DorisParserEXPONENT_VALUE          = 533
	DorisParserDECIMAL_VALUE           = 534
	DorisParserBIGDECIMAL_LITERAL      = 535
	DorisParserIDENTIFIER              = 536
	DorisParserBACKQUOTED_IDENTIFIER   = 537
	DorisParserSIMPLE_COMMENT          = 538
	DorisParserBRACKETED_COMMENT       = 539
	DorisParserFROM_DUAL               = 540
	DorisParserWS                      = 541
	DorisParserUNRECOGNIZED            = 542
)

// DorisParser rules.
const (
	DorisParserRULE_multiStatements                 = 0
	DorisParserRULE_singleStatement                 = 1
	DorisParserRULE_statement                       = 2
	DorisParserRULE_statementBase                   = 3
	DorisParserRULE_unsupportedStatement            = 4
	DorisParserRULE_materailizedViewStatement       = 5
	DorisParserRULE_constraintStatement             = 6
	DorisParserRULE_supportedDmlStatement           = 7
	DorisParserRULE_supportedCreateStatement        = 8
	DorisParserRULE_supportedAlterStatement         = 9
	DorisParserRULE_supportedDropStatement          = 10
	DorisParserRULE_unsupportedAdminStatement       = 11
	DorisParserRULE_baseTableRef                    = 12
	DorisParserRULE_wildWhere                       = 13
	DorisParserRULE_unsupportedTransactionStatement = 14
	DorisParserRULE_unsupportedGrantRevokeStatement = 15
	DorisParserRULE_privilege                       = 16
	DorisParserRULE_privilegeList                   = 17
	DorisParserRULE_unsupportedAlterStatement       = 18
	DorisParserRULE_alterSystemClause               = 19
	DorisParserRULE_dropRollupClause                = 20
	DorisParserRULE_addRollupClause                 = 21
	DorisParserRULE_alterTableClause                = 22
	DorisParserRULE_columnPosition                  = 23
	DorisParserRULE_toRollup                        = 24
	DorisParserRULE_fromRollup                      = 25
	DorisParserRULE_unsupportedDropStatement        = 26
	DorisParserRULE_unsupportedStatsStatement       = 27
	DorisParserRULE_unsupportedCreateStatement      = 28
	DorisParserRULE_channelDescriptions             = 29
	DorisParserRULE_channelDescription              = 30
	DorisParserRULE_workloadPolicyActions           = 31
	DorisParserRULE_workloadPolicyAction            = 32
	DorisParserRULE_workloadPolicyConditions        = 33
	DorisParserRULE_workloadPolicyCondition         = 34
	DorisParserRULE_storageBackend                  = 35
	DorisParserRULE_passwordOption                  = 36
	DorisParserRULE_functionArguments               = 37
	DorisParserRULE_functionArgument                = 38
	DorisParserRULE_unsupportedSetStatement         = 39
	DorisParserRULE_optionWithType                  = 40
	DorisParserRULE_optionWithoutType               = 41
	DorisParserRULE_variable                        = 42
	DorisParserRULE_transactionAccessMode           = 43
	DorisParserRULE_isolationLevel                  = 44
	DorisParserRULE_unsupoortedUnsetStatement       = 45
	DorisParserRULE_unsupportedUseStatement         = 46
	DorisParserRULE_unsupportedDmlStatement         = 47
	DorisParserRULE_unsupportedKillStatement        = 48
	DorisParserRULE_unsupportedDescribeStatement    = 49
	DorisParserRULE_constraint                      = 50
	DorisParserRULE_partitionSpec                   = 51
	DorisParserRULE_partitionTable                  = 52
	DorisParserRULE_identityOrFunctionList          = 53
	DorisParserRULE_identityOrFunction              = 54
	DorisParserRULE_dataDesc                        = 55
	DorisParserRULE_buildMode                       = 56
	DorisParserRULE_refreshTrigger                  = 57
	DorisParserRULE_refreshSchedule                 = 58
	DorisParserRULE_refreshMethod                   = 59
	DorisParserRULE_mvPartition                     = 60
	DorisParserRULE_identifierOrText                = 61
	DorisParserRULE_identifierOrTextOrAsterisk      = 62
	DorisParserRULE_multipartIdentifierOrAsterisk   = 63
	DorisParserRULE_identifierOrAsterisk            = 64
	DorisParserRULE_userIdentify                    = 65
	DorisParserRULE_grantUserIdentify               = 66
	DorisParserRULE_explain                         = 67
	DorisParserRULE_explainCommand                  = 68
	DorisParserRULE_planType                        = 69
	DorisParserRULE_mergeType                       = 70
	DorisParserRULE_preFilterClause                 = 71
	DorisParserRULE_deleteOnClause                  = 72
	DorisParserRULE_sequenceColClause               = 73
	DorisParserRULE_colFromPath                     = 74
	DorisParserRULE_colMappingList                  = 75
	DorisParserRULE_mappingExpr                     = 76
	DorisParserRULE_withRemoteStorageSystem         = 77
	DorisParserRULE_resourceDesc                    = 78
	DorisParserRULE_mysqlDataDesc                   = 79
	DorisParserRULE_skipLines                       = 80
	DorisParserRULE_outFileClause                   = 81
	DorisParserRULE_query                           = 82
	DorisParserRULE_queryTerm                       = 83
	DorisParserRULE_setQuantifier                   = 84
	DorisParserRULE_queryPrimary                    = 85
	DorisParserRULE_querySpecification              = 86
	DorisParserRULE_cte                             = 87
	DorisParserRULE_aliasQuery                      = 88
	DorisParserRULE_columnAliases                   = 89
	DorisParserRULE_selectClause                    = 90
	DorisParserRULE_selectColumnClause              = 91
	DorisParserRULE_whereClause                     = 92
	DorisParserRULE_fromClause                      = 93
	DorisParserRULE_intoClause                      = 94
	DorisParserRULE_bulkCollectClause               = 95
	DorisParserRULE_tableRow                        = 96
	DorisParserRULE_relations                       = 97
	DorisParserRULE_relation                        = 98
	DorisParserRULE_joinRelation                    = 99
	DorisParserRULE_distributeType                  = 100
	DorisParserRULE_relationHint                    = 101
	DorisParserRULE_aggClause                       = 102
	DorisParserRULE_groupingElement                 = 103
	DorisParserRULE_groupingSet                     = 104
	DorisParserRULE_havingClause                    = 105
	DorisParserRULE_selectHint                      = 106
	DorisParserRULE_hintStatement                   = 107
	DorisParserRULE_hintAssignment                  = 108
	DorisParserRULE_updateAssignment                = 109
	DorisParserRULE_updateAssignmentSeq             = 110
	DorisParserRULE_lateralView                     = 111
	DorisParserRULE_queryOrganization               = 112
	DorisParserRULE_sortClause                      = 113
	DorisParserRULE_sortItem                        = 114
	DorisParserRULE_limitClause                     = 115
	DorisParserRULE_partitionClause                 = 116
	DorisParserRULE_joinType                        = 117
	DorisParserRULE_joinCriteria                    = 118
	DorisParserRULE_identifierList                  = 119
	DorisParserRULE_identifierSeq                   = 120
	DorisParserRULE_optScanParams                   = 121
	DorisParserRULE_relationPrimary                 = 122
	DorisParserRULE_materializedViewName            = 123
	DorisParserRULE_propertyClause                  = 124
	DorisParserRULE_propertyItemList                = 125
	DorisParserRULE_propertyItem                    = 126
	DorisParserRULE_propertyKey                     = 127
	DorisParserRULE_propertyValue                   = 128
	DorisParserRULE_tableAlias                      = 129
	DorisParserRULE_multipartIdentifier             = 130
	DorisParserRULE_simpleColumnDefs                = 131
	DorisParserRULE_simpleColumnDef                 = 132
	DorisParserRULE_columnDefs                      = 133
	DorisParserRULE_columnDef                       = 134
	DorisParserRULE_indexDefs                       = 135
	DorisParserRULE_indexDef                        = 136
	DorisParserRULE_partitionsDef                   = 137
	DorisParserRULE_partitionDef                    = 138
	DorisParserRULE_lessThanPartitionDef            = 139
	DorisParserRULE_fixedPartitionDef               = 140
	DorisParserRULE_stepPartitionDef                = 141
	DorisParserRULE_inPartitionDef                  = 142
	DorisParserRULE_partitionValueList              = 143
	DorisParserRULE_partitionValueDef               = 144
	DorisParserRULE_rollupDefs                      = 145
	DorisParserRULE_rollupDef                       = 146
	DorisParserRULE_aggTypeDef                      = 147
	DorisParserRULE_tabletList                      = 148
	DorisParserRULE_inlineTable                     = 149
	DorisParserRULE_namedExpression                 = 150
	DorisParserRULE_namedExpressionSeq              = 151
	DorisParserRULE_expression                      = 152
	DorisParserRULE_lambdaExpression                = 153
	DorisParserRULE_booleanExpression               = 154
	DorisParserRULE_rowConstructor                  = 155
	DorisParserRULE_rowConstructorItem              = 156
	DorisParserRULE_predicate                       = 157
	DorisParserRULE_valueExpression                 = 158
	DorisParserRULE_datetimeUnit                    = 159
	DorisParserRULE_primaryExpression               = 160
	DorisParserRULE_exceptOrReplace                 = 161
	DorisParserRULE_castDataType                    = 162
	DorisParserRULE_functionCallExpression          = 163
	DorisParserRULE_functionIdentifier              = 164
	DorisParserRULE_functionNameIdentifier          = 165
	DorisParserRULE_windowSpec                      = 166
	DorisParserRULE_windowFrame                     = 167
	DorisParserRULE_frameUnits                      = 168
	DorisParserRULE_frameBoundary                   = 169
	DorisParserRULE_qualifiedName                   = 170
	DorisParserRULE_specifiedPartition              = 171
	DorisParserRULE_constant                        = 172
	DorisParserRULE_comparisonOperator              = 173
	DorisParserRULE_booleanValue                    = 174
	DorisParserRULE_whenClause                      = 175
	DorisParserRULE_interval                        = 176
	DorisParserRULE_unitIdentifier                  = 177
	DorisParserRULE_dataTypeWithNullable            = 178
	DorisParserRULE_dataType                        = 179
	DorisParserRULE_primitiveColType                = 180
	DorisParserRULE_complexColTypeList              = 181
	DorisParserRULE_complexColType                  = 182
	DorisParserRULE_commentSpec                     = 183
	DorisParserRULE_sample                          = 184
	DorisParserRULE_sampleMethod                    = 185
	DorisParserRULE_tableSnapshot                   = 186
	DorisParserRULE_errorCapturingIdentifier        = 187
	DorisParserRULE_errorCapturingIdentifierExtra   = 188
	DorisParserRULE_identifier                      = 189
	DorisParserRULE_strictIdentifier                = 190
	DorisParserRULE_quotedIdentifier                = 191
	DorisParserRULE_number                          = 192
	DorisParserRULE_nonReserved                     = 193
)

// IMultiStatementsContext is an interface to support dynamic dispatch.
type IMultiStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsMultiStatementsContext differentiates from other interfaces.
	IsMultiStatementsContext()
}

type MultiStatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiStatementsContext() *MultiStatementsContext {
	var p = new(MultiStatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_multiStatements
	return p
}

func InitEmptyMultiStatementsContext(p *MultiStatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_multiStatements
}

func (*MultiStatementsContext) IsMultiStatementsContext() {}

func NewMultiStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiStatementsContext {
	var p = new(MultiStatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_multiStatements

	return p
}

func (s *MultiStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiStatementsContext) EOF() antlr.TerminalNode {
	return s.GetToken(DorisParserEOF, 0)
}

func (s *MultiStatementsContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSEMICOLON)
}

func (s *MultiStatementsContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSEMICOLON, i)
}

func (s *MultiStatementsContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *MultiStatementsContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *MultiStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMultiStatements(s)
	}
}

func (s *MultiStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMultiStatements(s)
	}
}

func (p *DorisParser) MultiStatements() (localctx IMultiStatementsContext) {
	localctx = NewMultiStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, DorisParserRULE_multiStatements)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(391)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(388)
				p.Match(DorisParserSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(393)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(395)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-2)) & ^0x3f) == 0 && ((int64(1)<<(_la-2))&6953558099539017729) != 0) || ((int64((_la-83)) & ^0x3f) == 0 && ((int64(1)<<(_la-83))&58546795155881985) != 0) || ((int64((_la-150)) & ^0x3f) == 0 && ((int64(1)<<(_la-150))&4503599639953409) != 0) || ((int64((_la-229)) & ^0x3f) == 0 && ((int64(1)<<(_la-229))&274886295553) != 0) || ((int64((_la-332)) & ^0x3f) == 0 && ((int64(1)<<(_la-332))&293862091889049601) != 0) || ((int64((_la-402)) & ^0x3f) == 0 && ((int64(1)<<(_la-402))&1152921513196782113) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&8388889) != 0) {
		{
			p.SetState(394)
			p.Statement()
		}

	}
	p.SetState(405)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(398)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == DorisParserSEMICOLON {
				{
					p.SetState(397)
					p.Match(DorisParserSEMICOLON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(400)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(402)
				p.Statement()
			}

		}
		p.SetState(407)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(411)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserSEMICOLON {
		{
			p.SetState(408)
			p.Match(DorisParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(413)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(414)
		p.Match(DorisParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleStatementContext is an interface to support dynamic dispatch.
type ISingleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	Statement() IStatementContext

	// IsSingleStatementContext differentiates from other interfaces.
	IsSingleStatementContext()
}

type SingleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleStatementContext() *SingleStatementContext {
	var p = new(SingleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_singleStatement
	return p
}

func InitEmptySingleStatementContext(p *SingleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_singleStatement
}

func (*SingleStatementContext) IsSingleStatementContext() {}

func NewSingleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleStatementContext {
	var p = new(SingleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_singleStatement

	return p
}

func (s *SingleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleStatementContext) EOF() antlr.TerminalNode {
	return s.GetToken(DorisParserEOF, 0)
}

func (s *SingleStatementContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSEMICOLON)
}

func (s *SingleStatementContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSEMICOLON, i)
}

func (s *SingleStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SingleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSingleStatement(s)
	}
}

func (s *SingleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSingleStatement(s)
	}
}

func (p *DorisParser) SingleStatement() (localctx ISingleStatementContext) {
	localctx = NewSingleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, DorisParserRULE_singleStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(416)
				p.Match(DorisParserSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(421)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(423)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-2)) & ^0x3f) == 0 && ((int64(1)<<(_la-2))&6953558099539017729) != 0) || ((int64((_la-83)) & ^0x3f) == 0 && ((int64(1)<<(_la-83))&58546795155881985) != 0) || ((int64((_la-150)) & ^0x3f) == 0 && ((int64(1)<<(_la-150))&4503599639953409) != 0) || ((int64((_la-229)) & ^0x3f) == 0 && ((int64(1)<<(_la-229))&274886295553) != 0) || ((int64((_la-332)) & ^0x3f) == 0 && ((int64(1)<<(_la-332))&293862091889049601) != 0) || ((int64((_la-402)) & ^0x3f) == 0 && ((int64(1)<<(_la-402))&1152921513196782113) != 0) || ((int64((_la-472)) & ^0x3f) == 0 && ((int64(1)<<(_la-472))&8388889) != 0) {
		{
			p.SetState(422)
			p.Statement()
		}

	}
	p.SetState(428)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserSEMICOLON {
		{
			p.SetState(425)
			p.Match(DorisParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(430)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(431)
		p.Match(DorisParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) CopyAll(ctx *StatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowCreateProcedureContext struct {
	StatementContext
	name IMultipartIdentifierContext
}

func NewShowCreateProcedureContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateProcedureContext {
	var p = new(ShowCreateProcedureContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowCreateProcedureContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *ShowCreateProcedureContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *ShowCreateProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateProcedureContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCreateProcedureContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowCreateProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(DorisParserPROCEDURE, 0)
}

func (s *ShowCreateProcedureContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCreateProcedure(s)
	}
}

func (s *ShowCreateProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCreateProcedure(s)
	}
}

type StatementBaseAliasContext struct {
	StatementContext
}

func NewStatementBaseAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StatementBaseAliasContext {
	var p = new(StatementBaseAliasContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *StatementBaseAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementBaseAliasContext) StatementBase() IStatementBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementBaseContext)
}

func (s *StatementBaseAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStatementBaseAlias(s)
	}
}

func (s *StatementBaseAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStatementBaseAlias(s)
	}
}

type ShowProcedureStatusContext struct {
	StatementContext
	pattern IValueExpressionContext
}

func NewShowProcedureStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowProcedureStatusContext {
	var p = new(ShowProcedureStatusContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowProcedureStatusContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *ShowProcedureStatusContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *ShowProcedureStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProcedureStatusContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowProcedureStatusContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(DorisParserPROCEDURE, 0)
}

func (s *ShowProcedureStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATUS, 0)
}

func (s *ShowProcedureStatusContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *ShowProcedureStatusContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *ShowProcedureStatusContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ShowProcedureStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowProcedureStatus(s)
	}
}

func (s *ShowProcedureStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowProcedureStatus(s)
	}
}

type CreateProcedureContext struct {
	StatementContext
	name IMultipartIdentifierContext
}

func NewCreateProcedureContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateProcedureContext {
	var p = new(CreateProcedureContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateProcedureContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CreateProcedureContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CreateProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateProcedureContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CreateProcedureContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CreateProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(DorisParserPROCEDURE, 0)
}

func (s *CreateProcedureContext) PROC() antlr.TerminalNode {
	return s.GetToken(DorisParserPROC, 0)
}

func (s *CreateProcedureContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateProcedureContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *CreateProcedureContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateProcedureContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *CreateProcedureContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisParserOR, 0)
}

func (s *CreateProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateProcedure(s)
	}
}

func (s *CreateProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateProcedure(s)
	}
}

type ShowConfigContext struct {
	StatementContext
	type_     antlr.Token
	pattern   IValueExpressionContext
	backendId antlr.Token
}

func NewShowConfigContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowConfigContext {
	var p = new(ShowConfigContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowConfigContext) GetType_() antlr.Token { return s.type_ }

func (s *ShowConfigContext) GetBackendId() antlr.Token { return s.backendId }

func (s *ShowConfigContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *ShowConfigContext) SetBackendId(v antlr.Token) { s.backendId = v }

func (s *ShowConfigContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *ShowConfigContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *ShowConfigContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowConfigContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowConfigContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(DorisParserCONFIG, 0)
}

func (s *ShowConfigContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(DorisParserFRONTEND, 0)
}

func (s *ShowConfigContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKEND, 0)
}

func (s *ShowConfigContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *ShowConfigContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *ShowConfigContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowConfigContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ShowConfigContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ShowConfigContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowConfig(s)
	}
}

func (s *ShowConfigContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowConfig(s)
	}
}

type CallProcedureContext struct {
	StatementContext
	name IMultipartIdentifierContext
}

func NewCallProcedureContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CallProcedureContext {
	var p = new(CallProcedureContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CallProcedureContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CallProcedureContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CallProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallProcedureContext) CALL() antlr.TerminalNode {
	return s.GetToken(DorisParserCALL, 0)
}

func (s *CallProcedureContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CallProcedureContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CallProcedureContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CallProcedureContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CallProcedureContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CallProcedureContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *CallProcedureContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *CallProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCallProcedure(s)
	}
}

func (s *CallProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCallProcedure(s)
	}
}

type DropProcedureContext struct {
	StatementContext
	name IMultipartIdentifierContext
}

func NewDropProcedureContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropProcedureContext {
	var p = new(DropProcedureContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropProcedureContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *DropProcedureContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *DropProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropProcedureContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(DorisParserPROCEDURE, 0)
}

func (s *DropProcedureContext) PROC() antlr.TerminalNode {
	return s.GetToken(DorisParserPROC, 0)
}

func (s *DropProcedureContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropProcedureContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropProcedureContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropProcedure(s)
	}
}

func (s *DropProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropProcedure(s)
	}
}

func (p *DorisParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, DorisParserRULE_statement)
	var _la int

	var _alt int

	p.SetState(507)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStatementBaseAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(433)
			p.StatementBase()
		}

	case 2:
		localctx = NewCallProcedureContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(434)
			p.Match(DorisParserCALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(435)

			var _x = p.MultipartIdentifier()

			localctx.(*CallProcedureContext).name = _x
		}
		{
			p.SetState(436)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(445)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1153005225580239228) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-141717009369345) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-4539691388701481817) != 0) || ((int64((_la-195)) & ^0x3f) == 0 && ((int64(1)<<(_la-195))&-3103018623212733835) != 0) || ((int64((_la-259)) & ^0x3f) == 0 && ((int64(1)<<(_la-259))&-9089391056176578961) != 0) || ((int64((_la-323)) & ^0x3f) == 0 && ((int64(1)<<(_la-323))&-2310857813124972547) != 0) || ((int64((_la-387)) & ^0x3f) == 0 && ((int64(1)<<(_la-387))&-5255560032135782599) != 0) || ((int64((_la-451)) & ^0x3f) == 0 && ((int64(1)<<(_la-451))&5621092667580571559) != 0) || ((int64((_la-516)) & ^0x3f) == 0 && ((int64(1)<<(_la-516))&3608513) != 0) {
			{
				p.SetState(437)
				p.Expression()
			}
			p.SetState(442)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(438)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(439)
					p.Expression()
				}

				p.SetState(444)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(447)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewCreateProcedureContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(456)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserALTER:
			{
				p.SetState(449)
				p.Match(DorisParserALTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCREATE:
			{
				p.SetState(450)
				p.Match(DorisParserCREATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(453)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserOR {
				{
					p.SetState(451)
					p.Match(DorisParserOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(452)
					p.Match(DorisParserREPLACE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		case DorisParserREPLACE:
			{
				p.SetState(455)
				p.Match(DorisParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(458)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserPROC || _la == DorisParserPROCEDURE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(459)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateProcedureContext).name = _x
		}
		{
			p.SetState(460)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(464)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				p.SetState(461)
				p.MatchWildcard()

			}
			p.SetState(466)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(467)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(471)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				p.SetState(468)
				p.MatchWildcard()

			}
			p.SetState(473)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 4:
		localctx = NewDropProcedureContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(474)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(475)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserPROC || _la == DorisParserPROCEDURE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(478)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(476)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(477)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(480)

			var _x = p.MultipartIdentifier()

			localctx.(*DropProcedureContext).name = _x
		}

	case 5:
		localctx = NewShowProcedureStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(481)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(482)
			p.Match(DorisParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(483)
			p.Match(DorisParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(487)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case DorisParserLIKE:
			{
				p.SetState(484)
				p.Match(DorisParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(485)

				var _x = p.valueExpression(0)

				localctx.(*ShowProcedureStatusContext).pattern = _x
			}

		case DorisParserWHERE:
			{
				p.SetState(486)
				p.WhereClause()
			}

		case DorisParserEOF, DorisParserSEMICOLON:

		default:
		}

	case 6:
		localctx = NewShowCreateProcedureContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(489)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(490)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(491)
			p.Match(DorisParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(492)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateProcedureContext).name = _x
		}

	case 7:
		localctx = NewShowConfigContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		p.SetState(494)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserADMIN {
			{
				p.SetState(493)
				p.Match(DorisParserADMIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(496)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(497)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowConfigContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserBACKEND || _la == DorisParserFRONTEND) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowConfigContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(498)
			p.Match(DorisParserCONFIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(501)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE {
			{
				p.SetState(499)
				p.Match(DorisParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(500)

				var _x = p.valueExpression(0)

				localctx.(*ShowConfigContext).pattern = _x
			}

		}
		p.SetState(505)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(503)
				p.Match(DorisParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(504)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*ShowConfigContext).backendId = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementBaseContext is an interface to support dynamic dispatch.
type IStatementBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStatementBaseContext differentiates from other interfaces.
	IsStatementBaseContext()
}

type StatementBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementBaseContext() *StatementBaseContext {
	var p = new(StatementBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_statementBase
	return p
}

func InitEmptyStatementBaseContext(p *StatementBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_statementBase
}

func (*StatementBaseContext) IsStatementBaseContext() {}

func NewStatementBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementBaseContext {
	var p = new(StatementBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_statementBase

	return p
}

func (s *StatementBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementBaseContext) CopyAll(ctx *StatementBaseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StatementBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SupportedDmlStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedDmlStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedDmlStatementAliasContext {
	var p = new(SupportedDmlStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedDmlStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedDmlStatementAliasContext) SupportedDmlStatement() ISupportedDmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedDmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedDmlStatementContext)
}

func (s *SupportedDmlStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedDmlStatementAlias(s)
	}
}

func (s *SupportedDmlStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedDmlStatementAlias(s)
	}
}

type UnsupportedContext struct {
	StatementBaseContext
}

func NewUnsupportedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnsupportedContext {
	var p = new(UnsupportedContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *UnsupportedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedContext) UnsupportedStatement() IUnsupportedStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedStatementContext)
}

func (s *UnsupportedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUnsupported(s)
	}
}

func (s *UnsupportedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUnsupported(s)
	}
}

type ConstraintStatementAliasContext struct {
	StatementBaseContext
}

func NewConstraintStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstraintStatementAliasContext {
	var p = new(ConstraintStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *ConstraintStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintStatementAliasContext) ConstraintStatement() IConstraintStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintStatementContext)
}

func (s *ConstraintStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterConstraintStatementAlias(s)
	}
}

func (s *ConstraintStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitConstraintStatementAlias(s)
	}
}

type StatementDefaultContext struct {
	StatementBaseContext
}

func NewStatementDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StatementDefaultContext {
	var p = new(StatementDefaultContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *StatementDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementDefaultContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *StatementDefaultContext) Explain() IExplainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainContext)
}

func (s *StatementDefaultContext) OutFileClause() IOutFileClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOutFileClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOutFileClauseContext)
}

func (s *StatementDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStatementDefault(s)
	}
}

func (s *StatementDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStatementDefault(s)
	}
}

type SupportedAlterStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedAlterStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedAlterStatementAliasContext {
	var p = new(SupportedAlterStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedAlterStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedAlterStatementAliasContext) SupportedAlterStatement() ISupportedAlterStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedAlterStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedAlterStatementContext)
}

func (s *SupportedAlterStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedAlterStatementAlias(s)
	}
}

func (s *SupportedAlterStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedAlterStatementAlias(s)
	}
}

type SupportedDropStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedDropStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedDropStatementAliasContext {
	var p = new(SupportedDropStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedDropStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedDropStatementAliasContext) SupportedDropStatement() ISupportedDropStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedDropStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedDropStatementContext)
}

func (s *SupportedDropStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedDropStatementAlias(s)
	}
}

func (s *SupportedDropStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedDropStatementAlias(s)
	}
}

type SupportedCreateStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedCreateStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedCreateStatementAliasContext {
	var p = new(SupportedCreateStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedCreateStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedCreateStatementAliasContext) SupportedCreateStatement() ISupportedCreateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedCreateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedCreateStatementContext)
}

func (s *SupportedCreateStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedCreateStatementAlias(s)
	}
}

func (s *SupportedCreateStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedCreateStatementAlias(s)
	}
}

type MaterailizedViewStatementAliasContext struct {
	StatementBaseContext
}

func NewMaterailizedViewStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MaterailizedViewStatementAliasContext {
	var p = new(MaterailizedViewStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *MaterailizedViewStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaterailizedViewStatementAliasContext) MaterailizedViewStatement() IMaterailizedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaterailizedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaterailizedViewStatementContext)
}

func (s *MaterailizedViewStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMaterailizedViewStatementAlias(s)
	}
}

func (s *MaterailizedViewStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMaterailizedViewStatementAlias(s)
	}
}

func (p *DorisParser) StatementBase() (localctx IStatementBaseContext) {
	localctx = NewStatementBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, DorisParserRULE_statementBase)
	var _la int

	p.SetState(523)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStatementDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(510)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&34359738371) != 0 {
			{
				p.SetState(509)
				p.Explain()
			}

		}
		{
			p.SetState(512)
			p.Query()
		}
		p.SetState(514)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserINTO {
			{
				p.SetState(513)
				p.OutFileClause()
			}

		}

	case 2:
		localctx = NewSupportedDmlStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(516)
			p.SupportedDmlStatement()
		}

	case 3:
		localctx = NewSupportedCreateStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(517)
			p.SupportedCreateStatement()
		}

	case 4:
		localctx = NewSupportedAlterStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(518)
			p.SupportedAlterStatement()
		}

	case 5:
		localctx = NewMaterailizedViewStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(519)
			p.MaterailizedViewStatement()
		}

	case 6:
		localctx = NewConstraintStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(520)
			p.ConstraintStatement()
		}

	case 7:
		localctx = NewSupportedDropStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(521)
			p.SupportedDropStatement()
		}

	case 8:
		localctx = NewUnsupportedContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(522)
			p.UnsupportedStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedStatementContext is an interface to support dynamic dispatch.
type IUnsupportedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsupportedSetStatement() IUnsupportedSetStatementContext
	UnsupoortedUnsetStatement() IUnsupoortedUnsetStatementContext
	UnsupportedUseStatement() IUnsupportedUseStatementContext
	UnsupportedDmlStatement() IUnsupportedDmlStatementContext
	UnsupportedKillStatement() IUnsupportedKillStatementContext
	UnsupportedDescribeStatement() IUnsupportedDescribeStatementContext
	UnsupportedCreateStatement() IUnsupportedCreateStatementContext
	UnsupportedDropStatement() IUnsupportedDropStatementContext
	UnsupportedStatsStatement() IUnsupportedStatsStatementContext
	UnsupportedAlterStatement() IUnsupportedAlterStatementContext
	UnsupportedGrantRevokeStatement() IUnsupportedGrantRevokeStatementContext
	UnsupportedAdminStatement() IUnsupportedAdminStatementContext
	UnsupportedTransactionStatement() IUnsupportedTransactionStatementContext

	// IsUnsupportedStatementContext differentiates from other interfaces.
	IsUnsupportedStatementContext()
}

type UnsupportedStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedStatementContext() *UnsupportedStatementContext {
	var p = new(UnsupportedStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedStatement
	return p
}

func InitEmptyUnsupportedStatementContext(p *UnsupportedStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedStatement
}

func (*UnsupportedStatementContext) IsUnsupportedStatementContext() {}

func NewUnsupportedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedStatementContext {
	var p = new(UnsupportedStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedStatement

	return p
}

func (s *UnsupportedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedStatementContext) UnsupportedSetStatement() IUnsupportedSetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedSetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedSetStatementContext)
}

func (s *UnsupportedStatementContext) UnsupoortedUnsetStatement() IUnsupoortedUnsetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupoortedUnsetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupoortedUnsetStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedUseStatement() IUnsupportedUseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedUseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedUseStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedDmlStatement() IUnsupportedDmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedDmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedDmlStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedKillStatement() IUnsupportedKillStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedKillStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedKillStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedDescribeStatement() IUnsupportedDescribeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedDescribeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedDescribeStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedCreateStatement() IUnsupportedCreateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedCreateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedCreateStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedDropStatement() IUnsupportedDropStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedDropStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedDropStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedStatsStatement() IUnsupportedStatsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedStatsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedStatsStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedAlterStatement() IUnsupportedAlterStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedAlterStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedAlterStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedGrantRevokeStatement() IUnsupportedGrantRevokeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedGrantRevokeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedGrantRevokeStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedAdminStatement() IUnsupportedAdminStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedAdminStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedAdminStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedTransactionStatement() IUnsupportedTransactionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedTransactionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedTransactionStatementContext)
}

func (s *UnsupportedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsupportedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUnsupportedStatement(s)
	}
}

func (s *UnsupportedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUnsupportedStatement(s)
	}
}

func (p *DorisParser) UnsupportedStatement() (localctx IUnsupportedStatementContext) {
	localctx = NewUnsupportedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, DorisParserRULE_unsupportedStatement)
	p.SetState(538)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(525)
			p.UnsupportedSetStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(526)
			p.UnsupoortedUnsetStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(527)
			p.UnsupportedUseStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(528)
			p.UnsupportedDmlStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(529)
			p.UnsupportedKillStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(530)
			p.UnsupportedDescribeStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(531)
			p.UnsupportedCreateStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(532)
			p.UnsupportedDropStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(533)
			p.UnsupportedStatsStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(534)
			p.UnsupportedAlterStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(535)
			p.UnsupportedGrantRevokeStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(536)
			p.UnsupportedAdminStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(537)
			p.UnsupportedTransactionStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaterailizedViewStatementContext is an interface to support dynamic dispatch.
type IMaterailizedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsMaterailizedViewStatementContext differentiates from other interfaces.
	IsMaterailizedViewStatementContext()
}

type MaterailizedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaterailizedViewStatementContext() *MaterailizedViewStatementContext {
	var p = new(MaterailizedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_materailizedViewStatement
	return p
}

func InitEmptyMaterailizedViewStatementContext(p *MaterailizedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_materailizedViewStatement
}

func (*MaterailizedViewStatementContext) IsMaterailizedViewStatementContext() {}

func NewMaterailizedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaterailizedViewStatementContext {
	var p = new(MaterailizedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_materailizedViewStatement

	return p
}

func (s *MaterailizedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MaterailizedViewStatementContext) CopyAll(ctx *MaterailizedViewStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *MaterailizedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaterailizedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RefreshMTMVContext struct {
	MaterailizedViewStatementContext
	mvName IMultipartIdentifierContext
}

func NewRefreshMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RefreshMTMVContext {
	var p = new(RefreshMTMVContext)

	InitEmptyMaterailizedViewStatementContext(&p.MaterailizedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterailizedViewStatementContext))

	return p
}

func (s *RefreshMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *RefreshMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *RefreshMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshMTMVContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserREFRESH, 0)
}

func (s *RefreshMTMVContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *RefreshMTMVContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *RefreshMTMVContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *RefreshMTMVContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *RefreshMTMVContext) COMPLETE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPLETE, 0)
}

func (s *RefreshMTMVContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO, 0)
}

func (s *RefreshMTMVContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRefreshMTMV(s)
	}
}

func (s *RefreshMTMVContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRefreshMTMV(s)
	}
}

type AlterMTMVContext struct {
	MaterailizedViewStatementContext
	mvName         IMultipartIdentifierContext
	newName        IIdentifierContext
	fileProperties IPropertyItemListContext
}

func NewAlterMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterMTMVContext {
	var p = new(AlterMTMVContext)

	InitEmptyMaterailizedViewStatementContext(&p.MaterailizedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterailizedViewStatementContext))

	return p
}

func (s *AlterMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *AlterMTMVContext) GetNewName() IIdentifierContext { return s.newName }

func (s *AlterMTMVContext) GetFileProperties() IPropertyItemListContext { return s.fileProperties }

func (s *AlterMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *AlterMTMVContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *AlterMTMVContext) SetFileProperties(v IPropertyItemListContext) { s.fileProperties = v }

func (s *AlterMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterMTMVContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterMTMVContext) AllMATERIALIZED() []antlr.TerminalNode {
	return s.GetTokens(DorisParserMATERIALIZED)
}

func (s *AlterMTMVContext) MATERIALIZED(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, i)
}

func (s *AlterMTMVContext) AllVIEW() []antlr.TerminalNode {
	return s.GetTokens(DorisParserVIEW)
}

func (s *AlterMTMVContext) VIEW(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, i)
}

func (s *AlterMTMVContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterMTMVContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *AlterMTMVContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *AlterMTMVContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterMTMVContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserRENAME, 0)
}

func (s *AlterMTMVContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserREFRESH, 0)
}

func (s *AlterMTMVContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterMTMVContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterMTMVContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterMTMVContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterMTMVContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterMTMVContext) RefreshMethod() IRefreshMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshMethodContext)
}

func (s *AlterMTMVContext) RefreshTrigger() IRefreshTriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshTriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshTriggerContext)
}

func (s *AlterMTMVContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterMTMV(s)
	}
}

func (s *AlterMTMVContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterMTMV(s)
	}
}

type CreateMTMVContext struct {
	MaterailizedViewStatementContext
	mvName   IMultipartIdentifierContext
	cols     ISimpleColumnDefsContext
	keys     IIdentifierListContext
	hashKeys IIdentifierListContext
}

func NewCreateMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateMTMVContext {
	var p = new(CreateMTMVContext)

	InitEmptyMaterailizedViewStatementContext(&p.MaterailizedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterailizedViewStatementContext))

	return p
}

func (s *CreateMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *CreateMTMVContext) GetCols() ISimpleColumnDefsContext { return s.cols }

func (s *CreateMTMVContext) GetKeys() IIdentifierListContext { return s.keys }

func (s *CreateMTMVContext) GetHashKeys() IIdentifierListContext { return s.hashKeys }

func (s *CreateMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *CreateMTMVContext) SetCols(v ISimpleColumnDefsContext) { s.cols = v }

func (s *CreateMTMVContext) SetKeys(v IIdentifierListContext) { s.keys = v }

func (s *CreateMTMVContext) SetHashKeys(v IIdentifierListContext) { s.hashKeys = v }

func (s *CreateMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateMTMVContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateMTMVContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *CreateMTMVContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *CreateMTMVContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *CreateMTMVContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateMTMVContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateMTMVContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateMTMVContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateMTMVContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateMTMVContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserLEFT_PAREN)
}

func (s *CreateMTMVContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, i)
}

func (s *CreateMTMVContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserRIGHT_PAREN)
}

func (s *CreateMTMVContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, i)
}

func (s *CreateMTMVContext) BuildMode() IBuildModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBuildModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBuildModeContext)
}

func (s *CreateMTMVContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserREFRESH, 0)
}

func (s *CreateMTMVContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserKEY, 0)
}

func (s *CreateMTMVContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *CreateMTMVContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateMTMVContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *CreateMTMVContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(DorisParserBY)
}

func (s *CreateMTMVContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserBY, i)
}

func (s *CreateMTMVContext) MvPartition() IMvPartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMvPartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMvPartitionContext)
}

func (s *CreateMTMVContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTRIBUTED, 0)
}

func (s *CreateMTMVContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateMTMVContext) SimpleColumnDefs() ISimpleColumnDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleColumnDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleColumnDefsContext)
}

func (s *CreateMTMVContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *CreateMTMVContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateMTMVContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisParserHASH, 0)
}

func (s *CreateMTMVContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(DorisParserRANDOM, 0)
}

func (s *CreateMTMVContext) RefreshMethod() IRefreshMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshMethodContext)
}

func (s *CreateMTMVContext) RefreshTrigger() IRefreshTriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshTriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshTriggerContext)
}

func (s *CreateMTMVContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(DorisParserDUPLICATE, 0)
}

func (s *CreateMTMVContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisParserBUCKETS, 0)
}

func (s *CreateMTMVContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *CreateMTMVContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO, 0)
}

func (s *CreateMTMVContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateMTMV(s)
	}
}

func (s *CreateMTMVContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateMTMV(s)
	}
}

type ResumeMTMVContext struct {
	MaterailizedViewStatementContext
	mvName IMultipartIdentifierContext
}

func NewResumeMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ResumeMTMVContext {
	var p = new(ResumeMTMVContext)

	InitEmptyMaterailizedViewStatementContext(&p.MaterailizedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterailizedViewStatementContext))

	return p
}

func (s *ResumeMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *ResumeMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *ResumeMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumeMTMVContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisParserRESUME, 0)
}

func (s *ResumeMTMVContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *ResumeMTMVContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *ResumeMTMVContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *ResumeMTMVContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *ResumeMTMVContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ResumeMTMVContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterResumeMTMV(s)
	}
}

func (s *ResumeMTMVContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitResumeMTMV(s)
	}
}

type ShowCreateMTMVContext struct {
	MaterailizedViewStatementContext
	mvName IMultipartIdentifierContext
}

func NewShowCreateMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateMTMVContext {
	var p = new(ShowCreateMTMVContext)

	InitEmptyMaterailizedViewStatementContext(&p.MaterailizedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterailizedViewStatementContext))

	return p
}

func (s *ShowCreateMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *ShowCreateMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *ShowCreateMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateMTMVContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCreateMTMVContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowCreateMTMVContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *ShowCreateMTMVContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *ShowCreateMTMVContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateMTMVContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCreateMTMV(s)
	}
}

func (s *ShowCreateMTMVContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCreateMTMV(s)
	}
}

type CancelMTMVTaskContext struct {
	MaterailizedViewStatementContext
	taskId antlr.Token
	mvName IMultipartIdentifierContext
}

func NewCancelMTMVTaskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelMTMVTaskContext {
	var p = new(CancelMTMVTaskContext)

	InitEmptyMaterailizedViewStatementContext(&p.MaterailizedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterailizedViewStatementContext))

	return p
}

func (s *CancelMTMVTaskContext) GetTaskId() antlr.Token { return s.taskId }

func (s *CancelMTMVTaskContext) SetTaskId(v antlr.Token) { s.taskId = v }

func (s *CancelMTMVTaskContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *CancelMTMVTaskContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *CancelMTMVTaskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelMTMVTaskContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *CancelMTMVTaskContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *CancelMTMVTaskContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *CancelMTMVTaskContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisParserTASK, 0)
}

func (s *CancelMTMVTaskContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *CancelMTMVTaskContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *CancelMTMVTaskContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CancelMTMVTaskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCancelMTMVTask(s)
	}
}

func (s *CancelMTMVTaskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCancelMTMVTask(s)
	}
}

type PauseMTMVContext struct {
	MaterailizedViewStatementContext
	mvName IMultipartIdentifierContext
}

func NewPauseMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PauseMTMVContext {
	var p = new(PauseMTMVContext)

	InitEmptyMaterailizedViewStatementContext(&p.MaterailizedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterailizedViewStatementContext))

	return p
}

func (s *PauseMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *PauseMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *PauseMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PauseMTMVContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserPAUSE, 0)
}

func (s *PauseMTMVContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *PauseMTMVContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *PauseMTMVContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *PauseMTMVContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *PauseMTMVContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *PauseMTMVContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPauseMTMV(s)
	}
}

func (s *PauseMTMVContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPauseMTMV(s)
	}
}

type DropMTMVContext struct {
	MaterailizedViewStatementContext
	mvName    IMultipartIdentifierContext
	tableName IMultipartIdentifierContext
}

func NewDropMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropMTMVContext {
	var p = new(DropMTMVContext)

	InitEmptyMaterailizedViewStatementContext(&p.MaterailizedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterailizedViewStatementContext))

	return p
}

func (s *DropMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *DropMTMVContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DropMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *DropMTMVContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DropMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropMTMVContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropMTMVContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *DropMTMVContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *DropMTMVContext) AllMultipartIdentifier() []IMultipartIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultipartIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipartIdentifierContext); ok {
			tst[i] = t.(IMultipartIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DropMTMVContext) MultipartIdentifier(i int) IMultipartIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropMTMVContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropMTMVContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropMTMVContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *DropMTMVContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropMTMV(s)
	}
}

func (s *DropMTMVContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropMTMV(s)
	}
}

func (p *DorisParser) MaterailizedViewStatement() (localctx IMaterailizedViewStatementContext) {
	localctx = NewMaterailizedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, DorisParserRULE_materailizedViewStatement)
	var _la int

	p.SetState(679)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserCREATE:
		localctx = NewCreateMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(540)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(541)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(542)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(546)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(543)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(544)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(545)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(548)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateMTMVContext).mvName = _x
		}
		p.SetState(553)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(549)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(550)

				var _x = p.SimpleColumnDefs()

				localctx.(*CreateMTMVContext).cols = _x
			}
			{
				p.SetState(551)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(556)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserBUILD {
			{
				p.SetState(555)
				p.BuildMode()
			}

		}
		p.SetState(565)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserREFRESH {
			{
				p.SetState(558)
				p.Match(DorisParserREFRESH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(560)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserAUTO || _la == DorisParserCOMPLETE {
				{
					p.SetState(559)
					p.RefreshMethod()
				}

			}
			p.SetState(563)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserON {
				{
					p.SetState(562)
					p.RefreshTrigger()
				}

			}

		}
		p.SetState(572)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserDUPLICATE || _la == DorisParserKEY {
			p.SetState(568)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserDUPLICATE {
				{
					p.SetState(567)
					p.Match(DorisParserDUPLICATE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(570)
				p.Match(DorisParserKEY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(571)

				var _x = p.IdentifierList()

				localctx.(*CreateMTMVContext).keys = _x
			}

		}
		p.SetState(576)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(574)
				p.Match(DorisParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(575)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(584)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION {
			{
				p.SetState(578)
				p.Match(DorisParserPARTITION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(579)
				p.Match(DorisParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(580)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(581)
				p.MvPartition()
			}
			{
				p.SetState(582)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(597)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserDISTRIBUTED {
			{
				p.SetState(586)
				p.Match(DorisParserDISTRIBUTED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(587)
				p.Match(DorisParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(591)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserHASH:
				{
					p.SetState(588)
					p.Match(DorisParserHASH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(589)

					var _x = p.IdentifierList()

					localctx.(*CreateMTMVContext).hashKeys = _x
				}

			case DorisParserRANDOM:
				{
					p.SetState(590)
					p.Match(DorisParserRANDOM)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			p.SetState(595)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserBUCKETS {
				{
					p.SetState(593)
					p.Match(DorisParserBUCKETS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(594)
					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisParserAUTO || _la == DorisParserINTEGER_VALUE) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}

		}
		p.SetState(600)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(599)
				p.PropertyClause()
			}

		}
		{
			p.SetState(602)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(603)
			p.Query()
		}

	case DorisParserREFRESH:
		localctx = NewRefreshMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(605)
			p.Match(DorisParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(606)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(607)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(608)

			var _x = p.MultipartIdentifier()

			localctx.(*RefreshMTMVContext).mvName = _x
		}
		p.SetState(612)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserPARTITION, DorisParserPARTITIONS, DorisParserTEMPORARY:
			{
				p.SetState(609)
				p.PartitionSpec()
			}

		case DorisParserCOMPLETE:
			{
				p.SetState(610)
				p.Match(DorisParserCOMPLETE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserAUTO:
			{
				p.SetState(611)
				p.Match(DorisParserAUTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case DorisParserALTER:
		localctx = NewAlterMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(614)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(615)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(616)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(617)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterMTMVContext).mvName = _x
		}
		p.SetState(641)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserRENAME:
			{
				p.SetState(618)
				p.Match(DorisParserRENAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(619)

				var _x = p.Identifier()

				localctx.(*AlterMTMVContext).newName = _x
			}

		case DorisParserREFRESH:
			{
				p.SetState(620)
				p.Match(DorisParserREFRESH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(626)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(621)
					p.RefreshMethod()
				}

			case 2:
				{
					p.SetState(622)
					p.RefreshTrigger()
				}

			case 3:
				{
					p.SetState(623)
					p.RefreshMethod()
				}
				{
					p.SetState(624)
					p.RefreshTrigger()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		case DorisParserREPLACE:
			{
				p.SetState(628)
				p.Match(DorisParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(629)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(630)
				p.Match(DorisParserMATERIALIZED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(631)
				p.Match(DorisParserVIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(632)

				var _x = p.Identifier()

				localctx.(*AlterMTMVContext).newName = _x
			}
			p.SetState(634)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserPROPERTIES {
				{
					p.SetState(633)
					p.PropertyClause()
				}

			}

		case DorisParserSET:
			{
				p.SetState(636)
				p.Match(DorisParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(637)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(638)

				var _x = p.PropertyItemList()

				localctx.(*AlterMTMVContext).fileProperties = _x
			}
			{
				p.SetState(639)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case DorisParserDROP:
		localctx = NewDropMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(643)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(644)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(645)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(648)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(646)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(647)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(650)

			var _x = p.MultipartIdentifier()

			localctx.(*DropMTMVContext).mvName = _x
		}
		p.SetState(653)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserON {
			{
				p.SetState(651)
				p.Match(DorisParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(652)

				var _x = p.MultipartIdentifier()

				localctx.(*DropMTMVContext).tableName = _x
			}

		}

	case DorisParserPAUSE:
		localctx = NewPauseMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(655)
			p.Match(DorisParserPAUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(656)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(657)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(658)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(659)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(660)

			var _x = p.MultipartIdentifier()

			localctx.(*PauseMTMVContext).mvName = _x
		}

	case DorisParserRESUME:
		localctx = NewResumeMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(661)
			p.Match(DorisParserRESUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(662)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(663)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(664)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(665)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(666)

			var _x = p.MultipartIdentifier()

			localctx.(*ResumeMTMVContext).mvName = _x
		}

	case DorisParserCANCEL:
		localctx = NewCancelMTMVTaskContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(667)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(668)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(669)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(670)
			p.Match(DorisParserTASK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(671)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*CancelMTMVTaskContext).taskId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(672)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(673)

			var _x = p.MultipartIdentifier()

			localctx.(*CancelMTMVTaskContext).mvName = _x
		}

	case DorisParserSHOW:
		localctx = NewShowCreateMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(674)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(675)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(676)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(677)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(678)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateMTMVContext).mvName = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstraintStatementContext is an interface to support dynamic dispatch.
type IConstraintStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsConstraintStatementContext differentiates from other interfaces.
	IsConstraintStatementContext()
}

type ConstraintStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintStatementContext() *ConstraintStatementContext {
	var p = new(ConstraintStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_constraintStatement
	return p
}

func InitEmptyConstraintStatementContext(p *ConstraintStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_constraintStatement
}

func (*ConstraintStatementContext) IsConstraintStatementContext() {}

func NewConstraintStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintStatementContext {
	var p = new(ConstraintStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_constraintStatement

	return p
}

func (s *ConstraintStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintStatementContext) CopyAll(ctx *ConstraintStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ConstraintStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowConstraintContext struct {
	ConstraintStatementContext
	table IMultipartIdentifierContext
}

func NewShowConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowConstraintContext {
	var p = new(ShowConstraintContext)

	InitEmptyConstraintStatementContext(&p.ConstraintStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstraintStatementContext))

	return p
}

func (s *ShowConstraintContext) GetTable() IMultipartIdentifierContext { return s.table }

func (s *ShowConstraintContext) SetTable(v IMultipartIdentifierContext) { s.table = v }

func (s *ShowConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowConstraintContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowConstraintContext) CONSTRAINTS() antlr.TerminalNode {
	return s.GetToken(DorisParserCONSTRAINTS, 0)
}

func (s *ShowConstraintContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowConstraintContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowConstraint(s)
	}
}

func (s *ShowConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowConstraint(s)
	}
}

type DropConstraintContext struct {
	ConstraintStatementContext
	table          IMultipartIdentifierContext
	constraintName IErrorCapturingIdentifierContext
}

func NewDropConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropConstraintContext {
	var p = new(DropConstraintContext)

	InitEmptyConstraintStatementContext(&p.ConstraintStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstraintStatementContext))

	return p
}

func (s *DropConstraintContext) GetTable() IMultipartIdentifierContext { return s.table }

func (s *DropConstraintContext) GetConstraintName() IErrorCapturingIdentifierContext {
	return s.constraintName
}

func (s *DropConstraintContext) SetTable(v IMultipartIdentifierContext) { s.table = v }

func (s *DropConstraintContext) SetConstraintName(v IErrorCapturingIdentifierContext) {
	s.constraintName = v
}

func (s *DropConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropConstraintContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *DropConstraintContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *DropConstraintContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(DorisParserCONSTRAINT, 0)
}

func (s *DropConstraintContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropConstraintContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *DropConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropConstraint(s)
	}
}

func (s *DropConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropConstraint(s)
	}
}

type AddConstraintContext struct {
	ConstraintStatementContext
	table          IMultipartIdentifierContext
	constraintName IErrorCapturingIdentifierContext
}

func NewAddConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddConstraintContext {
	var p = new(AddConstraintContext)

	InitEmptyConstraintStatementContext(&p.ConstraintStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstraintStatementContext))

	return p
}

func (s *AddConstraintContext) GetTable() IMultipartIdentifierContext { return s.table }

func (s *AddConstraintContext) GetConstraintName() IErrorCapturingIdentifierContext {
	return s.constraintName
}

func (s *AddConstraintContext) SetTable(v IMultipartIdentifierContext) { s.table = v }

func (s *AddConstraintContext) SetConstraintName(v IErrorCapturingIdentifierContext) {
	s.constraintName = v
}

func (s *AddConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddConstraintContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AddConstraintContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AddConstraintContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(DorisParserCONSTRAINT, 0)
}

func (s *AddConstraintContext) Constraint() IConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintContext)
}

func (s *AddConstraintContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AddConstraintContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *AddConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddConstraint(s)
	}
}

func (s *AddConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddConstraint(s)
	}
}

func (p *DorisParser) ConstraintStatement() (localctx IConstraintStatementContext) {
	localctx = NewConstraintStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, DorisParserRULE_constraintStatement)
	p.SetState(700)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAddConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(681)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(682)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(683)

			var _x = p.MultipartIdentifier()

			localctx.(*AddConstraintContext).table = _x
		}
		{
			p.SetState(684)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(685)
			p.Match(DorisParserCONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(686)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*AddConstraintContext).constraintName = _x
		}
		{
			p.SetState(687)
			p.Constraint()
		}

	case 2:
		localctx = NewDropConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(689)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(690)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(691)

			var _x = p.MultipartIdentifier()

			localctx.(*DropConstraintContext).table = _x
		}
		{
			p.SetState(692)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(693)
			p.Match(DorisParserCONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(694)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*DropConstraintContext).constraintName = _x
		}

	case 3:
		localctx = NewShowConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(696)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(697)
			p.Match(DorisParserCONSTRAINTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(698)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(699)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowConstraintContext).table = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedDmlStatementContext is an interface to support dynamic dispatch.
type ISupportedDmlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedDmlStatementContext differentiates from other interfaces.
	IsSupportedDmlStatementContext()
}

type SupportedDmlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedDmlStatementContext() *SupportedDmlStatementContext {
	var p = new(SupportedDmlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedDmlStatement
	return p
}

func InitEmptySupportedDmlStatementContext(p *SupportedDmlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedDmlStatement
}

func (*SupportedDmlStatementContext) IsSupportedDmlStatementContext() {}

func NewSupportedDmlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedDmlStatementContext {
	var p = new(SupportedDmlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedDmlStatement

	return p
}

func (s *SupportedDmlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedDmlStatementContext) CopyAll(ctx *SupportedDmlStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedDmlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedDmlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type InsertTableContext struct {
	SupportedDmlStatementContext
	tableName IMultipartIdentifierContext
	tableId   antlr.Token
	labelName IIdentifierContext
	cols      IIdentifierListContext
	hints     IIdentifierSeqContext
}

func NewInsertTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertTableContext {
	var p = new(InsertTableContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *InsertTableContext) GetTableId() antlr.Token { return s.tableId }

func (s *InsertTableContext) SetTableId(v antlr.Token) { s.tableId = v }

func (s *InsertTableContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *InsertTableContext) GetLabelName() IIdentifierContext { return s.labelName }

func (s *InsertTableContext) GetCols() IIdentifierListContext { return s.cols }

func (s *InsertTableContext) GetHints() IIdentifierSeqContext { return s.hints }

func (s *InsertTableContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *InsertTableContext) SetLabelName(v IIdentifierContext) { s.labelName = v }

func (s *InsertTableContext) SetCols(v IIdentifierListContext) { s.cols = v }

func (s *InsertTableContext) SetHints(v IIdentifierSeqContext) { s.hints = v }

func (s *InsertTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertTableContext) INSERT() antlr.TerminalNode {
	return s.GetToken(DorisParserINSERT, 0)
}

func (s *InsertTableContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *InsertTableContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserINTO, 0)
}

func (s *InsertTableContext) OVERWRITE() antlr.TerminalNode {
	return s.GetToken(DorisParserOVERWRITE, 0)
}

func (s *InsertTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *InsertTableContext) DORIS_INTERNAL_TABLE_ID() antlr.TerminalNode {
	return s.GetToken(DorisParserDORIS_INTERNAL_TABLE_ID, 0)
}

func (s *InsertTableContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *InsertTableContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *InsertTableContext) Explain() IExplainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainContext)
}

func (s *InsertTableContext) Cte() ICteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteContext)
}

func (s *InsertTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *InsertTableContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *InsertTableContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *InsertTableContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *InsertTableContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisParserLABEL, 0)
}

func (s *InsertTableContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACKET, 0)
}

func (s *InsertTableContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACKET, 0)
}

func (s *InsertTableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InsertTableContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *InsertTableContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *InsertTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterInsertTable(s)
	}
}

func (s *InsertTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitInsertTable(s)
	}
}

type LoadContext struct {
	SupportedDmlStatementContext
	lableName  IIdentifierContext
	_dataDesc  IDataDescContext
	dataDescs  []IDataDescContext
	properties IPropertyItemListContext
}

func NewLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LoadContext {
	var p = new(LoadContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *LoadContext) GetLableName() IIdentifierContext { return s.lableName }

func (s *LoadContext) Get_dataDesc() IDataDescContext { return s._dataDesc }

func (s *LoadContext) GetProperties() IPropertyItemListContext { return s.properties }

func (s *LoadContext) SetLableName(v IIdentifierContext) { s.lableName = v }

func (s *LoadContext) Set_dataDesc(v IDataDescContext) { s._dataDesc = v }

func (s *LoadContext) SetProperties(v IPropertyItemListContext) { s.properties = v }

func (s *LoadContext) GetDataDescs() []IDataDescContext { return s.dataDescs }

func (s *LoadContext) SetDataDescs(v []IDataDescContext) { s.dataDescs = v }

func (s *LoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *LoadContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisParserLABEL, 0)
}

func (s *LoadContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserLEFT_PAREN)
}

func (s *LoadContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, i)
}

func (s *LoadContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserRIGHT_PAREN)
}

func (s *LoadContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, i)
}

func (s *LoadContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LoadContext) AllDataDesc() []IDataDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataDescContext); ok {
			len++
		}
	}

	tst := make([]IDataDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataDescContext); ok {
			tst[i] = t.(IDataDescContext)
			i++
		}
	}

	return tst
}

func (s *LoadContext) DataDesc(i int) IDataDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescContext)
}

func (s *LoadContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *LoadContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *LoadContext) WithRemoteStorageSystem() IWithRemoteStorageSystemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithRemoteStorageSystemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithRemoteStorageSystemContext)
}

func (s *LoadContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *LoadContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *LoadContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *LoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLoad(s)
	}
}

func (s *LoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLoad(s)
	}
}

type UpdateContext struct {
	SupportedDmlStatementContext
	tableName IMultipartIdentifierContext
}

func NewUpdateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UpdateContext {
	var p = new(UpdateContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *UpdateContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *UpdateContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *UpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(DorisParserUPDATE, 0)
}

func (s *UpdateContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *UpdateContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *UpdateContext) UpdateAssignmentSeq() IUpdateAssignmentSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateAssignmentSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateAssignmentSeqContext)
}

func (s *UpdateContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *UpdateContext) Explain() IExplainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainContext)
}

func (s *UpdateContext) Cte() ICteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteContext)
}

func (s *UpdateContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *UpdateContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *UpdateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUpdate(s)
	}
}

func (s *UpdateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUpdate(s)
	}
}

type DeleteContext struct {
	SupportedDmlStatementContext
	tableName IMultipartIdentifierContext
}

func NewDeleteContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeleteContext {
	var p = new(DeleteContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *DeleteContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DeleteContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisParserDELETE, 0)
}

func (s *DeleteContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *DeleteContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *DeleteContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DeleteContext) Explain() IExplainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainContext)
}

func (s *DeleteContext) Cte() ICteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteContext)
}

func (s *DeleteContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *DeleteContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserUSING, 0)
}

func (s *DeleteContext) Relations() IRelationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationsContext)
}

func (s *DeleteContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *DeleteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDelete(s)
	}
}

func (s *DeleteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDelete(s)
	}
}

type ExportContext struct {
	SupportedDmlStatementContext
	tableName IMultipartIdentifierContext
	partition IIdentifierListContext
	filePath  antlr.Token
}

func NewExportContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExportContext {
	var p = new(ExportContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *ExportContext) GetFilePath() antlr.Token { return s.filePath }

func (s *ExportContext) SetFilePath(v antlr.Token) { s.filePath = v }

func (s *ExportContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ExportContext) GetPartition() IIdentifierListContext { return s.partition }

func (s *ExportContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ExportContext) SetPartition(v IIdentifierListContext) { s.partition = v }

func (s *ExportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(DorisParserEXPORT, 0)
}

func (s *ExportContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *ExportContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *ExportContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ExportContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ExportContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *ExportContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *ExportContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ExportContext) WithRemoteStorageSystem() IWithRemoteStorageSystemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithRemoteStorageSystemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithRemoteStorageSystemContext)
}

func (s *ExportContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ExportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterExport(s)
	}
}

func (s *ExportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitExport(s)
	}
}

type MysqlLoadContext struct {
	SupportedDmlStatementContext
	properties IPropertyItemListContext
}

func NewMysqlLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MysqlLoadContext {
	var p = new(MysqlLoadContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *MysqlLoadContext) GetProperties() IPropertyItemListContext { return s.properties }

func (s *MysqlLoadContext) SetProperties(v IPropertyItemListContext) { s.properties = v }

func (s *MysqlLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MysqlLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *MysqlLoadContext) MysqlDataDesc() IMysqlDataDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMysqlDataDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMysqlDataDescContext)
}

func (s *MysqlLoadContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *MysqlLoadContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *MysqlLoadContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *MysqlLoadContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *MysqlLoadContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *MysqlLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMysqlLoad(s)
	}
}

func (s *MysqlLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMysqlLoad(s)
	}
}

func (p *DorisParser) SupportedDmlStatement() (localctx ISupportedDmlStatementContext) {
	localctx = NewSupportedDmlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, DorisParserRULE_supportedDmlStatement)
	var _la int

	p.SetState(832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext()) {
	case 1:
		localctx = NewInsertTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(703)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&34359738371) != 0 {
			{
				p.SetState(702)
				p.Explain()
			}

		}
		p.SetState(706)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(705)
				p.Cte()
			}

		}
		{
			p.SetState(708)
			p.Match(DorisParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(712)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserINTO:
			{
				p.SetState(709)
				p.Match(DorisParserINTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserOVERWRITE:
			{
				p.SetState(710)
				p.Match(DorisParserOVERWRITE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(711)
				p.Match(DorisParserTABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(719)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(714)

				var _x = p.MultipartIdentifier()

				localctx.(*InsertTableContext).tableName = _x
			}

		case 2:
			{
				p.SetState(715)
				p.Match(DorisParserDORIS_INTERNAL_TABLE_ID)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(716)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(717)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*InsertTableContext).tableId = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(718)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(722)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(721)
				p.PartitionSpec()
			}

		}
		p.SetState(727)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(724)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(725)
				p.Match(DorisParserLABEL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(726)

				var _x = p.Identifier()

				localctx.(*InsertTableContext).labelName = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(730)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(729)

				var _x = p.IdentifierList()

				localctx.(*InsertTableContext).cols = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(736)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_BRACKET {
			{
				p.SetState(732)
				p.Match(DorisParserLEFT_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(733)

				var _x = p.IdentifierSeq()

				localctx.(*InsertTableContext).hints = _x
			}
			{
				p.SetState(734)
				p.Match(DorisParserRIGHT_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(738)
			p.Query()
		}

	case 2:
		localctx = NewUpdateContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(740)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&34359738371) != 0 {
			{
				p.SetState(739)
				p.Explain()
			}

		}
		p.SetState(743)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(742)
				p.Cte()
			}

		}
		{
			p.SetState(745)
			p.Match(DorisParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(746)

			var _x = p.MultipartIdentifier()

			localctx.(*UpdateContext).tableName = _x
		}
		{
			p.SetState(747)
			p.TableAlias()
		}
		{
			p.SetState(748)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(749)
			p.UpdateAssignmentSeq()
		}
		p.SetState(751)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(750)
				p.FromClause()
			}

		}
		p.SetState(754)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWHERE {
			{
				p.SetState(753)
				p.WhereClause()
			}

		}

	case 3:
		localctx = NewDeleteContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(757)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&34359738371) != 0 {
			{
				p.SetState(756)
				p.Explain()
			}

		}
		p.SetState(760)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(759)
				p.Cte()
			}

		}
		{
			p.SetState(762)
			p.Match(DorisParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(763)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(764)

			var _x = p.MultipartIdentifier()

			localctx.(*DeleteContext).tableName = _x
		}
		p.SetState(766)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(765)
				p.PartitionSpec()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(768)
			p.TableAlias()
		}
		p.SetState(771)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserUSING {
			{
				p.SetState(769)
				p.Match(DorisParserUSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(770)
				p.Relations()
			}

		}
		p.SetState(774)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWHERE {
			{
				p.SetState(773)
				p.WhereClause()
			}

		}

	case 4:
		localctx = NewLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(776)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(777)
			p.Match(DorisParserLABEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(778)

			var _x = p.Identifier()

			localctx.(*LoadContext).lableName = _x
		}
		{
			p.SetState(779)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(780)

			var _x = p.DataDesc()

			localctx.(*LoadContext)._dataDesc = _x
		}
		localctx.(*LoadContext).dataDescs = append(localctx.(*LoadContext).dataDescs, localctx.(*LoadContext)._dataDesc)
		p.SetState(785)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(781)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(782)

				var _x = p.DataDesc()

				localctx.(*LoadContext)._dataDesc = _x
			}
			localctx.(*LoadContext).dataDescs = append(localctx.(*LoadContext).dataDescs, localctx.(*LoadContext)._dataDesc)

			p.SetState(787)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(788)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(790)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(789)
				p.WithRemoteStorageSystem()
			}

		}
		p.SetState(797)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(792)
				p.Match(DorisParserPROPERTIES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(793)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(794)

				var _x = p.PropertyItemList()

				localctx.(*LoadContext).properties = _x
			}
			{
				p.SetState(795)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(800)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(799)
				p.CommentSpec()
			}

		}

	case 5:
		localctx = NewMysqlLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(802)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(803)
			p.MysqlDataDesc()
		}
		p.SetState(809)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(804)
				p.Match(DorisParserPROPERTIES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(805)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(806)

				var _x = p.PropertyItemList()

				localctx.(*MysqlLoadContext).properties = _x
			}
			{
				p.SetState(807)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(812)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(811)
				p.CommentSpec()
			}

		}

	case 6:
		localctx = NewExportContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(814)
			p.Match(DorisParserEXPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(815)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(816)

			var _x = p.MultipartIdentifier()

			localctx.(*ExportContext).tableName = _x
		}
		p.SetState(819)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION {
			{
				p.SetState(817)
				p.Match(DorisParserPARTITION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(818)

				var _x = p.IdentifierList()

				localctx.(*ExportContext).partition = _x
			}

		}
		p.SetState(822)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWHERE {
			{
				p.SetState(821)
				p.WhereClause()
			}

		}
		{
			p.SetState(824)
			p.Match(DorisParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(825)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ExportContext).filePath = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(827)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(826)
				p.PropertyClause()
			}

		}
		p.SetState(830)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(829)
				p.WithRemoteStorageSystem()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedCreateStatementContext is an interface to support dynamic dispatch.
type ISupportedCreateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedCreateStatementContext differentiates from other interfaces.
	IsSupportedCreateStatementContext()
}

type SupportedCreateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedCreateStatementContext() *SupportedCreateStatementContext {
	var p = new(SupportedCreateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedCreateStatement
	return p
}

func InitEmptySupportedCreateStatementContext(p *SupportedCreateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedCreateStatement
}

func (*SupportedCreateStatementContext) IsSupportedCreateStatementContext() {}

func NewSupportedCreateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedCreateStatementContext {
	var p = new(SupportedCreateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedCreateStatement

	return p
}

func (s *SupportedCreateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedCreateStatementContext) CopyAll(ctx *SupportedCreateStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedCreateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedCreateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CreateTableContext struct {
	SupportedCreateStatementContext
	name          IMultipartIdentifierContext
	ctasCols      IIdentifierListContext
	engine        IIdentifierContext
	keys          IIdentifierListContext
	clusterKeys   IIdentifierListContext
	partition     IPartitionTableContext
	hashKeys      IIdentifierListContext
	autoBucket    antlr.Token
	properties    IPropertyClauseContext
	extProperties IPropertyClauseContext
}

func NewCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableContext {
	var p = new(CreateTableContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateTableContext) GetAutoBucket() antlr.Token { return s.autoBucket }

func (s *CreateTableContext) SetAutoBucket(v antlr.Token) { s.autoBucket = v }

func (s *CreateTableContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CreateTableContext) GetCtasCols() IIdentifierListContext { return s.ctasCols }

func (s *CreateTableContext) GetEngine() IIdentifierContext { return s.engine }

func (s *CreateTableContext) GetKeys() IIdentifierListContext { return s.keys }

func (s *CreateTableContext) GetClusterKeys() IIdentifierListContext { return s.clusterKeys }

func (s *CreateTableContext) GetPartition() IPartitionTableContext { return s.partition }

func (s *CreateTableContext) GetHashKeys() IIdentifierListContext { return s.hashKeys }

func (s *CreateTableContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateTableContext) GetExtProperties() IPropertyClauseContext { return s.extProperties }

func (s *CreateTableContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CreateTableContext) SetCtasCols(v IIdentifierListContext) { s.ctasCols = v }

func (s *CreateTableContext) SetEngine(v IIdentifierContext) { s.engine = v }

func (s *CreateTableContext) SetKeys(v IIdentifierListContext) { s.keys = v }

func (s *CreateTableContext) SetClusterKeys(v IIdentifierListContext) { s.clusterKeys = v }

func (s *CreateTableContext) SetPartition(v IPartitionTableContext) { s.partition = v }

func (s *CreateTableContext) SetHashKeys(v IIdentifierListContext) { s.hashKeys = v }

func (s *CreateTableContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateTableContext) SetExtProperties(v IPropertyClauseContext) { s.extProperties = v }

func (s *CreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *CreateTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateTableContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisParserEXTERNAL, 0)
}

func (s *CreateTableContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateTableContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateTableContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(DorisParserENGINE, 0)
}

func (s *CreateTableContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *CreateTableContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserKEY, 0)
}

func (s *CreateTableContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *CreateTableContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateTableContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTRIBUTED, 0)
}

func (s *CreateTableContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(DorisParserBY)
}

func (s *CreateTableContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserBY, i)
}

func (s *CreateTableContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *CreateTableContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserLEFT_PAREN)
}

func (s *CreateTableContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, i)
}

func (s *CreateTableContext) RollupDefs() IRollupDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupDefsContext)
}

func (s *CreateTableContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserRIGHT_PAREN)
}

func (s *CreateTableContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, i)
}

func (s *CreateTableContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserBROKER, 0)
}

func (s *CreateTableContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *CreateTableContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateTableContext) ColumnDefs() IColumnDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefsContext)
}

func (s *CreateTableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateTableContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(DorisParserAGGREGATE, 0)
}

func (s *CreateTableContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(DorisParserUNIQUE, 0)
}

func (s *CreateTableContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(DorisParserDUPLICATE, 0)
}

func (s *CreateTableContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateTableContext) PartitionTable() IPartitionTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionTableContext)
}

func (s *CreateTableContext) AllPropertyClause() []IPropertyClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			len++
		}
	}

	tst := make([]IPropertyClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyClauseContext); ok {
			tst[i] = t.(IPropertyClauseContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableContext) PropertyClause(i int) IPropertyClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateTableContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisParserHASH, 0)
}

func (s *CreateTableContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(DorisParserRANDOM, 0)
}

func (s *CreateTableContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(DorisParserCLUSTER, 0)
}

func (s *CreateTableContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisParserBUCKETS, 0)
}

func (s *CreateTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *CreateTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *CreateTableContext) IndexDefs() IIndexDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexDefsContext)
}

func (s *CreateTableContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *CreateTableContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO, 0)
}

func (s *CreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateTable(s)
	}
}

func (s *CreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateTable(s)
	}
}

type CreateTableLikeContext struct {
	SupportedCreateStatementContext
	name         IMultipartIdentifierContext
	existedTable IMultipartIdentifierContext
	rollupNames  IIdentifierListContext
}

func NewCreateTableLikeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableLikeContext {
	var p = new(CreateTableLikeContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateTableLikeContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CreateTableLikeContext) GetExistedTable() IMultipartIdentifierContext { return s.existedTable }

func (s *CreateTableLikeContext) GetRollupNames() IIdentifierListContext { return s.rollupNames }

func (s *CreateTableLikeContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CreateTableLikeContext) SetExistedTable(v IMultipartIdentifierContext) { s.existedTable = v }

func (s *CreateTableLikeContext) SetRollupNames(v IIdentifierListContext) { s.rollupNames = v }

func (s *CreateTableLikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableLikeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateTableLikeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *CreateTableLikeContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *CreateTableLikeContext) AllMultipartIdentifier() []IMultipartIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultipartIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipartIdentifierContext); ok {
			tst[i] = t.(IMultipartIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableLikeContext) MultipartIdentifier(i int) IMultipartIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateTableLikeContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisParserEXTERNAL, 0)
}

func (s *CreateTableLikeContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateTableLikeContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateTableLikeContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateTableLikeContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *CreateTableLikeContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *CreateTableLikeContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateTableLikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateTableLike(s)
	}
}

func (s *CreateTableLikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateTableLike(s)
	}
}

type CreateViewContext struct {
	SupportedCreateStatementContext
	name IMultipartIdentifierContext
	cols ISimpleColumnDefsContext
}

func NewCreateViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateViewContext {
	var p = new(CreateViewContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateViewContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CreateViewContext) GetCols() ISimpleColumnDefsContext { return s.cols }

func (s *CreateViewContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CreateViewContext) SetCols(v ISimpleColumnDefsContext) { s.cols = v }

func (s *CreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *CreateViewContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *CreateViewContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateViewContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateViewContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateViewContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateViewContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateViewContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CreateViewContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CreateViewContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *CreateViewContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateViewContext) SimpleColumnDefs() ISimpleColumnDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleColumnDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleColumnDefsContext)
}

func (s *CreateViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateView(s)
	}
}

func (s *CreateViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateView(s)
	}
}

type CreateRowPolicyContext struct {
	SupportedCreateStatementContext
	name     IIdentifierContext
	table    IMultipartIdentifierContext
	type_    antlr.Token
	user     IUserIdentifyContext
	roleName IIdentifierContext
}

func NewCreateRowPolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateRowPolicyContext {
	var p = new(CreateRowPolicyContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateRowPolicyContext) GetType_() antlr.Token { return s.type_ }

func (s *CreateRowPolicyContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *CreateRowPolicyContext) GetName() IIdentifierContext { return s.name }

func (s *CreateRowPolicyContext) GetTable() IMultipartIdentifierContext { return s.table }

func (s *CreateRowPolicyContext) GetUser() IUserIdentifyContext { return s.user }

func (s *CreateRowPolicyContext) GetRoleName() IIdentifierContext { return s.roleName }

func (s *CreateRowPolicyContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateRowPolicyContext) SetTable(v IMultipartIdentifierContext) { s.table = v }

func (s *CreateRowPolicyContext) SetUser(v IUserIdentifyContext) { s.user = v }

func (s *CreateRowPolicyContext) SetRoleName(v IIdentifierContext) { s.roleName = v }

func (s *CreateRowPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRowPolicyContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateRowPolicyContext) ROW() antlr.TerminalNode {
	return s.GetToken(DorisParserROW, 0)
}

func (s *CreateRowPolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *CreateRowPolicyContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *CreateRowPolicyContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *CreateRowPolicyContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *CreateRowPolicyContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserUSING, 0)
}

func (s *CreateRowPolicyContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CreateRowPolicyContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *CreateRowPolicyContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CreateRowPolicyContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateRowPolicyContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRowPolicyContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateRowPolicyContext) RESTRICTIVE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESTRICTIVE, 0)
}

func (s *CreateRowPolicyContext) PERMISSIVE() antlr.TerminalNode {
	return s.GetToken(DorisParserPERMISSIVE, 0)
}

func (s *CreateRowPolicyContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *CreateRowPolicyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateRowPolicyContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateRowPolicyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateRowPolicyContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *CreateRowPolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateRowPolicy(s)
	}
}

func (s *CreateRowPolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateRowPolicy(s)
	}
}

func (p *DorisParser) SupportedCreateStatement() (localctx ISupportedCreateStatementContext) {
	localctx = NewSupportedCreateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, DorisParserRULE_supportedCreateStatement)
	var _la int

	p.SetState(982)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(834)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(836)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserEXTERNAL {
			{
				p.SetState(835)
				p.Match(DorisParserEXTERNAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(838)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(842)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(839)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(840)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(841)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(844)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateTableContext).name = _x
		}
		p.SetState(859)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext()) {
		case 1:
			p.SetState(846)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserLEFT_PAREN {
				{
					p.SetState(845)

					var _x = p.IdentifierList()

					localctx.(*CreateTableContext).ctasCols = _x
				}

			}

		case 2:
			{
				p.SetState(848)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(849)
				p.ColumnDefs()
			}
			p.SetState(852)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(850)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(851)
					p.IndexDefs()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			p.SetState(855)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserCOMMA {
				{
					p.SetState(854)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(857)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(864)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserENGINE {
			{
				p.SetState(861)
				p.Match(DorisParserENGINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(862)
				p.Match(DorisParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(863)

				var _x = p.Identifier()

				localctx.(*CreateTableContext).engine = _x
			}

		}
		p.SetState(874)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAGGREGATE || _la == DorisParserDUPLICATE || _la == DorisParserUNIQUE {
			{
				p.SetState(866)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserAGGREGATE || _la == DorisParserDUPLICATE || _la == DorisParserUNIQUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(867)
				p.Match(DorisParserKEY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(868)

				var _x = p.IdentifierList()

				localctx.(*CreateTableContext).keys = _x
			}
			p.SetState(872)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserCLUSTER {
				{
					p.SetState(869)
					p.Match(DorisParserCLUSTER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(870)
					p.Match(DorisParserBY)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(871)

					var _x = p.IdentifierList()

					localctx.(*CreateTableContext).clusterKeys = _x
				}

			}

		}
		p.SetState(878)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(876)
				p.Match(DorisParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(877)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(881)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAUTO || _la == DorisParserPARTITION {
			{
				p.SetState(880)

				var _x = p.PartitionTable()

				localctx.(*CreateTableContext).partition = _x
			}

		}
		p.SetState(897)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserDISTRIBUTED {
			{
				p.SetState(883)
				p.Match(DorisParserDISTRIBUTED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(884)
				p.Match(DorisParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(888)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserHASH:
				{
					p.SetState(885)
					p.Match(DorisParserHASH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(886)

					var _x = p.IdentifierList()

					localctx.(*CreateTableContext).hashKeys = _x
				}

			case DorisParserRANDOM:
				{
					p.SetState(887)
					p.Match(DorisParserRANDOM)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			p.SetState(895)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserBUCKETS {
				{
					p.SetState(890)
					p.Match(DorisParserBUCKETS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(893)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DorisParserINTEGER_VALUE:
					{
						p.SetState(891)
						p.Match(DorisParserINTEGER_VALUE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case DorisParserAUTO:
					{
						p.SetState(892)

						var _m = p.Match(DorisParserAUTO)

						localctx.(*CreateTableContext).autoBucket = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			}

		}
		p.SetState(904)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserROLLUP {
			{
				p.SetState(899)
				p.Match(DorisParserROLLUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(900)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(901)
				p.RollupDefs()
			}
			{
				p.SetState(902)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(907)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(906)

				var _x = p.PropertyClause()

				localctx.(*CreateTableContext).properties = _x
			}

		}
		p.SetState(911)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserBROKER {
			{
				p.SetState(909)
				p.Match(DorisParserBROKER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(910)

				var _x = p.PropertyClause()

				localctx.(*CreateTableContext).extProperties = _x
			}

		}
		p.SetState(915)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAS {
			{
				p.SetState(913)
				p.Match(DorisParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(914)
				p.Query()
			}

		}

	case 2:
		localctx = NewCreateViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(917)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(918)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(922)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(919)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(920)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(921)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(924)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateViewContext).name = _x
		}
		p.SetState(929)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(925)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(926)

				var _x = p.SimpleColumnDefs()

				localctx.(*CreateViewContext).cols = _x
			}
			{
				p.SetState(927)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(933)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(931)
				p.Match(DorisParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(932)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(935)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(936)
			p.Query()
		}

	case 3:
		localctx = NewCreateTableLikeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(938)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(940)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserEXTERNAL {
			{
				p.SetState(939)
				p.Match(DorisParserEXTERNAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(942)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(946)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(943)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(944)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(945)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(948)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateTableLikeContext).name = _x
		}
		{
			p.SetState(949)
			p.Match(DorisParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(950)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateTableLikeContext).existedTable = _x
		}
		p.SetState(956)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(951)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(952)
				p.Match(DorisParserROLLUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(954)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserLEFT_PAREN {
				{
					p.SetState(953)

					var _x = p.IdentifierList()

					localctx.(*CreateTableLikeContext).rollupNames = _x
				}

			}

		}

	case 4:
		localctx = NewCreateRowPolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(958)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(959)
			p.Match(DorisParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(960)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(964)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(961)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(962)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(963)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(966)

			var _x = p.Identifier()

			localctx.(*CreateRowPolicyContext).name = _x
		}
		{
			p.SetState(967)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(968)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateRowPolicyContext).table = _x
		}
		{
			p.SetState(969)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(970)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateRowPolicyContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserPERMISSIVE || _la == DorisParserRESTRICTIVE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateRowPolicyContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(971)
			p.Match(DorisParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(975)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADDDATE, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserARRAY_RANGE, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATE_ADD, DorisParserDATE_CEIL, DorisParserDATE_DIFF, DorisParserDATE_FLOOR, DorisParserDATE_SUB, DorisParserDATEADD, DorisParserDATEDIFF, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS_ADD, DorisParserDAYS_SUB, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSEQUENCE, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUBDATE, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTIMESTAMPADD, DorisParserTIMESTAMPDIFF, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(972)

				var _x = p.UserIdentify()

				localctx.(*CreateRowPolicyContext).user = _x
			}

		case DorisParserROLE:
			{
				p.SetState(973)
				p.Match(DorisParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(974)

				var _x = p.Identifier()

				localctx.(*CreateRowPolicyContext).roleName = _x
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(977)
			p.Match(DorisParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(978)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(979)
			p.booleanExpression(0)
		}
		{
			p.SetState(980)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedAlterStatementContext is an interface to support dynamic dispatch.
type ISupportedAlterStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedAlterStatementContext differentiates from other interfaces.
	IsSupportedAlterStatementContext()
}

type SupportedAlterStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedAlterStatementContext() *SupportedAlterStatementContext {
	var p = new(SupportedAlterStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedAlterStatement
	return p
}

func InitEmptySupportedAlterStatementContext(p *SupportedAlterStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedAlterStatement
}

func (*SupportedAlterStatementContext) IsSupportedAlterStatementContext() {}

func NewSupportedAlterStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedAlterStatementContext {
	var p = new(SupportedAlterStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedAlterStatement

	return p
}

func (s *SupportedAlterStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedAlterStatementContext) CopyAll(ctx *SupportedAlterStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedAlterStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedAlterStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AlterViewContext struct {
	SupportedAlterStatementContext
	name IMultipartIdentifierContext
	cols ISimpleColumnDefsContext
}

func NewAlterViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterViewContext {
	var p = new(AlterViewContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterViewContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterViewContext) GetCols() ISimpleColumnDefsContext { return s.cols }

func (s *AlterViewContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterViewContext) SetCols(v ISimpleColumnDefsContext) { s.cols = v }

func (s *AlterViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterViewContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *AlterViewContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *AlterViewContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *AlterViewContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterViewContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterViewContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterViewContext) SimpleColumnDefs() ISimpleColumnDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleColumnDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleColumnDefsContext)
}

func (s *AlterViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterView(s)
	}
}

func (s *AlterViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterView(s)
	}
}

type AlterStorageVaultContext struct {
	SupportedAlterStatementContext
	name       IMultipartIdentifierContext
	properties IPropertyClauseContext
}

func NewAlterStorageVaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterStorageVaultContext {
	var p = new(AlterStorageVaultContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterStorageVaultContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterStorageVaultContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterStorageVaultContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterStorageVaultContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterStorageVaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStorageVaultContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterStorageVaultContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *AlterStorageVaultContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULT, 0)
}

func (s *AlterStorageVaultContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterStorageVaultContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterStorageVaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterStorageVault(s)
	}
}

func (s *AlterStorageVaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterStorageVault(s)
	}
}

func (p *DorisParser) SupportedAlterStatement() (localctx ISupportedAlterStatementContext) {
	localctx = NewSupportedAlterStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, DorisParserRULE_supportedAlterStatement)
	var _la int

	p.SetState(1002)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAlterViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(984)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(985)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(986)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterViewContext).name = _x
		}
		p.SetState(991)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(987)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(988)

				var _x = p.SimpleColumnDefs()

				localctx.(*AlterViewContext).cols = _x
			}
			{
				p.SetState(989)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(993)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(994)
			p.Query()
		}

	case 2:
		localctx = NewAlterStorageVaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(996)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(997)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(998)
			p.Match(DorisParserVAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(999)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterStorageVaultContext).name = _x
		}
		{
			p.SetState(1000)

			var _x = p.PropertyClause()

			localctx.(*AlterStorageVaultContext).properties = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedDropStatementContext is an interface to support dynamic dispatch.
type ISupportedDropStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedDropStatementContext differentiates from other interfaces.
	IsSupportedDropStatementContext()
}

type SupportedDropStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedDropStatementContext() *SupportedDropStatementContext {
	var p = new(SupportedDropStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedDropStatement
	return p
}

func InitEmptySupportedDropStatementContext(p *SupportedDropStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedDropStatement
}

func (*SupportedDropStatementContext) IsSupportedDropStatementContext() {}

func NewSupportedDropStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedDropStatementContext {
	var p = new(SupportedDropStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedDropStatement

	return p
}

func (s *SupportedDropStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedDropStatementContext) CopyAll(ctx *SupportedDropStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedDropStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedDropStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DropCatalogRecycleBinContext struct {
	SupportedDropStatementContext
	idType antlr.Token
	id     antlr.Token
}

func NewDropCatalogRecycleBinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropCatalogRecycleBinContext {
	var p = new(DropCatalogRecycleBinContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropCatalogRecycleBinContext) GetIdType() antlr.Token { return s.idType }

func (s *DropCatalogRecycleBinContext) GetId() antlr.Token { return s.id }

func (s *DropCatalogRecycleBinContext) SetIdType(v antlr.Token) { s.idType = v }

func (s *DropCatalogRecycleBinContext) SetId(v antlr.Token) { s.id = v }

func (s *DropCatalogRecycleBinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropCatalogRecycleBinContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropCatalogRecycleBinContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *DropCatalogRecycleBinContext) RECYCLE() antlr.TerminalNode {
	return s.GetToken(DorisParserRECYCLE, 0)
}

func (s *DropCatalogRecycleBinContext) BIN() antlr.TerminalNode {
	return s.GetToken(DorisParserBIN, 0)
}

func (s *DropCatalogRecycleBinContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserWHERE, 0)
}

func (s *DropCatalogRecycleBinContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *DropCatalogRecycleBinContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *DropCatalogRecycleBinContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *DropCatalogRecycleBinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropCatalogRecycleBin(s)
	}
}

func (s *DropCatalogRecycleBinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropCatalogRecycleBin(s)
	}
}

func (p *DorisParser) SupportedDropStatement() (localctx ISupportedDropStatementContext) {
	localctx = NewSupportedDropStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, DorisParserRULE_supportedDropStatement)
	localctx = NewDropCatalogRecycleBinContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1004)
		p.Match(DorisParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1005)
		p.Match(DorisParserCATALOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1006)
		p.Match(DorisParserRECYCLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1007)
		p.Match(DorisParserBIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1008)
		p.Match(DorisParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1009)

		var _m = p.Match(DorisParserSTRING_LITERAL)

		localctx.(*DropCatalogRecycleBinContext).idType = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1010)
		p.Match(DorisParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1011)

		var _m = p.Match(DorisParserINTEGER_VALUE)

		localctx.(*DropCatalogRecycleBinContext).id = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedAdminStatementContext is an interface to support dynamic dispatch.
type IUnsupportedAdminStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedAdminStatementContext differentiates from other interfaces.
	IsUnsupportedAdminStatementContext()
}

type UnsupportedAdminStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedAdminStatementContext() *UnsupportedAdminStatementContext {
	var p = new(UnsupportedAdminStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedAdminStatement
	return p
}

func InitEmptyUnsupportedAdminStatementContext(p *UnsupportedAdminStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedAdminStatement
}

func (*UnsupportedAdminStatementContext) IsUnsupportedAdminStatementContext() {}

func NewUnsupportedAdminStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedAdminStatementContext {
	var p = new(UnsupportedAdminStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedAdminStatement

	return p
}

func (s *UnsupportedAdminStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedAdminStatementContext) CopyAll(ctx *UnsupportedAdminStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedAdminStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedAdminStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AdminShowReplicaDistributionContext struct {
	UnsupportedAdminStatementContext
}

func NewAdminShowReplicaDistributionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminShowReplicaDistributionContext {
	var p = new(AdminShowReplicaDistributionContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminShowReplicaDistributionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminShowReplicaDistributionContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminShowReplicaDistributionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *AdminShowReplicaDistributionContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLICA, 0)
}

func (s *AdminShowReplicaDistributionContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTRIBUTION, 0)
}

func (s *AdminShowReplicaDistributionContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *AdminShowReplicaDistributionContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *AdminShowReplicaDistributionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminShowReplicaDistribution(s)
	}
}

func (s *AdminShowReplicaDistributionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminShowReplicaDistribution(s)
	}
}

type AdminShowTabletStorageFormatContext struct {
	UnsupportedAdminStatementContext
}

func NewAdminShowTabletStorageFormatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminShowTabletStorageFormatContext {
	var p = new(AdminShowTabletStorageFormatContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminShowTabletStorageFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminShowTabletStorageFormatContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminShowTabletStorageFormatContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *AdminShowTabletStorageFormatContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLET, 0)
}

func (s *AdminShowTabletStorageFormatContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *AdminShowTabletStorageFormatContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DorisParserFORMAT, 0)
}

func (s *AdminShowTabletStorageFormatContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserVERBOSE, 0)
}

func (s *AdminShowTabletStorageFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminShowTabletStorageFormat(s)
	}
}

func (s *AdminShowTabletStorageFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminShowTabletStorageFormat(s)
	}
}

type AdminSetReplicaStatusContext struct {
	UnsupportedAdminStatementContext
}

func NewAdminSetReplicaStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminSetReplicaStatusContext {
	var p = new(AdminSetReplicaStatusContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminSetReplicaStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetReplicaStatusContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminSetReplicaStatusContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AdminSetReplicaStatusContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLICA, 0)
}

func (s *AdminSetReplicaStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATUS, 0)
}

func (s *AdminSetReplicaStatusContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *AdminSetReplicaStatusContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AdminSetReplicaStatusContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AdminSetReplicaStatusContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AdminSetReplicaStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminSetReplicaStatus(s)
	}
}

func (s *AdminSetReplicaStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminSetReplicaStatus(s)
	}
}

type AdminRebalanceDiskContext struct {
	UnsupportedAdminStatementContext
	_STRING_LITERAL antlr.Token
	backends        []antlr.Token
}

func NewAdminRebalanceDiskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminRebalanceDiskContext {
	var p = new(AdminRebalanceDiskContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminRebalanceDiskContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *AdminRebalanceDiskContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *AdminRebalanceDiskContext) GetBackends() []antlr.Token { return s.backends }

func (s *AdminRebalanceDiskContext) SetBackends(v []antlr.Token) { s.backends = v }

func (s *AdminRebalanceDiskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminRebalanceDiskContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminRebalanceDiskContext) REBALANCE() antlr.TerminalNode {
	return s.GetToken(DorisParserREBALANCE, 0)
}

func (s *AdminRebalanceDiskContext) DISK() antlr.TerminalNode {
	return s.GetToken(DorisParserDISK, 0)
}

func (s *AdminRebalanceDiskContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *AdminRebalanceDiskContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AdminRebalanceDiskContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AdminRebalanceDiskContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *AdminRebalanceDiskContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *AdminRebalanceDiskContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, 0)
}

func (s *AdminRebalanceDiskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminRebalanceDisk(s)
	}
}

func (s *AdminRebalanceDiskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminRebalanceDisk(s)
	}
}

type AdminSetReplicaVersionContext struct {
	UnsupportedAdminStatementContext
}

func NewAdminSetReplicaVersionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminSetReplicaVersionContext {
	var p = new(AdminSetReplicaVersionContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminSetReplicaVersionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetReplicaVersionContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminSetReplicaVersionContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AdminSetReplicaVersionContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLICA, 0)
}

func (s *AdminSetReplicaVersionContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisParserVERSION, 0)
}

func (s *AdminSetReplicaVersionContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *AdminSetReplicaVersionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AdminSetReplicaVersionContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AdminSetReplicaVersionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AdminSetReplicaVersionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminSetReplicaVersion(s)
	}
}

func (s *AdminSetReplicaVersionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminSetReplicaVersion(s)
	}
}

type AdminSetTableStatusContext struct {
	UnsupportedAdminStatementContext
	name       IMultipartIdentifierContext
	properties IPropertyClauseContext
}

func NewAdminSetTableStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminSetTableStatusContext {
	var p = new(AdminSetTableStatusContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminSetTableStatusContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AdminSetTableStatusContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AdminSetTableStatusContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AdminSetTableStatusContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AdminSetTableStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetTableStatusContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminSetTableStatusContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AdminSetTableStatusContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AdminSetTableStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATUS, 0)
}

func (s *AdminSetTableStatusContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AdminSetTableStatusContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AdminSetTableStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminSetTableStatus(s)
	}
}

func (s *AdminSetTableStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminSetTableStatus(s)
	}
}

type AdminSetPartitionVersionContext struct {
	UnsupportedAdminStatementContext
	name       IMultipartIdentifierContext
	properties IPropertyClauseContext
}

func NewAdminSetPartitionVersionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminSetPartitionVersionContext {
	var p = new(AdminSetPartitionVersionContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminSetPartitionVersionContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AdminSetPartitionVersionContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AdminSetPartitionVersionContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AdminSetPartitionVersionContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AdminSetPartitionVersionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetPartitionVersionContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminSetPartitionVersionContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AdminSetPartitionVersionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AdminSetPartitionVersionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *AdminSetPartitionVersionContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisParserVERSION, 0)
}

func (s *AdminSetPartitionVersionContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AdminSetPartitionVersionContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AdminSetPartitionVersionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminSetPartitionVersion(s)
	}
}

func (s *AdminSetPartitionVersionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminSetPartitionVersion(s)
	}
}

type AdminCancelRepairTableContext struct {
	UnsupportedAdminStatementContext
}

func NewAdminCancelRepairTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminCancelRepairTableContext {
	var p = new(AdminCancelRepairTableContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminCancelRepairTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCancelRepairTableContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminCancelRepairTableContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *AdminCancelRepairTableContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(DorisParserREPAIR, 0)
}

func (s *AdminCancelRepairTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AdminCancelRepairTableContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *AdminCancelRepairTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminCancelRepairTable(s)
	}
}

func (s *AdminCancelRepairTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminCancelRepairTable(s)
	}
}

type AdminCopyTabletContext struct {
	UnsupportedAdminStatementContext
	tabletId   antlr.Token
	properties IPropertyClauseContext
}

func NewAdminCopyTabletContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminCopyTabletContext {
	var p = new(AdminCopyTabletContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminCopyTabletContext) GetTabletId() antlr.Token { return s.tabletId }

func (s *AdminCopyTabletContext) SetTabletId(v antlr.Token) { s.tabletId = v }

func (s *AdminCopyTabletContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AdminCopyTabletContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AdminCopyTabletContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCopyTabletContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminCopyTabletContext) COPY() antlr.TerminalNode {
	return s.GetToken(DorisParserCOPY, 0)
}

func (s *AdminCopyTabletContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLET, 0)
}

func (s *AdminCopyTabletContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *AdminCopyTabletContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AdminCopyTabletContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminCopyTablet(s)
	}
}

func (s *AdminCopyTabletContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminCopyTablet(s)
	}
}

type AdminRepairTableContext struct {
	UnsupportedAdminStatementContext
}

func NewAdminRepairTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminRepairTableContext {
	var p = new(AdminRepairTableContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminRepairTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminRepairTableContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminRepairTableContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(DorisParserREPAIR, 0)
}

func (s *AdminRepairTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AdminRepairTableContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *AdminRepairTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminRepairTable(s)
	}
}

func (s *AdminRepairTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminRepairTable(s)
	}
}

type AdminSetFrontendConfigContext struct {
	UnsupportedAdminStatementContext
}

func NewAdminSetFrontendConfigContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminSetFrontendConfigContext {
	var p = new(AdminSetFrontendConfigContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminSetFrontendConfigContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetFrontendConfigContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminSetFrontendConfigContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AdminSetFrontendConfigContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(DorisParserCONFIG, 0)
}

func (s *AdminSetFrontendConfigContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(DorisParserFRONTEND, 0)
}

func (s *AdminSetFrontendConfigContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AdminSetFrontendConfigContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AdminSetFrontendConfigContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AdminSetFrontendConfigContext) AllALL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserALL)
}

func (s *AdminSetFrontendConfigContext) ALL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserALL, i)
}

func (s *AdminSetFrontendConfigContext) FRONTENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserFRONTENDS, 0)
}

func (s *AdminSetFrontendConfigContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminSetFrontendConfig(s)
	}
}

func (s *AdminSetFrontendConfigContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminSetFrontendConfig(s)
	}
}

type AdminCheckTabletsContext struct {
	UnsupportedAdminStatementContext
	properties IPropertyClauseContext
}

func NewAdminCheckTabletsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminCheckTabletsContext {
	var p = new(AdminCheckTabletsContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminCheckTabletsContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AdminCheckTabletsContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AdminCheckTabletsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCheckTabletsContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminCheckTabletsContext) CHECK() antlr.TerminalNode {
	return s.GetToken(DorisParserCHECK, 0)
}

func (s *AdminCheckTabletsContext) TabletList() ITabletListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabletListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabletListContext)
}

func (s *AdminCheckTabletsContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AdminCheckTabletsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminCheckTablets(s)
	}
}

func (s *AdminCheckTabletsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminCheckTablets(s)
	}
}

type AdminCleanTrashContext struct {
	UnsupportedAdminStatementContext
	_STRING_LITERAL antlr.Token
	backends        []antlr.Token
}

func NewAdminCleanTrashContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminCleanTrashContext {
	var p = new(AdminCleanTrashContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminCleanTrashContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *AdminCleanTrashContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *AdminCleanTrashContext) GetBackends() []antlr.Token { return s.backends }

func (s *AdminCleanTrashContext) SetBackends(v []antlr.Token) { s.backends = v }

func (s *AdminCleanTrashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCleanTrashContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminCleanTrashContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(DorisParserCLEAN, 0)
}

func (s *AdminCleanTrashContext) TRASH() antlr.TerminalNode {
	return s.GetToken(DorisParserTRASH, 0)
}

func (s *AdminCleanTrashContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *AdminCleanTrashContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AdminCleanTrashContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AdminCleanTrashContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *AdminCleanTrashContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *AdminCleanTrashContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, 0)
}

func (s *AdminCleanTrashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminCleanTrash(s)
	}
}

func (s *AdminCleanTrashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminCleanTrash(s)
	}
}

type AdminCompactTableContext struct {
	UnsupportedAdminStatementContext
}

func NewAdminCompactTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminCompactTableContext {
	var p = new(AdminCompactTableContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminCompactTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCompactTableContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminCompactTableContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPACT, 0)
}

func (s *AdminCompactTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AdminCompactTableContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *AdminCompactTableContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *AdminCompactTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminCompactTable(s)
	}
}

func (s *AdminCompactTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminCompactTable(s)
	}
}

type AdminDiagnoseTabletContext struct {
	UnsupportedAdminStatementContext
	tabletId antlr.Token
}

func NewAdminDiagnoseTabletContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminDiagnoseTabletContext {
	var p = new(AdminDiagnoseTabletContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminDiagnoseTabletContext) GetTabletId() antlr.Token { return s.tabletId }

func (s *AdminDiagnoseTabletContext) SetTabletId(v antlr.Token) { s.tabletId = v }

func (s *AdminDiagnoseTabletContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminDiagnoseTabletContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminDiagnoseTabletContext) DIAGNOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserDIAGNOSE, 0)
}

func (s *AdminDiagnoseTabletContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLET, 0)
}

func (s *AdminDiagnoseTabletContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *AdminDiagnoseTabletContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminDiagnoseTablet(s)
	}
}

func (s *AdminDiagnoseTabletContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminDiagnoseTablet(s)
	}
}

type AdminCancelRebalanceDiskContext struct {
	UnsupportedAdminStatementContext
	_STRING_LITERAL antlr.Token
	backends        []antlr.Token
}

func NewAdminCancelRebalanceDiskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminCancelRebalanceDiskContext {
	var p = new(AdminCancelRebalanceDiskContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminCancelRebalanceDiskContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *AdminCancelRebalanceDiskContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *AdminCancelRebalanceDiskContext) GetBackends() []antlr.Token { return s.backends }

func (s *AdminCancelRebalanceDiskContext) SetBackends(v []antlr.Token) { s.backends = v }

func (s *AdminCancelRebalanceDiskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCancelRebalanceDiskContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminCancelRebalanceDiskContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *AdminCancelRebalanceDiskContext) REBALANCE() antlr.TerminalNode {
	return s.GetToken(DorisParserREBALANCE, 0)
}

func (s *AdminCancelRebalanceDiskContext) DISK() antlr.TerminalNode {
	return s.GetToken(DorisParserDISK, 0)
}

func (s *AdminCancelRebalanceDiskContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *AdminCancelRebalanceDiskContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AdminCancelRebalanceDiskContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AdminCancelRebalanceDiskContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *AdminCancelRebalanceDiskContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *AdminCancelRebalanceDiskContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, 0)
}

func (s *AdminCancelRebalanceDiskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminCancelRebalanceDisk(s)
	}
}

func (s *AdminCancelRebalanceDiskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminCancelRebalanceDisk(s)
	}
}

type AdminShowReplicaStatusContext struct {
	UnsupportedAdminStatementContext
}

func NewAdminShowReplicaStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminShowReplicaStatusContext {
	var p = new(AdminShowReplicaStatusContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminShowReplicaStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminShowReplicaStatusContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminShowReplicaStatusContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *AdminShowReplicaStatusContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLICA, 0)
}

func (s *AdminShowReplicaStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATUS, 0)
}

func (s *AdminShowReplicaStatusContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *AdminShowReplicaStatusContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *AdminShowReplicaStatusContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *AdminShowReplicaStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminShowReplicaStatus(s)
	}
}

func (s *AdminShowReplicaStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminShowReplicaStatus(s)
	}
}

func (p *DorisParser) UnsupportedAdminStatement() (localctx IUnsupportedAdminStatementContext) {
	localctx = NewUnsupportedAdminStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, DorisParserRULE_unsupportedAdminStatement)
	var _la int

	p.SetState(1158)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAdminShowReplicaStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1013)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1014)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1015)
			p.Match(DorisParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1016)
			p.Match(DorisParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1017)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1018)
			p.BaseTableRef()
		}
		p.SetState(1020)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(1019)
				p.WildWhere()
			}

		}

	case 2:
		localctx = NewAdminShowReplicaDistributionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1022)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1023)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1024)
			p.Match(DorisParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1025)
			p.Match(DorisParserDISTRIBUTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1026)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1027)
			p.BaseTableRef()
		}

	case 3:
		localctx = NewAdminSetReplicaStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1028)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1029)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1030)
			p.Match(DorisParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1031)
			p.Match(DorisParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1032)
			p.Match(DorisParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1033)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1034)
			p.PropertyItemList()
		}
		{
			p.SetState(1035)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewAdminSetReplicaVersionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1037)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1038)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1039)
			p.Match(DorisParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1040)
			p.Match(DorisParserVERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1041)
			p.Match(DorisParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1042)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1043)
			p.PropertyItemList()
		}
		{
			p.SetState(1044)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewAdminRepairTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1046)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1047)
			p.Match(DorisParserREPAIR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1048)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1049)
			p.BaseTableRef()
		}

	case 6:
		localctx = NewAdminCancelRepairTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1050)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1051)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1052)
			p.Match(DorisParserREPAIR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1053)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1054)
			p.BaseTableRef()
		}

	case 7:
		localctx = NewAdminCompactTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1055)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1056)
			p.Match(DorisParserCOMPACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1057)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1058)
			p.BaseTableRef()
		}
		p.SetState(1060)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(1059)
				p.WildWhere()
			}

		}

	case 8:
		localctx = NewAdminSetFrontendConfigContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1062)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1063)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1067)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserFRONTEND:
			{
				p.SetState(1064)
				p.Match(DorisParserFRONTEND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserALL:
			{
				p.SetState(1065)
				p.Match(DorisParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1066)
				p.Match(DorisParserFRONTENDS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(1069)
			p.Match(DorisParserCONFIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1074)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(1070)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1071)
				p.PropertyItemList()
			}
			{
				p.SetState(1072)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1077)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserALL {
			{
				p.SetState(1076)
				p.Match(DorisParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 9:
		localctx = NewAdminCheckTabletsContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1079)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1080)
			p.Match(DorisParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1081)
			p.TabletList()
		}
		p.SetState(1083)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1082)

				var _x = p.PropertyClause()

				localctx.(*AdminCheckTabletsContext).properties = _x
			}

		}

	case 10:
		localctx = NewAdminRebalanceDiskContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1085)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1086)
			p.Match(DorisParserREBALANCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1087)
			p.Match(DorisParserDISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1095)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserON {
			{
				p.SetState(1088)
				p.Match(DorisParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1089)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1090)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*AdminRebalanceDiskContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*AdminRebalanceDiskContext).backends = append(localctx.(*AdminRebalanceDiskContext).backends, localctx.(*AdminRebalanceDiskContext)._STRING_LITERAL)

			{
				p.SetState(1091)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1092)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*AdminRebalanceDiskContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*AdminRebalanceDiskContext).backends = append(localctx.(*AdminRebalanceDiskContext).backends, localctx.(*AdminRebalanceDiskContext)._STRING_LITERAL)

			{
				p.SetState(1094)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 11:
		localctx = NewAdminCancelRebalanceDiskContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1097)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1098)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1099)
			p.Match(DorisParserREBALANCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1100)
			p.Match(DorisParserDISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1108)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserON {
			{
				p.SetState(1101)
				p.Match(DorisParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1102)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1103)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*AdminCancelRebalanceDiskContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*AdminCancelRebalanceDiskContext).backends = append(localctx.(*AdminCancelRebalanceDiskContext).backends, localctx.(*AdminCancelRebalanceDiskContext)._STRING_LITERAL)

			{
				p.SetState(1104)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1105)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*AdminCancelRebalanceDiskContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*AdminCancelRebalanceDiskContext).backends = append(localctx.(*AdminCancelRebalanceDiskContext).backends, localctx.(*AdminCancelRebalanceDiskContext)._STRING_LITERAL)

			{
				p.SetState(1107)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 12:
		localctx = NewAdminCleanTrashContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1110)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1111)
			p.Match(DorisParserCLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1112)
			p.Match(DorisParserTRASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1120)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserON {
			{
				p.SetState(1113)
				p.Match(DorisParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1114)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1115)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*AdminCleanTrashContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*AdminCleanTrashContext).backends = append(localctx.(*AdminCleanTrashContext).backends, localctx.(*AdminCleanTrashContext)._STRING_LITERAL)

			{
				p.SetState(1116)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1117)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*AdminCleanTrashContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*AdminCleanTrashContext).backends = append(localctx.(*AdminCleanTrashContext).backends, localctx.(*AdminCleanTrashContext)._STRING_LITERAL)

			{
				p.SetState(1119)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 13:
		localctx = NewAdminSetPartitionVersionContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1122)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1123)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1124)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1125)

			var _x = p.MultipartIdentifier()

			localctx.(*AdminSetPartitionVersionContext).name = _x
		}
		{
			p.SetState(1126)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1127)
			p.Match(DorisParserVERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1129)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1128)

				var _x = p.PropertyClause()

				localctx.(*AdminSetPartitionVersionContext).properties = _x
			}

		}

	case 14:
		localctx = NewAdminDiagnoseTabletContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1131)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1132)
			p.Match(DorisParserDIAGNOSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1133)
			p.Match(DorisParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1134)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*AdminDiagnoseTabletContext).tabletId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		localctx = NewAdminShowTabletStorageFormatContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1135)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1136)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1137)
			p.Match(DorisParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1138)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1139)
			p.Match(DorisParserFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1141)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserVERBOSE {
			{
				p.SetState(1140)
				p.Match(DorisParserVERBOSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 16:
		localctx = NewAdminCopyTabletContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1143)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1144)
			p.Match(DorisParserCOPY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1145)
			p.Match(DorisParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1146)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*AdminCopyTabletContext).tabletId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1148)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1147)

				var _x = p.PropertyClause()

				localctx.(*AdminCopyTabletContext).properties = _x
			}

		}

	case 17:
		localctx = NewAdminSetTableStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1150)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1151)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1152)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1153)

			var _x = p.MultipartIdentifier()

			localctx.(*AdminSetTableStatusContext).name = _x
		}
		{
			p.SetState(1154)
			p.Match(DorisParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1156)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1155)

				var _x = p.PropertyClause()

				localctx.(*AdminSetTableStatusContext).properties = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBaseTableRefContext is an interface to support dynamic dispatch.
type IBaseTableRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MultipartIdentifier() IMultipartIdentifierContext
	TableAlias() ITableAliasContext
	OptScanParams() IOptScanParamsContext
	TableSnapshot() ITableSnapshotContext
	SpecifiedPartition() ISpecifiedPartitionContext
	TabletList() ITabletListContext
	Sample() ISampleContext
	RelationHint() IRelationHintContext

	// IsBaseTableRefContext differentiates from other interfaces.
	IsBaseTableRefContext()
}

type BaseTableRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseTableRefContext() *BaseTableRefContext {
	var p = new(BaseTableRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_baseTableRef
	return p
}

func InitEmptyBaseTableRefContext(p *BaseTableRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_baseTableRef
}

func (*BaseTableRefContext) IsBaseTableRefContext() {}

func NewBaseTableRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseTableRefContext {
	var p = new(BaseTableRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_baseTableRef

	return p
}

func (s *BaseTableRefContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseTableRefContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *BaseTableRefContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *BaseTableRefContext) OptScanParams() IOptScanParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptScanParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptScanParamsContext)
}

func (s *BaseTableRefContext) TableSnapshot() ITableSnapshotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSnapshotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSnapshotContext)
}

func (s *BaseTableRefContext) SpecifiedPartition() ISpecifiedPartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecifiedPartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecifiedPartitionContext)
}

func (s *BaseTableRefContext) TabletList() ITabletListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabletListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabletListContext)
}

func (s *BaseTableRefContext) Sample() ISampleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleContext)
}

func (s *BaseTableRefContext) RelationHint() IRelationHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationHintContext)
}

func (s *BaseTableRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseTableRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseTableRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBaseTableRef(s)
	}
}

func (s *BaseTableRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBaseTableRef(s)
	}
}

func (p *DorisParser) BaseTableRef() (localctx IBaseTableRefContext) {
	localctx = NewBaseTableRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, DorisParserRULE_baseTableRef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1160)
		p.MultipartIdentifier()
	}
	p.SetState(1162)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserATSIGN {
		{
			p.SetState(1161)
			p.OptScanParams()
		}

	}
	p.SetState(1165)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserFOR {
		{
			p.SetState(1164)
			p.TableSnapshot()
		}

	}
	p.SetState(1168)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1167)
			p.SpecifiedPartition()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1171)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserTABLET {
		{
			p.SetState(1170)
			p.TabletList()
		}

	}
	{
		p.SetState(1173)
		p.TableAlias()
	}
	p.SetState(1175)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserTABLESAMPLE {
		{
			p.SetState(1174)
			p.Sample()
		}

	}
	p.SetState(1178)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLEFT_BRACKET || _la == DorisParserHINT_START {
		{
			p.SetState(1177)
			p.RelationHint()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWildWhereContext is an interface to support dynamic dispatch.
type IWildWhereContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIKE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsWildWhereContext differentiates from other interfaces.
	IsWildWhereContext()
}

type WildWhereContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWildWhereContext() *WildWhereContext {
	var p = new(WildWhereContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_wildWhere
	return p
}

func InitEmptyWildWhereContext(p *WildWhereContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_wildWhere
}

func (*WildWhereContext) IsWildWhereContext() {}

func NewWildWhereContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WildWhereContext {
	var p = new(WildWhereContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_wildWhere

	return p
}

func (s *WildWhereContext) GetParser() antlr.Parser { return s.parser }

func (s *WildWhereContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *WildWhereContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *WildWhereContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserWHERE, 0)
}

func (s *WildWhereContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WildWhereContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildWhereContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WildWhereContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWildWhere(s)
	}
}

func (s *WildWhereContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWildWhere(s)
	}
}

func (p *DorisParser) WildWhere() (localctx IWildWhereContext) {
	localctx = NewWildWhereContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, DorisParserRULE_wildWhere)
	p.SetState(1184)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLIKE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1180)
			p.Match(DorisParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1181)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserWHERE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1182)
			p.Match(DorisParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1183)
			p.Expression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedTransactionStatementContext is an interface to support dynamic dispatch.
type IUnsupportedTransactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedTransactionStatementContext differentiates from other interfaces.
	IsUnsupportedTransactionStatementContext()
}

type UnsupportedTransactionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedTransactionStatementContext() *UnsupportedTransactionStatementContext {
	var p = new(UnsupportedTransactionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedTransactionStatement
	return p
}

func InitEmptyUnsupportedTransactionStatementContext(p *UnsupportedTransactionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedTransactionStatement
}

func (*UnsupportedTransactionStatementContext) IsUnsupportedTransactionStatementContext() {}

func NewUnsupportedTransactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedTransactionStatementContext {
	var p = new(UnsupportedTransactionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedTransactionStatement

	return p
}

func (s *UnsupportedTransactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedTransactionStatementContext) CopyAll(ctx *UnsupportedTransactionStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedTransactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedTransactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TranscationCommitContext struct {
	UnsupportedTransactionStatementContext
}

func NewTranscationCommitContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TranscationCommitContext {
	var p = new(TranscationCommitContext)

	InitEmptyUnsupportedTransactionStatementContext(&p.UnsupportedTransactionStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedTransactionStatementContext))

	return p
}

func (s *TranscationCommitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TranscationCommitContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMIT, 0)
}

func (s *TranscationCommitContext) WORK() antlr.TerminalNode {
	return s.GetToken(DorisParserWORK, 0)
}

func (s *TranscationCommitContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisParserAND, 0)
}

func (s *TranscationCommitContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(DorisParserCHAIN, 0)
}

func (s *TranscationCommitContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(DorisParserRELEASE, 0)
}

func (s *TranscationCommitContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(DorisParserNO)
}

func (s *TranscationCommitContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserNO, i)
}

func (s *TranscationCommitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTranscationCommit(s)
	}
}

func (s *TranscationCommitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTranscationCommit(s)
	}
}

type TransactionRollbackContext struct {
	UnsupportedTransactionStatementContext
}

func NewTransactionRollbackContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TransactionRollbackContext {
	var p = new(TransactionRollbackContext)

	InitEmptyUnsupportedTransactionStatementContext(&p.UnsupportedTransactionStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedTransactionStatementContext))

	return p
}

func (s *TransactionRollbackContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionRollbackContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLBACK, 0)
}

func (s *TransactionRollbackContext) WORK() antlr.TerminalNode {
	return s.GetToken(DorisParserWORK, 0)
}

func (s *TransactionRollbackContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisParserAND, 0)
}

func (s *TransactionRollbackContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(DorisParserCHAIN, 0)
}

func (s *TransactionRollbackContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(DorisParserRELEASE, 0)
}

func (s *TransactionRollbackContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(DorisParserNO)
}

func (s *TransactionRollbackContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserNO, i)
}

func (s *TransactionRollbackContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTransactionRollback(s)
	}
}

func (s *TransactionRollbackContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTransactionRollback(s)
	}
}

type TransactionBeginContext struct {
	UnsupportedTransactionStatementContext
}

func NewTransactionBeginContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TransactionBeginContext {
	var p = new(TransactionBeginContext)

	InitEmptyUnsupportedTransactionStatementContext(&p.UnsupportedTransactionStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedTransactionStatementContext))

	return p
}

func (s *TransactionBeginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionBeginContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(DorisParserBEGIN, 0)
}

func (s *TransactionBeginContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *TransactionBeginContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisParserLABEL, 0)
}

func (s *TransactionBeginContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TransactionBeginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTransactionBegin(s)
	}
}

func (s *TransactionBeginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTransactionBegin(s)
	}
}

func (p *DorisParser) UnsupportedTransactionStatement() (localctx IUnsupportedTransactionStatementContext) {
	localctx = NewUnsupportedTransactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, DorisParserRULE_unsupportedTransactionStatement)
	var _la int

	p.SetState(1228)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserBEGIN:
		localctx = NewTransactionBeginContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1186)
			p.Match(DorisParserBEGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1192)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(1187)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1188)
				p.Match(DorisParserLABEL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1190)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1153040409952344576) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&-53021438386753) != 0) || ((int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&3476586699635759401) != 0) || ((int64((_la-195)) & ^0x3f) == 0 && ((int64(1)<<(_la-195))&-3139048519776880011) != 0) || ((int64((_la-260)) & ^0x3f) == 0 && ((int64(1)<<(_la-260))&-4544906634320822477) != 0) || ((int64((_la-325)) & ^0x3f) == 0 && ((int64(1)<<(_la-325))&6339805778266808319) != 0) || ((int64((_la-390)) & ^0x3f) == 0 && ((int64(1)<<(_la-390))&-656945004016972825) != 0) || ((int64((_la-456)) & ^0x3f) == 0 && ((int64(1)<<(_la-456))&18760394443469) != 0) || ((int64((_la-522)) & ^0x3f) == 0 && ((int64(1)<<(_la-522))&49159) != 0) {
				{
					p.SetState(1189)
					p.Identifier()
				}

			}

		}

	case DorisParserCOMMIT:
		localctx = NewTranscationCommitContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1194)
			p.Match(DorisParserCOMMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1196)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWORK {
			{
				p.SetState(1195)
				p.Match(DorisParserWORK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1203)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAND {
			{
				p.SetState(1198)
				p.Match(DorisParserAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1200)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserNO {
				{
					p.SetState(1199)
					p.Match(DorisParserNO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1202)
				p.Match(DorisParserCHAIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1209)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNO || _la == DorisParserRELEASE {
			p.SetState(1206)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserNO {
				{
					p.SetState(1205)
					p.Match(DorisParserNO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1208)
				p.Match(DorisParserRELEASE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DorisParserROLLBACK:
		localctx = NewTransactionRollbackContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1211)
			p.Match(DorisParserROLLBACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1213)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWORK {
			{
				p.SetState(1212)
				p.Match(DorisParserWORK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1220)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAND {
			{
				p.SetState(1215)
				p.Match(DorisParserAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1217)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserNO {
				{
					p.SetState(1216)
					p.Match(DorisParserNO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1219)
				p.Match(DorisParserCHAIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1226)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNO || _la == DorisParserRELEASE {
			p.SetState(1223)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserNO {
				{
					p.SetState(1222)
					p.Match(DorisParserNO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1225)
				p.Match(DorisParserRELEASE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedGrantRevokeStatementContext is an interface to support dynamic dispatch.
type IUnsupportedGrantRevokeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedGrantRevokeStatementContext differentiates from other interfaces.
	IsUnsupportedGrantRevokeStatementContext()
}

type UnsupportedGrantRevokeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedGrantRevokeStatementContext() *UnsupportedGrantRevokeStatementContext {
	var p = new(UnsupportedGrantRevokeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedGrantRevokeStatement
	return p
}

func InitEmptyUnsupportedGrantRevokeStatementContext(p *UnsupportedGrantRevokeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedGrantRevokeStatement
}

func (*UnsupportedGrantRevokeStatementContext) IsUnsupportedGrantRevokeStatementContext() {}

func NewUnsupportedGrantRevokeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedGrantRevokeStatementContext {
	var p = new(UnsupportedGrantRevokeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedGrantRevokeStatement

	return p
}

func (s *UnsupportedGrantRevokeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedGrantRevokeStatementContext) CopyAll(ctx *UnsupportedGrantRevokeStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedGrantRevokeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedGrantRevokeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type GrantResourcePrivilegeContext struct {
	UnsupportedGrantRevokeStatementContext
}

func NewGrantResourcePrivilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantResourcePrivilegeContext {
	var p = new(GrantResourcePrivilegeContext)

	InitEmptyUnsupportedGrantRevokeStatementContext(&p.UnsupportedGrantRevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedGrantRevokeStatementContext))

	return p
}

func (s *GrantResourcePrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantResourcePrivilegeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(DorisParserGRANT, 0)
}

func (s *GrantResourcePrivilegeContext) PrivilegeList() IPrivilegeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeListContext)
}

func (s *GrantResourcePrivilegeContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *GrantResourcePrivilegeContext) IdentifierOrTextOrAsterisk() IIdentifierOrTextOrAsteriskContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextOrAsteriskContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextOrAsteriskContext)
}

func (s *GrantResourcePrivilegeContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *GrantResourcePrivilegeContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCE, 0)
}

func (s *GrantResourcePrivilegeContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(DorisParserCLUSTER, 0)
}

func (s *GrantResourcePrivilegeContext) STAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTAGE, 0)
}

func (s *GrantResourcePrivilegeContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *GrantResourcePrivilegeContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULT, 0)
}

func (s *GrantResourcePrivilegeContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserWORKLOAD, 0)
}

func (s *GrantResourcePrivilegeContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUP, 0)
}

func (s *GrantResourcePrivilegeContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *GrantResourcePrivilegeContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *GrantResourcePrivilegeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *GrantResourcePrivilegeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisParserREVOKE, 0)
}

func (s *GrantResourcePrivilegeContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *GrantResourcePrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterGrantResourcePrivilege(s)
	}
}

func (s *GrantResourcePrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitGrantResourcePrivilege(s)
	}
}

type GrantTablePrivilegeContext struct {
	UnsupportedGrantRevokeStatementContext
}

func NewGrantTablePrivilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantTablePrivilegeContext {
	var p = new(GrantTablePrivilegeContext)

	InitEmptyUnsupportedGrantRevokeStatementContext(&p.UnsupportedGrantRevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedGrantRevokeStatementContext))

	return p
}

func (s *GrantTablePrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantTablePrivilegeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(DorisParserGRANT, 0)
}

func (s *GrantTablePrivilegeContext) PrivilegeList() IPrivilegeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeListContext)
}

func (s *GrantTablePrivilegeContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *GrantTablePrivilegeContext) MultipartIdentifierOrAsterisk() IMultipartIdentifierOrAsteriskContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierOrAsteriskContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierOrAsteriskContext)
}

func (s *GrantTablePrivilegeContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *GrantTablePrivilegeContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *GrantTablePrivilegeContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *GrantTablePrivilegeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *GrantTablePrivilegeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisParserREVOKE, 0)
}

func (s *GrantTablePrivilegeContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *GrantTablePrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterGrantTablePrivilege(s)
	}
}

func (s *GrantTablePrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitGrantTablePrivilege(s)
	}
}

type GrantRoleContext struct {
	UnsupportedGrantRevokeStatementContext
	_STRING_LITERAL antlr.Token
	roles           []antlr.Token
}

func NewGrantRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantRoleContext {
	var p = new(GrantRoleContext)

	InitEmptyUnsupportedGrantRevokeStatementContext(&p.UnsupportedGrantRevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedGrantRevokeStatementContext))

	return p
}

func (s *GrantRoleContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *GrantRoleContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *GrantRoleContext) GetRoles() []antlr.Token { return s.roles }

func (s *GrantRoleContext) SetRoles(v []antlr.Token) { s.roles = v }

func (s *GrantRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRoleContext) GRANT() antlr.TerminalNode {
	return s.GetToken(DorisParserGRANT, 0)
}

func (s *GrantRoleContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *GrantRoleContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *GrantRoleContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *GrantRoleContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *GrantRoleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *GrantRoleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *GrantRoleContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisParserREVOKE, 0)
}

func (s *GrantRoleContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *GrantRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterGrantRole(s)
	}
}

func (s *GrantRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitGrantRole(s)
	}
}

func (p *DorisParser) UnsupportedGrantRevokeStatement() (localctx IUnsupportedGrantRevokeStatementContext) {
	localctx = NewUnsupportedGrantRevokeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, DorisParserRULE_unsupportedGrantRevokeStatement)
	var _la int

	p.SetState(1310)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext()) {
	case 1:
		localctx = NewGrantTablePrivilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1230)
			p.Match(DorisParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1231)
			p.PrivilegeList()
		}
		{
			p.SetState(1232)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1233)
			p.MultipartIdentifierOrAsterisk()
		}
		{
			p.SetState(1234)
			p.Match(DorisParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1238)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADDDATE, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserARRAY_RANGE, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATE_ADD, DorisParserDATE_CEIL, DorisParserDATE_DIFF, DorisParserDATE_FLOOR, DorisParserDATE_SUB, DorisParserDATEADD, DorisParserDATEDIFF, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS_ADD, DorisParserDAYS_SUB, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSEQUENCE, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUBDATE, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTIMESTAMPADD, DorisParserTIMESTAMPDIFF, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(1235)
				p.UserIdentify()
			}

		case DorisParserROLE:
			{
				p.SetState(1236)
				p.Match(DorisParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1237)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		localctx = NewGrantResourcePrivilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1240)
			p.Match(DorisParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1241)
			p.PrivilegeList()
		}
		{
			p.SetState(1242)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1250)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserRESOURCE:
			{
				p.SetState(1243)
				p.Match(DorisParserRESOURCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCLUSTER:
			{
				p.SetState(1244)
				p.Match(DorisParserCLUSTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserSTAGE:
			{
				p.SetState(1245)
				p.Match(DorisParserSTAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserSTORAGE:
			{
				p.SetState(1246)
				p.Match(DorisParserSTORAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1247)
				p.Match(DorisParserVAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserWORKLOAD:
			{
				p.SetState(1248)
				p.Match(DorisParserWORKLOAD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1249)
				p.Match(DorisParserGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(1252)
			p.IdentifierOrTextOrAsterisk()
		}
		{
			p.SetState(1253)
			p.Match(DorisParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1257)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADDDATE, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserARRAY_RANGE, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATE_ADD, DorisParserDATE_CEIL, DorisParserDATE_DIFF, DorisParserDATE_FLOOR, DorisParserDATE_SUB, DorisParserDATEADD, DorisParserDATEDIFF, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS_ADD, DorisParserDAYS_SUB, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSEQUENCE, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUBDATE, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTIMESTAMPADD, DorisParserTIMESTAMPDIFF, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(1254)
				p.UserIdentify()
			}

		case DorisParserROLE:
			{
				p.SetState(1255)
				p.Match(DorisParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1256)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		localctx = NewGrantRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1259)
			p.Match(DorisParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1260)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*GrantRoleContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*GrantRoleContext).roles = append(localctx.(*GrantRoleContext).roles, localctx.(*GrantRoleContext)._STRING_LITERAL)
		p.SetState(1265)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(1261)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1262)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*GrantRoleContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*GrantRoleContext).roles = append(localctx.(*GrantRoleContext).roles, localctx.(*GrantRoleContext)._STRING_LITERAL)

			p.SetState(1267)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1268)
			p.Match(DorisParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1269)
			p.UserIdentify()
		}

	case 4:
		localctx = NewGrantTablePrivilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1270)
			p.Match(DorisParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1271)
			p.PrivilegeList()
		}
		{
			p.SetState(1272)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1273)
			p.MultipartIdentifierOrAsterisk()
		}
		{
			p.SetState(1274)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1278)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADDDATE, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserARRAY_RANGE, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATE_ADD, DorisParserDATE_CEIL, DorisParserDATE_DIFF, DorisParserDATE_FLOOR, DorisParserDATE_SUB, DorisParserDATEADD, DorisParserDATEDIFF, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS_ADD, DorisParserDAYS_SUB, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSEQUENCE, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUBDATE, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTIMESTAMPADD, DorisParserTIMESTAMPDIFF, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(1275)
				p.UserIdentify()
			}

		case DorisParserROLE:
			{
				p.SetState(1276)
				p.Match(DorisParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1277)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 5:
		localctx = NewGrantResourcePrivilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1280)
			p.Match(DorisParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1281)
			p.PrivilegeList()
		}
		{
			p.SetState(1282)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1290)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserRESOURCE:
			{
				p.SetState(1283)
				p.Match(DorisParserRESOURCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCLUSTER:
			{
				p.SetState(1284)
				p.Match(DorisParserCLUSTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserSTAGE:
			{
				p.SetState(1285)
				p.Match(DorisParserSTAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserSTORAGE:
			{
				p.SetState(1286)
				p.Match(DorisParserSTORAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1287)
				p.Match(DorisParserVAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserWORKLOAD:
			{
				p.SetState(1288)
				p.Match(DorisParserWORKLOAD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1289)
				p.Match(DorisParserGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(1292)
			p.IdentifierOrTextOrAsterisk()
		}
		{
			p.SetState(1293)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1297)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADDDATE, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserARRAY_RANGE, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATE_ADD, DorisParserDATE_CEIL, DorisParserDATE_DIFF, DorisParserDATE_FLOOR, DorisParserDATE_SUB, DorisParserDATEADD, DorisParserDATEDIFF, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS_ADD, DorisParserDAYS_SUB, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSEQUENCE, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUBDATE, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTIMESTAMPADD, DorisParserTIMESTAMPDIFF, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(1294)
				p.UserIdentify()
			}

		case DorisParserROLE:
			{
				p.SetState(1295)
				p.Match(DorisParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1296)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 6:
		localctx = NewGrantRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1299)
			p.Match(DorisParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1300)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*GrantRoleContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*GrantRoleContext).roles = append(localctx.(*GrantRoleContext).roles, localctx.(*GrantRoleContext)._STRING_LITERAL)
		p.SetState(1305)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(1301)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1302)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*GrantRoleContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*GrantRoleContext).roles = append(localctx.(*GrantRoleContext).roles, localctx.(*GrantRoleContext)._STRING_LITERAL)

			p.SetState(1307)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1308)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1309)
			p.UserIdentify()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeContext is an interface to support dynamic dispatch.
type IPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IIdentifierListContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IIdentifierListContext)

	// Getter signatures
	Identifier() IIdentifierContext
	IdentifierList() IIdentifierListContext
	ALL() antlr.TerminalNode

	// IsPrivilegeContext differentiates from other interfaces.
	IsPrivilegeContext()
}

type PrivilegeContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	name    IIdentifierContext
	columns IIdentifierListContext
}

func NewEmptyPrivilegeContext() *PrivilegeContext {
	var p = new(PrivilegeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_privilege
	return p
}

func InitEmptyPrivilegeContext(p *PrivilegeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_privilege
}

func (*PrivilegeContext) IsPrivilegeContext() {}

func NewPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeContext {
	var p = new(PrivilegeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_privilege

	return p
}

func (s *PrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeContext) GetName() IIdentifierContext { return s.name }

func (s *PrivilegeContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *PrivilegeContext) SetName(v IIdentifierContext) { s.name = v }

func (s *PrivilegeContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *PrivilegeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrivilegeContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PrivilegeContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *PrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPrivilege(s)
	}
}

func (s *PrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPrivilege(s)
	}
}

func (p *DorisParser) Privilege() (localctx IPrivilegeContext) {
	localctx = NewPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, DorisParserRULE_privilege)
	var _la int

	p.SetState(1317)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADDDATE, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserARRAY_RANGE, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATE_ADD, DorisParserDATE_CEIL, DorisParserDATE_DIFF, DorisParserDATE_FLOOR, DorisParserDATE_SUB, DorisParserDATEADD, DorisParserDATEDIFF, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS_ADD, DorisParserDAYS_SUB, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSEQUENCE, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUBDATE, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTIMESTAMPADD, DorisParserTIMESTAMPDIFF, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1312)

			var _x = p.Identifier()

			localctx.(*PrivilegeContext).name = _x
		}
		p.SetState(1314)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(1313)

				var _x = p.IdentifierList()

				localctx.(*PrivilegeContext).columns = _x
			}

		}

	case DorisParserALL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1316)
			p.Match(DorisParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeListContext is an interface to support dynamic dispatch.
type IPrivilegeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrivilege() []IPrivilegeContext
	Privilege(i int) IPrivilegeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPrivilegeListContext differentiates from other interfaces.
	IsPrivilegeListContext()
}

type PrivilegeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeListContext() *PrivilegeListContext {
	var p = new(PrivilegeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_privilegeList
	return p
}

func InitEmptyPrivilegeListContext(p *PrivilegeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_privilegeList
}

func (*PrivilegeListContext) IsPrivilegeListContext() {}

func NewPrivilegeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeListContext {
	var p = new(PrivilegeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_privilegeList

	return p
}

func (s *PrivilegeListContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeListContext) AllPrivilege() []IPrivilegeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivilegeContext); ok {
			len++
		}
	}

	tst := make([]IPrivilegeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivilegeContext); ok {
			tst[i] = t.(IPrivilegeContext)
			i++
		}
	}

	return tst
}

func (s *PrivilegeListContext) Privilege(i int) IPrivilegeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeContext)
}

func (s *PrivilegeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *PrivilegeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *PrivilegeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPrivilegeList(s)
	}
}

func (s *PrivilegeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPrivilegeList(s)
	}
}

func (p *DorisParser) PrivilegeList() (localctx IPrivilegeListContext) {
	localctx = NewPrivilegeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, DorisParserRULE_privilegeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1319)
		p.Privilege()
	}
	p.SetState(1324)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(1320)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1321)
			p.Privilege()
		}

		p.SetState(1326)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedAlterStatementContext is an interface to support dynamic dispatch.
type IUnsupportedAlterStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedAlterStatementContext differentiates from other interfaces.
	IsUnsupportedAlterStatementContext()
}

type UnsupportedAlterStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedAlterStatementContext() *UnsupportedAlterStatementContext {
	var p = new(UnsupportedAlterStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedAlterStatement
	return p
}

func InitEmptyUnsupportedAlterStatementContext(p *UnsupportedAlterStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedAlterStatement
}

func (*UnsupportedAlterStatementContext) IsUnsupportedAlterStatementContext() {}

func NewUnsupportedAlterStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedAlterStatementContext {
	var p = new(UnsupportedAlterStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedAlterStatement

	return p
}

func (s *UnsupportedAlterStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedAlterStatementContext) CopyAll(ctx *UnsupportedAlterStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedAlterStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedAlterStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AlterStoragePlicyContext struct {
	UnsupportedAlterStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewAlterStoragePlicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterStoragePlicyContext {
	var p = new(AlterStoragePlicyContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterStoragePlicyContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *AlterStoragePlicyContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterStoragePlicyContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *AlterStoragePlicyContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterStoragePlicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStoragePlicyContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterStoragePlicyContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *AlterStoragePlicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *AlterStoragePlicyContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *AlterStoragePlicyContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterStoragePlicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterStoragePlicy(s)
	}
}

func (s *AlterStoragePlicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterStoragePlicy(s)
	}
}

type AlterSystemContext struct {
	UnsupportedAlterStatementContext
}

func NewAlterSystemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterSystemContext {
	var p = new(AlterSystemContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterSystemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSystemContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterSystemContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(DorisParserSYSTEM, 0)
}

func (s *AlterSystemContext) AlterSystemClause() IAlterSystemClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterSystemClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterSystemClauseContext)
}

func (s *AlterSystemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterSystem(s)
	}
}

func (s *AlterSystemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterSystem(s)
	}
}

type AlterCatalogRenameContext struct {
	UnsupportedAlterStatementContext
	name    IIdentifierContext
	newName IIdentifierContext
}

func NewAlterCatalogRenameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterCatalogRenameContext {
	var p = new(AlterCatalogRenameContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterCatalogRenameContext) GetName() IIdentifierContext { return s.name }

func (s *AlterCatalogRenameContext) GetNewName() IIdentifierContext { return s.newName }

func (s *AlterCatalogRenameContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterCatalogRenameContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *AlterCatalogRenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterCatalogRenameContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterCatalogRenameContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *AlterCatalogRenameContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserRENAME, 0)
}

func (s *AlterCatalogRenameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterCatalogRenameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterCatalogRenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterCatalogRename(s)
	}
}

func (s *AlterCatalogRenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterCatalogRename(s)
	}
}

type AlterDatabaseSetQuotaContext struct {
	UnsupportedAlterStatementContext
	name IIdentifierContext
}

func NewAlterDatabaseSetQuotaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterDatabaseSetQuotaContext {
	var p = new(AlterDatabaseSetQuotaContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterDatabaseSetQuotaContext) GetName() IIdentifierContext { return s.name }

func (s *AlterDatabaseSetQuotaContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterDatabaseSetQuotaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseSetQuotaContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterDatabaseSetQuotaContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *AlterDatabaseSetQuotaContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterDatabaseSetQuotaContext) QUOTA() antlr.TerminalNode {
	return s.GetToken(DorisParserQUOTA, 0)
}

func (s *AlterDatabaseSetQuotaContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *AlterDatabaseSetQuotaContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterDatabaseSetQuotaContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterDatabaseSetQuotaContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserDATA, 0)
}

func (s *AlterDatabaseSetQuotaContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLICA, 0)
}

func (s *AlterDatabaseSetQuotaContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisParserTRANSACTION, 0)
}

func (s *AlterDatabaseSetQuotaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterDatabaseSetQuota(s)
	}
}

func (s *AlterDatabaseSetQuotaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterDatabaseSetQuota(s)
	}
}

type AlterTableDropRollupContext struct {
	UnsupportedAlterStatementContext
	tableName IMultipartIdentifierContext
}

func NewAlterTableDropRollupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableDropRollupContext {
	var p = new(AlterTableDropRollupContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterTableDropRollupContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *AlterTableDropRollupContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *AlterTableDropRollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableDropRollupContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterTableDropRollupContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AlterTableDropRollupContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *AlterTableDropRollupContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *AlterTableDropRollupContext) AllDropRollupClause() []IDropRollupClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDropRollupClauseContext); ok {
			len++
		}
	}

	tst := make([]IDropRollupClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDropRollupClauseContext); ok {
			tst[i] = t.(IDropRollupClauseContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableDropRollupContext) DropRollupClause(i int) IDropRollupClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropRollupClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropRollupClauseContext)
}

func (s *AlterTableDropRollupContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterTableDropRollupContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AlterTableDropRollupContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AlterTableDropRollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterTableDropRollup(s)
	}
}

func (s *AlterTableDropRollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterTableDropRollup(s)
	}
}

type AlterWorkloadGroupContext struct {
	UnsupportedAlterStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewAlterWorkloadGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterWorkloadGroupContext {
	var p = new(AlterWorkloadGroupContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterWorkloadGroupContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *AlterWorkloadGroupContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterWorkloadGroupContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *AlterWorkloadGroupContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterWorkloadGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterWorkloadGroupContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterWorkloadGroupContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserWORKLOAD, 0)
}

func (s *AlterWorkloadGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUP, 0)
}

func (s *AlterWorkloadGroupContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *AlterWorkloadGroupContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterWorkloadGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterWorkloadGroup(s)
	}
}

func (s *AlterWorkloadGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterWorkloadGroup(s)
	}
}

type AlterTablePropertiesContext struct {
	UnsupportedAlterStatementContext
	name IMultipartIdentifierContext
}

func NewAlterTablePropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTablePropertiesContext {
	var p = new(AlterTablePropertiesContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterTablePropertiesContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterTablePropertiesContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterTablePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTablePropertiesContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterTablePropertiesContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AlterTablePropertiesContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterTablePropertiesContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterTablePropertiesContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterTablePropertiesContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterTablePropertiesContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterTablePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterTableProperties(s)
	}
}

func (s *AlterTablePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterTableProperties(s)
	}
}

type AlterUserContext struct {
	UnsupportedAlterStatementContext
}

func NewAlterUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterUserContext {
	var p = new(AlterUserContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterUserContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisParserUSER, 0)
}

func (s *AlterUserContext) GrantUserIdentify() IGrantUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantUserIdentifyContext)
}

func (s *AlterUserContext) PasswordOption() IPasswordOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordOptionContext)
}

func (s *AlterUserContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *AlterUserContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *AlterUserContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *AlterUserContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *AlterUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterUser(s)
	}
}

func (s *AlterUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterUser(s)
	}
}

type AlterDatabaseRenameContext struct {
	UnsupportedAlterStatementContext
	name    IIdentifierContext
	newName IIdentifierContext
}

func NewAlterDatabaseRenameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterDatabaseRenameContext {
	var p = new(AlterDatabaseRenameContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterDatabaseRenameContext) GetName() IIdentifierContext { return s.name }

func (s *AlterDatabaseRenameContext) GetNewName() IIdentifierContext { return s.newName }

func (s *AlterDatabaseRenameContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterDatabaseRenameContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *AlterDatabaseRenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseRenameContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterDatabaseRenameContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *AlterDatabaseRenameContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserRENAME, 0)
}

func (s *AlterDatabaseRenameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterDatabaseRenameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterDatabaseRenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterDatabaseRename(s)
	}
}

func (s *AlterDatabaseRenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterDatabaseRename(s)
	}
}

type AlterWorkloadPolicyContext struct {
	UnsupportedAlterStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewAlterWorkloadPolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterWorkloadPolicyContext {
	var p = new(AlterWorkloadPolicyContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterWorkloadPolicyContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *AlterWorkloadPolicyContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterWorkloadPolicyContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *AlterWorkloadPolicyContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterWorkloadPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterWorkloadPolicyContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterWorkloadPolicyContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserWORKLOAD, 0)
}

func (s *AlterWorkloadPolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *AlterWorkloadPolicyContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *AlterWorkloadPolicyContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterWorkloadPolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterWorkloadPolicy(s)
	}
}

func (s *AlterWorkloadPolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterWorkloadPolicy(s)
	}
}

type AlterDatabasePropertiesContext struct {
	UnsupportedAlterStatementContext
	name IIdentifierContext
}

func NewAlterDatabasePropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterDatabasePropertiesContext {
	var p = new(AlterDatabasePropertiesContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterDatabasePropertiesContext) GetName() IIdentifierContext { return s.name }

func (s *AlterDatabasePropertiesContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterDatabasePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabasePropertiesContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterDatabasePropertiesContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *AlterDatabasePropertiesContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterDatabasePropertiesContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *AlterDatabasePropertiesContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterDatabasePropertiesContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterDatabasePropertiesContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterDatabasePropertiesContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterDatabasePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterDatabaseProperties(s)
	}
}

func (s *AlterDatabasePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterDatabaseProperties(s)
	}
}

type AlterCatalogPropertiesContext struct {
	UnsupportedAlterStatementContext
	name IIdentifierContext
}

func NewAlterCatalogPropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterCatalogPropertiesContext {
	var p = new(AlterCatalogPropertiesContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterCatalogPropertiesContext) GetName() IIdentifierContext { return s.name }

func (s *AlterCatalogPropertiesContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterCatalogPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterCatalogPropertiesContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterCatalogPropertiesContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *AlterCatalogPropertiesContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterCatalogPropertiesContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *AlterCatalogPropertiesContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterCatalogPropertiesContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterCatalogPropertiesContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterCatalogPropertiesContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterCatalogPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterCatalogProperties(s)
	}
}

func (s *AlterCatalogPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterCatalogProperties(s)
	}
}

type AlterCatalogCommentContext struct {
	UnsupportedAlterStatementContext
	name    IIdentifierContext
	comment antlr.Token
}

func NewAlterCatalogCommentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterCatalogCommentContext {
	var p = new(AlterCatalogCommentContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterCatalogCommentContext) GetComment() antlr.Token { return s.comment }

func (s *AlterCatalogCommentContext) SetComment(v antlr.Token) { s.comment = v }

func (s *AlterCatalogCommentContext) GetName() IIdentifierContext { return s.name }

func (s *AlterCatalogCommentContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterCatalogCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterCatalogCommentContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterCatalogCommentContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *AlterCatalogCommentContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *AlterCatalogCommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *AlterCatalogCommentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterCatalogCommentContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *AlterCatalogCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterCatalogComment(s)
	}
}

func (s *AlterCatalogCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterCatalogComment(s)
	}
}

type AlterSqlBlockRuleContext struct {
	UnsupportedAlterStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewAlterSqlBlockRuleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterSqlBlockRuleContext {
	var p = new(AlterSqlBlockRuleContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterSqlBlockRuleContext) GetName() IIdentifierContext { return s.name }

func (s *AlterSqlBlockRuleContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterSqlBlockRuleContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterSqlBlockRuleContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterSqlBlockRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSqlBlockRuleContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterSqlBlockRuleContext) SQL_BLOCK_RULE() antlr.TerminalNode {
	return s.GetToken(DorisParserSQL_BLOCK_RULE, 0)
}

func (s *AlterSqlBlockRuleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterSqlBlockRuleContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterSqlBlockRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterSqlBlockRule(s)
	}
}

func (s *AlterSqlBlockRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterSqlBlockRule(s)
	}
}

type AlterResourceContext struct {
	UnsupportedAlterStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewAlterResourceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterResourceContext {
	var p = new(AlterResourceContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterResourceContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *AlterResourceContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterResourceContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *AlterResourceContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterResourceContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterResourceContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCE, 0)
}

func (s *AlterResourceContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *AlterResourceContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterResourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterResource(s)
	}
}

func (s *AlterResourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterResource(s)
	}
}

type AlterRoutineLoadContext struct {
	UnsupportedAlterStatementContext
	name       IMultipartIdentifierContext
	properties IPropertyClauseContext
	type_      IIdentifierContext
}

func NewAlterRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterRoutineLoadContext {
	var p = new(AlterRoutineLoadContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterRoutineLoadContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterRoutineLoadContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterRoutineLoadContext) GetType_() IIdentifierContext { return s.type_ }

func (s *AlterRoutineLoadContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterRoutineLoadContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterRoutineLoadContext) SetType_(v IIdentifierContext) { s.type_ = v }

func (s *AlterRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRoutineLoadContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserROUTINE, 0)
}

func (s *AlterRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *AlterRoutineLoadContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *AlterRoutineLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterRoutineLoadContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *AlterRoutineLoadContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterRoutineLoadContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterRoutineLoadContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterRoutineLoadContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterRoutineLoadContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterRoutineLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterRoutineLoad(s)
	}
}

func (s *AlterRoutineLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterRoutineLoad(s)
	}
}

type AlterTableAddRollupContext struct {
	UnsupportedAlterStatementContext
	tableName IMultipartIdentifierContext
}

func NewAlterTableAddRollupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableAddRollupContext {
	var p = new(AlterTableAddRollupContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterTableAddRollupContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *AlterTableAddRollupContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *AlterTableAddRollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableAddRollupContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterTableAddRollupContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AlterTableAddRollupContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AlterTableAddRollupContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *AlterTableAddRollupContext) AllAddRollupClause() []IAddRollupClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAddRollupClauseContext); ok {
			len++
		}
	}

	tst := make([]IAddRollupClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAddRollupClauseContext); ok {
			tst[i] = t.(IAddRollupClauseContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableAddRollupContext) AddRollupClause(i int) IAddRollupClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddRollupClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddRollupClauseContext)
}

func (s *AlterTableAddRollupContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterTableAddRollupContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AlterTableAddRollupContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AlterTableAddRollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterTableAddRollup(s)
	}
}

func (s *AlterTableAddRollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterTableAddRollup(s)
	}
}

type AlterRepositoryContext struct {
	UnsupportedAlterStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewAlterRepositoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterRepositoryContext {
	var p = new(AlterRepositoryContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterRepositoryContext) GetName() IIdentifierContext { return s.name }

func (s *AlterRepositoryContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterRepositoryContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterRepositoryContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterRepositoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRepositoryContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterRepositoryContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisParserREPOSITORY, 0)
}

func (s *AlterRepositoryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterRepositoryContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterRepositoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterRepository(s)
	}
}

func (s *AlterRepositoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterRepository(s)
	}
}

type AlterTableContext struct {
	UnsupportedAlterStatementContext
	tableName IMultipartIdentifierContext
}

func NewAlterTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableContext {
	var p = new(AlterTableContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterTableContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *AlterTableContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *AlterTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AlterTableContext) AllAlterTableClause() []IAlterTableClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterTableClauseContext); ok {
			len++
		}
	}

	tst := make([]IAlterTableClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterTableClauseContext); ok {
			tst[i] = t.(IAlterTableClauseContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableContext) AlterTableClause(i int) IAlterTableClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableClauseContext)
}

func (s *AlterTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AlterTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AlterTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterTable(s)
	}
}

func (s *AlterTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterTable(s)
	}
}

type AlterColocateGroupContext struct {
	UnsupportedAlterStatementContext
	name IMultipartIdentifierContext
}

func NewAlterColocateGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterColocateGroupContext {
	var p = new(AlterColocateGroupContext)

	InitEmptyUnsupportedAlterStatementContext(&p.UnsupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAlterStatementContext))

	return p
}

func (s *AlterColocateGroupContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterColocateGroupContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterColocateGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterColocateGroupContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterColocateGroupContext) COLOCATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLOCATE, 0)
}

func (s *AlterColocateGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUP, 0)
}

func (s *AlterColocateGroupContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterColocateGroupContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterColocateGroupContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterColocateGroupContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterColocateGroupContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterColocateGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterColocateGroup(s)
	}
}

func (s *AlterColocateGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterColocateGroup(s)
	}
}

func (p *DorisParser) UnsupportedAlterStatement() (localctx IUnsupportedAlterStatementContext) {
	localctx = NewUnsupportedAlterStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, DorisParserRULE_unsupportedAlterStatement)
	var _la int

	p.SetState(1497)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 164, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAlterTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1327)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1328)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1329)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterTableContext).tableName = _x
		}
		{
			p.SetState(1330)
			p.AlterTableClause()
		}
		p.SetState(1335)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(1331)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1332)
				p.AlterTableClause()
			}

			p.SetState(1337)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewAlterTableAddRollupContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1338)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1339)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1340)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterTableAddRollupContext).tableName = _x
		}
		{
			p.SetState(1341)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1342)
			p.Match(DorisParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1343)
			p.AddRollupClause()
		}
		p.SetState(1348)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(1344)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1345)
				p.AddRollupClause()
			}

			p.SetState(1350)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		localctx = NewAlterTableDropRollupContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1351)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1352)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1353)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterTableDropRollupContext).tableName = _x
		}
		{
			p.SetState(1354)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1355)
			p.Match(DorisParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1356)
			p.DropRollupClause()
		}
		p.SetState(1361)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(1357)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1358)
				p.DropRollupClause()
			}

			p.SetState(1363)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 4:
		localctx = NewAlterSystemContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1364)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1365)
			p.Match(DorisParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1366)
			p.AlterSystemClause()
		}

	case 5:
		localctx = NewAlterDatabaseSetQuotaContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1367)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1368)
			p.Match(DorisParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1369)

			var _x = p.Identifier()

			localctx.(*AlterDatabaseSetQuotaContext).name = _x
		}
		{
			p.SetState(1370)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1371)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserDATA || _la == DorisParserREPLICA || _la == DorisParserTRANSACTION) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1372)
			p.Match(DorisParserQUOTA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1373)
			p.Match(DorisParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1375)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1153040409952344576) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&-53021438386753) != 0) || ((int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&3476586699635759401) != 0) || ((int64((_la-195)) & ^0x3f) == 0 && ((int64(1)<<(_la-195))&-3139048519776880011) != 0) || ((int64((_la-260)) & ^0x3f) == 0 && ((int64(1)<<(_la-260))&-4544906634320822477) != 0) || ((int64((_la-325)) & ^0x3f) == 0 && ((int64(1)<<(_la-325))&6339805778266808319) != 0) || ((int64((_la-390)) & ^0x3f) == 0 && ((int64(1)<<(_la-390))&-656945004016972825) != 0) || ((int64((_la-456)) & ^0x3f) == 0 && ((int64(1)<<(_la-456))&18760394443469) != 0) || ((int64((_la-522)) & ^0x3f) == 0 && ((int64(1)<<(_la-522))&49159) != 0) {
			{
				p.SetState(1374)
				p.Identifier()
			}

		}

	case 6:
		localctx = NewAlterDatabaseRenameContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1377)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1378)
			p.Match(DorisParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1379)

			var _x = p.Identifier()

			localctx.(*AlterDatabaseRenameContext).name = _x
		}
		{
			p.SetState(1380)
			p.Match(DorisParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1381)

			var _x = p.Identifier()

			localctx.(*AlterDatabaseRenameContext).newName = _x
		}

	case 7:
		localctx = NewAlterDatabasePropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1383)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1384)
			p.Match(DorisParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1385)

			var _x = p.Identifier()

			localctx.(*AlterDatabasePropertiesContext).name = _x
		}
		{
			p.SetState(1386)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1387)
			p.Match(DorisParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1388)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1389)
			p.PropertyItemList()
		}
		{
			p.SetState(1390)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewAlterCatalogRenameContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1392)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1393)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1394)

			var _x = p.Identifier()

			localctx.(*AlterCatalogRenameContext).name = _x
		}
		{
			p.SetState(1395)
			p.Match(DorisParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1396)

			var _x = p.Identifier()

			localctx.(*AlterCatalogRenameContext).newName = _x
		}

	case 9:
		localctx = NewAlterCatalogPropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1398)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1399)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1400)

			var _x = p.Identifier()

			localctx.(*AlterCatalogPropertiesContext).name = _x
		}
		{
			p.SetState(1401)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1402)
			p.Match(DorisParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1403)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1404)
			p.PropertyItemList()
		}
		{
			p.SetState(1405)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewAlterCatalogCommentContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1407)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1408)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1409)

			var _x = p.Identifier()

			localctx.(*AlterCatalogCommentContext).name = _x
		}
		{
			p.SetState(1410)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1411)
			p.Match(DorisParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1412)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*AlterCatalogCommentContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewAlterResourceContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1414)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1415)
			p.Match(DorisParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1416)

			var _x = p.IdentifierOrText()

			localctx.(*AlterResourceContext).name = _x
		}
		p.SetState(1418)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1417)

				var _x = p.PropertyClause()

				localctx.(*AlterResourceContext).properties = _x
			}

		}

	case 12:
		localctx = NewAlterColocateGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1420)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1421)
			p.Match(DorisParserCOLOCATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1422)
			p.Match(DorisParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1423)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterColocateGroupContext).name = _x
		}
		{
			p.SetState(1424)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1425)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1426)
			p.PropertyItemList()
		}
		{
			p.SetState(1427)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		localctx = NewAlterWorkloadGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1429)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1430)
			p.Match(DorisParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1431)
			p.Match(DorisParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1432)

			var _x = p.IdentifierOrText()

			localctx.(*AlterWorkloadGroupContext).name = _x
		}
		p.SetState(1434)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1433)

				var _x = p.PropertyClause()

				localctx.(*AlterWorkloadGroupContext).properties = _x
			}

		}

	case 14:
		localctx = NewAlterWorkloadPolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1436)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1437)
			p.Match(DorisParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1438)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1439)

			var _x = p.IdentifierOrText()

			localctx.(*AlterWorkloadPolicyContext).name = _x
		}
		p.SetState(1441)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1440)

				var _x = p.PropertyClause()

				localctx.(*AlterWorkloadPolicyContext).properties = _x
			}

		}

	case 15:
		localctx = NewAlterRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1443)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1444)
			p.Match(DorisParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1445)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1446)
			p.Match(DorisParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1447)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterRoutineLoadContext).name = _x
		}
		p.SetState(1449)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1448)

				var _x = p.PropertyClause()

				localctx.(*AlterRoutineLoadContext).properties = _x
			}

		}
		p.SetState(1457)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(1451)
				p.Match(DorisParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1452)

				var _x = p.Identifier()

				localctx.(*AlterRoutineLoadContext).type_ = _x
			}
			{
				p.SetState(1453)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1454)
				p.PropertyItemList()
			}
			{
				p.SetState(1455)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 16:
		localctx = NewAlterSqlBlockRuleContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1459)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1460)
			p.Match(DorisParserSQL_BLOCK_RULE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1461)

			var _x = p.Identifier()

			localctx.(*AlterSqlBlockRuleContext).name = _x
		}
		p.SetState(1463)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1462)

				var _x = p.PropertyClause()

				localctx.(*AlterSqlBlockRuleContext).properties = _x
			}

		}

	case 17:
		localctx = NewAlterTablePropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1465)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1466)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1467)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterTablePropertiesContext).name = _x
		}
		{
			p.SetState(1468)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1469)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1470)
			p.PropertyItemList()
		}
		{
			p.SetState(1471)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		localctx = NewAlterStoragePlicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1473)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1474)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1475)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1476)

			var _x = p.IdentifierOrText()

			localctx.(*AlterStoragePlicyContext).name = _x
		}
		{
			p.SetState(1477)

			var _x = p.PropertyClause()

			localctx.(*AlterStoragePlicyContext).properties = _x
		}

	case 19:
		localctx = NewAlterUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1479)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1480)
			p.Match(DorisParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1483)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1481)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1482)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1485)
			p.GrantUserIdentify()
		}
		{
			p.SetState(1486)
			p.PasswordOption()
		}
		p.SetState(1489)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(1487)
				p.Match(DorisParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1488)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 20:
		localctx = NewAlterRepositoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1491)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1492)
			p.Match(DorisParserREPOSITORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1493)

			var _x = p.Identifier()

			localctx.(*AlterRepositoryContext).name = _x
		}
		p.SetState(1495)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1494)

				var _x = p.PropertyClause()

				localctx.(*AlterRepositoryContext).properties = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterSystemClauseContext is an interface to support dynamic dispatch.
type IAlterSystemClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlterSystemClauseContext differentiates from other interfaces.
	IsAlterSystemClauseContext()
}

type AlterSystemClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterSystemClauseContext() *AlterSystemClauseContext {
	var p = new(AlterSystemClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_alterSystemClause
	return p
}

func InitEmptyAlterSystemClauseContext(p *AlterSystemClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_alterSystemClause
}

func (*AlterSystemClauseContext) IsAlterSystemClauseContext() {}

func NewAlterSystemClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterSystemClauseContext {
	var p = new(AlterSystemClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_alterSystemClause

	return p
}

func (s *AlterSystemClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterSystemClauseContext) CopyAll(ctx *AlterSystemClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AlterSystemClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSystemClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DropBrokerClauseContext struct {
	AlterSystemClauseContext
	name            IIdentifierOrTextContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
}

func NewDropBrokerClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropBrokerClauseContext {
	var p = new(DropBrokerClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *DropBrokerClauseContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *DropBrokerClauseContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *DropBrokerClauseContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *DropBrokerClauseContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *DropBrokerClauseContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *DropBrokerClauseContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *DropBrokerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropBrokerClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropBrokerClauseContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserBROKER, 0)
}

func (s *DropBrokerClauseContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DropBrokerClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *DropBrokerClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *DropBrokerClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *DropBrokerClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *DropBrokerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropBrokerClause(s)
	}
}

func (s *DropBrokerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropBrokerClause(s)
	}
}

type ModifyFrontendOrBackendHostNameClauseContext struct {
	AlterSystemClauseContext
	hostPort antlr.Token
	hostName antlr.Token
}

func NewModifyFrontendOrBackendHostNameClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyFrontendOrBackendHostNameClauseContext {
	var p = new(ModifyFrontendOrBackendHostNameClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) GetHostPort() antlr.Token { return s.hostPort }

func (s *ModifyFrontendOrBackendHostNameClauseContext) GetHostName() antlr.Token { return s.hostName }

func (s *ModifyFrontendOrBackendHostNameClauseContext) SetHostPort(v antlr.Token) { s.hostPort = v }

func (s *ModifyFrontendOrBackendHostNameClauseContext) SetHostName(v antlr.Token) { s.hostName = v }

func (s *ModifyFrontendOrBackendHostNameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) HOSTNAME() antlr.TerminalNode {
	return s.GetToken(DorisParserHOSTNAME, 0)
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(DorisParserFRONTEND, 0)
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKEND, 0)
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterModifyFrontendOrBackendHostNameClause(s)
	}
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitModifyFrontendOrBackendHostNameClause(s)
	}
}

type DropObserverClauseContext struct {
	AlterSystemClauseContext
	hostPort antlr.Token
}

func NewDropObserverClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropObserverClauseContext {
	var p = new(DropObserverClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *DropObserverClauseContext) GetHostPort() antlr.Token { return s.hostPort }

func (s *DropObserverClauseContext) SetHostPort(v antlr.Token) { s.hostPort = v }

func (s *DropObserverClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropObserverClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropObserverClauseContext) OBSERVER() antlr.TerminalNode {
	return s.GetToken(DorisParserOBSERVER, 0)
}

func (s *DropObserverClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *DropObserverClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropObserverClause(s)
	}
}

func (s *DropObserverClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropObserverClause(s)
	}
}

type AddFollowerClauseContext struct {
	AlterSystemClauseContext
	hostPort antlr.Token
}

func NewAddFollowerClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddFollowerClauseContext {
	var p = new(AddFollowerClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *AddFollowerClauseContext) GetHostPort() antlr.Token { return s.hostPort }

func (s *AddFollowerClauseContext) SetHostPort(v antlr.Token) { s.hostPort = v }

func (s *AddFollowerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddFollowerClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddFollowerClauseContext) FOLLOWER() antlr.TerminalNode {
	return s.GetToken(DorisParserFOLLOWER, 0)
}

func (s *AddFollowerClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *AddFollowerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddFollowerClause(s)
	}
}

func (s *AddFollowerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddFollowerClause(s)
	}
}

type DropFollowerClauseContext struct {
	AlterSystemClauseContext
	hostPort antlr.Token
}

func NewDropFollowerClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropFollowerClauseContext {
	var p = new(DropFollowerClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *DropFollowerClauseContext) GetHostPort() antlr.Token { return s.hostPort }

func (s *DropFollowerClauseContext) SetHostPort(v antlr.Token) { s.hostPort = v }

func (s *DropFollowerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFollowerClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropFollowerClauseContext) FOLLOWER() antlr.TerminalNode {
	return s.GetToken(DorisParserFOLLOWER, 0)
}

func (s *DropFollowerClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *DropFollowerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropFollowerClause(s)
	}
}

func (s *DropFollowerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropFollowerClause(s)
	}
}

type DropAllBrokerClauseContext struct {
	AlterSystemClauseContext
	name IIdentifierOrTextContext
}

func NewDropAllBrokerClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropAllBrokerClauseContext {
	var p = new(DropAllBrokerClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *DropAllBrokerClauseContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *DropAllBrokerClauseContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *DropAllBrokerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropAllBrokerClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropAllBrokerClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *DropAllBrokerClauseContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserBROKER, 0)
}

func (s *DropAllBrokerClauseContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DropAllBrokerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropAllBrokerClause(s)
	}
}

func (s *DropAllBrokerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropAllBrokerClause(s)
	}
}

type DropBackendClauseContext struct {
	AlterSystemClauseContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
}

func NewDropBackendClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropBackendClauseContext {
	var p = new(DropBackendClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *DropBackendClauseContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *DropBackendClauseContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *DropBackendClauseContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *DropBackendClauseContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *DropBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKEND, 0)
}

func (s *DropBackendClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropBackendClauseContext) DROPP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROPP, 0)
}

func (s *DropBackendClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *DropBackendClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *DropBackendClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *DropBackendClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *DropBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropBackendClause(s)
	}
}

func (s *DropBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropBackendClause(s)
	}
}

type AlterLoadErrorUrlClauseContext struct {
	AlterSystemClauseContext
	properties IPropertyClauseContext
}

func NewAlterLoadErrorUrlClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterLoadErrorUrlClauseContext {
	var p = new(AlterLoadErrorUrlClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *AlterLoadErrorUrlClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterLoadErrorUrlClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterLoadErrorUrlClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterLoadErrorUrlClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterLoadErrorUrlClauseContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *AlterLoadErrorUrlClauseContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(DorisParserERRORS, 0)
}

func (s *AlterLoadErrorUrlClauseContext) HUB() antlr.TerminalNode {
	return s.GetToken(DorisParserHUB, 0)
}

func (s *AlterLoadErrorUrlClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterLoadErrorUrlClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterLoadErrorUrlClause(s)
	}
}

func (s *AlterLoadErrorUrlClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterLoadErrorUrlClause(s)
	}
}

type ModifyBackendClauseContext struct {
	AlterSystemClauseContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
}

func NewModifyBackendClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyBackendClauseContext {
	var p = new(ModifyBackendClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *ModifyBackendClauseContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *ModifyBackendClauseContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *ModifyBackendClauseContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *ModifyBackendClauseContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *ModifyBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyBackendClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *ModifyBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKEND, 0)
}

func (s *ModifyBackendClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *ModifyBackendClauseContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ModifyBackendClauseContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *ModifyBackendClauseContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ModifyBackendClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *ModifyBackendClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *ModifyBackendClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ModifyBackendClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ModifyBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterModifyBackendClause(s)
	}
}

func (s *ModifyBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitModifyBackendClause(s)
	}
}

type AddBrokerClauseContext struct {
	AlterSystemClauseContext
	name            IIdentifierOrTextContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
}

func NewAddBrokerClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddBrokerClauseContext {
	var p = new(AddBrokerClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *AddBrokerClauseContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *AddBrokerClauseContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *AddBrokerClauseContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *AddBrokerClauseContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *AddBrokerClauseContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *AddBrokerClauseContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *AddBrokerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddBrokerClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddBrokerClauseContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserBROKER, 0)
}

func (s *AddBrokerClauseContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *AddBrokerClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *AddBrokerClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *AddBrokerClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AddBrokerClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AddBrokerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddBrokerClause(s)
	}
}

func (s *AddBrokerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddBrokerClause(s)
	}
}

type AddObserverClauseContext struct {
	AlterSystemClauseContext
	hostPort antlr.Token
}

func NewAddObserverClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddObserverClauseContext {
	var p = new(AddObserverClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *AddObserverClauseContext) GetHostPort() antlr.Token { return s.hostPort }

func (s *AddObserverClauseContext) SetHostPort(v antlr.Token) { s.hostPort = v }

func (s *AddObserverClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddObserverClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddObserverClauseContext) OBSERVER() antlr.TerminalNode {
	return s.GetToken(DorisParserOBSERVER, 0)
}

func (s *AddObserverClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *AddObserverClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddObserverClause(s)
	}
}

func (s *AddObserverClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddObserverClause(s)
	}
}

type DecommissionBackendClauseContext struct {
	AlterSystemClauseContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
}

func NewDecommissionBackendClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecommissionBackendClauseContext {
	var p = new(DecommissionBackendClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *DecommissionBackendClauseContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *DecommissionBackendClauseContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *DecommissionBackendClauseContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *DecommissionBackendClauseContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *DecommissionBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecommissionBackendClauseContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(DorisParserDECOMMISSION, 0)
}

func (s *DecommissionBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKEND, 0)
}

func (s *DecommissionBackendClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *DecommissionBackendClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *DecommissionBackendClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *DecommissionBackendClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *DecommissionBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDecommissionBackendClause(s)
	}
}

func (s *DecommissionBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDecommissionBackendClause(s)
	}
}

type AddBackendClauseContext struct {
	AlterSystemClauseContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
	properties      IPropertyClauseContext
}

func NewAddBackendClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddBackendClauseContext {
	var p = new(AddBackendClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *AddBackendClauseContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *AddBackendClauseContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *AddBackendClauseContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *AddBackendClauseContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *AddBackendClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AddBackendClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AddBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddBackendClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKEND, 0)
}

func (s *AddBackendClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *AddBackendClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *AddBackendClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AddBackendClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AddBackendClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AddBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddBackendClause(s)
	}
}

func (s *AddBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddBackendClause(s)
	}
}

func (p *DorisParser) AlterSystemClause() (localctx IAlterSystemClauseContext) {
	localctx = NewAlterSystemClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, DorisParserRULE_alterSystemClause)
	var _la int

	p.SetState(1597)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 173, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAddBackendClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1499)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1500)
			p.Match(DorisParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1501)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*AddBackendClauseContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*AddBackendClauseContext).hostPorts = append(localctx.(*AddBackendClauseContext).hostPorts, localctx.(*AddBackendClauseContext)._STRING_LITERAL)
		p.SetState(1506)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(1502)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1503)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*AddBackendClauseContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*AddBackendClauseContext).hostPorts = append(localctx.(*AddBackendClauseContext).hostPorts, localctx.(*AddBackendClauseContext)._STRING_LITERAL)

			p.SetState(1508)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1510)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1509)

				var _x = p.PropertyClause()

				localctx.(*AddBackendClauseContext).properties = _x
			}

		}

	case 2:
		localctx = NewDropBackendClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1512)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserDROP || _la == DorisParserDROPP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1513)
			p.Match(DorisParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1514)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*DropBackendClauseContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*DropBackendClauseContext).hostPorts = append(localctx.(*DropBackendClauseContext).hostPorts, localctx.(*DropBackendClauseContext)._STRING_LITERAL)
		p.SetState(1519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(1515)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1516)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*DropBackendClauseContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*DropBackendClauseContext).hostPorts = append(localctx.(*DropBackendClauseContext).hostPorts, localctx.(*DropBackendClauseContext)._STRING_LITERAL)

			p.SetState(1521)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		localctx = NewDecommissionBackendClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1522)
			p.Match(DorisParserDECOMMISSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1523)
			p.Match(DorisParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1524)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*DecommissionBackendClauseContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*DecommissionBackendClauseContext).hostPorts = append(localctx.(*DecommissionBackendClauseContext).hostPorts, localctx.(*DecommissionBackendClauseContext)._STRING_LITERAL)
		p.SetState(1529)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(1525)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1526)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*DecommissionBackendClauseContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*DecommissionBackendClauseContext).hostPorts = append(localctx.(*DecommissionBackendClauseContext).hostPorts, localctx.(*DecommissionBackendClauseContext)._STRING_LITERAL)

			p.SetState(1531)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 4:
		localctx = NewAddObserverClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1532)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1533)
			p.Match(DorisParserOBSERVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1534)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*AddObserverClauseContext).hostPort = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewDropObserverClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1535)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1536)
			p.Match(DorisParserOBSERVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1537)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*DropObserverClauseContext).hostPort = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewAddFollowerClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1538)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1539)
			p.Match(DorisParserFOLLOWER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1540)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*AddFollowerClauseContext).hostPort = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewDropFollowerClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1541)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1542)
			p.Match(DorisParserFOLLOWER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1543)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*DropFollowerClauseContext).hostPort = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewAddBrokerClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1544)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1545)
			p.Match(DorisParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1546)

			var _x = p.IdentifierOrText()

			localctx.(*AddBrokerClauseContext).name = _x
		}
		{
			p.SetState(1547)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*AddBrokerClauseContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*AddBrokerClauseContext).hostPorts = append(localctx.(*AddBrokerClauseContext).hostPorts, localctx.(*AddBrokerClauseContext)._STRING_LITERAL)
		p.SetState(1552)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(1548)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1549)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*AddBrokerClauseContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*AddBrokerClauseContext).hostPorts = append(localctx.(*AddBrokerClauseContext).hostPorts, localctx.(*AddBrokerClauseContext)._STRING_LITERAL)

			p.SetState(1554)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 9:
		localctx = NewDropBrokerClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1555)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1556)
			p.Match(DorisParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1557)

			var _x = p.IdentifierOrText()

			localctx.(*DropBrokerClauseContext).name = _x
		}
		{
			p.SetState(1558)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*DropBrokerClauseContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*DropBrokerClauseContext).hostPorts = append(localctx.(*DropBrokerClauseContext).hostPorts, localctx.(*DropBrokerClauseContext)._STRING_LITERAL)
		p.SetState(1563)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(1559)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1560)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*DropBrokerClauseContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*DropBrokerClauseContext).hostPorts = append(localctx.(*DropBrokerClauseContext).hostPorts, localctx.(*DropBrokerClauseContext)._STRING_LITERAL)

			p.SetState(1565)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 10:
		localctx = NewDropAllBrokerClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1566)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1567)
			p.Match(DorisParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1568)
			p.Match(DorisParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1569)

			var _x = p.IdentifierOrText()

			localctx.(*DropAllBrokerClauseContext).name = _x
		}

	case 11:
		localctx = NewAlterLoadErrorUrlClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1570)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1571)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1572)
			p.Match(DorisParserERRORS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1573)
			p.Match(DorisParserHUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1575)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1574)

				var _x = p.PropertyClause()

				localctx.(*AlterLoadErrorUrlClauseContext).properties = _x
			}

		}

	case 12:
		localctx = NewModifyBackendClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1577)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1578)
			p.Match(DorisParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1579)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ModifyBackendClauseContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ModifyBackendClauseContext).hostPorts = append(localctx.(*ModifyBackendClauseContext).hostPorts, localctx.(*ModifyBackendClauseContext)._STRING_LITERAL)
		p.SetState(1584)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(1580)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1581)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*ModifyBackendClauseContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*ModifyBackendClauseContext).hostPorts = append(localctx.(*ModifyBackendClauseContext).hostPorts, localctx.(*ModifyBackendClauseContext)._STRING_LITERAL)

			p.SetState(1586)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1587)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1588)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1589)
			p.PropertyItemList()
		}
		{
			p.SetState(1590)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		localctx = NewModifyFrontendOrBackendHostNameClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1592)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1593)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserBACKEND || _la == DorisParserFRONTEND) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1594)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ModifyFrontendOrBackendHostNameClauseContext).hostPort = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1595)
			p.Match(DorisParserHOSTNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1596)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ModifyFrontendOrBackendHostNameClauseContext).hostName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropRollupClauseContext is an interface to support dynamic dispatch.
type IDropRollupClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// GetProperties returns the properties rule contexts.
	GetProperties() IPropertyClauseContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// SetProperties sets the properties rule contexts.
	SetProperties(IPropertyClauseContext)

	// Getter signatures
	Identifier() IIdentifierContext
	PropertyClause() IPropertyClauseContext

	// IsDropRollupClauseContext differentiates from other interfaces.
	IsDropRollupClauseContext()
}

type DropRollupClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
	properties IPropertyClauseContext
}

func NewEmptyDropRollupClauseContext() *DropRollupClauseContext {
	var p = new(DropRollupClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dropRollupClause
	return p
}

func InitEmptyDropRollupClauseContext(p *DropRollupClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dropRollupClause
}

func (*DropRollupClauseContext) IsDropRollupClauseContext() {}

func NewDropRollupClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropRollupClauseContext {
	var p = new(DropRollupClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_dropRollupClause

	return p
}

func (s *DropRollupClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropRollupClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *DropRollupClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *DropRollupClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *DropRollupClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *DropRollupClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropRollupClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *DropRollupClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRollupClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropRollupClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropRollupClause(s)
	}
}

func (s *DropRollupClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropRollupClause(s)
	}
}

func (p *DorisParser) DropRollupClause() (localctx IDropRollupClauseContext) {
	localctx = NewDropRollupClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, DorisParserRULE_dropRollupClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1599)

		var _x = p.Identifier()

		localctx.(*DropRollupClauseContext).rollupName = _x
	}
	p.SetState(1601)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPROPERTIES {
		{
			p.SetState(1600)

			var _x = p.PropertyClause()

			localctx.(*DropRollupClauseContext).properties = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddRollupClauseContext is an interface to support dynamic dispatch.
type IAddRollupClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IIdentifierListContext

	// GetDupKeys returns the dupKeys rule contexts.
	GetDupKeys() IIdentifierListContext

	// GetProperties returns the properties rule contexts.
	GetProperties() IPropertyClauseContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IIdentifierListContext)

	// SetDupKeys sets the dupKeys rule contexts.
	SetDupKeys(IIdentifierListContext)

	// SetProperties sets the properties rule contexts.
	SetProperties(IPropertyClauseContext)

	// Getter signatures
	Identifier() IIdentifierContext
	AllIdentifierList() []IIdentifierListContext
	IdentifierList(i int) IIdentifierListContext
	DUPLICATE() antlr.TerminalNode
	KEY() antlr.TerminalNode
	FromRollup() IFromRollupContext
	PropertyClause() IPropertyClauseContext

	// IsAddRollupClauseContext differentiates from other interfaces.
	IsAddRollupClauseContext()
}

type AddRollupClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
	columns    IIdentifierListContext
	dupKeys    IIdentifierListContext
	properties IPropertyClauseContext
}

func NewEmptyAddRollupClauseContext() *AddRollupClauseContext {
	var p = new(AddRollupClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_addRollupClause
	return p
}

func InitEmptyAddRollupClauseContext(p *AddRollupClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_addRollupClause
}

func (*AddRollupClauseContext) IsAddRollupClauseContext() {}

func NewAddRollupClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddRollupClauseContext {
	var p = new(AddRollupClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_addRollupClause

	return p
}

func (s *AddRollupClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddRollupClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *AddRollupClauseContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *AddRollupClauseContext) GetDupKeys() IIdentifierListContext { return s.dupKeys }

func (s *AddRollupClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AddRollupClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *AddRollupClauseContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *AddRollupClauseContext) SetDupKeys(v IIdentifierListContext) { s.dupKeys = v }

func (s *AddRollupClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AddRollupClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddRollupClauseContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *AddRollupClauseContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *AddRollupClauseContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(DorisParserDUPLICATE, 0)
}

func (s *AddRollupClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserKEY, 0)
}

func (s *AddRollupClauseContext) FromRollup() IFromRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromRollupContext)
}

func (s *AddRollupClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AddRollupClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddRollupClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddRollupClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddRollupClause(s)
	}
}

func (s *AddRollupClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddRollupClause(s)
	}
}

func (p *DorisParser) AddRollupClause() (localctx IAddRollupClauseContext) {
	localctx = NewAddRollupClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, DorisParserRULE_addRollupClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1603)

		var _x = p.Identifier()

		localctx.(*AddRollupClauseContext).rollupName = _x
	}
	{
		p.SetState(1604)

		var _x = p.IdentifierList()

		localctx.(*AddRollupClauseContext).columns = _x
	}
	p.SetState(1608)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserDUPLICATE {
		{
			p.SetState(1605)
			p.Match(DorisParserDUPLICATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1606)
			p.Match(DorisParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1607)

			var _x = p.IdentifierList()

			localctx.(*AddRollupClauseContext).dupKeys = _x
		}

	}
	p.SetState(1611)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserFROM {
		{
			p.SetState(1610)
			p.FromRollup()
		}

	}
	p.SetState(1614)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPROPERTIES {
		{
			p.SetState(1613)

			var _x = p.PropertyClause()

			localctx.(*AddRollupClauseContext).properties = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableClauseContext is an interface to support dynamic dispatch.
type IAlterTableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlterTableClauseContext differentiates from other interfaces.
	IsAlterTableClauseContext()
}

type AlterTableClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableClauseContext() *AlterTableClauseContext {
	var p = new(AlterTableClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_alterTableClause
	return p
}

func InitEmptyAlterTableClauseContext(p *AlterTableClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_alterTableClause
}

func (*AlterTableClauseContext) IsAlterTableClauseContext() {}

func NewAlterTableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableClauseContext {
	var p = new(AlterTableClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_alterTableClause

	return p
}

func (s *AlterTableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableClauseContext) CopyAll(ctx *AlterTableClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AlterTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AddPartitionClauseContext struct {
	AlterTableClauseContext
	partitionProperties IPropertyItemListContext
	hashKeys            IIdentifierListContext
	autoBucket          antlr.Token
	properties          IPropertyClauseContext
}

func NewAddPartitionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddPartitionClauseContext {
	var p = new(AddPartitionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AddPartitionClauseContext) GetAutoBucket() antlr.Token { return s.autoBucket }

func (s *AddPartitionClauseContext) SetAutoBucket(v antlr.Token) { s.autoBucket = v }

func (s *AddPartitionClauseContext) GetPartitionProperties() IPropertyItemListContext {
	return s.partitionProperties
}

func (s *AddPartitionClauseContext) GetHashKeys() IIdentifierListContext { return s.hashKeys }

func (s *AddPartitionClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AddPartitionClauseContext) SetPartitionProperties(v IPropertyItemListContext) {
	s.partitionProperties = v
}

func (s *AddPartitionClauseContext) SetHashKeys(v IIdentifierListContext) { s.hashKeys = v }

func (s *AddPartitionClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AddPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddPartitionClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddPartitionClauseContext) LessThanPartitionDef() ILessThanPartitionDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILessThanPartitionDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILessThanPartitionDefContext)
}

func (s *AddPartitionClauseContext) FixedPartitionDef() IFixedPartitionDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFixedPartitionDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFixedPartitionDefContext)
}

func (s *AddPartitionClauseContext) InPartitionDef() IInPartitionDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInPartitionDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInPartitionDefContext)
}

func (s *AddPartitionClauseContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *AddPartitionClauseContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AddPartitionClauseContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AddPartitionClauseContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTRIBUTED, 0)
}

func (s *AddPartitionClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *AddPartitionClauseContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AddPartitionClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AddPartitionClauseContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisParserHASH, 0)
}

func (s *AddPartitionClauseContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(DorisParserRANDOM, 0)
}

func (s *AddPartitionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *AddPartitionClauseContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisParserBUCKETS, 0)
}

func (s *AddPartitionClauseContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *AddPartitionClauseContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO, 0)
}

func (s *AddPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddPartitionClause(s)
	}
}

func (s *AddPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddPartitionClause(s)
	}
}

type ModifyDistributionClauseContext struct {
	AlterTableClauseContext
	hashKeys   IIdentifierListContext
	autoBucket antlr.Token
}

func NewModifyDistributionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyDistributionClauseContext {
	var p = new(ModifyDistributionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ModifyDistributionClauseContext) GetAutoBucket() antlr.Token { return s.autoBucket }

func (s *ModifyDistributionClauseContext) SetAutoBucket(v antlr.Token) { s.autoBucket = v }

func (s *ModifyDistributionClauseContext) GetHashKeys() IIdentifierListContext { return s.hashKeys }

func (s *ModifyDistributionClauseContext) SetHashKeys(v IIdentifierListContext) { s.hashKeys = v }

func (s *ModifyDistributionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyDistributionClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *ModifyDistributionClauseContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTRIBUTION, 0)
}

func (s *ModifyDistributionClauseContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTRIBUTED, 0)
}

func (s *ModifyDistributionClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *ModifyDistributionClauseContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisParserHASH, 0)
}

func (s *ModifyDistributionClauseContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(DorisParserRANDOM, 0)
}

func (s *ModifyDistributionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ModifyDistributionClauseContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisParserBUCKETS, 0)
}

func (s *ModifyDistributionClauseContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ModifyDistributionClauseContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO, 0)
}

func (s *ModifyDistributionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterModifyDistributionClause(s)
	}
}

func (s *ModifyDistributionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitModifyDistributionClause(s)
	}
}

type AddColumnClauseContext struct {
	AlterTableClauseContext
	properties IPropertyClauseContext
}

func NewAddColumnClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddColumnClauseContext {
	var p = new(AddColumnClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AddColumnClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AddColumnClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AddColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddColumnClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *AddColumnClauseContext) ColumnDef() IColumnDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefContext)
}

func (s *AddColumnClauseContext) ColumnPosition() IColumnPositionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnPositionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnPositionContext)
}

func (s *AddColumnClauseContext) ToRollup() IToRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IToRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IToRollupContext)
}

func (s *AddColumnClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AddColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddColumnClause(s)
	}
}

func (s *AddColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddColumnClause(s)
	}
}

type ModifyColumnClauseContext struct {
	AlterTableClauseContext
	properties IPropertyClauseContext
}

func NewModifyColumnClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyColumnClauseContext {
	var p = new(ModifyColumnClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ModifyColumnClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *ModifyColumnClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *ModifyColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyColumnClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *ModifyColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *ModifyColumnClauseContext) ColumnDef() IColumnDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefContext)
}

func (s *ModifyColumnClauseContext) ColumnPosition() IColumnPositionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnPositionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnPositionContext)
}

func (s *ModifyColumnClauseContext) FromRollup() IFromRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromRollupContext)
}

func (s *ModifyColumnClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ModifyColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterModifyColumnClause(s)
	}
}

func (s *ModifyColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitModifyColumnClause(s)
	}
}

type RenameRollupClauseContext struct {
	AlterTableClauseContext
	name    IIdentifierContext
	newName IIdentifierContext
}

func NewRenameRollupClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameRollupClauseContext {
	var p = new(RenameRollupClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *RenameRollupClauseContext) GetName() IIdentifierContext { return s.name }

func (s *RenameRollupClauseContext) GetNewName() IIdentifierContext { return s.newName }

func (s *RenameRollupClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *RenameRollupClauseContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *RenameRollupClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameRollupClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserRENAME, 0)
}

func (s *RenameRollupClauseContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *RenameRollupClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RenameRollupClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenameRollupClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRenameRollupClause(s)
	}
}

func (s *RenameRollupClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRenameRollupClause(s)
	}
}

type AddColumnsClauseContext struct {
	AlterTableClauseContext
	properties IPropertyClauseContext
}

func NewAddColumnsClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddColumnsClauseContext {
	var p = new(AddColumnsClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AddColumnsClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AddColumnsClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AddColumnsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddColumnsClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddColumnsClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *AddColumnsClauseContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AddColumnsClauseContext) AllColumnDef() []IColumnDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnDefContext); ok {
			len++
		}
	}

	tst := make([]IColumnDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnDefContext); ok {
			tst[i] = t.(IColumnDefContext)
			i++
		}
	}

	return tst
}

func (s *AddColumnsClauseContext) ColumnDef(i int) IColumnDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefContext)
}

func (s *AddColumnsClauseContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AddColumnsClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AddColumnsClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AddColumnsClauseContext) ToRollup() IToRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IToRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IToRollupContext)
}

func (s *AddColumnsClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AddColumnsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddColumnsClause(s)
	}
}

func (s *AddColumnsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddColumnsClause(s)
	}
}

type ReplaceTableClauseContext struct {
	AlterTableClauseContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewReplaceTableClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReplaceTableClauseContext {
	var p = new(ReplaceTableClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ReplaceTableClauseContext) GetName() IIdentifierContext { return s.name }

func (s *ReplaceTableClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *ReplaceTableClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ReplaceTableClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *ReplaceTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplaceTableClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *ReplaceTableClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *ReplaceTableClauseContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *ReplaceTableClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReplaceTableClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ReplaceTableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterReplaceTableClause(s)
	}
}

func (s *ReplaceTableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitReplaceTableClause(s)
	}
}

type RenamePartitionClauseContext struct {
	AlterTableClauseContext
	name    IIdentifierContext
	newName IIdentifierContext
}

func NewRenamePartitionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenamePartitionClauseContext {
	var p = new(RenamePartitionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *RenamePartitionClauseContext) GetName() IIdentifierContext { return s.name }

func (s *RenamePartitionClauseContext) GetNewName() IIdentifierContext { return s.newName }

func (s *RenamePartitionClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *RenamePartitionClauseContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *RenamePartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenamePartitionClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserRENAME, 0)
}

func (s *RenamePartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *RenamePartitionClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RenamePartitionClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenamePartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRenamePartitionClause(s)
	}
}

func (s *RenamePartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRenamePartitionClause(s)
	}
}

type DropIndexClauseContext struct {
	AlterTableClauseContext
	name IIdentifierContext
}

func NewDropIndexClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropIndexClauseContext {
	var p = new(DropIndexClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *DropIndexClauseContext) GetName() IIdentifierContext { return s.name }

func (s *DropIndexClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropIndexClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropIndexClauseContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *DropIndexClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropIndexClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropIndexClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropIndexClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropIndexClause(s)
	}
}

func (s *DropIndexClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropIndexClause(s)
	}
}

type DropColumnClauseContext struct {
	AlterTableClauseContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewDropColumnClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropColumnClauseContext {
	var p = new(DropColumnClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *DropColumnClauseContext) GetName() IIdentifierContext { return s.name }

func (s *DropColumnClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *DropColumnClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropColumnClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *DropColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropColumnClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *DropColumnClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropColumnClauseContext) FromRollup() IFromRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromRollupContext)
}

func (s *DropColumnClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *DropColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropColumnClause(s)
	}
}

func (s *DropColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropColumnClause(s)
	}
}

type DropPartitionClauseContext struct {
	AlterTableClauseContext
	partitionName IIdentifierContext
	indexName     IIdentifierContext
}

func NewDropPartitionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropPartitionClauseContext {
	var p = new(DropPartitionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *DropPartitionClauseContext) GetPartitionName() IIdentifierContext { return s.partitionName }

func (s *DropPartitionClauseContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *DropPartitionClauseContext) SetPartitionName(v IIdentifierContext) { s.partitionName = v }

func (s *DropPartitionClauseContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *DropPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropPartitionClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropPartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *DropPartitionClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DropPartitionClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropPartitionClauseContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *DropPartitionClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropPartitionClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropPartitionClauseContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserFORCE, 0)
}

func (s *DropPartitionClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *DropPartitionClauseContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *DropPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropPartitionClause(s)
	}
}

func (s *DropPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropPartitionClause(s)
	}
}

type ReplacePartitionClauseContext struct {
	AlterTableClauseContext
	partitions     IPartitionSpecContext
	tempPartitions IPartitionSpecContext
	properties     IPropertyClauseContext
}

func NewReplacePartitionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReplacePartitionClauseContext {
	var p = new(ReplacePartitionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ReplacePartitionClauseContext) GetPartitions() IPartitionSpecContext { return s.partitions }

func (s *ReplacePartitionClauseContext) GetTempPartitions() IPartitionSpecContext {
	return s.tempPartitions
}

func (s *ReplacePartitionClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *ReplacePartitionClauseContext) SetPartitions(v IPartitionSpecContext) { s.partitions = v }

func (s *ReplacePartitionClauseContext) SetTempPartitions(v IPartitionSpecContext) {
	s.tempPartitions = v
}

func (s *ReplacePartitionClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *ReplacePartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplacePartitionClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *ReplacePartitionClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *ReplacePartitionClauseContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserFORCE, 0)
}

func (s *ReplacePartitionClauseContext) AllPartitionSpec() []IPartitionSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			len++
		}
	}

	tst := make([]IPartitionSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionSpecContext); ok {
			tst[i] = t.(IPartitionSpecContext)
			i++
		}
	}

	return tst
}

func (s *ReplacePartitionClauseContext) PartitionSpec(i int) IPartitionSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *ReplacePartitionClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ReplacePartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterReplacePartitionClause(s)
	}
}

func (s *ReplacePartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitReplacePartitionClause(s)
	}
}

type RenameClauseContext struct {
	AlterTableClauseContext
	newName IIdentifierContext
}

func NewRenameClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameClauseContext {
	var p = new(RenameClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *RenameClauseContext) GetNewName() IIdentifierContext { return s.newName }

func (s *RenameClauseContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *RenameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserRENAME, 0)
}

func (s *RenameClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRenameClause(s)
	}
}

func (s *RenameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRenameClause(s)
	}
}

type ModifyTableCommentClauseContext struct {
	AlterTableClauseContext
	comment antlr.Token
}

func NewModifyTableCommentClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyTableCommentClauseContext {
	var p = new(ModifyTableCommentClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ModifyTableCommentClauseContext) GetComment() antlr.Token { return s.comment }

func (s *ModifyTableCommentClauseContext) SetComment(v antlr.Token) { s.comment = v }

func (s *ModifyTableCommentClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyTableCommentClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *ModifyTableCommentClauseContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *ModifyTableCommentClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ModifyTableCommentClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterModifyTableCommentClause(s)
	}
}

func (s *ModifyTableCommentClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitModifyTableCommentClause(s)
	}
}

type ModifyPartitionClauseContext struct {
	AlterTableClauseContext
	partitionName       IIdentifierContext
	partitionNames      IIdentifierListContext
	partitionProperties IPropertyItemListContext
}

func NewModifyPartitionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyPartitionClauseContext {
	var p = new(ModifyPartitionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ModifyPartitionClauseContext) GetPartitionName() IIdentifierContext { return s.partitionName }

func (s *ModifyPartitionClauseContext) GetPartitionNames() IIdentifierListContext {
	return s.partitionNames
}

func (s *ModifyPartitionClauseContext) GetPartitionProperties() IPropertyItemListContext {
	return s.partitionProperties
}

func (s *ModifyPartitionClauseContext) SetPartitionName(v IIdentifierContext) { s.partitionName = v }

func (s *ModifyPartitionClauseContext) SetPartitionNames(v IIdentifierListContext) {
	s.partitionNames = v
}

func (s *ModifyPartitionClauseContext) SetPartitionProperties(v IPropertyItemListContext) {
	s.partitionProperties = v
}

func (s *ModifyPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyPartitionClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *ModifyPartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *ModifyPartitionClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *ModifyPartitionClauseContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserLEFT_PAREN)
}

func (s *ModifyPartitionClauseContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, i)
}

func (s *ModifyPartitionClauseContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserRIGHT_PAREN)
}

func (s *ModifyPartitionClauseContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, i)
}

func (s *ModifyPartitionClauseContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *ModifyPartitionClauseContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserASTERISK, 0)
}

func (s *ModifyPartitionClauseContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *ModifyPartitionClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *ModifyPartitionClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *ModifyPartitionClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifyPartitionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ModifyPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterModifyPartitionClause(s)
	}
}

func (s *ModifyPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitModifyPartitionClause(s)
	}
}

type ModifyEngineClauseContext struct {
	AlterTableClauseContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewModifyEngineClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyEngineClauseContext {
	var p = new(ModifyEngineClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ModifyEngineClauseContext) GetName() IIdentifierContext { return s.name }

func (s *ModifyEngineClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *ModifyEngineClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ModifyEngineClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *ModifyEngineClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyEngineClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *ModifyEngineClauseContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(DorisParserENGINE, 0)
}

func (s *ModifyEngineClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *ModifyEngineClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifyEngineClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ModifyEngineClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterModifyEngineClause(s)
	}
}

func (s *ModifyEngineClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitModifyEngineClause(s)
	}
}

type ReorderColumnsClauseContext struct {
	AlterTableClauseContext
	properties IPropertyClauseContext
}

func NewReorderColumnsClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReorderColumnsClauseContext {
	var p = new(ReorderColumnsClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ReorderColumnsClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *ReorderColumnsClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *ReorderColumnsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReorderColumnsClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisParserORDER, 0)
}

func (s *ReorderColumnsClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *ReorderColumnsClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ReorderColumnsClauseContext) FromRollup() IFromRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromRollupContext)
}

func (s *ReorderColumnsClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ReorderColumnsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterReorderColumnsClause(s)
	}
}

func (s *ReorderColumnsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitReorderColumnsClause(s)
	}
}

type AddIndexClauseContext struct {
	AlterTableClauseContext
}

func NewAddIndexClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddIndexClauseContext {
	var p = new(AddIndexClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AddIndexClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddIndexClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddIndexClauseContext) IndexDef() IIndexDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexDefContext)
}

func (s *AddIndexClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddIndexClause(s)
	}
}

func (s *AddIndexClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddIndexClause(s)
	}
}

type ModifyColumnCommentClauseContext struct {
	AlterTableClauseContext
	name    IIdentifierContext
	comment antlr.Token
}

func NewModifyColumnCommentClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyColumnCommentClauseContext {
	var p = new(ModifyColumnCommentClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ModifyColumnCommentClauseContext) GetComment() antlr.Token { return s.comment }

func (s *ModifyColumnCommentClauseContext) SetComment(v antlr.Token) { s.comment = v }

func (s *ModifyColumnCommentClauseContext) GetName() IIdentifierContext { return s.name }

func (s *ModifyColumnCommentClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ModifyColumnCommentClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyColumnCommentClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *ModifyColumnCommentClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *ModifyColumnCommentClauseContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *ModifyColumnCommentClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifyColumnCommentClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ModifyColumnCommentClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterModifyColumnCommentClause(s)
	}
}

func (s *ModifyColumnCommentClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitModifyColumnCommentClause(s)
	}
}

type AlterMultiPartitionClauseContext struct {
	AlterTableClauseContext
	from       IPartitionValueListContext
	to         IPartitionValueListContext
	unit       IIdentifierContext
	properties IPropertyClauseContext
}

func NewAlterMultiPartitionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterMultiPartitionClauseContext {
	var p = new(AlterMultiPartitionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterMultiPartitionClauseContext) GetFrom() IPartitionValueListContext { return s.from }

func (s *AlterMultiPartitionClauseContext) GetTo() IPartitionValueListContext { return s.to }

func (s *AlterMultiPartitionClauseContext) GetUnit() IIdentifierContext { return s.unit }

func (s *AlterMultiPartitionClauseContext) GetProperties() IPropertyClauseContext {
	return s.properties
}

func (s *AlterMultiPartitionClauseContext) SetFrom(v IPartitionValueListContext) { s.from = v }

func (s *AlterMultiPartitionClauseContext) SetTo(v IPartitionValueListContext) { s.to = v }

func (s *AlterMultiPartitionClauseContext) SetUnit(v IIdentifierContext) { s.unit = v }

func (s *AlterMultiPartitionClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterMultiPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterMultiPartitionClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AlterMultiPartitionClauseContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITIONS, 0)
}

func (s *AlterMultiPartitionClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *AlterMultiPartitionClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *AlterMultiPartitionClauseContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DorisParserINTERVAL, 0)
}

func (s *AlterMultiPartitionClauseContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *AlterMultiPartitionClauseContext) AllPartitionValueList() []IPartitionValueListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueListContext); ok {
			tst[i] = t.(IPartitionValueListContext)
			i++
		}
	}

	return tst
}

func (s *AlterMultiPartitionClauseContext) PartitionValueList(i int) IPartitionValueListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueListContext)
}

func (s *AlterMultiPartitionClauseContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *AlterMultiPartitionClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterMultiPartitionClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterMultiPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterMultiPartitionClause(s)
	}
}

func (s *AlterMultiPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterMultiPartitionClause(s)
	}
}

type RenameColumnClauseContext struct {
	AlterTableClauseContext
	name    IIdentifierContext
	newName IIdentifierContext
}

func NewRenameColumnClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameColumnClauseContext {
	var p = new(RenameColumnClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *RenameColumnClauseContext) GetName() IIdentifierContext { return s.name }

func (s *RenameColumnClauseContext) GetNewName() IIdentifierContext { return s.newName }

func (s *RenameColumnClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *RenameColumnClauseContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *RenameColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameColumnClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserRENAME, 0)
}

func (s *RenameColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *RenameColumnClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RenameColumnClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenameColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRenameColumnClause(s)
	}
}

func (s *RenameColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRenameColumnClause(s)
	}
}

type EnableFeatureClauseContext struct {
	AlterTableClauseContext
	name       antlr.Token
	properties IPropertyClauseContext
}

func NewEnableFeatureClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EnableFeatureClauseContext {
	var p = new(EnableFeatureClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *EnableFeatureClauseContext) GetName() antlr.Token { return s.name }

func (s *EnableFeatureClauseContext) SetName(v antlr.Token) { s.name = v }

func (s *EnableFeatureClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *EnableFeatureClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *EnableFeatureClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnableFeatureClauseContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserENABLE, 0)
}

func (s *EnableFeatureClauseContext) FEATURE() antlr.TerminalNode {
	return s.GetToken(DorisParserFEATURE, 0)
}

func (s *EnableFeatureClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *EnableFeatureClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *EnableFeatureClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *EnableFeatureClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterEnableFeatureClause(s)
	}
}

func (s *EnableFeatureClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitEnableFeatureClause(s)
	}
}

func (p *DorisParser) AlterTableClause() (localctx IAlterTableClauseContext) {
	localctx = NewAlterTableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, DorisParserRULE_alterTableClause)
	var _la int

	p.SetState(1854)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 221, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAddColumnClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1616)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1617)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1618)
			p.ColumnDef()
		}
		p.SetState(1620)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAFTER || _la == DorisParserFIRST {
			{
				p.SetState(1619)
				p.ColumnPosition()
			}

		}
		p.SetState(1623)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIN || _la == DorisParserTO {
			{
				p.SetState(1622)
				p.ToRollup()
			}

		}
		p.SetState(1626)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1625)

				var _x = p.PropertyClause()

				localctx.(*AddColumnClauseContext).properties = _x
			}

		}

	case 2:
		localctx = NewAddColumnsClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1628)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1629)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1630)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1631)
			p.ColumnDef()
		}
		p.SetState(1636)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(1632)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1633)
				p.ColumnDef()
			}

			p.SetState(1638)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1639)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1641)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIN || _la == DorisParserTO {
			{
				p.SetState(1640)
				p.ToRollup()
			}

		}
		p.SetState(1644)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1643)

				var _x = p.PropertyClause()

				localctx.(*AddColumnsClauseContext).properties = _x
			}

		}

	case 3:
		localctx = NewDropColumnClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1646)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1647)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1648)

			var _x = p.Identifier()

			localctx.(*DropColumnClauseContext).name = _x
		}
		p.SetState(1650)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(1649)
				p.FromRollup()
			}

		}
		p.SetState(1653)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1652)

				var _x = p.PropertyClause()

				localctx.(*DropColumnClauseContext).properties = _x
			}

		}

	case 4:
		localctx = NewModifyColumnClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1655)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1656)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1657)
			p.ColumnDef()
		}
		p.SetState(1659)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAFTER || _la == DorisParserFIRST {
			{
				p.SetState(1658)
				p.ColumnPosition()
			}

		}
		p.SetState(1662)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(1661)
				p.FromRollup()
			}

		}
		p.SetState(1665)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1664)

				var _x = p.PropertyClause()

				localctx.(*ModifyColumnClauseContext).properties = _x
			}

		}

	case 5:
		localctx = NewReorderColumnsClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1667)
			p.Match(DorisParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1668)
			p.Match(DorisParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1669)
			p.IdentifierList()
		}
		p.SetState(1671)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(1670)
				p.FromRollup()
			}

		}
		p.SetState(1674)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1673)

				var _x = p.PropertyClause()

				localctx.(*ReorderColumnsClauseContext).properties = _x
			}

		}

	case 6:
		localctx = NewAddPartitionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1676)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1678)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(1677)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1683)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 192, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1680)
				p.LessThanPartitionDef()
			}

		case 2:
			{
				p.SetState(1681)
				p.FixedPartitionDef()
			}

		case 3:
			{
				p.SetState(1682)
				p.InPartitionDef()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(1689)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(1685)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1686)

				var _x = p.PropertyItemList()

				localctx.(*AddPartitionClauseContext).partitionProperties = _x
			}
			{
				p.SetState(1687)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1705)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserDISTRIBUTED {
			{
				p.SetState(1691)
				p.Match(DorisParserDISTRIBUTED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1692)
				p.Match(DorisParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1696)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserHASH:
				{
					p.SetState(1693)
					p.Match(DorisParserHASH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1694)

					var _x = p.IdentifierList()

					localctx.(*AddPartitionClauseContext).hashKeys = _x
				}

			case DorisParserRANDOM:
				{
					p.SetState(1695)
					p.Match(DorisParserRANDOM)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			p.SetState(1703)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserBUCKETS {
				{
					p.SetState(1698)
					p.Match(DorisParserBUCKETS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1701)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DorisParserINTEGER_VALUE:
					{
						p.SetState(1699)
						p.Match(DorisParserINTEGER_VALUE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case DorisParserAUTO:
					{
						p.SetState(1700)

						var _m = p.Match(DorisParserAUTO)

						localctx.(*AddPartitionClauseContext).autoBucket = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			}

		}
		p.SetState(1708)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1707)

				var _x = p.PropertyClause()

				localctx.(*AddPartitionClauseContext).properties = _x
			}

		}

	case 7:
		localctx = NewDropPartitionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1710)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1712)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(1711)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1714)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1717)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1715)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1716)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1719)

			var _x = p.Identifier()

			localctx.(*DropPartitionClauseContext).partitionName = _x
		}
		p.SetState(1721)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFORCE {
			{
				p.SetState(1720)
				p.Match(DorisParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1726)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(1723)
				p.Match(DorisParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1724)
				p.Match(DorisParserINDEX)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1725)

				var _x = p.Identifier()

				localctx.(*DropPartitionClauseContext).indexName = _x
			}

		}

	case 8:
		localctx = NewModifyPartitionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1728)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1730)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(1729)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1732)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1735)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1733)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1734)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1742)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 205, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1737)

				var _x = p.Identifier()

				localctx.(*ModifyPartitionClauseContext).partitionName = _x
			}

		case 2:
			{
				p.SetState(1738)

				var _x = p.IdentifierList()

				localctx.(*ModifyPartitionClauseContext).partitionNames = _x
			}

		case 3:
			{
				p.SetState(1739)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1740)
				p.Match(DorisParserASTERISK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1741)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(1744)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1745)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1746)

			var _x = p.PropertyItemList()

			localctx.(*ModifyPartitionClauseContext).partitionProperties = _x
		}
		{
			p.SetState(1747)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewReplacePartitionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1749)
			p.Match(DorisParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1751)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(1750)

				var _x = p.PartitionSpec()

				localctx.(*ReplacePartitionClauseContext).partitions = _x
			}

		}
		{
			p.SetState(1753)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1755)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(1754)

				var _x = p.PartitionSpec()

				localctx.(*ReplacePartitionClauseContext).tempPartitions = _x
			}

		}
		p.SetState(1758)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFORCE {
			{
				p.SetState(1757)
				p.Match(DorisParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1761)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1760)

				var _x = p.PropertyClause()

				localctx.(*ReplacePartitionClauseContext).properties = _x
			}

		}

	case 10:
		localctx = NewReplaceTableClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1763)
			p.Match(DorisParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1764)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1765)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1766)

			var _x = p.Identifier()

			localctx.(*ReplaceTableClauseContext).name = _x
		}
		p.SetState(1768)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1767)

				var _x = p.PropertyClause()

				localctx.(*ReplaceTableClauseContext).properties = _x
			}

		}

	case 11:
		localctx = NewRenameClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1770)
			p.Match(DorisParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1771)

			var _x = p.Identifier()

			localctx.(*RenameClauseContext).newName = _x
		}

	case 12:
		localctx = NewRenameRollupClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1772)
			p.Match(DorisParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1773)
			p.Match(DorisParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1774)

			var _x = p.Identifier()

			localctx.(*RenameRollupClauseContext).name = _x
		}
		{
			p.SetState(1775)

			var _x = p.Identifier()

			localctx.(*RenameRollupClauseContext).newName = _x
		}

	case 13:
		localctx = NewRenamePartitionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1777)
			p.Match(DorisParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1778)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1779)

			var _x = p.Identifier()

			localctx.(*RenamePartitionClauseContext).name = _x
		}
		{
			p.SetState(1780)

			var _x = p.Identifier()

			localctx.(*RenamePartitionClauseContext).newName = _x
		}

	case 14:
		localctx = NewRenameColumnClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1782)
			p.Match(DorisParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1783)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1784)

			var _x = p.Identifier()

			localctx.(*RenameColumnClauseContext).name = _x
		}
		{
			p.SetState(1785)

			var _x = p.Identifier()

			localctx.(*RenameColumnClauseContext).newName = _x
		}

	case 15:
		localctx = NewAddIndexClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1787)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1788)
			p.IndexDef()
		}

	case 16:
		localctx = NewDropIndexClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1789)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1790)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1793)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1791)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1792)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1795)

			var _x = p.Identifier()

			localctx.(*DropIndexClauseContext).name = _x
		}

	case 17:
		localctx = NewEnableFeatureClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1796)
			p.Match(DorisParserENABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1797)
			p.Match(DorisParserFEATURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1798)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*EnableFeatureClauseContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1801)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(1799)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1800)

				var _x = p.PropertyClause()

				localctx.(*EnableFeatureClauseContext).properties = _x
			}

		}

	case 18:
		localctx = NewModifyDistributionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1803)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1804)
			p.Match(DorisParserDISTRIBUTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1819)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserDISTRIBUTED {
			{
				p.SetState(1805)
				p.Match(DorisParserDISTRIBUTED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1806)
				p.Match(DorisParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1810)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserHASH:
				{
					p.SetState(1807)
					p.Match(DorisParserHASH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1808)

					var _x = p.IdentifierList()

					localctx.(*ModifyDistributionClauseContext).hashKeys = _x
				}

			case DorisParserRANDOM:
				{
					p.SetState(1809)
					p.Match(DorisParserRANDOM)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			p.SetState(1817)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserBUCKETS {
				{
					p.SetState(1812)
					p.Match(DorisParserBUCKETS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1815)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DorisParserINTEGER_VALUE:
					{
						p.SetState(1813)
						p.Match(DorisParserINTEGER_VALUE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case DorisParserAUTO:
					{
						p.SetState(1814)

						var _m = p.Match(DorisParserAUTO)

						localctx.(*ModifyDistributionClauseContext).autoBucket = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			}

		}

	case 19:
		localctx = NewModifyTableCommentClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1821)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1822)
			p.Match(DorisParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1823)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ModifyTableCommentClauseContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		localctx = NewModifyColumnCommentClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1824)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1825)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1826)

			var _x = p.Identifier()

			localctx.(*ModifyColumnCommentClauseContext).name = _x
		}
		{
			p.SetState(1827)
			p.Match(DorisParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1828)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ModifyColumnCommentClauseContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		localctx = NewModifyEngineClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1830)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1831)
			p.Match(DorisParserENGINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1832)
			p.Match(DorisParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1833)

			var _x = p.Identifier()

			localctx.(*ModifyEngineClauseContext).name = _x
		}
		p.SetState(1835)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1834)

				var _x = p.PropertyClause()

				localctx.(*ModifyEngineClauseContext).properties = _x
			}

		}

	case 22:
		localctx = NewAlterMultiPartitionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1837)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1839)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(1838)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1841)
			p.Match(DorisParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1842)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1843)

			var _x = p.PartitionValueList()

			localctx.(*AlterMultiPartitionClauseContext).from = _x
		}
		{
			p.SetState(1844)
			p.Match(DorisParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1845)

			var _x = p.PartitionValueList()

			localctx.(*AlterMultiPartitionClauseContext).to = _x
		}
		{
			p.SetState(1846)
			p.Match(DorisParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1847)
			p.Match(DorisParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1849)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 219, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1848)

				var _x = p.Identifier()

				localctx.(*AlterMultiPartitionClauseContext).unit = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1852)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1851)

				var _x = p.PropertyClause()

				localctx.(*AlterMultiPartitionClauseContext).properties = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnPositionContext is an interface to support dynamic dispatch.
type IColumnPositionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPosition returns the position rule contexts.
	GetPosition() IIdentifierContext

	// SetPosition sets the position rule contexts.
	SetPosition(IIdentifierContext)

	// Getter signatures
	FIRST() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsColumnPositionContext differentiates from other interfaces.
	IsColumnPositionContext()
}

type ColumnPositionContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	position IIdentifierContext
}

func NewEmptyColumnPositionContext() *ColumnPositionContext {
	var p = new(ColumnPositionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_columnPosition
	return p
}

func InitEmptyColumnPositionContext(p *ColumnPositionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_columnPosition
}

func (*ColumnPositionContext) IsColumnPositionContext() {}

func NewColumnPositionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnPositionContext {
	var p = new(ColumnPositionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_columnPosition

	return p
}

func (s *ColumnPositionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnPositionContext) GetPosition() IIdentifierContext { return s.position }

func (s *ColumnPositionContext) SetPosition(v IIdentifierContext) { s.position = v }

func (s *ColumnPositionContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DorisParserFIRST, 0)
}

func (s *ColumnPositionContext) AFTER() antlr.TerminalNode {
	return s.GetToken(DorisParserAFTER, 0)
}

func (s *ColumnPositionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnPositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnPositionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnPositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterColumnPosition(s)
	}
}

func (s *ColumnPositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitColumnPosition(s)
	}
}

func (p *DorisParser) ColumnPosition() (localctx IColumnPositionContext) {
	localctx = NewColumnPositionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, DorisParserRULE_columnPosition)
	p.SetState(1859)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserFIRST:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1856)
			p.Match(DorisParserFIRST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserAFTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1857)
			p.Match(DorisParserAFTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1858)

			var _x = p.Identifier()

			localctx.(*ColumnPositionContext).position = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IToRollupContext is an interface to support dynamic dispatch.
type IToRollupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollup returns the rollup rule contexts.
	GetRollup() IIdentifierContext

	// SetRollup sets the rollup rule contexts.
	SetRollup(IIdentifierContext)

	// Getter signatures
	TO() antlr.TerminalNode
	IN() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsToRollupContext differentiates from other interfaces.
	IsToRollupContext()
}

type ToRollupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	rollup IIdentifierContext
}

func NewEmptyToRollupContext() *ToRollupContext {
	var p = new(ToRollupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_toRollup
	return p
}

func InitEmptyToRollupContext(p *ToRollupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_toRollup
}

func (*ToRollupContext) IsToRollupContext() {}

func NewToRollupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ToRollupContext {
	var p = new(ToRollupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_toRollup

	return p
}

func (s *ToRollupContext) GetParser() antlr.Parser { return s.parser }

func (s *ToRollupContext) GetRollup() IIdentifierContext { return s.rollup }

func (s *ToRollupContext) SetRollup(v IIdentifierContext) { s.rollup = v }

func (s *ToRollupContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *ToRollupContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ToRollupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ToRollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ToRollupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ToRollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterToRollup(s)
	}
}

func (s *ToRollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitToRollup(s)
	}
}

func (p *DorisParser) ToRollup() (localctx IToRollupContext) {
	localctx = NewToRollupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, DorisParserRULE_toRollup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1861)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserIN || _la == DorisParserTO) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1862)

		var _x = p.Identifier()

		localctx.(*ToRollupContext).rollup = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromRollupContext is an interface to support dynamic dispatch.
type IFromRollupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollup returns the rollup rule contexts.
	GetRollup() IIdentifierContext

	// SetRollup sets the rollup rule contexts.
	SetRollup(IIdentifierContext)

	// Getter signatures
	FROM() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsFromRollupContext differentiates from other interfaces.
	IsFromRollupContext()
}

type FromRollupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	rollup IIdentifierContext
}

func NewEmptyFromRollupContext() *FromRollupContext {
	var p = new(FromRollupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_fromRollup
	return p
}

func InitEmptyFromRollupContext(p *FromRollupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_fromRollup
}

func (*FromRollupContext) IsFromRollupContext() {}

func NewFromRollupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromRollupContext {
	var p = new(FromRollupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_fromRollup

	return p
}

func (s *FromRollupContext) GetParser() antlr.Parser { return s.parser }

func (s *FromRollupContext) GetRollup() IIdentifierContext { return s.rollup }

func (s *FromRollupContext) SetRollup(v IIdentifierContext) { s.rollup = v }

func (s *FromRollupContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *FromRollupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FromRollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromRollupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromRollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFromRollup(s)
	}
}

func (s *FromRollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFromRollup(s)
	}
}

func (p *DorisParser) FromRollup() (localctx IFromRollupContext) {
	localctx = NewFromRollupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, DorisParserRULE_fromRollup)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1864)
		p.Match(DorisParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1865)

		var _x = p.Identifier()

		localctx.(*FromRollupContext).rollup = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedDropStatementContext is an interface to support dynamic dispatch.
type IUnsupportedDropStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedDropStatementContext differentiates from other interfaces.
	IsUnsupportedDropStatementContext()
}

type UnsupportedDropStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedDropStatementContext() *UnsupportedDropStatementContext {
	var p = new(UnsupportedDropStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedDropStatement
	return p
}

func InitEmptyUnsupportedDropStatementContext(p *UnsupportedDropStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedDropStatement
}

func (*UnsupportedDropStatementContext) IsUnsupportedDropStatementContext() {}

func NewUnsupportedDropStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedDropStatementContext {
	var p = new(UnsupportedDropStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedDropStatement

	return p
}

func (s *UnsupportedDropStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedDropStatementContext) CopyAll(ctx *UnsupportedDropStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedDropStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedDropStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DropDatabaseContext struct {
	UnsupportedDropStatementContext
	name IMultipartIdentifierContext
}

func NewDropDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropDatabaseContext {
	var p = new(DropDatabaseContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropDatabaseContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *DropDatabaseContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *DropDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDatabaseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *DropDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEMA, 0)
}

func (s *DropDatabaseContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropDatabaseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropDatabaseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropDatabaseContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserFORCE, 0)
}

func (s *DropDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropDatabase(s)
	}
}

func (s *DropDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropDatabase(s)
	}
}

type DropUserContext struct {
	UnsupportedDropStatementContext
}

func NewDropUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropUserContext {
	var p = new(DropUserContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropUserContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropUserContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisParserUSER, 0)
}

func (s *DropUserContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *DropUserContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropUserContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropUser(s)
	}
}

func (s *DropUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropUser(s)
	}
}

type DropWorkloadPolicyContext struct {
	UnsupportedDropStatementContext
	name IIdentifierOrTextContext
}

func NewDropWorkloadPolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropWorkloadPolicyContext {
	var p = new(DropWorkloadPolicyContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropWorkloadPolicyContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *DropWorkloadPolicyContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *DropWorkloadPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropWorkloadPolicyContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropWorkloadPolicyContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserWORKLOAD, 0)
}

func (s *DropWorkloadPolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *DropWorkloadPolicyContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DropWorkloadPolicyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropWorkloadPolicyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropWorkloadPolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropWorkloadPolicy(s)
	}
}

func (s *DropWorkloadPolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropWorkloadPolicy(s)
	}
}

type DropRowPolicyContext struct {
	UnsupportedDropStatementContext
	policyName IIdentifierContext
	tableName  IMultipartIdentifierContext
	roleName   IIdentifierContext
}

func NewDropRowPolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropRowPolicyContext {
	var p = new(DropRowPolicyContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropRowPolicyContext) GetPolicyName() IIdentifierContext { return s.policyName }

func (s *DropRowPolicyContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DropRowPolicyContext) GetRoleName() IIdentifierContext { return s.roleName }

func (s *DropRowPolicyContext) SetPolicyName(v IIdentifierContext) { s.policyName = v }

func (s *DropRowPolicyContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DropRowPolicyContext) SetRoleName(v IIdentifierContext) { s.roleName = v }

func (s *DropRowPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRowPolicyContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropRowPolicyContext) ROW() antlr.TerminalNode {
	return s.GetToken(DorisParserROW, 0)
}

func (s *DropRowPolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *DropRowPolicyContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *DropRowPolicyContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DropRowPolicyContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropRowPolicyContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropRowPolicyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropRowPolicyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropRowPolicyContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *DropRowPolicyContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *DropRowPolicyContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *DropRowPolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropRowPolicy(s)
	}
}

func (s *DropRowPolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropRowPolicy(s)
	}
}

type DropFunctionContext struct {
	UnsupportedDropStatementContext
}

func NewDropFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropFunctionContext {
	var p = new(DropFunctionContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFunctionContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserFUNCTION, 0)
}

func (s *DropFunctionContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *DropFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *DropFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *DropFunctionContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropFunctionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropFunctionContext) FunctionArguments() IFunctionArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgumentsContext)
}

func (s *DropFunctionContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *DropFunctionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION, 0)
}

func (s *DropFunctionContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *DropFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropFunction(s)
	}
}

func (s *DropFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropFunction(s)
	}
}

type DropWorkloadGroupContext struct {
	UnsupportedDropStatementContext
	name IIdentifierOrTextContext
}

func NewDropWorkloadGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropWorkloadGroupContext {
	var p = new(DropWorkloadGroupContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropWorkloadGroupContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *DropWorkloadGroupContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *DropWorkloadGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropWorkloadGroupContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropWorkloadGroupContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserWORKLOAD, 0)
}

func (s *DropWorkloadGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUP, 0)
}

func (s *DropWorkloadGroupContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DropWorkloadGroupContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropWorkloadGroupContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropWorkloadGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropWorkloadGroup(s)
	}
}

func (s *DropWorkloadGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropWorkloadGroup(s)
	}
}

type DropViewContext struct {
	UnsupportedDropStatementContext
	name IMultipartIdentifierContext
}

func NewDropViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropViewContext {
	var p = new(DropViewContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropViewContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *DropViewContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *DropViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropViewContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *DropViewContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropViewContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropViewContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropView(s)
	}
}

func (s *DropViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropView(s)
	}
}

type DropSqlBlockRuleContext struct {
	UnsupportedDropStatementContext
}

func NewDropSqlBlockRuleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropSqlBlockRuleContext {
	var p = new(DropSqlBlockRuleContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropSqlBlockRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropSqlBlockRuleContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropSqlBlockRuleContext) SQL_BLOCK_RULE() antlr.TerminalNode {
	return s.GetToken(DorisParserSQL_BLOCK_RULE, 0)
}

func (s *DropSqlBlockRuleContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *DropSqlBlockRuleContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropSqlBlockRuleContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropSqlBlockRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropSqlBlockRule(s)
	}
}

func (s *DropSqlBlockRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropSqlBlockRule(s)
	}
}

type DropIndexContext struct {
	UnsupportedDropStatementContext
	name      IIdentifierContext
	tableName IMultipartIdentifierContext
}

func NewDropIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropIndexContext {
	var p = new(DropIndexContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropIndexContext) GetName() IIdentifierContext { return s.name }

func (s *DropIndexContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DropIndexContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropIndexContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DropIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *DropIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *DropIndexContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropIndexContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropIndexContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropIndexContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropIndex(s)
	}
}

func (s *DropIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropIndex(s)
	}
}

type DropRepositoryContext struct {
	UnsupportedDropStatementContext
	name IIdentifierContext
}

func NewDropRepositoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropRepositoryContext {
	var p = new(DropRepositoryContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropRepositoryContext) GetName() IIdentifierContext { return s.name }

func (s *DropRepositoryContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropRepositoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRepositoryContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropRepositoryContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisParserREPOSITORY, 0)
}

func (s *DropRepositoryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropRepositoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropRepository(s)
	}
}

func (s *DropRepositoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropRepository(s)
	}
}

type DropEncryptkeyContext struct {
	UnsupportedDropStatementContext
	name IMultipartIdentifierContext
}

func NewDropEncryptkeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropEncryptkeyContext {
	var p = new(DropEncryptkeyContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropEncryptkeyContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *DropEncryptkeyContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *DropEncryptkeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropEncryptkeyContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropEncryptkeyContext) ENCRYPTKEY() antlr.TerminalNode {
	return s.GetToken(DorisParserENCRYPTKEY, 0)
}

func (s *DropEncryptkeyContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropEncryptkeyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropEncryptkeyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropEncryptkeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropEncryptkey(s)
	}
}

func (s *DropEncryptkeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropEncryptkey(s)
	}
}

type DropRoleContext struct {
	UnsupportedDropStatementContext
	name IIdentifierContext
}

func NewDropRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropRoleContext {
	var p = new(DropRoleContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropRoleContext) GetName() IIdentifierContext { return s.name }

func (s *DropRoleContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRoleContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *DropRoleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropRoleContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropRoleContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropRole(s)
	}
}

func (s *DropRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropRole(s)
	}
}

type DropStageContext struct {
	UnsupportedDropStatementContext
	name IIdentifierContext
}

func NewDropStageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropStageContext {
	var p = new(DropStageContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropStageContext) GetName() IIdentifierContext { return s.name }

func (s *DropStageContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropStageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStageContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropStageContext) STAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTAGE, 0)
}

func (s *DropStageContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropStageContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropStageContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropStageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropStage(s)
	}
}

func (s *DropStageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropStage(s)
	}
}

type DropResourceContext struct {
	UnsupportedDropStatementContext
	name IIdentifierOrTextContext
}

func NewDropResourceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropResourceContext {
	var p = new(DropResourceContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropResourceContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *DropResourceContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *DropResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropResourceContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropResourceContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCE, 0)
}

func (s *DropResourceContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DropResourceContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropResourceContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropResourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropResource(s)
	}
}

func (s *DropResourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropResource(s)
	}
}

type DropFileContext struct {
	UnsupportedDropStatementContext
	name       antlr.Token
	database   IIdentifierContext
	properties IPropertyClauseContext
}

func NewDropFileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropFileContext {
	var p = new(DropFileContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropFileContext) GetName() antlr.Token { return s.name }

func (s *DropFileContext) SetName(v antlr.Token) { s.name = v }

func (s *DropFileContext) GetDatabase() IIdentifierContext { return s.database }

func (s *DropFileContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *DropFileContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *DropFileContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *DropFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFileContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropFileContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisParserFILE, 0)
}

func (s *DropFileContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *DropFileContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *DropFileContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *DropFileContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *DropFileContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropFile(s)
	}
}

func (s *DropFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropFile(s)
	}
}

type DropCatalogContext struct {
	UnsupportedDropStatementContext
	name IIdentifierContext
}

func NewDropCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropCatalogContext {
	var p = new(DropCatalogContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropCatalogContext) GetName() IIdentifierContext { return s.name }

func (s *DropCatalogContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropCatalogContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropCatalogContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *DropCatalogContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropCatalogContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropCatalogContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropCatalogContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropCatalog(s)
	}
}

func (s *DropCatalogContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropCatalog(s)
	}
}

type DropTableContext struct {
	UnsupportedDropStatementContext
	name IMultipartIdentifierContext
}

func NewDropTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropTableContext {
	var p = new(DropTableContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropTableContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *DropTableContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *DropTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *DropTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropTableContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropTableContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserFORCE, 0)
}

func (s *DropTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropTable(s)
	}
}

func (s *DropTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropTable(s)
	}
}

type DropStoragePolicyContext struct {
	UnsupportedDropStatementContext
	name IIdentifierContext
}

func NewDropStoragePolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropStoragePolicyContext {
	var p = new(DropStoragePolicyContext)

	InitEmptyUnsupportedDropStatementContext(&p.UnsupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDropStatementContext))

	return p
}

func (s *DropStoragePolicyContext) GetName() IIdentifierContext { return s.name }

func (s *DropStoragePolicyContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropStoragePolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStoragePolicyContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropStoragePolicyContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *DropStoragePolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *DropStoragePolicyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropStoragePolicyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropStoragePolicyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropStoragePolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropStoragePolicy(s)
	}
}

func (s *DropStoragePolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropStoragePolicy(s)
	}
}

func (p *DorisParser) UnsupportedDropStatement() (localctx IUnsupportedDropStatementContext) {
	localctx = NewUnsupportedDropStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, DorisParserRULE_unsupportedDropStatement)
	var _la int

	p.SetState(2022)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 246, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDropDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1867)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1868)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserDATABASE || _la == DorisParserSCHEMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1871)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1869)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1870)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1873)

			var _x = p.MultipartIdentifier()

			localctx.(*DropDatabaseContext).name = _x
		}
		p.SetState(1875)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFORCE {
			{
				p.SetState(1874)
				p.Match(DorisParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		localctx = NewDropCatalogContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1877)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1878)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1881)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1879)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1880)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1883)

			var _x = p.Identifier()

			localctx.(*DropCatalogContext).name = _x
		}

	case 3:
		localctx = NewDropFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1884)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1886)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION {
			{
				p.SetState(1885)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1888)
			p.Match(DorisParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1891)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 227, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1889)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1890)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1893)
			p.FunctionIdentifier()
		}
		{
			p.SetState(1894)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1896)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&9297470595268672) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&4105039856441229313) != 0) || _la == DorisParserDOUBLE || _la == DorisParserFLOAT || ((int64((_la-213)) & ^0x3f) == 0 && ((int64(1)<<(_la-213))&-9223369734650855423) != 0) || _la == DorisParserQUANTILE_STATE || _la == DorisParserSMALLINT || ((int64((_la-430)) & ^0x3f) == 0 && ((int64(1)<<(_la-430))&20266198341124099) != 0) {
			{
				p.SetState(1895)
				p.FunctionArguments()
			}

		}
		{
			p.SetState(1898)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewDropTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1900)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1901)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1904)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1902)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1903)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1906)

			var _x = p.MultipartIdentifier()

			localctx.(*DropTableContext).name = _x
		}
		p.SetState(1908)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFORCE {
			{
				p.SetState(1907)
				p.Match(DorisParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		localctx = NewDropUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1910)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1911)
			p.Match(DorisParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1914)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1912)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1913)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1916)
			p.UserIdentify()
		}

	case 6:
		localctx = NewDropViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1917)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1918)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1921)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1919)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1920)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1923)

			var _x = p.MultipartIdentifier()

			localctx.(*DropViewContext).name = _x
		}

	case 7:
		localctx = NewDropRepositoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1924)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1925)
			p.Match(DorisParserREPOSITORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1926)

			var _x = p.Identifier()

			localctx.(*DropRepositoryContext).name = _x
		}

	case 8:
		localctx = NewDropRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1927)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1928)
			p.Match(DorisParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1931)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1929)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1930)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1933)

			var _x = p.Identifier()

			localctx.(*DropRoleContext).name = _x
		}

	case 9:
		localctx = NewDropFileContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1934)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1935)
			p.Match(DorisParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1936)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*DropFileContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1939)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1937)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1938)

				var _x = p.Identifier()

				localctx.(*DropFileContext).database = _x
			}

		}
		{
			p.SetState(1941)

			var _x = p.PropertyClause()

			localctx.(*DropFileContext).properties = _x
		}

	case 10:
		localctx = NewDropIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1942)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1943)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1946)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1944)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1945)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1948)

			var _x = p.Identifier()

			localctx.(*DropIndexContext).name = _x
		}
		{
			p.SetState(1949)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1950)

			var _x = p.MultipartIdentifier()

			localctx.(*DropIndexContext).tableName = _x
		}

	case 11:
		localctx = NewDropResourceContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1952)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1953)
			p.Match(DorisParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1956)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1954)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1955)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1958)

			var _x = p.IdentifierOrText()

			localctx.(*DropResourceContext).name = _x
		}

	case 12:
		localctx = NewDropWorkloadGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1959)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1960)
			p.Match(DorisParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1961)
			p.Match(DorisParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1964)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1962)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1963)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1966)

			var _x = p.IdentifierOrText()

			localctx.(*DropWorkloadGroupContext).name = _x
		}

	case 13:
		localctx = NewDropWorkloadPolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1967)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1968)
			p.Match(DorisParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1969)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1972)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1970)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1971)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1974)

			var _x = p.IdentifierOrText()

			localctx.(*DropWorkloadPolicyContext).name = _x
		}

	case 14:
		localctx = NewDropEncryptkeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1975)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1976)
			p.Match(DorisParserENCRYPTKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1979)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1977)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1978)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1981)

			var _x = p.MultipartIdentifier()

			localctx.(*DropEncryptkeyContext).name = _x
		}

	case 15:
		localctx = NewDropSqlBlockRuleContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1982)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1983)
			p.Match(DorisParserSQL_BLOCK_RULE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1986)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1984)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1985)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1988)
			p.IdentifierSeq()
		}

	case 16:
		localctx = NewDropRowPolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1989)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1990)
			p.Match(DorisParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1991)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1994)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1992)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1993)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1996)

			var _x = p.Identifier()

			localctx.(*DropRowPolicyContext).policyName = _x
		}
		{
			p.SetState(1997)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1998)

			var _x = p.MultipartIdentifier()

			localctx.(*DropRowPolicyContext).tableName = _x
		}
		p.SetState(2005)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFOR {
			{
				p.SetState(1999)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2003)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADDDATE, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserARRAY_RANGE, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATE_ADD, DorisParserDATE_CEIL, DorisParserDATE_DIFF, DorisParserDATE_FLOOR, DorisParserDATE_SUB, DorisParserDATEADD, DorisParserDATEDIFF, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS_ADD, DorisParserDAYS_SUB, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSEQUENCE, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUBDATE, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTIMESTAMPADD, DorisParserTIMESTAMPDIFF, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
				{
					p.SetState(2000)
					p.UserIdentify()
				}

			case DorisParserROLE:
				{
					p.SetState(2001)
					p.Match(DorisParserROLE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2002)

					var _x = p.Identifier()

					localctx.(*DropRowPolicyContext).roleName = _x
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}

	case 17:
		localctx = NewDropStoragePolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(2007)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2008)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2009)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2012)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(2010)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2011)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2014)

			var _x = p.Identifier()

			localctx.(*DropStoragePolicyContext).name = _x
		}

	case 18:
		localctx = NewDropStageContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(2015)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2016)
			p.Match(DorisParserSTAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2019)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(2017)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2018)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2021)

			var _x = p.Identifier()

			localctx.(*DropStageContext).name = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedStatsStatementContext is an interface to support dynamic dispatch.
type IUnsupportedStatsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedStatsStatementContext differentiates from other interfaces.
	IsUnsupportedStatsStatementContext()
}

type UnsupportedStatsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedStatsStatementContext() *UnsupportedStatsStatementContext {
	var p = new(UnsupportedStatsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedStatsStatement
	return p
}

func InitEmptyUnsupportedStatsStatementContext(p *UnsupportedStatsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedStatsStatement
}

func (*UnsupportedStatsStatementContext) IsUnsupportedStatsStatementContext() {}

func NewUnsupportedStatsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedStatsStatementContext {
	var p = new(UnsupportedStatsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedStatsStatement

	return p
}

func (s *UnsupportedStatsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedStatsStatementContext) CopyAll(ctx *UnsupportedStatsStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedStatsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedStatsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DropAanalyzeJobContext struct {
	UnsupportedStatsStatementContext
}

func NewDropAanalyzeJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropAanalyzeJobContext {
	var p = new(DropAanalyzeJobContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *DropAanalyzeJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropAanalyzeJobContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropAanalyzeJobContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisParserANALYZE, 0)
}

func (s *DropAanalyzeJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *DropAanalyzeJobContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *DropAanalyzeJobContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropAanalyzeJob(s)
	}
}

func (s *DropAanalyzeJobContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropAanalyzeJob(s)
	}
}

type AlterColumnStatsContext struct {
	UnsupportedStatsStatementContext
	name       IMultipartIdentifierContext
	indexName  IIdentifierContext
	columnName IIdentifierContext
}

func NewAlterColumnStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterColumnStatsContext {
	var p = new(AlterColumnStatsContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *AlterColumnStatsContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterColumnStatsContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *AlterColumnStatsContext) GetColumnName() IIdentifierContext { return s.columnName }

func (s *AlterColumnStatsContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterColumnStatsContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *AlterColumnStatsContext) SetColumnName(v IIdentifierContext) { s.columnName = v }

func (s *AlterColumnStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterColumnStatsContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterColumnStatsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AlterColumnStatsContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *AlterColumnStatsContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *AlterColumnStatsContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterColumnStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *AlterColumnStatsContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterColumnStatsContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterColumnStatsContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterColumnStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterColumnStatsContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterColumnStatsContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterColumnStatsContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *AlterColumnStatsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *AlterColumnStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterColumnStats(s)
	}
}

func (s *AlterColumnStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterColumnStats(s)
	}
}

type DropExpiredStatsContext struct {
	UnsupportedStatsStatementContext
}

func NewDropExpiredStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropExpiredStatsContext {
	var p = new(DropExpiredStatsContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *DropExpiredStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropExpiredStatsContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropExpiredStatsContext) EXPIRED() antlr.TerminalNode {
	return s.GetToken(DorisParserEXPIRED, 0)
}

func (s *DropExpiredStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *DropExpiredStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropExpiredStats(s)
	}
}

func (s *DropExpiredStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropExpiredStats(s)
	}
}

type AlterTableStatsContext struct {
	UnsupportedStatsStatementContext
	name IMultipartIdentifierContext
}

func NewAlterTableStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableStatsContext {
	var p = new(AlterTableStatsContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *AlterTableStatsContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterTableStatsContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterTableStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableStatsContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterTableStatsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AlterTableStatsContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterTableStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *AlterTableStatsContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterTableStatsContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterTableStatsContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterTableStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterTableStatsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *AlterTableStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterTableStats(s)
	}
}

func (s *AlterTableStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterTableStats(s)
	}
}

type DropStatsContext struct {
	UnsupportedStatsStatementContext
	tableName IMultipartIdentifierContext
	columns   IIdentifierListContext
}

func NewDropStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropStatsContext {
	var p = new(DropStatsContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *DropStatsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DropStatsContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *DropStatsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DropStatsContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *DropStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStatsContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *DropStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropStatsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *DropStatsContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DropStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropStats(s)
	}
}

func (s *DropStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropStats(s)
	}
}

type DropCachedStatsContext struct {
	UnsupportedStatsStatementContext
	tableName IMultipartIdentifierContext
}

func NewDropCachedStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropCachedStatsContext {
	var p = new(DropCachedStatsContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *DropCachedStatsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DropCachedStatsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DropCachedStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropCachedStatsContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropCachedStatsContext) CACHED() antlr.TerminalNode {
	return s.GetToken(DorisParserCACHED, 0)
}

func (s *DropCachedStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *DropCachedStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropCachedStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropCachedStats(s)
	}
}

func (s *DropCachedStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropCachedStats(s)
	}
}

func (p *DorisParser) UnsupportedStatsStatement() (localctx IUnsupportedStatsStatementContext) {
	localctx = NewUnsupportedStatsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, DorisParserRULE_unsupportedStatsStatement)
	var _la int

	p.SetState(2073)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 252, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAlterTableStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2024)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2025)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2026)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterTableStatsContext).name = _x
		}
		{
			p.SetState(2027)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2028)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2029)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2030)
			p.PropertyItemList()
		}
		{
			p.SetState(2031)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2033)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(2032)
				p.PartitionSpec()
			}

		}

	case 2:
		localctx = NewAlterColumnStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2035)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2036)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2037)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterColumnStatsContext).name = _x
		}
		p.SetState(2040)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserINDEX {
			{
				p.SetState(2038)
				p.Match(DorisParserINDEX)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2039)

				var _x = p.Identifier()

				localctx.(*AlterColumnStatsContext).indexName = _x
			}

		}
		{
			p.SetState(2042)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2043)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2044)

			var _x = p.Identifier()

			localctx.(*AlterColumnStatsContext).columnName = _x
		}
		{
			p.SetState(2045)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2046)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2047)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2048)
			p.PropertyItemList()
		}
		{
			p.SetState(2049)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2051)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(2050)
				p.PartitionSpec()
			}

		}

	case 3:
		localctx = NewDropStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2053)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2054)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2055)

			var _x = p.MultipartIdentifier()

			localctx.(*DropStatsContext).tableName = _x
		}
		p.SetState(2057)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(2056)

				var _x = p.IdentifierList()

				localctx.(*DropStatsContext).columns = _x
			}

		}
		p.SetState(2060)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(2059)
				p.PartitionSpec()
			}

		}

	case 4:
		localctx = NewDropCachedStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2062)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2063)
			p.Match(DorisParserCACHED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2064)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2065)

			var _x = p.MultipartIdentifier()

			localctx.(*DropCachedStatsContext).tableName = _x
		}

	case 5:
		localctx = NewDropExpiredStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2066)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2067)
			p.Match(DorisParserEXPIRED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2068)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewDropAanalyzeJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2069)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2070)
			p.Match(DorisParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2071)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2072)
			p.Match(DorisParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedCreateStatementContext is an interface to support dynamic dispatch.
type IUnsupportedCreateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedCreateStatementContext differentiates from other interfaces.
	IsUnsupportedCreateStatementContext()
}

type UnsupportedCreateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedCreateStatementContext() *UnsupportedCreateStatementContext {
	var p = new(UnsupportedCreateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedCreateStatement
	return p
}

func InitEmptyUnsupportedCreateStatementContext(p *UnsupportedCreateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedCreateStatement
}

func (*UnsupportedCreateStatementContext) IsUnsupportedCreateStatementContext() {}

func NewUnsupportedCreateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedCreateStatementContext {
	var p = new(UnsupportedCreateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedCreateStatement

	return p
}

func (s *UnsupportedCreateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedCreateStatementContext) CopyAll(ctx *UnsupportedCreateStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedCreateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedCreateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CreateStorageVaultContext struct {
	UnsupportedCreateStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewCreateStorageVaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateStorageVaultContext {
	var p = new(CreateStorageVaultContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateStorageVaultContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *CreateStorageVaultContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateStorageVaultContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *CreateStorageVaultContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateStorageVaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStorageVaultContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateStorageVaultContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *CreateStorageVaultContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULT, 0)
}

func (s *CreateStorageVaultContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CreateStorageVaultContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateStorageVaultContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateStorageVaultContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateStorageVaultContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateStorageVaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateStorageVault(s)
	}
}

func (s *CreateStorageVaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateStorageVault(s)
	}
}

type CreateWorkloadPolicyContext struct {
	UnsupportedCreateStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewCreateWorkloadPolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateWorkloadPolicyContext {
	var p = new(CreateWorkloadPolicyContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateWorkloadPolicyContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *CreateWorkloadPolicyContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateWorkloadPolicyContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *CreateWorkloadPolicyContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateWorkloadPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateWorkloadPolicyContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateWorkloadPolicyContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserWORKLOAD, 0)
}

func (s *CreateWorkloadPolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *CreateWorkloadPolicyContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CreateWorkloadPolicyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateWorkloadPolicyContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateWorkloadPolicyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateWorkloadPolicyContext) CONDITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserCONDITIONS, 0)
}

func (s *CreateWorkloadPolicyContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserLEFT_PAREN)
}

func (s *CreateWorkloadPolicyContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, i)
}

func (s *CreateWorkloadPolicyContext) WorkloadPolicyConditions() IWorkloadPolicyConditionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWorkloadPolicyConditionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWorkloadPolicyConditionsContext)
}

func (s *CreateWorkloadPolicyContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserRIGHT_PAREN)
}

func (s *CreateWorkloadPolicyContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, i)
}

func (s *CreateWorkloadPolicyContext) ACTIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserACTIONS, 0)
}

func (s *CreateWorkloadPolicyContext) WorkloadPolicyActions() IWorkloadPolicyActionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWorkloadPolicyActionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWorkloadPolicyActionsContext)
}

func (s *CreateWorkloadPolicyContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateWorkloadPolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateWorkloadPolicy(s)
	}
}

func (s *CreateWorkloadPolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateWorkloadPolicy(s)
	}
}

type CreateResourceContext struct {
	UnsupportedCreateStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewCreateResourceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateResourceContext {
	var p = new(CreateResourceContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateResourceContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *CreateResourceContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateResourceContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *CreateResourceContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateResourceContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateResourceContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCE, 0)
}

func (s *CreateResourceContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CreateResourceContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisParserEXTERNAL, 0)
}

func (s *CreateResourceContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateResourceContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateResourceContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateResourceContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateResourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateResource(s)
	}
}

func (s *CreateResourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateResource(s)
	}
}

type CreateDataSyncJobContext struct {
	UnsupportedCreateStatementContext
	dbName     IIdentifierContext
	jobName    IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewCreateDataSyncJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateDataSyncJobContext {
	var p = new(CreateDataSyncJobContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateDataSyncJobContext) GetDbName() IIdentifierContext { return s.dbName }

func (s *CreateDataSyncJobContext) GetJobName() IIdentifierOrTextContext { return s.jobName }

func (s *CreateDataSyncJobContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateDataSyncJobContext) SetDbName(v IIdentifierContext) { s.dbName = v }

func (s *CreateDataSyncJobContext) SetJobName(v IIdentifierOrTextContext) { s.jobName = v }

func (s *CreateDataSyncJobContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateDataSyncJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDataSyncJobContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateDataSyncJobContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DorisParserSYNC, 0)
}

func (s *CreateDataSyncJobContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *CreateDataSyncJobContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserLEFT_PAREN)
}

func (s *CreateDataSyncJobContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, i)
}

func (s *CreateDataSyncJobContext) ChannelDescriptions() IChannelDescriptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelDescriptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelDescriptionsContext)
}

func (s *CreateDataSyncJobContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserRIGHT_PAREN)
}

func (s *CreateDataSyncJobContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, i)
}

func (s *CreateDataSyncJobContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *CreateDataSyncJobContext) BINLOG() antlr.TerminalNode {
	return s.GetToken(DorisParserBINLOG, 0)
}

func (s *CreateDataSyncJobContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *CreateDataSyncJobContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateDataSyncJobContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CreateDataSyncJobContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateDataSyncJobContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateDataSyncJob(s)
	}
}

func (s *CreateDataSyncJobContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateDataSyncJob(s)
	}
}

type CreateUserDefineFunctionContext struct {
	UnsupportedCreateStatementContext
	returnType       IDataTypeContext
	intermediateType IDataTypeContext
	properties       IPropertyClauseContext
}

func NewCreateUserDefineFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateUserDefineFunctionContext {
	var p = new(CreateUserDefineFunctionContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateUserDefineFunctionContext) GetReturnType() IDataTypeContext { return s.returnType }

func (s *CreateUserDefineFunctionContext) GetIntermediateType() IDataTypeContext {
	return s.intermediateType
}

func (s *CreateUserDefineFunctionContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateUserDefineFunctionContext) SetReturnType(v IDataTypeContext) { s.returnType = v }

func (s *CreateUserDefineFunctionContext) SetIntermediateType(v IDataTypeContext) {
	s.intermediateType = v
}

func (s *CreateUserDefineFunctionContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateUserDefineFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserDefineFunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateUserDefineFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserFUNCTION, 0)
}

func (s *CreateUserDefineFunctionContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *CreateUserDefineFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CreateUserDefineFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CreateUserDefineFunctionContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(DorisParserRETURNS, 0)
}

func (s *CreateUserDefineFunctionContext) AllDataType() []IDataTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeContext); ok {
			tst[i] = t.(IDataTypeContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserDefineFunctionContext) DataType(i int) IDataTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CreateUserDefineFunctionContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateUserDefineFunctionContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateUserDefineFunctionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateUserDefineFunctionContext) FunctionArguments() IFunctionArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgumentsContext)
}

func (s *CreateUserDefineFunctionContext) INTERMEDIATE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTERMEDIATE, 0)
}

func (s *CreateUserDefineFunctionContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *CreateUserDefineFunctionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION, 0)
}

func (s *CreateUserDefineFunctionContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *CreateUserDefineFunctionContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLES, 0)
}

func (s *CreateUserDefineFunctionContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(DorisParserAGGREGATE, 0)
}

func (s *CreateUserDefineFunctionContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateUserDefineFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateUserDefineFunction(s)
	}
}

func (s *CreateUserDefineFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateUserDefineFunction(s)
	}
}

type CreateWorkloadGroupContext struct {
	UnsupportedCreateStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewCreateWorkloadGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateWorkloadGroupContext {
	var p = new(CreateWorkloadGroupContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateWorkloadGroupContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *CreateWorkloadGroupContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateWorkloadGroupContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *CreateWorkloadGroupContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateWorkloadGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateWorkloadGroupContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateWorkloadGroupContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserWORKLOAD, 0)
}

func (s *CreateWorkloadGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUP, 0)
}

func (s *CreateWorkloadGroupContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CreateWorkloadGroupContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateWorkloadGroupContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateWorkloadGroupContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateWorkloadGroupContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateWorkloadGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateWorkloadGroup(s)
	}
}

func (s *CreateWorkloadGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateWorkloadGroup(s)
	}
}

type CreateStoragePolicyContext struct {
	UnsupportedCreateStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateStoragePolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateStoragePolicyContext {
	var p = new(CreateStoragePolicyContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateStoragePolicyContext) GetName() IIdentifierContext { return s.name }

func (s *CreateStoragePolicyContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateStoragePolicyContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateStoragePolicyContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateStoragePolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStoragePolicyContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateStoragePolicyContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *CreateStoragePolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *CreateStoragePolicyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateStoragePolicyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateStoragePolicyContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateStoragePolicyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateStoragePolicyContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateStoragePolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateStoragePolicy(s)
	}
}

func (s *CreateStoragePolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateStoragePolicy(s)
	}
}

type CreateRoleContext struct {
	UnsupportedCreateStatementContext
	name IIdentifierContext
}

func NewCreateRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateRoleContext {
	var p = new(CreateRoleContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateRoleContext) GetName() IIdentifierContext { return s.name }

func (s *CreateRoleContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoleContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *CreateRoleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRoleContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateRoleContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateRoleContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateRoleContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *CreateRoleContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateRole(s)
	}
}

func (s *CreateRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateRole(s)
	}
}

type CreateStageContext struct {
	UnsupportedCreateStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateStageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateStageContext {
	var p = new(CreateStageContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateStageContext) GetName() IIdentifierContext { return s.name }

func (s *CreateStageContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateStageContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateStageContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateStageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStageContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateStageContext) STAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTAGE, 0)
}

func (s *CreateStageContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateStageContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateStageContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateStageContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateStageContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateStageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateStage(s)
	}
}

func (s *CreateStageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateStage(s)
	}
}

type CreateIndexContext struct {
	UnsupportedCreateStatementContext
	name       IIdentifierContext
	tableName  IMultipartIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateIndexContext {
	var p = new(CreateIndexContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateIndexContext) GetName() IIdentifierContext { return s.name }

func (s *CreateIndexContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *CreateIndexContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateIndexContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateIndexContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *CreateIndexContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *CreateIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *CreateIndexContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateIndexContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateIndexContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateIndexContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateIndexContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateIndexContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateIndexContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserUSING, 0)
}

func (s *CreateIndexContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *CreateIndexContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateIndexContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(DorisParserBITMAP, 0)
}

func (s *CreateIndexContext) NGRAM_BF() antlr.TerminalNode {
	return s.GetToken(DorisParserNGRAM_BF, 0)
}

func (s *CreateIndexContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserINVERTED, 0)
}

func (s *CreateIndexContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateIndex(s)
	}
}

func (s *CreateIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateIndex(s)
	}
}

type CreateFileContext struct {
	UnsupportedCreateStatementContext
	name       antlr.Token
	database   IIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateFileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateFileContext {
	var p = new(CreateFileContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateFileContext) GetName() antlr.Token { return s.name }

func (s *CreateFileContext) SetName(v antlr.Token) { s.name = v }

func (s *CreateFileContext) GetDatabase() IIdentifierContext { return s.database }

func (s *CreateFileContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateFileContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *CreateFileContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFileContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateFileContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisParserFILE, 0)
}

func (s *CreateFileContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateFileContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateFileContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *CreateFileContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *CreateFileContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateFile(s)
	}
}

func (s *CreateFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateFile(s)
	}
}

type CreateRepositoryContext struct {
	UnsupportedCreateStatementContext
	name IIdentifierContext
}

func NewCreateRepositoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateRepositoryContext {
	var p = new(CreateRepositoryContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateRepositoryContext) GetName() IIdentifierContext { return s.name }

func (s *CreateRepositoryContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateRepositoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRepositoryContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateRepositoryContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisParserREPOSITORY, 0)
}

func (s *CreateRepositoryContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *CreateRepositoryContext) StorageBackend() IStorageBackendContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStorageBackendContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStorageBackendContext)
}

func (s *CreateRepositoryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRepositoryContext) READ() antlr.TerminalNode {
	return s.GetToken(DorisParserREAD, 0)
}

func (s *CreateRepositoryContext) ONLY() antlr.TerminalNode {
	return s.GetToken(DorisParserONLY, 0)
}

func (s *CreateRepositoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateRepository(s)
	}
}

func (s *CreateRepositoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateRepository(s)
	}
}

type CreateEncryptkeyContext struct {
	UnsupportedCreateStatementContext
}

func NewCreateEncryptkeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateEncryptkeyContext {
	var p = new(CreateEncryptkeyContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateEncryptkeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateEncryptkeyContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateEncryptkeyContext) ENCRYPTKEY() antlr.TerminalNode {
	return s.GetToken(DorisParserENCRYPTKEY, 0)
}

func (s *CreateEncryptkeyContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateEncryptkeyContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *CreateEncryptkeyContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateEncryptkeyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateEncryptkeyContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateEncryptkeyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateEncryptkeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateEncryptkey(s)
	}
}

func (s *CreateEncryptkeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateEncryptkey(s)
	}
}

type CreateDatabaseContext struct {
	UnsupportedCreateStatementContext
	name       IMultipartIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateDatabaseContext {
	var p = new(CreateDatabaseContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateDatabaseContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CreateDatabaseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateDatabaseContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CreateDatabaseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDatabaseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *CreateDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEMA, 0)
}

func (s *CreateDatabaseContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateDatabaseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateDatabaseContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateDatabaseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateDatabaseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateDatabase(s)
	}
}

func (s *CreateDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateDatabase(s)
	}
}

type BuildIndexContext struct {
	UnsupportedCreateStatementContext
	name      IIdentifierContext
	tableName IMultipartIdentifierContext
}

func NewBuildIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BuildIndexContext {
	var p = new(BuildIndexContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *BuildIndexContext) GetName() IIdentifierContext { return s.name }

func (s *BuildIndexContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *BuildIndexContext) SetName(v IIdentifierContext) { s.name = v }

func (s *BuildIndexContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *BuildIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BuildIndexContext) BUILD() antlr.TerminalNode {
	return s.GetToken(DorisParserBUILD, 0)
}

func (s *BuildIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *BuildIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *BuildIndexContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BuildIndexContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *BuildIndexContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *BuildIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBuildIndex(s)
	}
}

func (s *BuildIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBuildIndex(s)
	}
}

type CreateUserContext struct {
	UnsupportedCreateStatementContext
	role antlr.Token
}

func NewCreateUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateUserContext {
	var p = new(CreateUserContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateUserContext) GetRole() antlr.Token { return s.role }

func (s *CreateUserContext) SetRole(v antlr.Token) { s.role = v }

func (s *CreateUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateUserContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisParserUSER, 0)
}

func (s *CreateUserContext) GrantUserIdentify() IGrantUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantUserIdentifyContext)
}

func (s *CreateUserContext) PasswordOption() IPasswordOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordOptionContext)
}

func (s *CreateUserContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateUserContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateUserContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateUserContext) SUPERUSER() antlr.TerminalNode {
	return s.GetToken(DorisParserSUPERUSER, 0)
}

func (s *CreateUserContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *CreateUserContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *CreateUserContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *CreateUserContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *CreateUserContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *CreateUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateUser(s)
	}
}

func (s *CreateUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateUser(s)
	}
}

type CreateCatalogContext struct {
	UnsupportedCreateStatementContext
	catalogName  IIdentifierContext
	resourceName IIdentifierContext
	properties   IPropertyClauseContext
}

func NewCreateCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateCatalogContext {
	var p = new(CreateCatalogContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateCatalogContext) GetCatalogName() IIdentifierContext { return s.catalogName }

func (s *CreateCatalogContext) GetResourceName() IIdentifierContext { return s.resourceName }

func (s *CreateCatalogContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateCatalogContext) SetCatalogName(v IIdentifierContext) { s.catalogName = v }

func (s *CreateCatalogContext) SetResourceName(v IIdentifierContext) { s.resourceName = v }

func (s *CreateCatalogContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateCatalogContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateCatalogContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *CreateCatalogContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateCatalogContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateCatalogContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateCatalogContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateCatalogContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateCatalogContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *CreateCatalogContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCE, 0)
}

func (s *CreateCatalogContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *CreateCatalogContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateCatalogContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateCatalogContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateCatalog(s)
	}
}

func (s *CreateCatalogContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateCatalog(s)
	}
}

type CreateAliasFunctionContext struct {
	UnsupportedCreateStatementContext
	parameters IIdentifierSeqContext
}

func NewCreateAliasFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateAliasFunctionContext {
	var p = new(CreateAliasFunctionContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateAliasFunctionContext) GetParameters() IIdentifierSeqContext { return s.parameters }

func (s *CreateAliasFunctionContext) SetParameters(v IIdentifierSeqContext) { s.parameters = v }

func (s *CreateAliasFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateAliasFunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateAliasFunctionContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(DorisParserALIAS, 0)
}

func (s *CreateAliasFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserFUNCTION, 0)
}

func (s *CreateAliasFunctionContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *CreateAliasFunctionContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserLEFT_PAREN)
}

func (s *CreateAliasFunctionContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, i)
}

func (s *CreateAliasFunctionContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserRIGHT_PAREN)
}

func (s *CreateAliasFunctionContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, i)
}

func (s *CreateAliasFunctionContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *CreateAliasFunctionContext) PARAMETER() antlr.TerminalNode {
	return s.GetToken(DorisParserPARAMETER, 0)
}

func (s *CreateAliasFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *CreateAliasFunctionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CreateAliasFunctionContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateAliasFunctionContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateAliasFunctionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateAliasFunctionContext) FunctionArguments() IFunctionArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgumentsContext)
}

func (s *CreateAliasFunctionContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *CreateAliasFunctionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION, 0)
}

func (s *CreateAliasFunctionContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *CreateAliasFunctionContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *CreateAliasFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateAliasFunction(s)
	}
}

func (s *CreateAliasFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateAliasFunction(s)
	}
}

type CreateSqlBlockRuleContext struct {
	UnsupportedCreateStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateSqlBlockRuleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateSqlBlockRuleContext {
	var p = new(CreateSqlBlockRuleContext)

	InitEmptyUnsupportedCreateStatementContext(&p.UnsupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedCreateStatementContext))

	return p
}

func (s *CreateSqlBlockRuleContext) GetName() IIdentifierContext { return s.name }

func (s *CreateSqlBlockRuleContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateSqlBlockRuleContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateSqlBlockRuleContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateSqlBlockRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateSqlBlockRuleContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateSqlBlockRuleContext) SQL_BLOCK_RULE() antlr.TerminalNode {
	return s.GetToken(DorisParserSQL_BLOCK_RULE, 0)
}

func (s *CreateSqlBlockRuleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateSqlBlockRuleContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateSqlBlockRuleContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateSqlBlockRuleContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateSqlBlockRuleContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateSqlBlockRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateSqlBlockRule(s)
	}
}

func (s *CreateSqlBlockRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateSqlBlockRule(s)
	}
}

func (p *DorisParser) UnsupportedCreateStatement() (localctx IUnsupportedCreateStatementContext) {
	localctx = NewUnsupportedCreateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, DorisParserRULE_unsupportedCreateStatement)
	var _la int

	p.SetState(2365)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 300, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCreateDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2075)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2076)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserDATABASE || _la == DorisParserSCHEMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2080)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(2077)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2078)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2079)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2082)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateDatabaseContext).name = _x
		}
		p.SetState(2084)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2083)

				var _x = p.PropertyClause()

				localctx.(*CreateDatabaseContext).properties = _x
			}

		}

	case 2:
		localctx = NewCreateCatalogContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2086)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2087)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2091)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(2088)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2089)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2090)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2093)

			var _x = p.Identifier()

			localctx.(*CreateCatalogContext).catalogName = _x
		}
		p.SetState(2097)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(2094)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2095)
				p.Match(DorisParserRESOURCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2096)

				var _x = p.Identifier()

				localctx.(*CreateCatalogContext).resourceName = _x
			}

		}
		p.SetState(2101)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(2099)
				p.Match(DorisParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2100)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2104)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2103)

				var _x = p.PropertyClause()

				localctx.(*CreateCatalogContext).properties = _x
			}

		}

	case 3:
		localctx = NewCreateUserDefineFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2106)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2108)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION {
			{
				p.SetState(2107)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(2111)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAGGREGATE || _la == DorisParserTABLES {
			{
				p.SetState(2110)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserAGGREGATE || _la == DorisParserTABLES) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(2113)
			p.Match(DorisParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2117)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 261, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2114)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2115)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2116)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2119)
			p.FunctionIdentifier()
		}
		{
			p.SetState(2120)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2122)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&9297470595268672) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&4105039856441229313) != 0) || _la == DorisParserDOUBLE || _la == DorisParserFLOAT || ((int64((_la-213)) & ^0x3f) == 0 && ((int64(1)<<(_la-213))&-9223369734650855423) != 0) || _la == DorisParserQUANTILE_STATE || _la == DorisParserSMALLINT || ((int64((_la-430)) & ^0x3f) == 0 && ((int64(1)<<(_la-430))&20266198341124099) != 0) {
			{
				p.SetState(2121)
				p.FunctionArguments()
			}

		}
		{
			p.SetState(2124)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2125)
			p.Match(DorisParserRETURNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2126)

			var _x = p.DataType()

			localctx.(*CreateUserDefineFunctionContext).returnType = _x
		}
		p.SetState(2129)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserINTERMEDIATE {
			{
				p.SetState(2127)
				p.Match(DorisParserINTERMEDIATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2128)

				var _x = p.DataType()

				localctx.(*CreateUserDefineFunctionContext).intermediateType = _x
			}

		}
		p.SetState(2132)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2131)

				var _x = p.PropertyClause()

				localctx.(*CreateUserDefineFunctionContext).properties = _x
			}

		}

	case 4:
		localctx = NewCreateAliasFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2134)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2136)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION {
			{
				p.SetState(2135)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(2138)
			p.Match(DorisParserALIAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2139)
			p.Match(DorisParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2143)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 266, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2140)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2141)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2142)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2145)
			p.FunctionIdentifier()
		}
		{
			p.SetState(2146)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2148)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&9297470595268672) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&4105039856441229313) != 0) || _la == DorisParserDOUBLE || _la == DorisParserFLOAT || ((int64((_la-213)) & ^0x3f) == 0 && ((int64(1)<<(_la-213))&-9223369734650855423) != 0) || _la == DorisParserQUANTILE_STATE || _la == DorisParserSMALLINT || ((int64((_la-430)) & ^0x3f) == 0 && ((int64(1)<<(_la-430))&20266198341124099) != 0) {
			{
				p.SetState(2147)
				p.FunctionArguments()
			}

		}
		{
			p.SetState(2150)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2151)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2152)
			p.Match(DorisParserPARAMETER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2153)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2155)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1153040409952344576) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&-53021438386753) != 0) || ((int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&3476586699635759401) != 0) || ((int64((_la-195)) & ^0x3f) == 0 && ((int64(1)<<(_la-195))&-3139048519776880011) != 0) || ((int64((_la-260)) & ^0x3f) == 0 && ((int64(1)<<(_la-260))&-4544906634320822477) != 0) || ((int64((_la-325)) & ^0x3f) == 0 && ((int64(1)<<(_la-325))&6339805778266808319) != 0) || ((int64((_la-390)) & ^0x3f) == 0 && ((int64(1)<<(_la-390))&-656945004016972825) != 0) || ((int64((_la-456)) & ^0x3f) == 0 && ((int64(1)<<(_la-456))&18760394443469) != 0) || ((int64((_la-522)) & ^0x3f) == 0 && ((int64(1)<<(_la-522))&49159) != 0) {
			{
				p.SetState(2154)

				var _x = p.IdentifierSeq()

				localctx.(*CreateAliasFunctionContext).parameters = _x
			}

		}
		{
			p.SetState(2157)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2158)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2159)
			p.Expression()
		}

	case 5:
		localctx = NewCreateUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2161)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2162)
			p.Match(DorisParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2166)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(2163)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2164)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2165)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2168)
			p.GrantUserIdentify()
		}
		p.SetState(2173)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case DorisParserSUPERUSER:
			{
				p.SetState(2169)
				p.Match(DorisParserSUPERUSER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserDEFAULT:
			{
				p.SetState(2170)
				p.Match(DorisParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2171)
				p.Match(DorisParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2172)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*CreateUserContext).role = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserEOF, DorisParserSEMICOLON, DorisParserACCOUNT_LOCK, DorisParserACCOUNT_UNLOCK, DorisParserCOMMENT, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE:

		default:
		}
		{
			p.SetState(2175)
			p.PasswordOption()
		}
		p.SetState(2178)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(2176)
				p.Match(DorisParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2177)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		localctx = NewCreateRepositoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2180)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2183)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserREAD {
			{
				p.SetState(2181)
				p.Match(DorisParserREAD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2182)
				p.Match(DorisParserONLY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2185)
			p.Match(DorisParserREPOSITORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2186)

			var _x = p.Identifier()

			localctx.(*CreateRepositoryContext).name = _x
		}
		{
			p.SetState(2187)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2188)
			p.StorageBackend()
		}

	case 7:
		localctx = NewCreateRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2190)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2191)
			p.Match(DorisParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2195)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(2192)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2193)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2194)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2197)

			var _x = p.Identifier()

			localctx.(*CreateRoleContext).name = _x
		}
		p.SetState(2200)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(2198)
				p.Match(DorisParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2199)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 8:
		localctx = NewCreateFileContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2202)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2203)
			p.Match(DorisParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2204)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*CreateFileContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2207)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2205)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2206)

				var _x = p.Identifier()

				localctx.(*CreateFileContext).database = _x
			}

		}
		{
			p.SetState(2209)

			var _x = p.PropertyClause()

			localctx.(*CreateFileContext).properties = _x
		}

	case 9:
		localctx = NewCreateIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2210)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2211)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2215)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(2212)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2213)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2214)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2217)

			var _x = p.Identifier()

			localctx.(*CreateIndexContext).name = _x
		}
		{
			p.SetState(2218)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2219)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateIndexContext).tableName = _x
		}
		{
			p.SetState(2220)
			p.IdentifierList()
		}
		p.SetState(2223)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserUSING {
			{
				p.SetState(2221)
				p.Match(DorisParserUSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2222)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserBITMAP || _la == DorisParserINVERTED || _la == DorisParserNGRAM_BF) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(2226)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2225)

				var _x = p.PropertyClause()

				localctx.(*CreateIndexContext).properties = _x
			}

		}
		p.SetState(2230)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(2228)
				p.Match(DorisParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2229)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 10:
		localctx = NewCreateResourceContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2232)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2234)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserEXTERNAL {
			{
				p.SetState(2233)
				p.Match(DorisParserEXTERNAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2236)
			p.Match(DorisParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2240)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(2237)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2238)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2239)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2242)

			var _x = p.IdentifierOrText()

			localctx.(*CreateResourceContext).name = _x
		}
		p.SetState(2244)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2243)

				var _x = p.PropertyClause()

				localctx.(*CreateResourceContext).properties = _x
			}

		}

	case 11:
		localctx = NewCreateStorageVaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2246)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2247)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2248)
			p.Match(DorisParserVAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2252)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(2249)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2250)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2251)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2254)

			var _x = p.IdentifierOrText()

			localctx.(*CreateStorageVaultContext).name = _x
		}
		p.SetState(2256)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2255)

				var _x = p.PropertyClause()

				localctx.(*CreateStorageVaultContext).properties = _x
			}

		}

	case 12:
		localctx = NewCreateWorkloadGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2258)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2259)
			p.Match(DorisParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2260)
			p.Match(DorisParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2264)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(2261)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2262)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2263)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2266)

			var _x = p.IdentifierOrText()

			localctx.(*CreateWorkloadGroupContext).name = _x
		}
		p.SetState(2268)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2267)

				var _x = p.PropertyClause()

				localctx.(*CreateWorkloadGroupContext).properties = _x
			}

		}

	case 13:
		localctx = NewCreateWorkloadPolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2270)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2271)
			p.Match(DorisParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2272)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2276)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(2273)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2274)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2275)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2278)

			var _x = p.IdentifierOrText()

			localctx.(*CreateWorkloadPolicyContext).name = _x
		}
		p.SetState(2284)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCONDITIONS {
			{
				p.SetState(2279)
				p.Match(DorisParserCONDITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2280)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2281)
				p.WorkloadPolicyConditions()
			}
			{
				p.SetState(2282)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2291)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserACTIONS {
			{
				p.SetState(2286)
				p.Match(DorisParserACTIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2287)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2288)
				p.WorkloadPolicyActions()
			}
			{
				p.SetState(2289)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2294)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2293)

				var _x = p.PropertyClause()

				localctx.(*CreateWorkloadPolicyContext).properties = _x
			}

		}

	case 14:
		localctx = NewCreateEncryptkeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2296)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2297)
			p.Match(DorisParserENCRYPTKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2301)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(2298)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2299)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2300)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2303)
			p.MultipartIdentifier()
		}
		{
			p.SetState(2304)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2305)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		localctx = NewCreateDataSyncJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(2307)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2308)
			p.Match(DorisParserSYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2309)

			var _x = p.Identifier()

			localctx.(*CreateDataSyncJobContext).dbName = _x
		}
		{
			p.SetState(2310)
			p.Match(DorisParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2311)

			var _x = p.IdentifierOrText()

			localctx.(*CreateDataSyncJobContext).jobName = _x
		}
		{
			p.SetState(2312)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2313)
			p.ChannelDescriptions()
		}
		{
			p.SetState(2314)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2315)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2316)
			p.Match(DorisParserBINLOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2317)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2318)
			p.PropertyItemList()
		}
		{
			p.SetState(2319)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2321)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2320)

				var _x = p.PropertyClause()

				localctx.(*CreateDataSyncJobContext).properties = _x
			}

		}

	case 16:
		localctx = NewCreateSqlBlockRuleContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(2323)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2324)
			p.Match(DorisParserSQL_BLOCK_RULE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2328)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(2325)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2326)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2327)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2330)

			var _x = p.Identifier()

			localctx.(*CreateSqlBlockRuleContext).name = _x
		}
		p.SetState(2332)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2331)

				var _x = p.PropertyClause()

				localctx.(*CreateSqlBlockRuleContext).properties = _x
			}

		}

	case 17:
		localctx = NewCreateStoragePolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(2334)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2335)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2336)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2340)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(2337)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2338)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2339)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2342)

			var _x = p.Identifier()

			localctx.(*CreateStoragePolicyContext).name = _x
		}
		p.SetState(2344)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2343)

				var _x = p.PropertyClause()

				localctx.(*CreateStoragePolicyContext).properties = _x
			}

		}

	case 18:
		localctx = NewBuildIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(2346)
			p.Match(DorisParserBUILD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2347)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2348)

			var _x = p.Identifier()

			localctx.(*BuildIndexContext).name = _x
		}
		{
			p.SetState(2349)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2350)

			var _x = p.MultipartIdentifier()

			localctx.(*BuildIndexContext).tableName = _x
		}
		p.SetState(2352)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(2351)
				p.PartitionSpec()
			}

		}

	case 19:
		localctx = NewCreateStageContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(2354)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2355)
			p.Match(DorisParserSTAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2359)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(2356)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2357)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2358)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2361)

			var _x = p.Identifier()

			localctx.(*CreateStageContext).name = _x
		}
		p.SetState(2363)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2362)

				var _x = p.PropertyClause()

				localctx.(*CreateStageContext).properties = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChannelDescriptionsContext is an interface to support dynamic dispatch.
type IChannelDescriptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllChannelDescription() []IChannelDescriptionContext
	ChannelDescription(i int) IChannelDescriptionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsChannelDescriptionsContext differentiates from other interfaces.
	IsChannelDescriptionsContext()
}

type ChannelDescriptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChannelDescriptionsContext() *ChannelDescriptionsContext {
	var p = new(ChannelDescriptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_channelDescriptions
	return p
}

func InitEmptyChannelDescriptionsContext(p *ChannelDescriptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_channelDescriptions
}

func (*ChannelDescriptionsContext) IsChannelDescriptionsContext() {}

func NewChannelDescriptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChannelDescriptionsContext {
	var p = new(ChannelDescriptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_channelDescriptions

	return p
}

func (s *ChannelDescriptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ChannelDescriptionsContext) AllChannelDescription() []IChannelDescriptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IChannelDescriptionContext); ok {
			len++
		}
	}

	tst := make([]IChannelDescriptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IChannelDescriptionContext); ok {
			tst[i] = t.(IChannelDescriptionContext)
			i++
		}
	}

	return tst
}

func (s *ChannelDescriptionsContext) ChannelDescription(i int) IChannelDescriptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelDescriptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelDescriptionContext)
}

func (s *ChannelDescriptionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ChannelDescriptionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ChannelDescriptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChannelDescriptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChannelDescriptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterChannelDescriptions(s)
	}
}

func (s *ChannelDescriptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitChannelDescriptions(s)
	}
}

func (p *DorisParser) ChannelDescriptions() (localctx IChannelDescriptionsContext) {
	localctx = NewChannelDescriptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, DorisParserRULE_channelDescriptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2367)
		p.ChannelDescription()
	}
	p.SetState(2372)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(2368)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2369)
			p.ChannelDescription()
		}

		p.SetState(2374)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChannelDescriptionContext is an interface to support dynamic dispatch.
type IChannelDescriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSource returns the source rule contexts.
	GetSource() IMultipartIdentifierContext

	// GetDestination returns the destination rule contexts.
	GetDestination() IMultipartIdentifierContext

	// GetColumnList returns the columnList rule contexts.
	GetColumnList() IIdentifierListContext

	// SetSource sets the source rule contexts.
	SetSource(IMultipartIdentifierContext)

	// SetDestination sets the destination rule contexts.
	SetDestination(IMultipartIdentifierContext)

	// SetColumnList sets the columnList rule contexts.
	SetColumnList(IIdentifierListContext)

	// Getter signatures
	FROM() antlr.TerminalNode
	INTO() antlr.TerminalNode
	AllMultipartIdentifier() []IMultipartIdentifierContext
	MultipartIdentifier(i int) IMultipartIdentifierContext
	PartitionSpec() IPartitionSpecContext
	IdentifierList() IIdentifierListContext

	// IsChannelDescriptionContext differentiates from other interfaces.
	IsChannelDescriptionContext()
}

type ChannelDescriptionContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	source      IMultipartIdentifierContext
	destination IMultipartIdentifierContext
	columnList  IIdentifierListContext
}

func NewEmptyChannelDescriptionContext() *ChannelDescriptionContext {
	var p = new(ChannelDescriptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_channelDescription
	return p
}

func InitEmptyChannelDescriptionContext(p *ChannelDescriptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_channelDescription
}

func (*ChannelDescriptionContext) IsChannelDescriptionContext() {}

func NewChannelDescriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChannelDescriptionContext {
	var p = new(ChannelDescriptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_channelDescription

	return p
}

func (s *ChannelDescriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ChannelDescriptionContext) GetSource() IMultipartIdentifierContext { return s.source }

func (s *ChannelDescriptionContext) GetDestination() IMultipartIdentifierContext {
	return s.destination
}

func (s *ChannelDescriptionContext) GetColumnList() IIdentifierListContext { return s.columnList }

func (s *ChannelDescriptionContext) SetSource(v IMultipartIdentifierContext) { s.source = v }

func (s *ChannelDescriptionContext) SetDestination(v IMultipartIdentifierContext) { s.destination = v }

func (s *ChannelDescriptionContext) SetColumnList(v IIdentifierListContext) { s.columnList = v }

func (s *ChannelDescriptionContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ChannelDescriptionContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserINTO, 0)
}

func (s *ChannelDescriptionContext) AllMultipartIdentifier() []IMultipartIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultipartIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipartIdentifierContext); ok {
			tst[i] = t.(IMultipartIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ChannelDescriptionContext) MultipartIdentifier(i int) IMultipartIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ChannelDescriptionContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *ChannelDescriptionContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ChannelDescriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChannelDescriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChannelDescriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterChannelDescription(s)
	}
}

func (s *ChannelDescriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitChannelDescription(s)
	}
}

func (p *DorisParser) ChannelDescription() (localctx IChannelDescriptionContext) {
	localctx = NewChannelDescriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, DorisParserRULE_channelDescription)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2375)
		p.Match(DorisParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2376)

		var _x = p.MultipartIdentifier()

		localctx.(*ChannelDescriptionContext).source = _x
	}
	{
		p.SetState(2377)
		p.Match(DorisParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2378)

		var _x = p.MultipartIdentifier()

		localctx.(*ChannelDescriptionContext).destination = _x
	}
	p.SetState(2380)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
		{
			p.SetState(2379)
			p.PartitionSpec()
		}

	}
	p.SetState(2383)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLEFT_PAREN {
		{
			p.SetState(2382)

			var _x = p.IdentifierList()

			localctx.(*ChannelDescriptionContext).columnList = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWorkloadPolicyActionsContext is an interface to support dynamic dispatch.
type IWorkloadPolicyActionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWorkloadPolicyAction() []IWorkloadPolicyActionContext
	WorkloadPolicyAction(i int) IWorkloadPolicyActionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWorkloadPolicyActionsContext differentiates from other interfaces.
	IsWorkloadPolicyActionsContext()
}

type WorkloadPolicyActionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWorkloadPolicyActionsContext() *WorkloadPolicyActionsContext {
	var p = new(WorkloadPolicyActionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_workloadPolicyActions
	return p
}

func InitEmptyWorkloadPolicyActionsContext(p *WorkloadPolicyActionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_workloadPolicyActions
}

func (*WorkloadPolicyActionsContext) IsWorkloadPolicyActionsContext() {}

func NewWorkloadPolicyActionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WorkloadPolicyActionsContext {
	var p = new(WorkloadPolicyActionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_workloadPolicyActions

	return p
}

func (s *WorkloadPolicyActionsContext) GetParser() antlr.Parser { return s.parser }

func (s *WorkloadPolicyActionsContext) AllWorkloadPolicyAction() []IWorkloadPolicyActionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWorkloadPolicyActionContext); ok {
			len++
		}
	}

	tst := make([]IWorkloadPolicyActionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWorkloadPolicyActionContext); ok {
			tst[i] = t.(IWorkloadPolicyActionContext)
			i++
		}
	}

	return tst
}

func (s *WorkloadPolicyActionsContext) WorkloadPolicyAction(i int) IWorkloadPolicyActionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWorkloadPolicyActionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWorkloadPolicyActionContext)
}

func (s *WorkloadPolicyActionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *WorkloadPolicyActionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *WorkloadPolicyActionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WorkloadPolicyActionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WorkloadPolicyActionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWorkloadPolicyActions(s)
	}
}

func (s *WorkloadPolicyActionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWorkloadPolicyActions(s)
	}
}

func (p *DorisParser) WorkloadPolicyActions() (localctx IWorkloadPolicyActionsContext) {
	localctx = NewWorkloadPolicyActionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, DorisParserRULE_workloadPolicyActions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2385)
		p.WorkloadPolicyAction()
	}
	p.SetState(2390)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(2386)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2387)
			p.WorkloadPolicyAction()
		}

		p.SetState(2392)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWorkloadPolicyActionContext is an interface to support dynamic dispatch.
type IWorkloadPolicyActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET_SESSION_VARIABLE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsWorkloadPolicyActionContext differentiates from other interfaces.
	IsWorkloadPolicyActionContext()
}

type WorkloadPolicyActionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWorkloadPolicyActionContext() *WorkloadPolicyActionContext {
	var p = new(WorkloadPolicyActionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_workloadPolicyAction
	return p
}

func InitEmptyWorkloadPolicyActionContext(p *WorkloadPolicyActionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_workloadPolicyAction
}

func (*WorkloadPolicyActionContext) IsWorkloadPolicyActionContext() {}

func NewWorkloadPolicyActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WorkloadPolicyActionContext {
	var p = new(WorkloadPolicyActionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_workloadPolicyAction

	return p
}

func (s *WorkloadPolicyActionContext) GetParser() antlr.Parser { return s.parser }

func (s *WorkloadPolicyActionContext) SET_SESSION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserSET_SESSION_VARIABLE, 0)
}

func (s *WorkloadPolicyActionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *WorkloadPolicyActionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WorkloadPolicyActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WorkloadPolicyActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WorkloadPolicyActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWorkloadPolicyAction(s)
	}
}

func (s *WorkloadPolicyActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWorkloadPolicyAction(s)
	}
}

func (p *DorisParser) WorkloadPolicyAction() (localctx IWorkloadPolicyActionContext) {
	localctx = NewWorkloadPolicyActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, DorisParserRULE_workloadPolicyAction)
	var _la int

	p.SetState(2399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 306, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2393)
			p.Match(DorisParserSET_SESSION_VARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2394)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2395)
			p.Identifier()
		}
		p.SetState(2397)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserSTRING_LITERAL {
			{
				p.SetState(2396)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWorkloadPolicyConditionsContext is an interface to support dynamic dispatch.
type IWorkloadPolicyConditionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWorkloadPolicyCondition() []IWorkloadPolicyConditionContext
	WorkloadPolicyCondition(i int) IWorkloadPolicyConditionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWorkloadPolicyConditionsContext differentiates from other interfaces.
	IsWorkloadPolicyConditionsContext()
}

type WorkloadPolicyConditionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWorkloadPolicyConditionsContext() *WorkloadPolicyConditionsContext {
	var p = new(WorkloadPolicyConditionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_workloadPolicyConditions
	return p
}

func InitEmptyWorkloadPolicyConditionsContext(p *WorkloadPolicyConditionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_workloadPolicyConditions
}

func (*WorkloadPolicyConditionsContext) IsWorkloadPolicyConditionsContext() {}

func NewWorkloadPolicyConditionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WorkloadPolicyConditionsContext {
	var p = new(WorkloadPolicyConditionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_workloadPolicyConditions

	return p
}

func (s *WorkloadPolicyConditionsContext) GetParser() antlr.Parser { return s.parser }

func (s *WorkloadPolicyConditionsContext) AllWorkloadPolicyCondition() []IWorkloadPolicyConditionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWorkloadPolicyConditionContext); ok {
			len++
		}
	}

	tst := make([]IWorkloadPolicyConditionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWorkloadPolicyConditionContext); ok {
			tst[i] = t.(IWorkloadPolicyConditionContext)
			i++
		}
	}

	return tst
}

func (s *WorkloadPolicyConditionsContext) WorkloadPolicyCondition(i int) IWorkloadPolicyConditionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWorkloadPolicyConditionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWorkloadPolicyConditionContext)
}

func (s *WorkloadPolicyConditionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *WorkloadPolicyConditionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *WorkloadPolicyConditionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WorkloadPolicyConditionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WorkloadPolicyConditionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWorkloadPolicyConditions(s)
	}
}

func (s *WorkloadPolicyConditionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWorkloadPolicyConditions(s)
	}
}

func (p *DorisParser) WorkloadPolicyConditions() (localctx IWorkloadPolicyConditionsContext) {
	localctx = NewWorkloadPolicyConditionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, DorisParserRULE_workloadPolicyConditions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2401)
		p.WorkloadPolicyCondition()
	}
	p.SetState(2406)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(2402)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2403)
			p.WorkloadPolicyCondition()
		}

		p.SetState(2408)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWorkloadPolicyConditionContext is an interface to support dynamic dispatch.
type IWorkloadPolicyConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMetricName returns the metricName rule contexts.
	GetMetricName() IIdentifierContext

	// SetMetricName sets the metricName rule contexts.
	SetMetricName(IIdentifierContext)

	// Getter signatures
	ComparisonOperator() IComparisonOperatorContext
	Identifier() IIdentifierContext
	Number() INumberContext
	STRING_LITERAL() antlr.TerminalNode

	// IsWorkloadPolicyConditionContext differentiates from other interfaces.
	IsWorkloadPolicyConditionContext()
}

type WorkloadPolicyConditionContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	metricName IIdentifierContext
}

func NewEmptyWorkloadPolicyConditionContext() *WorkloadPolicyConditionContext {
	var p = new(WorkloadPolicyConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_workloadPolicyCondition
	return p
}

func InitEmptyWorkloadPolicyConditionContext(p *WorkloadPolicyConditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_workloadPolicyCondition
}

func (*WorkloadPolicyConditionContext) IsWorkloadPolicyConditionContext() {}

func NewWorkloadPolicyConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WorkloadPolicyConditionContext {
	var p = new(WorkloadPolicyConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_workloadPolicyCondition

	return p
}

func (s *WorkloadPolicyConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *WorkloadPolicyConditionContext) GetMetricName() IIdentifierContext { return s.metricName }

func (s *WorkloadPolicyConditionContext) SetMetricName(v IIdentifierContext) { s.metricName = v }

func (s *WorkloadPolicyConditionContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *WorkloadPolicyConditionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WorkloadPolicyConditionContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *WorkloadPolicyConditionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *WorkloadPolicyConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WorkloadPolicyConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WorkloadPolicyConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWorkloadPolicyCondition(s)
	}
}

func (s *WorkloadPolicyConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWorkloadPolicyCondition(s)
	}
}

func (p *DorisParser) WorkloadPolicyCondition() (localctx IWorkloadPolicyConditionContext) {
	localctx = NewWorkloadPolicyConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, DorisParserRULE_workloadPolicyCondition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2409)

		var _x = p.Identifier()

		localctx.(*WorkloadPolicyConditionContext).metricName = _x
	}
	{
		p.SetState(2410)
		p.ComparisonOperator()
	}
	p.SetState(2413)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserSUBTRACT, DorisParserINTEGER_VALUE, DorisParserEXPONENT_VALUE, DorisParserDECIMAL_VALUE:
		{
			p.SetState(2411)
			p.Number()
		}

	case DorisParserSTRING_LITERAL:
		{
			p.SetState(2412)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStorageBackendContext is an interface to support dynamic dispatch.
type IStorageBackendContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBrokerName returns the brokerName rule contexts.
	GetBrokerName() IIdentifierContext

	// GetProperties returns the properties rule contexts.
	GetProperties() IPropertyClauseContext

	// SetBrokerName sets the brokerName rule contexts.
	SetBrokerName(IIdentifierContext)

	// SetProperties sets the properties rule contexts.
	SetProperties(IPropertyClauseContext)

	// Getter signatures
	ON() antlr.TerminalNode
	LOCATION() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	S3() antlr.TerminalNode
	HDFS() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	Identifier() IIdentifierContext
	PropertyClause() IPropertyClauseContext

	// IsStorageBackendContext differentiates from other interfaces.
	IsStorageBackendContext()
}

type StorageBackendContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	brokerName IIdentifierContext
	properties IPropertyClauseContext
}

func NewEmptyStorageBackendContext() *StorageBackendContext {
	var p = new(StorageBackendContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_storageBackend
	return p
}

func InitEmptyStorageBackendContext(p *StorageBackendContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_storageBackend
}

func (*StorageBackendContext) IsStorageBackendContext() {}

func NewStorageBackendContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StorageBackendContext {
	var p = new(StorageBackendContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_storageBackend

	return p
}

func (s *StorageBackendContext) GetParser() antlr.Parser { return s.parser }

func (s *StorageBackendContext) GetBrokerName() IIdentifierContext { return s.brokerName }

func (s *StorageBackendContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *StorageBackendContext) SetBrokerName(v IIdentifierContext) { s.brokerName = v }

func (s *StorageBackendContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *StorageBackendContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *StorageBackendContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCATION, 0)
}

func (s *StorageBackendContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *StorageBackendContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserBROKER, 0)
}

func (s *StorageBackendContext) S3() antlr.TerminalNode {
	return s.GetToken(DorisParserS3, 0)
}

func (s *StorageBackendContext) HDFS() antlr.TerminalNode {
	return s.GetToken(DorisParserHDFS, 0)
}

func (s *StorageBackendContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *StorageBackendContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StorageBackendContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *StorageBackendContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StorageBackendContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StorageBackendContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStorageBackend(s)
	}
}

func (s *StorageBackendContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStorageBackend(s)
	}
}

func (p *DorisParser) StorageBackend() (localctx IStorageBackendContext) {
	localctx = NewStorageBackendContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, DorisParserRULE_storageBackend)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2415)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserBROKER || _la == DorisParserHDFS || _la == DorisParserLOCAL || _la == DorisParserS3) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2417)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1153040409952344576) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&-53021438386753) != 0) || ((int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&3476586699635759401) != 0) || ((int64((_la-195)) & ^0x3f) == 0 && ((int64(1)<<(_la-195))&-3139048519776880011) != 0) || ((int64((_la-260)) & ^0x3f) == 0 && ((int64(1)<<(_la-260))&-4544906634320822477) != 0) || ((int64((_la-325)) & ^0x3f) == 0 && ((int64(1)<<(_la-325))&6339805778266808319) != 0) || ((int64((_la-390)) & ^0x3f) == 0 && ((int64(1)<<(_la-390))&-656945004016972825) != 0) || ((int64((_la-456)) & ^0x3f) == 0 && ((int64(1)<<(_la-456))&18760394443469) != 0) || ((int64((_la-522)) & ^0x3f) == 0 && ((int64(1)<<(_la-522))&49159) != 0) {
		{
			p.SetState(2416)

			var _x = p.Identifier()

			localctx.(*StorageBackendContext).brokerName = _x
		}

	}
	{
		p.SetState(2419)
		p.Match(DorisParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2420)
		p.Match(DorisParserLOCATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2421)
		p.Match(DorisParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2423)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPROPERTIES {
		{
			p.SetState(2422)

			var _x = p.PropertyClause()

			localctx.(*StorageBackendContext).properties = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPasswordOptionContext is an interface to support dynamic dispatch.
type IPasswordOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetHistoryDefault returns the historyDefault token.
	GetHistoryDefault() antlr.Token

	// GetHistoryValue returns the historyValue token.
	GetHistoryValue() antlr.Token

	// GetExpireDefault returns the expireDefault token.
	GetExpireDefault() antlr.Token

	// GetExpireNever returns the expireNever token.
	GetExpireNever() antlr.Token

	// GetExpireValue returns the expireValue token.
	GetExpireValue() antlr.Token

	// GetExpireTimeUnit returns the expireTimeUnit token.
	GetExpireTimeUnit() antlr.Token

	// GetReuseDefault returns the reuseDefault token.
	GetReuseDefault() antlr.Token

	// GetReuseValue returns the reuseValue token.
	GetReuseValue() antlr.Token

	// GetAttemptsValue returns the attemptsValue token.
	GetAttemptsValue() antlr.Token

	// GetLockUnbounded returns the lockUnbounded token.
	GetLockUnbounded() antlr.Token

	// GetLockValue returns the lockValue token.
	GetLockValue() antlr.Token

	// GetLockTimeUint returns the lockTimeUint token.
	GetLockTimeUint() antlr.Token

	// SetHistoryDefault sets the historyDefault token.
	SetHistoryDefault(antlr.Token)

	// SetHistoryValue sets the historyValue token.
	SetHistoryValue(antlr.Token)

	// SetExpireDefault sets the expireDefault token.
	SetExpireDefault(antlr.Token)

	// SetExpireNever sets the expireNever token.
	SetExpireNever(antlr.Token)

	// SetExpireValue sets the expireValue token.
	SetExpireValue(antlr.Token)

	// SetExpireTimeUnit sets the expireTimeUnit token.
	SetExpireTimeUnit(antlr.Token)

	// SetReuseDefault sets the reuseDefault token.
	SetReuseDefault(antlr.Token)

	// SetReuseValue sets the reuseValue token.
	SetReuseValue(antlr.Token)

	// SetAttemptsValue sets the attemptsValue token.
	SetAttemptsValue(antlr.Token)

	// SetLockUnbounded sets the lockUnbounded token.
	SetLockUnbounded(antlr.Token)

	// SetLockValue sets the lockValue token.
	SetLockValue(antlr.Token)

	// SetLockTimeUint sets the lockTimeUint token.
	SetLockTimeUint(antlr.Token)

	// Getter signatures
	PASSWORD_HISTORY() antlr.TerminalNode
	PASSWORD_EXPIRE() antlr.TerminalNode
	PASSWORD_REUSE() antlr.TerminalNode
	AllINTERVAL() []antlr.TerminalNode
	INTERVAL(i int) antlr.TerminalNode
	FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode
	PASSWORD_LOCK_TIME() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	ACCOUNT_LOCK() antlr.TerminalNode
	ACCOUNT_UNLOCK() antlr.TerminalNode
	AllDAY() []antlr.TerminalNode
	DAY(i int) antlr.TerminalNode
	AllDEFAULT() []antlr.TerminalNode
	DEFAULT(i int) antlr.TerminalNode
	NEVER() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	AllHOUR() []antlr.TerminalNode
	HOUR(i int) antlr.TerminalNode
	AllSECOND() []antlr.TerminalNode
	SECOND(i int) antlr.TerminalNode

	// IsPasswordOptionContext differentiates from other interfaces.
	IsPasswordOptionContext()
}

type PasswordOptionContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	historyDefault antlr.Token
	historyValue   antlr.Token
	expireDefault  antlr.Token
	expireNever    antlr.Token
	expireValue    antlr.Token
	expireTimeUnit antlr.Token
	reuseDefault   antlr.Token
	reuseValue     antlr.Token
	attemptsValue  antlr.Token
	lockUnbounded  antlr.Token
	lockValue      antlr.Token
	lockTimeUint   antlr.Token
}

func NewEmptyPasswordOptionContext() *PasswordOptionContext {
	var p = new(PasswordOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_passwordOption
	return p
}

func InitEmptyPasswordOptionContext(p *PasswordOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_passwordOption
}

func (*PasswordOptionContext) IsPasswordOptionContext() {}

func NewPasswordOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PasswordOptionContext {
	var p = new(PasswordOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_passwordOption

	return p
}

func (s *PasswordOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *PasswordOptionContext) GetHistoryDefault() antlr.Token { return s.historyDefault }

func (s *PasswordOptionContext) GetHistoryValue() antlr.Token { return s.historyValue }

func (s *PasswordOptionContext) GetExpireDefault() antlr.Token { return s.expireDefault }

func (s *PasswordOptionContext) GetExpireNever() antlr.Token { return s.expireNever }

func (s *PasswordOptionContext) GetExpireValue() antlr.Token { return s.expireValue }

func (s *PasswordOptionContext) GetExpireTimeUnit() antlr.Token { return s.expireTimeUnit }

func (s *PasswordOptionContext) GetReuseDefault() antlr.Token { return s.reuseDefault }

func (s *PasswordOptionContext) GetReuseValue() antlr.Token { return s.reuseValue }

func (s *PasswordOptionContext) GetAttemptsValue() antlr.Token { return s.attemptsValue }

func (s *PasswordOptionContext) GetLockUnbounded() antlr.Token { return s.lockUnbounded }

func (s *PasswordOptionContext) GetLockValue() antlr.Token { return s.lockValue }

func (s *PasswordOptionContext) GetLockTimeUint() antlr.Token { return s.lockTimeUint }

func (s *PasswordOptionContext) SetHistoryDefault(v antlr.Token) { s.historyDefault = v }

func (s *PasswordOptionContext) SetHistoryValue(v antlr.Token) { s.historyValue = v }

func (s *PasswordOptionContext) SetExpireDefault(v antlr.Token) { s.expireDefault = v }

func (s *PasswordOptionContext) SetExpireNever(v antlr.Token) { s.expireNever = v }

func (s *PasswordOptionContext) SetExpireValue(v antlr.Token) { s.expireValue = v }

func (s *PasswordOptionContext) SetExpireTimeUnit(v antlr.Token) { s.expireTimeUnit = v }

func (s *PasswordOptionContext) SetReuseDefault(v antlr.Token) { s.reuseDefault = v }

func (s *PasswordOptionContext) SetReuseValue(v antlr.Token) { s.reuseValue = v }

func (s *PasswordOptionContext) SetAttemptsValue(v antlr.Token) { s.attemptsValue = v }

func (s *PasswordOptionContext) SetLockUnbounded(v antlr.Token) { s.lockUnbounded = v }

func (s *PasswordOptionContext) SetLockValue(v antlr.Token) { s.lockValue = v }

func (s *PasswordOptionContext) SetLockTimeUint(v antlr.Token) { s.lockTimeUint = v }

func (s *PasswordOptionContext) PASSWORD_HISTORY() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD_HISTORY, 0)
}

func (s *PasswordOptionContext) PASSWORD_EXPIRE() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD_EXPIRE, 0)
}

func (s *PasswordOptionContext) PASSWORD_REUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD_REUSE, 0)
}

func (s *PasswordOptionContext) AllINTERVAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserINTERVAL)
}

func (s *PasswordOptionContext) INTERVAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserINTERVAL, i)
}

func (s *PasswordOptionContext) FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode {
	return s.GetToken(DorisParserFAILED_LOGIN_ATTEMPTS, 0)
}

func (s *PasswordOptionContext) PASSWORD_LOCK_TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD_LOCK_TIME, 0)
}

func (s *PasswordOptionContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserINTEGER_VALUE)
}

func (s *PasswordOptionContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, i)
}

func (s *PasswordOptionContext) ACCOUNT_LOCK() antlr.TerminalNode {
	return s.GetToken(DorisParserACCOUNT_LOCK, 0)
}

func (s *PasswordOptionContext) ACCOUNT_UNLOCK() antlr.TerminalNode {
	return s.GetToken(DorisParserACCOUNT_UNLOCK, 0)
}

func (s *PasswordOptionContext) AllDAY() []antlr.TerminalNode {
	return s.GetTokens(DorisParserDAY)
}

func (s *PasswordOptionContext) DAY(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserDAY, i)
}

func (s *PasswordOptionContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(DorisParserDEFAULT)
}

func (s *PasswordOptionContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, i)
}

func (s *PasswordOptionContext) NEVER() antlr.TerminalNode {
	return s.GetToken(DorisParserNEVER, 0)
}

func (s *PasswordOptionContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(DorisParserUNBOUNDED, 0)
}

func (s *PasswordOptionContext) AllHOUR() []antlr.TerminalNode {
	return s.GetTokens(DorisParserHOUR)
}

func (s *PasswordOptionContext) HOUR(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserHOUR, i)
}

func (s *PasswordOptionContext) AllSECOND() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSECOND)
}

func (s *PasswordOptionContext) SECOND(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSECOND, i)
}

func (s *PasswordOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PasswordOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPasswordOption(s)
	}
}

func (s *PasswordOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPasswordOption(s)
	}
}

func (p *DorisParser) PasswordOption() (localctx IPasswordOptionContext) {
	localctx = NewPasswordOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, DorisParserRULE_passwordOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2430)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPASSWORD_HISTORY {
		{
			p.SetState(2425)
			p.Match(DorisParserPASSWORD_HISTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2428)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserDEFAULT:
			{
				p.SetState(2426)

				var _m = p.Match(DorisParserDEFAULT)

				localctx.(*PasswordOptionContext).historyDefault = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserINTEGER_VALUE:
			{
				p.SetState(2427)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*PasswordOptionContext).historyValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(2440)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPASSWORD_EXPIRE {
		{
			p.SetState(2432)
			p.Match(DorisParserPASSWORD_EXPIRE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2438)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserDEFAULT:
			{
				p.SetState(2433)

				var _m = p.Match(DorisParserDEFAULT)

				localctx.(*PasswordOptionContext).expireDefault = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserNEVER:
			{
				p.SetState(2434)

				var _m = p.Match(DorisParserNEVER)

				localctx.(*PasswordOptionContext).expireNever = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserINTERVAL:
			{
				p.SetState(2435)
				p.Match(DorisParserINTERVAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2436)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*PasswordOptionContext).expireValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2437)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*PasswordOptionContext).expireTimeUnit = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserDAY || _la == DorisParserHOUR || _la == DorisParserSECOND) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*PasswordOptionContext).expireTimeUnit = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(2449)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPASSWORD_REUSE {
		{
			p.SetState(2442)
			p.Match(DorisParserPASSWORD_REUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2443)
			p.Match(DorisParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2447)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserDEFAULT:
			{
				p.SetState(2444)

				var _m = p.Match(DorisParserDEFAULT)

				localctx.(*PasswordOptionContext).reuseDefault = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserINTEGER_VALUE:
			{
				p.SetState(2445)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*PasswordOptionContext).reuseValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2446)
				p.Match(DorisParserDAY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(2453)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserFAILED_LOGIN_ATTEMPTS {
		{
			p.SetState(2451)
			p.Match(DorisParserFAILED_LOGIN_ATTEMPTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2452)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*PasswordOptionContext).attemptsValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2461)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPASSWORD_LOCK_TIME {
		{
			p.SetState(2455)
			p.Match(DorisParserPASSWORD_LOCK_TIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2459)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserUNBOUNDED:
			{
				p.SetState(2456)

				var _m = p.Match(DorisParserUNBOUNDED)

				localctx.(*PasswordOptionContext).lockUnbounded = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserINTEGER_VALUE:
			{
				p.SetState(2457)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*PasswordOptionContext).lockValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2458)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*PasswordOptionContext).lockTimeUint = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserDAY || _la == DorisParserHOUR || _la == DorisParserSECOND) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*PasswordOptionContext).lockTimeUint = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(2464)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserACCOUNT_LOCK || _la == DorisParserACCOUNT_UNLOCK {
		{
			p.SetState(2463)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserACCOUNT_LOCK || _la == DorisParserACCOUNT_UNLOCK) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionArgumentsContext is an interface to support dynamic dispatch.
type IFunctionArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFunctionArgument() []IFunctionArgumentContext
	FunctionArgument(i int) IFunctionArgumentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFunctionArgumentsContext differentiates from other interfaces.
	IsFunctionArgumentsContext()
}

type FunctionArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionArgumentsContext() *FunctionArgumentsContext {
	var p = new(FunctionArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionArguments
	return p
}

func InitEmptyFunctionArgumentsContext(p *FunctionArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionArguments
}

func (*FunctionArgumentsContext) IsFunctionArgumentsContext() {}

func NewFunctionArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgumentsContext {
	var p = new(FunctionArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_functionArguments

	return p
}

func (s *FunctionArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgumentsContext) AllFunctionArgument() []IFunctionArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionArgumentContext); ok {
			len++
		}
	}

	tst := make([]IFunctionArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionArgumentContext); ok {
			tst[i] = t.(IFunctionArgumentContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgumentsContext) FunctionArgument(i int) IFunctionArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgumentContext)
}

func (s *FunctionArgumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *FunctionArgumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *FunctionArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFunctionArguments(s)
	}
}

func (s *FunctionArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFunctionArguments(s)
	}
}

func (p *DorisParser) FunctionArguments() (localctx IFunctionArgumentsContext) {
	localctx = NewFunctionArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, DorisParserRULE_functionArguments)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2466)
		p.FunctionArgument()
	}
	p.SetState(2471)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(2467)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2468)
			p.FunctionArgument()
		}

		p.SetState(2473)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionArgumentContext is an interface to support dynamic dispatch.
type IFunctionArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOTDOTDOT() antlr.TerminalNode
	DataType() IDataTypeContext

	// IsFunctionArgumentContext differentiates from other interfaces.
	IsFunctionArgumentContext()
}

type FunctionArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionArgumentContext() *FunctionArgumentContext {
	var p = new(FunctionArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionArgument
	return p
}

func InitEmptyFunctionArgumentContext(p *FunctionArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionArgument
}

func (*FunctionArgumentContext) IsFunctionArgumentContext() {}

func NewFunctionArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgumentContext {
	var p = new(FunctionArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_functionArgument

	return p
}

func (s *FunctionArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgumentContext) DOTDOTDOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOTDOTDOT, 0)
}

func (s *FunctionArgumentContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *FunctionArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFunctionArgument(s)
	}
}

func (s *FunctionArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFunctionArgument(s)
	}
}

func (p *DorisParser) FunctionArgument() (localctx IFunctionArgumentContext) {
	localctx = NewFunctionArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, DorisParserRULE_functionArgument)
	p.SetState(2476)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserDOTDOTDOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2474)
			p.Match(DorisParserDOTDOTDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserAGG_STATE, DorisParserALL, DorisParserARRAY, DorisParserBIGINT, DorisParserBITMAP, DorisParserBOOLEAN, DorisParserCHAR, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDOUBLE, DorisParserFLOAT, DorisParserHLL, DorisParserINT, DorisParserINTEGER, DorisParserIPV4, DorisParserIPV6, DorisParserJSON, DorisParserJSONB, DorisParserLARGEINT, DorisParserMAP, DorisParserQUANTILE_STATE, DorisParserSMALLINT, DorisParserSTRING, DorisParserSTRUCT, DorisParserTEXT, DorisParserTIME, DorisParserTINYINT, DorisParserVARCHAR, DorisParserVARIANT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2475)
			p.DataType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedSetStatementContext is an interface to support dynamic dispatch.
type IUnsupportedSetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedSetStatementContext differentiates from other interfaces.
	IsUnsupportedSetStatementContext()
}

type UnsupportedSetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedSetStatementContext() *UnsupportedSetStatementContext {
	var p = new(UnsupportedSetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedSetStatement
	return p
}

func InitEmptyUnsupportedSetStatementContext(p *UnsupportedSetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedSetStatement
}

func (*UnsupportedSetStatementContext) IsUnsupportedSetStatementContext() {}

func NewUnsupportedSetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedSetStatementContext {
	var p = new(UnsupportedSetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedSetStatement

	return p
}

func (s *UnsupportedSetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedSetStatementContext) CopyAll(ctx *UnsupportedSetStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedSetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedSetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SetTransactionContext struct {
	UnsupportedSetStatementContext
}

func NewSetTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetTransactionContext {
	var p = new(SetTransactionContext)

	InitEmptyUnsupportedSetStatementContext(&p.UnsupportedSetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedSetStatementContext))

	return p
}

func (s *SetTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTransactionContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *SetTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisParserTRANSACTION, 0)
}

func (s *SetTransactionContext) TransactionAccessMode() ITransactionAccessModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionAccessModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionAccessModeContext)
}

func (s *SetTransactionContext) IsolationLevel() IIsolationLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsolationLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsolationLevelContext)
}

func (s *SetTransactionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, 0)
}

func (s *SetTransactionContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *SetTransactionContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *SetTransactionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION, 0)
}

func (s *SetTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetTransaction(s)
	}
}

func (s *SetTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetTransaction(s)
	}
}

type SetUserPropertiesContext struct {
	UnsupportedSetStatementContext
	user IIdentifierOrTextContext
}

func NewSetUserPropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetUserPropertiesContext {
	var p = new(SetUserPropertiesContext)

	InitEmptyUnsupportedSetStatementContext(&p.UnsupportedSetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedSetStatementContext))

	return p
}

func (s *SetUserPropertiesContext) GetUser() IIdentifierOrTextContext { return s.user }

func (s *SetUserPropertiesContext) SetUser(v IIdentifierOrTextContext) { s.user = v }

func (s *SetUserPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetUserPropertiesContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *SetUserPropertiesContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTY, 0)
}

func (s *SetUserPropertiesContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *SetUserPropertiesContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *SetUserPropertiesContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *SetUserPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetUserProperties(s)
	}
}

func (s *SetUserPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetUserProperties(s)
	}
}

type SetDefaultStorageVaultContext struct {
	UnsupportedSetStatementContext
}

func NewSetDefaultStorageVaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetDefaultStorageVaultContext {
	var p = new(SetDefaultStorageVaultContext)

	InitEmptyUnsupportedSetStatementContext(&p.UnsupportedSetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedSetStatementContext))

	return p
}

func (s *SetDefaultStorageVaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetDefaultStorageVaultContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *SetDefaultStorageVaultContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetDefaultStorageVaultContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *SetDefaultStorageVaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *SetDefaultStorageVaultContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *SetDefaultStorageVaultContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULT, 0)
}

func (s *SetDefaultStorageVaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetDefaultStorageVault(s)
	}
}

func (s *SetDefaultStorageVaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetDefaultStorageVault(s)
	}
}

type SetOptionsContext struct {
	UnsupportedSetStatementContext
}

func NewSetOptionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetOptionsContext {
	var p = new(SetOptionsContext)

	InitEmptyUnsupportedSetStatementContext(&p.UnsupportedSetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedSetStatementContext))

	return p
}

func (s *SetOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOptionsContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *SetOptionsContext) AllOptionWithType() []IOptionWithTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOptionWithTypeContext); ok {
			len++
		}
	}

	tst := make([]IOptionWithTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOptionWithTypeContext); ok {
			tst[i] = t.(IOptionWithTypeContext)
			i++
		}
	}

	return tst
}

func (s *SetOptionsContext) OptionWithType(i int) IOptionWithTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionWithTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionWithTypeContext)
}

func (s *SetOptionsContext) AllOptionWithoutType() []IOptionWithoutTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOptionWithoutTypeContext); ok {
			len++
		}
	}

	tst := make([]IOptionWithoutTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOptionWithoutTypeContext); ok {
			tst[i] = t.(IOptionWithoutTypeContext)
			i++
		}
	}

	return tst
}

func (s *SetOptionsContext) OptionWithoutType(i int) IOptionWithoutTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionWithoutTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionWithoutTypeContext)
}

func (s *SetOptionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *SetOptionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *SetOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetOptions(s)
	}
}

func (s *SetOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetOptions(s)
	}
}

func (p *DorisParser) UnsupportedSetStatement() (localctx IUnsupportedSetStatementContext) {
	localctx = NewUnsupportedSetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, DorisParserRULE_unsupportedSetStatement)
	var _la int

	p.SetState(2524)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 329, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSetOptionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2478)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2481)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 323, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2479)
				p.OptionWithType()
			}

		case 2:
			{
				p.SetState(2480)
				p.OptionWithoutType()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(2490)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(2483)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2486)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 324, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(2484)
					p.OptionWithType()
				}

			case 2:
				{
					p.SetState(2485)
					p.OptionWithoutType()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

			p.SetState(2492)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewSetDefaultStorageVaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2493)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2494)
			p.Identifier()
		}
		{
			p.SetState(2495)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2496)
			p.Match(DorisParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2497)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2498)
			p.Match(DorisParserVAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewSetUserPropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2500)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2501)
			p.Match(DorisParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2504)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFOR {
			{
				p.SetState(2502)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2503)

				var _x = p.IdentifierOrText()

				localctx.(*SetUserPropertiesContext).user = _x
			}

		}
		{
			p.SetState(2506)
			p.PropertyItemList()
		}

	case 4:
		localctx = NewSetTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2507)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2509)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION {
			{
				p.SetState(2508)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(2511)
			p.Match(DorisParserTRANSACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2522)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 328, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2512)
				p.TransactionAccessMode()
			}

		case 2:
			{
				p.SetState(2513)
				p.IsolationLevel()
			}

		case 3:
			{
				p.SetState(2514)
				p.TransactionAccessMode()
			}
			{
				p.SetState(2515)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2516)
				p.IsolationLevel()
			}

		case 4:
			{
				p.SetState(2518)
				p.IsolationLevel()
			}
			{
				p.SetState(2519)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2520)
				p.TransactionAccessMode()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionWithTypeContext is an interface to support dynamic dispatch.
type IOptionWithTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQ() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	Expression() IExpressionContext
	DEFAULT() antlr.TerminalNode

	// IsOptionWithTypeContext differentiates from other interfaces.
	IsOptionWithTypeContext()
}

type OptionWithTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionWithTypeContext() *OptionWithTypeContext {
	var p = new(OptionWithTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_optionWithType
	return p
}

func InitEmptyOptionWithTypeContext(p *OptionWithTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_optionWithType
}

func (*OptionWithTypeContext) IsOptionWithTypeContext() {}

func NewOptionWithTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionWithTypeContext {
	var p = new(OptionWithTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_optionWithType

	return p
}

func (s *OptionWithTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionWithTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *OptionWithTypeContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *OptionWithTypeContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *OptionWithTypeContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *OptionWithTypeContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION, 0)
}

func (s *OptionWithTypeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OptionWithTypeContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *OptionWithTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionWithTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionWithTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterOptionWithType(s)
	}
}

func (s *OptionWithTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitOptionWithType(s)
	}
}

func (p *DorisParser) OptionWithType() (localctx IOptionWithTypeContext) {
	localctx = NewOptionWithTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, DorisParserRULE_optionWithType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2526)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2527)
		p.Identifier()
	}
	{
		p.SetState(2528)
		p.Match(DorisParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2531)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_PAREN, DorisParserLEFT_BRACKET, DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADD, DorisParserADDDATE, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserARRAY_RANGE, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBINARY, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCASE, DorisParserCAST, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATABASE, DorisParserDATE, DorisParserDATE_ADD, DorisParserDATE_CEIL, DorisParserDATE_DIFF, DorisParserDATE_FLOOR, DorisParserDATE_SUB, DorisParserDATEADD, DorisParserDATEDIFF, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS_ADD, DorisParserDAYS_SUB, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXISTS, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserEXTRACT, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFALSE, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIF, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINTERVAL, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserKEY, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLEFT, DorisParserLESS, DorisParserLEVEL, DorisParserLIKE, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNOT, DorisParserNULL, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLACEHOLDER, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREGEXP, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRIGHT, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSEQUENCE, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUBDATE, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTIMESTAMPADD, DorisParserTIMESTAMPDIFF, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRIM, DorisParserTRUE, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserPLUS, DorisParserSUBTRACT, DorisParserASTERISK, DorisParserTILDE, DorisParserLOGICALNOT, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserATSIGN, DorisParserDOUBLEATSIGN, DorisParserSTRING_LITERAL, DorisParserINTEGER_VALUE, DorisParserEXPONENT_VALUE, DorisParserDECIMAL_VALUE, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		{
			p.SetState(2529)
			p.Expression()
		}

	case DorisParserDEFAULT:
		{
			p.SetState(2530)
			p.Match(DorisParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionWithoutTypeContext is an interface to support dynamic dispatch.
type IOptionWithoutTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsOptionWithoutTypeContext differentiates from other interfaces.
	IsOptionWithoutTypeContext()
}

type OptionWithoutTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionWithoutTypeContext() *OptionWithoutTypeContext {
	var p = new(OptionWithoutTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_optionWithoutType
	return p
}

func InitEmptyOptionWithoutTypeContext(p *OptionWithoutTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_optionWithoutType
}

func (*OptionWithoutTypeContext) IsOptionWithoutTypeContext() {}

func NewOptionWithoutTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionWithoutTypeContext {
	var p = new(OptionWithoutTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_optionWithoutType

	return p
}

func (s *OptionWithoutTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionWithoutTypeContext) CopyAll(ctx *OptionWithoutTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *OptionWithoutTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionWithoutTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SetNamesContext struct {
	OptionWithoutTypeContext
}

func NewSetNamesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetNamesContext {
	var p = new(SetNamesContext)

	InitEmptyOptionWithoutTypeContext(&p.OptionWithoutTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithoutTypeContext))

	return p
}

func (s *SetNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetNamesContext) NAMES() antlr.TerminalNode {
	return s.GetToken(DorisParserNAMES, 0)
}

func (s *SetNamesContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *SetNamesContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetNames(s)
	}
}

func (s *SetNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetNames(s)
	}
}

type SetCharsetContext struct {
	OptionWithoutTypeContext
	charsetName IIdentifierOrTextContext
}

func NewSetCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetCharsetContext {
	var p = new(SetCharsetContext)

	InitEmptyOptionWithoutTypeContext(&p.OptionWithoutTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithoutTypeContext))

	return p
}

func (s *SetCharsetContext) GetCharsetName() IIdentifierOrTextContext { return s.charsetName }

func (s *SetCharsetContext) SetCharsetName(v IIdentifierOrTextContext) { s.charsetName = v }

func (s *SetCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetCharsetContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserCHAR, 0)
}

func (s *SetCharsetContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *SetCharsetContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(DorisParserCHARSET, 0)
}

func (s *SetCharsetContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *SetCharsetContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *SetCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetCharset(s)
	}
}

func (s *SetCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetCharset(s)
	}
}

type SetCollateContext struct {
	OptionWithoutTypeContext
	charsetName IIdentifierOrTextContext
	collateName IIdentifierOrTextContext
}

func NewSetCollateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetCollateContext {
	var p = new(SetCollateContext)

	InitEmptyOptionWithoutTypeContext(&p.OptionWithoutTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithoutTypeContext))

	return p
}

func (s *SetCollateContext) GetCharsetName() IIdentifierOrTextContext { return s.charsetName }

func (s *SetCollateContext) GetCollateName() IIdentifierOrTextContext { return s.collateName }

func (s *SetCollateContext) SetCharsetName(v IIdentifierOrTextContext) { s.charsetName = v }

func (s *SetCollateContext) SetCollateName(v IIdentifierOrTextContext) { s.collateName = v }

func (s *SetCollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetCollateContext) NAMES() antlr.TerminalNode {
	return s.GetToken(DorisParserNAMES, 0)
}

func (s *SetCollateContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(DorisParserDEFAULT)
}

func (s *SetCollateContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, i)
}

func (s *SetCollateContext) AllIdentifierOrText() []IIdentifierOrTextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrTextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrTextContext); ok {
			tst[i] = t.(IIdentifierOrTextContext)
			i++
		}
	}

	return tst
}

func (s *SetCollateContext) IdentifierOrText(i int) IIdentifierOrTextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *SetCollateContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLLATE, 0)
}

func (s *SetCollateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetCollate(s)
	}
}

func (s *SetCollateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetCollate(s)
	}
}

type SetPasswordContext struct {
	OptionWithoutTypeContext
}

func NewSetPasswordContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetPasswordContext {
	var p = new(SetPasswordContext)

	InitEmptyOptionWithoutTypeContext(&p.OptionWithoutTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithoutTypeContext))

	return p
}

func (s *SetPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetPasswordContext) AllPASSWORD() []antlr.TerminalNode {
	return s.GetTokens(DorisParserPASSWORD)
}

func (s *SetPasswordContext) PASSWORD(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD, i)
}

func (s *SetPasswordContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *SetPasswordContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *SetPasswordContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *SetPasswordContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *SetPasswordContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *SetPasswordContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *SetPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetPassword(s)
	}
}

func (s *SetPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetPassword(s)
	}
}

type SetVariableWithoutTypeContext struct {
	OptionWithoutTypeContext
}

func NewSetVariableWithoutTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetVariableWithoutTypeContext {
	var p = new(SetVariableWithoutTypeContext)

	InitEmptyOptionWithoutTypeContext(&p.OptionWithoutTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithoutTypeContext))

	return p
}

func (s *SetVariableWithoutTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetVariableWithoutTypeContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *SetVariableWithoutTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetVariableWithoutType(s)
	}
}

func (s *SetVariableWithoutTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetVariableWithoutType(s)
	}
}

type SetLdapAdminPasswordContext struct {
	OptionWithoutTypeContext
}

func NewSetLdapAdminPasswordContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetLdapAdminPasswordContext {
	var p = new(SetLdapAdminPasswordContext)

	InitEmptyOptionWithoutTypeContext(&p.OptionWithoutTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithoutTypeContext))

	return p
}

func (s *SetLdapAdminPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetLdapAdminPasswordContext) LDAP_ADMIN_PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisParserLDAP_ADMIN_PASSWORD, 0)
}

func (s *SetLdapAdminPasswordContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *SetLdapAdminPasswordContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *SetLdapAdminPasswordContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD, 0)
}

func (s *SetLdapAdminPasswordContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *SetLdapAdminPasswordContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *SetLdapAdminPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetLdapAdminPassword(s)
	}
}

func (s *SetLdapAdminPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetLdapAdminPassword(s)
	}
}

func (p *DorisParser) OptionWithoutType() (localctx IOptionWithoutTypeContext) {
	localctx = NewOptionWithoutTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, DorisParserRULE_optionWithoutType)
	var _la int

	p.SetState(2578)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 338, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSetNamesContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2533)
			p.Match(DorisParserNAMES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2534)
			p.Match(DorisParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2535)
			p.Expression()
		}

	case 2:
		localctx = NewSetCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2539)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserCHAR:
			{
				p.SetState(2536)
				p.Match(DorisParserCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2537)
				p.Match(DorisParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCHARSET:
			{
				p.SetState(2538)
				p.Match(DorisParserCHARSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(2543)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADDDATE, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserARRAY_RANGE, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATE_ADD, DorisParserDATE_CEIL, DorisParserDATE_DIFF, DorisParserDATE_FLOOR, DorisParserDATE_SUB, DorisParserDATEADD, DorisParserDATEDIFF, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS_ADD, DorisParserDAYS_SUB, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSEQUENCE, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUBDATE, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTIMESTAMPADD, DorisParserTIMESTAMPDIFF, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(2541)

				var _x = p.IdentifierOrText()

				localctx.(*SetCharsetContext).charsetName = _x
			}

		case DorisParserDEFAULT:
			{
				p.SetState(2542)
				p.Match(DorisParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		localctx = NewSetCollateContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2545)
			p.Match(DorisParserNAMES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2548)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADDDATE, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserARRAY_RANGE, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATE_ADD, DorisParserDATE_CEIL, DorisParserDATE_DIFF, DorisParserDATE_FLOOR, DorisParserDATE_SUB, DorisParserDATEADD, DorisParserDATEDIFF, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS_ADD, DorisParserDAYS_SUB, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSEQUENCE, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUBDATE, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTIMESTAMPADD, DorisParserTIMESTAMPDIFF, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(2546)

				var _x = p.IdentifierOrText()

				localctx.(*SetCollateContext).charsetName = _x
			}

		case DorisParserDEFAULT:
			{
				p.SetState(2547)
				p.Match(DorisParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(2553)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case DorisParserCOLLATE:
			{
				p.SetState(2550)
				p.Match(DorisParserCOLLATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2551)

				var _x = p.IdentifierOrText()

				localctx.(*SetCollateContext).collateName = _x
			}

		case DorisParserDEFAULT:
			{
				p.SetState(2552)
				p.Match(DorisParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserEOF, DorisParserSEMICOLON, DorisParserCOMMA:

		default:
		}

	case 4:
		localctx = NewSetPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2555)
			p.Match(DorisParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2558)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFOR {
			{
				p.SetState(2556)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2557)
				p.UserIdentify()
			}

		}
		{
			p.SetState(2560)
			p.Match(DorisParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2566)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserSTRING_LITERAL:
			{
				p.SetState(2561)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserPASSWORD:
			{
				p.SetState(2562)
				p.Match(DorisParserPASSWORD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2563)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2564)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2565)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 5:
		localctx = NewSetLdapAdminPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2568)
			p.Match(DorisParserLDAP_ADMIN_PASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2569)
			p.Match(DorisParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2575)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserSTRING_LITERAL:
			{
				p.SetState(2570)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserPASSWORD:
			{
				p.SetState(2571)
				p.Match(DorisParserPASSWORD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2572)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2573)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2574)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 6:
		localctx = NewSetVariableWithoutTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2577)
			p.Variable()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableContext is an interface to support dynamic dispatch.
type IVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsVariableContext differentiates from other interfaces.
	IsVariableContext()
}

type VariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableContext() *VariableContext {
	var p = new(VariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_variable
	return p
}

func InitEmptyVariableContext(p *VariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_variable
}

func (*VariableContext) IsVariableContext() {}

func NewVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableContext {
	var p = new(VariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_variable

	return p
}

func (s *VariableContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableContext) CopyAll(ctx *VariableContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *VariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SetUserVariableContext struct {
	VariableContext
}

func NewSetUserVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetUserVariableContext {
	var p = new(SetUserVariableContext)

	InitEmptyVariableContext(&p.VariableContext)
	p.parser = parser
	p.CopyAll(ctx.(*VariableContext))

	return p
}

func (s *SetUserVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetUserVariableContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserATSIGN, 0)
}

func (s *SetUserVariableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetUserVariableContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *SetUserVariableContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetUserVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetUserVariable(s)
	}
}

func (s *SetUserVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetUserVariable(s)
	}
}

type SetSystemVariableContext struct {
	VariableContext
}

func NewSetSystemVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetSystemVariableContext {
	var p = new(SetSystemVariableContext)

	InitEmptyVariableContext(&p.VariableContext)
	p.parser = parser
	p.CopyAll(ctx.(*VariableContext))

	return p
}

func (s *SetSystemVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetSystemVariableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetSystemVariableContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *SetSystemVariableContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetSystemVariableContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *SetSystemVariableContext) DOUBLEATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserDOUBLEATSIGN, 0)
}

func (s *SetSystemVariableContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *SetSystemVariableContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *SetSystemVariableContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *SetSystemVariableContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION, 0)
}

func (s *SetSystemVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetSystemVariable(s)
	}
}

func (s *SetSystemVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetSystemVariable(s)
	}
}

func (p *DorisParser) Variable() (localctx IVariableContext) {
	localctx = NewVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, DorisParserRULE_variable)
	var _la int

	p.SetState(2598)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADDDATE, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserARRAY_RANGE, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATE_ADD, DorisParserDATE_CEIL, DorisParserDATE_DIFF, DorisParserDATE_FLOOR, DorisParserDATE_SUB, DorisParserDATEADD, DorisParserDATEDIFF, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS_ADD, DorisParserDAYS_SUB, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSEQUENCE, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUBDATE, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTIMESTAMPADD, DorisParserTIMESTAMPDIFF, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserDOUBLEATSIGN, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		localctx = NewSetSystemVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2585)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserDOUBLEATSIGN {
			{
				p.SetState(2580)
				p.Match(DorisParserDOUBLEATSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2583)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 339, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2581)
					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(2582)
					p.Match(DorisParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}
		{
			p.SetState(2587)
			p.Identifier()
		}
		{
			p.SetState(2588)
			p.Match(DorisParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2591)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_PAREN, DorisParserLEFT_BRACKET, DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADD, DorisParserADDDATE, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserARRAY_RANGE, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBINARY, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCASE, DorisParserCAST, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATABASE, DorisParserDATE, DorisParserDATE_ADD, DorisParserDATE_CEIL, DorisParserDATE_DIFF, DorisParserDATE_FLOOR, DorisParserDATE_SUB, DorisParserDATEADD, DorisParserDATEDIFF, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS_ADD, DorisParserDAYS_SUB, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXISTS, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserEXTRACT, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFALSE, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIF, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINTERVAL, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserKEY, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLEFT, DorisParserLESS, DorisParserLEVEL, DorisParserLIKE, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNOT, DorisParserNULL, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLACEHOLDER, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREGEXP, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRIGHT, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSEQUENCE, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUBDATE, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTIMESTAMPADD, DorisParserTIMESTAMPDIFF, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRIM, DorisParserTRUE, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserPLUS, DorisParserSUBTRACT, DorisParserASTERISK, DorisParserTILDE, DorisParserLOGICALNOT, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserATSIGN, DorisParserDOUBLEATSIGN, DorisParserSTRING_LITERAL, DorisParserINTEGER_VALUE, DorisParserEXPONENT_VALUE, DorisParserDECIMAL_VALUE, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(2589)
				p.Expression()
			}

		case DorisParserDEFAULT:
			{
				p.SetState(2590)
				p.Match(DorisParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case DorisParserATSIGN:
		localctx = NewSetUserVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2593)
			p.Match(DorisParserATSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2594)
			p.Identifier()
		}
		{
			p.SetState(2595)
			p.Match(DorisParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2596)
			p.Expression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionAccessModeContext is an interface to support dynamic dispatch.
type ITransactionAccessModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	WRITE() antlr.TerminalNode

	// IsTransactionAccessModeContext differentiates from other interfaces.
	IsTransactionAccessModeContext()
}

type TransactionAccessModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionAccessModeContext() *TransactionAccessModeContext {
	var p = new(TransactionAccessModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_transactionAccessMode
	return p
}

func InitEmptyTransactionAccessModeContext(p *TransactionAccessModeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_transactionAccessMode
}

func (*TransactionAccessModeContext) IsTransactionAccessModeContext() {}

func NewTransactionAccessModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionAccessModeContext {
	var p = new(TransactionAccessModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_transactionAccessMode

	return p
}

func (s *TransactionAccessModeContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionAccessModeContext) READ() antlr.TerminalNode {
	return s.GetToken(DorisParserREAD, 0)
}

func (s *TransactionAccessModeContext) ONLY() antlr.TerminalNode {
	return s.GetToken(DorisParserONLY, 0)
}

func (s *TransactionAccessModeContext) WRITE() antlr.TerminalNode {
	return s.GetToken(DorisParserWRITE, 0)
}

func (s *TransactionAccessModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionAccessModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionAccessModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTransactionAccessMode(s)
	}
}

func (s *TransactionAccessModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTransactionAccessMode(s)
	}
}

func (p *DorisParser) TransactionAccessMode() (localctx ITransactionAccessModeContext) {
	localctx = NewTransactionAccessModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, DorisParserRULE_transactionAccessMode)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2600)
		p.Match(DorisParserREAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2601)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserONLY || _la == DorisParserWRITE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIsolationLevelContext is an interface to support dynamic dispatch.
type IIsolationLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ISOLATION() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	READ() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	REPEATABLE() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode

	// IsIsolationLevelContext differentiates from other interfaces.
	IsIsolationLevelContext()
}

type IsolationLevelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsolationLevelContext() *IsolationLevelContext {
	var p = new(IsolationLevelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_isolationLevel
	return p
}

func InitEmptyIsolationLevelContext(p *IsolationLevelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_isolationLevel
}

func (*IsolationLevelContext) IsIsolationLevelContext() {}

func NewIsolationLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IsolationLevelContext {
	var p = new(IsolationLevelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_isolationLevel

	return p
}

func (s *IsolationLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *IsolationLevelContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(DorisParserISOLATION, 0)
}

func (s *IsolationLevelContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(DorisParserLEVEL, 0)
}

func (s *IsolationLevelContext) READ() antlr.TerminalNode {
	return s.GetToken(DorisParserREAD, 0)
}

func (s *IsolationLevelContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(DorisParserUNCOMMITTED, 0)
}

func (s *IsolationLevelContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMITTED, 0)
}

func (s *IsolationLevelContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPEATABLE, 0)
}

func (s *IsolationLevelContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserSERIALIZABLE, 0)
}

func (s *IsolationLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsolationLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IsolationLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIsolationLevel(s)
	}
}

func (s *IsolationLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIsolationLevel(s)
	}
}

func (p *DorisParser) IsolationLevel() (localctx IIsolationLevelContext) {
	localctx = NewIsolationLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, DorisParserRULE_isolationLevel)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2603)
		p.Match(DorisParserISOLATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2604)
		p.Match(DorisParserLEVEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2612)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 343, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2605)
			p.Match(DorisParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2606)
			p.Match(DorisParserUNCOMMITTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(2607)
			p.Match(DorisParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2608)
			p.Match(DorisParserCOMMITTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(2609)
			p.Match(DorisParserREPEATABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2610)
			p.Match(DorisParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(2611)
			p.Match(DorisParserSERIALIZABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupoortedUnsetStatementContext is an interface to support dynamic dispatch.
type IUnsupoortedUnsetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNSET() antlr.TerminalNode
	VARIABLE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	Identifier() IIdentifierContext
	GLOBAL() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VAULT() antlr.TerminalNode

	// IsUnsupoortedUnsetStatementContext differentiates from other interfaces.
	IsUnsupoortedUnsetStatementContext()
}

type UnsupoortedUnsetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupoortedUnsetStatementContext() *UnsupoortedUnsetStatementContext {
	var p = new(UnsupoortedUnsetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupoortedUnsetStatement
	return p
}

func InitEmptyUnsupoortedUnsetStatementContext(p *UnsupoortedUnsetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupoortedUnsetStatement
}

func (*UnsupoortedUnsetStatementContext) IsUnsupoortedUnsetStatementContext() {}

func NewUnsupoortedUnsetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupoortedUnsetStatementContext {
	var p = new(UnsupoortedUnsetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupoortedUnsetStatement

	return p
}

func (s *UnsupoortedUnsetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupoortedUnsetStatementContext) UNSET() antlr.TerminalNode {
	return s.GetToken(DorisParserUNSET, 0)
}

func (s *UnsupoortedUnsetStatementContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserVARIABLE, 0)
}

func (s *UnsupoortedUnsetStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *UnsupoortedUnsetStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnsupoortedUnsetStatementContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *UnsupoortedUnsetStatementContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION, 0)
}

func (s *UnsupoortedUnsetStatementContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *UnsupoortedUnsetStatementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *UnsupoortedUnsetStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *UnsupoortedUnsetStatementContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULT, 0)
}

func (s *UnsupoortedUnsetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupoortedUnsetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsupoortedUnsetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUnsupoortedUnsetStatement(s)
	}
}

func (s *UnsupoortedUnsetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUnsupoortedUnsetStatement(s)
	}
}

func (p *DorisParser) UnsupoortedUnsetStatement() (localctx IUnsupoortedUnsetStatementContext) {
	localctx = NewUnsupoortedUnsetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, DorisParserRULE_unsupoortedUnsetStatement)
	var _la int

	p.SetState(2627)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 346, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2614)
			p.Match(DorisParserUNSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2616)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION {
			{
				p.SetState(2615)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(2618)
			p.Match(DorisParserVARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2621)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserALL:
			{
				p.SetState(2619)
				p.Match(DorisParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADDDATE, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserARRAY_RANGE, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATE_ADD, DorisParserDATE_CEIL, DorisParserDATE_DIFF, DorisParserDATE_FLOOR, DorisParserDATE_SUB, DorisParserDATEADD, DorisParserDATEDIFF, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS_ADD, DorisParserDAYS_SUB, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSEQUENCE, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUBDATE, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTIMESTAMPADD, DorisParserTIMESTAMPDIFF, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(2620)
				p.Identifier()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2623)
			p.Match(DorisParserUNSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2624)
			p.Match(DorisParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2625)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2626)
			p.Match(DorisParserVAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedUseStatementContext is an interface to support dynamic dispatch.
type IUnsupportedUseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedUseStatementContext differentiates from other interfaces.
	IsUnsupportedUseStatementContext()
}

type UnsupportedUseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedUseStatementContext() *UnsupportedUseStatementContext {
	var p = new(UnsupportedUseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedUseStatement
	return p
}

func InitEmptyUnsupportedUseStatementContext(p *UnsupportedUseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedUseStatement
}

func (*UnsupportedUseStatementContext) IsUnsupportedUseStatementContext() {}

func NewUnsupportedUseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedUseStatementContext {
	var p = new(UnsupportedUseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedUseStatement

	return p
}

func (s *UnsupportedUseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedUseStatementContext) CopyAll(ctx *UnsupportedUseStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedUseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedUseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UseCloudClusterContext struct {
	UnsupportedUseStatementContext
	catalog  IIdentifierContext
	database IIdentifierContext
	cluster  IIdentifierContext
}

func NewUseCloudClusterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UseCloudClusterContext {
	var p = new(UseCloudClusterContext)

	InitEmptyUnsupportedUseStatementContext(&p.UnsupportedUseStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedUseStatementContext))

	return p
}

func (s *UseCloudClusterContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *UseCloudClusterContext) GetDatabase() IIdentifierContext { return s.database }

func (s *UseCloudClusterContext) GetCluster() IIdentifierContext { return s.cluster }

func (s *UseCloudClusterContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *UseCloudClusterContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *UseCloudClusterContext) SetCluster(v IIdentifierContext) { s.cluster = v }

func (s *UseCloudClusterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseCloudClusterContext) USE() antlr.TerminalNode {
	return s.GetToken(DorisParserUSE, 0)
}

func (s *UseCloudClusterContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserATSIGN, 0)
}

func (s *UseCloudClusterContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *UseCloudClusterContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UseCloudClusterContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *UseCloudClusterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUseCloudCluster(s)
	}
}

func (s *UseCloudClusterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUseCloudCluster(s)
	}
}

type UseDatabaseContext struct {
	UnsupportedUseStatementContext
	catalog  IIdentifierContext
	database IIdentifierContext
}

func NewUseDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UseDatabaseContext {
	var p = new(UseDatabaseContext)

	InitEmptyUnsupportedUseStatementContext(&p.UnsupportedUseStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedUseStatementContext))

	return p
}

func (s *UseDatabaseContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *UseDatabaseContext) GetDatabase() IIdentifierContext { return s.database }

func (s *UseDatabaseContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *UseDatabaseContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *UseDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseDatabaseContext) USE() antlr.TerminalNode {
	return s.GetToken(DorisParserUSE, 0)
}

func (s *UseDatabaseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *UseDatabaseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UseDatabaseContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *UseDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUseDatabase(s)
	}
}

func (s *UseDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUseDatabase(s)
	}
}

type SwitchCatalogContext struct {
	UnsupportedUseStatementContext
	catalog IIdentifierContext
}

func NewSwitchCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SwitchCatalogContext {
	var p = new(SwitchCatalogContext)

	InitEmptyUnsupportedUseStatementContext(&p.UnsupportedUseStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedUseStatementContext))

	return p
}

func (s *SwitchCatalogContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *SwitchCatalogContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *SwitchCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchCatalogContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(DorisParserSWITCH, 0)
}

func (s *SwitchCatalogContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SwitchCatalogContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSwitchCatalog(s)
	}
}

func (s *SwitchCatalogContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSwitchCatalog(s)
	}
}

func (p *DorisParser) UnsupportedUseStatement() (localctx IUnsupportedUseStatementContext) {
	localctx = NewUnsupportedUseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, DorisParserRULE_unsupportedUseStatement)
	var _la int

	p.SetState(2649)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 350, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUseDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2629)
			p.Match(DorisParserUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2633)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 347, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2630)

				var _x = p.Identifier()

				localctx.(*UseDatabaseContext).catalog = _x
			}
			{
				p.SetState(2631)
				p.Match(DorisParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2635)

			var _x = p.Identifier()

			localctx.(*UseDatabaseContext).database = _x
		}

	case 2:
		localctx = NewUseCloudClusterContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2636)
			p.Match(DorisParserUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2643)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1153040409952344576) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&-53021438386753) != 0) || ((int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&3476586699635759401) != 0) || ((int64((_la-195)) & ^0x3f) == 0 && ((int64(1)<<(_la-195))&-3139048519776880011) != 0) || ((int64((_la-260)) & ^0x3f) == 0 && ((int64(1)<<(_la-260))&-4544906634320822477) != 0) || ((int64((_la-325)) & ^0x3f) == 0 && ((int64(1)<<(_la-325))&6339805778266808319) != 0) || ((int64((_la-390)) & ^0x3f) == 0 && ((int64(1)<<(_la-390))&-656945004016972825) != 0) || ((int64((_la-456)) & ^0x3f) == 0 && ((int64(1)<<(_la-456))&18760394443469) != 0) || ((int64((_la-522)) & ^0x3f) == 0 && ((int64(1)<<(_la-522))&49159) != 0) {
			p.SetState(2640)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 348, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2637)

					var _x = p.Identifier()

					localctx.(*UseCloudClusterContext).catalog = _x
				}
				{
					p.SetState(2638)
					p.Match(DorisParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(2642)

				var _x = p.Identifier()

				localctx.(*UseCloudClusterContext).database = _x
			}

		}
		{
			p.SetState(2645)
			p.Match(DorisParserATSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2646)

			var _x = p.Identifier()

			localctx.(*UseCloudClusterContext).cluster = _x
		}

	case 3:
		localctx = NewSwitchCatalogContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2647)
			p.Match(DorisParserSWITCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2648)

			var _x = p.Identifier()

			localctx.(*SwitchCatalogContext).catalog = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedDmlStatementContext is an interface to support dynamic dispatch.
type IUnsupportedDmlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedDmlStatementContext differentiates from other interfaces.
	IsUnsupportedDmlStatementContext()
}

type UnsupportedDmlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedDmlStatementContext() *UnsupportedDmlStatementContext {
	var p = new(UnsupportedDmlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedDmlStatement
	return p
}

func InitEmptyUnsupportedDmlStatementContext(p *UnsupportedDmlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedDmlStatement
}

func (*UnsupportedDmlStatementContext) IsUnsupportedDmlStatementContext() {}

func NewUnsupportedDmlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedDmlStatementContext {
	var p = new(UnsupportedDmlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedDmlStatement

	return p
}

func (s *UnsupportedDmlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedDmlStatementContext) CopyAll(ctx *UnsupportedDmlStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedDmlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedDmlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TruncateTableContext struct {
	UnsupportedDmlStatementContext
}

func NewTruncateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TruncateTableContext {
	var p = new(TruncateTableContext)

	InitEmptyUnsupportedDmlStatementContext(&p.UnsupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDmlStatementContext))

	return p
}

func (s *TruncateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncateTableContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(DorisParserTRUNCATE, 0)
}

func (s *TruncateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *TruncateTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *TruncateTableContext) SpecifiedPartition() ISpecifiedPartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecifiedPartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecifiedPartitionContext)
}

func (s *TruncateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTruncateTable(s)
	}
}

func (s *TruncateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTruncateTable(s)
	}
}

func (p *DorisParser) UnsupportedDmlStatement() (localctx IUnsupportedDmlStatementContext) {
	localctx = NewUnsupportedDmlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, DorisParserRULE_unsupportedDmlStatement)
	var _la int

	localctx = NewTruncateTableContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2651)
		p.Match(DorisParserTRUNCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2652)
		p.Match(DorisParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2653)
		p.MultipartIdentifier()
	}
	p.SetState(2655)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
		{
			p.SetState(2654)
			p.SpecifiedPartition()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedKillStatementContext is an interface to support dynamic dispatch.
type IUnsupportedKillStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedKillStatementContext differentiates from other interfaces.
	IsUnsupportedKillStatementContext()
}

type UnsupportedKillStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedKillStatementContext() *UnsupportedKillStatementContext {
	var p = new(UnsupportedKillStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedKillStatement
	return p
}

func InitEmptyUnsupportedKillStatementContext(p *UnsupportedKillStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedKillStatement
}

func (*UnsupportedKillStatementContext) IsUnsupportedKillStatementContext() {}

func NewUnsupportedKillStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedKillStatementContext {
	var p = new(UnsupportedKillStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedKillStatement

	return p
}

func (s *UnsupportedKillStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedKillStatementContext) CopyAll(ctx *UnsupportedKillStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedKillStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedKillStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type KillQueryContext struct {
	UnsupportedKillStatementContext
}

func NewKillQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KillQueryContext {
	var p = new(KillQueryContext)

	InitEmptyUnsupportedKillStatementContext(&p.UnsupportedKillStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedKillStatementContext))

	return p
}

func (s *KillQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillQueryContext) KILL() antlr.TerminalNode {
	return s.GetToken(DorisParserKILL, 0)
}

func (s *KillQueryContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DorisParserQUERY, 0)
}

func (s *KillQueryContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *KillQueryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *KillQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterKillQuery(s)
	}
}

func (s *KillQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitKillQuery(s)
	}
}

type KillConnectionContext struct {
	UnsupportedKillStatementContext
}

func NewKillConnectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KillConnectionContext {
	var p = new(KillConnectionContext)

	InitEmptyUnsupportedKillStatementContext(&p.UnsupportedKillStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedKillStatementContext))

	return p
}

func (s *KillConnectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillConnectionContext) KILL() antlr.TerminalNode {
	return s.GetToken(DorisParserKILL, 0)
}

func (s *KillConnectionContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *KillConnectionContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(DorisParserCONNECTION, 0)
}

func (s *KillConnectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterKillConnection(s)
	}
}

func (s *KillConnectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitKillConnection(s)
	}
}

func (p *DorisParser) UnsupportedKillStatement() (localctx IUnsupportedKillStatementContext) {
	localctx = NewUnsupportedKillStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, DorisParserRULE_unsupportedKillStatement)
	var _la int

	p.SetState(2665)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 353, p.GetParserRuleContext()) {
	case 1:
		localctx = NewKillConnectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2657)
			p.Match(DorisParserKILL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2659)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCONNECTION {
			{
				p.SetState(2658)
				p.Match(DorisParserCONNECTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2661)
			p.Match(DorisParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewKillQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2662)
			p.Match(DorisParserKILL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2663)
			p.Match(DorisParserQUERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2664)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserSTRING_LITERAL || _la == DorisParserINTEGER_VALUE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedDescribeStatementContext is an interface to support dynamic dispatch.
type IUnsupportedDescribeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedDescribeStatementContext differentiates from other interfaces.
	IsUnsupportedDescribeStatementContext()
}

type UnsupportedDescribeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedDescribeStatementContext() *UnsupportedDescribeStatementContext {
	var p = new(UnsupportedDescribeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedDescribeStatement
	return p
}

func InitEmptyUnsupportedDescribeStatementContext(p *UnsupportedDescribeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedDescribeStatement
}

func (*UnsupportedDescribeStatementContext) IsUnsupportedDescribeStatementContext() {}

func NewUnsupportedDescribeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedDescribeStatementContext {
	var p = new(UnsupportedDescribeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedDescribeStatement

	return p
}

func (s *UnsupportedDescribeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedDescribeStatementContext) CopyAll(ctx *UnsupportedDescribeStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedDescribeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedDescribeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DescribeTableValuedFunctionContext struct {
	UnsupportedDescribeStatementContext
	tvfName    IIdentifierContext
	properties IPropertyItemListContext
}

func NewDescribeTableValuedFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeTableValuedFunctionContext {
	var p = new(DescribeTableValuedFunctionContext)

	InitEmptyUnsupportedDescribeStatementContext(&p.UnsupportedDescribeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDescribeStatementContext))

	return p
}

func (s *DescribeTableValuedFunctionContext) GetTvfName() IIdentifierContext { return s.tvfName }

func (s *DescribeTableValuedFunctionContext) GetProperties() IPropertyItemListContext {
	return s.properties
}

func (s *DescribeTableValuedFunctionContext) SetTvfName(v IIdentifierContext) { s.tvfName = v }

func (s *DescribeTableValuedFunctionContext) SetProperties(v IPropertyItemListContext) {
	s.properties = v
}

func (s *DescribeTableValuedFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeTableValuedFunctionContext) ExplainCommand() IExplainCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainCommandContext)
}

func (s *DescribeTableValuedFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserFUNCTION, 0)
}

func (s *DescribeTableValuedFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *DescribeTableValuedFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *DescribeTableValuedFunctionContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *DescribeTableValuedFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DescribeTableValuedFunctionContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *DescribeTableValuedFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDescribeTableValuedFunction(s)
	}
}

func (s *DescribeTableValuedFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDescribeTableValuedFunction(s)
	}
}

type DescribeTableContext struct {
	UnsupportedDescribeStatementContext
}

func NewDescribeTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeTableContext {
	var p = new(DescribeTableContext)

	InitEmptyUnsupportedDescribeStatementContext(&p.UnsupportedDescribeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDescribeStatementContext))

	return p
}

func (s *DescribeTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeTableContext) ExplainCommand() IExplainCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainCommandContext)
}

func (s *DescribeTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DescribeTableContext) SpecifiedPartition() ISpecifiedPartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecifiedPartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecifiedPartitionContext)
}

func (s *DescribeTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDescribeTable(s)
	}
}

func (s *DescribeTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDescribeTable(s)
	}
}

type DescribeTableAllContext struct {
	UnsupportedDescribeStatementContext
}

func NewDescribeTableAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeTableAllContext {
	var p = new(DescribeTableAllContext)

	InitEmptyUnsupportedDescribeStatementContext(&p.UnsupportedDescribeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedDescribeStatementContext))

	return p
}

func (s *DescribeTableAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeTableAllContext) ExplainCommand() IExplainCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainCommandContext)
}

func (s *DescribeTableAllContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DescribeTableAllContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *DescribeTableAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDescribeTableAll(s)
	}
}

func (s *DescribeTableAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDescribeTableAll(s)
	}
}

func (p *DorisParser) UnsupportedDescribeStatement() (localctx IUnsupportedDescribeStatementContext) {
	localctx = NewUnsupportedDescribeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, DorisParserRULE_unsupportedDescribeStatement)
	var _la int

	p.SetState(2686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 356, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDescribeTableValuedFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2667)
			p.ExplainCommand()
		}
		{
			p.SetState(2668)
			p.Match(DorisParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2669)

			var _x = p.Identifier()

			localctx.(*DescribeTableValuedFunctionContext).tvfName = _x
		}
		{
			p.SetState(2670)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2672)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1153005225580255616) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&-53021438386753) != 0) || ((int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&3476727437124114729) != 0) || ((int64((_la-195)) & ^0x3f) == 0 && ((int64(1)<<(_la-195))&-3139048519776880011) != 0) || ((int64((_la-260)) & ^0x3f) == 0 && ((int64(1)<<(_la-260))&-4544765896832467149) != 0) || ((int64((_la-325)) & ^0x3f) == 0 && ((int64(1)<<(_la-325))&6339805778266816511) != 0) || ((int64((_la-390)) & ^0x3f) == 0 && ((int64(1)<<(_la-390))&-656945004016972825) != 0) || ((int64((_la-456)) & ^0x3f) == 0 && ((int64(1)<<(_la-456))&9025959649184493) != 0) || ((int64((_la-522)) & ^0x3f) == 0 && ((int64(1)<<(_la-522))&56359) != 0) {
			{
				p.SetState(2671)

				var _x = p.PropertyItemList()

				localctx.(*DescribeTableValuedFunctionContext).properties = _x
			}

		}
		{
			p.SetState(2674)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2675)
			p.TableAlias()
		}

	case 2:
		localctx = NewDescribeTableAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2677)
			p.ExplainCommand()
		}
		{
			p.SetState(2678)
			p.MultipartIdentifier()
		}
		{
			p.SetState(2679)
			p.Match(DorisParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewDescribeTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2681)
			p.ExplainCommand()
		}
		{
			p.SetState(2682)
			p.MultipartIdentifier()
		}
		p.SetState(2684)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(2683)
				p.SpecifiedPartition()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstraintContext is an interface to support dynamic dispatch.
type IConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSlots returns the slots rule contexts.
	GetSlots() IIdentifierListContext

	// GetReferenceTable returns the referenceTable rule contexts.
	GetReferenceTable() IMultipartIdentifierContext

	// GetReferencedSlots returns the referencedSlots rule contexts.
	GetReferencedSlots() IIdentifierListContext

	// SetSlots sets the slots rule contexts.
	SetSlots(IIdentifierListContext)

	// SetReferenceTable sets the referenceTable rule contexts.
	SetReferenceTable(IMultipartIdentifierContext)

	// SetReferencedSlots sets the referencedSlots rule contexts.
	SetReferencedSlots(IIdentifierListContext)

	// Getter signatures
	PRIMARY() antlr.TerminalNode
	KEY() antlr.TerminalNode
	AllIdentifierList() []IIdentifierListContext
	IdentifierList(i int) IIdentifierListContext
	UNIQUE() antlr.TerminalNode
	FOREIGN() antlr.TerminalNode
	REFERENCES() antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext

	// IsConstraintContext differentiates from other interfaces.
	IsConstraintContext()
}

type ConstraintContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	slots           IIdentifierListContext
	referenceTable  IMultipartIdentifierContext
	referencedSlots IIdentifierListContext
}

func NewEmptyConstraintContext() *ConstraintContext {
	var p = new(ConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_constraint
	return p
}

func InitEmptyConstraintContext(p *ConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_constraint
}

func (*ConstraintContext) IsConstraintContext() {}

func NewConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintContext {
	var p = new(ConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_constraint

	return p
}

func (s *ConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintContext) GetSlots() IIdentifierListContext { return s.slots }

func (s *ConstraintContext) GetReferenceTable() IMultipartIdentifierContext { return s.referenceTable }

func (s *ConstraintContext) GetReferencedSlots() IIdentifierListContext { return s.referencedSlots }

func (s *ConstraintContext) SetSlots(v IIdentifierListContext) { s.slots = v }

func (s *ConstraintContext) SetReferenceTable(v IMultipartIdentifierContext) { s.referenceTable = v }

func (s *ConstraintContext) SetReferencedSlots(v IIdentifierListContext) { s.referencedSlots = v }

func (s *ConstraintContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(DorisParserPRIMARY, 0)
}

func (s *ConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserKEY, 0)
}

func (s *ConstraintContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *ConstraintContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ConstraintContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(DorisParserUNIQUE, 0)
}

func (s *ConstraintContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserFOREIGN, 0)
}

func (s *ConstraintContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(DorisParserREFERENCES, 0)
}

func (s *ConstraintContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterConstraint(s)
	}
}

func (s *ConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitConstraint(s)
	}
}

func (p *DorisParser) Constraint() (localctx IConstraintContext) {
	localctx = NewConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, DorisParserRULE_constraint)
	p.SetState(2700)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserPRIMARY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2688)
			p.Match(DorisParserPRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2689)
			p.Match(DorisParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2690)

			var _x = p.IdentifierList()

			localctx.(*ConstraintContext).slots = _x
		}

	case DorisParserUNIQUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2691)
			p.Match(DorisParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2692)

			var _x = p.IdentifierList()

			localctx.(*ConstraintContext).slots = _x
		}

	case DorisParserFOREIGN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2693)
			p.Match(DorisParserFOREIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2694)
			p.Match(DorisParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2695)

			var _x = p.IdentifierList()

			localctx.(*ConstraintContext).slots = _x
		}
		{
			p.SetState(2696)
			p.Match(DorisParserREFERENCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2697)

			var _x = p.MultipartIdentifier()

			localctx.(*ConstraintContext).referenceTable = _x
		}
		{
			p.SetState(2698)

			var _x = p.IdentifierList()

			localctx.(*ConstraintContext).referencedSlots = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionSpecContext is an interface to support dynamic dispatch.
type IPartitionSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitions returns the partitions rule contexts.
	GetPartitions() IIdentifierListContext

	// GetPartition returns the partition rule contexts.
	GetPartition() IErrorCapturingIdentifierContext

	// SetPartitions sets the partitions rule contexts.
	SetPartitions(IIdentifierListContext)

	// SetPartition sets the partition rule contexts.
	SetPartition(IErrorCapturingIdentifierContext)

	// Getter signatures
	PARTITION() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	TEMPORARY() antlr.TerminalNode
	ErrorCapturingIdentifier() IErrorCapturingIdentifierContext
	LEFT_PAREN() antlr.TerminalNode
	ASTERISK() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode

	// IsPartitionSpecContext differentiates from other interfaces.
	IsPartitionSpecContext()
}

type PartitionSpecContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	partitions IIdentifierListContext
	partition  IErrorCapturingIdentifierContext
}

func NewEmptyPartitionSpecContext() *PartitionSpecContext {
	var p = new(PartitionSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionSpec
	return p
}

func InitEmptyPartitionSpecContext(p *PartitionSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionSpec
}

func (*PartitionSpecContext) IsPartitionSpecContext() {}

func NewPartitionSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionSpecContext {
	var p = new(PartitionSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_partitionSpec

	return p
}

func (s *PartitionSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionSpecContext) GetPartitions() IIdentifierListContext { return s.partitions }

func (s *PartitionSpecContext) GetPartition() IErrorCapturingIdentifierContext { return s.partition }

func (s *PartitionSpecContext) SetPartitions(v IIdentifierListContext) { s.partitions = v }

func (s *PartitionSpecContext) SetPartition(v IErrorCapturingIdentifierContext) { s.partition = v }

func (s *PartitionSpecContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *PartitionSpecContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITIONS, 0)
}

func (s *PartitionSpecContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PartitionSpecContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *PartitionSpecContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *PartitionSpecContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *PartitionSpecContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserASTERISK, 0)
}

func (s *PartitionSpecContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *PartitionSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPartitionSpec(s)
	}
}

func (s *PartitionSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPartitionSpec(s)
	}
}

func (p *DorisParser) PartitionSpec() (localctx IPartitionSpecContext) {
	localctx = NewPartitionSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, DorisParserRULE_partitionSpec)
	var _la int

	p.SetState(2716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 360, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2703)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(2702)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2705)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserPARTITION || _la == DorisParserPARTITIONS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2706)

			var _x = p.IdentifierList()

			localctx.(*PartitionSpecContext).partitions = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2708)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(2707)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2710)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2711)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*PartitionSpecContext).partition = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2712)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserPARTITION || _la == DorisParserPARTITIONS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2713)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2714)
			p.Match(DorisParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2715)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionTableContext is an interface to support dynamic dispatch.
type IPartitionTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAutoPartition returns the autoPartition token.
	GetAutoPartition() antlr.Token

	// SetAutoPartition sets the autoPartition token.
	SetAutoPartition(antlr.Token)

	// GetPartitionList returns the partitionList rule contexts.
	GetPartitionList() IIdentityOrFunctionListContext

	// GetPartitions returns the partitions rule contexts.
	GetPartitions() IPartitionsDefContext

	// SetPartitionList sets the partitionList rule contexts.
	SetPartitionList(IIdentityOrFunctionListContext)

	// SetPartitions sets the partitions rule contexts.
	SetPartitions(IPartitionsDefContext)

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	IdentityOrFunctionList() IIdentityOrFunctionListContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AUTO() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	LIST() antlr.TerminalNode
	PartitionsDef() IPartitionsDefContext

	// IsPartitionTableContext differentiates from other interfaces.
	IsPartitionTableContext()
}

type PartitionTableContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	autoPartition antlr.Token
	partitionList IIdentityOrFunctionListContext
	partitions    IPartitionsDefContext
}

func NewEmptyPartitionTableContext() *PartitionTableContext {
	var p = new(PartitionTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionTable
	return p
}

func InitEmptyPartitionTableContext(p *PartitionTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionTable
}

func (*PartitionTableContext) IsPartitionTableContext() {}

func NewPartitionTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionTableContext {
	var p = new(PartitionTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_partitionTable

	return p
}

func (s *PartitionTableContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionTableContext) GetAutoPartition() antlr.Token { return s.autoPartition }

func (s *PartitionTableContext) SetAutoPartition(v antlr.Token) { s.autoPartition = v }

func (s *PartitionTableContext) GetPartitionList() IIdentityOrFunctionListContext {
	return s.partitionList
}

func (s *PartitionTableContext) GetPartitions() IPartitionsDefContext { return s.partitions }

func (s *PartitionTableContext) SetPartitionList(v IIdentityOrFunctionListContext) {
	s.partitionList = v
}

func (s *PartitionTableContext) SetPartitions(v IPartitionsDefContext) { s.partitions = v }

func (s *PartitionTableContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *PartitionTableContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *PartitionTableContext) IdentityOrFunctionList() IIdentityOrFunctionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentityOrFunctionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentityOrFunctionListContext)
}

func (s *PartitionTableContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *PartitionTableContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *PartitionTableContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO, 0)
}

func (s *PartitionTableContext) RANGE() antlr.TerminalNode {
	return s.GetToken(DorisParserRANGE, 0)
}

func (s *PartitionTableContext) LIST() antlr.TerminalNode {
	return s.GetToken(DorisParserLIST, 0)
}

func (s *PartitionTableContext) PartitionsDef() IPartitionsDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionsDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionsDefContext)
}

func (s *PartitionTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPartitionTable(s)
	}
}

func (s *PartitionTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPartitionTable(s)
	}
}

func (p *DorisParser) PartitionTable() (localctx IPartitionTableContext) {
	localctx = NewPartitionTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, DorisParserRULE_partitionTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2719)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserAUTO {
		{
			p.SetState(2718)

			var _m = p.Match(DorisParserAUTO)

			localctx.(*PartitionTableContext).autoPartition = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2721)
		p.Match(DorisParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2722)
		p.Match(DorisParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2724)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLIST || _la == DorisParserRANGE {
		{
			p.SetState(2723)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserLIST || _la == DorisParserRANGE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(2726)

		var _x = p.IdentityOrFunctionList()

		localctx.(*PartitionTableContext).partitionList = _x
	}

	{
		p.SetState(2727)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2729)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserFROM || _la == DorisParserPARTITION {
		{
			p.SetState(2728)

			var _x = p.PartitionsDef()

			localctx.(*PartitionTableContext).partitions = _x
		}

	}
	{
		p.SetState(2731)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentityOrFunctionListContext is an interface to support dynamic dispatch.
type IIdentityOrFunctionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_identityOrFunction returns the _identityOrFunction rule contexts.
	Get_identityOrFunction() IIdentityOrFunctionContext

	// Set_identityOrFunction sets the _identityOrFunction rule contexts.
	Set_identityOrFunction(IIdentityOrFunctionContext)

	// GetPartitions returns the partitions rule context list.
	GetPartitions() []IIdentityOrFunctionContext

	// SetPartitions sets the partitions rule context list.
	SetPartitions([]IIdentityOrFunctionContext)

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	AllIdentityOrFunction() []IIdentityOrFunctionContext
	IdentityOrFunction(i int) IIdentityOrFunctionContext
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentityOrFunctionListContext differentiates from other interfaces.
	IsIdentityOrFunctionListContext()
}

type IdentityOrFunctionListContext struct {
	antlr.BaseParserRuleContext
	parser              antlr.Parser
	_identityOrFunction IIdentityOrFunctionContext
	partitions          []IIdentityOrFunctionContext
}

func NewEmptyIdentityOrFunctionListContext() *IdentityOrFunctionListContext {
	var p = new(IdentityOrFunctionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identityOrFunctionList
	return p
}

func InitEmptyIdentityOrFunctionListContext(p *IdentityOrFunctionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identityOrFunctionList
}

func (*IdentityOrFunctionListContext) IsIdentityOrFunctionListContext() {}

func NewIdentityOrFunctionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentityOrFunctionListContext {
	var p = new(IdentityOrFunctionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_identityOrFunctionList

	return p
}

func (s *IdentityOrFunctionListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentityOrFunctionListContext) Get_identityOrFunction() IIdentityOrFunctionContext {
	return s._identityOrFunction
}

func (s *IdentityOrFunctionListContext) Set_identityOrFunction(v IIdentityOrFunctionContext) {
	s._identityOrFunction = v
}

func (s *IdentityOrFunctionListContext) GetPartitions() []IIdentityOrFunctionContext {
	return s.partitions
}

func (s *IdentityOrFunctionListContext) SetPartitions(v []IIdentityOrFunctionContext) {
	s.partitions = v
}

func (s *IdentityOrFunctionListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *IdentityOrFunctionListContext) AllIdentityOrFunction() []IIdentityOrFunctionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentityOrFunctionContext); ok {
			len++
		}
	}

	tst := make([]IIdentityOrFunctionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentityOrFunctionContext); ok {
			tst[i] = t.(IIdentityOrFunctionContext)
			i++
		}
	}

	return tst
}

func (s *IdentityOrFunctionListContext) IdentityOrFunction(i int) IIdentityOrFunctionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentityOrFunctionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentityOrFunctionContext)
}

func (s *IdentityOrFunctionListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *IdentityOrFunctionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *IdentityOrFunctionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *IdentityOrFunctionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentityOrFunctionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentityOrFunctionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIdentityOrFunctionList(s)
	}
}

func (s *IdentityOrFunctionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIdentityOrFunctionList(s)
	}
}

func (p *DorisParser) IdentityOrFunctionList() (localctx IIdentityOrFunctionListContext) {
	localctx = NewIdentityOrFunctionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, DorisParserRULE_identityOrFunctionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2733)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2734)
		p.IdentityOrFunction()
	}
	p.SetState(2739)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(2735)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2736)

			var _x = p.IdentityOrFunction()

			localctx.(*IdentityOrFunctionListContext)._identityOrFunction = _x
		}
		localctx.(*IdentityOrFunctionListContext).partitions = append(localctx.(*IdentityOrFunctionListContext).partitions, localctx.(*IdentityOrFunctionListContext)._identityOrFunction)

		p.SetState(2741)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2742)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentityOrFunctionContext is an interface to support dynamic dispatch.
type IIdentityOrFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	FunctionCallExpression() IFunctionCallExpressionContext

	// IsIdentityOrFunctionContext differentiates from other interfaces.
	IsIdentityOrFunctionContext()
}

type IdentityOrFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentityOrFunctionContext() *IdentityOrFunctionContext {
	var p = new(IdentityOrFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identityOrFunction
	return p
}

func InitEmptyIdentityOrFunctionContext(p *IdentityOrFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identityOrFunction
}

func (*IdentityOrFunctionContext) IsIdentityOrFunctionContext() {}

func NewIdentityOrFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentityOrFunctionContext {
	var p = new(IdentityOrFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_identityOrFunction

	return p
}

func (s *IdentityOrFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentityOrFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentityOrFunctionContext) FunctionCallExpression() IFunctionCallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallExpressionContext)
}

func (s *IdentityOrFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentityOrFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentityOrFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIdentityOrFunction(s)
	}
}

func (s *IdentityOrFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIdentityOrFunction(s)
	}
}

func (p *DorisParser) IdentityOrFunction() (localctx IIdentityOrFunctionContext) {
	localctx = NewIdentityOrFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, DorisParserRULE_identityOrFunction)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2746)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 365, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2744)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(2745)
			p.FunctionCallExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataDescContext is an interface to support dynamic dispatch.
type IDataDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_STRING_LITERAL returns the _STRING_LITERAL token.
	Get_STRING_LITERAL() antlr.Token

	// GetComma returns the comma token.
	GetComma() antlr.Token

	// GetSeparator returns the separator token.
	GetSeparator() antlr.Token

	// Set_STRING_LITERAL sets the _STRING_LITERAL token.
	Set_STRING_LITERAL(antlr.Token)

	// SetComma sets the comma token.
	SetComma(antlr.Token)

	// SetSeparator sets the separator token.
	SetSeparator(antlr.Token)

	// GetFilePaths returns the filePaths token list.
	GetFilePaths() []antlr.Token

	// GetFilePath returns the filePath token list.
	GetFilePath() []antlr.Token

	// SetFilePaths sets the filePaths token list.
	SetFilePaths([]antlr.Token)

	// SetFilePath sets the filePath token list.
	SetFilePath([]antlr.Token)

	// GetTableName returns the tableName rule contexts.
	GetTableName() IMultipartIdentifierContext

	// GetPartition returns the partition rule contexts.
	GetPartition() IIdentifierListContext

	// GetFormat returns the format rule contexts.
	GetFormat() IIdentifierOrTextContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IIdentifierListContext

	// GetColumnsFromPath returns the columnsFromPath rule contexts.
	GetColumnsFromPath() IColFromPathContext

	// GetColumnMapping returns the columnMapping rule contexts.
	GetColumnMapping() IColMappingListContext

	// GetPreFilter returns the preFilter rule contexts.
	GetPreFilter() IPreFilterClauseContext

	// GetWhere returns the where rule contexts.
	GetWhere() IWhereClauseContext

	// GetDeleteOn returns the deleteOn rule contexts.
	GetDeleteOn() IDeleteOnClauseContext

	// GetSequenceColumn returns the sequenceColumn rule contexts.
	GetSequenceColumn() ISequenceColClauseContext

	// SetTableName sets the tableName rule contexts.
	SetTableName(IMultipartIdentifierContext)

	// SetPartition sets the partition rule contexts.
	SetPartition(IIdentifierListContext)

	// SetFormat sets the format rule contexts.
	SetFormat(IIdentifierOrTextContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IIdentifierListContext)

	// SetColumnsFromPath sets the columnsFromPath rule contexts.
	SetColumnsFromPath(IColFromPathContext)

	// SetColumnMapping sets the columnMapping rule contexts.
	SetColumnMapping(IColMappingListContext)

	// SetPreFilter sets the preFilter rule contexts.
	SetPreFilter(IPreFilterClauseContext)

	// SetWhere sets the where rule contexts.
	SetWhere(IWhereClauseContext)

	// SetDeleteOn sets the deleteOn rule contexts.
	SetDeleteOn(IDeleteOnClauseContext)

	// SetSequenceColumn sets the sequenceColumn rule contexts.
	SetSequenceColumn(ISequenceColClauseContext)

	// Getter signatures
	DATA() antlr.TerminalNode
	INFILE() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	INTO() antlr.TerminalNode
	AllTABLE() []antlr.TerminalNode
	TABLE(i int) antlr.TerminalNode
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	AllMultipartIdentifier() []IMultipartIdentifierContext
	MultipartIdentifier(i int) IMultipartIdentifierContext
	MergeType() IMergeTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	AllTERMINATED() []antlr.TerminalNode
	TERMINATED(i int) antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	LINES() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	AS() antlr.TerminalNode
	PropertyClause() IPropertyClauseContext
	AllIdentifierList() []IIdentifierListContext
	IdentifierList(i int) IIdentifierListContext
	IdentifierOrText() IIdentifierOrTextContext
	ColFromPath() IColFromPathContext
	ColMappingList() IColMappingListContext
	PreFilterClause() IPreFilterClauseContext
	WhereClause() IWhereClauseContext
	DeleteOnClause() IDeleteOnClauseContext
	SequenceColClause() ISequenceColClauseContext
	WITH() antlr.TerminalNode
	FROM() antlr.TerminalNode

	// IsDataDescContext differentiates from other interfaces.
	IsDataDescContext()
}

type DataDescContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	_STRING_LITERAL antlr.Token
	filePaths       []antlr.Token
	filePath        []antlr.Token
	tableName       IMultipartIdentifierContext
	partition       IIdentifierListContext
	comma           antlr.Token
	separator       antlr.Token
	format          IIdentifierOrTextContext
	columns         IIdentifierListContext
	columnsFromPath IColFromPathContext
	columnMapping   IColMappingListContext
	preFilter       IPreFilterClauseContext
	where           IWhereClauseContext
	deleteOn        IDeleteOnClauseContext
	sequenceColumn  ISequenceColClauseContext
}

func NewEmptyDataDescContext() *DataDescContext {
	var p = new(DataDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dataDesc
	return p
}

func InitEmptyDataDescContext(p *DataDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dataDesc
}

func (*DataDescContext) IsDataDescContext() {}

func NewDataDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescContext {
	var p = new(DataDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_dataDesc

	return p
}

func (s *DataDescContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDescContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *DataDescContext) GetComma() antlr.Token { return s.comma }

func (s *DataDescContext) GetSeparator() antlr.Token { return s.separator }

func (s *DataDescContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *DataDescContext) SetComma(v antlr.Token) { s.comma = v }

func (s *DataDescContext) SetSeparator(v antlr.Token) { s.separator = v }

func (s *DataDescContext) GetFilePaths() []antlr.Token { return s.filePaths }

func (s *DataDescContext) GetFilePath() []antlr.Token { return s.filePath }

func (s *DataDescContext) SetFilePaths(v []antlr.Token) { s.filePaths = v }

func (s *DataDescContext) SetFilePath(v []antlr.Token) { s.filePath = v }

func (s *DataDescContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DataDescContext) GetPartition() IIdentifierListContext { return s.partition }

func (s *DataDescContext) GetFormat() IIdentifierOrTextContext { return s.format }

func (s *DataDescContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *DataDescContext) GetColumnsFromPath() IColFromPathContext { return s.columnsFromPath }

func (s *DataDescContext) GetColumnMapping() IColMappingListContext { return s.columnMapping }

func (s *DataDescContext) GetPreFilter() IPreFilterClauseContext { return s.preFilter }

func (s *DataDescContext) GetWhere() IWhereClauseContext { return s.where }

func (s *DataDescContext) GetDeleteOn() IDeleteOnClauseContext { return s.deleteOn }

func (s *DataDescContext) GetSequenceColumn() ISequenceColClauseContext { return s.sequenceColumn }

func (s *DataDescContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DataDescContext) SetPartition(v IIdentifierListContext) { s.partition = v }

func (s *DataDescContext) SetFormat(v IIdentifierOrTextContext) { s.format = v }

func (s *DataDescContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *DataDescContext) SetColumnsFromPath(v IColFromPathContext) { s.columnsFromPath = v }

func (s *DataDescContext) SetColumnMapping(v IColMappingListContext) { s.columnMapping = v }

func (s *DataDescContext) SetPreFilter(v IPreFilterClauseContext) { s.preFilter = v }

func (s *DataDescContext) SetWhere(v IWhereClauseContext) { s.where = v }

func (s *DataDescContext) SetDeleteOn(v IDeleteOnClauseContext) { s.deleteOn = v }

func (s *DataDescContext) SetSequenceColumn(v ISequenceColClauseContext) { s.sequenceColumn = v }

func (s *DataDescContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserDATA, 0)
}

func (s *DataDescContext) INFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserINFILE, 0)
}

func (s *DataDescContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *DataDescContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *DataDescContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserINTO, 0)
}

func (s *DataDescContext) AllTABLE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserTABLE)
}

func (s *DataDescContext) TABLE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, i)
}

func (s *DataDescContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *DataDescContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *DataDescContext) AllMultipartIdentifier() []IMultipartIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultipartIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipartIdentifierContext); ok {
			tst[i] = t.(IMultipartIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DataDescContext) MultipartIdentifier(i int) IMultipartIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DataDescContext) MergeType() IMergeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeTypeContext)
}

func (s *DataDescContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *DataDescContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *DataDescContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *DataDescContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMNS, 0)
}

func (s *DataDescContext) AllTERMINATED() []antlr.TerminalNode {
	return s.GetTokens(DorisParserTERMINATED)
}

func (s *DataDescContext) TERMINATED(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserTERMINATED, i)
}

func (s *DataDescContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(DorisParserBY)
}

func (s *DataDescContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserBY, i)
}

func (s *DataDescContext) LINES() antlr.TerminalNode {
	return s.GetToken(DorisParserLINES, 0)
}

func (s *DataDescContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DorisParserFORMAT, 0)
}

func (s *DataDescContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *DataDescContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *DataDescContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *DataDescContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DataDescContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DataDescContext) ColFromPath() IColFromPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColFromPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColFromPathContext)
}

func (s *DataDescContext) ColMappingList() IColMappingListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColMappingListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColMappingListContext)
}

func (s *DataDescContext) PreFilterClause() IPreFilterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreFilterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreFilterClauseContext)
}

func (s *DataDescContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *DataDescContext) DeleteOnClause() IDeleteOnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteOnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteOnClauseContext)
}

func (s *DataDescContext) SequenceColClause() ISequenceColClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceColClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceColClauseContext)
}

func (s *DataDescContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *DataDescContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *DataDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDataDesc(s)
	}
}

func (s *DataDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDataDesc(s)
	}
}

func (p *DorisParser) DataDesc() (localctx IDataDescContext) {
	localctx = NewDataDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, DorisParserRULE_dataDesc)
	var _la int

	p.SetState(2843)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 388, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2752)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAPPEND || _la == DorisParserDELETE || _la == DorisParserMERGE || _la == DorisParserWITH {
			p.SetState(2749)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserWITH {
				{
					p.SetState(2748)
					p.Match(DorisParserWITH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(2751)
				p.MergeType()
			}

		}
		{
			p.SetState(2754)
			p.Match(DorisParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2755)
			p.Match(DorisParserINFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2756)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2757)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*DataDescContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*DataDescContext).filePaths = append(localctx.(*DataDescContext).filePaths, localctx.(*DataDescContext)._STRING_LITERAL)
		p.SetState(2762)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(2758)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2759)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*DataDescContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*DataDescContext).filePath = append(localctx.(*DataDescContext).filePath, localctx.(*DataDescContext)._STRING_LITERAL)

			p.SetState(2764)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2765)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2766)
			p.Match(DorisParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2767)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2768)

			var _x = p.MultipartIdentifier()

			localctx.(*DataDescContext).tableName = _x
		}
		p.SetState(2771)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION {
			{
				p.SetState(2769)
				p.Match(DorisParserPARTITION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2770)

				var _x = p.IdentifierList()

				localctx.(*DataDescContext).partition = _x
			}

		}
		p.SetState(2777)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 370, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2773)
				p.Match(DorisParserCOLUMNS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2774)
				p.Match(DorisParserTERMINATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2775)
				p.Match(DorisParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2776)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*DataDescContext).comma = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2783)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLINES {
			{
				p.SetState(2779)
				p.Match(DorisParserLINES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2780)
				p.Match(DorisParserTERMINATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2781)
				p.Match(DorisParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2782)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*DataDescContext).separator = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2788)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFORMAT {
			{
				p.SetState(2785)
				p.Match(DorisParserFORMAT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2786)
				p.Match(DorisParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2787)

				var _x = p.IdentifierOrText()

				localctx.(*DataDescContext).format = _x
			}

		}
		p.SetState(2791)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(2790)

				var _x = p.IdentifierList()

				localctx.(*DataDescContext).columns = _x
			}

		}
		p.SetState(2794)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOLUMNS {
			{
				p.SetState(2793)

				var _x = p.ColFromPath()

				localctx.(*DataDescContext).columnsFromPath = _x
			}

		}
		p.SetState(2797)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserSET {
			{
				p.SetState(2796)

				var _x = p.ColMappingList()

				localctx.(*DataDescContext).columnMapping = _x
			}

		}
		p.SetState(2800)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPRECEDING {
			{
				p.SetState(2799)

				var _x = p.PreFilterClause()

				localctx.(*DataDescContext).preFilter = _x
			}

		}
		p.SetState(2803)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWHERE {
			{
				p.SetState(2802)

				var _x = p.WhereClause()

				localctx.(*DataDescContext).where = _x
			}

		}
		p.SetState(2806)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserDELETE {
			{
				p.SetState(2805)

				var _x = p.DeleteOnClause()

				localctx.(*DataDescContext).deleteOn = _x
			}

		}
		p.SetState(2809)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserORDER {
			{
				p.SetState(2808)

				var _x = p.SequenceColClause()

				localctx.(*DataDescContext).sequenceColumn = _x
			}

		}
		p.SetState(2812)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2811)
				p.PropertyClause()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2818)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAPPEND || _la == DorisParserDELETE || _la == DorisParserMERGE || _la == DorisParserWITH {
			p.SetState(2815)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserWITH {
				{
					p.SetState(2814)
					p.Match(DorisParserWITH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(2817)
				p.MergeType()
			}

		}
		{
			p.SetState(2820)
			p.Match(DorisParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2821)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2822)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2823)

			var _x = p.MultipartIdentifier()

			localctx.(*DataDescContext).tableName = _x
		}
		{
			p.SetState(2824)
			p.Match(DorisParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2825)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2826)

			var _x = p.MultipartIdentifier()

			localctx.(*DataDescContext).tableName = _x
		}
		p.SetState(2829)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION {
			{
				p.SetState(2827)
				p.Match(DorisParserPARTITION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2828)

				var _x = p.IdentifierList()

				localctx.(*DataDescContext).partition = _x
			}

		}
		p.SetState(2832)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserSET {
			{
				p.SetState(2831)

				var _x = p.ColMappingList()

				localctx.(*DataDescContext).columnMapping = _x
			}

		}
		p.SetState(2835)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWHERE {
			{
				p.SetState(2834)

				var _x = p.WhereClause()

				localctx.(*DataDescContext).where = _x
			}

		}
		p.SetState(2838)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserDELETE {
			{
				p.SetState(2837)

				var _x = p.DeleteOnClause()

				localctx.(*DataDescContext).deleteOn = _x
			}

		}
		p.SetState(2841)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2840)
				p.PropertyClause()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBuildModeContext is an interface to support dynamic dispatch.
type IBuildModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BUILD() antlr.TerminalNode
	IMMEDIATE() antlr.TerminalNode
	DEFERRED() antlr.TerminalNode

	// IsBuildModeContext differentiates from other interfaces.
	IsBuildModeContext()
}

type BuildModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBuildModeContext() *BuildModeContext {
	var p = new(BuildModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_buildMode
	return p
}

func InitEmptyBuildModeContext(p *BuildModeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_buildMode
}

func (*BuildModeContext) IsBuildModeContext() {}

func NewBuildModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BuildModeContext {
	var p = new(BuildModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_buildMode

	return p
}

func (s *BuildModeContext) GetParser() antlr.Parser { return s.parser }

func (s *BuildModeContext) BUILD() antlr.TerminalNode {
	return s.GetToken(DorisParserBUILD, 0)
}

func (s *BuildModeContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(DorisParserIMMEDIATE, 0)
}

func (s *BuildModeContext) DEFERRED() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFERRED, 0)
}

func (s *BuildModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BuildModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BuildModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBuildMode(s)
	}
}

func (s *BuildModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBuildMode(s)
	}
}

func (p *DorisParser) BuildMode() (localctx IBuildModeContext) {
	localctx = NewBuildModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, DorisParserRULE_buildMode)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2845)
		p.Match(DorisParserBUILD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2846)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserDEFERRED || _la == DorisParserIMMEDIATE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshTriggerContext is an interface to support dynamic dispatch.
type IRefreshTriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	MANUAL() antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	RefreshSchedule() IRefreshScheduleContext
	COMMIT() antlr.TerminalNode

	// IsRefreshTriggerContext differentiates from other interfaces.
	IsRefreshTriggerContext()
}

type RefreshTriggerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefreshTriggerContext() *RefreshTriggerContext {
	var p = new(RefreshTriggerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_refreshTrigger
	return p
}

func InitEmptyRefreshTriggerContext(p *RefreshTriggerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_refreshTrigger
}

func (*RefreshTriggerContext) IsRefreshTriggerContext() {}

func NewRefreshTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshTriggerContext {
	var p = new(RefreshTriggerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_refreshTrigger

	return p
}

func (s *RefreshTriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshTriggerContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *RefreshTriggerContext) MANUAL() antlr.TerminalNode {
	return s.GetToken(DorisParserMANUAL, 0)
}

func (s *RefreshTriggerContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEDULE, 0)
}

func (s *RefreshTriggerContext) RefreshSchedule() IRefreshScheduleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshScheduleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshScheduleContext)
}

func (s *RefreshTriggerContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMIT, 0)
}

func (s *RefreshTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshTriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRefreshTrigger(s)
	}
}

func (s *RefreshTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRefreshTrigger(s)
	}
}

func (p *DorisParser) RefreshTrigger() (localctx IRefreshTriggerContext) {
	localctx = NewRefreshTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, DorisParserRULE_refreshTrigger)
	p.SetState(2855)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 389, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2848)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2849)
			p.Match(DorisParserMANUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2850)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2851)
			p.Match(DorisParserSCHEDULE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2852)
			p.RefreshSchedule()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2853)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2854)
			p.Match(DorisParserCOMMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshScheduleContext is an interface to support dynamic dispatch.
type IRefreshScheduleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRefreshUnit returns the refreshUnit rule contexts.
	GetRefreshUnit() IIdentifierContext

	// SetRefreshUnit sets the refreshUnit rule contexts.
	SetRefreshUnit(IIdentifierContext)

	// Getter signatures
	EVERY() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	Identifier() IIdentifierContext
	STARTS() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsRefreshScheduleContext differentiates from other interfaces.
	IsRefreshScheduleContext()
}

type RefreshScheduleContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	refreshUnit IIdentifierContext
}

func NewEmptyRefreshScheduleContext() *RefreshScheduleContext {
	var p = new(RefreshScheduleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_refreshSchedule
	return p
}

func InitEmptyRefreshScheduleContext(p *RefreshScheduleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_refreshSchedule
}

func (*RefreshScheduleContext) IsRefreshScheduleContext() {}

func NewRefreshScheduleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshScheduleContext {
	var p = new(RefreshScheduleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_refreshSchedule

	return p
}

func (s *RefreshScheduleContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshScheduleContext) GetRefreshUnit() IIdentifierContext { return s.refreshUnit }

func (s *RefreshScheduleContext) SetRefreshUnit(v IIdentifierContext) { s.refreshUnit = v }

func (s *RefreshScheduleContext) EVERY() antlr.TerminalNode {
	return s.GetToken(DorisParserEVERY, 0)
}

func (s *RefreshScheduleContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *RefreshScheduleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RefreshScheduleContext) STARTS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTARTS, 0)
}

func (s *RefreshScheduleContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *RefreshScheduleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshScheduleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshScheduleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRefreshSchedule(s)
	}
}

func (s *RefreshScheduleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRefreshSchedule(s)
	}
}

func (p *DorisParser) RefreshSchedule() (localctx IRefreshScheduleContext) {
	localctx = NewRefreshScheduleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, DorisParserRULE_refreshSchedule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2857)
		p.Match(DorisParserEVERY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2858)
		p.Match(DorisParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2859)

		var _x = p.Identifier()

		localctx.(*RefreshScheduleContext).refreshUnit = _x
	}
	p.SetState(2862)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserSTARTS {
		{
			p.SetState(2860)
			p.Match(DorisParserSTARTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2861)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshMethodContext is an interface to support dynamic dispatch.
type IRefreshMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMPLETE() antlr.TerminalNode
	AUTO() antlr.TerminalNode

	// IsRefreshMethodContext differentiates from other interfaces.
	IsRefreshMethodContext()
}

type RefreshMethodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefreshMethodContext() *RefreshMethodContext {
	var p = new(RefreshMethodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_refreshMethod
	return p
}

func InitEmptyRefreshMethodContext(p *RefreshMethodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_refreshMethod
}

func (*RefreshMethodContext) IsRefreshMethodContext() {}

func NewRefreshMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshMethodContext {
	var p = new(RefreshMethodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_refreshMethod

	return p
}

func (s *RefreshMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshMethodContext) COMPLETE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPLETE, 0)
}

func (s *RefreshMethodContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO, 0)
}

func (s *RefreshMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshMethodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRefreshMethod(s)
	}
}

func (s *RefreshMethodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRefreshMethod(s)
	}
}

func (p *DorisParser) RefreshMethod() (localctx IRefreshMethodContext) {
	localctx = NewRefreshMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, DorisParserRULE_refreshMethod)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2864)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserAUTO || _la == DorisParserCOMPLETE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMvPartitionContext is an interface to support dynamic dispatch.
type IMvPartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionKey returns the partitionKey rule contexts.
	GetPartitionKey() IIdentifierContext

	// GetPartitionExpr returns the partitionExpr rule contexts.
	GetPartitionExpr() IFunctionCallExpressionContext

	// SetPartitionKey sets the partitionKey rule contexts.
	SetPartitionKey(IIdentifierContext)

	// SetPartitionExpr sets the partitionExpr rule contexts.
	SetPartitionExpr(IFunctionCallExpressionContext)

	// Getter signatures
	Identifier() IIdentifierContext
	FunctionCallExpression() IFunctionCallExpressionContext

	// IsMvPartitionContext differentiates from other interfaces.
	IsMvPartitionContext()
}

type MvPartitionContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	partitionKey  IIdentifierContext
	partitionExpr IFunctionCallExpressionContext
}

func NewEmptyMvPartitionContext() *MvPartitionContext {
	var p = new(MvPartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_mvPartition
	return p
}

func InitEmptyMvPartitionContext(p *MvPartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_mvPartition
}

func (*MvPartitionContext) IsMvPartitionContext() {}

func NewMvPartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MvPartitionContext {
	var p = new(MvPartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_mvPartition

	return p
}

func (s *MvPartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *MvPartitionContext) GetPartitionKey() IIdentifierContext { return s.partitionKey }

func (s *MvPartitionContext) GetPartitionExpr() IFunctionCallExpressionContext {
	return s.partitionExpr
}

func (s *MvPartitionContext) SetPartitionKey(v IIdentifierContext) { s.partitionKey = v }

func (s *MvPartitionContext) SetPartitionExpr(v IFunctionCallExpressionContext) { s.partitionExpr = v }

func (s *MvPartitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MvPartitionContext) FunctionCallExpression() IFunctionCallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallExpressionContext)
}

func (s *MvPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MvPartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MvPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMvPartition(s)
	}
}

func (s *MvPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMvPartition(s)
	}
}

func (p *DorisParser) MvPartition() (localctx IMvPartitionContext) {
	localctx = NewMvPartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, DorisParserRULE_mvPartition)
	p.SetState(2868)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 391, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2866)

			var _x = p.Identifier()

			localctx.(*MvPartitionContext).partitionKey = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2867)

			var _x = p.FunctionCallExpression()

			localctx.(*MvPartitionContext).partitionExpr = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrTextContext is an interface to support dynamic dispatch.
type IIdentifierOrTextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	STRING_LITERAL() antlr.TerminalNode

	// IsIdentifierOrTextContext differentiates from other interfaces.
	IsIdentifierOrTextContext()
}

type IdentifierOrTextContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrTextContext() *IdentifierOrTextContext {
	var p = new(IdentifierOrTextContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierOrText
	return p
}

func InitEmptyIdentifierOrTextContext(p *IdentifierOrTextContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierOrText
}

func (*IdentifierOrTextContext) IsIdentifierOrTextContext() {}

func NewIdentifierOrTextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrTextContext {
	var p = new(IdentifierOrTextContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_identifierOrText

	return p
}

func (s *IdentifierOrTextContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrTextContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierOrTextContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *IdentifierOrTextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrTextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrTextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIdentifierOrText(s)
	}
}

func (s *IdentifierOrTextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIdentifierOrText(s)
	}
}

func (p *DorisParser) IdentifierOrText() (localctx IIdentifierOrTextContext) {
	localctx = NewIdentifierOrTextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, DorisParserRULE_identifierOrText)
	p.SetState(2872)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADDDATE, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserARRAY_RANGE, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATE_ADD, DorisParserDATE_CEIL, DorisParserDATE_DIFF, DorisParserDATE_FLOOR, DorisParserDATE_SUB, DorisParserDATEADD, DorisParserDATEDIFF, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS_ADD, DorisParserDAYS_SUB, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSEQUENCE, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUBDATE, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTIMESTAMPADD, DorisParserTIMESTAMPDIFF, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2870)
			p.Identifier()
		}

	case DorisParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2871)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrTextOrAsteriskContext is an interface to support dynamic dispatch.
type IIdentifierOrTextOrAsteriskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	STRING_LITERAL() antlr.TerminalNode
	ASTERISK() antlr.TerminalNode

	// IsIdentifierOrTextOrAsteriskContext differentiates from other interfaces.
	IsIdentifierOrTextOrAsteriskContext()
}

type IdentifierOrTextOrAsteriskContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrTextOrAsteriskContext() *IdentifierOrTextOrAsteriskContext {
	var p = new(IdentifierOrTextOrAsteriskContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierOrTextOrAsterisk
	return p
}

func InitEmptyIdentifierOrTextOrAsteriskContext(p *IdentifierOrTextOrAsteriskContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierOrTextOrAsterisk
}

func (*IdentifierOrTextOrAsteriskContext) IsIdentifierOrTextOrAsteriskContext() {}

func NewIdentifierOrTextOrAsteriskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrTextOrAsteriskContext {
	var p = new(IdentifierOrTextOrAsteriskContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_identifierOrTextOrAsterisk

	return p
}

func (s *IdentifierOrTextOrAsteriskContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrTextOrAsteriskContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierOrTextOrAsteriskContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *IdentifierOrTextOrAsteriskContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserASTERISK, 0)
}

func (s *IdentifierOrTextOrAsteriskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrTextOrAsteriskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrTextOrAsteriskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIdentifierOrTextOrAsterisk(s)
	}
}

func (s *IdentifierOrTextOrAsteriskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIdentifierOrTextOrAsterisk(s)
	}
}

func (p *DorisParser) IdentifierOrTextOrAsterisk() (localctx IIdentifierOrTextOrAsteriskContext) {
	localctx = NewIdentifierOrTextOrAsteriskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, DorisParserRULE_identifierOrTextOrAsterisk)
	p.SetState(2877)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADDDATE, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserARRAY_RANGE, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATE_ADD, DorisParserDATE_CEIL, DorisParserDATE_DIFF, DorisParserDATE_FLOOR, DorisParserDATE_SUB, DorisParserDATEADD, DorisParserDATEDIFF, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS_ADD, DorisParserDAYS_SUB, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSEQUENCE, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUBDATE, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTIMESTAMPADD, DorisParserTIMESTAMPDIFF, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2874)
			p.Identifier()
		}

	case DorisParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2875)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserASTERISK:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2876)
			p.Match(DorisParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultipartIdentifierOrAsteriskContext is an interface to support dynamic dispatch.
type IMultipartIdentifierOrAsteriskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_identifierOrAsterisk returns the _identifierOrAsterisk rule contexts.
	Get_identifierOrAsterisk() IIdentifierOrAsteriskContext

	// Set_identifierOrAsterisk sets the _identifierOrAsterisk rule contexts.
	Set_identifierOrAsterisk(IIdentifierOrAsteriskContext)

	// GetParts returns the parts rule context list.
	GetParts() []IIdentifierOrAsteriskContext

	// SetParts sets the parts rule context list.
	SetParts([]IIdentifierOrAsteriskContext)

	// Getter signatures
	AllIdentifierOrAsterisk() []IIdentifierOrAsteriskContext
	IdentifierOrAsterisk(i int) IIdentifierOrAsteriskContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsMultipartIdentifierOrAsteriskContext differentiates from other interfaces.
	IsMultipartIdentifierOrAsteriskContext()
}

type MultipartIdentifierOrAsteriskContext struct {
	antlr.BaseParserRuleContext
	parser                antlr.Parser
	_identifierOrAsterisk IIdentifierOrAsteriskContext
	parts                 []IIdentifierOrAsteriskContext
}

func NewEmptyMultipartIdentifierOrAsteriskContext() *MultipartIdentifierOrAsteriskContext {
	var p = new(MultipartIdentifierOrAsteriskContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_multipartIdentifierOrAsterisk
	return p
}

func InitEmptyMultipartIdentifierOrAsteriskContext(p *MultipartIdentifierOrAsteriskContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_multipartIdentifierOrAsterisk
}

func (*MultipartIdentifierOrAsteriskContext) IsMultipartIdentifierOrAsteriskContext() {}

func NewMultipartIdentifierOrAsteriskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipartIdentifierOrAsteriskContext {
	var p = new(MultipartIdentifierOrAsteriskContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_multipartIdentifierOrAsterisk

	return p
}

func (s *MultipartIdentifierOrAsteriskContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipartIdentifierOrAsteriskContext) Get_identifierOrAsterisk() IIdentifierOrAsteriskContext {
	return s._identifierOrAsterisk
}

func (s *MultipartIdentifierOrAsteriskContext) Set_identifierOrAsterisk(v IIdentifierOrAsteriskContext) {
	s._identifierOrAsterisk = v
}

func (s *MultipartIdentifierOrAsteriskContext) GetParts() []IIdentifierOrAsteriskContext {
	return s.parts
}

func (s *MultipartIdentifierOrAsteriskContext) SetParts(v []IIdentifierOrAsteriskContext) {
	s.parts = v
}

func (s *MultipartIdentifierOrAsteriskContext) AllIdentifierOrAsterisk() []IIdentifierOrAsteriskContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrAsteriskContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrAsteriskContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrAsteriskContext); ok {
			tst[i] = t.(IIdentifierOrAsteriskContext)
			i++
		}
	}

	return tst
}

func (s *MultipartIdentifierOrAsteriskContext) IdentifierOrAsterisk(i int) IIdentifierOrAsteriskContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrAsteriskContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrAsteriskContext)
}

func (s *MultipartIdentifierOrAsteriskContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(DorisParserDOT)
}

func (s *MultipartIdentifierOrAsteriskContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, i)
}

func (s *MultipartIdentifierOrAsteriskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipartIdentifierOrAsteriskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipartIdentifierOrAsteriskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMultipartIdentifierOrAsterisk(s)
	}
}

func (s *MultipartIdentifierOrAsteriskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMultipartIdentifierOrAsterisk(s)
	}
}

func (p *DorisParser) MultipartIdentifierOrAsterisk() (localctx IMultipartIdentifierOrAsteriskContext) {
	localctx = NewMultipartIdentifierOrAsteriskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, DorisParserRULE_multipartIdentifierOrAsterisk)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2879)

		var _x = p.IdentifierOrAsterisk()

		localctx.(*MultipartIdentifierOrAsteriskContext)._identifierOrAsterisk = _x
	}
	localctx.(*MultipartIdentifierOrAsteriskContext).parts = append(localctx.(*MultipartIdentifierOrAsteriskContext).parts, localctx.(*MultipartIdentifierOrAsteriskContext)._identifierOrAsterisk)
	p.SetState(2884)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserDOT {
		{
			p.SetState(2880)
			p.Match(DorisParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2881)

			var _x = p.IdentifierOrAsterisk()

			localctx.(*MultipartIdentifierOrAsteriskContext)._identifierOrAsterisk = _x
		}
		localctx.(*MultipartIdentifierOrAsteriskContext).parts = append(localctx.(*MultipartIdentifierOrAsteriskContext).parts, localctx.(*MultipartIdentifierOrAsteriskContext)._identifierOrAsterisk)

		p.SetState(2886)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrAsteriskContext is an interface to support dynamic dispatch.
type IIdentifierOrAsteriskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierOrText() IIdentifierOrTextContext
	ASTERISK() antlr.TerminalNode

	// IsIdentifierOrAsteriskContext differentiates from other interfaces.
	IsIdentifierOrAsteriskContext()
}

type IdentifierOrAsteriskContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrAsteriskContext() *IdentifierOrAsteriskContext {
	var p = new(IdentifierOrAsteriskContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierOrAsterisk
	return p
}

func InitEmptyIdentifierOrAsteriskContext(p *IdentifierOrAsteriskContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierOrAsterisk
}

func (*IdentifierOrAsteriskContext) IsIdentifierOrAsteriskContext() {}

func NewIdentifierOrAsteriskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrAsteriskContext {
	var p = new(IdentifierOrAsteriskContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_identifierOrAsterisk

	return p
}

func (s *IdentifierOrAsteriskContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrAsteriskContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *IdentifierOrAsteriskContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserASTERISK, 0)
}

func (s *IdentifierOrAsteriskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrAsteriskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrAsteriskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIdentifierOrAsterisk(s)
	}
}

func (s *IdentifierOrAsteriskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIdentifierOrAsterisk(s)
	}
}

func (p *DorisParser) IdentifierOrAsterisk() (localctx IIdentifierOrAsteriskContext) {
	localctx = NewIdentifierOrAsteriskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, DorisParserRULE_identifierOrAsterisk)
	p.SetState(2889)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADDDATE, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserARRAY_RANGE, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATE_ADD, DorisParserDATE_CEIL, DorisParserDATE_DIFF, DorisParserDATE_FLOOR, DorisParserDATE_SUB, DorisParserDATEADD, DorisParserDATEDIFF, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS_ADD, DorisParserDAYS_SUB, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSEQUENCE, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUBDATE, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTIMESTAMPADD, DorisParserTIMESTAMPDIFF, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2887)
			p.IdentifierOrText()
		}

	case DorisParserASTERISK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2888)
			p.Match(DorisParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserIdentifyContext is an interface to support dynamic dispatch.
type IUserIdentifyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUser returns the user rule contexts.
	GetUser() IIdentifierOrTextContext

	// GetHost returns the host rule contexts.
	GetHost() IIdentifierOrTextContext

	// SetUser sets the user rule contexts.
	SetUser(IIdentifierOrTextContext)

	// SetHost sets the host rule contexts.
	SetHost(IIdentifierOrTextContext)

	// Getter signatures
	AllIdentifierOrText() []IIdentifierOrTextContext
	IdentifierOrText(i int) IIdentifierOrTextContext
	ATSIGN() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode

	// IsUserIdentifyContext differentiates from other interfaces.
	IsUserIdentifyContext()
}

type UserIdentifyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	user   IIdentifierOrTextContext
	host   IIdentifierOrTextContext
}

func NewEmptyUserIdentifyContext() *UserIdentifyContext {
	var p = new(UserIdentifyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_userIdentify
	return p
}

func InitEmptyUserIdentifyContext(p *UserIdentifyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_userIdentify
}

func (*UserIdentifyContext) IsUserIdentifyContext() {}

func NewUserIdentifyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserIdentifyContext {
	var p = new(UserIdentifyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_userIdentify

	return p
}

func (s *UserIdentifyContext) GetParser() antlr.Parser { return s.parser }

func (s *UserIdentifyContext) GetUser() IIdentifierOrTextContext { return s.user }

func (s *UserIdentifyContext) GetHost() IIdentifierOrTextContext { return s.host }

func (s *UserIdentifyContext) SetUser(v IIdentifierOrTextContext) { s.user = v }

func (s *UserIdentifyContext) SetHost(v IIdentifierOrTextContext) { s.host = v }

func (s *UserIdentifyContext) AllIdentifierOrText() []IIdentifierOrTextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrTextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrTextContext); ok {
			tst[i] = t.(IIdentifierOrTextContext)
			i++
		}
	}

	return tst
}

func (s *UserIdentifyContext) IdentifierOrText(i int) IIdentifierOrTextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *UserIdentifyContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserATSIGN, 0)
}

func (s *UserIdentifyContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *UserIdentifyContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *UserIdentifyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserIdentifyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserIdentifyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUserIdentify(s)
	}
}

func (s *UserIdentifyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUserIdentify(s)
	}
}

func (p *DorisParser) UserIdentify() (localctx IUserIdentifyContext) {
	localctx = NewUserIdentifyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, DorisParserRULE_userIdentify)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2891)

		var _x = p.IdentifierOrText()

		localctx.(*UserIdentifyContext).user = _x
	}
	p.SetState(2900)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserATSIGN {
		{
			p.SetState(2892)
			p.Match(DorisParserATSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2898)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADDDATE, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserARRAY_RANGE, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATE_ADD, DorisParserDATE_CEIL, DorisParserDATE_DIFF, DorisParserDATE_FLOOR, DorisParserDATE_SUB, DorisParserDATEADD, DorisParserDATEDIFF, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS_ADD, DorisParserDAYS_SUB, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSEQUENCE, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUBDATE, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTIMESTAMPADD, DorisParserTIMESTAMPDIFF, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(2893)

				var _x = p.IdentifierOrText()

				localctx.(*UserIdentifyContext).host = _x
			}

		case DorisParserLEFT_PAREN:
			{
				p.SetState(2894)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2895)

				var _x = p.IdentifierOrText()

				localctx.(*UserIdentifyContext).host = _x
			}
			{
				p.SetState(2896)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantUserIdentifyContext is an interface to support dynamic dispatch.
type IGrantUserIdentifyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserIdentify() IUserIdentifyContext
	IDENTIFIED() antlr.TerminalNode
	BY() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode

	// IsGrantUserIdentifyContext differentiates from other interfaces.
	IsGrantUserIdentifyContext()
}

type GrantUserIdentifyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantUserIdentifyContext() *GrantUserIdentifyContext {
	var p = new(GrantUserIdentifyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_grantUserIdentify
	return p
}

func InitEmptyGrantUserIdentifyContext(p *GrantUserIdentifyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_grantUserIdentify
}

func (*GrantUserIdentifyContext) IsGrantUserIdentifyContext() {}

func NewGrantUserIdentifyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantUserIdentifyContext {
	var p = new(GrantUserIdentifyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_grantUserIdentify

	return p
}

func (s *GrantUserIdentifyContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantUserIdentifyContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *GrantUserIdentifyContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(DorisParserIDENTIFIED, 0)
}

func (s *GrantUserIdentifyContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *GrantUserIdentifyContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *GrantUserIdentifyContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD, 0)
}

func (s *GrantUserIdentifyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantUserIdentifyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantUserIdentifyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterGrantUserIdentify(s)
	}
}

func (s *GrantUserIdentifyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitGrantUserIdentify(s)
	}
}

func (p *DorisParser) GrantUserIdentify() (localctx IGrantUserIdentifyContext) {
	localctx = NewGrantUserIdentifyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, DorisParserRULE_grantUserIdentify)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2902)
		p.UserIdentify()
	}
	p.SetState(2909)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserIDENTIFIED {
		{
			p.SetState(2903)
			p.Match(DorisParserIDENTIFIED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2904)
			p.Match(DorisParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2906)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPASSWORD {
			{
				p.SetState(2905)
				p.Match(DorisParserPASSWORD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2908)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplainContext is an interface to support dynamic dispatch.
type IExplainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLevel returns the level token.
	GetLevel() antlr.Token

	// SetLevel sets the level token.
	SetLevel(antlr.Token)

	// Getter signatures
	ExplainCommand() IExplainCommandContext
	PlanType() IPlanTypeContext
	PROCESS() antlr.TerminalNode
	VERBOSE() antlr.TerminalNode
	TREE() antlr.TerminalNode
	GRAPH() antlr.TerminalNode
	PLAN() antlr.TerminalNode

	// IsExplainContext differentiates from other interfaces.
	IsExplainContext()
}

type ExplainContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	level  antlr.Token
}

func NewEmptyExplainContext() *ExplainContext {
	var p = new(ExplainContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_explain
	return p
}

func InitEmptyExplainContext(p *ExplainContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_explain
}

func (*ExplainContext) IsExplainContext() {}

func NewExplainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainContext {
	var p = new(ExplainContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_explain

	return p
}

func (s *ExplainContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainContext) GetLevel() antlr.Token { return s.level }

func (s *ExplainContext) SetLevel(v antlr.Token) { s.level = v }

func (s *ExplainContext) ExplainCommand() IExplainCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainCommandContext)
}

func (s *ExplainContext) PlanType() IPlanTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPlanTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPlanTypeContext)
}

func (s *ExplainContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(DorisParserPROCESS, 0)
}

func (s *ExplainContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserVERBOSE, 0)
}

func (s *ExplainContext) TREE() antlr.TerminalNode {
	return s.GetToken(DorisParserTREE, 0)
}

func (s *ExplainContext) GRAPH() antlr.TerminalNode {
	return s.GetToken(DorisParserGRAPH, 0)
}

func (s *ExplainContext) PLAN() antlr.TerminalNode {
	return s.GetToken(DorisParserPLAN, 0)
}

func (s *ExplainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterExplain(s)
	}
}

func (s *ExplainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitExplain(s)
	}
}

func (p *DorisParser) Explain() (localctx IExplainContext) {
	localctx = NewExplainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, DorisParserRULE_explain)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2911)
		p.ExplainCommand()
	}
	p.SetState(2913)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserALL || _la == DorisParserANALYZED || _la == DorisParserDISTRIBUTED || ((int64((_la-273)) & ^0x3f) == 0 && ((int64(1)<<(_la-273))&-9222241738901405695) != 0) || _la == DorisParserREWRITTEN || _la == DorisParserSHAPE {
		{
			p.SetState(2912)
			p.PlanType()
		}

	}
	p.SetState(2916)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserGRAPH || _la == DorisParserPLAN || _la == DorisParserTREE || _la == DorisParserVERBOSE {
		{
			p.SetState(2915)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ExplainContext).level = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserGRAPH || _la == DorisParserPLAN || _la == DorisParserTREE || _la == DorisParserVERBOSE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ExplainContext).level = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(2919)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPROCESS {
		{
			p.SetState(2918)
			p.Match(DorisParserPROCESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplainCommandContext is an interface to support dynamic dispatch.
type IExplainCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXPLAIN() antlr.TerminalNode
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode

	// IsExplainCommandContext differentiates from other interfaces.
	IsExplainCommandContext()
}

type ExplainCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainCommandContext() *ExplainCommandContext {
	var p = new(ExplainCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_explainCommand
	return p
}

func InitEmptyExplainCommandContext(p *ExplainCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_explainCommand
}

func (*ExplainCommandContext) IsExplainCommandContext() {}

func NewExplainCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainCommandContext {
	var p = new(ExplainCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_explainCommand

	return p
}

func (s *ExplainCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainCommandContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(DorisParserEXPLAIN, 0)
}

func (s *ExplainCommandContext) DESC() antlr.TerminalNode {
	return s.GetToken(DorisParserDESC, 0)
}

func (s *ExplainCommandContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(DorisParserDESCRIBE, 0)
}

func (s *ExplainCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplainCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterExplainCommand(s)
	}
}

func (s *ExplainCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitExplainCommand(s)
	}
}

func (p *DorisParser) ExplainCommand() (localctx IExplainCommandContext) {
	localctx = NewExplainCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, DorisParserRULE_explainCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2921)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&34359738371) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPlanTypeContext is an interface to support dynamic dispatch.
type IPlanTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARSED() antlr.TerminalNode
	ANALYZED() antlr.TerminalNode
	REWRITTEN() antlr.TerminalNode
	LOGICAL() antlr.TerminalNode
	OPTIMIZED() antlr.TerminalNode
	PHYSICAL() antlr.TerminalNode
	SHAPE() antlr.TerminalNode
	MEMO() antlr.TerminalNode
	DISTRIBUTED() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsPlanTypeContext differentiates from other interfaces.
	IsPlanTypeContext()
}

type PlanTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPlanTypeContext() *PlanTypeContext {
	var p = new(PlanTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_planType
	return p
}

func InitEmptyPlanTypeContext(p *PlanTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_planType
}

func (*PlanTypeContext) IsPlanTypeContext() {}

func NewPlanTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PlanTypeContext {
	var p = new(PlanTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_planType

	return p
}

func (s *PlanTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PlanTypeContext) PARSED() antlr.TerminalNode {
	return s.GetToken(DorisParserPARSED, 0)
}

func (s *PlanTypeContext) ANALYZED() antlr.TerminalNode {
	return s.GetToken(DorisParserANALYZED, 0)
}

func (s *PlanTypeContext) REWRITTEN() antlr.TerminalNode {
	return s.GetToken(DorisParserREWRITTEN, 0)
}

func (s *PlanTypeContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOGICAL, 0)
}

func (s *PlanTypeContext) OPTIMIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserOPTIMIZED, 0)
}

func (s *PlanTypeContext) PHYSICAL() antlr.TerminalNode {
	return s.GetToken(DorisParserPHYSICAL, 0)
}

func (s *PlanTypeContext) SHAPE() antlr.TerminalNode {
	return s.GetToken(DorisParserSHAPE, 0)
}

func (s *PlanTypeContext) MEMO() antlr.TerminalNode {
	return s.GetToken(DorisParserMEMO, 0)
}

func (s *PlanTypeContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTRIBUTED, 0)
}

func (s *PlanTypeContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *PlanTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PlanTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PlanTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPlanType(s)
	}
}

func (s *PlanTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPlanType(s)
	}
}

func (p *DorisParser) PlanType() (localctx IPlanTypeContext) {
	localctx = NewPlanTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, DorisParserRULE_planType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2923)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserALL || _la == DorisParserANALYZED || _la == DorisParserDISTRIBUTED || ((int64((_la-273)) & ^0x3f) == 0 && ((int64(1)<<(_la-273))&-9222241738901405695) != 0) || _la == DorisParserREWRITTEN || _la == DorisParserSHAPE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMergeTypeContext is an interface to support dynamic dispatch.
type IMergeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	APPEND() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	MERGE() antlr.TerminalNode

	// IsMergeTypeContext differentiates from other interfaces.
	IsMergeTypeContext()
}

type MergeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeTypeContext() *MergeTypeContext {
	var p = new(MergeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_mergeType
	return p
}

func InitEmptyMergeTypeContext(p *MergeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_mergeType
}

func (*MergeTypeContext) IsMergeTypeContext() {}

func NewMergeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeTypeContext {
	var p = new(MergeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_mergeType

	return p
}

func (s *MergeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeTypeContext) APPEND() antlr.TerminalNode {
	return s.GetToken(DorisParserAPPEND, 0)
}

func (s *MergeTypeContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisParserDELETE, 0)
}

func (s *MergeTypeContext) MERGE() antlr.TerminalNode {
	return s.GetToken(DorisParserMERGE, 0)
}

func (s *MergeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMergeType(s)
	}
}

func (s *MergeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMergeType(s)
	}
}

func (p *DorisParser) MergeType() (localctx IMergeTypeContext) {
	localctx = NewMergeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, DorisParserRULE_mergeType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2925)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserAPPEND || _la == DorisParserDELETE || _la == DorisParserMERGE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPreFilterClauseContext is an interface to support dynamic dispatch.
type IPreFilterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRECEDING() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	Expression() IExpressionContext

	// IsPreFilterClauseContext differentiates from other interfaces.
	IsPreFilterClauseContext()
}

type PreFilterClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreFilterClauseContext() *PreFilterClauseContext {
	var p = new(PreFilterClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_preFilterClause
	return p
}

func InitEmptyPreFilterClauseContext(p *PreFilterClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_preFilterClause
}

func (*PreFilterClauseContext) IsPreFilterClauseContext() {}

func NewPreFilterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PreFilterClauseContext {
	var p = new(PreFilterClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_preFilterClause

	return p
}

func (s *PreFilterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PreFilterClauseContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(DorisParserPRECEDING, 0)
}

func (s *PreFilterClauseContext) FILTER() antlr.TerminalNode {
	return s.GetToken(DorisParserFILTER, 0)
}

func (s *PreFilterClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PreFilterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreFilterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PreFilterClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPreFilterClause(s)
	}
}

func (s *PreFilterClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPreFilterClause(s)
	}
}

func (p *DorisParser) PreFilterClause() (localctx IPreFilterClauseContext) {
	localctx = NewPreFilterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, DorisParserRULE_preFilterClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2927)
		p.Match(DorisParserPRECEDING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2928)
		p.Match(DorisParserFILTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2929)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteOnClauseContext is an interface to support dynamic dispatch.
type IDeleteOnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	ON() antlr.TerminalNode
	Expression() IExpressionContext

	// IsDeleteOnClauseContext differentiates from other interfaces.
	IsDeleteOnClauseContext()
}

type DeleteOnClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteOnClauseContext() *DeleteOnClauseContext {
	var p = new(DeleteOnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_deleteOnClause
	return p
}

func InitEmptyDeleteOnClauseContext(p *DeleteOnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_deleteOnClause
}

func (*DeleteOnClauseContext) IsDeleteOnClauseContext() {}

func NewDeleteOnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteOnClauseContext {
	var p = new(DeleteOnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_deleteOnClause

	return p
}

func (s *DeleteOnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteOnClauseContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisParserDELETE, 0)
}

func (s *DeleteOnClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *DeleteOnClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DeleteOnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteOnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteOnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDeleteOnClause(s)
	}
}

func (s *DeleteOnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDeleteOnClause(s)
	}
}

func (p *DorisParser) DeleteOnClause() (localctx IDeleteOnClauseContext) {
	localctx = NewDeleteOnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, DorisParserRULE_deleteOnClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2931)
		p.Match(DorisParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2932)
		p.Match(DorisParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2933)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISequenceColClauseContext is an interface to support dynamic dispatch.
type ISequenceColClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsSequenceColClauseContext differentiates from other interfaces.
	IsSequenceColClauseContext()
}

type SequenceColClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequenceColClauseContext() *SequenceColClauseContext {
	var p = new(SequenceColClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sequenceColClause
	return p
}

func InitEmptySequenceColClauseContext(p *SequenceColClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sequenceColClause
}

func (*SequenceColClauseContext) IsSequenceColClauseContext() {}

func NewSequenceColClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SequenceColClauseContext {
	var p = new(SequenceColClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_sequenceColClause

	return p
}

func (s *SequenceColClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SequenceColClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisParserORDER, 0)
}

func (s *SequenceColClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *SequenceColClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SequenceColClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SequenceColClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SequenceColClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSequenceColClause(s)
	}
}

func (s *SequenceColClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSequenceColClause(s)
	}
}

func (p *DorisParser) SequenceColClause() (localctx ISequenceColClauseContext) {
	localctx = NewSequenceColClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, DorisParserRULE_sequenceColClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2935)
		p.Match(DorisParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2936)
		p.Match(DorisParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2937)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColFromPathContext is an interface to support dynamic dispatch.
type IColFromPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLUMNS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	PATH() antlr.TerminalNode
	AS() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsColFromPathContext differentiates from other interfaces.
	IsColFromPathContext()
}

type ColFromPathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColFromPathContext() *ColFromPathContext {
	var p = new(ColFromPathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_colFromPath
	return p
}

func InitEmptyColFromPathContext(p *ColFromPathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_colFromPath
}

func (*ColFromPathContext) IsColFromPathContext() {}

func NewColFromPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColFromPathContext {
	var p = new(ColFromPathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_colFromPath

	return p
}

func (s *ColFromPathContext) GetParser() antlr.Parser { return s.parser }

func (s *ColFromPathContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMNS, 0)
}

func (s *ColFromPathContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ColFromPathContext) PATH() antlr.TerminalNode {
	return s.GetToken(DorisParserPATH, 0)
}

func (s *ColFromPathContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *ColFromPathContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ColFromPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColFromPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColFromPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterColFromPath(s)
	}
}

func (s *ColFromPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitColFromPath(s)
	}
}

func (p *DorisParser) ColFromPath() (localctx IColFromPathContext) {
	localctx = NewColFromPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, DorisParserRULE_colFromPath)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2939)
		p.Match(DorisParserCOLUMNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2940)
		p.Match(DorisParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2941)
		p.Match(DorisParserPATH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2942)
		p.Match(DorisParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2943)
		p.IdentifierList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColMappingListContext is an interface to support dynamic dispatch.
type IColMappingListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_mappingExpr returns the _mappingExpr rule contexts.
	Get_mappingExpr() IMappingExprContext

	// Set_mappingExpr sets the _mappingExpr rule contexts.
	Set_mappingExpr(IMappingExprContext)

	// GetMappingSet returns the mappingSet rule context list.
	GetMappingSet() []IMappingExprContext

	// SetMappingSet sets the mappingSet rule context list.
	SetMappingSet([]IMappingExprContext)

	// Getter signatures
	SET() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllMappingExpr() []IMappingExprContext
	MappingExpr(i int) IMappingExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColMappingListContext differentiates from other interfaces.
	IsColMappingListContext()
}

type ColMappingListContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	_mappingExpr IMappingExprContext
	mappingSet   []IMappingExprContext
}

func NewEmptyColMappingListContext() *ColMappingListContext {
	var p = new(ColMappingListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_colMappingList
	return p
}

func InitEmptyColMappingListContext(p *ColMappingListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_colMappingList
}

func (*ColMappingListContext) IsColMappingListContext() {}

func NewColMappingListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColMappingListContext {
	var p = new(ColMappingListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_colMappingList

	return p
}

func (s *ColMappingListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColMappingListContext) Get_mappingExpr() IMappingExprContext { return s._mappingExpr }

func (s *ColMappingListContext) Set_mappingExpr(v IMappingExprContext) { s._mappingExpr = v }

func (s *ColMappingListContext) GetMappingSet() []IMappingExprContext { return s.mappingSet }

func (s *ColMappingListContext) SetMappingSet(v []IMappingExprContext) { s.mappingSet = v }

func (s *ColMappingListContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *ColMappingListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ColMappingListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ColMappingListContext) AllMappingExpr() []IMappingExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMappingExprContext); ok {
			len++
		}
	}

	tst := make([]IMappingExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMappingExprContext); ok {
			tst[i] = t.(IMappingExprContext)
			i++
		}
	}

	return tst
}

func (s *ColMappingListContext) MappingExpr(i int) IMappingExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMappingExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMappingExprContext)
}

func (s *ColMappingListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ColMappingListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ColMappingListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColMappingListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColMappingListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterColMappingList(s)
	}
}

func (s *ColMappingListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitColMappingList(s)
	}
}

func (p *DorisParser) ColMappingList() (localctx IColMappingListContext) {
	localctx = NewColMappingListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, DorisParserRULE_colMappingList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2945)
		p.Match(DorisParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2946)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2947)

		var _x = p.MappingExpr()

		localctx.(*ColMappingListContext)._mappingExpr = _x
	}
	localctx.(*ColMappingListContext).mappingSet = append(localctx.(*ColMappingListContext).mappingSet, localctx.(*ColMappingListContext)._mappingExpr)
	p.SetState(2952)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(2948)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2949)

			var _x = p.MappingExpr()

			localctx.(*ColMappingListContext)._mappingExpr = _x
		}
		localctx.(*ColMappingListContext).mappingSet = append(localctx.(*ColMappingListContext).mappingSet, localctx.(*ColMappingListContext)._mappingExpr)

		p.SetState(2954)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2955)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMappingExprContext is an interface to support dynamic dispatch.
type IMappingExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMappingCol returns the mappingCol rule contexts.
	GetMappingCol() IIdentifierContext

	// SetMappingCol sets the mappingCol rule contexts.
	SetMappingCol(IIdentifierContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	Expression() IExpressionContext
	Identifier() IIdentifierContext

	// IsMappingExprContext differentiates from other interfaces.
	IsMappingExprContext()
}

type MappingExprContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	mappingCol IIdentifierContext
}

func NewEmptyMappingExprContext() *MappingExprContext {
	var p = new(MappingExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_mappingExpr
	return p
}

func InitEmptyMappingExprContext(p *MappingExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_mappingExpr
}

func (*MappingExprContext) IsMappingExprContext() {}

func NewMappingExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MappingExprContext {
	var p = new(MappingExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_mappingExpr

	return p
}

func (s *MappingExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MappingExprContext) GetMappingCol() IIdentifierContext { return s.mappingCol }

func (s *MappingExprContext) SetMappingCol(v IIdentifierContext) { s.mappingCol = v }

func (s *MappingExprContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *MappingExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MappingExprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MappingExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MappingExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MappingExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMappingExpr(s)
	}
}

func (s *MappingExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMappingExpr(s)
	}
}

func (p *DorisParser) MappingExpr() (localctx IMappingExprContext) {
	localctx = NewMappingExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, DorisParserRULE_mappingExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2957)

		var _x = p.Identifier()

		localctx.(*MappingExprContext).mappingCol = _x
	}
	{
		p.SetState(2958)
		p.Match(DorisParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2959)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithRemoteStorageSystemContext is an interface to support dynamic dispatch.
type IWithRemoteStorageSystemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBrokerProperties returns the brokerProperties rule contexts.
	GetBrokerProperties() IPropertyItemListContext

	// GetBrokerName returns the brokerName rule contexts.
	GetBrokerName() IIdentifierOrTextContext

	// SetBrokerProperties sets the brokerProperties rule contexts.
	SetBrokerProperties(IPropertyItemListContext)

	// SetBrokerName sets the brokerName rule contexts.
	SetBrokerName(IIdentifierOrTextContext)

	// Getter signatures
	ResourceDesc() IResourceDescContext
	WITH() antlr.TerminalNode
	S3() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	PropertyItemList() IPropertyItemListContext
	HDFS() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	IdentifierOrText() IIdentifierOrTextContext

	// IsWithRemoteStorageSystemContext differentiates from other interfaces.
	IsWithRemoteStorageSystemContext()
}

type WithRemoteStorageSystemContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	brokerProperties IPropertyItemListContext
	brokerName       IIdentifierOrTextContext
}

func NewEmptyWithRemoteStorageSystemContext() *WithRemoteStorageSystemContext {
	var p = new(WithRemoteStorageSystemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_withRemoteStorageSystem
	return p
}

func InitEmptyWithRemoteStorageSystemContext(p *WithRemoteStorageSystemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_withRemoteStorageSystem
}

func (*WithRemoteStorageSystemContext) IsWithRemoteStorageSystemContext() {}

func NewWithRemoteStorageSystemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithRemoteStorageSystemContext {
	var p = new(WithRemoteStorageSystemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_withRemoteStorageSystem

	return p
}

func (s *WithRemoteStorageSystemContext) GetParser() antlr.Parser { return s.parser }

func (s *WithRemoteStorageSystemContext) GetBrokerProperties() IPropertyItemListContext {
	return s.brokerProperties
}

func (s *WithRemoteStorageSystemContext) GetBrokerName() IIdentifierOrTextContext {
	return s.brokerName
}

func (s *WithRemoteStorageSystemContext) SetBrokerProperties(v IPropertyItemListContext) {
	s.brokerProperties = v
}

func (s *WithRemoteStorageSystemContext) SetBrokerName(v IIdentifierOrTextContext) { s.brokerName = v }

func (s *WithRemoteStorageSystemContext) ResourceDesc() IResourceDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceDescContext)
}

func (s *WithRemoteStorageSystemContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *WithRemoteStorageSystemContext) S3() antlr.TerminalNode {
	return s.GetToken(DorisParserS3, 0)
}

func (s *WithRemoteStorageSystemContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *WithRemoteStorageSystemContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *WithRemoteStorageSystemContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *WithRemoteStorageSystemContext) HDFS() antlr.TerminalNode {
	return s.GetToken(DorisParserHDFS, 0)
}

func (s *WithRemoteStorageSystemContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *WithRemoteStorageSystemContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserBROKER, 0)
}

func (s *WithRemoteStorageSystemContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *WithRemoteStorageSystemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithRemoteStorageSystemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithRemoteStorageSystemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWithRemoteStorageSystem(s)
	}
}

func (s *WithRemoteStorageSystemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWithRemoteStorageSystem(s)
	}
}

func (p *DorisParser) WithRemoteStorageSystem() (localctx IWithRemoteStorageSystemContext) {
	localctx = NewWithRemoteStorageSystemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, DorisParserRULE_withRemoteStorageSystem)
	var _la int

	p.SetState(2989)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 405, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2961)
			p.ResourceDesc()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2962)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2963)
			p.Match(DorisParserS3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2964)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2965)

			var _x = p.PropertyItemList()

			localctx.(*WithRemoteStorageSystemContext).brokerProperties = _x
		}
		{
			p.SetState(2966)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2968)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2969)
			p.Match(DorisParserHDFS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2970)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2971)

			var _x = p.PropertyItemList()

			localctx.(*WithRemoteStorageSystemContext).brokerProperties = _x
		}
		{
			p.SetState(2972)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2974)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2975)
			p.Match(DorisParserLOCAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2976)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2977)

			var _x = p.PropertyItemList()

			localctx.(*WithRemoteStorageSystemContext).brokerProperties = _x
		}
		{
			p.SetState(2978)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2980)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2981)
			p.Match(DorisParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2982)

			var _x = p.IdentifierOrText()

			localctx.(*WithRemoteStorageSystemContext).brokerName = _x
		}
		p.SetState(2987)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(2983)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2984)

				var _x = p.PropertyItemList()

				localctx.(*WithRemoteStorageSystemContext).brokerProperties = _x
			}
			{
				p.SetState(2985)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceDescContext is an interface to support dynamic dispatch.
type IResourceDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResourceName returns the resourceName rule contexts.
	GetResourceName() IIdentifierOrTextContext

	// SetResourceName sets the resourceName rule contexts.
	SetResourceName(IIdentifierOrTextContext)

	// Getter signatures
	WITH() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	IdentifierOrText() IIdentifierOrTextContext
	LEFT_PAREN() antlr.TerminalNode
	PropertyItemList() IPropertyItemListContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsResourceDescContext differentiates from other interfaces.
	IsResourceDescContext()
}

type ResourceDescContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	resourceName IIdentifierOrTextContext
}

func NewEmptyResourceDescContext() *ResourceDescContext {
	var p = new(ResourceDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_resourceDesc
	return p
}

func InitEmptyResourceDescContext(p *ResourceDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_resourceDesc
}

func (*ResourceDescContext) IsResourceDescContext() {}

func NewResourceDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceDescContext {
	var p = new(ResourceDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_resourceDesc

	return p
}

func (s *ResourceDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceDescContext) GetResourceName() IIdentifierOrTextContext { return s.resourceName }

func (s *ResourceDescContext) SetResourceName(v IIdentifierOrTextContext) { s.resourceName = v }

func (s *ResourceDescContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *ResourceDescContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCE, 0)
}

func (s *ResourceDescContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *ResourceDescContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ResourceDescContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *ResourceDescContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ResourceDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterResourceDesc(s)
	}
}

func (s *ResourceDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitResourceDesc(s)
	}
}

func (p *DorisParser) ResourceDesc() (localctx IResourceDescContext) {
	localctx = NewResourceDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, DorisParserRULE_resourceDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2991)
		p.Match(DorisParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2992)
		p.Match(DorisParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2993)

		var _x = p.IdentifierOrText()

		localctx.(*ResourceDescContext).resourceName = _x
	}
	p.SetState(2998)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLEFT_PAREN {
		{
			p.SetState(2994)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2995)
			p.PropertyItemList()
		}
		{
			p.SetState(2996)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMysqlDataDescContext is an interface to support dynamic dispatch.
type IMysqlDataDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFilePath returns the filePath token.
	GetFilePath() antlr.Token

	// GetComma returns the comma token.
	GetComma() antlr.Token

	// GetSeparator returns the separator token.
	GetSeparator() antlr.Token

	// SetFilePath sets the filePath token.
	SetFilePath(antlr.Token)

	// SetComma sets the comma token.
	SetComma(antlr.Token)

	// SetSeparator sets the separator token.
	SetSeparator(antlr.Token)

	// GetTableName returns the tableName rule contexts.
	GetTableName() IMultipartIdentifierContext

	// GetPartition returns the partition rule contexts.
	GetPartition() IIdentifierListContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IIdentifierListContext

	// SetTableName sets the tableName rule contexts.
	SetTableName(IMultipartIdentifierContext)

	// SetPartition sets the partition rule contexts.
	SetPartition(IIdentifierListContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IIdentifierListContext)

	// Getter signatures
	DATA() antlr.TerminalNode
	INFILE() antlr.TerminalNode
	INTO() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext
	LOCAL() antlr.TerminalNode
	BooleanValue() IBooleanValueContext
	PARTITION() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	AllTERMINATED() []antlr.TerminalNode
	TERMINATED(i int) antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	LINES() antlr.TerminalNode
	SkipLines() ISkipLinesContext
	ColMappingList() IColMappingListContext
	PropertyClause() IPropertyClauseContext
	AllIdentifierList() []IIdentifierListContext
	IdentifierList(i int) IIdentifierListContext

	// IsMysqlDataDescContext differentiates from other interfaces.
	IsMysqlDataDescContext()
}

type MysqlDataDescContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	filePath  antlr.Token
	tableName IMultipartIdentifierContext
	partition IIdentifierListContext
	comma     antlr.Token
	separator antlr.Token
	columns   IIdentifierListContext
}

func NewEmptyMysqlDataDescContext() *MysqlDataDescContext {
	var p = new(MysqlDataDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_mysqlDataDesc
	return p
}

func InitEmptyMysqlDataDescContext(p *MysqlDataDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_mysqlDataDesc
}

func (*MysqlDataDescContext) IsMysqlDataDescContext() {}

func NewMysqlDataDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MysqlDataDescContext {
	var p = new(MysqlDataDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_mysqlDataDesc

	return p
}

func (s *MysqlDataDescContext) GetParser() antlr.Parser { return s.parser }

func (s *MysqlDataDescContext) GetFilePath() antlr.Token { return s.filePath }

func (s *MysqlDataDescContext) GetComma() antlr.Token { return s.comma }

func (s *MysqlDataDescContext) GetSeparator() antlr.Token { return s.separator }

func (s *MysqlDataDescContext) SetFilePath(v antlr.Token) { s.filePath = v }

func (s *MysqlDataDescContext) SetComma(v antlr.Token) { s.comma = v }

func (s *MysqlDataDescContext) SetSeparator(v antlr.Token) { s.separator = v }

func (s *MysqlDataDescContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *MysqlDataDescContext) GetPartition() IIdentifierListContext { return s.partition }

func (s *MysqlDataDescContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *MysqlDataDescContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *MysqlDataDescContext) SetPartition(v IIdentifierListContext) { s.partition = v }

func (s *MysqlDataDescContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *MysqlDataDescContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserDATA, 0)
}

func (s *MysqlDataDescContext) INFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserINFILE, 0)
}

func (s *MysqlDataDescContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserINTO, 0)
}

func (s *MysqlDataDescContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *MysqlDataDescContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *MysqlDataDescContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *MysqlDataDescContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *MysqlDataDescContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *MysqlDataDescContext) BooleanValue() IBooleanValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *MysqlDataDescContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *MysqlDataDescContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMNS, 0)
}

func (s *MysqlDataDescContext) AllTERMINATED() []antlr.TerminalNode {
	return s.GetTokens(DorisParserTERMINATED)
}

func (s *MysqlDataDescContext) TERMINATED(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserTERMINATED, i)
}

func (s *MysqlDataDescContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(DorisParserBY)
}

func (s *MysqlDataDescContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserBY, i)
}

func (s *MysqlDataDescContext) LINES() antlr.TerminalNode {
	return s.GetToken(DorisParserLINES, 0)
}

func (s *MysqlDataDescContext) SkipLines() ISkipLinesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkipLinesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkipLinesContext)
}

func (s *MysqlDataDescContext) ColMappingList() IColMappingListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColMappingListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColMappingListContext)
}

func (s *MysqlDataDescContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *MysqlDataDescContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *MysqlDataDescContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *MysqlDataDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MysqlDataDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MysqlDataDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMysqlDataDesc(s)
	}
}

func (s *MysqlDataDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMysqlDataDesc(s)
	}
}

func (p *DorisParser) MysqlDataDesc() (localctx IMysqlDataDescContext) {
	localctx = NewMysqlDataDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, DorisParserRULE_mysqlDataDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3000)
		p.Match(DorisParserDATA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3003)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLOCAL {
		{
			p.SetState(3001)
			p.Match(DorisParserLOCAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3002)
			p.BooleanValue()
		}

	}
	{
		p.SetState(3005)
		p.Match(DorisParserINFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3006)

		var _m = p.Match(DorisParserSTRING_LITERAL)

		localctx.(*MysqlDataDescContext).filePath = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3007)
		p.Match(DorisParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3008)
		p.Match(DorisParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3009)

		var _x = p.MultipartIdentifier()

		localctx.(*MysqlDataDescContext).tableName = _x
	}
	p.SetState(3012)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPARTITION {
		{
			p.SetState(3010)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3011)

			var _x = p.IdentifierList()

			localctx.(*MysqlDataDescContext).partition = _x
		}

	}
	p.SetState(3018)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserCOLUMNS {
		{
			p.SetState(3014)
			p.Match(DorisParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3015)
			p.Match(DorisParserTERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3016)
			p.Match(DorisParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3017)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*MysqlDataDescContext).comma = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3024)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLINES {
		{
			p.SetState(3020)
			p.Match(DorisParserLINES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3021)
			p.Match(DorisParserTERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3022)
			p.Match(DorisParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3023)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*MysqlDataDescContext).separator = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3027)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserIGNORE {
		{
			p.SetState(3026)
			p.SkipLines()
		}

	}
	p.SetState(3030)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLEFT_PAREN {
		{
			p.SetState(3029)

			var _x = p.IdentifierList()

			localctx.(*MysqlDataDescContext).columns = _x
		}

	}
	p.SetState(3033)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserSET {
		{
			p.SetState(3032)
			p.ColMappingList()
		}

	}
	p.SetState(3036)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 414, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3035)
			p.PropertyClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISkipLinesContext is an interface to support dynamic dispatch.
type ISkipLinesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLines returns the lines token.
	GetLines() antlr.Token

	// SetLines sets the lines token.
	SetLines(antlr.Token)

	// Getter signatures
	IGNORE() antlr.TerminalNode
	LINES() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	ROWS() antlr.TerminalNode

	// IsSkipLinesContext differentiates from other interfaces.
	IsSkipLinesContext()
}

type SkipLinesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	lines  antlr.Token
}

func NewEmptySkipLinesContext() *SkipLinesContext {
	var p = new(SkipLinesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_skipLines
	return p
}

func InitEmptySkipLinesContext(p *SkipLinesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_skipLines
}

func (*SkipLinesContext) IsSkipLinesContext() {}

func NewSkipLinesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SkipLinesContext {
	var p = new(SkipLinesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_skipLines

	return p
}

func (s *SkipLinesContext) GetParser() antlr.Parser { return s.parser }

func (s *SkipLinesContext) GetLines() antlr.Token { return s.lines }

func (s *SkipLinesContext) SetLines(v antlr.Token) { s.lines = v }

func (s *SkipLinesContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(DorisParserIGNORE, 0)
}

func (s *SkipLinesContext) LINES() antlr.TerminalNode {
	return s.GetToken(DorisParserLINES, 0)
}

func (s *SkipLinesContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *SkipLinesContext) ROWS() antlr.TerminalNode {
	return s.GetToken(DorisParserROWS, 0)
}

func (s *SkipLinesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SkipLinesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SkipLinesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSkipLines(s)
	}
}

func (s *SkipLinesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSkipLines(s)
	}
}

func (p *DorisParser) SkipLines() (localctx ISkipLinesContext) {
	localctx = NewSkipLinesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, DorisParserRULE_skipLines)
	p.SetState(3044)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 415, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3038)
			p.Match(DorisParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3039)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*SkipLinesContext).lines = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3040)
			p.Match(DorisParserLINES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3041)
			p.Match(DorisParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3042)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*SkipLinesContext).lines = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3043)
			p.Match(DorisParserROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOutFileClauseContext is an interface to support dynamic dispatch.
type IOutFileClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFilePath returns the filePath rule contexts.
	GetFilePath() IConstantContext

	// GetFormat returns the format rule contexts.
	GetFormat() IIdentifierContext

	// SetFilePath sets the filePath rule contexts.
	SetFilePath(IConstantContext)

	// SetFormat sets the format rule contexts.
	SetFormat(IIdentifierContext)

	// Getter signatures
	INTO() antlr.TerminalNode
	OUTFILE() antlr.TerminalNode
	Constant() IConstantContext
	FORMAT() antlr.TerminalNode
	AS() antlr.TerminalNode
	PropertyClause() IPropertyClauseContext
	Identifier() IIdentifierContext

	// IsOutFileClauseContext differentiates from other interfaces.
	IsOutFileClauseContext()
}

type OutFileClauseContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	filePath IConstantContext
	format   IIdentifierContext
}

func NewEmptyOutFileClauseContext() *OutFileClauseContext {
	var p = new(OutFileClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_outFileClause
	return p
}

func InitEmptyOutFileClauseContext(p *OutFileClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_outFileClause
}

func (*OutFileClauseContext) IsOutFileClauseContext() {}

func NewOutFileClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OutFileClauseContext {
	var p = new(OutFileClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_outFileClause

	return p
}

func (s *OutFileClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OutFileClauseContext) GetFilePath() IConstantContext { return s.filePath }

func (s *OutFileClauseContext) GetFormat() IIdentifierContext { return s.format }

func (s *OutFileClauseContext) SetFilePath(v IConstantContext) { s.filePath = v }

func (s *OutFileClauseContext) SetFormat(v IIdentifierContext) { s.format = v }

func (s *OutFileClauseContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserINTO, 0)
}

func (s *OutFileClauseContext) OUTFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserOUTFILE, 0)
}

func (s *OutFileClauseContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *OutFileClauseContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DorisParserFORMAT, 0)
}

func (s *OutFileClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *OutFileClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *OutFileClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *OutFileClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OutFileClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OutFileClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterOutFileClause(s)
	}
}

func (s *OutFileClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitOutFileClause(s)
	}
}

func (p *DorisParser) OutFileClause() (localctx IOutFileClauseContext) {
	localctx = NewOutFileClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, DorisParserRULE_outFileClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3046)
		p.Match(DorisParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3047)
		p.Match(DorisParserOUTFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3048)

		var _x = p.Constant()

		localctx.(*OutFileClauseContext).filePath = _x
	}
	p.SetState(3052)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserFORMAT {
		{
			p.SetState(3049)
			p.Match(DorisParserFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3050)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3051)

			var _x = p.Identifier()

			localctx.(*OutFileClauseContext).format = _x
		}

	}
	p.SetState(3055)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPROPERTIES {
		{
			p.SetState(3054)
			p.PropertyClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryTerm() IQueryTermContext
	QueryOrganization() IQueryOrganizationContext
	Cte() ICteContext

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_query
	return p
}

func InitEmptyQueryContext(p *QueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_query
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) QueryTerm() IQueryTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *QueryContext) QueryOrganization() IQueryOrganizationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryOrganizationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryOrganizationContext)
}

func (s *QueryContext) Cte() ICteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (p *DorisParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, DorisParserRULE_query)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3058)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserWITH {
		{
			p.SetState(3057)
			p.Cte()
		}

	}
	{
		p.SetState(3060)
		p.queryTerm(0)
	}
	{
		p.SetState(3061)
		p.QueryOrganization()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryTermContext is an interface to support dynamic dispatch.
type IQueryTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQueryTermContext differentiates from other interfaces.
	IsQueryTermContext()
}

type QueryTermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryTermContext() *QueryTermContext {
	var p = new(QueryTermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_queryTerm
	return p
}

func InitEmptyQueryTermContext(p *QueryTermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_queryTerm
}

func (*QueryTermContext) IsQueryTermContext() {}

func NewQueryTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryTermContext {
	var p = new(QueryTermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_queryTerm

	return p
}

func (s *QueryTermContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryTermContext) CopyAll(ctx *QueryTermContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QueryTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QueryTermDefaultContext struct {
	QueryTermContext
}

func NewQueryTermDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryTermDefaultContext {
	var p = new(QueryTermDefaultContext)

	InitEmptyQueryTermContext(&p.QueryTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryTermContext))

	return p
}

func (s *QueryTermDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermDefaultContext) QueryPrimary() IQueryPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryPrimaryContext)
}

func (s *QueryTermDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterQueryTermDefault(s)
	}
}

func (s *QueryTermDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitQueryTermDefault(s)
	}
}

type SetOperationContext struct {
	QueryTermContext
	left     IQueryTermContext
	operator antlr.Token
	right    IQueryTermContext
}

func NewSetOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetOperationContext {
	var p = new(SetOperationContext)

	InitEmptyQueryTermContext(&p.QueryTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryTermContext))

	return p
}

func (s *SetOperationContext) GetOperator() antlr.Token { return s.operator }

func (s *SetOperationContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *SetOperationContext) GetLeft() IQueryTermContext { return s.left }

func (s *SetOperationContext) GetRight() IQueryTermContext { return s.right }

func (s *SetOperationContext) SetLeft(v IQueryTermContext) { s.left = v }

func (s *SetOperationContext) SetRight(v IQueryTermContext) { s.right = v }

func (s *SetOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOperationContext) AllQueryTerm() []IQueryTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQueryTermContext); ok {
			len++
		}
	}

	tst := make([]IQueryTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQueryTermContext); ok {
			tst[i] = t.(IQueryTermContext)
			i++
		}
	}

	return tst
}

func (s *SetOperationContext) QueryTerm(i int) IQueryTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *SetOperationContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(DorisParserINTERSECT, 0)
}

func (s *SetOperationContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *SetOperationContext) UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserUNION, 0)
}

func (s *SetOperationContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(DorisParserEXCEPT, 0)
}

func (s *SetOperationContext) MINUS() antlr.TerminalNode {
	return s.GetToken(DorisParserMINUS, 0)
}

func (s *SetOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetOperation(s)
	}
}

func (s *SetOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetOperation(s)
	}
}

func (p *DorisParser) QueryTerm() (localctx IQueryTermContext) {
	return p.queryTerm(0)
}

func (p *DorisParser) queryTerm(_p int) (localctx IQueryTermContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewQueryTermContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IQueryTermContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 166
	p.EnterRecursionRule(localctx, 166, DorisParserRULE_queryTerm, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewQueryTermDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(3064)
		p.QueryPrimary()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(3080)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 422, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(3078)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 421, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSetOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_queryTerm)
				p.SetState(3066)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(3067)

					var _m = p.Match(DorisParserINTERSECT)

					localctx.(*SetOperationContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(3069)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisParserALL || _la == DorisParserDISTINCT {
					{
						p.SetState(3068)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(3071)

					var _x = p.queryTerm(3)

					localctx.(*SetOperationContext).right = _x
				}

			case 2:
				localctx = NewSetOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_queryTerm)
				p.SetState(3072)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(3073)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*SetOperationContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisParserEXCEPT || _la == DorisParserMINUS || _la == DorisParserUNION) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*SetOperationContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(3075)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisParserALL || _la == DorisParserDISTINCT {
					{
						p.SetState(3074)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(3077)

					var _x = p.queryTerm(2)

					localctx.(*SetOperationContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(3082)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 422, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetQuantifierContext is an interface to support dynamic dispatch.
type ISetQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTINCT() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsSetQuantifierContext differentiates from other interfaces.
	IsSetQuantifierContext()
}

type SetQuantifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetQuantifierContext() *SetQuantifierContext {
	var p = new(SetQuantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_setQuantifier
	return p
}

func InitEmptySetQuantifierContext(p *SetQuantifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_setQuantifier
}

func (*SetQuantifierContext) IsSetQuantifierContext() {}

func NewSetQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetQuantifierContext {
	var p = new(SetQuantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_setQuantifier

	return p
}

func (s *SetQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SetQuantifierContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTINCT, 0)
}

func (s *SetQuantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *SetQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetQuantifier(s)
	}
}

func (p *DorisParser) SetQuantifier() (localctx ISetQuantifierContext) {
	localctx = NewSetQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, DorisParserRULE_setQuantifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3083)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserALL || _la == DorisParserDISTINCT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryPrimaryContext is an interface to support dynamic dispatch.
type IQueryPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQueryPrimaryContext differentiates from other interfaces.
	IsQueryPrimaryContext()
}

type QueryPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryPrimaryContext() *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_queryPrimary
	return p
}

func InitEmptyQueryPrimaryContext(p *QueryPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_queryPrimary
}

func (*QueryPrimaryContext) IsQueryPrimaryContext() {}

func NewQueryPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_queryPrimary

	return p
}

func (s *QueryPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryPrimaryContext) CopyAll(ctx *QueryPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QueryPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryContext struct {
	QueryPrimaryContext
}

func NewSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryContext {
	var p = new(SubqueryContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *SubqueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *SubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSubquery(s)
	}
}

func (s *SubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSubquery(s)
	}
}

type ValuesTableContext struct {
	QueryPrimaryContext
}

func NewValuesTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValuesTableContext {
	var p = new(ValuesTableContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *ValuesTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesTableContext) InlineTable() IInlineTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineTableContext)
}

func (s *ValuesTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterValuesTable(s)
	}
}

func (s *ValuesTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitValuesTable(s)
	}
}

type QueryPrimaryDefaultContext struct {
	QueryPrimaryContext
}

func NewQueryPrimaryDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryPrimaryDefaultContext {
	var p = new(QueryPrimaryDefaultContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *QueryPrimaryDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryDefaultContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *QueryPrimaryDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterQueryPrimaryDefault(s)
	}
}

func (s *QueryPrimaryDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitQueryPrimaryDefault(s)
	}
}

func (p *DorisParser) QueryPrimary() (localctx IQueryPrimaryContext) {
	localctx = NewQueryPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, DorisParserRULE_queryPrimary)
	p.SetState(3091)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserSELECT:
		localctx = NewQueryPrimaryDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3085)
			p.QuerySpecification()
		}

	case DorisParserLEFT_PAREN:
		localctx = NewSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3086)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3087)
			p.Query()
		}
		{
			p.SetState(3088)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserVALUES:
		localctx = NewValuesTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3090)
			p.InlineTable()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_querySpecification
	return p
}

func InitEmptyQuerySpecificationContext(p *QuerySpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_querySpecification
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) CopyAll(ctx *QuerySpecificationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RegularQuerySpecificationContext struct {
	QuerySpecificationContext
}

func NewRegularQuerySpecificationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegularQuerySpecificationContext {
	var p = new(RegularQuerySpecificationContext)

	InitEmptyQuerySpecificationContext(&p.QuerySpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*QuerySpecificationContext))

	return p
}

func (s *RegularQuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegularQuerySpecificationContext) SelectClause() ISelectClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectClauseContext)
}

func (s *RegularQuerySpecificationContext) QueryOrganization() IQueryOrganizationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryOrganizationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryOrganizationContext)
}

func (s *RegularQuerySpecificationContext) IntoClause() IIntoClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntoClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntoClauseContext)
}

func (s *RegularQuerySpecificationContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *RegularQuerySpecificationContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *RegularQuerySpecificationContext) AggClause() IAggClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggClauseContext)
}

func (s *RegularQuerySpecificationContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *RegularQuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRegularQuerySpecification(s)
	}
}

func (s *RegularQuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRegularQuerySpecification(s)
	}
}

func (p *DorisParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, DorisParserRULE_querySpecification)
	localctx = NewRegularQuerySpecificationContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3093)
		p.SelectClause()
	}
	p.SetState(3095)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 424, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3094)
			p.IntoClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3098)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 425, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3097)
			p.FromClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3101)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 426, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3100)
			p.WhereClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3104)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 427, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3103)
			p.AggClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3107)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 428, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3106)
			p.HavingClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3109)

	if !(doris_legacy_SQL_syntax) {
		p.SetError(antlr.NewFailedPredicateException(p, "doris_legacy_SQL_syntax", ""))
		goto errorExit
	}
	{
		p.SetState(3110)
		p.QueryOrganization()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICteContext is an interface to support dynamic dispatch.
type ICteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	AllAliasQuery() []IAliasQueryContext
	AliasQuery(i int) IAliasQueryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCteContext differentiates from other interfaces.
	IsCteContext()
}

type CteContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCteContext() *CteContext {
	var p = new(CteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_cte
	return p
}

func InitEmptyCteContext(p *CteContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_cte
}

func (*CteContext) IsCteContext() {}

func NewCteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CteContext {
	var p = new(CteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_cte

	return p
}

func (s *CteContext) GetParser() antlr.Parser { return s.parser }

func (s *CteContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *CteContext) AllAliasQuery() []IAliasQueryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAliasQueryContext); ok {
			len++
		}
	}

	tst := make([]IAliasQueryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAliasQueryContext); ok {
			tst[i] = t.(IAliasQueryContext)
			i++
		}
	}

	return tst
}

func (s *CteContext) AliasQuery(i int) IAliasQueryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasQueryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasQueryContext)
}

func (s *CteContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *CteContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *CteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCte(s)
	}
}

func (s *CteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCte(s)
	}
}

func (p *DorisParser) Cte() (localctx ICteContext) {
	localctx = NewCteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, DorisParserRULE_cte)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3112)
		p.Match(DorisParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3113)
		p.AliasQuery()
	}
	p.SetState(3118)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(3114)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3115)
			p.AliasQuery()
		}

		p.SetState(3120)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAliasQueryContext is an interface to support dynamic dispatch.
type IAliasQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AS() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	Query() IQueryContext
	RIGHT_PAREN() antlr.TerminalNode
	ColumnAliases() IColumnAliasesContext

	// IsAliasQueryContext differentiates from other interfaces.
	IsAliasQueryContext()
}

type AliasQueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasQueryContext() *AliasQueryContext {
	var p = new(AliasQueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_aliasQuery
	return p
}

func InitEmptyAliasQueryContext(p *AliasQueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_aliasQuery
}

func (*AliasQueryContext) IsAliasQueryContext() {}

func NewAliasQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasQueryContext {
	var p = new(AliasQueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_aliasQuery

	return p
}

func (s *AliasQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasQueryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AliasQueryContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *AliasQueryContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AliasQueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *AliasQueryContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AliasQueryContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *AliasQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAliasQuery(s)
	}
}

func (s *AliasQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAliasQuery(s)
	}
}

func (p *DorisParser) AliasQuery() (localctx IAliasQueryContext) {
	localctx = NewAliasQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, DorisParserRULE_aliasQuery)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3121)
		p.Identifier()
	}
	p.SetState(3123)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLEFT_PAREN {
		{
			p.SetState(3122)
			p.ColumnAliases()
		}

	}
	{
		p.SetState(3125)
		p.Match(DorisParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3126)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3127)
		p.Query()
	}
	{
		p.SetState(3128)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnAliasesContext is an interface to support dynamic dispatch.
type IColumnAliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnAliasesContext differentiates from other interfaces.
	IsColumnAliasesContext()
}

type ColumnAliasesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnAliasesContext() *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_columnAliases
	return p
}

func InitEmptyColumnAliasesContext(p *ColumnAliasesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_columnAliases
}

func (*ColumnAliasesContext) IsColumnAliasesContext() {}

func NewColumnAliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_columnAliases

	return p
}

func (s *ColumnAliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnAliasesContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ColumnAliasesContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnAliasesContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnAliasesContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ColumnAliasesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ColumnAliasesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ColumnAliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnAliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnAliasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterColumnAliases(s)
	}
}

func (s *ColumnAliasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitColumnAliases(s)
	}
}

func (p *DorisParser) ColumnAliases() (localctx IColumnAliasesContext) {
	localctx = NewColumnAliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, DorisParserRULE_columnAliases)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3130)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3131)
		p.Identifier()
	}
	p.SetState(3136)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(3132)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3133)
			p.Identifier()
		}

		p.SetState(3138)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3139)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectClauseContext is an interface to support dynamic dispatch.
type ISelectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	SelectColumnClause() ISelectColumnClauseContext
	SelectHint() ISelectHintContext
	DISTINCT() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsSelectClauseContext differentiates from other interfaces.
	IsSelectClauseContext()
}

type SelectClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectClauseContext() *SelectClauseContext {
	var p = new(SelectClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_selectClause
	return p
}

func InitEmptySelectClauseContext(p *SelectClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_selectClause
}

func (*SelectClauseContext) IsSelectClauseContext() {}

func NewSelectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectClauseContext {
	var p = new(SelectClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_selectClause

	return p
}

func (s *SelectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectClauseContext) SELECT() antlr.TerminalNode {
	return s.GetToken(DorisParserSELECT, 0)
}

func (s *SelectClauseContext) SelectColumnClause() ISelectColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectColumnClauseContext)
}

func (s *SelectClauseContext) SelectHint() ISelectHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectHintContext)
}

func (s *SelectClauseContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTINCT, 0)
}

func (s *SelectClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *SelectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSelectClause(s)
	}
}

func (s *SelectClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSelectClause(s)
	}
}

func (p *DorisParser) SelectClause() (localctx ISelectClauseContext) {
	localctx = NewSelectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, DorisParserRULE_selectClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3141)
		p.Match(DorisParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3143)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 432, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3142)
			p.SelectHint()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3146)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserALL || _la == DorisParserDISTINCT {
		{
			p.SetState(3145)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserALL || _la == DorisParserDISTINCT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3148)
		p.SelectColumnClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectColumnClauseContext is an interface to support dynamic dispatch.
type ISelectColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NamedExpressionSeq() INamedExpressionSeqContext

	// IsSelectColumnClauseContext differentiates from other interfaces.
	IsSelectColumnClauseContext()
}

type SelectColumnClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectColumnClauseContext() *SelectColumnClauseContext {
	var p = new(SelectColumnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_selectColumnClause
	return p
}

func InitEmptySelectColumnClauseContext(p *SelectColumnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_selectColumnClause
}

func (*SelectColumnClauseContext) IsSelectColumnClauseContext() {}

func NewSelectColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectColumnClauseContext {
	var p = new(SelectColumnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_selectColumnClause

	return p
}

func (s *SelectColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectColumnClauseContext) NamedExpressionSeq() INamedExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionSeqContext)
}

func (s *SelectColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSelectColumnClause(s)
	}
}

func (s *SelectColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSelectColumnClause(s)
	}
}

func (p *DorisParser) SelectColumnClause() (localctx ISelectColumnClauseContext) {
	localctx = NewSelectColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, DorisParserRULE_selectColumnClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3150)
		p.NamedExpressionSeq()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_whereClause
	return p
}

func InitEmptyWhereClauseContext(p *WhereClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_whereClause
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserWHERE, 0)
}

func (s *WhereClauseContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWhereClause(s)
	}
}

func (s *WhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWhereClause(s)
	}
}

func (p *DorisParser) WhereClause() (localctx IWhereClauseContext) {
	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, DorisParserRULE_whereClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3152)
		p.Match(DorisParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3153)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM() antlr.TerminalNode
	Relations() IRelationsContext

	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_fromClause
	return p
}

func InitEmptyFromClauseContext(p *FromClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_fromClause
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *FromClauseContext) Relations() IRelationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationsContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFromClause(s)
	}
}

func (s *FromClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFromClause(s)
	}
}

func (p *DorisParser) FromClause() (localctx IFromClauseContext) {
	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, DorisParserRULE_fromClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3155)
		p.Match(DorisParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3156)
		p.Relations()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntoClauseContext is an interface to support dynamic dispatch.
type IIntoClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTO() antlr.TerminalNode
	AllTableRow() []ITableRowContext
	TableRow(i int) ITableRowContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	BulkCollectClause() IBulkCollectClauseContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIntoClauseContext differentiates from other interfaces.
	IsIntoClauseContext()
}

type IntoClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntoClauseContext() *IntoClauseContext {
	var p = new(IntoClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_intoClause
	return p
}

func InitEmptyIntoClauseContext(p *IntoClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_intoClause
}

func (*IntoClauseContext) IsIntoClauseContext() {}

func NewIntoClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntoClauseContext {
	var p = new(IntoClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_intoClause

	return p
}

func (s *IntoClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *IntoClauseContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserINTO, 0)
}

func (s *IntoClauseContext) AllTableRow() []ITableRowContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableRowContext); ok {
			len++
		}
	}

	tst := make([]ITableRowContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableRowContext); ok {
			tst[i] = t.(ITableRowContext)
			i++
		}
	}

	return tst
}

func (s *IntoClauseContext) TableRow(i int) ITableRowContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRowContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRowContext)
}

func (s *IntoClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IntoClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IntoClauseContext) BulkCollectClause() IBulkCollectClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBulkCollectClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBulkCollectClauseContext)
}

func (s *IntoClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *IntoClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *IntoClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntoClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntoClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIntoClause(s)
	}
}

func (s *IntoClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIntoClause(s)
	}
}

func (p *DorisParser) IntoClause() (localctx IIntoClauseContext) {
	localctx = NewIntoClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, DorisParserRULE_intoClause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3159)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserBULK {
		{
			p.SetState(3158)
			p.BulkCollectClause()
		}

	}
	{
		p.SetState(3161)
		p.Match(DorisParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3164)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 435, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3162)
			p.TableRow()
		}

	case 2:
		{
			p.SetState(3163)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(3173)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 437, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3166)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3169)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 436, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(3167)
					p.TableRow()
				}

			case 2:
				{
					p.SetState(3168)
					p.Identifier()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(3175)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 437, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBulkCollectClauseContext is an interface to support dynamic dispatch.
type IBulkCollectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BULK() antlr.TerminalNode
	COLLECT() antlr.TerminalNode

	// IsBulkCollectClauseContext differentiates from other interfaces.
	IsBulkCollectClauseContext()
}

type BulkCollectClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBulkCollectClauseContext() *BulkCollectClauseContext {
	var p = new(BulkCollectClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_bulkCollectClause
	return p
}

func InitEmptyBulkCollectClauseContext(p *BulkCollectClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_bulkCollectClause
}

func (*BulkCollectClauseContext) IsBulkCollectClauseContext() {}

func NewBulkCollectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BulkCollectClauseContext {
	var p = new(BulkCollectClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_bulkCollectClause

	return p
}

func (s *BulkCollectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *BulkCollectClauseContext) BULK() antlr.TerminalNode {
	return s.GetToken(DorisParserBULK, 0)
}

func (s *BulkCollectClauseContext) COLLECT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLLECT, 0)
}

func (s *BulkCollectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BulkCollectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BulkCollectClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBulkCollectClause(s)
	}
}

func (s *BulkCollectClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBulkCollectClause(s)
	}
}

func (p *DorisParser) BulkCollectClause() (localctx IBulkCollectClauseContext) {
	localctx = NewBulkCollectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, DorisParserRULE_bulkCollectClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3176)
		p.Match(DorisParserBULK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3177)
		p.Match(DorisParserCOLLECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableRowContext is an interface to support dynamic dispatch.
type ITableRowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LEFT_PAREN() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode

	// IsTableRowContext differentiates from other interfaces.
	IsTableRowContext()
}

type TableRowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableRowContext() *TableRowContext {
	var p = new(TableRowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tableRow
	return p
}

func InitEmptyTableRowContext(p *TableRowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tableRow
}

func (*TableRowContext) IsTableRowContext() {}

func NewTableRowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableRowContext {
	var p = new(TableRowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_tableRow

	return p
}

func (s *TableRowContext) GetParser() antlr.Parser { return s.parser }

func (s *TableRowContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableRowContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *TableRowContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *TableRowContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *TableRowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableRowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableRowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTableRow(s)
	}
}

func (s *TableRowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTableRow(s)
	}
}

func (p *DorisParser) TableRow() (localctx ITableRowContext) {
	localctx = NewTableRowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, DorisParserRULE_tableRow)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3179)
		p.Identifier()
	}
	{
		p.SetState(3180)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3181)
		p.Match(DorisParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3182)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationsContext is an interface to support dynamic dispatch.
type IRelationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRelation() []IRelationContext
	Relation(i int) IRelationContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRelationsContext differentiates from other interfaces.
	IsRelationsContext()
}

type RelationsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationsContext() *RelationsContext {
	var p = new(RelationsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_relations
	return p
}

func InitEmptyRelationsContext(p *RelationsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_relations
}

func (*RelationsContext) IsRelationsContext() {}

func NewRelationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationsContext {
	var p = new(RelationsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_relations

	return p
}

func (s *RelationsContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationsContext) AllRelation() []IRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelationContext); ok {
			len++
		}
	}

	tst := make([]IRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelationContext); ok {
			tst[i] = t.(IRelationContext)
			i++
		}
	}

	return tst
}

func (s *RelationsContext) Relation(i int) IRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *RelationsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *RelationsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *RelationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRelations(s)
	}
}

func (s *RelationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRelations(s)
	}
}

func (p *DorisParser) Relations() (localctx IRelationsContext) {
	localctx = NewRelationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, DorisParserRULE_relations)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3184)
		p.Relation()
	}
	p.SetState(3189)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 438, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3185)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3186)
				p.Relation()
			}

		}
		p.SetState(3191)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 438, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RelationPrimary() IRelationPrimaryContext
	AllJoinRelation() []IJoinRelationContext
	JoinRelation(i int) IJoinRelationContext

	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_relation
	return p
}

func InitEmptyRelationContext(p *RelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_relation
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) RelationPrimary() IRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *RelationContext) AllJoinRelation() []IJoinRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinRelationContext); ok {
			len++
		}
	}

	tst := make([]IJoinRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinRelationContext); ok {
			tst[i] = t.(IJoinRelationContext)
			i++
		}
	}

	return tst
}

func (s *RelationContext) JoinRelation(i int) IJoinRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinRelationContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRelation(s)
	}
}

func (s *RelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRelation(s)
	}
}

func (p *DorisParser) Relation() (localctx IRelationContext) {
	localctx = NewRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, DorisParserRULE_relation)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3192)
		p.RelationPrimary()
	}
	p.SetState(3196)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 439, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3193)
				p.JoinRelation()
			}

		}
		p.SetState(3198)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 439, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinRelationContext is an interface to support dynamic dispatch.
type IJoinRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRight returns the right rule contexts.
	GetRight() IRelationPrimaryContext

	// SetRight sets the right rule contexts.
	SetRight(IRelationPrimaryContext)

	// Getter signatures
	JOIN() antlr.TerminalNode
	RelationPrimary() IRelationPrimaryContext
	JoinType() IJoinTypeContext
	DistributeType() IDistributeTypeContext
	JoinCriteria() IJoinCriteriaContext

	// IsJoinRelationContext differentiates from other interfaces.
	IsJoinRelationContext()
}

type JoinRelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	right  IRelationPrimaryContext
}

func NewEmptyJoinRelationContext() *JoinRelationContext {
	var p = new(JoinRelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_joinRelation
	return p
}

func InitEmptyJoinRelationContext(p *JoinRelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_joinRelation
}

func (*JoinRelationContext) IsJoinRelationContext() {}

func NewJoinRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinRelationContext {
	var p = new(JoinRelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_joinRelation

	return p
}

func (s *JoinRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinRelationContext) GetRight() IRelationPrimaryContext { return s.right }

func (s *JoinRelationContext) SetRight(v IRelationPrimaryContext) { s.right = v }

func (s *JoinRelationContext) JOIN() antlr.TerminalNode {
	return s.GetToken(DorisParserJOIN, 0)
}

func (s *JoinRelationContext) RelationPrimary() IRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *JoinRelationContext) JoinType() IJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinTypeContext)
}

func (s *JoinRelationContext) DistributeType() IDistributeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributeTypeContext)
}

func (s *JoinRelationContext) JoinCriteria() IJoinCriteriaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinCriteriaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinCriteriaContext)
}

func (s *JoinRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterJoinRelation(s)
	}
}

func (s *JoinRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitJoinRelation(s)
	}
}

func (p *DorisParser) JoinRelation() (localctx IJoinRelationContext) {
	localctx = NewJoinRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, DorisParserRULE_joinRelation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3199)
		p.JoinType()
	}

	{
		p.SetState(3200)
		p.Match(DorisParserJOIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3202)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 440, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3201)
			p.DistributeType()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3204)

		var _x = p.RelationPrimary()

		localctx.(*JoinRelationContext).right = _x
	}
	p.SetState(3206)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 441, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3205)
			p.JoinCriteria()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDistributeTypeContext is an interface to support dynamic dispatch.
type IDistributeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDistributeTypeContext differentiates from other interfaces.
	IsDistributeTypeContext()
}

type DistributeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistributeTypeContext() *DistributeTypeContext {
	var p = new(DistributeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_distributeType
	return p
}

func InitEmptyDistributeTypeContext(p *DistributeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_distributeType
}

func (*DistributeTypeContext) IsDistributeTypeContext() {}

func NewDistributeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistributeTypeContext {
	var p = new(DistributeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_distributeType

	return p
}

func (s *DistributeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DistributeTypeContext) CopyAll(ctx *DistributeTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DistributeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistributeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CommentDistributeTypeContext struct {
	DistributeTypeContext
}

func NewCommentDistributeTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommentDistributeTypeContext {
	var p = new(CommentDistributeTypeContext)

	InitEmptyDistributeTypeContext(&p.DistributeTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DistributeTypeContext))

	return p
}

func (s *CommentDistributeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentDistributeTypeContext) HINT_START() antlr.TerminalNode {
	return s.GetToken(DorisParserHINT_START, 0)
}

func (s *CommentDistributeTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CommentDistributeTypeContext) HINT_END() antlr.TerminalNode {
	return s.GetToken(DorisParserHINT_END, 0)
}

func (s *CommentDistributeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCommentDistributeType(s)
	}
}

func (s *CommentDistributeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCommentDistributeType(s)
	}
}

type BracketDistributeTypeContext struct {
	DistributeTypeContext
}

func NewBracketDistributeTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BracketDistributeTypeContext {
	var p = new(BracketDistributeTypeContext)

	InitEmptyDistributeTypeContext(&p.DistributeTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DistributeTypeContext))

	return p
}

func (s *BracketDistributeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BracketDistributeTypeContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACKET, 0)
}

func (s *BracketDistributeTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BracketDistributeTypeContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACKET, 0)
}

func (s *BracketDistributeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBracketDistributeType(s)
	}
}

func (s *BracketDistributeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBracketDistributeType(s)
	}
}

func (p *DorisParser) DistributeType() (localctx IDistributeTypeContext) {
	localctx = NewDistributeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, DorisParserRULE_distributeType)
	p.SetState(3216)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACKET:
		localctx = NewBracketDistributeTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3208)
			p.Match(DorisParserLEFT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3209)
			p.Identifier()
		}
		{
			p.SetState(3210)
			p.Match(DorisParserRIGHT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserHINT_START:
		localctx = NewCommentDistributeTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3212)
			p.Match(DorisParserHINT_START)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3213)
			p.Identifier()
		}
		{
			p.SetState(3214)
			p.Match(DorisParserHINT_END)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationHintContext is an interface to support dynamic dispatch.
type IRelationHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationHintContext differentiates from other interfaces.
	IsRelationHintContext()
}

type RelationHintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationHintContext() *RelationHintContext {
	var p = new(RelationHintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_relationHint
	return p
}

func InitEmptyRelationHintContext(p *RelationHintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_relationHint
}

func (*RelationHintContext) IsRelationHintContext() {}

func NewRelationHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationHintContext {
	var p = new(RelationHintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_relationHint

	return p
}

func (s *RelationHintContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationHintContext) CopyAll(ctx *RelationHintContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RelationHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BracketRelationHintContext struct {
	RelationHintContext
}

func NewBracketRelationHintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BracketRelationHintContext {
	var p = new(BracketRelationHintContext)

	InitEmptyRelationHintContext(&p.RelationHintContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationHintContext))

	return p
}

func (s *BracketRelationHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BracketRelationHintContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACKET, 0)
}

func (s *BracketRelationHintContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *BracketRelationHintContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BracketRelationHintContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACKET, 0)
}

func (s *BracketRelationHintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *BracketRelationHintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *BracketRelationHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBracketRelationHint(s)
	}
}

func (s *BracketRelationHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBracketRelationHint(s)
	}
}

type CommentRelationHintContext struct {
	RelationHintContext
}

func NewCommentRelationHintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommentRelationHintContext {
	var p = new(CommentRelationHintContext)

	InitEmptyRelationHintContext(&p.RelationHintContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationHintContext))

	return p
}

func (s *CommentRelationHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentRelationHintContext) HINT_START() antlr.TerminalNode {
	return s.GetToken(DorisParserHINT_START, 0)
}

func (s *CommentRelationHintContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CommentRelationHintContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CommentRelationHintContext) HINT_END() antlr.TerminalNode {
	return s.GetToken(DorisParserHINT_END, 0)
}

func (s *CommentRelationHintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *CommentRelationHintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *CommentRelationHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCommentRelationHint(s)
	}
}

func (s *CommentRelationHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCommentRelationHint(s)
	}
}

func (p *DorisParser) RelationHint() (localctx IRelationHintContext) {
	localctx = NewRelationHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, DorisParserRULE_relationHint)
	var _la int

	p.SetState(3240)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACKET:
		localctx = NewBracketRelationHintContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3218)
			p.Match(DorisParserLEFT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3219)
			p.Identifier()
		}
		p.SetState(3224)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(3220)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3221)
				p.Identifier()
			}

			p.SetState(3226)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3227)
			p.Match(DorisParserRIGHT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserHINT_START:
		localctx = NewCommentRelationHintContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3229)
			p.Match(DorisParserHINT_START)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3230)
			p.Identifier()
		}
		p.SetState(3235)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(3231)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3232)
				p.Identifier()
			}

			p.SetState(3237)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3238)
			p.Match(DorisParserHINT_END)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggClauseContext is an interface to support dynamic dispatch.
type IAggClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	GroupingElement() IGroupingElementContext

	// IsAggClauseContext differentiates from other interfaces.
	IsAggClauseContext()
}

type AggClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggClauseContext() *AggClauseContext {
	var p = new(AggClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_aggClause
	return p
}

func InitEmptyAggClauseContext(p *AggClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_aggClause
}

func (*AggClauseContext) IsAggClauseContext() {}

func NewAggClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggClauseContext {
	var p = new(AggClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_aggClause

	return p
}

func (s *AggClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AggClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUP, 0)
}

func (s *AggClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *AggClauseContext) GroupingElement() IGroupingElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingElementContext)
}

func (s *AggClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAggClause(s)
	}
}

func (s *AggClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAggClause(s)
	}
}

func (p *DorisParser) AggClause() (localctx IAggClauseContext) {
	localctx = NewAggClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, DorisParserRULE_aggClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3242)
		p.Match(DorisParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3243)
		p.Match(DorisParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3244)
		p.GroupingElement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingElementContext is an interface to support dynamic dispatch.
type IGroupingElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLLUP() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	CUBE() antlr.TerminalNode
	GROUPING() antlr.TerminalNode
	SETS() antlr.TerminalNode
	AllGroupingSet() []IGroupingSetContext
	GroupingSet(i int) IGroupingSetContext

	// IsGroupingElementContext differentiates from other interfaces.
	IsGroupingElementContext()
}

type GroupingElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingElementContext() *GroupingElementContext {
	var p = new(GroupingElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_groupingElement
	return p
}

func InitEmptyGroupingElementContext(p *GroupingElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_groupingElement
}

func (*GroupingElementContext) IsGroupingElementContext() {}

func NewGroupingElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingElementContext {
	var p = new(GroupingElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_groupingElement

	return p
}

func (s *GroupingElementContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingElementContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *GroupingElementContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *GroupingElementContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *GroupingElementContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupingElementContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingElementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *GroupingElementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *GroupingElementContext) CUBE() antlr.TerminalNode {
	return s.GetToken(DorisParserCUBE, 0)
}

func (s *GroupingElementContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUPING, 0)
}

func (s *GroupingElementContext) SETS() antlr.TerminalNode {
	return s.GetToken(DorisParserSETS, 0)
}

func (s *GroupingElementContext) AllGroupingSet() []IGroupingSetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupingSetContext); ok {
			len++
		}
	}

	tst := make([]IGroupingSetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupingSetContext); ok {
			tst[i] = t.(IGroupingSetContext)
			i++
		}
	}

	return tst
}

func (s *GroupingElementContext) GroupingSet(i int) IGroupingSetContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingSetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *GroupingElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterGroupingElement(s)
	}
}

func (s *GroupingElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitGroupingElement(s)
	}
}

func (p *DorisParser) GroupingElement() (localctx IGroupingElementContext) {
	localctx = NewGroupingElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, DorisParserRULE_groupingElement)
	var _la int

	var _alt int

	p.SetState(3293)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 452, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3246)
			p.Match(DorisParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3247)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3256)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1153005225580239228) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-141717009369345) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-4539691388701481817) != 0) || ((int64((_la-195)) & ^0x3f) == 0 && ((int64(1)<<(_la-195))&-3103018623212733835) != 0) || ((int64((_la-259)) & ^0x3f) == 0 && ((int64(1)<<(_la-259))&-9089391056176578961) != 0) || ((int64((_la-323)) & ^0x3f) == 0 && ((int64(1)<<(_la-323))&-2310857813124972547) != 0) || ((int64((_la-387)) & ^0x3f) == 0 && ((int64(1)<<(_la-387))&-5255560032135782599) != 0) || ((int64((_la-451)) & ^0x3f) == 0 && ((int64(1)<<(_la-451))&5621092667580571559) != 0) || ((int64((_la-516)) & ^0x3f) == 0 && ((int64(1)<<(_la-516))&3608513) != 0) {
			{
				p.SetState(3248)
				p.Expression()
			}
			p.SetState(3253)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(3249)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3250)
					p.Expression()
				}

				p.SetState(3255)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(3258)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3259)
			p.Match(DorisParserCUBE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3260)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3269)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1153005225580239228) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-141717009369345) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-4539691388701481817) != 0) || ((int64((_la-195)) & ^0x3f) == 0 && ((int64(1)<<(_la-195))&-3103018623212733835) != 0) || ((int64((_la-259)) & ^0x3f) == 0 && ((int64(1)<<(_la-259))&-9089391056176578961) != 0) || ((int64((_la-323)) & ^0x3f) == 0 && ((int64(1)<<(_la-323))&-2310857813124972547) != 0) || ((int64((_la-387)) & ^0x3f) == 0 && ((int64(1)<<(_la-387))&-5255560032135782599) != 0) || ((int64((_la-451)) & ^0x3f) == 0 && ((int64(1)<<(_la-451))&5621092667580571559) != 0) || ((int64((_la-516)) & ^0x3f) == 0 && ((int64(1)<<(_la-516))&3608513) != 0) {
			{
				p.SetState(3261)
				p.Expression()
			}
			p.SetState(3266)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(3262)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3263)
					p.Expression()
				}

				p.SetState(3268)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(3271)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3272)
			p.Match(DorisParserGROUPING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3273)
			p.Match(DorisParserSETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3274)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3275)
			p.GroupingSet()
		}
		p.SetState(3280)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(3276)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3277)
				p.GroupingSet()
			}

			p.SetState(3282)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3283)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3285)
			p.Expression()
		}
		p.SetState(3290)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 451, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3286)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3287)
					p.Expression()
				}

			}
			p.SetState(3292)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 451, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingSetContext is an interface to support dynamic dispatch.
type IGroupingSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGroupingSetContext differentiates from other interfaces.
	IsGroupingSetContext()
}

type GroupingSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingSetContext() *GroupingSetContext {
	var p = new(GroupingSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_groupingSet
	return p
}

func InitEmptyGroupingSetContext(p *GroupingSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_groupingSet
}

func (*GroupingSetContext) IsGroupingSetContext() {}

func NewGroupingSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingSetContext {
	var p = new(GroupingSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_groupingSet

	return p
}

func (s *GroupingSetContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingSetContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *GroupingSetContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *GroupingSetContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupingSetContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingSetContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *GroupingSetContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *GroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterGroupingSet(s)
	}
}

func (s *GroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitGroupingSet(s)
	}
}

func (p *DorisParser) GroupingSet() (localctx IGroupingSetContext) {
	localctx = NewGroupingSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, DorisParserRULE_groupingSet)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3295)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3304)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1153005225580239228) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-141717009369345) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-4539691388701481817) != 0) || ((int64((_la-195)) & ^0x3f) == 0 && ((int64(1)<<(_la-195))&-3103018623212733835) != 0) || ((int64((_la-259)) & ^0x3f) == 0 && ((int64(1)<<(_la-259))&-9089391056176578961) != 0) || ((int64((_la-323)) & ^0x3f) == 0 && ((int64(1)<<(_la-323))&-2310857813124972547) != 0) || ((int64((_la-387)) & ^0x3f) == 0 && ((int64(1)<<(_la-387))&-5255560032135782599) != 0) || ((int64((_la-451)) & ^0x3f) == 0 && ((int64(1)<<(_la-451))&5621092667580571559) != 0) || ((int64((_la-516)) & ^0x3f) == 0 && ((int64(1)<<(_la-516))&3608513) != 0) {
		{
			p.SetState(3296)
			p.Expression()
		}
		p.SetState(3301)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(3297)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3298)
				p.Expression()
			}

			p.SetState(3303)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3306)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHavingClauseContext is an interface to support dynamic dispatch.
type IHavingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HAVING() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsHavingClauseContext differentiates from other interfaces.
	IsHavingClauseContext()
}

type HavingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHavingClauseContext() *HavingClauseContext {
	var p = new(HavingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_havingClause
	return p
}

func InitEmptyHavingClauseContext(p *HavingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_havingClause
}

func (*HavingClauseContext) IsHavingClauseContext() {}

func NewHavingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HavingClauseContext {
	var p = new(HavingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_havingClause

	return p
}

func (s *HavingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *HavingClauseContext) HAVING() antlr.TerminalNode {
	return s.GetToken(DorisParserHAVING, 0)
}

func (s *HavingClauseContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *HavingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HavingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HavingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterHavingClause(s)
	}
}

func (s *HavingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitHavingClause(s)
	}
}

func (p *DorisParser) HavingClause() (localctx IHavingClauseContext) {
	localctx = NewHavingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, DorisParserRULE_havingClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3308)
		p.Match(DorisParserHAVING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3309)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectHintContext is an interface to support dynamic dispatch.
type ISelectHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_hintStatement returns the _hintStatement rule contexts.
	Get_hintStatement() IHintStatementContext

	// Set_hintStatement sets the _hintStatement rule contexts.
	Set_hintStatement(IHintStatementContext)

	// GetHintStatements returns the hintStatements rule context list.
	GetHintStatements() []IHintStatementContext

	// SetHintStatements sets the hintStatements rule context list.
	SetHintStatements([]IHintStatementContext)

	// Getter signatures
	HINT_END() antlr.TerminalNode
	AllHintStatement() []IHintStatementContext
	HintStatement(i int) IHintStatementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSelectHintContext differentiates from other interfaces.
	IsSelectHintContext()
}

type SelectHintContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	_hintStatement IHintStatementContext
	hintStatements []IHintStatementContext
}

func NewEmptySelectHintContext() *SelectHintContext {
	var p = new(SelectHintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_selectHint
	return p
}

func InitEmptySelectHintContext(p *SelectHintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_selectHint
}

func (*SelectHintContext) IsSelectHintContext() {}

func NewSelectHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectHintContext {
	var p = new(SelectHintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_selectHint

	return p
}

func (s *SelectHintContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectHintContext) Get_hintStatement() IHintStatementContext { return s._hintStatement }

func (s *SelectHintContext) Set_hintStatement(v IHintStatementContext) { s._hintStatement = v }

func (s *SelectHintContext) GetHintStatements() []IHintStatementContext { return s.hintStatements }

func (s *SelectHintContext) SetHintStatements(v []IHintStatementContext) { s.hintStatements = v }

func (s *SelectHintContext) HINT_END() antlr.TerminalNode {
	return s.GetToken(DorisParserHINT_END, 0)
}

func (s *SelectHintContext) AllHintStatement() []IHintStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHintStatementContext); ok {
			len++
		}
	}

	tst := make([]IHintStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHintStatementContext); ok {
			tst[i] = t.(IHintStatementContext)
			i++
		}
	}

	return tst
}

func (s *SelectHintContext) HintStatement(i int) IHintStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintStatementContext)
}

func (s *SelectHintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *SelectHintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *SelectHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSelectHint(s)
	}
}

func (s *SelectHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSelectHint(s)
	}
}

func (p *DorisParser) SelectHint() (localctx ISelectHintContext) {
	localctx = NewSelectHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, DorisParserRULE_selectHint)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3311)

		var _x = p.HintStatement()

		localctx.(*SelectHintContext)._hintStatement = _x
	}
	localctx.(*SelectHintContext).hintStatements = append(localctx.(*SelectHintContext).hintStatements, localctx.(*SelectHintContext)._hintStatement)
	p.SetState(3318)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 456, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(3313)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserCOMMA {
				{
					p.SetState(3312)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(3315)

				var _x = p.HintStatement()

				localctx.(*SelectHintContext)._hintStatement = _x
			}
			localctx.(*SelectHintContext).hintStatements = append(localctx.(*SelectHintContext).hintStatements, localctx.(*SelectHintContext)._hintStatement)

		}
		p.SetState(3320)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 456, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(3321)
		p.Match(DorisParserHINT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHintStatementContext is an interface to support dynamic dispatch.
type IHintStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetHintName returns the hintName rule contexts.
	GetHintName() IIdentifierContext

	// Get_hintAssignment returns the _hintAssignment rule contexts.
	Get_hintAssignment() IHintAssignmentContext

	// SetHintName sets the hintName rule contexts.
	SetHintName(IIdentifierContext)

	// Set_hintAssignment sets the _hintAssignment rule contexts.
	Set_hintAssignment(IHintAssignmentContext)

	// GetParameters returns the parameters rule context list.
	GetParameters() []IHintAssignmentContext

	// SetParameters sets the parameters rule context list.
	SetParameters([]IHintAssignmentContext)

	// Getter signatures
	Identifier() IIdentifierContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllHintAssignment() []IHintAssignmentContext
	HintAssignment(i int) IHintAssignmentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsHintStatementContext differentiates from other interfaces.
	IsHintStatementContext()
}

type HintStatementContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	hintName        IIdentifierContext
	_hintAssignment IHintAssignmentContext
	parameters      []IHintAssignmentContext
}

func NewEmptyHintStatementContext() *HintStatementContext {
	var p = new(HintStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_hintStatement
	return p
}

func InitEmptyHintStatementContext(p *HintStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_hintStatement
}

func (*HintStatementContext) IsHintStatementContext() {}

func NewHintStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintStatementContext {
	var p = new(HintStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_hintStatement

	return p
}

func (s *HintStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HintStatementContext) GetHintName() IIdentifierContext { return s.hintName }

func (s *HintStatementContext) Get_hintAssignment() IHintAssignmentContext { return s._hintAssignment }

func (s *HintStatementContext) SetHintName(v IIdentifierContext) { s.hintName = v }

func (s *HintStatementContext) Set_hintAssignment(v IHintAssignmentContext) { s._hintAssignment = v }

func (s *HintStatementContext) GetParameters() []IHintAssignmentContext { return s.parameters }

func (s *HintStatementContext) SetParameters(v []IHintAssignmentContext) { s.parameters = v }

func (s *HintStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *HintStatementContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *HintStatementContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *HintStatementContext) AllHintAssignment() []IHintAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHintAssignmentContext); ok {
			len++
		}
	}

	tst := make([]IHintAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHintAssignmentContext); ok {
			tst[i] = t.(IHintAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *HintStatementContext) HintAssignment(i int) IHintAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintAssignmentContext)
}

func (s *HintStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *HintStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *HintStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HintStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterHintStatement(s)
	}
}

func (s *HintStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitHintStatement(s)
	}
}

func (p *DorisParser) HintStatement() (localctx IHintStatementContext) {
	localctx = NewHintStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, DorisParserRULE_hintStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3323)

		var _x = p.Identifier()

		localctx.(*HintStatementContext).hintName = _x
	}
	p.SetState(3337)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLEFT_PAREN {
		{
			p.SetState(3324)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3325)

			var _x = p.HintAssignment()

			localctx.(*HintStatementContext)._hintAssignment = _x
		}
		localctx.(*HintStatementContext).parameters = append(localctx.(*HintStatementContext).parameters, localctx.(*HintStatementContext)._hintAssignment)
		p.SetState(3332)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1153005225580255600) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&-53021438386753) != 0) || ((int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&3476727437124114729) != 0) || ((int64((_la-195)) & ^0x3f) == 0 && ((int64(1)<<(_la-195))&-3139048519776880011) != 0) || ((int64((_la-260)) & ^0x3f) == 0 && ((int64(1)<<(_la-260))&-4544765896832467149) != 0) || ((int64((_la-325)) & ^0x3f) == 0 && ((int64(1)<<(_la-325))&6339805778266816511) != 0) || ((int64((_la-390)) & ^0x3f) == 0 && ((int64(1)<<(_la-390))&-656945004016972825) != 0) || ((int64((_la-456)) & ^0x3f) == 0 && ((int64(1)<<(_la-456))&9025959649184493) != 0) || ((int64((_la-522)) & ^0x3f) == 0 && ((int64(1)<<(_la-522))&56359) != 0) {
			p.SetState(3327)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserCOMMA {
				{
					p.SetState(3326)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(3329)

				var _x = p.HintAssignment()

				localctx.(*HintStatementContext)._hintAssignment = _x
			}
			localctx.(*HintStatementContext).parameters = append(localctx.(*HintStatementContext).parameters, localctx.(*HintStatementContext)._hintAssignment)

			p.SetState(3334)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3335)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHintAssignmentContext is an interface to support dynamic dispatch.
type IHintAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IIdentifierOrTextContext

	// GetConstantValue returns the constantValue rule contexts.
	GetConstantValue() IConstantContext

	// GetIdentifierValue returns the identifierValue rule contexts.
	GetIdentifierValue() IIdentifierContext

	// SetKey sets the key rule contexts.
	SetKey(IIdentifierOrTextContext)

	// SetConstantValue sets the constantValue rule contexts.
	SetConstantValue(IConstantContext)

	// SetIdentifierValue sets the identifierValue rule contexts.
	SetIdentifierValue(IIdentifierContext)

	// Getter signatures
	IdentifierOrText() IIdentifierOrTextContext
	EQ() antlr.TerminalNode
	Constant() IConstantContext
	Identifier() IIdentifierContext

	// IsHintAssignmentContext differentiates from other interfaces.
	IsHintAssignmentContext()
}

type HintAssignmentContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	key             IIdentifierOrTextContext
	constantValue   IConstantContext
	identifierValue IIdentifierContext
}

func NewEmptyHintAssignmentContext() *HintAssignmentContext {
	var p = new(HintAssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_hintAssignment
	return p
}

func InitEmptyHintAssignmentContext(p *HintAssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_hintAssignment
}

func (*HintAssignmentContext) IsHintAssignmentContext() {}

func NewHintAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintAssignmentContext {
	var p = new(HintAssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_hintAssignment

	return p
}

func (s *HintAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *HintAssignmentContext) GetKey() IIdentifierOrTextContext { return s.key }

func (s *HintAssignmentContext) GetConstantValue() IConstantContext { return s.constantValue }

func (s *HintAssignmentContext) GetIdentifierValue() IIdentifierContext { return s.identifierValue }

func (s *HintAssignmentContext) SetKey(v IIdentifierOrTextContext) { s.key = v }

func (s *HintAssignmentContext) SetConstantValue(v IConstantContext) { s.constantValue = v }

func (s *HintAssignmentContext) SetIdentifierValue(v IIdentifierContext) { s.identifierValue = v }

func (s *HintAssignmentContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *HintAssignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *HintAssignmentContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *HintAssignmentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *HintAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HintAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterHintAssignment(s)
	}
}

func (s *HintAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitHintAssignment(s)
	}
}

func (p *DorisParser) HintAssignment() (localctx IHintAssignmentContext) {
	localctx = NewHintAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, DorisParserRULE_hintAssignment)
	var _la int

	p.SetState(3348)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 462, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3339)

			var _x = p.IdentifierOrText()

			localctx.(*HintAssignmentContext).key = _x
		}
		p.SetState(3345)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserEQ {
			{
				p.SetState(3340)
				p.Match(DorisParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3343)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 460, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(3341)

					var _x = p.Constant()

					localctx.(*HintAssignmentContext).constantValue = _x
				}

			case 2:
				{
					p.SetState(3342)

					var _x = p.Identifier()

					localctx.(*HintAssignmentContext).identifierValue = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3347)
			p.Constant()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateAssignmentContext is an interface to support dynamic dispatch.
type IUpdateAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCol returns the col rule contexts.
	GetCol() IMultipartIdentifierContext

	// SetCol sets the col rule contexts.
	SetCol(IMultipartIdentifierContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext
	Expression() IExpressionContext
	DEFAULT() antlr.TerminalNode

	// IsUpdateAssignmentContext differentiates from other interfaces.
	IsUpdateAssignmentContext()
}

type UpdateAssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	col    IMultipartIdentifierContext
}

func NewEmptyUpdateAssignmentContext() *UpdateAssignmentContext {
	var p = new(UpdateAssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_updateAssignment
	return p
}

func InitEmptyUpdateAssignmentContext(p *UpdateAssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_updateAssignment
}

func (*UpdateAssignmentContext) IsUpdateAssignmentContext() {}

func NewUpdateAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateAssignmentContext {
	var p = new(UpdateAssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_updateAssignment

	return p
}

func (s *UpdateAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateAssignmentContext) GetCol() IMultipartIdentifierContext { return s.col }

func (s *UpdateAssignmentContext) SetCol(v IMultipartIdentifierContext) { s.col = v }

func (s *UpdateAssignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *UpdateAssignmentContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *UpdateAssignmentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UpdateAssignmentContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *UpdateAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUpdateAssignment(s)
	}
}

func (s *UpdateAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUpdateAssignment(s)
	}
}

func (p *DorisParser) UpdateAssignment() (localctx IUpdateAssignmentContext) {
	localctx = NewUpdateAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, DorisParserRULE_updateAssignment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3350)

		var _x = p.MultipartIdentifier()

		localctx.(*UpdateAssignmentContext).col = _x
	}
	{
		p.SetState(3351)
		p.Match(DorisParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3354)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_PAREN, DorisParserLEFT_BRACKET, DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADD, DorisParserADDDATE, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserARRAY_RANGE, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBINARY, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCASE, DorisParserCAST, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATABASE, DorisParserDATE, DorisParserDATE_ADD, DorisParserDATE_CEIL, DorisParserDATE_DIFF, DorisParserDATE_FLOOR, DorisParserDATE_SUB, DorisParserDATEADD, DorisParserDATEDIFF, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS_ADD, DorisParserDAYS_SUB, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXISTS, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserEXTRACT, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFALSE, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIF, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINTERVAL, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserKEY, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLEFT, DorisParserLESS, DorisParserLEVEL, DorisParserLIKE, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNOT, DorisParserNULL, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLACEHOLDER, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREGEXP, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRIGHT, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSEQUENCE, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUBDATE, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTIMESTAMPADD, DorisParserTIMESTAMPDIFF, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRIM, DorisParserTRUE, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserPLUS, DorisParserSUBTRACT, DorisParserASTERISK, DorisParserTILDE, DorisParserLOGICALNOT, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserATSIGN, DorisParserDOUBLEATSIGN, DorisParserSTRING_LITERAL, DorisParserINTEGER_VALUE, DorisParserEXPONENT_VALUE, DorisParserDECIMAL_VALUE, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		{
			p.SetState(3352)
			p.Expression()
		}

	case DorisParserDEFAULT:
		{
			p.SetState(3353)
			p.Match(DorisParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateAssignmentSeqContext is an interface to support dynamic dispatch.
type IUpdateAssignmentSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_updateAssignment returns the _updateAssignment rule contexts.
	Get_updateAssignment() IUpdateAssignmentContext

	// Set_updateAssignment sets the _updateAssignment rule contexts.
	Set_updateAssignment(IUpdateAssignmentContext)

	// GetAssignments returns the assignments rule context list.
	GetAssignments() []IUpdateAssignmentContext

	// SetAssignments sets the assignments rule context list.
	SetAssignments([]IUpdateAssignmentContext)

	// Getter signatures
	AllUpdateAssignment() []IUpdateAssignmentContext
	UpdateAssignment(i int) IUpdateAssignmentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsUpdateAssignmentSeqContext differentiates from other interfaces.
	IsUpdateAssignmentSeqContext()
}

type UpdateAssignmentSeqContext struct {
	antlr.BaseParserRuleContext
	parser            antlr.Parser
	_updateAssignment IUpdateAssignmentContext
	assignments       []IUpdateAssignmentContext
}

func NewEmptyUpdateAssignmentSeqContext() *UpdateAssignmentSeqContext {
	var p = new(UpdateAssignmentSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_updateAssignmentSeq
	return p
}

func InitEmptyUpdateAssignmentSeqContext(p *UpdateAssignmentSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_updateAssignmentSeq
}

func (*UpdateAssignmentSeqContext) IsUpdateAssignmentSeqContext() {}

func NewUpdateAssignmentSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateAssignmentSeqContext {
	var p = new(UpdateAssignmentSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_updateAssignmentSeq

	return p
}

func (s *UpdateAssignmentSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateAssignmentSeqContext) Get_updateAssignment() IUpdateAssignmentContext {
	return s._updateAssignment
}

func (s *UpdateAssignmentSeqContext) Set_updateAssignment(v IUpdateAssignmentContext) {
	s._updateAssignment = v
}

func (s *UpdateAssignmentSeqContext) GetAssignments() []IUpdateAssignmentContext {
	return s.assignments
}

func (s *UpdateAssignmentSeqContext) SetAssignments(v []IUpdateAssignmentContext) { s.assignments = v }

func (s *UpdateAssignmentSeqContext) AllUpdateAssignment() []IUpdateAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdateAssignmentContext); ok {
			len++
		}
	}

	tst := make([]IUpdateAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdateAssignmentContext); ok {
			tst[i] = t.(IUpdateAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *UpdateAssignmentSeqContext) UpdateAssignment(i int) IUpdateAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateAssignmentContext)
}

func (s *UpdateAssignmentSeqContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *UpdateAssignmentSeqContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *UpdateAssignmentSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateAssignmentSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateAssignmentSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUpdateAssignmentSeq(s)
	}
}

func (s *UpdateAssignmentSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUpdateAssignmentSeq(s)
	}
}

func (p *DorisParser) UpdateAssignmentSeq() (localctx IUpdateAssignmentSeqContext) {
	localctx = NewUpdateAssignmentSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, DorisParserRULE_updateAssignmentSeq)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3356)

		var _x = p.UpdateAssignment()

		localctx.(*UpdateAssignmentSeqContext)._updateAssignment = _x
	}
	localctx.(*UpdateAssignmentSeqContext).assignments = append(localctx.(*UpdateAssignmentSeqContext).assignments, localctx.(*UpdateAssignmentSeqContext)._updateAssignment)
	p.SetState(3361)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(3357)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3358)

			var _x = p.UpdateAssignment()

			localctx.(*UpdateAssignmentSeqContext)._updateAssignment = _x
		}
		localctx.(*UpdateAssignmentSeqContext).assignments = append(localctx.(*UpdateAssignmentSeqContext).assignments, localctx.(*UpdateAssignmentSeqContext)._updateAssignment)

		p.SetState(3363)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILateralViewContext is an interface to support dynamic dispatch.
type ILateralViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFunctionName returns the functionName rule contexts.
	GetFunctionName() IIdentifierContext

	// GetTableName returns the tableName rule contexts.
	GetTableName() IIdentifierContext

	// Get_identifier returns the _identifier rule contexts.
	Get_identifier() IIdentifierContext

	// SetFunctionName sets the functionName rule contexts.
	SetFunctionName(IIdentifierContext)

	// SetTableName sets the tableName rule contexts.
	SetTableName(IIdentifierContext)

	// Set_identifier sets the _identifier rule contexts.
	Set_identifier(IIdentifierContext)

	// GetColumnNames returns the columnNames rule context list.
	GetColumnNames() []IIdentifierContext

	// SetColumnNames sets the columnNames rule context list.
	SetColumnNames([]IIdentifierContext)

	// Getter signatures
	LATERAL() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AS() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLateralViewContext differentiates from other interfaces.
	IsLateralViewContext()
}

type LateralViewContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	functionName IIdentifierContext
	tableName    IIdentifierContext
	_identifier  IIdentifierContext
	columnNames  []IIdentifierContext
}

func NewEmptyLateralViewContext() *LateralViewContext {
	var p = new(LateralViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_lateralView
	return p
}

func InitEmptyLateralViewContext(p *LateralViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_lateralView
}

func (*LateralViewContext) IsLateralViewContext() {}

func NewLateralViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LateralViewContext {
	var p = new(LateralViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_lateralView

	return p
}

func (s *LateralViewContext) GetParser() antlr.Parser { return s.parser }

func (s *LateralViewContext) GetFunctionName() IIdentifierContext { return s.functionName }

func (s *LateralViewContext) GetTableName() IIdentifierContext { return s.tableName }

func (s *LateralViewContext) Get_identifier() IIdentifierContext { return s._identifier }

func (s *LateralViewContext) SetFunctionName(v IIdentifierContext) { s.functionName = v }

func (s *LateralViewContext) SetTableName(v IIdentifierContext) { s.tableName = v }

func (s *LateralViewContext) Set_identifier(v IIdentifierContext) { s._identifier = v }

func (s *LateralViewContext) GetColumnNames() []IIdentifierContext { return s.columnNames }

func (s *LateralViewContext) SetColumnNames(v []IIdentifierContext) { s.columnNames = v }

func (s *LateralViewContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLATERAL, 0)
}

func (s *LateralViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *LateralViewContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *LateralViewContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *LateralViewContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *LateralViewContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *LateralViewContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LateralViewContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LateralViewContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LateralViewContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *LateralViewContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *LateralViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LateralViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LateralViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLateralView(s)
	}
}

func (s *LateralViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLateralView(s)
	}
}

func (p *DorisParser) LateralView() (localctx ILateralViewContext) {
	localctx = NewLateralViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, DorisParserRULE_lateralView)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3364)
		p.Match(DorisParserLATERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3365)
		p.Match(DorisParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3366)

		var _x = p.Identifier()

		localctx.(*LateralViewContext).functionName = _x
	}
	{
		p.SetState(3367)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1153005225580239228) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-141717009369345) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-4539691388701481817) != 0) || ((int64((_la-195)) & ^0x3f) == 0 && ((int64(1)<<(_la-195))&-3103018623212733835) != 0) || ((int64((_la-259)) & ^0x3f) == 0 && ((int64(1)<<(_la-259))&-9089391056176578961) != 0) || ((int64((_la-323)) & ^0x3f) == 0 && ((int64(1)<<(_la-323))&-2310857813124972547) != 0) || ((int64((_la-387)) & ^0x3f) == 0 && ((int64(1)<<(_la-387))&-5255560032135782599) != 0) || ((int64((_la-451)) & ^0x3f) == 0 && ((int64(1)<<(_la-451))&5621092667580571559) != 0) || ((int64((_la-516)) & ^0x3f) == 0 && ((int64(1)<<(_la-516))&3608513) != 0) {
		{
			p.SetState(3368)
			p.Expression()
		}
		p.SetState(3373)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(3369)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3370)
				p.Expression()
			}

			p.SetState(3375)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3378)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3379)

		var _x = p.Identifier()

		localctx.(*LateralViewContext).tableName = _x
	}
	{
		p.SetState(3380)
		p.Match(DorisParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3381)

		var _x = p.Identifier()

		localctx.(*LateralViewContext)._identifier = _x
	}
	localctx.(*LateralViewContext).columnNames = append(localctx.(*LateralViewContext).columnNames, localctx.(*LateralViewContext)._identifier)
	p.SetState(3386)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 467, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3382)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3383)

				var _x = p.Identifier()

				localctx.(*LateralViewContext)._identifier = _x
			}
			localctx.(*LateralViewContext).columnNames = append(localctx.(*LateralViewContext).columnNames, localctx.(*LateralViewContext)._identifier)

		}
		p.SetState(3388)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 467, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryOrganizationContext is an interface to support dynamic dispatch.
type IQueryOrganizationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SortClause() ISortClauseContext
	LimitClause() ILimitClauseContext

	// IsQueryOrganizationContext differentiates from other interfaces.
	IsQueryOrganizationContext()
}

type QueryOrganizationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryOrganizationContext() *QueryOrganizationContext {
	var p = new(QueryOrganizationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_queryOrganization
	return p
}

func InitEmptyQueryOrganizationContext(p *QueryOrganizationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_queryOrganization
}

func (*QueryOrganizationContext) IsQueryOrganizationContext() {}

func NewQueryOrganizationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryOrganizationContext {
	var p = new(QueryOrganizationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_queryOrganization

	return p
}

func (s *QueryOrganizationContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryOrganizationContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *QueryOrganizationContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QueryOrganizationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryOrganizationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryOrganizationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterQueryOrganization(s)
	}
}

func (s *QueryOrganizationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitQueryOrganization(s)
	}
}

func (p *DorisParser) QueryOrganization() (localctx IQueryOrganizationContext) {
	localctx = NewQueryOrganizationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, DorisParserRULE_queryOrganization)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(3390)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 468, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3389)
			p.SortClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3393)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 469, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3392)
			p.LimitClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortClauseContext is an interface to support dynamic dispatch.
type ISortClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSortClauseContext differentiates from other interfaces.
	IsSortClauseContext()
}

type SortClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortClauseContext() *SortClauseContext {
	var p = new(SortClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sortClause
	return p
}

func InitEmptySortClauseContext(p *SortClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sortClause
}

func (*SortClauseContext) IsSortClauseContext() {}

func NewSortClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortClauseContext {
	var p = new(SortClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_sortClause

	return p
}

func (s *SortClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisParserORDER, 0)
}

func (s *SortClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *SortClauseContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *SortClauseContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *SortClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *SortClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *SortClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSortClause(s)
	}
}

func (s *SortClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSortClause(s)
	}
}

func (p *DorisParser) SortClause() (localctx ISortClauseContext) {
	localctx = NewSortClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, DorisParserRULE_sortClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3395)
		p.Match(DorisParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3396)
		p.Match(DorisParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3397)
		p.SortItem()
	}
	p.SetState(3402)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 470, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3398)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3399)
				p.SortItem()
			}

		}
		p.SetState(3404)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 470, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortItemContext is an interface to support dynamic dispatch.
type ISortItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrdering returns the ordering token.
	GetOrdering() antlr.Token

	// SetOrdering sets the ordering token.
	SetOrdering(antlr.Token)

	// Getter signatures
	Expression() IExpressionContext
	NULLS() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsSortItemContext differentiates from other interfaces.
	IsSortItemContext()
}

type SortItemContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	ordering antlr.Token
}

func NewEmptySortItemContext() *SortItemContext {
	var p = new(SortItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sortItem
	return p
}

func InitEmptySortItemContext(p *SortItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sortItem
}

func (*SortItemContext) IsSortItemContext() {}

func NewSortItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortItemContext {
	var p = new(SortItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_sortItem

	return p
}

func (s *SortItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SortItemContext) GetOrdering() antlr.Token { return s.ordering }

func (s *SortItemContext) SetOrdering(v antlr.Token) { s.ordering = v }

func (s *SortItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SortItemContext) NULLS() antlr.TerminalNode {
	return s.GetToken(DorisParserNULLS, 0)
}

func (s *SortItemContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DorisParserFIRST, 0)
}

func (s *SortItemContext) LAST() antlr.TerminalNode {
	return s.GetToken(DorisParserLAST, 0)
}

func (s *SortItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(DorisParserASC, 0)
}

func (s *SortItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(DorisParserDESC, 0)
}

func (s *SortItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSortItem(s)
	}
}

func (s *SortItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSortItem(s)
	}
}

func (p *DorisParser) SortItem() (localctx ISortItemContext) {
	localctx = NewSortItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, DorisParserRULE_sortItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3405)
		p.Expression()
	}
	p.SetState(3407)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 471, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3406)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).ordering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserASC || _la == DorisParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).ordering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3411)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 472, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3409)
			p.Match(DorisParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3410)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserFIRST || _la == DorisParserLAST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// GetOffset returns the offset token.
	GetOffset() antlr.Token

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// SetOffset sets the offset token.
	SetOffset(antlr.Token)

	// Getter signatures
	LIMIT() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	limit  antlr.Token
	offset antlr.Token
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_limitClause
	return p
}

func InitEmptyLimitClauseContext(p *LimitClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_limitClause
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) GetLimit() antlr.Token { return s.limit }

func (s *LimitClauseContext) GetOffset() antlr.Token { return s.offset }

func (s *LimitClauseContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *LimitClauseContext) SetOffset(v antlr.Token) { s.offset = v }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(DorisParserLIMIT, 0)
}

func (s *LimitClauseContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserINTEGER_VALUE)
}

func (s *LimitClauseContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, i)
}

func (s *LimitClauseContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(DorisParserOFFSET, 0)
}

func (s *LimitClauseContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, 0)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLimitClause(s)
	}
}

func (p *DorisParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, DorisParserRULE_limitClause)
	p.SetState(3423)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 473, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3413)
			p.Match(DorisParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3414)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*LimitClauseContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3415)
			p.Match(DorisParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3416)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*LimitClauseContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3417)
			p.Match(DorisParserOFFSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3418)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*LimitClauseContext).offset = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3419)
			p.Match(DorisParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3420)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*LimitClauseContext).offset = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3421)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3422)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*LimitClauseContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionClauseContext is an interface to support dynamic dispatch.
type IPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionClauseContext differentiates from other interfaces.
	IsPartitionClauseContext()
}

type PartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionClauseContext() *PartitionClauseContext {
	var p = new(PartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionClause
	return p
}

func InitEmptyPartitionClauseContext(p *PartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionClause
}

func (*PartitionClauseContext) IsPartitionClauseContext() {}

func NewPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionClauseContext {
	var p = new(PartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_partitionClause

	return p
}

func (s *PartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *PartitionClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *PartitionClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *PartitionClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *PartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPartitionClause(s)
	}
}

func (s *PartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPartitionClause(s)
	}
}

func (p *DorisParser) PartitionClause() (localctx IPartitionClauseContext) {
	localctx = NewPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, DorisParserRULE_partitionClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3425)
		p.Match(DorisParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3426)
		p.Match(DorisParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3427)
		p.Expression()
	}
	p.SetState(3432)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(3428)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3429)
			p.Expression()
		}

		p.SetState(3434)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinTypeContext is an interface to support dynamic dispatch.
type IJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INNER() antlr.TerminalNode
	CROSS() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	FULL() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	ANTI() antlr.TerminalNode

	// IsJoinTypeContext differentiates from other interfaces.
	IsJoinTypeContext()
}

type JoinTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinTypeContext() *JoinTypeContext {
	var p = new(JoinTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_joinType
	return p
}

func InitEmptyJoinTypeContext(p *JoinTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_joinType
}

func (*JoinTypeContext) IsJoinTypeContext() {}

func NewJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinTypeContext {
	var p = new(JoinTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_joinType

	return p
}

func (s *JoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinTypeContext) INNER() antlr.TerminalNode {
	return s.GetToken(DorisParserINNER, 0)
}

func (s *JoinTypeContext) CROSS() antlr.TerminalNode {
	return s.GetToken(DorisParserCROSS, 0)
}

func (s *JoinTypeContext) LEFT() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT, 0)
}

func (s *JoinTypeContext) OUTER() antlr.TerminalNode {
	return s.GetToken(DorisParserOUTER, 0)
}

func (s *JoinTypeContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT, 0)
}

func (s *JoinTypeContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserFULL, 0)
}

func (s *JoinTypeContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DorisParserSEMI, 0)
}

func (s *JoinTypeContext) ANTI() antlr.TerminalNode {
	return s.GetToken(DorisParserANTI, 0)
}

func (s *JoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterJoinType(s)
	}
}

func (s *JoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitJoinType(s)
	}
}

func (p *DorisParser) JoinType() (localctx IJoinTypeContext) {
	localctx = NewJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, DorisParserRULE_joinType)
	var _la int

	p.SetState(3459)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 479, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3436)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserINNER {
			{
				p.SetState(3435)
				p.Match(DorisParserINNER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3438)
			p.Match(DorisParserCROSS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3439)
			p.Match(DorisParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3441)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserOUTER {
			{
				p.SetState(3440)
				p.Match(DorisParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3443)
			p.Match(DorisParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3445)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserOUTER {
			{
				p.SetState(3444)
				p.Match(DorisParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3447)
			p.Match(DorisParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3449)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserOUTER {
			{
				p.SetState(3448)
				p.Match(DorisParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3451)
			p.Match(DorisParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3452)
			p.Match(DorisParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3453)
			p.Match(DorisParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3454)
			p.Match(DorisParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3455)
			p.Match(DorisParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3456)
			p.Match(DorisParserANTI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3457)
			p.Match(DorisParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3458)
			p.Match(DorisParserANTI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinCriteriaContext is an interface to support dynamic dispatch.
type IJoinCriteriaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext
	USING() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsJoinCriteriaContext differentiates from other interfaces.
	IsJoinCriteriaContext()
}

type JoinCriteriaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinCriteriaContext() *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_joinCriteria
	return p
}

func InitEmptyJoinCriteriaContext(p *JoinCriteriaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_joinCriteria
}

func (*JoinCriteriaContext) IsJoinCriteriaContext() {}

func NewJoinCriteriaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_joinCriteria

	return p
}

func (s *JoinCriteriaContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinCriteriaContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *JoinCriteriaContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *JoinCriteriaContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserUSING, 0)
}

func (s *JoinCriteriaContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *JoinCriteriaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinCriteriaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinCriteriaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitJoinCriteria(s)
	}
}

func (p *DorisParser) JoinCriteria() (localctx IJoinCriteriaContext) {
	localctx = NewJoinCriteriaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, DorisParserRULE_joinCriteria)
	p.SetState(3465)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3461)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3462)
			p.booleanExpression(0)
		}

	case DorisParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3463)
			p.Match(DorisParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3464)
			p.IdentifierList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	IdentifierSeq() IIdentifierSeqContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierList
	return p
}

func InitEmptyIdentifierListContext(p *IdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierList
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *IdentifierListContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *IdentifierListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (p *DorisParser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, DorisParserRULE_identifierList)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3467)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3468)
		p.IdentifierSeq()
	}
	{
		p.SetState(3469)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierSeqContext is an interface to support dynamic dispatch.
type IIdentifierSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_errorCapturingIdentifier returns the _errorCapturingIdentifier rule contexts.
	Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext

	// Set_errorCapturingIdentifier sets the _errorCapturingIdentifier rule contexts.
	Set_errorCapturingIdentifier(IErrorCapturingIdentifierContext)

	// GetIdent returns the ident rule context list.
	GetIdent() []IErrorCapturingIdentifierContext

	// SetIdent sets the ident rule context list.
	SetIdent([]IErrorCapturingIdentifierContext)

	// Getter signatures
	AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext
	ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentifierSeqContext differentiates from other interfaces.
	IsIdentifierSeqContext()
}

type IdentifierSeqContext struct {
	antlr.BaseParserRuleContext
	parser                    antlr.Parser
	_errorCapturingIdentifier IErrorCapturingIdentifierContext
	ident                     []IErrorCapturingIdentifierContext
}

func NewEmptyIdentifierSeqContext() *IdentifierSeqContext {
	var p = new(IdentifierSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierSeq
	return p
}

func InitEmptyIdentifierSeqContext(p *IdentifierSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierSeq
}

func (*IdentifierSeqContext) IsIdentifierSeqContext() {}

func NewIdentifierSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierSeqContext {
	var p = new(IdentifierSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_identifierSeq

	return p
}

func (s *IdentifierSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierSeqContext) Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext {
	return s._errorCapturingIdentifier
}

func (s *IdentifierSeqContext) Set_errorCapturingIdentifier(v IErrorCapturingIdentifierContext) {
	s._errorCapturingIdentifier = v
}

func (s *IdentifierSeqContext) GetIdent() []IErrorCapturingIdentifierContext { return s.ident }

func (s *IdentifierSeqContext) SetIdent(v []IErrorCapturingIdentifierContext) { s.ident = v }

func (s *IdentifierSeqContext) AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IErrorCapturingIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			tst[i] = t.(IErrorCapturingIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierSeqContext) ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *IdentifierSeqContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *IdentifierSeqContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *IdentifierSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIdentifierSeq(s)
	}
}

func (s *IdentifierSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIdentifierSeq(s)
	}
}

func (p *DorisParser) IdentifierSeq() (localctx IIdentifierSeqContext) {
	localctx = NewIdentifierSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, DorisParserRULE_identifierSeq)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3471)

		var _x = p.ErrorCapturingIdentifier()

		localctx.(*IdentifierSeqContext)._errorCapturingIdentifier = _x
	}
	localctx.(*IdentifierSeqContext).ident = append(localctx.(*IdentifierSeqContext).ident, localctx.(*IdentifierSeqContext)._errorCapturingIdentifier)
	p.SetState(3476)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(3472)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3473)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*IdentifierSeqContext)._errorCapturingIdentifier = _x
		}
		localctx.(*IdentifierSeqContext).ident = append(localctx.(*IdentifierSeqContext).ident, localctx.(*IdentifierSeqContext)._errorCapturingIdentifier)

		p.SetState(3478)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptScanParamsContext is an interface to support dynamic dispatch.
type IOptScanParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFuncName returns the funcName rule contexts.
	GetFuncName() IIdentifierContext

	// GetProperties returns the properties rule contexts.
	GetProperties() IPropertyItemListContext

	// SetFuncName sets the funcName rule contexts.
	SetFuncName(IIdentifierContext)

	// SetProperties sets the properties rule contexts.
	SetProperties(IPropertyItemListContext)

	// Getter signatures
	ATSIGN() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	PropertyItemList() IPropertyItemListContext

	// IsOptScanParamsContext differentiates from other interfaces.
	IsOptScanParamsContext()
}

type OptScanParamsContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	funcName   IIdentifierContext
	properties IPropertyItemListContext
}

func NewEmptyOptScanParamsContext() *OptScanParamsContext {
	var p = new(OptScanParamsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_optScanParams
	return p
}

func InitEmptyOptScanParamsContext(p *OptScanParamsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_optScanParams
}

func (*OptScanParamsContext) IsOptScanParamsContext() {}

func NewOptScanParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptScanParamsContext {
	var p = new(OptScanParamsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_optScanParams

	return p
}

func (s *OptScanParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *OptScanParamsContext) GetFuncName() IIdentifierContext { return s.funcName }

func (s *OptScanParamsContext) GetProperties() IPropertyItemListContext { return s.properties }

func (s *OptScanParamsContext) SetFuncName(v IIdentifierContext) { s.funcName = v }

func (s *OptScanParamsContext) SetProperties(v IPropertyItemListContext) { s.properties = v }

func (s *OptScanParamsContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserATSIGN, 0)
}

func (s *OptScanParamsContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *OptScanParamsContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *OptScanParamsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *OptScanParamsContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *OptScanParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptScanParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptScanParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterOptScanParams(s)
	}
}

func (s *OptScanParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitOptScanParams(s)
	}
}

func (p *DorisParser) OptScanParams() (localctx IOptScanParamsContext) {
	localctx = NewOptScanParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, DorisParserRULE_optScanParams)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3479)
		p.Match(DorisParserATSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3480)

		var _x = p.Identifier()

		localctx.(*OptScanParamsContext).funcName = _x
	}
	{
		p.SetState(3481)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3483)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1153005225580255616) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&-53021438386753) != 0) || ((int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&3476727437124114729) != 0) || ((int64((_la-195)) & ^0x3f) == 0 && ((int64(1)<<(_la-195))&-3139048519776880011) != 0) || ((int64((_la-260)) & ^0x3f) == 0 && ((int64(1)<<(_la-260))&-4544765896832467149) != 0) || ((int64((_la-325)) & ^0x3f) == 0 && ((int64(1)<<(_la-325))&6339805778266816511) != 0) || ((int64((_la-390)) & ^0x3f) == 0 && ((int64(1)<<(_la-390))&-656945004016972825) != 0) || ((int64((_la-456)) & ^0x3f) == 0 && ((int64(1)<<(_la-456))&9025959649184493) != 0) || ((int64((_la-522)) & ^0x3f) == 0 && ((int64(1)<<(_la-522))&56359) != 0) {
		{
			p.SetState(3482)

			var _x = p.PropertyItemList()

			localctx.(*OptScanParamsContext).properties = _x
		}

	}
	{
		p.SetState(3485)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationPrimaryContext is an interface to support dynamic dispatch.
type IRelationPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationPrimaryContext differentiates from other interfaces.
	IsRelationPrimaryContext()
}

type RelationPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationPrimaryContext() *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_relationPrimary
	return p
}

func InitEmptyRelationPrimaryContext(p *RelationPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_relationPrimary
}

func (*RelationPrimaryContext) IsRelationPrimaryContext() {}

func NewRelationPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_relationPrimary

	return p
}

func (s *RelationPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationPrimaryContext) CopyAll(ctx *RelationPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RelationPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableValuedFunctionContext struct {
	RelationPrimaryContext
	tvfName    IIdentifierContext
	properties IPropertyItemListContext
}

func NewTableValuedFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableValuedFunctionContext {
	var p = new(TableValuedFunctionContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableValuedFunctionContext) GetTvfName() IIdentifierContext { return s.tvfName }

func (s *TableValuedFunctionContext) GetProperties() IPropertyItemListContext { return s.properties }

func (s *TableValuedFunctionContext) SetTvfName(v IIdentifierContext) { s.tvfName = v }

func (s *TableValuedFunctionContext) SetProperties(v IPropertyItemListContext) { s.properties = v }

func (s *TableValuedFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableValuedFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *TableValuedFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *TableValuedFunctionContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *TableValuedFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableValuedFunctionContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *TableValuedFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTableValuedFunction(s)
	}
}

func (s *TableValuedFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTableValuedFunction(s)
	}
}

type RelationListContext struct {
	RelationPrimaryContext
}

func NewRelationListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationListContext {
	var p = new(RelationListContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *RelationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *RelationListContext) Relations() IRelationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationsContext)
}

func (s *RelationListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *RelationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRelationList(s)
	}
}

func (s *RelationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRelationList(s)
	}
}

type AliasedQueryContext struct {
	RelationPrimaryContext
}

func NewAliasedQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AliasedQueryContext {
	var p = new(AliasedQueryContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *AliasedQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasedQueryContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AliasedQueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *AliasedQueryContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AliasedQueryContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *AliasedQueryContext) AllLateralView() []ILateralViewContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILateralViewContext); ok {
			len++
		}
	}

	tst := make([]ILateralViewContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILateralViewContext); ok {
			tst[i] = t.(ILateralViewContext)
			i++
		}
	}

	return tst
}

func (s *AliasedQueryContext) LateralView(i int) ILateralViewContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILateralViewContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILateralViewContext)
}

func (s *AliasedQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAliasedQuery(s)
	}
}

func (s *AliasedQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAliasedQuery(s)
	}
}

type TableNameContext struct {
	RelationPrimaryContext
}

func NewTableNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableNameContext {
	var p = new(TableNameContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *TableNameContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *TableNameContext) OptScanParams() IOptScanParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptScanParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptScanParamsContext)
}

func (s *TableNameContext) MaterializedViewName() IMaterializedViewNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaterializedViewNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaterializedViewNameContext)
}

func (s *TableNameContext) TableSnapshot() ITableSnapshotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSnapshotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSnapshotContext)
}

func (s *TableNameContext) SpecifiedPartition() ISpecifiedPartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecifiedPartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecifiedPartitionContext)
}

func (s *TableNameContext) TabletList() ITabletListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabletListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabletListContext)
}

func (s *TableNameContext) Sample() ISampleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleContext)
}

func (s *TableNameContext) RelationHint() IRelationHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationHintContext)
}

func (s *TableNameContext) AllLateralView() []ILateralViewContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILateralViewContext); ok {
			len++
		}
	}

	tst := make([]ILateralViewContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILateralViewContext); ok {
			tst[i] = t.(ILateralViewContext)
			i++
		}
	}

	return tst
}

func (s *TableNameContext) LateralView(i int) ILateralViewContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILateralViewContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILateralViewContext)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (p *DorisParser) RelationPrimary() (localctx IRelationPrimaryContext) {
	localctx = NewRelationPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, DorisParserRULE_relationPrimary)
	var _la int

	var _alt int

	p.SetState(3538)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 493, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableNameContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3487)
			p.MultipartIdentifier()
		}
		p.SetState(3489)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 483, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3488)
				p.OptScanParams()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3492)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 484, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3491)
				p.MaterializedViewName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3495)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 485, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3494)
				p.TableSnapshot()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3498)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 486, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3497)
				p.SpecifiedPartition()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3501)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 487, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3500)
				p.TabletList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3503)
			p.TableAlias()
		}
		p.SetState(3505)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 488, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3504)
				p.Sample()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3508)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 489, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3507)
				p.RelationHint()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3513)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 490, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3510)
					p.LateralView()
				}

			}
			p.SetState(3515)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 490, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		localctx = NewAliasedQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3516)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3517)
			p.Query()
		}
		{
			p.SetState(3518)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3519)
			p.TableAlias()
		}
		p.SetState(3523)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 491, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3520)
					p.LateralView()
				}

			}
			p.SetState(3525)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 491, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 3:
		localctx = NewTableValuedFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3526)

			var _x = p.Identifier()

			localctx.(*TableValuedFunctionContext).tvfName = _x
		}
		{
			p.SetState(3527)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3529)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1153005225580255616) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&-53021438386753) != 0) || ((int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&3476727437124114729) != 0) || ((int64((_la-195)) & ^0x3f) == 0 && ((int64(1)<<(_la-195))&-3139048519776880011) != 0) || ((int64((_la-260)) & ^0x3f) == 0 && ((int64(1)<<(_la-260))&-4544765896832467149) != 0) || ((int64((_la-325)) & ^0x3f) == 0 && ((int64(1)<<(_la-325))&6339805778266816511) != 0) || ((int64((_la-390)) & ^0x3f) == 0 && ((int64(1)<<(_la-390))&-656945004016972825) != 0) || ((int64((_la-456)) & ^0x3f) == 0 && ((int64(1)<<(_la-456))&9025959649184493) != 0) || ((int64((_la-522)) & ^0x3f) == 0 && ((int64(1)<<(_la-522))&56359) != 0) {
			{
				p.SetState(3528)

				var _x = p.PropertyItemList()

				localctx.(*TableValuedFunctionContext).properties = _x
			}

		}
		{
			p.SetState(3531)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3532)
			p.TableAlias()
		}

	case 4:
		localctx = NewRelationListContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3534)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3535)
			p.Relations()
		}
		{
			p.SetState(3536)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaterializedViewNameContext is an interface to support dynamic dispatch.
type IMaterializedViewNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// Getter signatures
	INDEX() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsMaterializedViewNameContext differentiates from other interfaces.
	IsMaterializedViewNameContext()
}

type MaterializedViewNameContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	indexName IIdentifierContext
}

func NewEmptyMaterializedViewNameContext() *MaterializedViewNameContext {
	var p = new(MaterializedViewNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_materializedViewName
	return p
}

func InitEmptyMaterializedViewNameContext(p *MaterializedViewNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_materializedViewName
}

func (*MaterializedViewNameContext) IsMaterializedViewNameContext() {}

func NewMaterializedViewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaterializedViewNameContext {
	var p = new(MaterializedViewNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_materializedViewName

	return p
}

func (s *MaterializedViewNameContext) GetParser() antlr.Parser { return s.parser }

func (s *MaterializedViewNameContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *MaterializedViewNameContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *MaterializedViewNameContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *MaterializedViewNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MaterializedViewNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaterializedViewNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaterializedViewNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMaterializedViewName(s)
	}
}

func (s *MaterializedViewNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMaterializedViewName(s)
	}
}

func (p *DorisParser) MaterializedViewName() (localctx IMaterializedViewNameContext) {
	localctx = NewMaterializedViewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, DorisParserRULE_materializedViewName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3540)
		p.Match(DorisParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3541)

		var _x = p.Identifier()

		localctx.(*MaterializedViewNameContext).indexName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyClauseContext is an interface to support dynamic dispatch.
type IPropertyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFileProperties returns the fileProperties rule contexts.
	GetFileProperties() IPropertyItemListContext

	// SetFileProperties sets the fileProperties rule contexts.
	SetFileProperties(IPropertyItemListContext)

	// Getter signatures
	PROPERTIES() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	PropertyItemList() IPropertyItemListContext

	// IsPropertyClauseContext differentiates from other interfaces.
	IsPropertyClauseContext()
}

type PropertyClauseContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	fileProperties IPropertyItemListContext
}

func NewEmptyPropertyClauseContext() *PropertyClauseContext {
	var p = new(PropertyClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyClause
	return p
}

func InitEmptyPropertyClauseContext(p *PropertyClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyClause
}

func (*PropertyClauseContext) IsPropertyClauseContext() {}

func NewPropertyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyClauseContext {
	var p = new(PropertyClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_propertyClause

	return p
}

func (s *PropertyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyClauseContext) GetFileProperties() IPropertyItemListContext { return s.fileProperties }

func (s *PropertyClauseContext) SetFileProperties(v IPropertyItemListContext) { s.fileProperties = v }

func (s *PropertyClauseContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *PropertyClauseContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *PropertyClauseContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *PropertyClauseContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *PropertyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPropertyClause(s)
	}
}

func (s *PropertyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPropertyClause(s)
	}
}

func (p *DorisParser) PropertyClause() (localctx IPropertyClauseContext) {
	localctx = NewPropertyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, DorisParserRULE_propertyClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3543)
		p.Match(DorisParserPROPERTIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3544)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3545)

		var _x = p.PropertyItemList()

		localctx.(*PropertyClauseContext).fileProperties = _x
	}
	{
		p.SetState(3546)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyItemListContext is an interface to support dynamic dispatch.
type IPropertyItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_propertyItem returns the _propertyItem rule contexts.
	Get_propertyItem() IPropertyItemContext

	// Set_propertyItem sets the _propertyItem rule contexts.
	Set_propertyItem(IPropertyItemContext)

	// GetProperties returns the properties rule context list.
	GetProperties() []IPropertyItemContext

	// SetProperties sets the properties rule context list.
	SetProperties([]IPropertyItemContext)

	// Getter signatures
	AllPropertyItem() []IPropertyItemContext
	PropertyItem(i int) IPropertyItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPropertyItemListContext differentiates from other interfaces.
	IsPropertyItemListContext()
}

type PropertyItemListContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	_propertyItem IPropertyItemContext
	properties    []IPropertyItemContext
}

func NewEmptyPropertyItemListContext() *PropertyItemListContext {
	var p = new(PropertyItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyItemList
	return p
}

func InitEmptyPropertyItemListContext(p *PropertyItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyItemList
}

func (*PropertyItemListContext) IsPropertyItemListContext() {}

func NewPropertyItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyItemListContext {
	var p = new(PropertyItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_propertyItemList

	return p
}

func (s *PropertyItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyItemListContext) Get_propertyItem() IPropertyItemContext { return s._propertyItem }

func (s *PropertyItemListContext) Set_propertyItem(v IPropertyItemContext) { s._propertyItem = v }

func (s *PropertyItemListContext) GetProperties() []IPropertyItemContext { return s.properties }

func (s *PropertyItemListContext) SetProperties(v []IPropertyItemContext) { s.properties = v }

func (s *PropertyItemListContext) AllPropertyItem() []IPropertyItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyItemContext); ok {
			len++
		}
	}

	tst := make([]IPropertyItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyItemContext); ok {
			tst[i] = t.(IPropertyItemContext)
			i++
		}
	}

	return tst
}

func (s *PropertyItemListContext) PropertyItem(i int) IPropertyItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemContext)
}

func (s *PropertyItemListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *PropertyItemListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *PropertyItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPropertyItemList(s)
	}
}

func (s *PropertyItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPropertyItemList(s)
	}
}

func (p *DorisParser) PropertyItemList() (localctx IPropertyItemListContext) {
	localctx = NewPropertyItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, DorisParserRULE_propertyItemList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3548)

		var _x = p.PropertyItem()

		localctx.(*PropertyItemListContext)._propertyItem = _x
	}
	localctx.(*PropertyItemListContext).properties = append(localctx.(*PropertyItemListContext).properties, localctx.(*PropertyItemListContext)._propertyItem)
	p.SetState(3553)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(3549)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3550)

			var _x = p.PropertyItem()

			localctx.(*PropertyItemListContext)._propertyItem = _x
		}
		localctx.(*PropertyItemListContext).properties = append(localctx.(*PropertyItemListContext).properties, localctx.(*PropertyItemListContext)._propertyItem)

		p.SetState(3555)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyItemContext is an interface to support dynamic dispatch.
type IPropertyItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IPropertyKeyContext

	// GetValue returns the value rule contexts.
	GetValue() IPropertyValueContext

	// SetKey sets the key rule contexts.
	SetKey(IPropertyKeyContext)

	// SetValue sets the value rule contexts.
	SetValue(IPropertyValueContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	PropertyKey() IPropertyKeyContext
	PropertyValue() IPropertyValueContext

	// IsPropertyItemContext differentiates from other interfaces.
	IsPropertyItemContext()
}

type PropertyItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IPropertyKeyContext
	value  IPropertyValueContext
}

func NewEmptyPropertyItemContext() *PropertyItemContext {
	var p = new(PropertyItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyItem
	return p
}

func InitEmptyPropertyItemContext(p *PropertyItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyItem
}

func (*PropertyItemContext) IsPropertyItemContext() {}

func NewPropertyItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyItemContext {
	var p = new(PropertyItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_propertyItem

	return p
}

func (s *PropertyItemContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyItemContext) GetKey() IPropertyKeyContext { return s.key }

func (s *PropertyItemContext) GetValue() IPropertyValueContext { return s.value }

func (s *PropertyItemContext) SetKey(v IPropertyKeyContext) { s.key = v }

func (s *PropertyItemContext) SetValue(v IPropertyValueContext) { s.value = v }

func (s *PropertyItemContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *PropertyItemContext) PropertyKey() IPropertyKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyKeyContext)
}

func (s *PropertyItemContext) PropertyValue() IPropertyValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyValueContext)
}

func (s *PropertyItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPropertyItem(s)
	}
}

func (s *PropertyItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPropertyItem(s)
	}
}

func (p *DorisParser) PropertyItem() (localctx IPropertyItemContext) {
	localctx = NewPropertyItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, DorisParserRULE_propertyItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3556)

		var _x = p.PropertyKey()

		localctx.(*PropertyItemContext).key = _x
	}
	{
		p.SetState(3557)
		p.Match(DorisParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3558)

		var _x = p.PropertyValue()

		localctx.(*PropertyItemContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyKeyContext is an interface to support dynamic dispatch.
type IPropertyKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Constant() IConstantContext

	// IsPropertyKeyContext differentiates from other interfaces.
	IsPropertyKeyContext()
}

type PropertyKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyKeyContext() *PropertyKeyContext {
	var p = new(PropertyKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyKey
	return p
}

func InitEmptyPropertyKeyContext(p *PropertyKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyKey
}

func (*PropertyKeyContext) IsPropertyKeyContext() {}

func NewPropertyKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyKeyContext {
	var p = new(PropertyKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_propertyKey

	return p
}

func (s *PropertyKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyKeyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyKeyContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *PropertyKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPropertyKey(s)
	}
}

func (s *PropertyKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPropertyKey(s)
	}
}

func (p *DorisParser) PropertyKey() (localctx IPropertyKeyContext) {
	localctx = NewPropertyKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, DorisParserRULE_propertyKey)
	p.SetState(3562)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 495, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3560)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3561)
			p.Constant()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyValueContext is an interface to support dynamic dispatch.
type IPropertyValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Constant() IConstantContext

	// IsPropertyValueContext differentiates from other interfaces.
	IsPropertyValueContext()
}

type PropertyValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyValueContext() *PropertyValueContext {
	var p = new(PropertyValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyValue
	return p
}

func InitEmptyPropertyValueContext(p *PropertyValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyValue
}

func (*PropertyValueContext) IsPropertyValueContext() {}

func NewPropertyValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyValueContext {
	var p = new(PropertyValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_propertyValue

	return p
}

func (s *PropertyValueContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyValueContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyValueContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *PropertyValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPropertyValue(s)
	}
}

func (s *PropertyValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPropertyValue(s)
	}
}

func (p *DorisParser) PropertyValue() (localctx IPropertyValueContext) {
	localctx = NewPropertyValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, DorisParserRULE_propertyValue)
	p.SetState(3566)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 496, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3564)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3565)
			p.Constant()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableAliasContext is an interface to support dynamic dispatch.
type ITableAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StrictIdentifier() IStrictIdentifierContext
	AS() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsTableAliasContext differentiates from other interfaces.
	IsTableAliasContext()
}

type TableAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableAliasContext() *TableAliasContext {
	var p = new(TableAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tableAlias
	return p
}

func InitEmptyTableAliasContext(p *TableAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tableAlias
}

func (*TableAliasContext) IsTableAliasContext() {}

func NewTableAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableAliasContext {
	var p = new(TableAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_tableAlias

	return p
}

func (s *TableAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *TableAliasContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *TableAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *TableAliasContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *TableAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTableAlias(s)
	}
}

func (s *TableAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTableAlias(s)
	}
}

func (p *DorisParser) TableAlias() (localctx ITableAliasContext) {
	localctx = NewTableAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, DorisParserRULE_tableAlias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3575)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 499, p.GetParserRuleContext()) == 1 {
		p.SetState(3569)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAS {
			{
				p.SetState(3568)
				p.Match(DorisParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3571)
			p.StrictIdentifier()
		}
		p.SetState(3573)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 498, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3572)
				p.IdentifierList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultipartIdentifierContext is an interface to support dynamic dispatch.
type IMultipartIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_errorCapturingIdentifier returns the _errorCapturingIdentifier rule contexts.
	Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext

	// Set_errorCapturingIdentifier sets the _errorCapturingIdentifier rule contexts.
	Set_errorCapturingIdentifier(IErrorCapturingIdentifierContext)

	// GetParts returns the parts rule context list.
	GetParts() []IErrorCapturingIdentifierContext

	// SetParts sets the parts rule context list.
	SetParts([]IErrorCapturingIdentifierContext)

	// Getter signatures
	AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext
	ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsMultipartIdentifierContext differentiates from other interfaces.
	IsMultipartIdentifierContext()
}

type MultipartIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser                    antlr.Parser
	_errorCapturingIdentifier IErrorCapturingIdentifierContext
	parts                     []IErrorCapturingIdentifierContext
}

func NewEmptyMultipartIdentifierContext() *MultipartIdentifierContext {
	var p = new(MultipartIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_multipartIdentifier
	return p
}

func InitEmptyMultipartIdentifierContext(p *MultipartIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_multipartIdentifier
}

func (*MultipartIdentifierContext) IsMultipartIdentifierContext() {}

func NewMultipartIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipartIdentifierContext {
	var p = new(MultipartIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_multipartIdentifier

	return p
}

func (s *MultipartIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipartIdentifierContext) Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext {
	return s._errorCapturingIdentifier
}

func (s *MultipartIdentifierContext) Set_errorCapturingIdentifier(v IErrorCapturingIdentifierContext) {
	s._errorCapturingIdentifier = v
}

func (s *MultipartIdentifierContext) GetParts() []IErrorCapturingIdentifierContext { return s.parts }

func (s *MultipartIdentifierContext) SetParts(v []IErrorCapturingIdentifierContext) { s.parts = v }

func (s *MultipartIdentifierContext) AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IErrorCapturingIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			tst[i] = t.(IErrorCapturingIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *MultipartIdentifierContext) ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *MultipartIdentifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(DorisParserDOT)
}

func (s *MultipartIdentifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, i)
}

func (s *MultipartIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipartIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipartIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMultipartIdentifier(s)
	}
}

func (s *MultipartIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMultipartIdentifier(s)
	}
}

func (p *DorisParser) MultipartIdentifier() (localctx IMultipartIdentifierContext) {
	localctx = NewMultipartIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, DorisParserRULE_multipartIdentifier)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3577)

		var _x = p.ErrorCapturingIdentifier()

		localctx.(*MultipartIdentifierContext)._errorCapturingIdentifier = _x
	}
	localctx.(*MultipartIdentifierContext).parts = append(localctx.(*MultipartIdentifierContext).parts, localctx.(*MultipartIdentifierContext)._errorCapturingIdentifier)
	p.SetState(3582)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 500, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3578)
				p.Match(DorisParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3579)

				var _x = p.ErrorCapturingIdentifier()

				localctx.(*MultipartIdentifierContext)._errorCapturingIdentifier = _x
			}
			localctx.(*MultipartIdentifierContext).parts = append(localctx.(*MultipartIdentifierContext).parts, localctx.(*MultipartIdentifierContext)._errorCapturingIdentifier)

		}
		p.SetState(3584)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 500, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleColumnDefsContext is an interface to support dynamic dispatch.
type ISimpleColumnDefsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_simpleColumnDef returns the _simpleColumnDef rule contexts.
	Get_simpleColumnDef() ISimpleColumnDefContext

	// Set_simpleColumnDef sets the _simpleColumnDef rule contexts.
	Set_simpleColumnDef(ISimpleColumnDefContext)

	// GetCols returns the cols rule context list.
	GetCols() []ISimpleColumnDefContext

	// SetCols sets the cols rule context list.
	SetCols([]ISimpleColumnDefContext)

	// Getter signatures
	AllSimpleColumnDef() []ISimpleColumnDefContext
	SimpleColumnDef(i int) ISimpleColumnDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSimpleColumnDefsContext differentiates from other interfaces.
	IsSimpleColumnDefsContext()
}

type SimpleColumnDefsContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	_simpleColumnDef ISimpleColumnDefContext
	cols             []ISimpleColumnDefContext
}

func NewEmptySimpleColumnDefsContext() *SimpleColumnDefsContext {
	var p = new(SimpleColumnDefsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_simpleColumnDefs
	return p
}

func InitEmptySimpleColumnDefsContext(p *SimpleColumnDefsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_simpleColumnDefs
}

func (*SimpleColumnDefsContext) IsSimpleColumnDefsContext() {}

func NewSimpleColumnDefsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleColumnDefsContext {
	var p = new(SimpleColumnDefsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_simpleColumnDefs

	return p
}

func (s *SimpleColumnDefsContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleColumnDefsContext) Get_simpleColumnDef() ISimpleColumnDefContext {
	return s._simpleColumnDef
}

func (s *SimpleColumnDefsContext) Set_simpleColumnDef(v ISimpleColumnDefContext) {
	s._simpleColumnDef = v
}

func (s *SimpleColumnDefsContext) GetCols() []ISimpleColumnDefContext { return s.cols }

func (s *SimpleColumnDefsContext) SetCols(v []ISimpleColumnDefContext) { s.cols = v }

func (s *SimpleColumnDefsContext) AllSimpleColumnDef() []ISimpleColumnDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleColumnDefContext); ok {
			len++
		}
	}

	tst := make([]ISimpleColumnDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleColumnDefContext); ok {
			tst[i] = t.(ISimpleColumnDefContext)
			i++
		}
	}

	return tst
}

func (s *SimpleColumnDefsContext) SimpleColumnDef(i int) ISimpleColumnDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleColumnDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleColumnDefContext)
}

func (s *SimpleColumnDefsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *SimpleColumnDefsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *SimpleColumnDefsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleColumnDefsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleColumnDefsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSimpleColumnDefs(s)
	}
}

func (s *SimpleColumnDefsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSimpleColumnDefs(s)
	}
}

func (p *DorisParser) SimpleColumnDefs() (localctx ISimpleColumnDefsContext) {
	localctx = NewSimpleColumnDefsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, DorisParserRULE_simpleColumnDefs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3585)

		var _x = p.SimpleColumnDef()

		localctx.(*SimpleColumnDefsContext)._simpleColumnDef = _x
	}
	localctx.(*SimpleColumnDefsContext).cols = append(localctx.(*SimpleColumnDefsContext).cols, localctx.(*SimpleColumnDefsContext)._simpleColumnDef)
	p.SetState(3590)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(3586)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3587)

			var _x = p.SimpleColumnDef()

			localctx.(*SimpleColumnDefsContext)._simpleColumnDef = _x
		}
		localctx.(*SimpleColumnDefsContext).cols = append(localctx.(*SimpleColumnDefsContext).cols, localctx.(*SimpleColumnDefsContext)._simpleColumnDef)

		p.SetState(3592)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleColumnDefContext is an interface to support dynamic dispatch.
type ISimpleColumnDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetComment returns the comment token.
	GetComment() antlr.Token

	// SetComment sets the comment token.
	SetComment(antlr.Token)

	// GetColName returns the colName rule contexts.
	GetColName() IIdentifierContext

	// SetColName sets the colName rule contexts.
	SetColName(IIdentifierContext)

	// Getter signatures
	Identifier() IIdentifierContext
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsSimpleColumnDefContext differentiates from other interfaces.
	IsSimpleColumnDefContext()
}

type SimpleColumnDefContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	colName IIdentifierContext
	comment antlr.Token
}

func NewEmptySimpleColumnDefContext() *SimpleColumnDefContext {
	var p = new(SimpleColumnDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_simpleColumnDef
	return p
}

func InitEmptySimpleColumnDefContext(p *SimpleColumnDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_simpleColumnDef
}

func (*SimpleColumnDefContext) IsSimpleColumnDefContext() {}

func NewSimpleColumnDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleColumnDefContext {
	var p = new(SimpleColumnDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_simpleColumnDef

	return p
}

func (s *SimpleColumnDefContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleColumnDefContext) GetComment() antlr.Token { return s.comment }

func (s *SimpleColumnDefContext) SetComment(v antlr.Token) { s.comment = v }

func (s *SimpleColumnDefContext) GetColName() IIdentifierContext { return s.colName }

func (s *SimpleColumnDefContext) SetColName(v IIdentifierContext) { s.colName = v }

func (s *SimpleColumnDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SimpleColumnDefContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *SimpleColumnDefContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *SimpleColumnDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleColumnDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleColumnDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSimpleColumnDef(s)
	}
}

func (s *SimpleColumnDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSimpleColumnDef(s)
	}
}

func (p *DorisParser) SimpleColumnDef() (localctx ISimpleColumnDefContext) {
	localctx = NewSimpleColumnDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, DorisParserRULE_simpleColumnDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3593)

		var _x = p.Identifier()

		localctx.(*SimpleColumnDefContext).colName = _x
	}
	p.SetState(3596)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserCOMMENT {
		{
			p.SetState(3594)
			p.Match(DorisParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3595)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*SimpleColumnDefContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDefsContext is an interface to support dynamic dispatch.
type IColumnDefsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_columnDef returns the _columnDef rule contexts.
	Get_columnDef() IColumnDefContext

	// Set_columnDef sets the _columnDef rule contexts.
	Set_columnDef(IColumnDefContext)

	// GetCols returns the cols rule context list.
	GetCols() []IColumnDefContext

	// SetCols sets the cols rule context list.
	SetCols([]IColumnDefContext)

	// Getter signatures
	AllColumnDef() []IColumnDefContext
	ColumnDef(i int) IColumnDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnDefsContext differentiates from other interfaces.
	IsColumnDefsContext()
}

type ColumnDefsContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	_columnDef IColumnDefContext
	cols       []IColumnDefContext
}

func NewEmptyColumnDefsContext() *ColumnDefsContext {
	var p = new(ColumnDefsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_columnDefs
	return p
}

func InitEmptyColumnDefsContext(p *ColumnDefsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_columnDefs
}

func (*ColumnDefsContext) IsColumnDefsContext() {}

func NewColumnDefsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefsContext {
	var p = new(ColumnDefsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_columnDefs

	return p
}

func (s *ColumnDefsContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefsContext) Get_columnDef() IColumnDefContext { return s._columnDef }

func (s *ColumnDefsContext) Set_columnDef(v IColumnDefContext) { s._columnDef = v }

func (s *ColumnDefsContext) GetCols() []IColumnDefContext { return s.cols }

func (s *ColumnDefsContext) SetCols(v []IColumnDefContext) { s.cols = v }

func (s *ColumnDefsContext) AllColumnDef() []IColumnDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnDefContext); ok {
			len++
		}
	}

	tst := make([]IColumnDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnDefContext); ok {
			tst[i] = t.(IColumnDefContext)
			i++
		}
	}

	return tst
}

func (s *ColumnDefsContext) ColumnDef(i int) IColumnDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefContext)
}

func (s *ColumnDefsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ColumnDefsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ColumnDefsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterColumnDefs(s)
	}
}

func (s *ColumnDefsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitColumnDefs(s)
	}
}

func (p *DorisParser) ColumnDefs() (localctx IColumnDefsContext) {
	localctx = NewColumnDefsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, DorisParserRULE_columnDefs)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3598)

		var _x = p.ColumnDef()

		localctx.(*ColumnDefsContext)._columnDef = _x
	}
	localctx.(*ColumnDefsContext).cols = append(localctx.(*ColumnDefsContext).cols, localctx.(*ColumnDefsContext)._columnDef)
	p.SetState(3603)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 503, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3599)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3600)

				var _x = p.ColumnDef()

				localctx.(*ColumnDefsContext)._columnDef = _x
			}
			localctx.(*ColumnDefsContext).cols = append(localctx.(*ColumnDefsContext).cols, localctx.(*ColumnDefsContext)._columnDef)

		}
		p.SetState(3605)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 503, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDefContext is an interface to support dynamic dispatch.
type IColumnDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNullable returns the nullable token.
	GetNullable() antlr.Token

	// GetNullValue returns the nullValue token.
	GetNullValue() antlr.Token

	// GetStringValue returns the stringValue token.
	GetStringValue() antlr.Token

	// GetDefaultTimestamp returns the defaultTimestamp token.
	GetDefaultTimestamp() antlr.Token

	// GetComment returns the comment token.
	GetComment() antlr.Token

	// SetNullable sets the nullable token.
	SetNullable(antlr.Token)

	// SetNullValue sets the nullValue token.
	SetNullValue(antlr.Token)

	// SetStringValue sets the stringValue token.
	SetStringValue(antlr.Token)

	// SetDefaultTimestamp sets the defaultTimestamp token.
	SetDefaultTimestamp(antlr.Token)

	// SetComment sets the comment token.
	SetComment(antlr.Token)

	// GetColName returns the colName rule contexts.
	GetColName() IIdentifierContext

	// GetType_ returns the type_ rule contexts.
	GetType_() IDataTypeContext

	// GetAggType returns the aggType rule contexts.
	GetAggType() IAggTypeDefContext

	// GetGeneratedExpr returns the generatedExpr rule contexts.
	GetGeneratedExpr() IExpressionContext

	// GetAutoIncInitValue returns the autoIncInitValue rule contexts.
	GetAutoIncInitValue() INumberContext

	// GetDefaultValuePrecision returns the defaultValuePrecision rule contexts.
	GetDefaultValuePrecision() INumberContext

	// GetOnUpdateValuePrecision returns the onUpdateValuePrecision rule contexts.
	GetOnUpdateValuePrecision() INumberContext

	// SetColName sets the colName rule contexts.
	SetColName(IIdentifierContext)

	// SetType_ sets the type_ rule contexts.
	SetType_(IDataTypeContext)

	// SetAggType sets the aggType rule contexts.
	SetAggType(IAggTypeDefContext)

	// SetGeneratedExpr sets the generatedExpr rule contexts.
	SetGeneratedExpr(IExpressionContext)

	// SetAutoIncInitValue sets the autoIncInitValue rule contexts.
	SetAutoIncInitValue(INumberContext)

	// SetDefaultValuePrecision sets the defaultValuePrecision rule contexts.
	SetDefaultValuePrecision(INumberContext)

	// SetOnUpdateValuePrecision sets the onUpdateValuePrecision rule contexts.
	SetOnUpdateValuePrecision(INumberContext)

	// Getter signatures
	Identifier() IIdentifierContext
	DataType() IDataTypeContext
	KEY() antlr.TerminalNode
	AS() antlr.TerminalNode
	AllLEFT_PAREN() []antlr.TerminalNode
	LEFT_PAREN(i int) antlr.TerminalNode
	AllRIGHT_PAREN() []antlr.TerminalNode
	RIGHT_PAREN(i int) antlr.TerminalNode
	AUTO_INCREMENT() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	ON() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	AllCURRENT_TIMESTAMP() []antlr.TerminalNode
	CURRENT_TIMESTAMP(i int) antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	AggTypeDef() IAggTypeDefContext
	Expression() IExpressionContext
	AllNULL() []antlr.TerminalNode
	NULL(i int) antlr.TerminalNode
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	DECIMAL_VALUE() antlr.TerminalNode
	PI() antlr.TerminalNode
	CURRENT_DATE() antlr.TerminalNode
	GENERATED() antlr.TerminalNode
	ALWAYS() antlr.TerminalNode
	NOT() antlr.TerminalNode
	AllNumber() []INumberContext
	Number(i int) INumberContext

	// IsColumnDefContext differentiates from other interfaces.
	IsColumnDefContext()
}

type ColumnDefContext struct {
	antlr.BaseParserRuleContext
	parser                 antlr.Parser
	colName                IIdentifierContext
	type_                  IDataTypeContext
	aggType                IAggTypeDefContext
	generatedExpr          IExpressionContext
	nullable               antlr.Token
	autoIncInitValue       INumberContext
	nullValue              antlr.Token
	stringValue            antlr.Token
	defaultTimestamp       antlr.Token
	defaultValuePrecision  INumberContext
	onUpdateValuePrecision INumberContext
	comment                antlr.Token
}

func NewEmptyColumnDefContext() *ColumnDefContext {
	var p = new(ColumnDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_columnDef
	return p
}

func InitEmptyColumnDefContext(p *ColumnDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_columnDef
}

func (*ColumnDefContext) IsColumnDefContext() {}

func NewColumnDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefContext {
	var p = new(ColumnDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_columnDef

	return p
}

func (s *ColumnDefContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefContext) GetNullable() antlr.Token { return s.nullable }

func (s *ColumnDefContext) GetNullValue() antlr.Token { return s.nullValue }

func (s *ColumnDefContext) GetStringValue() antlr.Token { return s.stringValue }

func (s *ColumnDefContext) GetDefaultTimestamp() antlr.Token { return s.defaultTimestamp }

func (s *ColumnDefContext) GetComment() antlr.Token { return s.comment }

func (s *ColumnDefContext) SetNullable(v antlr.Token) { s.nullable = v }

func (s *ColumnDefContext) SetNullValue(v antlr.Token) { s.nullValue = v }

func (s *ColumnDefContext) SetStringValue(v antlr.Token) { s.stringValue = v }

func (s *ColumnDefContext) SetDefaultTimestamp(v antlr.Token) { s.defaultTimestamp = v }

func (s *ColumnDefContext) SetComment(v antlr.Token) { s.comment = v }

func (s *ColumnDefContext) GetColName() IIdentifierContext { return s.colName }

func (s *ColumnDefContext) GetType_() IDataTypeContext { return s.type_ }

func (s *ColumnDefContext) GetAggType() IAggTypeDefContext { return s.aggType }

func (s *ColumnDefContext) GetGeneratedExpr() IExpressionContext { return s.generatedExpr }

func (s *ColumnDefContext) GetAutoIncInitValue() INumberContext { return s.autoIncInitValue }

func (s *ColumnDefContext) GetDefaultValuePrecision() INumberContext { return s.defaultValuePrecision }

func (s *ColumnDefContext) GetOnUpdateValuePrecision() INumberContext {
	return s.onUpdateValuePrecision
}

func (s *ColumnDefContext) SetColName(v IIdentifierContext) { s.colName = v }

func (s *ColumnDefContext) SetType_(v IDataTypeContext) { s.type_ = v }

func (s *ColumnDefContext) SetAggType(v IAggTypeDefContext) { s.aggType = v }

func (s *ColumnDefContext) SetGeneratedExpr(v IExpressionContext) { s.generatedExpr = v }

func (s *ColumnDefContext) SetAutoIncInitValue(v INumberContext) { s.autoIncInitValue = v }

func (s *ColumnDefContext) SetDefaultValuePrecision(v INumberContext) { s.defaultValuePrecision = v }

func (s *ColumnDefContext) SetOnUpdateValuePrecision(v INumberContext) { s.onUpdateValuePrecision = v }

func (s *ColumnDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnDefContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ColumnDefContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserKEY, 0)
}

func (s *ColumnDefContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *ColumnDefContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserLEFT_PAREN)
}

func (s *ColumnDefContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, i)
}

func (s *ColumnDefContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserRIGHT_PAREN)
}

func (s *ColumnDefContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, i)
}

func (s *ColumnDefContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO_INCREMENT, 0)
}

func (s *ColumnDefContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *ColumnDefContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *ColumnDefContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(DorisParserUPDATE, 0)
}

func (s *ColumnDefContext) AllCURRENT_TIMESTAMP() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCURRENT_TIMESTAMP)
}

func (s *ColumnDefContext) CURRENT_TIMESTAMP(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_TIMESTAMP, i)
}

func (s *ColumnDefContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *ColumnDefContext) AggTypeDef() IAggTypeDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggTypeDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggTypeDefContext)
}

func (s *ColumnDefContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ColumnDefContext) AllNULL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserNULL)
}

func (s *ColumnDefContext) NULL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserNULL, i)
}

func (s *ColumnDefContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *ColumnDefContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *ColumnDefContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ColumnDefContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserDECIMAL_VALUE, 0)
}

func (s *ColumnDefContext) PI() antlr.TerminalNode {
	return s.GetToken(DorisParserPI, 0)
}

func (s *ColumnDefContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_DATE, 0)
}

func (s *ColumnDefContext) GENERATED() antlr.TerminalNode {
	return s.GetToken(DorisParserGENERATED, 0)
}

func (s *ColumnDefContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(DorisParserALWAYS, 0)
}

func (s *ColumnDefContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *ColumnDefContext) AllNumber() []INumberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INumberContext); ok {
			len++
		}
	}

	tst := make([]INumberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INumberContext); ok {
			tst[i] = t.(INumberContext)
			i++
		}
	}

	return tst
}

func (s *ColumnDefContext) Number(i int) INumberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *ColumnDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterColumnDef(s)
	}
}

func (s *ColumnDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitColumnDef(s)
	}
}

func (p *DorisParser) ColumnDef() (localctx IColumnDefContext) {
	localctx = NewColumnDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, DorisParserRULE_columnDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3606)

		var _x = p.Identifier()

		localctx.(*ColumnDefContext).colName = _x
	}
	{
		p.SetState(3607)

		var _x = p.DataType()

		localctx.(*ColumnDefContext).type_ = _x
	}
	p.SetState(3609)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserKEY {
		{
			p.SetState(3608)
			p.Match(DorisParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3612)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserBITMAP_UNION || _la == DorisParserGENERIC || _la == DorisParserHLL_UNION || _la == DorisParserMAX || _la == DorisParserMIN || ((int64((_la-355)) & ^0x3f) == 0 && ((int64(1)<<(_la-355))&786433) != 0) || _la == DorisParserSUM {
		{
			p.SetState(3611)

			var _x = p.AggTypeDef()

			localctx.(*ColumnDefContext).aggType = _x
		}

	}
	p.SetState(3623)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserAS || _la == DorisParserGENERATED {
		p.SetState(3616)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserGENERATED {
			{
				p.SetState(3614)
				p.Match(DorisParserGENERATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3615)
				p.Match(DorisParserALWAYS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3618)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3619)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3620)

			var _x = p.Expression()

			localctx.(*ColumnDefContext).generatedExpr = _x
		}
		{
			p.SetState(3621)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3629)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserNOT || _la == DorisParserNULL {
		p.SetState(3626)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(3625)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3628)

			var _m = p.Match(DorisParserNULL)

			localctx.(*ColumnDefContext).nullable = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3638)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserAUTO_INCREMENT {
		{
			p.SetState(3631)
			p.Match(DorisParserAUTO_INCREMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3636)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(3632)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3633)

				var _x = p.Number()

				localctx.(*ColumnDefContext).autoIncInitValue = _x
			}
			{
				p.SetState(3634)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	p.SetState(3656)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserDEFAULT {
		{
			p.SetState(3640)
			p.Match(DorisParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3654)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserNULL:
			{
				p.SetState(3641)

				var _m = p.Match(DorisParserNULL)

				localctx.(*ColumnDefContext).nullValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserINTEGER_VALUE:
			{
				p.SetState(3642)
				p.Match(DorisParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserDECIMAL_VALUE:
			{
				p.SetState(3643)
				p.Match(DorisParserDECIMAL_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserPI:
			{
				p.SetState(3644)
				p.Match(DorisParserPI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserSTRING_LITERAL:
			{
				p.SetState(3645)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*ColumnDefContext).stringValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCURRENT_DATE:
			{
				p.SetState(3646)
				p.Match(DorisParserCURRENT_DATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCURRENT_TIMESTAMP:
			{
				p.SetState(3647)

				var _m = p.Match(DorisParserCURRENT_TIMESTAMP)

				localctx.(*ColumnDefContext).defaultTimestamp = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3652)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserLEFT_PAREN {
				{
					p.SetState(3648)
					p.Match(DorisParserLEFT_PAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3649)

					var _x = p.Number()

					localctx.(*ColumnDefContext).defaultValuePrecision = _x
				}
				{
					p.SetState(3650)
					p.Match(DorisParserRIGHT_PAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(3667)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserON {
		{
			p.SetState(3658)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3659)
			p.Match(DorisParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3660)
			p.Match(DorisParserCURRENT_TIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3665)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(3661)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3662)

				var _x = p.Number()

				localctx.(*ColumnDefContext).onUpdateValuePrecision = _x
			}
			{
				p.SetState(3663)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	p.SetState(3671)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserCOMMENT {
		{
			p.SetState(3669)
			p.Match(DorisParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3670)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ColumnDefContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexDefsContext is an interface to support dynamic dispatch.
type IIndexDefsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_indexDef returns the _indexDef rule contexts.
	Get_indexDef() IIndexDefContext

	// Set_indexDef sets the _indexDef rule contexts.
	Set_indexDef(IIndexDefContext)

	// GetIndexes returns the indexes rule context list.
	GetIndexes() []IIndexDefContext

	// SetIndexes sets the indexes rule context list.
	SetIndexes([]IIndexDefContext)

	// Getter signatures
	AllIndexDef() []IIndexDefContext
	IndexDef(i int) IIndexDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIndexDefsContext differentiates from other interfaces.
	IsIndexDefsContext()
}

type IndexDefsContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	_indexDef IIndexDefContext
	indexes   []IIndexDefContext
}

func NewEmptyIndexDefsContext() *IndexDefsContext {
	var p = new(IndexDefsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_indexDefs
	return p
}

func InitEmptyIndexDefsContext(p *IndexDefsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_indexDefs
}

func (*IndexDefsContext) IsIndexDefsContext() {}

func NewIndexDefsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexDefsContext {
	var p = new(IndexDefsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_indexDefs

	return p
}

func (s *IndexDefsContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexDefsContext) Get_indexDef() IIndexDefContext { return s._indexDef }

func (s *IndexDefsContext) Set_indexDef(v IIndexDefContext) { s._indexDef = v }

func (s *IndexDefsContext) GetIndexes() []IIndexDefContext { return s.indexes }

func (s *IndexDefsContext) SetIndexes(v []IIndexDefContext) { s.indexes = v }

func (s *IndexDefsContext) AllIndexDef() []IIndexDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexDefContext); ok {
			len++
		}
	}

	tst := make([]IIndexDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexDefContext); ok {
			tst[i] = t.(IIndexDefContext)
			i++
		}
	}

	return tst
}

func (s *IndexDefsContext) IndexDef(i int) IIndexDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexDefContext)
}

func (s *IndexDefsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *IndexDefsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *IndexDefsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexDefsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexDefsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIndexDefs(s)
	}
}

func (s *IndexDefsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIndexDefs(s)
	}
}

func (p *DorisParser) IndexDefs() (localctx IIndexDefsContext) {
	localctx = NewIndexDefsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, DorisParserRULE_indexDefs)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3673)

		var _x = p.IndexDef()

		localctx.(*IndexDefsContext)._indexDef = _x
	}
	localctx.(*IndexDefsContext).indexes = append(localctx.(*IndexDefsContext).indexes, localctx.(*IndexDefsContext)._indexDef)
	p.SetState(3678)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 518, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3674)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3675)

				var _x = p.IndexDef()

				localctx.(*IndexDefsContext)._indexDef = _x
			}
			localctx.(*IndexDefsContext).indexes = append(localctx.(*IndexDefsContext).indexes, localctx.(*IndexDefsContext)._indexDef)

		}
		p.SetState(3680)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 518, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexDefContext is an interface to support dynamic dispatch.
type IIndexDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexType returns the indexType token.
	GetIndexType() antlr.Token

	// GetComment returns the comment token.
	GetComment() antlr.Token

	// SetIndexType sets the indexType token.
	SetIndexType(antlr.Token)

	// SetComment sets the comment token.
	SetComment(antlr.Token)

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// GetCols returns the cols rule contexts.
	GetCols() IIdentifierListContext

	// GetProperties returns the properties rule contexts.
	GetProperties() IPropertyItemListContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// SetCols sets the cols rule contexts.
	SetCols(IIdentifierListContext)

	// SetProperties sets the properties rule contexts.
	SetProperties(IPropertyItemListContext)

	// Getter signatures
	INDEX() antlr.TerminalNode
	Identifier() IIdentifierContext
	IdentifierList() IIdentifierListContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	USING() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	PropertyItemList() IPropertyItemListContext
	STRING_LITERAL() antlr.TerminalNode
	BITMAP() antlr.TerminalNode
	INVERTED() antlr.TerminalNode
	NGRAM_BF() antlr.TerminalNode

	// IsIndexDefContext differentiates from other interfaces.
	IsIndexDefContext()
}

type IndexDefContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	indexName  IIdentifierContext
	cols       IIdentifierListContext
	indexType  antlr.Token
	properties IPropertyItemListContext
	comment    antlr.Token
}

func NewEmptyIndexDefContext() *IndexDefContext {
	var p = new(IndexDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_indexDef
	return p
}

func InitEmptyIndexDefContext(p *IndexDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_indexDef
}

func (*IndexDefContext) IsIndexDefContext() {}

func NewIndexDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexDefContext {
	var p = new(IndexDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_indexDef

	return p
}

func (s *IndexDefContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexDefContext) GetIndexType() antlr.Token { return s.indexType }

func (s *IndexDefContext) GetComment() antlr.Token { return s.comment }

func (s *IndexDefContext) SetIndexType(v antlr.Token) { s.indexType = v }

func (s *IndexDefContext) SetComment(v antlr.Token) { s.comment = v }

func (s *IndexDefContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *IndexDefContext) GetCols() IIdentifierListContext { return s.cols }

func (s *IndexDefContext) GetProperties() IPropertyItemListContext { return s.properties }

func (s *IndexDefContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *IndexDefContext) SetCols(v IIdentifierListContext) { s.cols = v }

func (s *IndexDefContext) SetProperties(v IPropertyItemListContext) { s.properties = v }

func (s *IndexDefContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *IndexDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IndexDefContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *IndexDefContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *IndexDefContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *IndexDefContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *IndexDefContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserUSING, 0)
}

func (s *IndexDefContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *IndexDefContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *IndexDefContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *IndexDefContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *IndexDefContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *IndexDefContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *IndexDefContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(DorisParserBITMAP, 0)
}

func (s *IndexDefContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserINVERTED, 0)
}

func (s *IndexDefContext) NGRAM_BF() antlr.TerminalNode {
	return s.GetToken(DorisParserNGRAM_BF, 0)
}

func (s *IndexDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIndexDef(s)
	}
}

func (s *IndexDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIndexDef(s)
	}
}

func (p *DorisParser) IndexDef() (localctx IIndexDefContext) {
	localctx = NewIndexDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, DorisParserRULE_indexDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3681)
		p.Match(DorisParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3685)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserIF {
		{
			p.SetState(3682)
			p.Match(DorisParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3683)
			p.Match(DorisParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3684)
			p.Match(DorisParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3687)

		var _x = p.Identifier()

		localctx.(*IndexDefContext).indexName = _x
	}
	{
		p.SetState(3688)

		var _x = p.IdentifierList()

		localctx.(*IndexDefContext).cols = _x
	}
	p.SetState(3691)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserUSING {
		{
			p.SetState(3689)
			p.Match(DorisParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3690)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IndexDefContext).indexType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserBITMAP || _la == DorisParserINVERTED || _la == DorisParserNGRAM_BF) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IndexDefContext).indexType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3698)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPROPERTIES {
		{
			p.SetState(3693)
			p.Match(DorisParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3694)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3695)

			var _x = p.PropertyItemList()

			localctx.(*IndexDefContext).properties = _x
		}
		{
			p.SetState(3696)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3702)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserCOMMENT {
		{
			p.SetState(3700)
			p.Match(DorisParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3701)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*IndexDefContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionsDefContext is an interface to support dynamic dispatch.
type IPartitionsDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_partitionDef returns the _partitionDef rule contexts.
	Get_partitionDef() IPartitionDefContext

	// Set_partitionDef sets the _partitionDef rule contexts.
	Set_partitionDef(IPartitionDefContext)

	// GetPartitions returns the partitions rule context list.
	GetPartitions() []IPartitionDefContext

	// SetPartitions sets the partitions rule context list.
	SetPartitions([]IPartitionDefContext)

	// Getter signatures
	AllPartitionDef() []IPartitionDefContext
	PartitionDef(i int) IPartitionDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionsDefContext differentiates from other interfaces.
	IsPartitionsDefContext()
}

type PartitionsDefContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	_partitionDef IPartitionDefContext
	partitions    []IPartitionDefContext
}

func NewEmptyPartitionsDefContext() *PartitionsDefContext {
	var p = new(PartitionsDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionsDef
	return p
}

func InitEmptyPartitionsDefContext(p *PartitionsDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionsDef
}

func (*PartitionsDefContext) IsPartitionsDefContext() {}

func NewPartitionsDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionsDefContext {
	var p = new(PartitionsDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_partitionsDef

	return p
}

func (s *PartitionsDefContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionsDefContext) Get_partitionDef() IPartitionDefContext { return s._partitionDef }

func (s *PartitionsDefContext) Set_partitionDef(v IPartitionDefContext) { s._partitionDef = v }

func (s *PartitionsDefContext) GetPartitions() []IPartitionDefContext { return s.partitions }

func (s *PartitionsDefContext) SetPartitions(v []IPartitionDefContext) { s.partitions = v }

func (s *PartitionsDefContext) AllPartitionDef() []IPartitionDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefContext); ok {
			tst[i] = t.(IPartitionDefContext)
			i++
		}
	}

	return tst
}

func (s *PartitionsDefContext) PartitionDef(i int) IPartitionDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefContext)
}

func (s *PartitionsDefContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *PartitionsDefContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *PartitionsDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionsDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionsDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPartitionsDef(s)
	}
}

func (s *PartitionsDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPartitionsDef(s)
	}
}

func (p *DorisParser) PartitionsDef() (localctx IPartitionsDefContext) {
	localctx = NewPartitionsDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, DorisParserRULE_partitionsDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3704)

		var _x = p.PartitionDef()

		localctx.(*PartitionsDefContext)._partitionDef = _x
	}
	localctx.(*PartitionsDefContext).partitions = append(localctx.(*PartitionsDefContext).partitions, localctx.(*PartitionsDefContext)._partitionDef)
	p.SetState(3709)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(3705)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3706)

			var _x = p.PartitionDef()

			localctx.(*PartitionsDefContext)._partitionDef = _x
		}
		localctx.(*PartitionsDefContext).partitions = append(localctx.(*PartitionsDefContext).partitions, localctx.(*PartitionsDefContext)._partitionDef)

		p.SetState(3711)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDefContext is an interface to support dynamic dispatch.
type IPartitionDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionProperties returns the partitionProperties rule contexts.
	GetPartitionProperties() IPropertyItemListContext

	// SetPartitionProperties sets the partitionProperties rule contexts.
	SetPartitionProperties(IPropertyItemListContext)

	// Getter signatures
	LessThanPartitionDef() ILessThanPartitionDefContext
	FixedPartitionDef() IFixedPartitionDefContext
	StepPartitionDef() IStepPartitionDefContext
	InPartitionDef() IInPartitionDefContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	PropertyItemList() IPropertyItemListContext

	// IsPartitionDefContext differentiates from other interfaces.
	IsPartitionDefContext()
}

type PartitionDefContext struct {
	antlr.BaseParserRuleContext
	parser              antlr.Parser
	partitionProperties IPropertyItemListContext
}

func NewEmptyPartitionDefContext() *PartitionDefContext {
	var p = new(PartitionDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionDef
	return p
}

func InitEmptyPartitionDefContext(p *PartitionDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionDef
}

func (*PartitionDefContext) IsPartitionDefContext() {}

func NewPartitionDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefContext {
	var p = new(PartitionDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_partitionDef

	return p
}

func (s *PartitionDefContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefContext) GetPartitionProperties() IPropertyItemListContext {
	return s.partitionProperties
}

func (s *PartitionDefContext) SetPartitionProperties(v IPropertyItemListContext) {
	s.partitionProperties = v
}

func (s *PartitionDefContext) LessThanPartitionDef() ILessThanPartitionDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILessThanPartitionDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILessThanPartitionDefContext)
}

func (s *PartitionDefContext) FixedPartitionDef() IFixedPartitionDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFixedPartitionDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFixedPartitionDefContext)
}

func (s *PartitionDefContext) StepPartitionDef() IStepPartitionDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStepPartitionDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStepPartitionDefContext)
}

func (s *PartitionDefContext) InPartitionDef() IInPartitionDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInPartitionDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInPartitionDefContext)
}

func (s *PartitionDefContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *PartitionDefContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *PartitionDefContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *PartitionDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPartitionDef(s)
	}
}

func (s *PartitionDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPartitionDef(s)
	}
}

func (p *DorisParser) PartitionDef() (localctx IPartitionDefContext) {
	localctx = NewPartitionDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, DorisParserRULE_partitionDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 524, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3712)
			p.LessThanPartitionDef()
		}

	case 2:
		{
			p.SetState(3713)
			p.FixedPartitionDef()
		}

	case 3:
		{
			p.SetState(3714)
			p.StepPartitionDef()
		}

	case 4:
		{
			p.SetState(3715)
			p.InPartitionDef()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(3722)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLEFT_PAREN {
		{
			p.SetState(3718)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3719)

			var _x = p.PropertyItemList()

			localctx.(*PartitionDefContext).partitionProperties = _x
		}
		{
			p.SetState(3720)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILessThanPartitionDefContext is an interface to support dynamic dispatch.
type ILessThanPartitionDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionName returns the partitionName rule contexts.
	GetPartitionName() IIdentifierContext

	// SetPartitionName sets the partitionName rule contexts.
	SetPartitionName(IIdentifierContext)

	// Getter signatures
	PARTITION() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	LESS() antlr.TerminalNode
	THAN() antlr.TerminalNode
	Identifier() IIdentifierContext
	MAXVALUE() antlr.TerminalNode
	PartitionValueList() IPartitionValueListContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsLessThanPartitionDefContext differentiates from other interfaces.
	IsLessThanPartitionDefContext()
}

type LessThanPartitionDefContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	partitionName IIdentifierContext
}

func NewEmptyLessThanPartitionDefContext() *LessThanPartitionDefContext {
	var p = new(LessThanPartitionDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_lessThanPartitionDef
	return p
}

func InitEmptyLessThanPartitionDefContext(p *LessThanPartitionDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_lessThanPartitionDef
}

func (*LessThanPartitionDefContext) IsLessThanPartitionDefContext() {}

func NewLessThanPartitionDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LessThanPartitionDefContext {
	var p = new(LessThanPartitionDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_lessThanPartitionDef

	return p
}

func (s *LessThanPartitionDefContext) GetParser() antlr.Parser { return s.parser }

func (s *LessThanPartitionDefContext) GetPartitionName() IIdentifierContext { return s.partitionName }

func (s *LessThanPartitionDefContext) SetPartitionName(v IIdentifierContext) { s.partitionName = v }

func (s *LessThanPartitionDefContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *LessThanPartitionDefContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisParserVALUES, 0)
}

func (s *LessThanPartitionDefContext) LESS() antlr.TerminalNode {
	return s.GetToken(DorisParserLESS, 0)
}

func (s *LessThanPartitionDefContext) THAN() antlr.TerminalNode {
	return s.GetToken(DorisParserTHAN, 0)
}

func (s *LessThanPartitionDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LessThanPartitionDefContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserMAXVALUE, 0)
}

func (s *LessThanPartitionDefContext) PartitionValueList() IPartitionValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueListContext)
}

func (s *LessThanPartitionDefContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *LessThanPartitionDefContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *LessThanPartitionDefContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *LessThanPartitionDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LessThanPartitionDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LessThanPartitionDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLessThanPartitionDef(s)
	}
}

func (s *LessThanPartitionDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLessThanPartitionDef(s)
	}
}

func (p *DorisParser) LessThanPartitionDef() (localctx ILessThanPartitionDefContext) {
	localctx = NewLessThanPartitionDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, DorisParserRULE_lessThanPartitionDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3724)
		p.Match(DorisParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3728)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserIF {
		{
			p.SetState(3725)
			p.Match(DorisParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3726)
			p.Match(DorisParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3727)
			p.Match(DorisParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3730)

		var _x = p.Identifier()

		localctx.(*LessThanPartitionDefContext).partitionName = _x
	}
	{
		p.SetState(3731)
		p.Match(DorisParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3732)
		p.Match(DorisParserLESS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3733)
		p.Match(DorisParserTHAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3736)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserMAXVALUE:
		{
			p.SetState(3734)
			p.Match(DorisParserMAXVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserLEFT_PAREN:
		{
			p.SetState(3735)
			p.PartitionValueList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFixedPartitionDefContext is an interface to support dynamic dispatch.
type IFixedPartitionDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionName returns the partitionName rule contexts.
	GetPartitionName() IIdentifierContext

	// GetLower returns the lower rule contexts.
	GetLower() IPartitionValueListContext

	// GetUpper returns the upper rule contexts.
	GetUpper() IPartitionValueListContext

	// SetPartitionName sets the partitionName rule contexts.
	SetPartitionName(IIdentifierContext)

	// SetLower sets the lower rule contexts.
	SetLower(IPartitionValueListContext)

	// SetUpper sets the upper rule contexts.
	SetUpper(IPartitionValueListContext)

	// Getter signatures
	PARTITION() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	LEFT_BRACKET() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	AllPartitionValueList() []IPartitionValueListContext
	PartitionValueList(i int) IPartitionValueListContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsFixedPartitionDefContext differentiates from other interfaces.
	IsFixedPartitionDefContext()
}

type FixedPartitionDefContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	partitionName IIdentifierContext
	lower         IPartitionValueListContext
	upper         IPartitionValueListContext
}

func NewEmptyFixedPartitionDefContext() *FixedPartitionDefContext {
	var p = new(FixedPartitionDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_fixedPartitionDef
	return p
}

func InitEmptyFixedPartitionDefContext(p *FixedPartitionDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_fixedPartitionDef
}

func (*FixedPartitionDefContext) IsFixedPartitionDefContext() {}

func NewFixedPartitionDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FixedPartitionDefContext {
	var p = new(FixedPartitionDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_fixedPartitionDef

	return p
}

func (s *FixedPartitionDefContext) GetParser() antlr.Parser { return s.parser }

func (s *FixedPartitionDefContext) GetPartitionName() IIdentifierContext { return s.partitionName }

func (s *FixedPartitionDefContext) GetLower() IPartitionValueListContext { return s.lower }

func (s *FixedPartitionDefContext) GetUpper() IPartitionValueListContext { return s.upper }

func (s *FixedPartitionDefContext) SetPartitionName(v IIdentifierContext) { s.partitionName = v }

func (s *FixedPartitionDefContext) SetLower(v IPartitionValueListContext) { s.lower = v }

func (s *FixedPartitionDefContext) SetUpper(v IPartitionValueListContext) { s.upper = v }

func (s *FixedPartitionDefContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *FixedPartitionDefContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisParserVALUES, 0)
}

func (s *FixedPartitionDefContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACKET, 0)
}

func (s *FixedPartitionDefContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, 0)
}

func (s *FixedPartitionDefContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *FixedPartitionDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FixedPartitionDefContext) AllPartitionValueList() []IPartitionValueListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueListContext); ok {
			tst[i] = t.(IPartitionValueListContext)
			i++
		}
	}

	return tst
}

func (s *FixedPartitionDefContext) PartitionValueList(i int) IPartitionValueListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueListContext)
}

func (s *FixedPartitionDefContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *FixedPartitionDefContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *FixedPartitionDefContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *FixedPartitionDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FixedPartitionDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FixedPartitionDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFixedPartitionDef(s)
	}
}

func (s *FixedPartitionDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFixedPartitionDef(s)
	}
}

func (p *DorisParser) FixedPartitionDef() (localctx IFixedPartitionDefContext) {
	localctx = NewFixedPartitionDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, DorisParserRULE_fixedPartitionDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3738)
		p.Match(DorisParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3742)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserIF {
		{
			p.SetState(3739)
			p.Match(DorisParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3740)
			p.Match(DorisParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3741)
			p.Match(DorisParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3744)

		var _x = p.Identifier()

		localctx.(*FixedPartitionDefContext).partitionName = _x
	}
	{
		p.SetState(3745)
		p.Match(DorisParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3746)
		p.Match(DorisParserLEFT_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3747)

		var _x = p.PartitionValueList()

		localctx.(*FixedPartitionDefContext).lower = _x
	}
	{
		p.SetState(3748)
		p.Match(DorisParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3749)

		var _x = p.PartitionValueList()

		localctx.(*FixedPartitionDefContext).upper = _x
	}
	{
		p.SetState(3750)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStepPartitionDefContext is an interface to support dynamic dispatch.
type IStepPartitionDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnitsAmount returns the unitsAmount token.
	GetUnitsAmount() antlr.Token

	// SetUnitsAmount sets the unitsAmount token.
	SetUnitsAmount(antlr.Token)

	// GetFrom returns the from rule contexts.
	GetFrom() IPartitionValueListContext

	// GetTo returns the to rule contexts.
	GetTo() IPartitionValueListContext

	// GetUnit returns the unit rule contexts.
	GetUnit() IDatetimeUnitContext

	// SetFrom sets the from rule contexts.
	SetFrom(IPartitionValueListContext)

	// SetTo sets the to rule contexts.
	SetTo(IPartitionValueListContext)

	// SetUnit sets the unit rule contexts.
	SetUnit(IDatetimeUnitContext)

	// Getter signatures
	FROM() antlr.TerminalNode
	TO() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	AllPartitionValueList() []IPartitionValueListContext
	PartitionValueList(i int) IPartitionValueListContext
	INTEGER_VALUE() antlr.TerminalNode
	DatetimeUnit() IDatetimeUnitContext

	// IsStepPartitionDefContext differentiates from other interfaces.
	IsStepPartitionDefContext()
}

type StepPartitionDefContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	from        IPartitionValueListContext
	to          IPartitionValueListContext
	unitsAmount antlr.Token
	unit        IDatetimeUnitContext
}

func NewEmptyStepPartitionDefContext() *StepPartitionDefContext {
	var p = new(StepPartitionDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_stepPartitionDef
	return p
}

func InitEmptyStepPartitionDefContext(p *StepPartitionDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_stepPartitionDef
}

func (*StepPartitionDefContext) IsStepPartitionDefContext() {}

func NewStepPartitionDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StepPartitionDefContext {
	var p = new(StepPartitionDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_stepPartitionDef

	return p
}

func (s *StepPartitionDefContext) GetParser() antlr.Parser { return s.parser }

func (s *StepPartitionDefContext) GetUnitsAmount() antlr.Token { return s.unitsAmount }

func (s *StepPartitionDefContext) SetUnitsAmount(v antlr.Token) { s.unitsAmount = v }

func (s *StepPartitionDefContext) GetFrom() IPartitionValueListContext { return s.from }

func (s *StepPartitionDefContext) GetTo() IPartitionValueListContext { return s.to }

func (s *StepPartitionDefContext) GetUnit() IDatetimeUnitContext { return s.unit }

func (s *StepPartitionDefContext) SetFrom(v IPartitionValueListContext) { s.from = v }

func (s *StepPartitionDefContext) SetTo(v IPartitionValueListContext) { s.to = v }

func (s *StepPartitionDefContext) SetUnit(v IDatetimeUnitContext) { s.unit = v }

func (s *StepPartitionDefContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *StepPartitionDefContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *StepPartitionDefContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DorisParserINTERVAL, 0)
}

func (s *StepPartitionDefContext) AllPartitionValueList() []IPartitionValueListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueListContext); ok {
			tst[i] = t.(IPartitionValueListContext)
			i++
		}
	}

	return tst
}

func (s *StepPartitionDefContext) PartitionValueList(i int) IPartitionValueListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueListContext)
}

func (s *StepPartitionDefContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *StepPartitionDefContext) DatetimeUnit() IDatetimeUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeUnitContext)
}

func (s *StepPartitionDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StepPartitionDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StepPartitionDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStepPartitionDef(s)
	}
}

func (s *StepPartitionDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStepPartitionDef(s)
	}
}

func (p *DorisParser) StepPartitionDef() (localctx IStepPartitionDefContext) {
	localctx = NewStepPartitionDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, DorisParserRULE_stepPartitionDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3752)
		p.Match(DorisParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3753)

		var _x = p.PartitionValueList()

		localctx.(*StepPartitionDefContext).from = _x
	}
	{
		p.SetState(3754)
		p.Match(DorisParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3755)

		var _x = p.PartitionValueList()

		localctx.(*StepPartitionDefContext).to = _x
	}
	{
		p.SetState(3756)
		p.Match(DorisParserINTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3757)

		var _m = p.Match(DorisParserINTEGER_VALUE)

		localctx.(*StepPartitionDefContext).unitsAmount = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3759)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserDAY || _la == DorisParserHOUR || _la == DorisParserMINUTE || _la == DorisParserMONTH || _la == DorisParserSECOND || _la == DorisParserWEEK || _la == DorisParserYEAR {
		{
			p.SetState(3758)

			var _x = p.DatetimeUnit()

			localctx.(*StepPartitionDefContext).unit = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInPartitionDefContext is an interface to support dynamic dispatch.
type IInPartitionDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionName returns the partitionName rule contexts.
	GetPartitionName() IIdentifierContext

	// Get_partitionValueList returns the _partitionValueList rule contexts.
	Get_partitionValueList() IPartitionValueListContext

	// GetConstants returns the constants rule contexts.
	GetConstants() IPartitionValueListContext

	// SetPartitionName sets the partitionName rule contexts.
	SetPartitionName(IIdentifierContext)

	// Set_partitionValueList sets the _partitionValueList rule contexts.
	Set_partitionValueList(IPartitionValueListContext)

	// SetConstants sets the constants rule contexts.
	SetConstants(IPartitionValueListContext)

	// GetPartitionValueLists returns the partitionValueLists rule context list.
	GetPartitionValueLists() []IPartitionValueListContext

	// SetPartitionValueLists sets the partitionValueLists rule context list.
	SetPartitionValueLists([]IPartitionValueListContext)

	// Getter signatures
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	IN() antlr.TerminalNode
	AllPartitionValueList() []IPartitionValueListContext
	PartitionValueList(i int) IPartitionValueListContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsInPartitionDefContext differentiates from other interfaces.
	IsInPartitionDefContext()
}

type InPartitionDefContext struct {
	antlr.BaseParserRuleContext
	parser              antlr.Parser
	partitionName       IIdentifierContext
	_partitionValueList IPartitionValueListContext
	partitionValueLists []IPartitionValueListContext
	constants           IPartitionValueListContext
}

func NewEmptyInPartitionDefContext() *InPartitionDefContext {
	var p = new(InPartitionDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_inPartitionDef
	return p
}

func InitEmptyInPartitionDefContext(p *InPartitionDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_inPartitionDef
}

func (*InPartitionDefContext) IsInPartitionDefContext() {}

func NewInPartitionDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InPartitionDefContext {
	var p = new(InPartitionDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_inPartitionDef

	return p
}

func (s *InPartitionDefContext) GetParser() antlr.Parser { return s.parser }

func (s *InPartitionDefContext) GetPartitionName() IIdentifierContext { return s.partitionName }

func (s *InPartitionDefContext) Get_partitionValueList() IPartitionValueListContext {
	return s._partitionValueList
}

func (s *InPartitionDefContext) GetConstants() IPartitionValueListContext { return s.constants }

func (s *InPartitionDefContext) SetPartitionName(v IIdentifierContext) { s.partitionName = v }

func (s *InPartitionDefContext) Set_partitionValueList(v IPartitionValueListContext) {
	s._partitionValueList = v
}

func (s *InPartitionDefContext) SetConstants(v IPartitionValueListContext) { s.constants = v }

func (s *InPartitionDefContext) GetPartitionValueLists() []IPartitionValueListContext {
	return s.partitionValueLists
}

func (s *InPartitionDefContext) SetPartitionValueLists(v []IPartitionValueListContext) {
	s.partitionValueLists = v
}

func (s *InPartitionDefContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *InPartitionDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InPartitionDefContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *InPartitionDefContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *InPartitionDefContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *InPartitionDefContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisParserVALUES, 0)
}

func (s *InPartitionDefContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *InPartitionDefContext) AllPartitionValueList() []IPartitionValueListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueListContext); ok {
			tst[i] = t.(IPartitionValueListContext)
			i++
		}
	}

	return tst
}

func (s *InPartitionDefContext) PartitionValueList(i int) IPartitionValueListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueListContext)
}

func (s *InPartitionDefContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *InPartitionDefContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *InPartitionDefContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *InPartitionDefContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *InPartitionDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InPartitionDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InPartitionDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterInPartitionDef(s)
	}
}

func (s *InPartitionDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitInPartitionDef(s)
	}
}

func (p *DorisParser) InPartitionDef() (localctx IInPartitionDefContext) {
	localctx = NewInPartitionDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, DorisParserRULE_inPartitionDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3761)
		p.Match(DorisParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3765)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserIF {
		{
			p.SetState(3762)
			p.Match(DorisParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3763)
			p.Match(DorisParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3764)
			p.Match(DorisParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3767)

		var _x = p.Identifier()

		localctx.(*InPartitionDefContext).partitionName = _x
	}
	p.SetState(3784)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserVALUES {
		{
			p.SetState(3768)
			p.Match(DorisParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3769)
			p.Match(DorisParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3782)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 532, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3770)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3771)

				var _x = p.PartitionValueList()

				localctx.(*InPartitionDefContext)._partitionValueList = _x
			}
			localctx.(*InPartitionDefContext).partitionValueLists = append(localctx.(*InPartitionDefContext).partitionValueLists, localctx.(*InPartitionDefContext)._partitionValueList)
			p.SetState(3776)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(3772)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3773)

					var _x = p.PartitionValueList()

					localctx.(*InPartitionDefContext)._partitionValueList = _x
				}
				localctx.(*InPartitionDefContext).partitionValueLists = append(localctx.(*InPartitionDefContext).partitionValueLists, localctx.(*InPartitionDefContext)._partitionValueList)

				p.SetState(3778)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3779)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(3781)

				var _x = p.PartitionValueList()

				localctx.(*InPartitionDefContext).constants = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionValueListContext is an interface to support dynamic dispatch.
type IPartitionValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_partitionValueDef returns the _partitionValueDef rule contexts.
	Get_partitionValueDef() IPartitionValueDefContext

	// Set_partitionValueDef sets the _partitionValueDef rule contexts.
	Set_partitionValueDef(IPartitionValueDefContext)

	// GetValues returns the values rule context list.
	GetValues() []IPartitionValueDefContext

	// SetValues sets the values rule context list.
	SetValues([]IPartitionValueDefContext)

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllPartitionValueDef() []IPartitionValueDefContext
	PartitionValueDef(i int) IPartitionValueDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionValueListContext differentiates from other interfaces.
	IsPartitionValueListContext()
}

type PartitionValueListContext struct {
	antlr.BaseParserRuleContext
	parser             antlr.Parser
	_partitionValueDef IPartitionValueDefContext
	values             []IPartitionValueDefContext
}

func NewEmptyPartitionValueListContext() *PartitionValueListContext {
	var p = new(PartitionValueListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionValueList
	return p
}

func InitEmptyPartitionValueListContext(p *PartitionValueListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionValueList
}

func (*PartitionValueListContext) IsPartitionValueListContext() {}

func NewPartitionValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValueListContext {
	var p = new(PartitionValueListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_partitionValueList

	return p
}

func (s *PartitionValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValueListContext) Get_partitionValueDef() IPartitionValueDefContext {
	return s._partitionValueDef
}

func (s *PartitionValueListContext) Set_partitionValueDef(v IPartitionValueDefContext) {
	s._partitionValueDef = v
}

func (s *PartitionValueListContext) GetValues() []IPartitionValueDefContext { return s.values }

func (s *PartitionValueListContext) SetValues(v []IPartitionValueDefContext) { s.values = v }

func (s *PartitionValueListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *PartitionValueListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *PartitionValueListContext) AllPartitionValueDef() []IPartitionValueDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueDefContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueDefContext); ok {
			tst[i] = t.(IPartitionValueDefContext)
			i++
		}
	}

	return tst
}

func (s *PartitionValueListContext) PartitionValueDef(i int) IPartitionValueDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueDefContext)
}

func (s *PartitionValueListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *PartitionValueListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *PartitionValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionValueListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPartitionValueList(s)
	}
}

func (s *PartitionValueListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPartitionValueList(s)
	}
}

func (p *DorisParser) PartitionValueList() (localctx IPartitionValueListContext) {
	localctx = NewPartitionValueListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, DorisParserRULE_partitionValueList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3786)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3787)

		var _x = p.PartitionValueDef()

		localctx.(*PartitionValueListContext)._partitionValueDef = _x
	}
	localctx.(*PartitionValueListContext).values = append(localctx.(*PartitionValueListContext).values, localctx.(*PartitionValueListContext)._partitionValueDef)
	p.SetState(3792)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(3788)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3789)

			var _x = p.PartitionValueDef()

			localctx.(*PartitionValueListContext)._partitionValueDef = _x
		}
		localctx.(*PartitionValueListContext).values = append(localctx.(*PartitionValueListContext).values, localctx.(*PartitionValueListContext)._partitionValueDef)

		p.SetState(3794)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3795)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionValueDefContext is an interface to support dynamic dispatch.
type IPartitionValueDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER_VALUE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	MAXVALUE() antlr.TerminalNode
	NULL() antlr.TerminalNode

	// IsPartitionValueDefContext differentiates from other interfaces.
	IsPartitionValueDefContext()
}

type PartitionValueDefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionValueDefContext() *PartitionValueDefContext {
	var p = new(PartitionValueDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionValueDef
	return p
}

func InitEmptyPartitionValueDefContext(p *PartitionValueDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionValueDef
}

func (*PartitionValueDefContext) IsPartitionValueDefContext() {}

func NewPartitionValueDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValueDefContext {
	var p = new(PartitionValueDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_partitionValueDef

	return p
}

func (s *PartitionValueDefContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValueDefContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *PartitionValueDefContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *PartitionValueDefContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserMAXVALUE, 0)
}

func (s *PartitionValueDefContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisParserNULL, 0)
}

func (s *PartitionValueDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValueDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionValueDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPartitionValueDef(s)
	}
}

func (s *PartitionValueDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPartitionValueDef(s)
	}
}

func (p *DorisParser) PartitionValueDef() (localctx IPartitionValueDefContext) {
	localctx = NewPartitionValueDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, DorisParserRULE_partitionValueDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3797)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserMAXVALUE || _la == DorisParserNULL || _la == DorisParserSTRING_LITERAL || _la == DorisParserINTEGER_VALUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollupDefsContext is an interface to support dynamic dispatch.
type IRollupDefsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_rollupDef returns the _rollupDef rule contexts.
	Get_rollupDef() IRollupDefContext

	// Set_rollupDef sets the _rollupDef rule contexts.
	Set_rollupDef(IRollupDefContext)

	// GetRollups returns the rollups rule context list.
	GetRollups() []IRollupDefContext

	// SetRollups sets the rollups rule context list.
	SetRollups([]IRollupDefContext)

	// Getter signatures
	AllRollupDef() []IRollupDefContext
	RollupDef(i int) IRollupDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRollupDefsContext differentiates from other interfaces.
	IsRollupDefsContext()
}

type RollupDefsContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	_rollupDef IRollupDefContext
	rollups    []IRollupDefContext
}

func NewEmptyRollupDefsContext() *RollupDefsContext {
	var p = new(RollupDefsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_rollupDefs
	return p
}

func InitEmptyRollupDefsContext(p *RollupDefsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_rollupDefs
}

func (*RollupDefsContext) IsRollupDefsContext() {}

func NewRollupDefsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollupDefsContext {
	var p = new(RollupDefsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_rollupDefs

	return p
}

func (s *RollupDefsContext) GetParser() antlr.Parser { return s.parser }

func (s *RollupDefsContext) Get_rollupDef() IRollupDefContext { return s._rollupDef }

func (s *RollupDefsContext) Set_rollupDef(v IRollupDefContext) { s._rollupDef = v }

func (s *RollupDefsContext) GetRollups() []IRollupDefContext { return s.rollups }

func (s *RollupDefsContext) SetRollups(v []IRollupDefContext) { s.rollups = v }

func (s *RollupDefsContext) AllRollupDef() []IRollupDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRollupDefContext); ok {
			len++
		}
	}

	tst := make([]IRollupDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRollupDefContext); ok {
			tst[i] = t.(IRollupDefContext)
			i++
		}
	}

	return tst
}

func (s *RollupDefsContext) RollupDef(i int) IRollupDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupDefContext)
}

func (s *RollupDefsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *RollupDefsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *RollupDefsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupDefsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollupDefsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRollupDefs(s)
	}
}

func (s *RollupDefsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRollupDefs(s)
	}
}

func (p *DorisParser) RollupDefs() (localctx IRollupDefsContext) {
	localctx = NewRollupDefsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, DorisParserRULE_rollupDefs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3799)

		var _x = p.RollupDef()

		localctx.(*RollupDefsContext)._rollupDef = _x
	}
	localctx.(*RollupDefsContext).rollups = append(localctx.(*RollupDefsContext).rollups, localctx.(*RollupDefsContext)._rollupDef)
	p.SetState(3804)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(3800)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3801)

			var _x = p.RollupDef()

			localctx.(*RollupDefsContext)._rollupDef = _x
		}
		localctx.(*RollupDefsContext).rollups = append(localctx.(*RollupDefsContext).rollups, localctx.(*RollupDefsContext)._rollupDef)

		p.SetState(3806)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollupDefContext is an interface to support dynamic dispatch.
type IRollupDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// GetRollupCols returns the rollupCols rule contexts.
	GetRollupCols() IIdentifierListContext

	// GetDupKeys returns the dupKeys rule contexts.
	GetDupKeys() IIdentifierListContext

	// GetProperties returns the properties rule contexts.
	GetProperties() IPropertyClauseContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// SetRollupCols sets the rollupCols rule contexts.
	SetRollupCols(IIdentifierListContext)

	// SetDupKeys sets the dupKeys rule contexts.
	SetDupKeys(IIdentifierListContext)

	// SetProperties sets the properties rule contexts.
	SetProperties(IPropertyClauseContext)

	// Getter signatures
	Identifier() IIdentifierContext
	AllIdentifierList() []IIdentifierListContext
	IdentifierList(i int) IIdentifierListContext
	DUPLICATE() antlr.TerminalNode
	KEY() antlr.TerminalNode
	PropertyClause() IPropertyClauseContext

	// IsRollupDefContext differentiates from other interfaces.
	IsRollupDefContext()
}

type RollupDefContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
	rollupCols IIdentifierListContext
	dupKeys    IIdentifierListContext
	properties IPropertyClauseContext
}

func NewEmptyRollupDefContext() *RollupDefContext {
	var p = new(RollupDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_rollupDef
	return p
}

func InitEmptyRollupDefContext(p *RollupDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_rollupDef
}

func (*RollupDefContext) IsRollupDefContext() {}

func NewRollupDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollupDefContext {
	var p = new(RollupDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_rollupDef

	return p
}

func (s *RollupDefContext) GetParser() antlr.Parser { return s.parser }

func (s *RollupDefContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *RollupDefContext) GetRollupCols() IIdentifierListContext { return s.rollupCols }

func (s *RollupDefContext) GetDupKeys() IIdentifierListContext { return s.dupKeys }

func (s *RollupDefContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *RollupDefContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *RollupDefContext) SetRollupCols(v IIdentifierListContext) { s.rollupCols = v }

func (s *RollupDefContext) SetDupKeys(v IIdentifierListContext) { s.dupKeys = v }

func (s *RollupDefContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *RollupDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RollupDefContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *RollupDefContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *RollupDefContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(DorisParserDUPLICATE, 0)
}

func (s *RollupDefContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserKEY, 0)
}

func (s *RollupDefContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *RollupDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollupDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRollupDef(s)
	}
}

func (s *RollupDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRollupDef(s)
	}
}

func (p *DorisParser) RollupDef() (localctx IRollupDefContext) {
	localctx = NewRollupDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, DorisParserRULE_rollupDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3807)

		var _x = p.Identifier()

		localctx.(*RollupDefContext).rollupName = _x
	}
	{
		p.SetState(3808)

		var _x = p.IdentifierList()

		localctx.(*RollupDefContext).rollupCols = _x
	}
	p.SetState(3812)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserDUPLICATE {
		{
			p.SetState(3809)
			p.Match(DorisParserDUPLICATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3810)
			p.Match(DorisParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3811)

			var _x = p.IdentifierList()

			localctx.(*RollupDefContext).dupKeys = _x
		}

	}
	p.SetState(3815)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPROPERTIES {
		{
			p.SetState(3814)

			var _x = p.PropertyClause()

			localctx.(*RollupDefContext).properties = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggTypeDefContext is an interface to support dynamic dispatch.
type IAggTypeDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAX() antlr.TerminalNode
	MIN() antlr.TerminalNode
	SUM() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	REPLACE_IF_NOT_NULL() antlr.TerminalNode
	HLL_UNION() antlr.TerminalNode
	BITMAP_UNION() antlr.TerminalNode
	QUANTILE_UNION() antlr.TerminalNode
	GENERIC() antlr.TerminalNode

	// IsAggTypeDefContext differentiates from other interfaces.
	IsAggTypeDefContext()
}

type AggTypeDefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggTypeDefContext() *AggTypeDefContext {
	var p = new(AggTypeDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_aggTypeDef
	return p
}

func InitEmptyAggTypeDefContext(p *AggTypeDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_aggTypeDef
}

func (*AggTypeDefContext) IsAggTypeDefContext() {}

func NewAggTypeDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggTypeDefContext {
	var p = new(AggTypeDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_aggTypeDef

	return p
}

func (s *AggTypeDefContext) GetParser() antlr.Parser { return s.parser }

func (s *AggTypeDefContext) MAX() antlr.TerminalNode {
	return s.GetToken(DorisParserMAX, 0)
}

func (s *AggTypeDefContext) MIN() antlr.TerminalNode {
	return s.GetToken(DorisParserMIN, 0)
}

func (s *AggTypeDefContext) SUM() antlr.TerminalNode {
	return s.GetToken(DorisParserSUM, 0)
}

func (s *AggTypeDefContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *AggTypeDefContext) REPLACE_IF_NOT_NULL() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE_IF_NOT_NULL, 0)
}

func (s *AggTypeDefContext) HLL_UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserHLL_UNION, 0)
}

func (s *AggTypeDefContext) BITMAP_UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserBITMAP_UNION, 0)
}

func (s *AggTypeDefContext) QUANTILE_UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserQUANTILE_UNION, 0)
}

func (s *AggTypeDefContext) GENERIC() antlr.TerminalNode {
	return s.GetToken(DorisParserGENERIC, 0)
}

func (s *AggTypeDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggTypeDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggTypeDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAggTypeDef(s)
	}
}

func (s *AggTypeDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAggTypeDef(s)
	}
}

func (p *DorisParser) AggTypeDef() (localctx IAggTypeDefContext) {
	localctx = NewAggTypeDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, DorisParserRULE_aggTypeDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3817)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserBITMAP_UNION || _la == DorisParserGENERIC || _la == DorisParserHLL_UNION || _la == DorisParserMAX || _la == DorisParserMIN || ((int64((_la-355)) & ^0x3f) == 0 && ((int64(1)<<(_la-355))&786433) != 0) || _la == DorisParserSUM) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITabletListContext is an interface to support dynamic dispatch.
type ITabletListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_INTEGER_VALUE returns the _INTEGER_VALUE token.
	Get_INTEGER_VALUE() antlr.Token

	// Set_INTEGER_VALUE sets the _INTEGER_VALUE token.
	Set_INTEGER_VALUE(antlr.Token)

	// GetTabletIdList returns the tabletIdList token list.
	GetTabletIdList() []antlr.Token

	// SetTabletIdList sets the tabletIdList token list.
	SetTabletIdList([]antlr.Token)

	// Getter signatures
	TABLET() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTabletListContext differentiates from other interfaces.
	IsTabletListContext()
}

type TabletListContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	_INTEGER_VALUE antlr.Token
	tabletIdList   []antlr.Token
}

func NewEmptyTabletListContext() *TabletListContext {
	var p = new(TabletListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tabletList
	return p
}

func InitEmptyTabletListContext(p *TabletListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tabletList
}

func (*TabletListContext) IsTabletListContext() {}

func NewTabletListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TabletListContext {
	var p = new(TabletListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_tabletList

	return p
}

func (s *TabletListContext) GetParser() antlr.Parser { return s.parser }

func (s *TabletListContext) Get_INTEGER_VALUE() antlr.Token { return s._INTEGER_VALUE }

func (s *TabletListContext) Set_INTEGER_VALUE(v antlr.Token) { s._INTEGER_VALUE = v }

func (s *TabletListContext) GetTabletIdList() []antlr.Token { return s.tabletIdList }

func (s *TabletListContext) SetTabletIdList(v []antlr.Token) { s.tabletIdList = v }

func (s *TabletListContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLET, 0)
}

func (s *TabletListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *TabletListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *TabletListContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserINTEGER_VALUE)
}

func (s *TabletListContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, i)
}

func (s *TabletListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *TabletListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *TabletListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TabletListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TabletListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTabletList(s)
	}
}

func (s *TabletListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTabletList(s)
	}
}

func (p *DorisParser) TabletList() (localctx ITabletListContext) {
	localctx = NewTabletListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, DorisParserRULE_tabletList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3819)
		p.Match(DorisParserTABLET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3820)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3821)

		var _m = p.Match(DorisParserINTEGER_VALUE)

		localctx.(*TabletListContext)._INTEGER_VALUE = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	localctx.(*TabletListContext).tabletIdList = append(localctx.(*TabletListContext).tabletIdList, localctx.(*TabletListContext)._INTEGER_VALUE)
	p.SetState(3826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(3822)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3823)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*TabletListContext)._INTEGER_VALUE = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*TabletListContext).tabletIdList = append(localctx.(*TabletListContext).tabletIdList, localctx.(*TabletListContext)._INTEGER_VALUE)

		p.SetState(3828)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3829)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlineTableContext is an interface to support dynamic dispatch.
type IInlineTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALUES() antlr.TerminalNode
	AllRowConstructor() []IRowConstructorContext
	RowConstructor(i int) IRowConstructorContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsInlineTableContext differentiates from other interfaces.
	IsInlineTableContext()
}

type InlineTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineTableContext() *InlineTableContext {
	var p = new(InlineTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_inlineTable
	return p
}

func InitEmptyInlineTableContext(p *InlineTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_inlineTable
}

func (*InlineTableContext) IsInlineTableContext() {}

func NewInlineTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineTableContext {
	var p = new(InlineTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_inlineTable

	return p
}

func (s *InlineTableContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineTableContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisParserVALUES, 0)
}

func (s *InlineTableContext) AllRowConstructor() []IRowConstructorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRowConstructorContext); ok {
			len++
		}
	}

	tst := make([]IRowConstructorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRowConstructorContext); ok {
			tst[i] = t.(IRowConstructorContext)
			i++
		}
	}

	return tst
}

func (s *InlineTableContext) RowConstructor(i int) IRowConstructorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowConstructorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowConstructorContext)
}

func (s *InlineTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *InlineTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *InlineTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterInlineTable(s)
	}
}

func (s *InlineTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitInlineTable(s)
	}
}

func (p *DorisParser) InlineTable() (localctx IInlineTableContext) {
	localctx = NewInlineTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, DorisParserRULE_inlineTable)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3831)
		p.Match(DorisParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3832)
		p.RowConstructor()
	}
	p.SetState(3837)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 539, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3833)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3834)
				p.RowConstructor()
			}

		}
		p.SetState(3839)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 539, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedExpressionContext is an interface to support dynamic dispatch.
type INamedExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	IdentifierOrText() IIdentifierOrTextContext
	AS() antlr.TerminalNode

	// IsNamedExpressionContext differentiates from other interfaces.
	IsNamedExpressionContext()
}

type NamedExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedExpressionContext() *NamedExpressionContext {
	var p = new(NamedExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_namedExpression
	return p
}

func InitEmptyNamedExpressionContext(p *NamedExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_namedExpression
}

func (*NamedExpressionContext) IsNamedExpressionContext() {}

func NewNamedExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedExpressionContext {
	var p = new(NamedExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_namedExpression

	return p
}

func (s *NamedExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NamedExpressionContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *NamedExpressionContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *NamedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterNamedExpression(s)
	}
}

func (s *NamedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitNamedExpression(s)
	}
}

func (p *DorisParser) NamedExpression() (localctx INamedExpressionContext) {
	localctx = NewNamedExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, DorisParserRULE_namedExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3840)
		p.Expression()
	}
	p.SetState(3845)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 541, p.GetParserRuleContext()) == 1 {
		p.SetState(3842)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAS {
			{
				p.SetState(3841)
				p.Match(DorisParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

		{
			p.SetState(3844)
			p.IdentifierOrText()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedExpressionSeqContext is an interface to support dynamic dispatch.
type INamedExpressionSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNamedExpression() []INamedExpressionContext
	NamedExpression(i int) INamedExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsNamedExpressionSeqContext differentiates from other interfaces.
	IsNamedExpressionSeqContext()
}

type NamedExpressionSeqContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedExpressionSeqContext() *NamedExpressionSeqContext {
	var p = new(NamedExpressionSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_namedExpressionSeq
	return p
}

func InitEmptyNamedExpressionSeqContext(p *NamedExpressionSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_namedExpressionSeq
}

func (*NamedExpressionSeqContext) IsNamedExpressionSeqContext() {}

func NewNamedExpressionSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedExpressionSeqContext {
	var p = new(NamedExpressionSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_namedExpressionSeq

	return p
}

func (s *NamedExpressionSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedExpressionSeqContext) AllNamedExpression() []INamedExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedExpressionContext); ok {
			len++
		}
	}

	tst := make([]INamedExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedExpressionContext); ok {
			tst[i] = t.(INamedExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NamedExpressionSeqContext) NamedExpression(i int) INamedExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionContext)
}

func (s *NamedExpressionSeqContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *NamedExpressionSeqContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *NamedExpressionSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedExpressionSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedExpressionSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterNamedExpressionSeq(s)
	}
}

func (s *NamedExpressionSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitNamedExpressionSeq(s)
	}
}

func (p *DorisParser) NamedExpressionSeq() (localctx INamedExpressionSeqContext) {
	localctx = NewNamedExpressionSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, DorisParserRULE_namedExpressionSeq)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3847)
		p.NamedExpression()
	}
	p.SetState(3852)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 542, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3848)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3849)
				p.NamedExpression()
			}

		}
		p.SetState(3854)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 542, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BooleanExpression() IBooleanExpressionContext
	LambdaExpression() ILambdaExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ExpressionContext) LambdaExpression() ILambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *DorisParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, DorisParserRULE_expression)
	p.SetState(3857)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 543, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3855)
			p.booleanExpression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3856)
			p.LambdaExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaExpressionContext is an interface to support dynamic dispatch.
type ILambdaExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_errorCapturingIdentifier returns the _errorCapturingIdentifier rule contexts.
	Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext

	// GetBody returns the body rule contexts.
	GetBody() IBooleanExpressionContext

	// Set_errorCapturingIdentifier sets the _errorCapturingIdentifier rule contexts.
	Set_errorCapturingIdentifier(IErrorCapturingIdentifierContext)

	// SetBody sets the body rule contexts.
	SetBody(IBooleanExpressionContext)

	// GetArgs returns the args rule context list.
	GetArgs() []IErrorCapturingIdentifierContext

	// SetArgs sets the args rule context list.
	SetArgs([]IErrorCapturingIdentifierContext)

	// Getter signatures
	ARROW() antlr.TerminalNode
	AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext
	ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext
	BooleanExpression() IBooleanExpressionContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLambdaExpressionContext differentiates from other interfaces.
	IsLambdaExpressionContext()
}

type LambdaExpressionContext struct {
	antlr.BaseParserRuleContext
	parser                    antlr.Parser
	_errorCapturingIdentifier IErrorCapturingIdentifierContext
	args                      []IErrorCapturingIdentifierContext
	body                      IBooleanExpressionContext
}

func NewEmptyLambdaExpressionContext() *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_lambdaExpression
	return p
}

func InitEmptyLambdaExpressionContext(p *LambdaExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_lambdaExpression
}

func (*LambdaExpressionContext) IsLambdaExpressionContext() {}

func NewLambdaExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_lambdaExpression

	return p
}

func (s *LambdaExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaExpressionContext) Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext {
	return s._errorCapturingIdentifier
}

func (s *LambdaExpressionContext) GetBody() IBooleanExpressionContext { return s.body }

func (s *LambdaExpressionContext) Set_errorCapturingIdentifier(v IErrorCapturingIdentifierContext) {
	s._errorCapturingIdentifier = v
}

func (s *LambdaExpressionContext) SetBody(v IBooleanExpressionContext) { s.body = v }

func (s *LambdaExpressionContext) GetArgs() []IErrorCapturingIdentifierContext { return s.args }

func (s *LambdaExpressionContext) SetArgs(v []IErrorCapturingIdentifierContext) { s.args = v }

func (s *LambdaExpressionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(DorisParserARROW, 0)
}

func (s *LambdaExpressionContext) AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IErrorCapturingIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			tst[i] = t.(IErrorCapturingIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *LambdaExpressionContext) ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *LambdaExpressionContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LambdaExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *LambdaExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *LambdaExpressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *LambdaExpressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *LambdaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLambdaExpression(s)
	}
}

func (s *LambdaExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLambdaExpression(s)
	}
}

func (p *DorisParser) LambdaExpression() (localctx ILambdaExpressionContext) {
	localctx = NewLambdaExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, DorisParserRULE_lambdaExpression)
	var _la int

	p.SetState(3875)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADDDATE, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserARRAY_RANGE, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATE_ADD, DorisParserDATE_CEIL, DorisParserDATE_DIFF, DorisParserDATE_FLOOR, DorisParserDATE_SUB, DorisParserDATEADD, DorisParserDATEDIFF, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS_ADD, DorisParserDAYS_SUB, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSEQUENCE, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUBDATE, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTIMESTAMPADD, DorisParserTIMESTAMPDIFF, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3859)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*LambdaExpressionContext)._errorCapturingIdentifier = _x
		}
		localctx.(*LambdaExpressionContext).args = append(localctx.(*LambdaExpressionContext).args, localctx.(*LambdaExpressionContext)._errorCapturingIdentifier)
		{
			p.SetState(3860)
			p.Match(DorisParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3861)

			var _x = p.booleanExpression(0)

			localctx.(*LambdaExpressionContext).body = _x
		}

	case DorisParserLEFT_PAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3863)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3864)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*LambdaExpressionContext)._errorCapturingIdentifier = _x
		}
		localctx.(*LambdaExpressionContext).args = append(localctx.(*LambdaExpressionContext).args, localctx.(*LambdaExpressionContext)._errorCapturingIdentifier)
		p.SetState(3867)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == DorisParserCOMMA {
			{
				p.SetState(3865)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3866)

				var _x = p.ErrorCapturingIdentifier()

				localctx.(*LambdaExpressionContext)._errorCapturingIdentifier = _x
			}
			localctx.(*LambdaExpressionContext).args = append(localctx.(*LambdaExpressionContext).args, localctx.(*LambdaExpressionContext)._errorCapturingIdentifier)

			p.SetState(3869)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3871)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3872)
			p.Match(DorisParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3873)

			var _x = p.booleanExpression(0)

			localctx.(*LambdaExpressionContext).body = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanExpressionContext is an interface to support dynamic dispatch.
type IBooleanExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBooleanExpressionContext differentiates from other interfaces.
	IsBooleanExpressionContext()
}

type BooleanExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanExpressionContext() *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_booleanExpression
	return p
}

func InitEmptyBooleanExpressionContext(p *BooleanExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_booleanExpression
}

func (*BooleanExpressionContext) IsBooleanExpressionContext() {}

func NewBooleanExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_booleanExpression

	return p
}

func (s *BooleanExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanExpressionContext) CopyAll(ctx *BooleanExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BooleanExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExistContext struct {
	BooleanExpressionContext
}

func NewExistContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistContext {
	var p = new(ExistContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *ExistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *ExistContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ExistContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *ExistContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ExistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterExist(s)
	}
}

func (s *ExistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitExist(s)
	}
}

type LogicalNotContext struct {
	BooleanExpressionContext
}

func NewLogicalNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalNotContext {
	var p = new(LogicalNotContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalNotContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalNotContext) LOGICALNOT() antlr.TerminalNode {
	return s.GetToken(DorisParserLOGICALNOT, 0)
}

func (s *LogicalNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *LogicalNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLogicalNot(s)
	}
}

func (s *LogicalNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLogicalNot(s)
	}
}

type PredicatedContext struct {
	BooleanExpressionContext
}

func NewPredicatedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicatedContext {
	var p = new(PredicatedContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *PredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicatedContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicatedContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPredicated(s)
	}
}

func (s *PredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPredicated(s)
	}
}

type IsnullContext struct {
	BooleanExpressionContext
}

func NewIsnullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsnullContext {
	var p = new(IsnullContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *IsnullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsnullContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *IsnullContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *IsnullContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *IsnullContext) ISNULL() antlr.TerminalNode {
	return s.GetToken(DorisParserISNULL, 0)
}

func (s *IsnullContext) IS_NULL_PRED() antlr.TerminalNode {
	return s.GetToken(DorisParserIS_NULL_PRED, 0)
}

func (s *IsnullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIsnull(s)
	}
}

func (s *IsnullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIsnull(s)
	}
}

type Is_not_null_predContext struct {
	BooleanExpressionContext
}

func NewIs_not_null_predContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Is_not_null_predContext {
	var p = new(Is_not_null_predContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *Is_not_null_predContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Is_not_null_predContext) IS_NOT_NULL_PRED() antlr.TerminalNode {
	return s.GetToken(DorisParserIS_NOT_NULL_PRED, 0)
}

func (s *Is_not_null_predContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *Is_not_null_predContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *Is_not_null_predContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *Is_not_null_predContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIs_not_null_pred(s)
	}
}

func (s *Is_not_null_predContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIs_not_null_pred(s)
	}
}

type LogicalBinaryContext struct {
	BooleanExpressionContext
	left     IBooleanExpressionContext
	operator antlr.Token
	right    IBooleanExpressionContext
}

func NewLogicalBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalBinaryContext {
	var p = new(LogicalBinaryContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *LogicalBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *LogicalBinaryContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *LogicalBinaryContext) GetRight() IBooleanExpressionContext { return s.right }

func (s *LogicalBinaryContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *LogicalBinaryContext) SetRight(v IBooleanExpressionContext) { s.right = v }

func (s *LogicalBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalBinaryContext) AllBooleanExpression() []IBooleanExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			len++
		}
	}

	tst := make([]IBooleanExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBooleanExpressionContext); ok {
			tst[i] = t.(IBooleanExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalBinaryContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalBinaryContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisParserAND, 0)
}

func (s *LogicalBinaryContext) LOGICALAND() antlr.TerminalNode {
	return s.GetToken(DorisParserLOGICALAND, 0)
}

func (s *LogicalBinaryContext) XOR() antlr.TerminalNode {
	return s.GetToken(DorisParserXOR, 0)
}

func (s *LogicalBinaryContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisParserOR, 0)
}

func (s *LogicalBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLogicalBinary(s)
	}
}

type DoublePipesContext struct {
	BooleanExpressionContext
	left     IBooleanExpressionContext
	operator antlr.Token
	right    IBooleanExpressionContext
}

func NewDoublePipesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoublePipesContext {
	var p = new(DoublePipesContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *DoublePipesContext) GetOperator() antlr.Token { return s.operator }

func (s *DoublePipesContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *DoublePipesContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *DoublePipesContext) GetRight() IBooleanExpressionContext { return s.right }

func (s *DoublePipesContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *DoublePipesContext) SetRight(v IBooleanExpressionContext) { s.right = v }

func (s *DoublePipesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoublePipesContext) AllBooleanExpression() []IBooleanExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			len++
		}
	}

	tst := make([]IBooleanExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBooleanExpressionContext); ok {
			tst[i] = t.(IBooleanExpressionContext)
			i++
		}
	}

	return tst
}

func (s *DoublePipesContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *DoublePipesContext) DOUBLEPIPES() antlr.TerminalNode {
	return s.GetToken(DorisParserDOUBLEPIPES, 0)
}

func (s *DoublePipesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDoublePipes(s)
	}
}

func (s *DoublePipesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDoublePipes(s)
	}
}

func (p *DorisParser) BooleanExpression() (localctx IBooleanExpressionContext) {
	return p.booleanExpression(0)
}

func (p *DorisParser) booleanExpression(_p int) (localctx IBooleanExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBooleanExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBooleanExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 308
	p.EnterRecursionRule(localctx, 308, DorisParserRULE_booleanExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3899)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 547, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(3878)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserNOT || _la == DorisParserLOGICALNOT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3879)
			p.booleanExpression(9)
		}

	case 2:
		localctx = NewExistContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3880)
			p.Match(DorisParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3881)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3882)
			p.Query()
		}
		{
			p.SetState(3883)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewIsnullContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3885)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserIS_NULL_PRED || _la == DorisParserISNULL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3886)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3887)
			p.valueExpression(0)
		}
		{
			p.SetState(3888)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewIs_not_null_predContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3890)
			p.Match(DorisParserIS_NOT_NULL_PRED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3891)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3892)
			p.valueExpression(0)
		}
		{
			p.SetState(3893)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewPredicatedContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3895)
			p.valueExpression(0)
		}
		p.SetState(3897)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 546, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3896)
				p.Predicate()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(3915)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 549, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(3913)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 548, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_booleanExpression)
				p.SetState(3901)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(3902)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*LogicalBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisParserAND || _la == DorisParserLOGICALAND) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*LogicalBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(3903)

					var _x = p.booleanExpression(5)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 2:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_booleanExpression)
				p.SetState(3904)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(3905)

					var _m = p.Match(DorisParserXOR)

					localctx.(*LogicalBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3906)

					var _x = p.booleanExpression(4)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 3:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_booleanExpression)
				p.SetState(3907)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(3908)

					var _m = p.Match(DorisParserOR)

					localctx.(*LogicalBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3909)

					var _x = p.booleanExpression(3)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 4:
				localctx = NewDoublePipesContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*DoublePipesContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_booleanExpression)
				p.SetState(3910)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(3911)

					var _m = p.Match(DorisParserDOUBLEPIPES)

					localctx.(*DoublePipesContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3912)

					var _x = p.booleanExpression(2)

					localctx.(*DoublePipesContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(3917)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 549, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowConstructorContext is an interface to support dynamic dispatch.
type IRowConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllRowConstructorItem() []IRowConstructorItemContext
	RowConstructorItem(i int) IRowConstructorItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRowConstructorContext differentiates from other interfaces.
	IsRowConstructorContext()
}

type RowConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowConstructorContext() *RowConstructorContext {
	var p = new(RowConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_rowConstructor
	return p
}

func InitEmptyRowConstructorContext(p *RowConstructorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_rowConstructor
}

func (*RowConstructorContext) IsRowConstructorContext() {}

func NewRowConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowConstructorContext {
	var p = new(RowConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_rowConstructor

	return p
}

func (s *RowConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *RowConstructorContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *RowConstructorContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *RowConstructorContext) AllRowConstructorItem() []IRowConstructorItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRowConstructorItemContext); ok {
			len++
		}
	}

	tst := make([]IRowConstructorItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRowConstructorItemContext); ok {
			tst[i] = t.(IRowConstructorItemContext)
			i++
		}
	}

	return tst
}

func (s *RowConstructorContext) RowConstructorItem(i int) IRowConstructorItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowConstructorItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowConstructorItemContext)
}

func (s *RowConstructorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *RowConstructorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *RowConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRowConstructor(s)
	}
}

func (s *RowConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRowConstructor(s)
	}
}

func (p *DorisParser) RowConstructor() (localctx IRowConstructorContext) {
	localctx = NewRowConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, DorisParserRULE_rowConstructor)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3918)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3927)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1153005225580239228) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-141717009369345) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-4539691388701481801) != 0) || ((int64((_la-195)) & ^0x3f) == 0 && ((int64(1)<<(_la-195))&-3103018623212733835) != 0) || ((int64((_la-259)) & ^0x3f) == 0 && ((int64(1)<<(_la-259))&-9089391056176578961) != 0) || ((int64((_la-323)) & ^0x3f) == 0 && ((int64(1)<<(_la-323))&-2310857813124972547) != 0) || ((int64((_la-387)) & ^0x3f) == 0 && ((int64(1)<<(_la-387))&-5255560032135782599) != 0) || ((int64((_la-451)) & ^0x3f) == 0 && ((int64(1)<<(_la-451))&5621092667580571559) != 0) || ((int64((_la-516)) & ^0x3f) == 0 && ((int64(1)<<(_la-516))&3608513) != 0) {
		{
			p.SetState(3919)
			p.RowConstructorItem()
		}
		p.SetState(3924)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(3920)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3921)
				p.RowConstructorItem()
			}

			p.SetState(3926)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3929)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowConstructorItemContext is an interface to support dynamic dispatch.
type IRowConstructorItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NamedExpression() INamedExpressionContext
	DEFAULT() antlr.TerminalNode

	// IsRowConstructorItemContext differentiates from other interfaces.
	IsRowConstructorItemContext()
}

type RowConstructorItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowConstructorItemContext() *RowConstructorItemContext {
	var p = new(RowConstructorItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_rowConstructorItem
	return p
}

func InitEmptyRowConstructorItemContext(p *RowConstructorItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_rowConstructorItem
}

func (*RowConstructorItemContext) IsRowConstructorItemContext() {}

func NewRowConstructorItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowConstructorItemContext {
	var p = new(RowConstructorItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_rowConstructorItem

	return p
}

func (s *RowConstructorItemContext) GetParser() antlr.Parser { return s.parser }

func (s *RowConstructorItemContext) NamedExpression() INamedExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionContext)
}

func (s *RowConstructorItemContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *RowConstructorItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowConstructorItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowConstructorItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRowConstructorItem(s)
	}
}

func (s *RowConstructorItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRowConstructorItem(s)
	}
}

func (p *DorisParser) RowConstructorItem() (localctx IRowConstructorItemContext) {
	localctx = NewRowConstructorItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, DorisParserRULE_rowConstructorItem)
	p.SetState(3933)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_PAREN, DorisParserLEFT_BRACKET, DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADD, DorisParserADDDATE, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserARRAY_RANGE, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBINARY, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCASE, DorisParserCAST, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATABASE, DorisParserDATE, DorisParserDATE_ADD, DorisParserDATE_CEIL, DorisParserDATE_DIFF, DorisParserDATE_FLOOR, DorisParserDATE_SUB, DorisParserDATEADD, DorisParserDATEDIFF, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS_ADD, DorisParserDAYS_SUB, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXISTS, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserEXTRACT, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFALSE, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIF, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINTERVAL, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserKEY, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLEFT, DorisParserLESS, DorisParserLEVEL, DorisParserLIKE, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNOT, DorisParserNULL, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLACEHOLDER, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREGEXP, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRIGHT, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSEQUENCE, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUBDATE, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTIMESTAMPADD, DorisParserTIMESTAMPDIFF, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRIM, DorisParserTRUE, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserPLUS, DorisParserSUBTRACT, DorisParserASTERISK, DorisParserTILDE, DorisParserLOGICALNOT, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserATSIGN, DorisParserDOUBLEATSIGN, DorisParserSTRING_LITERAL, DorisParserINTEGER_VALUE, DorisParserEXPONENT_VALUE, DorisParserDECIMAL_VALUE, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3931)
			p.NamedExpression()
		}

	case DorisParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3932)
			p.Match(DorisParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKind returns the kind token.
	GetKind() antlr.Token

	// SetKind sets the kind token.
	SetKind(antlr.Token)

	// GetLower returns the lower rule contexts.
	GetLower() IValueExpressionContext

	// GetUpper returns the upper rule contexts.
	GetUpper() IValueExpressionContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IValueExpressionContext

	// SetLower sets the lower rule contexts.
	SetLower(IValueExpressionContext)

	// SetUpper sets the upper rule contexts.
	SetUpper(IValueExpressionContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IValueExpressionContext)

	// Getter signatures
	AND() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	AllValueExpression() []IValueExpressionContext
	ValueExpression(i int) IValueExpressionContext
	NOT() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	REGEXP() antlr.TerminalNode
	RLIKE() antlr.TerminalNode
	MATCH() antlr.TerminalNode
	MATCH_ANY() antlr.TerminalNode
	MATCH_ALL() antlr.TerminalNode
	MATCH_PHRASE() antlr.TerminalNode
	MATCH_PHRASE_PREFIX() antlr.TerminalNode
	MATCH_REGEXP() antlr.TerminalNode
	MATCH_PHRASE_EDGE() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	Query() IQueryContext
	RIGHT_PAREN() antlr.TerminalNode
	IN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	IS() antlr.TerminalNode
	NULL() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	kind    antlr.Token
	lower   IValueExpressionContext
	upper   IValueExpressionContext
	pattern IValueExpressionContext
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_predicate
	return p
}

func InitEmptyPredicateContext(p *PredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_predicate
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) GetKind() antlr.Token { return s.kind }

func (s *PredicateContext) SetKind(v antlr.Token) { s.kind = v }

func (s *PredicateContext) GetLower() IValueExpressionContext { return s.lower }

func (s *PredicateContext) GetUpper() IValueExpressionContext { return s.upper }

func (s *PredicateContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *PredicateContext) SetLower(v IValueExpressionContext) { s.lower = v }

func (s *PredicateContext) SetUpper(v IValueExpressionContext) { s.upper = v }

func (s *PredicateContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *PredicateContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisParserAND, 0)
}

func (s *PredicateContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(DorisParserBETWEEN, 0)
}

func (s *PredicateContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PredicateContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *PredicateContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *PredicateContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(DorisParserREGEXP, 0)
}

func (s *PredicateContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserRLIKE, 0)
}

func (s *PredicateContext) MATCH() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH, 0)
}

func (s *PredicateContext) MATCH_ANY() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_ANY, 0)
}

func (s *PredicateContext) MATCH_ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_ALL, 0)
}

func (s *PredicateContext) MATCH_PHRASE() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_PHRASE, 0)
}

func (s *PredicateContext) MATCH_PHRASE_PREFIX() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_PHRASE_PREFIX, 0)
}

func (s *PredicateContext) MATCH_REGEXP() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_REGEXP, 0)
}

func (s *PredicateContext) MATCH_PHRASE_EDGE() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_PHRASE_EDGE, 0)
}

func (s *PredicateContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *PredicateContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *PredicateContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *PredicateContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *PredicateContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PredicateContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PredicateContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *PredicateContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *PredicateContext) IS() antlr.TerminalNode {
	return s.GetToken(DorisParserIS, 0)
}

func (s *PredicateContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisParserNULL, 0)
}

func (s *PredicateContext) TRUE() antlr.TerminalNode {
	return s.GetToken(DorisParserTRUE, 0)
}

func (s *PredicateContext) FALSE() antlr.TerminalNode {
	return s.GetToken(DorisParserFALSE, 0)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPredicate(s)
	}
}

func (s *PredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPredicate(s)
	}
}

func (p *DorisParser) Predicate() (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, DorisParserRULE_predicate)
	var _la int

	p.SetState(3986)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 561, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3936)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(3935)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3938)

			var _m = p.Match(DorisParserBETWEEN)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3939)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).lower = _x
		}
		{
			p.SetState(3940)
			p.Match(DorisParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3941)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).upper = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3944)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(3943)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3946)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PredicateContext).kind = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserLIKE || _la == DorisParserREGEXP || _la == DorisParserRLIKE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PredicateContext).kind = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3947)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).pattern = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(3949)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(3948)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3951)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PredicateContext).kind = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-277)) & ^0x3f) == 0 && ((int64(1)<<(_la-277))&127) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PredicateContext).kind = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3952)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).pattern = _x
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(3954)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(3953)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3956)

			var _m = p.Match(DorisParserIN)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3957)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3958)
			p.Query()
		}
		{
			p.SetState(3959)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(3962)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(3961)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3964)

			var _m = p.Match(DorisParserIN)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3965)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3966)
			p.Expression()
		}
		p.SetState(3971)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(3967)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3968)
				p.Expression()
			}

			p.SetState(3973)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3974)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3976)
			p.Match(DorisParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3978)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(3977)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3980)

			var _m = p.Match(DorisParserNULL)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3981)
			p.Match(DorisParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3983)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(3982)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3985)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PredicateContext).kind = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserFALSE || _la == DorisParserTRUE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PredicateContext).kind = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueExpressionContext is an interface to support dynamic dispatch.
type IValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsValueExpressionContext differentiates from other interfaces.
	IsValueExpressionContext()
}

type ValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExpressionContext() *ValueExpressionContext {
	var p = new(ValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_valueExpression
	return p
}

func InitEmptyValueExpressionContext(p *ValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_valueExpression
}

func (*ValueExpressionContext) IsValueExpressionContext() {}

func NewValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExpressionContext {
	var p = new(ValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_valueExpression

	return p
}

func (s *ValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExpressionContext) CopyAll(ctx *ValueExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ValueExpressionDefaultContext struct {
	ValueExpressionContext
}

func NewValueExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValueExpressionDefaultContext {
	var p = new(ValueExpressionDefaultContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ValueExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionDefaultContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ValueExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitValueExpressionDefault(s)
	}
}

type ComparisonContext struct {
	ValueExpressionContext
	left  IValueExpressionContext
	right IValueExpressionContext
}

func NewComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonContext {
	var p = new(ComparisonContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ComparisonContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ComparisonContext) GetRight() IValueExpressionContext { return s.right }

func (s *ComparisonContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ComparisonContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitComparison(s)
	}
}

type BitOperationContext struct {
	ValueExpressionContext
	operator antlr.Token
	left     IValueExpressionContext
	right    IValueExpressionContext
}

func NewBitOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitOperationContext {
	var p = new(BitOperationContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *BitOperationContext) GetOperator() antlr.Token { return s.operator }

func (s *BitOperationContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *BitOperationContext) GetLeft() IValueExpressionContext { return s.left }

func (s *BitOperationContext) GetRight() IValueExpressionContext { return s.right }

func (s *BitOperationContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *BitOperationContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *BitOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitOperationContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *BitOperationContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, 0)
}

func (s *BitOperationContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *BitOperationContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitOperationContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *BitOperationContext) BITAND() antlr.TerminalNode {
	return s.GetToken(DorisParserBITAND, 0)
}

func (s *BitOperationContext) BITOR() antlr.TerminalNode {
	return s.GetToken(DorisParserBITOR, 0)
}

func (s *BitOperationContext) BITXOR() antlr.TerminalNode {
	return s.GetToken(DorisParserBITXOR, 0)
}

func (s *BitOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBitOperation(s)
	}
}

func (s *BitOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBitOperation(s)
	}
}

type ArithmeticBinaryContext struct {
	ValueExpressionContext
	left     IValueExpressionContext
	operator antlr.Token
	right    IValueExpressionContext
}

func NewArithmeticBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticBinaryContext {
	var p = new(ArithmeticBinaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticBinaryContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ArithmeticBinaryContext) GetRight() IValueExpressionContext { return s.right }

func (s *ArithmeticBinaryContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ArithmeticBinaryContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ArithmeticBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticBinaryContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArithmeticBinaryContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticBinaryContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserASTERISK, 0)
}

func (s *ArithmeticBinaryContext) SLASH() antlr.TerminalNode {
	return s.GetToken(DorisParserSLASH, 0)
}

func (s *ArithmeticBinaryContext) MOD() antlr.TerminalNode {
	return s.GetToken(DorisParserMOD, 0)
}

func (s *ArithmeticBinaryContext) DIV() antlr.TerminalNode {
	return s.GetToken(DorisParserDIV, 0)
}

func (s *ArithmeticBinaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(DorisParserPLUS, 0)
}

func (s *ArithmeticBinaryContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(DorisParserSUBTRACT, 0)
}

func (s *ArithmeticBinaryContext) HAT() antlr.TerminalNode {
	return s.GetToken(DorisParserHAT, 0)
}

func (s *ArithmeticBinaryContext) PIPE() antlr.TerminalNode {
	return s.GetToken(DorisParserPIPE, 0)
}

func (s *ArithmeticBinaryContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(DorisParserAMPERSAND, 0)
}

func (s *ArithmeticBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitArithmeticBinary(s)
	}
}

type ArithmeticUnaryContext struct {
	ValueExpressionContext
	operator antlr.Token
}

func NewArithmeticUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticUnaryContext {
	var p = new(ArithmeticUnaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticUnaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticUnaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticUnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticUnaryContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticUnaryContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(DorisParserSUBTRACT, 0)
}

func (s *ArithmeticUnaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(DorisParserPLUS, 0)
}

func (s *ArithmeticUnaryContext) TILDE() antlr.TerminalNode {
	return s.GetToken(DorisParserTILDE, 0)
}

func (s *ArithmeticUnaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitArithmeticUnary(s)
	}
}

func (p *DorisParser) ValueExpression() (localctx IValueExpressionContext) {
	return p.valueExpression(0)
}

func (p *DorisParser) valueExpression(_p int) (localctx IValueExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewValueExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 316
	p.EnterRecursionRule(localctx, 316, DorisParserRULE_valueExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3999)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 562, p.GetParserRuleContext()) {
	case 1:
		localctx = NewValueExpressionDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(3989)
			p.primaryExpression(0)
		}

	case 2:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3990)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ArithmeticUnaryContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-508)) & ^0x3f) == 0 && ((int64(1)<<(_la-508))&35) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ArithmeticUnaryContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3991)
			p.valueExpression(5)
		}

	case 3:
		localctx = NewBitOperationContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3992)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*BitOperationContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3518437208883200) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*BitOperationContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3993)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3994)

			var _x = p.valueExpression(0)

			localctx.(*BitOperationContext).left = _x
		}
		{
			p.SetState(3995)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3996)

			var _x = p.valueExpression(0)

			localctx.(*BitOperationContext).right = _x
		}
		{
			p.SetState(3997)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(4013)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 564, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(4011)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 563, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_valueExpression)
				p.SetState(4001)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(4002)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisParserDIV || ((int64((_la-510)) & ^0x3f) == 0 && ((int64(1)<<(_la-510))&7) != 0)) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(4003)

					var _x = p.valueExpression(5)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 2:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_valueExpression)
				p.SetState(4004)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(4005)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-508)) & ^0x3f) == 0 && ((int64(1)<<(_la-508))&2627) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(4006)

					var _x = p.valueExpression(4)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 3:
				localctx = NewComparisonContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ComparisonContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_valueExpression)
				p.SetState(4007)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(4008)
					p.ComparisonOperator()
				}
				{
					p.SetState(4009)

					var _x = p.valueExpression(3)

					localctx.(*ComparisonContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(4015)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 564, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatetimeUnitContext is an interface to support dynamic dispatch.
type IDatetimeUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YEAR() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	SECOND() antlr.TerminalNode

	// IsDatetimeUnitContext differentiates from other interfaces.
	IsDatetimeUnitContext()
}

type DatetimeUnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatetimeUnitContext() *DatetimeUnitContext {
	var p = new(DatetimeUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_datetimeUnit
	return p
}

func InitEmptyDatetimeUnitContext(p *DatetimeUnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_datetimeUnit
}

func (*DatetimeUnitContext) IsDatetimeUnitContext() {}

func NewDatetimeUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatetimeUnitContext {
	var p = new(DatetimeUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_datetimeUnit

	return p
}

func (s *DatetimeUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *DatetimeUnitContext) YEAR() antlr.TerminalNode {
	return s.GetToken(DorisParserYEAR, 0)
}

func (s *DatetimeUnitContext) MONTH() antlr.TerminalNode {
	return s.GetToken(DorisParserMONTH, 0)
}

func (s *DatetimeUnitContext) WEEK() antlr.TerminalNode {
	return s.GetToken(DorisParserWEEK, 0)
}

func (s *DatetimeUnitContext) DAY() antlr.TerminalNode {
	return s.GetToken(DorisParserDAY, 0)
}

func (s *DatetimeUnitContext) HOUR() antlr.TerminalNode {
	return s.GetToken(DorisParserHOUR, 0)
}

func (s *DatetimeUnitContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(DorisParserMINUTE, 0)
}

func (s *DatetimeUnitContext) SECOND() antlr.TerminalNode {
	return s.GetToken(DorisParserSECOND, 0)
}

func (s *DatetimeUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatetimeUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatetimeUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDatetimeUnit(s)
	}
}

func (s *DatetimeUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDatetimeUnit(s)
	}
}

func (p *DorisParser) DatetimeUnit() (localctx IDatetimeUnitContext) {
	localctx = NewDatetimeUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, DorisParserRULE_datetimeUnit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4016)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserDAY || _la == DorisParserHOUR || _la == DorisParserMINUTE || _la == DorisParserMONTH || _la == DorisParserSECOND || _la == DorisParserWEEK || _la == DorisParserYEAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_primaryExpression
	return p
}

func InitEmptyPrimaryExpressionContext(p *PrimaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_primaryExpression
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) CopyAll(ctx *PrimaryExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DateCeilContext struct {
	PrimaryExpressionContext
	name        antlr.Token
	timestamp   IValueExpressionContext
	unitsAmount IValueExpressionContext
	unit        IDatetimeUnitContext
}

func NewDateCeilContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DateCeilContext {
	var p = new(DateCeilContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DateCeilContext) GetName() antlr.Token { return s.name }

func (s *DateCeilContext) SetName(v antlr.Token) { s.name = v }

func (s *DateCeilContext) GetTimestamp() IValueExpressionContext { return s.timestamp }

func (s *DateCeilContext) GetUnitsAmount() IValueExpressionContext { return s.unitsAmount }

func (s *DateCeilContext) GetUnit() IDatetimeUnitContext { return s.unit }

func (s *DateCeilContext) SetTimestamp(v IValueExpressionContext) { s.timestamp = v }

func (s *DateCeilContext) SetUnitsAmount(v IValueExpressionContext) { s.unitsAmount = v }

func (s *DateCeilContext) SetUnit(v IDatetimeUnitContext) { s.unit = v }

func (s *DateCeilContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateCeilContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *DateCeilContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, 0)
}

func (s *DateCeilContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *DateCeilContext) DATE_CEIL() antlr.TerminalNode {
	return s.GetToken(DorisParserDATE_CEIL, 0)
}

func (s *DateCeilContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *DateCeilContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *DateCeilContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DorisParserINTERVAL, 0)
}

func (s *DateCeilContext) DatetimeUnit() IDatetimeUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeUnitContext)
}

func (s *DateCeilContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDateCeil(s)
	}
}

func (s *DateCeilContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDateCeil(s)
	}
}

type DereferenceContext struct {
	PrimaryExpressionContext
	base      IPrimaryExpressionContext
	fieldName IIdentifierContext
}

func NewDereferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DereferenceContext {
	var p = new(DereferenceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DereferenceContext) GetBase() IPrimaryExpressionContext { return s.base }

func (s *DereferenceContext) GetFieldName() IIdentifierContext { return s.fieldName }

func (s *DereferenceContext) SetBase(v IPrimaryExpressionContext) { s.base = v }

func (s *DereferenceContext) SetFieldName(v IIdentifierContext) { s.fieldName = v }

func (s *DereferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DereferenceContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *DereferenceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *DereferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DereferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDereference(s)
	}
}

func (s *DereferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDereference(s)
	}
}

type CurrentDateContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentDateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentDateContext {
	var p = new(CurrentDateContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentDateContext) GetName() antlr.Token { return s.name }

func (s *CurrentDateContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentDateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentDateContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_DATE, 0)
}

func (s *CurrentDateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCurrentDate(s)
	}
}

func (s *CurrentDateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCurrentDate(s)
	}
}

type TimestampaddContext struct {
	PrimaryExpressionContext
	name           antlr.Token
	unit           IDatetimeUnitContext
	startTimestamp IValueExpressionContext
	endTimestamp   IValueExpressionContext
}

func NewTimestampaddContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimestampaddContext {
	var p = new(TimestampaddContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *TimestampaddContext) GetName() antlr.Token { return s.name }

func (s *TimestampaddContext) SetName(v antlr.Token) { s.name = v }

func (s *TimestampaddContext) GetUnit() IDatetimeUnitContext { return s.unit }

func (s *TimestampaddContext) GetStartTimestamp() IValueExpressionContext { return s.startTimestamp }

func (s *TimestampaddContext) GetEndTimestamp() IValueExpressionContext { return s.endTimestamp }

func (s *TimestampaddContext) SetUnit(v IDatetimeUnitContext) { s.unit = v }

func (s *TimestampaddContext) SetStartTimestamp(v IValueExpressionContext) { s.startTimestamp = v }

func (s *TimestampaddContext) SetEndTimestamp(v IValueExpressionContext) { s.endTimestamp = v }

func (s *TimestampaddContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimestampaddContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *TimestampaddContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *TimestampaddContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *TimestampaddContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *TimestampaddContext) DatetimeUnit() IDatetimeUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeUnitContext)
}

func (s *TimestampaddContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TimestampaddContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *TimestampaddContext) TIMESTAMPADD() antlr.TerminalNode {
	return s.GetToken(DorisParserTIMESTAMPADD, 0)
}

func (s *TimestampaddContext) DATEADD() antlr.TerminalNode {
	return s.GetToken(DorisParserDATEADD, 0)
}

func (s *TimestampaddContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTimestampadd(s)
	}
}

func (s *TimestampaddContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTimestampadd(s)
	}
}

type Date_subContext struct {
	PrimaryExpressionContext
	name        antlr.Token
	timestamp   IValueExpressionContext
	unitsAmount IValueExpressionContext
	unit        IDatetimeUnitContext
}

func NewDate_subContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Date_subContext {
	var p = new(Date_subContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *Date_subContext) GetName() antlr.Token { return s.name }

func (s *Date_subContext) SetName(v antlr.Token) { s.name = v }

func (s *Date_subContext) GetTimestamp() IValueExpressionContext { return s.timestamp }

func (s *Date_subContext) GetUnitsAmount() IValueExpressionContext { return s.unitsAmount }

func (s *Date_subContext) GetUnit() IDatetimeUnitContext { return s.unit }

func (s *Date_subContext) SetTimestamp(v IValueExpressionContext) { s.timestamp = v }

func (s *Date_subContext) SetUnitsAmount(v IValueExpressionContext) { s.unitsAmount = v }

func (s *Date_subContext) SetUnit(v IDatetimeUnitContext) { s.unit = v }

func (s *Date_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Date_subContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *Date_subContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, 0)
}

func (s *Date_subContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *Date_subContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Date_subContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *Date_subContext) SUBDATE() antlr.TerminalNode {
	return s.GetToken(DorisParserSUBDATE, 0)
}

func (s *Date_subContext) DAYS_SUB() antlr.TerminalNode {
	return s.GetToken(DorisParserDAYS_SUB, 0)
}

func (s *Date_subContext) DATE_SUB() antlr.TerminalNode {
	return s.GetToken(DorisParserDATE_SUB, 0)
}

func (s *Date_subContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DorisParserINTERVAL, 0)
}

func (s *Date_subContext) DatetimeUnit() IDatetimeUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeUnitContext)
}

func (s *Date_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDate_sub(s)
	}
}

func (s *Date_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDate_sub(s)
	}
}

type CastContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastContext {
	var p = new(CastContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CastContext) GetName() antlr.Token { return s.name }

func (s *CastContext) SetName(v antlr.Token) { s.name = v }

func (s *CastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CastContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *CastContext) CastDataType() ICastDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastDataTypeContext)
}

func (s *CastContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CastContext) CAST() antlr.TerminalNode {
	return s.GetToken(DorisParserCAST, 0)
}

func (s *CastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCast(s)
	}
}

func (s *CastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCast(s)
	}
}

type ParenthesizedExpressionContext struct {
	PrimaryExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

type UserVariableContext struct {
	PrimaryExpressionContext
}

func NewUserVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserVariableContext {
	var p = new(UserVariableContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *UserVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserVariableContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserATSIGN, 0)
}

func (s *UserVariableContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *UserVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUserVariable(s)
	}
}

func (s *UserVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUserVariable(s)
	}
}

type ElementAtContext struct {
	PrimaryExpressionContext
	value IPrimaryExpressionContext
	index IValueExpressionContext
}

func NewElementAtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ElementAtContext {
	var p = new(ElementAtContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ElementAtContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *ElementAtContext) GetIndex() IValueExpressionContext { return s.index }

func (s *ElementAtContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *ElementAtContext) SetIndex(v IValueExpressionContext) { s.index = v }

func (s *ElementAtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementAtContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACKET, 0)
}

func (s *ElementAtContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACKET, 0)
}

func (s *ElementAtContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ElementAtContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ElementAtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterElementAt(s)
	}
}

func (s *ElementAtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitElementAt(s)
	}
}

type LocalTimestampContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewLocalTimestampContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LocalTimestampContext {
	var p = new(LocalTimestampContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LocalTimestampContext) GetName() antlr.Token { return s.name }

func (s *LocalTimestampContext) SetName(v antlr.Token) { s.name = v }

func (s *LocalTimestampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalTimestampContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCALTIMESTAMP, 0)
}

func (s *LocalTimestampContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLocalTimestamp(s)
	}
}

func (s *LocalTimestampContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLocalTimestamp(s)
	}
}

type CharFunctionContext struct {
	PrimaryExpressionContext
	_expression IExpressionContext
	arguments   []IExpressionContext
	charSet     IIdentifierOrTextContext
}

func NewCharFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CharFunctionContext {
	var p = new(CharFunctionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CharFunctionContext) Get_expression() IExpressionContext { return s._expression }

func (s *CharFunctionContext) GetCharSet() IIdentifierOrTextContext { return s.charSet }

func (s *CharFunctionContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *CharFunctionContext) SetCharSet(v IIdentifierOrTextContext) { s.charSet = v }

func (s *CharFunctionContext) GetArguments() []IExpressionContext { return s.arguments }

func (s *CharFunctionContext) SetArguments(v []IExpressionContext) { s.arguments = v }

func (s *CharFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharFunctionContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserCHAR, 0)
}

func (s *CharFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CharFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CharFunctionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CharFunctionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CharFunctionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *CharFunctionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *CharFunctionContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserUSING, 0)
}

func (s *CharFunctionContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CharFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCharFunction(s)
	}
}

func (s *CharFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCharFunction(s)
	}
}

type IntervalLiteralContext struct {
	PrimaryExpressionContext
}

func NewIntervalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalLiteralContext {
	var p = new(IntervalLiteralContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *IntervalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalLiteralContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *IntervalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIntervalLiteral(s)
	}
}

func (s *IntervalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIntervalLiteral(s)
	}
}

type ArrayRangeContext struct {
	PrimaryExpressionContext
	name        antlr.Token
	start_      IValueExpressionContext
	end         IValueExpressionContext
	unitsAmount IValueExpressionContext
	unit        IDatetimeUnitContext
}

func NewArrayRangeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayRangeContext {
	var p = new(ArrayRangeContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArrayRangeContext) GetName() antlr.Token { return s.name }

func (s *ArrayRangeContext) SetName(v antlr.Token) { s.name = v }

func (s *ArrayRangeContext) GetStart_() IValueExpressionContext { return s.start_ }

func (s *ArrayRangeContext) GetEnd() IValueExpressionContext { return s.end }

func (s *ArrayRangeContext) GetUnitsAmount() IValueExpressionContext { return s.unitsAmount }

func (s *ArrayRangeContext) GetUnit() IDatetimeUnitContext { return s.unit }

func (s *ArrayRangeContext) SetStart_(v IValueExpressionContext) { s.start_ = v }

func (s *ArrayRangeContext) SetEnd(v IValueExpressionContext) { s.end = v }

func (s *ArrayRangeContext) SetUnitsAmount(v IValueExpressionContext) { s.unitsAmount = v }

func (s *ArrayRangeContext) SetUnit(v IDatetimeUnitContext) { s.unit = v }

func (s *ArrayRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayRangeContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ArrayRangeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ArrayRangeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ArrayRangeContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ArrayRangeContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArrayRangeContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArrayRangeContext) ARRAY_RANGE() antlr.TerminalNode {
	return s.GetToken(DorisParserARRAY_RANGE, 0)
}

func (s *ArrayRangeContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(DorisParserSEQUENCE, 0)
}

func (s *ArrayRangeContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DorisParserINTERVAL, 0)
}

func (s *ArrayRangeContext) DatetimeUnit() IDatetimeUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeUnitContext)
}

func (s *ArrayRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterArrayRange(s)
	}
}

func (s *ArrayRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitArrayRange(s)
	}
}

type SimpleCaseContext struct {
	PrimaryExpressionContext
	value          IExpressionContext
	elseExpression IExpressionContext
}

func NewSimpleCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleCaseContext {
	var p = new(SimpleCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SimpleCaseContext) GetValue() IExpressionContext { return s.value }

func (s *SimpleCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SimpleCaseContext) SetValue(v IExpressionContext) { s.value = v }

func (s *SimpleCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SimpleCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(DorisParserCASE, 0)
}

func (s *SimpleCaseContext) END() antlr.TerminalNode {
	return s.GetToken(DorisParserEND, 0)
}

func (s *SimpleCaseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SimpleCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(DorisParserELSE, 0)
}

func (s *SimpleCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSimpleCase(s)
	}
}

func (s *SimpleCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSimpleCase(s)
	}
}

type ColumnReferenceContext struct {
	PrimaryExpressionContext
}

func NewColumnReferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnReferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnReferenceContext) BINARY() antlr.TerminalNode {
	return s.GetToken(DorisParserBINARY, 0)
}

func (s *ColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterColumnReference(s)
	}
}

func (s *ColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitColumnReference(s)
	}
}

type StarContext struct {
	PrimaryExpressionContext
}

func NewStarContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StarContext {
	var p = new(StarContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *StarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StarContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserASTERISK, 0)
}

func (s *StarContext) AllExceptOrReplace() []IExceptOrReplaceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExceptOrReplaceContext); ok {
			len++
		}
	}

	tst := make([]IExceptOrReplaceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExceptOrReplaceContext); ok {
			tst[i] = t.(IExceptOrReplaceContext)
			i++
		}
	}

	return tst
}

func (s *StarContext) ExceptOrReplace(i int) IExceptOrReplaceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExceptOrReplaceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExceptOrReplaceContext)
}

func (s *StarContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *StarContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *StarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStar(s)
	}
}

func (s *StarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStar(s)
	}
}

type ConvertTypeContext struct {
	PrimaryExpressionContext
	argument IExpressionContext
}

func NewConvertTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConvertTypeContext {
	var p = new(ConvertTypeContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ConvertTypeContext) GetArgument() IExpressionContext { return s.argument }

func (s *ConvertTypeContext) SetArgument(v IExpressionContext) { s.argument = v }

func (s *ConvertTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertTypeContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(DorisParserCONVERT, 0)
}

func (s *ConvertTypeContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ConvertTypeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, 0)
}

func (s *ConvertTypeContext) CastDataType() ICastDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastDataTypeContext)
}

func (s *ConvertTypeContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ConvertTypeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConvertTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterConvertType(s)
	}
}

func (s *ConvertTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitConvertType(s)
	}
}

type TimestampdiffContext struct {
	PrimaryExpressionContext
	name           antlr.Token
	unit           IDatetimeUnitContext
	startTimestamp IValueExpressionContext
	endTimestamp   IValueExpressionContext
}

func NewTimestampdiffContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimestampdiffContext {
	var p = new(TimestampdiffContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *TimestampdiffContext) GetName() antlr.Token { return s.name }

func (s *TimestampdiffContext) SetName(v antlr.Token) { s.name = v }

func (s *TimestampdiffContext) GetUnit() IDatetimeUnitContext { return s.unit }

func (s *TimestampdiffContext) GetStartTimestamp() IValueExpressionContext { return s.startTimestamp }

func (s *TimestampdiffContext) GetEndTimestamp() IValueExpressionContext { return s.endTimestamp }

func (s *TimestampdiffContext) SetUnit(v IDatetimeUnitContext) { s.unit = v }

func (s *TimestampdiffContext) SetStartTimestamp(v IValueExpressionContext) { s.startTimestamp = v }

func (s *TimestampdiffContext) SetEndTimestamp(v IValueExpressionContext) { s.endTimestamp = v }

func (s *TimestampdiffContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimestampdiffContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *TimestampdiffContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *TimestampdiffContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *TimestampdiffContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *TimestampdiffContext) DatetimeUnit() IDatetimeUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeUnitContext)
}

func (s *TimestampdiffContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TimestampdiffContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *TimestampdiffContext) TIMESTAMPDIFF() antlr.TerminalNode {
	return s.GetToken(DorisParserTIMESTAMPDIFF, 0)
}

func (s *TimestampdiffContext) DATEDIFF() antlr.TerminalNode {
	return s.GetToken(DorisParserDATEDIFF, 0)
}

func (s *TimestampdiffContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTimestampdiff(s)
	}
}

func (s *TimestampdiffContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTimestampdiff(s)
	}
}

type ConvertCharSetContext struct {
	PrimaryExpressionContext
	argument IExpressionContext
	charSet  IIdentifierOrTextContext
}

func NewConvertCharSetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConvertCharSetContext {
	var p = new(ConvertCharSetContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ConvertCharSetContext) GetArgument() IExpressionContext { return s.argument }

func (s *ConvertCharSetContext) GetCharSet() IIdentifierOrTextContext { return s.charSet }

func (s *ConvertCharSetContext) SetArgument(v IExpressionContext) { s.argument = v }

func (s *ConvertCharSetContext) SetCharSet(v IIdentifierOrTextContext) { s.charSet = v }

func (s *ConvertCharSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertCharSetContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(DorisParserCONVERT, 0)
}

func (s *ConvertCharSetContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ConvertCharSetContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserUSING, 0)
}

func (s *ConvertCharSetContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ConvertCharSetContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConvertCharSetContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *ConvertCharSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterConvertCharSet(s)
	}
}

func (s *ConvertCharSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitConvertCharSet(s)
	}
}

type SubqueryExpressionContext struct {
	PrimaryExpressionContext
}

func NewSubqueryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryExpressionContext {
	var p = new(SubqueryExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubqueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *SubqueryExpressionContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *SubqueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSubqueryExpression(s)
	}
}

func (s *SubqueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSubqueryExpression(s)
	}
}

type EncryptKeyContext struct {
	PrimaryExpressionContext
	dbName  IIdentifierContext
	keyName IIdentifierContext
}

func NewEncryptKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EncryptKeyContext {
	var p = new(EncryptKeyContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *EncryptKeyContext) GetDbName() IIdentifierContext { return s.dbName }

func (s *EncryptKeyContext) GetKeyName() IIdentifierContext { return s.keyName }

func (s *EncryptKeyContext) SetDbName(v IIdentifierContext) { s.dbName = v }

func (s *EncryptKeyContext) SetKeyName(v IIdentifierContext) { s.keyName = v }

func (s *EncryptKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EncryptKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserKEY, 0)
}

func (s *EncryptKeyContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *EncryptKeyContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EncryptKeyContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *EncryptKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterEncryptKey(s)
	}
}

func (s *EncryptKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitEncryptKey(s)
	}
}

type Date_addContext struct {
	PrimaryExpressionContext
	name        antlr.Token
	timestamp   IValueExpressionContext
	unitsAmount IValueExpressionContext
	unit        IDatetimeUnitContext
}

func NewDate_addContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Date_addContext {
	var p = new(Date_addContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *Date_addContext) GetName() antlr.Token { return s.name }

func (s *Date_addContext) SetName(v antlr.Token) { s.name = v }

func (s *Date_addContext) GetTimestamp() IValueExpressionContext { return s.timestamp }

func (s *Date_addContext) GetUnitsAmount() IValueExpressionContext { return s.unitsAmount }

func (s *Date_addContext) GetUnit() IDatetimeUnitContext { return s.unit }

func (s *Date_addContext) SetTimestamp(v IValueExpressionContext) { s.timestamp = v }

func (s *Date_addContext) SetUnitsAmount(v IValueExpressionContext) { s.unitsAmount = v }

func (s *Date_addContext) SetUnit(v IDatetimeUnitContext) { s.unit = v }

func (s *Date_addContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Date_addContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *Date_addContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, 0)
}

func (s *Date_addContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *Date_addContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Date_addContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *Date_addContext) ADDDATE() antlr.TerminalNode {
	return s.GetToken(DorisParserADDDATE, 0)
}

func (s *Date_addContext) DAYS_ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserDAYS_ADD, 0)
}

func (s *Date_addContext) DATE_ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserDATE_ADD, 0)
}

func (s *Date_addContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DorisParserINTERVAL, 0)
}

func (s *Date_addContext) DatetimeUnit() IDatetimeUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeUnitContext)
}

func (s *Date_addContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDate_add(s)
	}
}

func (s *Date_addContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDate_add(s)
	}
}

type CurrentTimeContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentTimeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentTimeContext {
	var p = new(CurrentTimeContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentTimeContext) GetName() antlr.Token { return s.name }

func (s *CurrentTimeContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentTimeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentTimeContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_TIME, 0)
}

func (s *CurrentTimeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCurrentTime(s)
	}
}

func (s *CurrentTimeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCurrentTime(s)
	}
}

type LocalTimeContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewLocalTimeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LocalTimeContext {
	var p = new(LocalTimeContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LocalTimeContext) GetName() antlr.Token { return s.name }

func (s *LocalTimeContext) SetName(v antlr.Token) { s.name = v }

func (s *LocalTimeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalTimeContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCALTIME, 0)
}

func (s *LocalTimeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLocalTime(s)
	}
}

func (s *LocalTimeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLocalTime(s)
	}
}

type SystemVariableContext struct {
	PrimaryExpressionContext
	kind antlr.Token
}

func NewSystemVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SystemVariableContext {
	var p = new(SystemVariableContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SystemVariableContext) GetKind() antlr.Token { return s.kind }

func (s *SystemVariableContext) SetKind(v antlr.Token) { s.kind = v }

func (s *SystemVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SystemVariableContext) DOUBLEATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserDOUBLEATSIGN, 0)
}

func (s *SystemVariableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SystemVariableContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *SystemVariableContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *SystemVariableContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION, 0)
}

func (s *SystemVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSystemVariable(s)
	}
}

func (s *SystemVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSystemVariable(s)
	}
}

type CollateContext struct {
	PrimaryExpressionContext
}

func NewCollateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollateContext {
	var p = new(CollateContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *CollateContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLLATE, 0)
}

func (s *CollateContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CollateContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CollateContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *CollateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCollate(s)
	}
}

func (s *CollateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCollate(s)
	}
}

type CurrentUserContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentUserContext {
	var p = new(CurrentUserContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentUserContext) GetName() antlr.Token { return s.name }

func (s *CurrentUserContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentUserContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_USER, 0)
}

func (s *CurrentUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCurrentUser(s)
	}
}

func (s *CurrentUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCurrentUser(s)
	}
}

type ConstantDefaultContext struct {
	PrimaryExpressionContext
}

func NewConstantDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstantDefaultContext {
	var p = new(ConstantDefaultContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ConstantDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantDefaultContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterConstantDefault(s)
	}
}

func (s *ConstantDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitConstantDefault(s)
	}
}

type ExtractContext struct {
	PrimaryExpressionContext
	field  IIdentifierContext
	source IValueExpressionContext
}

func NewExtractContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExtractContext {
	var p = new(ExtractContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ExtractContext) GetField() IIdentifierContext { return s.field }

func (s *ExtractContext) GetSource() IValueExpressionContext { return s.source }

func (s *ExtractContext) SetField(v IIdentifierContext) { s.field = v }

func (s *ExtractContext) SetSource(v IValueExpressionContext) { s.source = v }

func (s *ExtractContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(DorisParserEXTRACT, 0)
}

func (s *ExtractContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ExtractContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ExtractContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ExtractContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExtractContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ExtractContext) DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATE, 0)
}

func (s *ExtractContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserTIMESTAMP, 0)
}

func (s *ExtractContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterExtract(s)
	}
}

func (s *ExtractContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitExtract(s)
	}
}

type CurrentTimestampContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentTimestampContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentTimestampContext {
	var p = new(CurrentTimestampContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentTimestampContext) GetName() antlr.Token { return s.name }

func (s *CurrentTimestampContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentTimestampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentTimestampContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_TIMESTAMP, 0)
}

func (s *CurrentTimestampContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCurrentTimestamp(s)
	}
}

func (s *CurrentTimestampContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCurrentTimestamp(s)
	}
}

type FunctionCallContext struct {
	PrimaryExpressionContext
}

func NewFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallContext {
	var p = new(FunctionCallContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) FunctionCallExpression() IFunctionCallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallExpressionContext)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

type ArraySliceContext struct {
	PrimaryExpressionContext
	value IPrimaryExpressionContext
	begin IValueExpressionContext
	end   IValueExpressionContext
}

func NewArraySliceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArraySliceContext {
	var p = new(ArraySliceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArraySliceContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *ArraySliceContext) GetBegin() IValueExpressionContext { return s.begin }

func (s *ArraySliceContext) GetEnd() IValueExpressionContext { return s.end }

func (s *ArraySliceContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *ArraySliceContext) SetBegin(v IValueExpressionContext) { s.begin = v }

func (s *ArraySliceContext) SetEnd(v IValueExpressionContext) { s.end = v }

func (s *ArraySliceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArraySliceContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACKET, 0)
}

func (s *ArraySliceContext) COLON() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLON, 0)
}

func (s *ArraySliceContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACKET, 0)
}

func (s *ArraySliceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ArraySliceContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArraySliceContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArraySliceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterArraySlice(s)
	}
}

func (s *ArraySliceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitArraySlice(s)
	}
}

type DateFloorContext struct {
	PrimaryExpressionContext
	name        antlr.Token
	timestamp   IValueExpressionContext
	unitsAmount IValueExpressionContext
	unit        IDatetimeUnitContext
}

func NewDateFloorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DateFloorContext {
	var p = new(DateFloorContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DateFloorContext) GetName() antlr.Token { return s.name }

func (s *DateFloorContext) SetName(v antlr.Token) { s.name = v }

func (s *DateFloorContext) GetTimestamp() IValueExpressionContext { return s.timestamp }

func (s *DateFloorContext) GetUnitsAmount() IValueExpressionContext { return s.unitsAmount }

func (s *DateFloorContext) GetUnit() IDatetimeUnitContext { return s.unit }

func (s *DateFloorContext) SetTimestamp(v IValueExpressionContext) { s.timestamp = v }

func (s *DateFloorContext) SetUnitsAmount(v IValueExpressionContext) { s.unitsAmount = v }

func (s *DateFloorContext) SetUnit(v IDatetimeUnitContext) { s.unit = v }

func (s *DateFloorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateFloorContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *DateFloorContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, 0)
}

func (s *DateFloorContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *DateFloorContext) DATE_FLOOR() antlr.TerminalNode {
	return s.GetToken(DorisParserDATE_FLOOR, 0)
}

func (s *DateFloorContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *DateFloorContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *DateFloorContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DorisParserINTERVAL, 0)
}

func (s *DateFloorContext) DatetimeUnit() IDatetimeUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeUnitContext)
}

func (s *DateFloorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDateFloor(s)
	}
}

func (s *DateFloorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDateFloor(s)
	}
}

type SearchedCaseContext struct {
	PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSearchedCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SearchedCaseContext {
	var p = new(SearchedCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SearchedCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SearchedCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SearchedCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(DorisParserCASE, 0)
}

func (s *SearchedCaseContext) END() antlr.TerminalNode {
	return s.GetToken(DorisParserEND, 0)
}

func (s *SearchedCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SearchedCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SearchedCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(DorisParserELSE, 0)
}

func (s *SearchedCaseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SearchedCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSearchedCase(s)
	}
}

func (s *SearchedCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSearchedCase(s)
	}
}

func (p *DorisParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	return p.primaryExpression(0)
}

func (p *DorisParser) primaryExpression(_p int) (localctx IPrimaryExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 320
	p.EnterRecursionRule(localctx, 320, DorisParserRULE_primaryExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4228)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 582, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTimestampdiffContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(4019)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TimestampdiffContext).name = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserDATEDIFF || _la == DorisParserTIMESTAMPDIFF) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TimestampdiffContext).name = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4020)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4021)

			var _x = p.DatetimeUnit()

			localctx.(*TimestampdiffContext).unit = _x
		}
		{
			p.SetState(4022)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4023)

			var _x = p.valueExpression(0)

			localctx.(*TimestampdiffContext).startTimestamp = _x
		}
		{
			p.SetState(4024)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4025)

			var _x = p.valueExpression(0)

			localctx.(*TimestampdiffContext).endTimestamp = _x
		}
		{
			p.SetState(4026)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewTimestampaddContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4028)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TimestampaddContext).name = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserDATEADD || _la == DorisParserTIMESTAMPADD) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TimestampaddContext).name = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4029)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4030)

			var _x = p.DatetimeUnit()

			localctx.(*TimestampaddContext).unit = _x
		}
		{
			p.SetState(4031)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4032)

			var _x = p.valueExpression(0)

			localctx.(*TimestampaddContext).startTimestamp = _x
		}
		{
			p.SetState(4033)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4034)

			var _x = p.valueExpression(0)

			localctx.(*TimestampaddContext).endTimestamp = _x
		}
		{
			p.SetState(4035)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewDate_addContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4037)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Date_addContext).name = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserADDDATE || _la == DorisParserDATE_ADD || _la == DorisParserDAYS_ADD) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Date_addContext).name = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4038)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4039)

			var _x = p.valueExpression(0)

			localctx.(*Date_addContext).timestamp = _x
		}
		{
			p.SetState(4040)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4046)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 565, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4041)
				p.Match(DorisParserINTERVAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4042)

				var _x = p.valueExpression(0)

				localctx.(*Date_addContext).unitsAmount = _x
			}
			{
				p.SetState(4043)

				var _x = p.DatetimeUnit()

				localctx.(*Date_addContext).unit = _x
			}

		case 2:
			{
				p.SetState(4045)

				var _x = p.valueExpression(0)

				localctx.(*Date_addContext).unitsAmount = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(4048)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewDate_subContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4050)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Date_subContext).name = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserDATE_SUB || _la == DorisParserDAYS_SUB || _la == DorisParserSUBDATE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Date_subContext).name = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4051)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4052)

			var _x = p.valueExpression(0)

			localctx.(*Date_subContext).timestamp = _x
		}
		{
			p.SetState(4053)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4059)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 566, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4054)
				p.Match(DorisParserINTERVAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4055)

				var _x = p.valueExpression(0)

				localctx.(*Date_subContext).unitsAmount = _x
			}
			{
				p.SetState(4056)

				var _x = p.DatetimeUnit()

				localctx.(*Date_subContext).unit = _x
			}

		case 2:
			{
				p.SetState(4058)

				var _x = p.valueExpression(0)

				localctx.(*Date_subContext).unitsAmount = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(4061)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewDateFloorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4063)

			var _m = p.Match(DorisParserDATE_FLOOR)

			localctx.(*DateFloorContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4064)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4065)

			var _x = p.valueExpression(0)

			localctx.(*DateFloorContext).timestamp = _x
		}
		{
			p.SetState(4066)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4072)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 567, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4067)
				p.Match(DorisParserINTERVAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4068)

				var _x = p.valueExpression(0)

				localctx.(*DateFloorContext).unitsAmount = _x
			}
			{
				p.SetState(4069)

				var _x = p.DatetimeUnit()

				localctx.(*DateFloorContext).unit = _x
			}

		case 2:
			{
				p.SetState(4071)

				var _x = p.valueExpression(0)

				localctx.(*DateFloorContext).unitsAmount = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(4074)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewDateCeilContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4076)

			var _m = p.Match(DorisParserDATE_CEIL)

			localctx.(*DateCeilContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4077)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4078)

			var _x = p.valueExpression(0)

			localctx.(*DateCeilContext).timestamp = _x
		}
		{
			p.SetState(4079)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4085)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 568, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4080)
				p.Match(DorisParserINTERVAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4081)

				var _x = p.valueExpression(0)

				localctx.(*DateCeilContext).unitsAmount = _x
			}
			{
				p.SetState(4082)

				var _x = p.DatetimeUnit()

				localctx.(*DateCeilContext).unit = _x
			}

		case 2:
			{
				p.SetState(4084)

				var _x = p.valueExpression(0)

				localctx.(*DateCeilContext).unitsAmount = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(4087)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewArrayRangeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4089)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ArrayRangeContext).name = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserARRAY_RANGE || _la == DorisParserSEQUENCE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ArrayRangeContext).name = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4090)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4091)

			var _x = p.valueExpression(0)

			localctx.(*ArrayRangeContext).start_ = _x
		}
		{
			p.SetState(4092)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4093)

			var _x = p.valueExpression(0)

			localctx.(*ArrayRangeContext).end = _x
		}
		{
			p.SetState(4094)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4100)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 569, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4095)
				p.Match(DorisParserINTERVAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4096)

				var _x = p.valueExpression(0)

				localctx.(*ArrayRangeContext).unitsAmount = _x
			}
			{
				p.SetState(4097)

				var _x = p.DatetimeUnit()

				localctx.(*ArrayRangeContext).unit = _x
			}

		case 2:
			{
				p.SetState(4099)

				var _x = p.valueExpression(0)

				localctx.(*ArrayRangeContext).unitsAmount = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(4102)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewCurrentDateContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4104)

			var _m = p.Match(DorisParserCURRENT_DATE)

			localctx.(*CurrentDateContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewCurrentTimeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4105)

			var _m = p.Match(DorisParserCURRENT_TIME)

			localctx.(*CurrentTimeContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewCurrentTimestampContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4106)

			var _m = p.Match(DorisParserCURRENT_TIMESTAMP)

			localctx.(*CurrentTimestampContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewLocalTimeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4107)

			var _m = p.Match(DorisParserLOCALTIME)

			localctx.(*LocalTimeContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewLocalTimestampContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4108)

			var _m = p.Match(DorisParserLOCALTIMESTAMP)

			localctx.(*LocalTimestampContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		localctx = NewCurrentUserContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4109)

			var _m = p.Match(DorisParserCURRENT_USER)

			localctx.(*CurrentUserContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		localctx = NewSearchedCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4110)
			p.Match(DorisParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4112)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == DorisParserWHEN {
			{
				p.SetState(4111)
				p.WhenClause()
			}

			p.SetState(4114)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(4118)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserELSE {
			{
				p.SetState(4116)
				p.Match(DorisParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4117)

				var _x = p.Expression()

				localctx.(*SearchedCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(4120)
			p.Match(DorisParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		localctx = NewSimpleCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4122)
			p.Match(DorisParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4123)

			var _x = p.Expression()

			localctx.(*SimpleCaseContext).value = _x
		}
		p.SetState(4125)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == DorisParserWHEN {
			{
				p.SetState(4124)
				p.WhenClause()
			}

			p.SetState(4127)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(4131)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserELSE {
			{
				p.SetState(4129)
				p.Match(DorisParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4130)

				var _x = p.Expression()

				localctx.(*SimpleCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(4133)
			p.Match(DorisParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4135)

			var _m = p.Match(DorisParserCAST)

			localctx.(*CastContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4136)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4137)
			p.Expression()
		}
		{
			p.SetState(4138)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4139)
			p.CastDataType()
		}
		{
			p.SetState(4140)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		localctx = NewConstantDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4142)
			p.Constant()
		}

	case 18:
		localctx = NewIntervalLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4143)
			p.Interval()
		}

	case 19:
		localctx = NewStarContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4144)
			p.Match(DorisParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4148)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 574, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(4145)
					p.ExceptOrReplace()
				}

			}
			p.SetState(4150)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 574, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 20:
		localctx = NewStarContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4151)
			p.QualifiedName()
		}
		{
			p.SetState(4152)
			p.Match(DorisParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4153)
			p.Match(DorisParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4157)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 575, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(4154)
					p.ExceptOrReplace()
				}

			}
			p.SetState(4159)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 575, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 21:
		localctx = NewCharFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4160)
			p.Match(DorisParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4161)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4162)

			var _x = p.Expression()

			localctx.(*CharFunctionContext)._expression = _x
		}
		localctx.(*CharFunctionContext).arguments = append(localctx.(*CharFunctionContext).arguments, localctx.(*CharFunctionContext)._expression)
		p.SetState(4167)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(4163)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4164)

				var _x = p.Expression()

				localctx.(*CharFunctionContext)._expression = _x
			}
			localctx.(*CharFunctionContext).arguments = append(localctx.(*CharFunctionContext).arguments, localctx.(*CharFunctionContext)._expression)

			p.SetState(4169)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(4172)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserUSING {
			{
				p.SetState(4170)
				p.Match(DorisParserUSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4171)

				var _x = p.IdentifierOrText()

				localctx.(*CharFunctionContext).charSet = _x
			}

		}
		{
			p.SetState(4174)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 22:
		localctx = NewConvertCharSetContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4176)
			p.Match(DorisParserCONVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4177)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4178)

			var _x = p.Expression()

			localctx.(*ConvertCharSetContext).argument = _x
		}
		{
			p.SetState(4179)
			p.Match(DorisParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4180)

			var _x = p.IdentifierOrText()

			localctx.(*ConvertCharSetContext).charSet = _x
		}
		{
			p.SetState(4181)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		localctx = NewConvertTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4183)
			p.Match(DorisParserCONVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4184)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4185)

			var _x = p.Expression()

			localctx.(*ConvertTypeContext).argument = _x
		}
		{
			p.SetState(4186)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4187)
			p.CastDataType()
		}
		{
			p.SetState(4188)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4190)
			p.FunctionCallExpression()
		}

	case 25:
		localctx = NewSubqueryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4191)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4192)
			p.Query()
		}
		{
			p.SetState(4193)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 26:
		localctx = NewUserVariableContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4195)
			p.Match(DorisParserATSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4196)
			p.IdentifierOrText()
		}

	case 27:
		localctx = NewSystemVariableContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4197)
			p.Match(DorisParserDOUBLEATSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4200)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 578, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4198)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*SystemVariableContext).kind = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserGLOBAL || _la == DorisParserSESSION) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*SystemVariableContext).kind = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(4199)
				p.Match(DorisParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4202)
			p.Identifier()
		}

	case 28:
		localctx = NewColumnReferenceContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(4204)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserBINARY {
			{
				p.SetState(4203)
				p.Match(DorisParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4206)
			p.Identifier()
		}

	case 29:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4207)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4208)
			p.Expression()
		}
		{
			p.SetState(4209)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 30:
		localctx = NewEncryptKeyContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4211)
			p.Match(DorisParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4215)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 580, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4212)

				var _x = p.Identifier()

				localctx.(*EncryptKeyContext).dbName = _x
			}
			{
				p.SetState(4213)
				p.Match(DorisParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4217)

			var _x = p.Identifier()

			localctx.(*EncryptKeyContext).keyName = _x
		}

	case 31:
		localctx = NewExtractContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(4218)
			p.Match(DorisParserEXTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4219)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4220)

			var _x = p.Identifier()

			localctx.(*ExtractContext).field = _x
		}
		{
			p.SetState(4221)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4223)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 581, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4222)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserDATE || _la == DorisParserTIMESTAMP) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4225)

			var _x = p.valueExpression(0)

			localctx.(*ExtractContext).source = _x
		}
		{
			p.SetState(4226)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(4256)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 586, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(4254)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 585, p.GetParserRuleContext()) {
			case 1:
				localctx = NewElementAtContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*ElementAtContext).value = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_primaryExpression)
				p.SetState(4230)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
					goto errorExit
				}
				{
					p.SetState(4231)
					p.Match(DorisParserLEFT_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4232)

					var _x = p.valueExpression(0)

					localctx.(*ElementAtContext).index = _x
				}
				{
					p.SetState(4233)
					p.Match(DorisParserRIGHT_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				localctx = NewArraySliceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArraySliceContext).value = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_primaryExpression)
				p.SetState(4235)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
					goto errorExit
				}
				{
					p.SetState(4236)
					p.Match(DorisParserLEFT_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4237)

					var _x = p.valueExpression(0)

					localctx.(*ArraySliceContext).begin = _x
				}
				{
					p.SetState(4238)
					p.Match(DorisParserCOLON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(4240)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1153005225580239228) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-141717009369345) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-4539693587724737369) != 0) || ((int64((_la-195)) & ^0x3f) == 0 && ((int64(1)<<(_la-195))&-3103018623212733835) != 0) || ((int64((_la-259)) & ^0x3f) == 0 && ((int64(1)<<(_la-259))&-9089531793664934289) != 0) || ((int64((_la-323)) & ^0x3f) == 0 && ((int64(1)<<(_la-323))&-2310857813124972547) != 0) || ((int64((_la-387)) & ^0x3f) == 0 && ((int64(1)<<(_la-387))&-5255560032135782599) != 0) || ((int64((_la-451)) & ^0x3f) == 0 && ((int64(1)<<(_la-451))&5621092667580571559) != 0) || ((int64((_la-522)) & ^0x3f) == 0 && ((int64(1)<<(_la-522))&56383) != 0) {
					{
						p.SetState(4239)

						var _x = p.valueExpression(0)

						localctx.(*ArraySliceContext).end = _x
					}

				}
				{
					p.SetState(4242)
					p.Match(DorisParserRIGHT_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 3:
				localctx = NewDereferenceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*DereferenceContext).base = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_primaryExpression)
				p.SetState(4244)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(4245)
					p.Match(DorisParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4246)

					var _x = p.Identifier()

					localctx.(*DereferenceContext).fieldName = _x
				}

			case 4:
				localctx = NewCollateContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_primaryExpression)
				p.SetState(4247)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(4248)
					p.Match(DorisParserCOLLATE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(4252)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADDDATE, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserARRAY_RANGE, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATE_ADD, DorisParserDATE_CEIL, DorisParserDATE_DIFF, DorisParserDATE_FLOOR, DorisParserDATE_SUB, DorisParserDATEADD, DorisParserDATEDIFF, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS_ADD, DorisParserDAYS_SUB, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSEQUENCE, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUBDATE, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTIMESTAMPADD, DorisParserTIMESTAMPDIFF, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
					{
						p.SetState(4249)
						p.Identifier()
					}

				case DorisParserSTRING_LITERAL:
					{
						p.SetState(4250)
						p.Match(DorisParserSTRING_LITERAL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case DorisParserDEFAULT:
					{
						p.SetState(4251)
						p.Match(DorisParserDEFAULT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(4258)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 586, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExceptOrReplaceContext is an interface to support dynamic dispatch.
type IExceptOrReplaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExceptOrReplaceContext differentiates from other interfaces.
	IsExceptOrReplaceContext()
}

type ExceptOrReplaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExceptOrReplaceContext() *ExceptOrReplaceContext {
	var p = new(ExceptOrReplaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_exceptOrReplace
	return p
}

func InitEmptyExceptOrReplaceContext(p *ExceptOrReplaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_exceptOrReplace
}

func (*ExceptOrReplaceContext) IsExceptOrReplaceContext() {}

func NewExceptOrReplaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptOrReplaceContext {
	var p = new(ExceptOrReplaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_exceptOrReplace

	return p
}

func (s *ExceptOrReplaceContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptOrReplaceContext) CopyAll(ctx *ExceptOrReplaceContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExceptOrReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptOrReplaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ReplaceContext struct {
	ExceptOrReplaceContext
}

func NewReplaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReplaceContext {
	var p = new(ReplaceContext)

	InitEmptyExceptOrReplaceContext(&p.ExceptOrReplaceContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExceptOrReplaceContext))

	return p
}

func (s *ReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplaceContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *ReplaceContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ReplaceContext) NamedExpressionSeq() INamedExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionSeqContext)
}

func (s *ReplaceContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ReplaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterReplace(s)
	}
}

func (s *ReplaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitReplace(s)
	}
}

type ExceptContext struct {
	ExceptOrReplaceContext
}

func NewExceptContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExceptContext {
	var p = new(ExceptContext)

	InitEmptyExceptOrReplaceContext(&p.ExceptOrReplaceContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExceptOrReplaceContext))

	return p
}

func (s *ExceptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(DorisParserEXCEPT, 0)
}

func (s *ExceptContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ExceptContext) NamedExpressionSeq() INamedExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionSeqContext)
}

func (s *ExceptContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ExceptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterExcept(s)
	}
}

func (s *ExceptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitExcept(s)
	}
}

func (p *DorisParser) ExceptOrReplace() (localctx IExceptOrReplaceContext) {
	localctx = NewExceptOrReplaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, DorisParserRULE_exceptOrReplace)
	p.SetState(4269)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserEXCEPT:
		localctx = NewExceptContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4259)
			p.Match(DorisParserEXCEPT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4260)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4261)
			p.NamedExpressionSeq()
		}
		{
			p.SetState(4262)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserREPLACE:
		localctx = NewReplaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4264)
			p.Match(DorisParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4265)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4266)
			p.NamedExpressionSeq()
		}
		{
			p.SetState(4267)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastDataTypeContext is an interface to support dynamic dispatch.
type ICastDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DataType() IDataTypeContext
	SIGNED() antlr.TerminalNode
	UNSIGNED() antlr.TerminalNode
	INT() antlr.TerminalNode
	INTEGER() antlr.TerminalNode

	// IsCastDataTypeContext differentiates from other interfaces.
	IsCastDataTypeContext()
}

type CastDataTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastDataTypeContext() *CastDataTypeContext {
	var p = new(CastDataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_castDataType
	return p
}

func InitEmptyCastDataTypeContext(p *CastDataTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_castDataType
}

func (*CastDataTypeContext) IsCastDataTypeContext() {}

func NewCastDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastDataTypeContext {
	var p = new(CastDataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_castDataType

	return p
}

func (s *CastDataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CastDataTypeContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CastDataTypeContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(DorisParserSIGNED, 0)
}

func (s *CastDataTypeContext) UNSIGNED() antlr.TerminalNode {
	return s.GetToken(DorisParserUNSIGNED, 0)
}

func (s *CastDataTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(DorisParserINT, 0)
}

func (s *CastDataTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER, 0)
}

func (s *CastDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastDataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCastDataType(s)
	}
}

func (s *CastDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCastDataType(s)
	}
}

func (p *DorisParser) CastDataType() (localctx ICastDataTypeContext) {
	localctx = NewCastDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, DorisParserRULE_castDataType)
	var _la int

	p.SetState(4276)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserAGG_STATE, DorisParserALL, DorisParserARRAY, DorisParserBIGINT, DorisParserBITMAP, DorisParserBOOLEAN, DorisParserCHAR, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDOUBLE, DorisParserFLOAT, DorisParserHLL, DorisParserINT, DorisParserINTEGER, DorisParserIPV4, DorisParserIPV6, DorisParserJSON, DorisParserJSONB, DorisParserLARGEINT, DorisParserMAP, DorisParserQUANTILE_STATE, DorisParserSMALLINT, DorisParserSTRING, DorisParserSTRUCT, DorisParserTEXT, DorisParserTIME, DorisParserTINYINT, DorisParserVARCHAR, DorisParserVARIANT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4271)
			p.DataType()
		}

	case DorisParserSIGNED, DorisParserUNSIGNED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4272)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserSIGNED || _la == DorisParserUNSIGNED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(4274)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserINT || _la == DorisParserINTEGER {
			{
				p.SetState(4273)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserINT || _la == DorisParserINTEGER) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallExpressionContext is an interface to support dynamic dispatch.
type IFunctionCallExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetArguments returns the arguments rule context list.
	GetArguments() []IExpressionContext

	// SetArguments sets the arguments rule context list.
	SetArguments([]IExpressionContext)

	// Getter signatures
	FunctionIdentifier() IFunctionIdentifierContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	OVER() antlr.TerminalNode
	WindowSpec() IWindowSpecContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	DISTINCT() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsFunctionCallExpressionContext differentiates from other interfaces.
	IsFunctionCallExpressionContext()
}

type FunctionCallExpressionContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	_expression IExpressionContext
	arguments   []IExpressionContext
}

func NewEmptyFunctionCallExpressionContext() *FunctionCallExpressionContext {
	var p = new(FunctionCallExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionCallExpression
	return p
}

func InitEmptyFunctionCallExpressionContext(p *FunctionCallExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionCallExpression
}

func (*FunctionCallExpressionContext) IsFunctionCallExpressionContext() {}

func NewFunctionCallExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallExpressionContext {
	var p = new(FunctionCallExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_functionCallExpression

	return p
}

func (s *FunctionCallExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallExpressionContext) Get_expression() IExpressionContext { return s._expression }

func (s *FunctionCallExpressionContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *FunctionCallExpressionContext) GetArguments() []IExpressionContext { return s.arguments }

func (s *FunctionCallExpressionContext) SetArguments(v []IExpressionContext) { s.arguments = v }

func (s *FunctionCallExpressionContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *FunctionCallExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *FunctionCallExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *FunctionCallExpressionContext) OVER() antlr.TerminalNode {
	return s.GetToken(DorisParserOVER, 0)
}

func (s *FunctionCallExpressionContext) WindowSpec() IWindowSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecContext)
}

func (s *FunctionCallExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *FunctionCallExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionCallExpressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *FunctionCallExpressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *FunctionCallExpressionContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisParserORDER, 0)
}

func (s *FunctionCallExpressionContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *FunctionCallExpressionContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *FunctionCallExpressionContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *FunctionCallExpressionContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTINCT, 0)
}

func (s *FunctionCallExpressionContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *FunctionCallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFunctionCallExpression(s)
	}
}

func (s *FunctionCallExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFunctionCallExpression(s)
	}
}

func (p *DorisParser) FunctionCallExpression() (localctx IFunctionCallExpressionContext) {
	localctx = NewFunctionCallExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, DorisParserRULE_functionCallExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4278)
		p.FunctionIdentifier()
	}
	{
		p.SetState(4279)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4303)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1153005225578142076) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-141717009369345) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-4539691388701477721) != 0) || ((int64((_la-195)) & ^0x3f) == 0 && ((int64(1)<<(_la-195))&-3103018623212733835) != 0) || ((int64((_la-259)) & ^0x3f) == 0 && ((int64(1)<<(_la-259))&-9089391056176578961) != 0) || ((int64((_la-323)) & ^0x3f) == 0 && ((int64(1)<<(_la-323))&-2310857813124972547) != 0) || ((int64((_la-387)) & ^0x3f) == 0 && ((int64(1)<<(_la-387))&-5255560032135782599) != 0) || ((int64((_la-451)) & ^0x3f) == 0 && ((int64(1)<<(_la-451))&5621092667580571559) != 0) || ((int64((_la-516)) & ^0x3f) == 0 && ((int64(1)<<(_la-516))&3608513) != 0) {
		p.SetState(4281)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserALL || _la == DorisParserDISTINCT {
			{
				p.SetState(4280)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserALL || _la == DorisParserDISTINCT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(4283)

			var _x = p.Expression()

			localctx.(*FunctionCallExpressionContext)._expression = _x
		}
		localctx.(*FunctionCallExpressionContext).arguments = append(localctx.(*FunctionCallExpressionContext).arguments, localctx.(*FunctionCallExpressionContext)._expression)
		p.SetState(4288)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(4284)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4285)

				var _x = p.Expression()

				localctx.(*FunctionCallExpressionContext)._expression = _x
			}
			localctx.(*FunctionCallExpressionContext).arguments = append(localctx.(*FunctionCallExpressionContext).arguments, localctx.(*FunctionCallExpressionContext)._expression)

			p.SetState(4290)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(4301)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserORDER {
			{
				p.SetState(4291)
				p.Match(DorisParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4292)
				p.Match(DorisParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4293)
				p.SortItem()
			}
			p.SetState(4298)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(4294)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4295)
					p.SortItem()
				}

				p.SetState(4300)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}

	}
	{
		p.SetState(4305)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4308)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 595, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4306)
			p.Match(DorisParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4307)
			p.WindowSpec()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionIdentifierContext is an interface to support dynamic dispatch.
type IFunctionIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDbName returns the dbName rule contexts.
	GetDbName() IIdentifierContext

	// SetDbName sets the dbName rule contexts.
	SetDbName(IIdentifierContext)

	// Getter signatures
	FunctionNameIdentifier() IFunctionNameIdentifierContext
	DOT() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsFunctionIdentifierContext differentiates from other interfaces.
	IsFunctionIdentifierContext()
}

type FunctionIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	dbName IIdentifierContext
}

func NewEmptyFunctionIdentifierContext() *FunctionIdentifierContext {
	var p = new(FunctionIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionIdentifier
	return p
}

func InitEmptyFunctionIdentifierContext(p *FunctionIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionIdentifier
}

func (*FunctionIdentifierContext) IsFunctionIdentifierContext() {}

func NewFunctionIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionIdentifierContext {
	var p = new(FunctionIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_functionIdentifier

	return p
}

func (s *FunctionIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionIdentifierContext) GetDbName() IIdentifierContext { return s.dbName }

func (s *FunctionIdentifierContext) SetDbName(v IIdentifierContext) { s.dbName = v }

func (s *FunctionIdentifierContext) FunctionNameIdentifier() IFunctionNameIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameIdentifierContext)
}

func (s *FunctionIdentifierContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *FunctionIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFunctionIdentifier(s)
	}
}

func (s *FunctionIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFunctionIdentifier(s)
	}
}

func (p *DorisParser) FunctionIdentifier() (localctx IFunctionIdentifierContext) {
	localctx = NewFunctionIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, DorisParserRULE_functionIdentifier)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4313)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 596, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4310)

			var _x = p.Identifier()

			localctx.(*FunctionIdentifierContext).dbName = _x
		}
		{
			p.SetState(4311)
			p.Match(DorisParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4315)
		p.FunctionNameIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionNameIdentifierContext is an interface to support dynamic dispatch.
type IFunctionNameIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ADD() antlr.TerminalNode
	CONNECTION_ID() antlr.TerminalNode
	CURRENT_CATALOG() antlr.TerminalNode
	CURRENT_USER() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	IF() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	REGEXP() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	TRIM() antlr.TerminalNode
	USER() antlr.TerminalNode

	// IsFunctionNameIdentifierContext differentiates from other interfaces.
	IsFunctionNameIdentifierContext()
}

type FunctionNameIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameIdentifierContext() *FunctionNameIdentifierContext {
	var p = new(FunctionNameIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionNameIdentifier
	return p
}

func InitEmptyFunctionNameIdentifierContext(p *FunctionNameIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionNameIdentifier
}

func (*FunctionNameIdentifierContext) IsFunctionNameIdentifierContext() {}

func NewFunctionNameIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameIdentifierContext {
	var p = new(FunctionNameIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_functionNameIdentifier

	return p
}

func (s *FunctionNameIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionNameIdentifierContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *FunctionNameIdentifierContext) CONNECTION_ID() antlr.TerminalNode {
	return s.GetToken(DorisParserCONNECTION_ID, 0)
}

func (s *FunctionNameIdentifierContext) CURRENT_CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_CATALOG, 0)
}

func (s *FunctionNameIdentifierContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_USER, 0)
}

func (s *FunctionNameIdentifierContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *FunctionNameIdentifierContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *FunctionNameIdentifierContext) LEFT() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT, 0)
}

func (s *FunctionNameIdentifierContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *FunctionNameIdentifierContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD, 0)
}

func (s *FunctionNameIdentifierContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(DorisParserREGEXP, 0)
}

func (s *FunctionNameIdentifierContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT, 0)
}

func (s *FunctionNameIdentifierContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEMA, 0)
}

func (s *FunctionNameIdentifierContext) TRIM() antlr.TerminalNode {
	return s.GetToken(DorisParserTRIM, 0)
}

func (s *FunctionNameIdentifierContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisParserUSER, 0)
}

func (s *FunctionNameIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFunctionNameIdentifier(s)
	}
}

func (s *FunctionNameIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFunctionNameIdentifier(s)
	}
}

func (p *DorisParser) FunctionNameIdentifier() (localctx IFunctionNameIdentifierContext) {
	localctx = NewFunctionNameIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, DorisParserRULE_functionNameIdentifier)
	p.SetState(4332)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 597, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4317)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4318)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4319)
			p.Match(DorisParserCONNECTION_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4320)
			p.Match(DorisParserCURRENT_CATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4321)
			p.Match(DorisParserCURRENT_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4322)
			p.Match(DorisParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4323)
			p.Match(DorisParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4324)
			p.Match(DorisParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4325)
			p.Match(DorisParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(4326)
			p.Match(DorisParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(4327)
			p.Match(DorisParserREGEXP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(4328)
			p.Match(DorisParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(4329)
			p.Match(DorisParserSCHEMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(4330)
			p.Match(DorisParserTRIM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(4331)
			p.Match(DorisParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowSpecContext is an interface to support dynamic dispatch.
type IWindowSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	PartitionClause() IPartitionClauseContext
	SortClause() ISortClauseContext
	WindowFrame() IWindowFrameContext

	// IsWindowSpecContext differentiates from other interfaces.
	IsWindowSpecContext()
}

type WindowSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowSpecContext() *WindowSpecContext {
	var p = new(WindowSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_windowSpec
	return p
}

func InitEmptyWindowSpecContext(p *WindowSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_windowSpec
}

func (*WindowSpecContext) IsWindowSpecContext() {}

func NewWindowSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowSpecContext {
	var p = new(WindowSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_windowSpec

	return p
}

func (s *WindowSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowSpecContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *WindowSpecContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *WindowSpecContext) PartitionClause() IPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *WindowSpecContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *WindowSpecContext) WindowFrame() IWindowFrameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameContext)
}

func (s *WindowSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWindowSpec(s)
	}
}

func (s *WindowSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWindowSpec(s)
	}
}

func (p *DorisParser) WindowSpec() (localctx IWindowSpecContext) {
	localctx = NewWindowSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, DorisParserRULE_windowSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4334)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4336)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPARTITION {
		{
			p.SetState(4335)
			p.PartitionClause()
		}

	}
	p.SetState(4339)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserORDER {
		{
			p.SetState(4338)
			p.SortClause()
		}

	}
	p.SetState(4342)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserRANGE || _la == DorisParserROWS {
		{
			p.SetState(4341)
			p.WindowFrame()
		}

	}
	{
		p.SetState(4344)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameContext is an interface to support dynamic dispatch.
type IWindowFrameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStart_ returns the start_ rule contexts.
	GetStart_() IFrameBoundaryContext

	// GetEnd returns the end rule contexts.
	GetEnd() IFrameBoundaryContext

	// SetStart_ sets the start_ rule contexts.
	SetStart_(IFrameBoundaryContext)

	// SetEnd sets the end rule contexts.
	SetEnd(IFrameBoundaryContext)

	// Getter signatures
	FrameUnits() IFrameUnitsContext
	AllFrameBoundary() []IFrameBoundaryContext
	FrameBoundary(i int) IFrameBoundaryContext
	BETWEEN() antlr.TerminalNode
	AND() antlr.TerminalNode

	// IsWindowFrameContext differentiates from other interfaces.
	IsWindowFrameContext()
}

type WindowFrameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	start_ IFrameBoundaryContext
	end    IFrameBoundaryContext
}

func NewEmptyWindowFrameContext() *WindowFrameContext {
	var p = new(WindowFrameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_windowFrame
	return p
}

func InitEmptyWindowFrameContext(p *WindowFrameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_windowFrame
}

func (*WindowFrameContext) IsWindowFrameContext() {}

func NewWindowFrameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameContext {
	var p = new(WindowFrameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_windowFrame

	return p
}

func (s *WindowFrameContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameContext) GetStart_() IFrameBoundaryContext { return s.start_ }

func (s *WindowFrameContext) GetEnd() IFrameBoundaryContext { return s.end }

func (s *WindowFrameContext) SetStart_(v IFrameBoundaryContext) { s.start_ = v }

func (s *WindowFrameContext) SetEnd(v IFrameBoundaryContext) { s.end = v }

func (s *WindowFrameContext) FrameUnits() IFrameUnitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameUnitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameUnitsContext)
}

func (s *WindowFrameContext) AllFrameBoundary() []IFrameBoundaryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrameBoundaryContext); ok {
			len++
		}
	}

	tst := make([]IFrameBoundaryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrameBoundaryContext); ok {
			tst[i] = t.(IFrameBoundaryContext)
			i++
		}
	}

	return tst
}

func (s *WindowFrameContext) FrameBoundary(i int) IFrameBoundaryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameBoundaryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameBoundaryContext)
}

func (s *WindowFrameContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(DorisParserBETWEEN, 0)
}

func (s *WindowFrameContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisParserAND, 0)
}

func (s *WindowFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWindowFrame(s)
	}
}

func (s *WindowFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWindowFrame(s)
	}
}

func (p *DorisParser) WindowFrame() (localctx IWindowFrameContext) {
	localctx = NewWindowFrameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, DorisParserRULE_windowFrame)
	p.SetState(4355)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 601, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4346)
			p.FrameUnits()
		}
		{
			p.SetState(4347)

			var _x = p.FrameBoundary()

			localctx.(*WindowFrameContext).start_ = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4349)
			p.FrameUnits()
		}
		{
			p.SetState(4350)
			p.Match(DorisParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4351)

			var _x = p.FrameBoundary()

			localctx.(*WindowFrameContext).start_ = _x
		}
		{
			p.SetState(4352)
			p.Match(DorisParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4353)

			var _x = p.FrameBoundary()

			localctx.(*WindowFrameContext).end = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameUnitsContext is an interface to support dynamic dispatch.
type IFrameUnitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROWS() antlr.TerminalNode
	RANGE() antlr.TerminalNode

	// IsFrameUnitsContext differentiates from other interfaces.
	IsFrameUnitsContext()
}

type FrameUnitsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameUnitsContext() *FrameUnitsContext {
	var p = new(FrameUnitsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_frameUnits
	return p
}

func InitEmptyFrameUnitsContext(p *FrameUnitsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_frameUnits
}

func (*FrameUnitsContext) IsFrameUnitsContext() {}

func NewFrameUnitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameUnitsContext {
	var p = new(FrameUnitsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_frameUnits

	return p
}

func (s *FrameUnitsContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameUnitsContext) ROWS() antlr.TerminalNode {
	return s.GetToken(DorisParserROWS, 0)
}

func (s *FrameUnitsContext) RANGE() antlr.TerminalNode {
	return s.GetToken(DorisParserRANGE, 0)
}

func (s *FrameUnitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameUnitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameUnitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFrameUnits(s)
	}
}

func (s *FrameUnitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFrameUnits(s)
	}
}

func (p *DorisParser) FrameUnits() (localctx IFrameUnitsContext) {
	localctx = NewFrameUnitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, DorisParserRULE_frameUnits)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4357)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserRANGE || _la == DorisParserROWS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameBoundaryContext is an interface to support dynamic dispatch.
type IFrameBoundaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBoundType returns the boundType token.
	GetBoundType() antlr.Token

	// SetBoundType sets the boundType token.
	SetBoundType(antlr.Token)

	// Getter signatures
	UNBOUNDED() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	ROW() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	Expression() IExpressionContext

	// IsFrameBoundaryContext differentiates from other interfaces.
	IsFrameBoundaryContext()
}

type FrameBoundaryContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	boundType antlr.Token
}

func NewEmptyFrameBoundaryContext() *FrameBoundaryContext {
	var p = new(FrameBoundaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_frameBoundary
	return p
}

func InitEmptyFrameBoundaryContext(p *FrameBoundaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_frameBoundary
}

func (*FrameBoundaryContext) IsFrameBoundaryContext() {}

func NewFrameBoundaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameBoundaryContext {
	var p = new(FrameBoundaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_frameBoundary

	return p
}

func (s *FrameBoundaryContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameBoundaryContext) GetBoundType() antlr.Token { return s.boundType }

func (s *FrameBoundaryContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *FrameBoundaryContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(DorisParserUNBOUNDED, 0)
}

func (s *FrameBoundaryContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(DorisParserPRECEDING, 0)
}

func (s *FrameBoundaryContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(DorisParserFOLLOWING, 0)
}

func (s *FrameBoundaryContext) ROW() antlr.TerminalNode {
	return s.GetToken(DorisParserROW, 0)
}

func (s *FrameBoundaryContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT, 0)
}

func (s *FrameBoundaryContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FrameBoundaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameBoundaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameBoundaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFrameBoundary(s)
	}
}

func (s *FrameBoundaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFrameBoundary(s)
	}
}

func (p *DorisParser) FrameBoundary() (localctx IFrameBoundaryContext) {
	localctx = NewFrameBoundaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, DorisParserRULE_frameBoundary)
	var _la int

	p.SetState(4366)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserUNBOUNDED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4359)
			p.Match(DorisParserUNBOUNDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4360)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FrameBoundaryContext).boundType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserFOLLOWING || _la == DorisParserPRECEDING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FrameBoundaryContext).boundType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case DorisParserCURRENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4361)

			var _m = p.Match(DorisParserCURRENT)

			localctx.(*FrameBoundaryContext).boundType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4362)
			p.Match(DorisParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserLEFT_PAREN, DorisParserLEFT_BRACKET, DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADD, DorisParserADDDATE, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserARRAY_RANGE, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBINARY, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCASE, DorisParserCAST, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATABASE, DorisParserDATE, DorisParserDATE_ADD, DorisParserDATE_CEIL, DorisParserDATE_DIFF, DorisParserDATE_FLOOR, DorisParserDATE_SUB, DorisParserDATEADD, DorisParserDATEDIFF, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS_ADD, DorisParserDAYS_SUB, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXISTS, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserEXTRACT, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFALSE, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIF, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINTERVAL, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserKEY, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLEFT, DorisParserLESS, DorisParserLEVEL, DorisParserLIKE, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNOT, DorisParserNULL, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLACEHOLDER, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREGEXP, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRIGHT, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSEQUENCE, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUBDATE, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTIMESTAMPADD, DorisParserTIMESTAMPDIFF, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRIM, DorisParserTRUE, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserPLUS, DorisParserSUBTRACT, DorisParserASTERISK, DorisParserTILDE, DorisParserLOGICALNOT, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserATSIGN, DorisParserDOUBLEATSIGN, DorisParserSTRING_LITERAL, DorisParserINTEGER_VALUE, DorisParserEXPONENT_VALUE, DorisParserDECIMAL_VALUE, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4363)
			p.Expression()
		}
		{
			p.SetState(4364)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FrameBoundaryContext).boundType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserFOLLOWING || _la == DorisParserPRECEDING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FrameBoundaryContext).boundType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_qualifiedName
	return p
}

func InitEmptyQualifiedNameContext(p *QualifiedNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_qualifiedName
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(DorisParserDOT)
}

func (s *QualifiedNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, i)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterQualifiedName(s)
	}
}

func (s *QualifiedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitQualifiedName(s)
	}
}

func (p *DorisParser) QualifiedName() (localctx IQualifiedNameContext) {
	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, DorisParserRULE_qualifiedName)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4368)
		p.Identifier()
	}
	p.SetState(4373)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 603, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4369)
				p.Match(DorisParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4370)
				p.Identifier()
			}

		}
		p.SetState(4375)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 603, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpecifiedPartitionContext is an interface to support dynamic dispatch.
type ISpecifiedPartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	IdentifierList() IIdentifierListContext
	TEMPORARY() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode

	// IsSpecifiedPartitionContext differentiates from other interfaces.
	IsSpecifiedPartitionContext()
}

type SpecifiedPartitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecifiedPartitionContext() *SpecifiedPartitionContext {
	var p = new(SpecifiedPartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_specifiedPartition
	return p
}

func InitEmptySpecifiedPartitionContext(p *SpecifiedPartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_specifiedPartition
}

func (*SpecifiedPartitionContext) IsSpecifiedPartitionContext() {}

func NewSpecifiedPartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecifiedPartitionContext {
	var p = new(SpecifiedPartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_specifiedPartition

	return p
}

func (s *SpecifiedPartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecifiedPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *SpecifiedPartitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SpecifiedPartitionContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *SpecifiedPartitionContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *SpecifiedPartitionContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITIONS, 0)
}

func (s *SpecifiedPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecifiedPartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecifiedPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSpecifiedPartition(s)
	}
}

func (s *SpecifiedPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSpecifiedPartition(s)
	}
}

func (p *DorisParser) SpecifiedPartition() (localctx ISpecifiedPartitionContext) {
	localctx = NewSpecifiedPartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, DorisParserRULE_specifiedPartition)
	var _la int

	p.SetState(4389)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 607, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4377)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(4376)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4379)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4382)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADDDATE, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserARRAY_RANGE, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATE_ADD, DorisParserDATE_CEIL, DorisParserDATE_DIFF, DorisParserDATE_FLOOR, DorisParserDATE_SUB, DorisParserDATEADD, DorisParserDATEDIFF, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS_ADD, DorisParserDAYS_SUB, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSEQUENCE, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUBDATE, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTIMESTAMPADD, DorisParserTIMESTAMPDIFF, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(4380)
				p.Identifier()
			}

		case DorisParserLEFT_PAREN:
			{
				p.SetState(4381)
				p.IdentifierList()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4385)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(4384)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4387)
			p.Match(DorisParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4388)
			p.IdentifierList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_constant
	return p
}

func InitEmptyConstantContext(p *ConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_constant
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) CopyAll(ctx *ConstantContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StructLiteralContext struct {
	ConstantContext
	_constant IConstantContext
	items     []IConstantContext
}

func NewStructLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StructLiteralContext {
	var p = new(StructLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *StructLiteralContext) Get_constant() IConstantContext { return s._constant }

func (s *StructLiteralContext) Set_constant(v IConstantContext) { s._constant = v }

func (s *StructLiteralContext) GetItems() []IConstantContext { return s.items }

func (s *StructLiteralContext) SetItems(v []IConstantContext) { s.items = v }

func (s *StructLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructLiteralContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACE, 0)
}

func (s *StructLiteralContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACE, 0)
}

func (s *StructLiteralContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *StructLiteralContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *StructLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *StructLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *StructLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStructLiteral(s)
	}
}

func (s *StructLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStructLiteral(s)
	}
}

type NullLiteralContext struct {
	ConstantContext
}

func NewNullLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralContext {
	var p = new(NullLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisParserNULL, 0)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

type StringLiteralContext struct {
	ConstantContext
}

func NewStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralContext {
	var p = new(StringLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *StringLiteralContext) BINARY() antlr.TerminalNode {
	return s.GetToken(DorisParserBINARY, 0)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

type TypeConstructorContext struct {
	ConstantContext
	type_ antlr.Token
}

func NewTypeConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeConstructorContext {
	var p = new(TypeConstructorContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *TypeConstructorContext) GetType_() antlr.Token { return s.type_ }

func (s *TypeConstructorContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *TypeConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConstructorContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *TypeConstructorContext) DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATE, 0)
}

func (s *TypeConstructorContext) DATEV1() antlr.TerminalNode {
	return s.GetToken(DorisParserDATEV1, 0)
}

func (s *TypeConstructorContext) DATEV2() antlr.TerminalNode {
	return s.GetToken(DorisParserDATEV2, 0)
}

func (s *TypeConstructorContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserTIMESTAMP, 0)
}

func (s *TypeConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTypeConstructor(s)
	}
}

func (s *TypeConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTypeConstructor(s)
	}
}

type ArrayLiteralContext struct {
	ConstantContext
	_constant IConstantContext
	items     []IConstantContext
}

func NewArrayLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *ArrayLiteralContext) Get_constant() IConstantContext { return s._constant }

func (s *ArrayLiteralContext) Set_constant(v IConstantContext) { s._constant = v }

func (s *ArrayLiteralContext) GetItems() []IConstantContext { return s.items }

func (s *ArrayLiteralContext) SetItems(v []IConstantContext) { s.items = v }

func (s *ArrayLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACKET, 0)
}

func (s *ArrayLiteralContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACKET, 0)
}

func (s *ArrayLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ArrayLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ArrayLiteralContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *ArrayLiteralContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ArrayLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitArrayLiteral(s)
	}
}

type PlaceholderContext struct {
	ConstantContext
}

func NewPlaceholderContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PlaceholderContext {
	var p = new(PlaceholderContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *PlaceholderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PlaceholderContext) PLACEHOLDER() antlr.TerminalNode {
	return s.GetToken(DorisParserPLACEHOLDER, 0)
}

func (s *PlaceholderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPlaceholder(s)
	}
}

func (s *PlaceholderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPlaceholder(s)
	}
}

type MapLiteralContext struct {
	ConstantContext
	_constant IConstantContext
	items     []IConstantContext
}

func NewMapLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MapLiteralContext {
	var p = new(MapLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *MapLiteralContext) Get_constant() IConstantContext { return s._constant }

func (s *MapLiteralContext) Set_constant(v IConstantContext) { s._constant = v }

func (s *MapLiteralContext) GetItems() []IConstantContext { return s.items }

func (s *MapLiteralContext) SetItems(v []IConstantContext) { s.items = v }

func (s *MapLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapLiteralContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACE, 0)
}

func (s *MapLiteralContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACE, 0)
}

func (s *MapLiteralContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOLON)
}

func (s *MapLiteralContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOLON, i)
}

func (s *MapLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *MapLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *MapLiteralContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *MapLiteralContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *MapLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMapLiteral(s)
	}
}

func (s *MapLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMapLiteral(s)
	}
}

type NumericLiteralContext struct {
	ConstantContext
}

func NewNumericLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

type BooleanLiteralContext struct {
	ConstantContext
}

func NewBooleanLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) BooleanValue() IBooleanValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (p *DorisParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, DorisParserRULE_constant)
	var _la int

	p.SetState(4442)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 614, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNullLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4391)
			p.Match(DorisParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewTypeConstructorContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4392)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TypeConstructorContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-113)) & ^0x3f) == 0 && ((int64(1)<<(_la-113))&5121) != 0) || _la == DorisParserTIMESTAMP) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TypeConstructorContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4393)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewNumericLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4394)
			p.Number()
		}

	case 4:
		localctx = NewBooleanLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4395)
			p.BooleanValue()
		}

	case 5:
		localctx = NewStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(4397)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserBINARY {
			{
				p.SetState(4396)
				p.Match(DorisParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4399)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewArrayLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4400)
			p.Match(DorisParserLEFT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4402)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&35184372089472) != 0) || ((int64((_la-113)) & ^0x3f) == 0 && ((int64(1)<<(_la-113))&5121) != 0) || _la == DorisParserFALSE || _la == DorisParserNULL || _la == DorisParserPLACEHOLDER || ((int64((_la-451)) & ^0x3f) == 0 && ((int64(1)<<(_la-451))&288230376151712769) != 0) || ((int64((_la-527)) & ^0x3f) == 0 && ((int64(1)<<(_la-527))&225) != 0) {
			{
				p.SetState(4401)

				var _x = p.Constant()

				localctx.(*ArrayLiteralContext)._constant = _x
			}
			localctx.(*ArrayLiteralContext).items = append(localctx.(*ArrayLiteralContext).items, localctx.(*ArrayLiteralContext)._constant)

		}
		p.SetState(4408)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(4404)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4405)

				var _x = p.Constant()

				localctx.(*ArrayLiteralContext)._constant = _x
			}
			localctx.(*ArrayLiteralContext).items = append(localctx.(*ArrayLiteralContext).items, localctx.(*ArrayLiteralContext)._constant)

			p.SetState(4410)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4411)
			p.Match(DorisParserRIGHT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewMapLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4412)
			p.Match(DorisParserLEFT_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4417)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&35184372089472) != 0) || ((int64((_la-113)) & ^0x3f) == 0 && ((int64(1)<<(_la-113))&5121) != 0) || _la == DorisParserFALSE || _la == DorisParserNULL || _la == DorisParserPLACEHOLDER || ((int64((_la-451)) & ^0x3f) == 0 && ((int64(1)<<(_la-451))&288230376151712769) != 0) || ((int64((_la-527)) & ^0x3f) == 0 && ((int64(1)<<(_la-527))&225) != 0) {
			{
				p.SetState(4413)

				var _x = p.Constant()

				localctx.(*MapLiteralContext)._constant = _x
			}
			localctx.(*MapLiteralContext).items = append(localctx.(*MapLiteralContext).items, localctx.(*MapLiteralContext)._constant)
			{
				p.SetState(4414)
				p.Match(DorisParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4415)

				var _x = p.Constant()

				localctx.(*MapLiteralContext)._constant = _x
			}
			localctx.(*MapLiteralContext).items = append(localctx.(*MapLiteralContext).items, localctx.(*MapLiteralContext)._constant)

		}
		p.SetState(4426)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(4419)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4420)

				var _x = p.Constant()

				localctx.(*MapLiteralContext)._constant = _x
			}
			localctx.(*MapLiteralContext).items = append(localctx.(*MapLiteralContext).items, localctx.(*MapLiteralContext)._constant)
			{
				p.SetState(4421)
				p.Match(DorisParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4422)

				var _x = p.Constant()

				localctx.(*MapLiteralContext)._constant = _x
			}
			localctx.(*MapLiteralContext).items = append(localctx.(*MapLiteralContext).items, localctx.(*MapLiteralContext)._constant)

			p.SetState(4428)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4429)
			p.Match(DorisParserRIGHT_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewStructLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4430)
			p.Match(DorisParserLEFT_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4431)

			var _x = p.Constant()

			localctx.(*StructLiteralContext)._constant = _x
		}
		localctx.(*StructLiteralContext).items = append(localctx.(*StructLiteralContext).items, localctx.(*StructLiteralContext)._constant)
		p.SetState(4436)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(4432)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4433)

				var _x = p.Constant()

				localctx.(*StructLiteralContext)._constant = _x
			}
			localctx.(*StructLiteralContext).items = append(localctx.(*StructLiteralContext).items, localctx.(*StructLiteralContext)._constant)

			p.SetState(4438)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4439)
			p.Match(DorisParserRIGHT_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewPlaceholderContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4441)
			p.Match(DorisParserPLACEHOLDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQ() antlr.TerminalNode
	NEQ() antlr.TerminalNode
	LT() antlr.TerminalNode
	LTE() antlr.TerminalNode
	GT() antlr.TerminalNode
	GTE() antlr.TerminalNode
	NSEQ() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_comparisonOperator
	return p
}

func InitEmptyComparisonOperatorContext(p *ComparisonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_comparisonOperator
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *ComparisonOperatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(DorisParserNEQ, 0)
}

func (s *ComparisonOperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(DorisParserLT, 0)
}

func (s *ComparisonOperatorContext) LTE() antlr.TerminalNode {
	return s.GetToken(DorisParserLTE, 0)
}

func (s *ComparisonOperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(DorisParserGT, 0)
}

func (s *ComparisonOperatorContext) GTE() antlr.TerminalNode {
	return s.GetToken(DorisParserGTE, 0)
}

func (s *ComparisonOperatorContext) NSEQ() antlr.TerminalNode {
	return s.GetToken(DorisParserNSEQ, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (p *DorisParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, DorisParserRULE_comparisonOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4444)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-501)) & ^0x3f) == 0 && ((int64(1)<<(_la-501))&127) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanValueContext is an interface to support dynamic dispatch.
type IBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBooleanValueContext differentiates from other interfaces.
	IsBooleanValueContext()
}

type BooleanValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueContext() *BooleanValueContext {
	var p = new(BooleanValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_booleanValue
	return p
}

func InitEmptyBooleanValueContext(p *BooleanValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_booleanValue
}

func (*BooleanValueContext) IsBooleanValueContext() {}

func NewBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueContext {
	var p = new(BooleanValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_booleanValue

	return p
}

func (s *BooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(DorisParserTRUE, 0)
}

func (s *BooleanValueContext) FALSE() antlr.TerminalNode {
	return s.GetToken(DorisParserFALSE, 0)
}

func (s *BooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBooleanValue(s)
	}
}

func (s *BooleanValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBooleanValue(s)
	}
}

func (p *DorisParser) BooleanValue() (localctx IBooleanValueContext) {
	localctx = NewBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, DorisParserRULE_booleanValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4446)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserFALSE || _la == DorisParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetResult returns the result rule contexts.
	GetResult() IExpressionContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetResult sets the result rule contexts.
	SetResult(IExpressionContext)

	// Getter signatures
	WHEN() antlr.TerminalNode
	THEN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExpressionContext
	result    IExpressionContext
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_whenClause
	return p
}

func InitEmptyWhenClauseContext(p *WhenClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_whenClause
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) GetCondition() IExpressionContext { return s.condition }

func (s *WhenClauseContext) GetResult() IExpressionContext { return s.result }

func (s *WhenClauseContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *WhenClauseContext) SetResult(v IExpressionContext) { s.result = v }

func (s *WhenClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(DorisParserWHEN, 0)
}

func (s *WhenClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(DorisParserTHEN, 0)
}

func (s *WhenClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WhenClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWhenClause(s)
	}
}

func (s *WhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWhenClause(s)
	}
}

func (p *DorisParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, DorisParserRULE_whenClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4448)
		p.Match(DorisParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4449)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).condition = _x
	}
	{
		p.SetState(4450)
		p.Match(DorisParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4451)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).result = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalContext is an interface to support dynamic dispatch.
type IIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value rule contexts.
	GetValue() IExpressionContext

	// GetUnit returns the unit rule contexts.
	GetUnit() IUnitIdentifierContext

	// SetValue sets the value rule contexts.
	SetValue(IExpressionContext)

	// SetUnit sets the unit rule contexts.
	SetUnit(IUnitIdentifierContext)

	// Getter signatures
	INTERVAL() antlr.TerminalNode
	Expression() IExpressionContext
	UnitIdentifier() IUnitIdentifierContext

	// IsIntervalContext differentiates from other interfaces.
	IsIntervalContext()
}

type IntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  IExpressionContext
	unit   IUnitIdentifierContext
}

func NewEmptyIntervalContext() *IntervalContext {
	var p = new(IntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_interval
	return p
}

func InitEmptyIntervalContext(p *IntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_interval
}

func (*IntervalContext) IsIntervalContext() {}

func NewIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalContext {
	var p = new(IntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_interval

	return p
}

func (s *IntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalContext) GetValue() IExpressionContext { return s.value }

func (s *IntervalContext) GetUnit() IUnitIdentifierContext { return s.unit }

func (s *IntervalContext) SetValue(v IExpressionContext) { s.value = v }

func (s *IntervalContext) SetUnit(v IUnitIdentifierContext) { s.unit = v }

func (s *IntervalContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DorisParserINTERVAL, 0)
}

func (s *IntervalContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalContext) UnitIdentifier() IUnitIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitIdentifierContext)
}

func (s *IntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterInterval(s)
	}
}

func (s *IntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitInterval(s)
	}
}

func (p *DorisParser) Interval() (localctx IIntervalContext) {
	localctx = NewIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, DorisParserRULE_interval)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4453)
		p.Match(DorisParserINTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4454)

		var _x = p.Expression()

		localctx.(*IntervalContext).value = _x
	}
	{
		p.SetState(4455)

		var _x = p.UnitIdentifier()

		localctx.(*IntervalContext).unit = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitIdentifierContext is an interface to support dynamic dispatch.
type IUnitIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YEAR() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	SECOND() antlr.TerminalNode

	// IsUnitIdentifierContext differentiates from other interfaces.
	IsUnitIdentifierContext()
}

type UnitIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitIdentifierContext() *UnitIdentifierContext {
	var p = new(UnitIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unitIdentifier
	return p
}

func InitEmptyUnitIdentifierContext(p *UnitIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unitIdentifier
}

func (*UnitIdentifierContext) IsUnitIdentifierContext() {}

func NewUnitIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitIdentifierContext {
	var p = new(UnitIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unitIdentifier

	return p
}

func (s *UnitIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitIdentifierContext) YEAR() antlr.TerminalNode {
	return s.GetToken(DorisParserYEAR, 0)
}

func (s *UnitIdentifierContext) MONTH() antlr.TerminalNode {
	return s.GetToken(DorisParserMONTH, 0)
}

func (s *UnitIdentifierContext) WEEK() antlr.TerminalNode {
	return s.GetToken(DorisParserWEEK, 0)
}

func (s *UnitIdentifierContext) DAY() antlr.TerminalNode {
	return s.GetToken(DorisParserDAY, 0)
}

func (s *UnitIdentifierContext) HOUR() antlr.TerminalNode {
	return s.GetToken(DorisParserHOUR, 0)
}

func (s *UnitIdentifierContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(DorisParserMINUTE, 0)
}

func (s *UnitIdentifierContext) SECOND() antlr.TerminalNode {
	return s.GetToken(DorisParserSECOND, 0)
}

func (s *UnitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUnitIdentifier(s)
	}
}

func (s *UnitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUnitIdentifier(s)
	}
}

func (p *DorisParser) UnitIdentifier() (localctx IUnitIdentifierContext) {
	localctx = NewUnitIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, DorisParserRULE_unitIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4457)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserDAY || _la == DorisParserHOUR || _la == DorisParserMINUTE || _la == DorisParserMONTH || _la == DorisParserSECOND || _la == DorisParserWEEK || _la == DorisParserYEAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeWithNullableContext is an interface to support dynamic dispatch.
type IDataTypeWithNullableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DataType() IDataTypeContext
	NULL() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsDataTypeWithNullableContext differentiates from other interfaces.
	IsDataTypeWithNullableContext()
}

type DataTypeWithNullableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeWithNullableContext() *DataTypeWithNullableContext {
	var p = new(DataTypeWithNullableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dataTypeWithNullable
	return p
}

func InitEmptyDataTypeWithNullableContext(p *DataTypeWithNullableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dataTypeWithNullable
}

func (*DataTypeWithNullableContext) IsDataTypeWithNullableContext() {}

func NewDataTypeWithNullableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeWithNullableContext {
	var p = new(DataTypeWithNullableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_dataTypeWithNullable

	return p
}

func (s *DataTypeWithNullableContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeWithNullableContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *DataTypeWithNullableContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisParserNULL, 0)
}

func (s *DataTypeWithNullableContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *DataTypeWithNullableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeWithNullableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeWithNullableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDataTypeWithNullable(s)
	}
}

func (s *DataTypeWithNullableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDataTypeWithNullable(s)
	}
}

func (p *DorisParser) DataTypeWithNullable() (localctx IDataTypeWithNullableContext) {
	localctx = NewDataTypeWithNullableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, DorisParserRULE_dataTypeWithNullable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4459)
		p.DataType()
	}
	p.SetState(4464)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserNOT || _la == DorisParserNULL {
		p.SetState(4461)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(4460)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4463)
			p.Match(DorisParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeContext is an interface to support dynamic dispatch.
type IDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDataTypeContext differentiates from other interfaces.
	IsDataTypeContext()
}

type DataTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeContext() *DataTypeContext {
	var p = new(DataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dataType
	return p
}

func InitEmptyDataTypeContext(p *DataTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dataType
}

func (*DataTypeContext) IsDataTypeContext() {}

func NewDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeContext {
	var p = new(DataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_dataType

	return p
}

func (s *DataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeContext) CopyAll(ctx *DataTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ComplexDataTypeContext struct {
	DataTypeContext
	complex_ antlr.Token
}

func NewComplexDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComplexDataTypeContext {
	var p = new(ComplexDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *ComplexDataTypeContext) GetComplex_() antlr.Token { return s.complex_ }

func (s *ComplexDataTypeContext) SetComplex_(v antlr.Token) { s.complex_ = v }

func (s *ComplexDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComplexDataTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(DorisParserLT, 0)
}

func (s *ComplexDataTypeContext) AllDataType() []IDataTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeContext); ok {
			tst[i] = t.(IDataTypeContext)
			i++
		}
	}

	return tst
}

func (s *ComplexDataTypeContext) DataType(i int) IDataTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ComplexDataTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(DorisParserGT, 0)
}

func (s *ComplexDataTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(DorisParserARRAY, 0)
}

func (s *ComplexDataTypeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, 0)
}

func (s *ComplexDataTypeContext) MAP() antlr.TerminalNode {
	return s.GetToken(DorisParserMAP, 0)
}

func (s *ComplexDataTypeContext) ComplexColTypeList() IComplexColTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComplexColTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComplexColTypeListContext)
}

func (s *ComplexDataTypeContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRUCT, 0)
}

func (s *ComplexDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterComplexDataType(s)
	}
}

func (s *ComplexDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitComplexDataType(s)
	}
}

type AggStateDataTypeContext struct {
	DataTypeContext
	_dataTypeWithNullable IDataTypeWithNullableContext
	dataTypes             []IDataTypeWithNullableContext
}

func NewAggStateDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AggStateDataTypeContext {
	var p = new(AggStateDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *AggStateDataTypeContext) Get_dataTypeWithNullable() IDataTypeWithNullableContext {
	return s._dataTypeWithNullable
}

func (s *AggStateDataTypeContext) Set_dataTypeWithNullable(v IDataTypeWithNullableContext) {
	s._dataTypeWithNullable = v
}

func (s *AggStateDataTypeContext) GetDataTypes() []IDataTypeWithNullableContext { return s.dataTypes }

func (s *AggStateDataTypeContext) SetDataTypes(v []IDataTypeWithNullableContext) { s.dataTypes = v }

func (s *AggStateDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggStateDataTypeContext) AGG_STATE() antlr.TerminalNode {
	return s.GetToken(DorisParserAGG_STATE, 0)
}

func (s *AggStateDataTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(DorisParserLT, 0)
}

func (s *AggStateDataTypeContext) FunctionNameIdentifier() IFunctionNameIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameIdentifierContext)
}

func (s *AggStateDataTypeContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AggStateDataTypeContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AggStateDataTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(DorisParserGT, 0)
}

func (s *AggStateDataTypeContext) AllDataTypeWithNullable() []IDataTypeWithNullableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeWithNullableContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeWithNullableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeWithNullableContext); ok {
			tst[i] = t.(IDataTypeWithNullableContext)
			i++
		}
	}

	return tst
}

func (s *AggStateDataTypeContext) DataTypeWithNullable(i int) IDataTypeWithNullableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeWithNullableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeWithNullableContext)
}

func (s *AggStateDataTypeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AggStateDataTypeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AggStateDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAggStateDataType(s)
	}
}

func (s *AggStateDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAggStateDataType(s)
	}
}

type PrimitiveDataTypeContext struct {
	DataTypeContext
}

func NewPrimitiveDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimitiveDataTypeContext {
	var p = new(PrimitiveDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *PrimitiveDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveDataTypeContext) PrimitiveColType() IPrimitiveColTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveColTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveColTypeContext)
}

func (s *PrimitiveDataTypeContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *PrimitiveDataTypeContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *PrimitiveDataTypeContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserINTEGER_VALUE)
}

func (s *PrimitiveDataTypeContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, i)
}

func (s *PrimitiveDataTypeContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserASTERISK, 0)
}

func (s *PrimitiveDataTypeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *PrimitiveDataTypeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *PrimitiveDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPrimitiveDataType(s)
	}
}

func (s *PrimitiveDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPrimitiveDataType(s)
	}
}

func (p *DorisParser) DataType() (localctx IDataTypeContext) {
	localctx = NewDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, DorisParserRULE_dataType)
	var _la int

	p.SetState(4511)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 620, p.GetParserRuleContext()) {
	case 1:
		localctx = NewComplexDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4466)

			var _m = p.Match(DorisParserARRAY)

			localctx.(*ComplexDataTypeContext).complex_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4467)
			p.Match(DorisParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4468)
			p.DataType()
		}
		{
			p.SetState(4469)
			p.Match(DorisParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewComplexDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4471)

			var _m = p.Match(DorisParserMAP)

			localctx.(*ComplexDataTypeContext).complex_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4472)
			p.Match(DorisParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4473)
			p.DataType()
		}
		{
			p.SetState(4474)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4475)
			p.DataType()
		}
		{
			p.SetState(4476)
			p.Match(DorisParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewComplexDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4478)

			var _m = p.Match(DorisParserSTRUCT)

			localctx.(*ComplexDataTypeContext).complex_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4479)
			p.Match(DorisParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4480)
			p.ComplexColTypeList()
		}
		{
			p.SetState(4481)
			p.Match(DorisParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewAggStateDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4483)
			p.Match(DorisParserAGG_STATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4484)
			p.Match(DorisParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4485)
			p.FunctionNameIdentifier()
		}
		{
			p.SetState(4486)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4487)

			var _x = p.DataTypeWithNullable()

			localctx.(*AggStateDataTypeContext)._dataTypeWithNullable = _x
		}
		localctx.(*AggStateDataTypeContext).dataTypes = append(localctx.(*AggStateDataTypeContext).dataTypes, localctx.(*AggStateDataTypeContext)._dataTypeWithNullable)
		p.SetState(4492)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(4488)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4489)

				var _x = p.DataTypeWithNullable()

				localctx.(*AggStateDataTypeContext)._dataTypeWithNullable = _x
			}
			localctx.(*AggStateDataTypeContext).dataTypes = append(localctx.(*AggStateDataTypeContext).dataTypes, localctx.(*AggStateDataTypeContext)._dataTypeWithNullable)

			p.SetState(4494)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4495)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4496)
			p.Match(DorisParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewPrimitiveDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4498)
			p.PrimitiveColType()
		}
		p.SetState(4509)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(4499)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4500)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserASTERISK || _la == DorisParserINTEGER_VALUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(4505)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(4501)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4502)
					p.Match(DorisParserINTEGER_VALUE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(4507)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(4508)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimitiveColTypeContext is an interface to support dynamic dispatch.
type IPrimitiveColTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	TINYINT() antlr.TerminalNode
	SMALLINT() antlr.TerminalNode
	INT() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	BIGINT() antlr.TerminalNode
	LARGEINT() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	TIME() antlr.TerminalNode
	DATEV2() antlr.TerminalNode
	DATETIMEV2() antlr.TerminalNode
	DATEV1() antlr.TerminalNode
	DATETIMEV1() antlr.TerminalNode
	BITMAP() antlr.TerminalNode
	QUANTILE_STATE() antlr.TerminalNode
	HLL() antlr.TerminalNode
	AGG_STATE() antlr.TerminalNode
	STRING() antlr.TerminalNode
	JSON() antlr.TerminalNode
	JSONB() antlr.TerminalNode
	TEXT() antlr.TerminalNode
	VARCHAR() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	DECIMALV2() antlr.TerminalNode
	DECIMALV3() antlr.TerminalNode
	IPV4() antlr.TerminalNode
	IPV6() antlr.TerminalNode
	VARIANT() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsPrimitiveColTypeContext differentiates from other interfaces.
	IsPrimitiveColTypeContext()
}

type PrimitiveColTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyPrimitiveColTypeContext() *PrimitiveColTypeContext {
	var p = new(PrimitiveColTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_primitiveColType
	return p
}

func InitEmptyPrimitiveColTypeContext(p *PrimitiveColTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_primitiveColType
}

func (*PrimitiveColTypeContext) IsPrimitiveColTypeContext() {}

func NewPrimitiveColTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveColTypeContext {
	var p = new(PrimitiveColTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_primitiveColType

	return p
}

func (s *PrimitiveColTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveColTypeContext) GetType_() antlr.Token { return s.type_ }

func (s *PrimitiveColTypeContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *PrimitiveColTypeContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(DorisParserTINYINT, 0)
}

func (s *PrimitiveColTypeContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(DorisParserSMALLINT, 0)
}

func (s *PrimitiveColTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(DorisParserINT, 0)
}

func (s *PrimitiveColTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER, 0)
}

func (s *PrimitiveColTypeContext) BIGINT() antlr.TerminalNode {
	return s.GetToken(DorisParserBIGINT, 0)
}

func (s *PrimitiveColTypeContext) LARGEINT() antlr.TerminalNode {
	return s.GetToken(DorisParserLARGEINT, 0)
}

func (s *PrimitiveColTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(DorisParserBOOLEAN, 0)
}

func (s *PrimitiveColTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(DorisParserFLOAT, 0)
}

func (s *PrimitiveColTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(DorisParserDOUBLE, 0)
}

func (s *PrimitiveColTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATE, 0)
}

func (s *PrimitiveColTypeContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(DorisParserDATETIME, 0)
}

func (s *PrimitiveColTypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserTIME, 0)
}

func (s *PrimitiveColTypeContext) DATEV2() antlr.TerminalNode {
	return s.GetToken(DorisParserDATEV2, 0)
}

func (s *PrimitiveColTypeContext) DATETIMEV2() antlr.TerminalNode {
	return s.GetToken(DorisParserDATETIMEV2, 0)
}

func (s *PrimitiveColTypeContext) DATEV1() antlr.TerminalNode {
	return s.GetToken(DorisParserDATEV1, 0)
}

func (s *PrimitiveColTypeContext) DATETIMEV1() antlr.TerminalNode {
	return s.GetToken(DorisParserDATETIMEV1, 0)
}

func (s *PrimitiveColTypeContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(DorisParserBITMAP, 0)
}

func (s *PrimitiveColTypeContext) QUANTILE_STATE() antlr.TerminalNode {
	return s.GetToken(DorisParserQUANTILE_STATE, 0)
}

func (s *PrimitiveColTypeContext) HLL() antlr.TerminalNode {
	return s.GetToken(DorisParserHLL, 0)
}

func (s *PrimitiveColTypeContext) AGG_STATE() antlr.TerminalNode {
	return s.GetToken(DorisParserAGG_STATE, 0)
}

func (s *PrimitiveColTypeContext) STRING() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING, 0)
}

func (s *PrimitiveColTypeContext) JSON() antlr.TerminalNode {
	return s.GetToken(DorisParserJSON, 0)
}

func (s *PrimitiveColTypeContext) JSONB() antlr.TerminalNode {
	return s.GetToken(DorisParserJSONB, 0)
}

func (s *PrimitiveColTypeContext) TEXT() antlr.TerminalNode {
	return s.GetToken(DorisParserTEXT, 0)
}

func (s *PrimitiveColTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserVARCHAR, 0)
}

func (s *PrimitiveColTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserCHAR, 0)
}

func (s *PrimitiveColTypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(DorisParserDECIMAL, 0)
}

func (s *PrimitiveColTypeContext) DECIMALV2() antlr.TerminalNode {
	return s.GetToken(DorisParserDECIMALV2, 0)
}

func (s *PrimitiveColTypeContext) DECIMALV3() antlr.TerminalNode {
	return s.GetToken(DorisParserDECIMALV3, 0)
}

func (s *PrimitiveColTypeContext) IPV4() antlr.TerminalNode {
	return s.GetToken(DorisParserIPV4, 0)
}

func (s *PrimitiveColTypeContext) IPV6() antlr.TerminalNode {
	return s.GetToken(DorisParserIPV6, 0)
}

func (s *PrimitiveColTypeContext) VARIANT() antlr.TerminalNode {
	return s.GetToken(DorisParserVARIANT, 0)
}

func (s *PrimitiveColTypeContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *PrimitiveColTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveColTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveColTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPrimitiveColType(s)
	}
}

func (s *PrimitiveColTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPrimitiveColType(s)
	}
}

func (p *DorisParser) PrimitiveColType() (localctx IPrimitiveColTypeContext) {
	localctx = NewPrimitiveColTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, DorisParserRULE_primitiveColType)
	var _la int

	p.SetState(4545)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserTINYINT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4513)

			var _m = p.Match(DorisParserTINYINT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserSMALLINT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4514)

			var _m = p.Match(DorisParserSMALLINT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserINT, DorisParserINTEGER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4515)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PrimitiveColTypeContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserINT || _la == DorisParserINTEGER) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PrimitiveColTypeContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case DorisParserBIGINT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4516)

			var _m = p.Match(DorisParserBIGINT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserLARGEINT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4517)

			var _m = p.Match(DorisParserLARGEINT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserBOOLEAN:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4518)

			var _m = p.Match(DorisParserBOOLEAN)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserFLOAT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4519)

			var _m = p.Match(DorisParserFLOAT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDOUBLE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4520)

			var _m = p.Match(DorisParserDOUBLE)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDATE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4521)

			var _m = p.Match(DorisParserDATE)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDATETIME:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(4522)

			var _m = p.Match(DorisParserDATETIME)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserTIME:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(4523)

			var _m = p.Match(DorisParserTIME)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDATEV2:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(4524)

			var _m = p.Match(DorisParserDATEV2)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDATETIMEV2:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(4525)

			var _m = p.Match(DorisParserDATETIMEV2)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDATEV1:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(4526)

			var _m = p.Match(DorisParserDATEV1)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDATETIMEV1:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(4527)

			var _m = p.Match(DorisParserDATETIMEV1)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserBITMAP:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(4528)

			var _m = p.Match(DorisParserBITMAP)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserQUANTILE_STATE:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(4529)

			var _m = p.Match(DorisParserQUANTILE_STATE)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserHLL:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(4530)

			var _m = p.Match(DorisParserHLL)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserAGG_STATE:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(4531)

			var _m = p.Match(DorisParserAGG_STATE)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserSTRING:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(4532)

			var _m = p.Match(DorisParserSTRING)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserJSON:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(4533)

			var _m = p.Match(DorisParserJSON)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserJSONB:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(4534)

			var _m = p.Match(DorisParserJSONB)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserTEXT:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(4535)

			var _m = p.Match(DorisParserTEXT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserVARCHAR:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(4536)

			var _m = p.Match(DorisParserVARCHAR)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserCHAR:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(4537)

			var _m = p.Match(DorisParserCHAR)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDECIMAL:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(4538)

			var _m = p.Match(DorisParserDECIMAL)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDECIMALV2:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(4539)

			var _m = p.Match(DorisParserDECIMALV2)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDECIMALV3:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(4540)

			var _m = p.Match(DorisParserDECIMALV3)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserIPV4:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(4541)

			var _m = p.Match(DorisParserIPV4)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserIPV6:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(4542)

			var _m = p.Match(DorisParserIPV6)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserVARIANT:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(4543)

			var _m = p.Match(DorisParserVARIANT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserALL:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(4544)

			var _m = p.Match(DorisParserALL)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComplexColTypeListContext is an interface to support dynamic dispatch.
type IComplexColTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllComplexColType() []IComplexColTypeContext
	ComplexColType(i int) IComplexColTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsComplexColTypeListContext differentiates from other interfaces.
	IsComplexColTypeListContext()
}

type ComplexColTypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComplexColTypeListContext() *ComplexColTypeListContext {
	var p = new(ComplexColTypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_complexColTypeList
	return p
}

func InitEmptyComplexColTypeListContext(p *ComplexColTypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_complexColTypeList
}

func (*ComplexColTypeListContext) IsComplexColTypeListContext() {}

func NewComplexColTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComplexColTypeListContext {
	var p = new(ComplexColTypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_complexColTypeList

	return p
}

func (s *ComplexColTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *ComplexColTypeListContext) AllComplexColType() []IComplexColTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IComplexColTypeContext); ok {
			len++
		}
	}

	tst := make([]IComplexColTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IComplexColTypeContext); ok {
			tst[i] = t.(IComplexColTypeContext)
			i++
		}
	}

	return tst
}

func (s *ComplexColTypeListContext) ComplexColType(i int) IComplexColTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComplexColTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComplexColTypeContext)
}

func (s *ComplexColTypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ComplexColTypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ComplexColTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComplexColTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComplexColTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterComplexColTypeList(s)
	}
}

func (s *ComplexColTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitComplexColTypeList(s)
	}
}

func (p *DorisParser) ComplexColTypeList() (localctx IComplexColTypeListContext) {
	localctx = NewComplexColTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, DorisParserRULE_complexColTypeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4547)
		p.ComplexColType()
	}
	p.SetState(4552)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(4548)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4549)
			p.ComplexColType()
		}

		p.SetState(4554)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComplexColTypeContext is an interface to support dynamic dispatch.
type IComplexColTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	DataType() IDataTypeContext
	CommentSpec() ICommentSpecContext

	// IsComplexColTypeContext differentiates from other interfaces.
	IsComplexColTypeContext()
}

type ComplexColTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComplexColTypeContext() *ComplexColTypeContext {
	var p = new(ComplexColTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_complexColType
	return p
}

func InitEmptyComplexColTypeContext(p *ComplexColTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_complexColType
}

func (*ComplexColTypeContext) IsComplexColTypeContext() {}

func NewComplexColTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComplexColTypeContext {
	var p = new(ComplexColTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_complexColType

	return p
}

func (s *ComplexColTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ComplexColTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ComplexColTypeContext) COLON() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLON, 0)
}

func (s *ComplexColTypeContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ComplexColTypeContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *ComplexColTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComplexColTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComplexColTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterComplexColType(s)
	}
}

func (s *ComplexColTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitComplexColType(s)
	}
}

func (p *DorisParser) ComplexColType() (localctx IComplexColTypeContext) {
	localctx = NewComplexColTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, DorisParserRULE_complexColType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4555)
		p.Identifier()
	}
	{
		p.SetState(4556)
		p.Match(DorisParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4557)
		p.DataType()
	}
	p.SetState(4559)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserCOMMENT {
		{
			p.SetState(4558)
			p.CommentSpec()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommentSpecContext is an interface to support dynamic dispatch.
type ICommentSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsCommentSpecContext differentiates from other interfaces.
	IsCommentSpecContext()
}

type CommentSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentSpecContext() *CommentSpecContext {
	var p = new(CommentSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_commentSpec
	return p
}

func InitEmptyCommentSpecContext(p *CommentSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_commentSpec
}

func (*CommentSpecContext) IsCommentSpecContext() {}

func NewCommentSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentSpecContext {
	var p = new(CommentSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_commentSpec

	return p
}

func (s *CommentSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentSpecContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *CommentSpecContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CommentSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCommentSpec(s)
	}
}

func (s *CommentSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCommentSpec(s)
	}
}

func (p *DorisParser) CommentSpec() (localctx ICommentSpecContext) {
	localctx = NewCommentSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, DorisParserRULE_commentSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4561)
		p.Match(DorisParserCOMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4562)
		p.Match(DorisParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampleContext is an interface to support dynamic dispatch.
type ISampleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSeed returns the seed token.
	GetSeed() antlr.Token

	// SetSeed sets the seed token.
	SetSeed(antlr.Token)

	// Getter signatures
	TABLESAMPLE() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	SampleMethod() ISampleMethodContext
	REPEATABLE() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsSampleContext differentiates from other interfaces.
	IsSampleContext()
}

type SampleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	seed   antlr.Token
}

func NewEmptySampleContext() *SampleContext {
	var p = new(SampleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sample
	return p
}

func InitEmptySampleContext(p *SampleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sample
}

func (*SampleContext) IsSampleContext() {}

func NewSampleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleContext {
	var p = new(SampleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_sample

	return p
}

func (s *SampleContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleContext) GetSeed() antlr.Token { return s.seed }

func (s *SampleContext) SetSeed(v antlr.Token) { s.seed = v }

func (s *SampleContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLESAMPLE, 0)
}

func (s *SampleContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *SampleContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *SampleContext) SampleMethod() ISampleMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleMethodContext)
}

func (s *SampleContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPEATABLE, 0)
}

func (s *SampleContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *SampleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSample(s)
	}
}

func (s *SampleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSample(s)
	}
}

func (p *DorisParser) Sample() (localctx ISampleContext) {
	localctx = NewSampleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, DorisParserRULE_sample)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4564)
		p.Match(DorisParserTABLESAMPLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4565)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserINTEGER_VALUE {
		{
			p.SetState(4566)
			p.SampleMethod()
		}

	}
	{
		p.SetState(4569)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4572)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 625, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4570)
			p.Match(DorisParserREPEATABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4571)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*SampleContext).seed = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampleMethodContext is an interface to support dynamic dispatch.
type ISampleMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSampleMethodContext differentiates from other interfaces.
	IsSampleMethodContext()
}

type SampleMethodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampleMethodContext() *SampleMethodContext {
	var p = new(SampleMethodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sampleMethod
	return p
}

func InitEmptySampleMethodContext(p *SampleMethodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sampleMethod
}

func (*SampleMethodContext) IsSampleMethodContext() {}

func NewSampleMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleMethodContext {
	var p = new(SampleMethodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_sampleMethod

	return p
}

func (s *SampleMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleMethodContext) CopyAll(ctx *SampleMethodContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SampleMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SampleByRowsContext struct {
	SampleMethodContext
}

func NewSampleByRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SampleByRowsContext {
	var p = new(SampleByRowsContext)

	InitEmptySampleMethodContext(&p.SampleMethodContext)
	p.parser = parser
	p.CopyAll(ctx.(*SampleMethodContext))

	return p
}

func (s *SampleByRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleByRowsContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *SampleByRowsContext) ROWS() antlr.TerminalNode {
	return s.GetToken(DorisParserROWS, 0)
}

func (s *SampleByRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSampleByRows(s)
	}
}

func (s *SampleByRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSampleByRows(s)
	}
}

type SampleByPercentileContext struct {
	SampleMethodContext
	percentage antlr.Token
}

func NewSampleByPercentileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SampleByPercentileContext {
	var p = new(SampleByPercentileContext)

	InitEmptySampleMethodContext(&p.SampleMethodContext)
	p.parser = parser
	p.CopyAll(ctx.(*SampleMethodContext))

	return p
}

func (s *SampleByPercentileContext) GetPercentage() antlr.Token { return s.percentage }

func (s *SampleByPercentileContext) SetPercentage(v antlr.Token) { s.percentage = v }

func (s *SampleByPercentileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleByPercentileContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(DorisParserPERCENT, 0)
}

func (s *SampleByPercentileContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *SampleByPercentileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSampleByPercentile(s)
	}
}

func (s *SampleByPercentileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSampleByPercentile(s)
	}
}

func (p *DorisParser) SampleMethod() (localctx ISampleMethodContext) {
	localctx = NewSampleMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, DorisParserRULE_sampleMethod)
	p.SetState(4578)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 626, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSampleByPercentileContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4574)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*SampleByPercentileContext).percentage = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4575)
			p.Match(DorisParserPERCENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewSampleByRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4576)
			p.Match(DorisParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4577)
			p.Match(DorisParserROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableSnapshotContext is an interface to support dynamic dispatch.
type ITableSnapshotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetVersion returns the version token.
	GetVersion() antlr.Token

	// GetTime returns the time token.
	GetTime() antlr.Token

	// SetVersion sets the version token.
	SetVersion(antlr.Token)

	// SetTime sets the time token.
	SetTime(antlr.Token)

	// Getter signatures
	FOR() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	TIME() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsTableSnapshotContext differentiates from other interfaces.
	IsTableSnapshotContext()
}

type TableSnapshotContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	version antlr.Token
	time    antlr.Token
}

func NewEmptyTableSnapshotContext() *TableSnapshotContext {
	var p = new(TableSnapshotContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tableSnapshot
	return p
}

func InitEmptyTableSnapshotContext(p *TableSnapshotContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tableSnapshot
}

func (*TableSnapshotContext) IsTableSnapshotContext() {}

func NewTableSnapshotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSnapshotContext {
	var p = new(TableSnapshotContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_tableSnapshot

	return p
}

func (s *TableSnapshotContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSnapshotContext) GetVersion() antlr.Token { return s.version }

func (s *TableSnapshotContext) GetTime() antlr.Token { return s.time }

func (s *TableSnapshotContext) SetVersion(v antlr.Token) { s.version = v }

func (s *TableSnapshotContext) SetTime(v antlr.Token) { s.time = v }

func (s *TableSnapshotContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *TableSnapshotContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisParserVERSION, 0)
}

func (s *TableSnapshotContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *TableSnapshotContext) OF() antlr.TerminalNode {
	return s.GetToken(DorisParserOF, 0)
}

func (s *TableSnapshotContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *TableSnapshotContext) TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserTIME, 0)
}

func (s *TableSnapshotContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *TableSnapshotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSnapshotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableSnapshotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTableSnapshot(s)
	}
}

func (s *TableSnapshotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTableSnapshot(s)
	}
}

func (p *DorisParser) TableSnapshot() (localctx ITableSnapshotContext) {
	localctx = NewTableSnapshotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, DorisParserRULE_tableSnapshot)
	p.SetState(4590)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 627, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4580)
			p.Match(DorisParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4581)
			p.Match(DorisParserVERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4582)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4583)
			p.Match(DorisParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4584)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*TableSnapshotContext).version = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4585)
			p.Match(DorisParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4586)
			p.Match(DorisParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4587)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4588)
			p.Match(DorisParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4589)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*TableSnapshotContext).time = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorCapturingIdentifierContext is an interface to support dynamic dispatch.
type IErrorCapturingIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ErrorCapturingIdentifierExtra() IErrorCapturingIdentifierExtraContext

	// IsErrorCapturingIdentifierContext differentiates from other interfaces.
	IsErrorCapturingIdentifierContext()
}

type ErrorCapturingIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorCapturingIdentifierContext() *ErrorCapturingIdentifierContext {
	var p = new(ErrorCapturingIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_errorCapturingIdentifier
	return p
}

func InitEmptyErrorCapturingIdentifierContext(p *ErrorCapturingIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_errorCapturingIdentifier
}

func (*ErrorCapturingIdentifierContext) IsErrorCapturingIdentifierContext() {}

func NewErrorCapturingIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorCapturingIdentifierContext {
	var p = new(ErrorCapturingIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_errorCapturingIdentifier

	return p
}

func (s *ErrorCapturingIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorCapturingIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ErrorCapturingIdentifierContext) ErrorCapturingIdentifierExtra() IErrorCapturingIdentifierExtraContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierExtraContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierExtraContext)
}

func (s *ErrorCapturingIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorCapturingIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorCapturingIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterErrorCapturingIdentifier(s)
	}
}

func (s *ErrorCapturingIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitErrorCapturingIdentifier(s)
	}
}

func (p *DorisParser) ErrorCapturingIdentifier() (localctx IErrorCapturingIdentifierContext) {
	localctx = NewErrorCapturingIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, DorisParserRULE_errorCapturingIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4592)
		p.Identifier()
	}
	{
		p.SetState(4593)
		p.ErrorCapturingIdentifierExtra()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorCapturingIdentifierExtraContext is an interface to support dynamic dispatch.
type IErrorCapturingIdentifierExtraContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsErrorCapturingIdentifierExtraContext differentiates from other interfaces.
	IsErrorCapturingIdentifierExtraContext()
}

type ErrorCapturingIdentifierExtraContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorCapturingIdentifierExtraContext() *ErrorCapturingIdentifierExtraContext {
	var p = new(ErrorCapturingIdentifierExtraContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_errorCapturingIdentifierExtra
	return p
}

func InitEmptyErrorCapturingIdentifierExtraContext(p *ErrorCapturingIdentifierExtraContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_errorCapturingIdentifierExtra
}

func (*ErrorCapturingIdentifierExtraContext) IsErrorCapturingIdentifierExtraContext() {}

func NewErrorCapturingIdentifierExtraContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorCapturingIdentifierExtraContext {
	var p = new(ErrorCapturingIdentifierExtraContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_errorCapturingIdentifierExtra

	return p
}

func (s *ErrorCapturingIdentifierExtraContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorCapturingIdentifierExtraContext) CopyAll(ctx *ErrorCapturingIdentifierExtraContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ErrorCapturingIdentifierExtraContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorCapturingIdentifierExtraContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ErrorIdentContext struct {
	ErrorCapturingIdentifierExtraContext
}

func NewErrorIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ErrorIdentContext {
	var p = new(ErrorIdentContext)

	InitEmptyErrorCapturingIdentifierExtraContext(&p.ErrorCapturingIdentifierExtraContext)
	p.parser = parser
	p.CopyAll(ctx.(*ErrorCapturingIdentifierExtraContext))

	return p
}

func (s *ErrorIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorIdentContext) AllSUBTRACT() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSUBTRACT)
}

func (s *ErrorIdentContext) SUBTRACT(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSUBTRACT, i)
}

func (s *ErrorIdentContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ErrorIdentContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ErrorIdentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterErrorIdent(s)
	}
}

func (s *ErrorIdentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitErrorIdent(s)
	}
}

type RealIdentContext struct {
	ErrorCapturingIdentifierExtraContext
}

func NewRealIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RealIdentContext {
	var p = new(RealIdentContext)

	InitEmptyErrorCapturingIdentifierExtraContext(&p.ErrorCapturingIdentifierExtraContext)
	p.parser = parser
	p.CopyAll(ctx.(*ErrorCapturingIdentifierExtraContext))

	return p
}

func (s *RealIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RealIdentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRealIdent(s)
	}
}

func (s *RealIdentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRealIdent(s)
	}
}

func (p *DorisParser) ErrorCapturingIdentifierExtra() (localctx IErrorCapturingIdentifierExtraContext) {
	localctx = NewErrorCapturingIdentifierExtraContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, DorisParserRULE_errorCapturingIdentifierExtra)
	var _alt int

	p.SetState(4602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 629, p.GetParserRuleContext()) {
	case 1:
		localctx = NewErrorIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4597)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(4595)
					p.Match(DorisParserSUBTRACT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4596)
					p.Identifier()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(4599)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 628, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		localctx = NewRealIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StrictIdentifier() IStrictIdentifierContext

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *DorisParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, DorisParserRULE_identifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4604)
		p.StrictIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStrictIdentifierContext is an interface to support dynamic dispatch.
type IStrictIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStrictIdentifierContext differentiates from other interfaces.
	IsStrictIdentifierContext()
}

type StrictIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrictIdentifierContext() *StrictIdentifierContext {
	var p = new(StrictIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_strictIdentifier
	return p
}

func InitEmptyStrictIdentifierContext(p *StrictIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_strictIdentifier
}

func (*StrictIdentifierContext) IsStrictIdentifierContext() {}

func NewStrictIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StrictIdentifierContext {
	var p = new(StrictIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_strictIdentifier

	return p
}

func (s *StrictIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *StrictIdentifierContext) CopyAll(ctx *StrictIdentifierContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StrictIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StrictIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QuotedIdentifierAlternativeContext struct {
	StrictIdentifierContext
}

func NewQuotedIdentifierAlternativeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuotedIdentifierAlternativeContext {
	var p = new(QuotedIdentifierAlternativeContext)

	InitEmptyStrictIdentifierContext(&p.StrictIdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*StrictIdentifierContext))

	return p
}

func (s *QuotedIdentifierAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierAlternativeContext) QuotedIdentifier() IQuotedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuotedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuotedIdentifierContext)
}

func (s *QuotedIdentifierAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterQuotedIdentifierAlternative(s)
	}
}

func (s *QuotedIdentifierAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitQuotedIdentifierAlternative(s)
	}
}

type UnquotedIdentifierContext struct {
	StrictIdentifierContext
}

func NewUnquotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnquotedIdentifierContext {
	var p = new(UnquotedIdentifierContext)

	InitEmptyStrictIdentifierContext(&p.StrictIdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*StrictIdentifierContext))

	return p
}

func (s *UnquotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnquotedIdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(DorisParserIDENTIFIER, 0)
}

func (s *UnquotedIdentifierContext) NonReserved() INonReservedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonReservedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonReservedContext)
}

func (s *UnquotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUnquotedIdentifier(s)
	}
}

func (p *DorisParser) StrictIdentifier() (localctx IStrictIdentifierContext) {
	localctx = NewStrictIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, DorisParserRULE_strictIdentifier)
	p.SetState(4609)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserIDENTIFIER:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4606)
			p.Match(DorisParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserBACKQUOTED_IDENTIFIER:
		localctx = NewQuotedIdentifierAlternativeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4607)
			p.QuotedIdentifier()
		}

	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADDDATE, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserARRAY_RANGE, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATE_ADD, DorisParserDATE_CEIL, DorisParserDATE_DIFF, DorisParserDATE_FLOOR, DorisParserDATE_SUB, DorisParserDATEADD, DorisParserDATEDIFF, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS_ADD, DorisParserDAYS_SUB, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUOTA, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSEQUENCE, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUBDATE, DorisParserSUM, DorisParserTABLES, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTIMESTAMPADD, DorisParserTIMESTAMPDIFF, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4608)
			p.NonReserved()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuotedIdentifierContext is an interface to support dynamic dispatch.
type IQuotedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BACKQUOTED_IDENTIFIER() antlr.TerminalNode

	// IsQuotedIdentifierContext differentiates from other interfaces.
	IsQuotedIdentifierContext()
}

type QuotedIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuotedIdentifierContext() *QuotedIdentifierContext {
	var p = new(QuotedIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_quotedIdentifier
	return p
}

func InitEmptyQuotedIdentifierContext(p *QuotedIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_quotedIdentifier
}

func (*QuotedIdentifierContext) IsQuotedIdentifierContext() {}

func NewQuotedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuotedIdentifierContext {
	var p = new(QuotedIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_quotedIdentifier

	return p
}

func (s *QuotedIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *QuotedIdentifierContext) BACKQUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKQUOTED_IDENTIFIER, 0)
}

func (s *QuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterQuotedIdentifier(s)
	}
}

func (s *QuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitQuotedIdentifier(s)
	}
}

func (p *DorisParser) QuotedIdentifier() (localctx IQuotedIdentifierContext) {
	localctx = NewQuotedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, DorisParserRULE_quotedIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4611)
		p.Match(DorisParserBACKQUOTED_IDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_number
	return p
}

func InitEmptyNumberContext(p *NumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_number
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) CopyAll(ctx *NumberContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DecimalLiteralContext struct {
	NumberContext
}

func NewDecimalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) EXPONENT_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserEXPONENT_VALUE, 0)
}

func (s *DecimalLiteralContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserDECIMAL_VALUE, 0)
}

func (s *DecimalLiteralContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(DorisParserSUBTRACT, 0)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

type IntegerLiteralContext struct {
	NumberContext
}

func NewIntegerLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *IntegerLiteralContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(DorisParserSUBTRACT, 0)
}

func (s *IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIntegerLiteral(s)
	}
}

func (p *DorisParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, DorisParserRULE_number)
	var _la int

	p.SetState(4621)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 633, p.GetParserRuleContext()) {
	case 1:
		localctx = NewIntegerLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4614)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserSUBTRACT {
			{
				p.SetState(4613)
				p.Match(DorisParserSUBTRACT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4616)
			p.Match(DorisParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewDecimalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4618)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserSUBTRACT {
			{
				p.SetState(4617)
				p.Match(DorisParserSUBTRACT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4620)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserEXPONENT_VALUE || _la == DorisParserDECIMAL_VALUE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonReservedContext is an interface to support dynamic dispatch.
type INonReservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACTIONS() antlr.TerminalNode
	ADDDATE() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	AGG_STATE() antlr.TerminalNode
	AGGREGATE() antlr.TerminalNode
	ALIAS() antlr.TerminalNode
	ALWAYS() antlr.TerminalNode
	ANALYZED() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	ARRAY_RANGE() antlr.TerminalNode
	AT() antlr.TerminalNode
	AUTHORS() antlr.TerminalNode
	AUTO_INCREMENT() antlr.TerminalNode
	BACKENDS() antlr.TerminalNode
	BACKUP() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	BELONG() antlr.TerminalNode
	BIN() antlr.TerminalNode
	BITAND() antlr.TerminalNode
	BITMAP() antlr.TerminalNode
	BITMAP_UNION() antlr.TerminalNode
	BITOR() antlr.TerminalNode
	BITXOR() antlr.TerminalNode
	BLOB() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	BRIEF() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	BUILD() antlr.TerminalNode
	BUILTIN() antlr.TerminalNode
	BULK() antlr.TerminalNode
	CACHE() antlr.TerminalNode
	CACHED() antlr.TerminalNode
	CALL() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	CATALOGS() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	CLUSTERS() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	COLLECT() antlr.TerminalNode
	COLOCATE() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	COMMENT_START() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	COMPACT() antlr.TerminalNode
	COMPLETE() antlr.TerminalNode
	COMPRESS_TYPE() antlr.TerminalNode
	CONDITIONS() antlr.TerminalNode
	CONFIG() antlr.TerminalNode
	CONNECTION() antlr.TerminalNode
	CONNECTION_ID() antlr.TerminalNode
	CONSISTENT() antlr.TerminalNode
	CONSTRAINTS() antlr.TerminalNode
	CONVERT() antlr.TerminalNode
	CONVERT_LSC() antlr.TerminalNode
	COPY() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	CREATION() antlr.TerminalNode
	CRON() antlr.TerminalNode
	CURRENT_CATALOG() antlr.TerminalNode
	CURRENT_DATE() antlr.TerminalNode
	CURRENT_TIME() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	CURRENT_USER() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATE_ADD() antlr.TerminalNode
	DATE_CEIL() antlr.TerminalNode
	DATE_DIFF() antlr.TerminalNode
	DATE_FLOOR() antlr.TerminalNode
	DATE_SUB() antlr.TerminalNode
	DATEADD() antlr.TerminalNode
	DATEDIFF() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	DATETIMEV1() antlr.TerminalNode
	DATETIMEV2() antlr.TerminalNode
	DATEV1() antlr.TerminalNode
	DATEV2() antlr.TerminalNode
	DAY() antlr.TerminalNode
	DAYS_ADD() antlr.TerminalNode
	DAYS_SUB() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	DECIMALV2() antlr.TerminalNode
	DECIMALV3() antlr.TerminalNode
	DEFERRED() antlr.TerminalNode
	DEMAND() antlr.TerminalNode
	DIAGNOSE() antlr.TerminalNode
	DISTINCTPC() antlr.TerminalNode
	DISTINCTPCSA() antlr.TerminalNode
	DO() antlr.TerminalNode
	DORIS_INTERNAL_TABLE_ID() antlr.TerminalNode
	DUAL() antlr.TerminalNode
	DYNAMIC() antlr.TerminalNode
	ENABLE() antlr.TerminalNode
	ENCRYPTKEY() antlr.TerminalNode
	ENCRYPTKEYS() antlr.TerminalNode
	END() antlr.TerminalNode
	ENDS() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	ENGINES() antlr.TerminalNode
	ERRORS() antlr.TerminalNode
	EVENTS() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	EXCLUDE() antlr.TerminalNode
	EXPIRED() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode
	FAST() antlr.TerminalNode
	FEATURE() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	FILE() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	FREE() antlr.TerminalNode
	FRONTENDS() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	GENERATED() antlr.TerminalNode
	GENERIC() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	GRAPH() antlr.TerminalNode
	GROUPING() antlr.TerminalNode
	GROUPS() antlr.TerminalNode
	HASH() antlr.TerminalNode
	HDFS() antlr.TerminalNode
	HELP() antlr.TerminalNode
	HINT_END() antlr.TerminalNode
	HINT_START() antlr.TerminalNode
	HISTOGRAM() antlr.TerminalNode
	HLL_UNION() antlr.TerminalNode
	HOSTNAME() antlr.TerminalNode
	HOTSPOT() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	HUB() antlr.TerminalNode
	IDENTIFIED() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	IMMEDIATE() antlr.TerminalNode
	INCREMENTAL() antlr.TerminalNode
	INDEXES() antlr.TerminalNode
	INVERTED() antlr.TerminalNode
	IPV4() antlr.TerminalNode
	IPV6() antlr.TerminalNode
	IS_NOT_NULL_PRED() antlr.TerminalNode
	IS_NULL_PRED() antlr.TerminalNode
	ISNULL() antlr.TerminalNode
	ISOLATION() antlr.TerminalNode
	JOB() antlr.TerminalNode
	JOBS() antlr.TerminalNode
	JSON() antlr.TerminalNode
	JSONB() antlr.TerminalNode
	LABEL() antlr.TerminalNode
	LAST() antlr.TerminalNode
	LDAP() antlr.TerminalNode
	LDAP_ADMIN_PASSWORD() antlr.TerminalNode
	LEFT_BRACE() antlr.TerminalNode
	LESS() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	LINES() antlr.TerminalNode
	LINK() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	LOCALTIME() antlr.TerminalNode
	LOCALTIMESTAMP() antlr.TerminalNode
	LOCATION() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	LOGICAL() antlr.TerminalNode
	MANUAL() antlr.TerminalNode
	MAP() antlr.TerminalNode
	MATCH_ALL() antlr.TerminalNode
	MATCH_ANY() antlr.TerminalNode
	MATCH_PHRASE() antlr.TerminalNode
	MATCH_PHRASE_EDGE() antlr.TerminalNode
	MATCH_PHRASE_PREFIX() antlr.TerminalNode
	MATCH_REGEXP() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MEMO() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	MIGRATE() antlr.TerminalNode
	MIGRATIONS() antlr.TerminalNode
	MIN() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	MTMV() antlr.TerminalNode
	NAME() antlr.TerminalNode
	NAMES() antlr.TerminalNode
	NEGATIVE() antlr.TerminalNode
	NEVER() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	NGRAM_BF() antlr.TerminalNode
	NO() antlr.TerminalNode
	NON_NULLABLE() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	OF() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	OPTIMIZED() antlr.TerminalNode
	PARAMETER() antlr.TerminalNode
	PARSED() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	PASSWORD_EXPIRE() antlr.TerminalNode
	PASSWORD_HISTORY() antlr.TerminalNode
	PASSWORD_LOCK_TIME() antlr.TerminalNode
	PASSWORD_REUSE() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	PATH() antlr.TerminalNode
	PAUSE() antlr.TerminalNode
	PERCENT() antlr.TerminalNode
	PERIOD() antlr.TerminalNode
	PERMISSIVE() antlr.TerminalNode
	PHYSICAL() antlr.TerminalNode
	PI() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	PLUGINS() antlr.TerminalNode
	POLICY() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	PROC() antlr.TerminalNode
	PROCESS() antlr.TerminalNode
	PROCESSLIST() antlr.TerminalNode
	PROFILE() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode
	QUANTILE_STATE() antlr.TerminalNode
	QUANTILE_UNION() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	QUOTA() antlr.TerminalNode
	RANDOM() antlr.TerminalNode
	RECENT() antlr.TerminalNode
	RECOVER() antlr.TerminalNode
	RECYCLE() antlr.TerminalNode
	REFRESH() antlr.TerminalNode
	REPEATABLE() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	REPLACE_IF_NOT_NULL() antlr.TerminalNode
	REPOSITORIES() antlr.TerminalNode
	REPOSITORY() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	RESOURCES() antlr.TerminalNode
	RESTORE() antlr.TerminalNode
	RESTRICTIVE() antlr.TerminalNode
	RESUME() antlr.TerminalNode
	RETURNS() antlr.TerminalNode
	REWRITTEN() antlr.TerminalNode
	RIGHT_BRACE() antlr.TerminalNode
	RLIKE() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	S3() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	SCHEDULER() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode
	SET_SESSION_VARIABLE() antlr.TerminalNode
	SEQUENCE() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	SHAPE() antlr.TerminalNode
	SKEW() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	SONAME() antlr.TerminalNode
	SPLIT() antlr.TerminalNode
	SQL() antlr.TerminalNode
	STAGE() antlr.TerminalNode
	STAGES() antlr.TerminalNode
	START() antlr.TerminalNode
	STARTS() antlr.TerminalNode
	STATS() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	STOP() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	STREAM() antlr.TerminalNode
	STREAMING() antlr.TerminalNode
	STRING() antlr.TerminalNode
	STRUCT() antlr.TerminalNode
	SUBDATE() antlr.TerminalNode
	SUM() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	TASK() antlr.TerminalNode
	TASKS() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TEXT() antlr.TerminalNode
	THAN() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	TIMESTAMPADD() antlr.TerminalNode
	TIMESTAMPDIFF() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	TREE() antlr.TerminalNode
	TRIGGERS() antlr.TerminalNode
	TRUNCATE() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	TYPES() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	UNLOCK() antlr.TerminalNode
	UNSET() antlr.TerminalNode
	UP() antlr.TerminalNode
	USER() antlr.TerminalNode
	VALUE() antlr.TerminalNode
	VARCHAR() antlr.TerminalNode
	VARIABLE() antlr.TerminalNode
	VARIABLES() antlr.TerminalNode
	VARIANT() antlr.TerminalNode
	VAULT() antlr.TerminalNode
	VERBOSE() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	WARM() antlr.TerminalNode
	WARNINGS() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	WORK() antlr.TerminalNode
	YEAR() antlr.TerminalNode

	// IsNonReservedContext differentiates from other interfaces.
	IsNonReservedContext()
}

type NonReservedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedContext() *NonReservedContext {
	var p = new(NonReservedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_nonReserved
	return p
}

func InitEmptyNonReservedContext(p *NonReservedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_nonReserved
}

func (*NonReservedContext) IsNonReservedContext() {}

func NewNonReservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedContext {
	var p = new(NonReservedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_nonReserved

	return p
}

func (s *NonReservedContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedContext) ACTIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserACTIONS, 0)
}

func (s *NonReservedContext) ADDDATE() antlr.TerminalNode {
	return s.GetToken(DorisParserADDDATE, 0)
}

func (s *NonReservedContext) AFTER() antlr.TerminalNode {
	return s.GetToken(DorisParserAFTER, 0)
}

func (s *NonReservedContext) AGG_STATE() antlr.TerminalNode {
	return s.GetToken(DorisParserAGG_STATE, 0)
}

func (s *NonReservedContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(DorisParserAGGREGATE, 0)
}

func (s *NonReservedContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(DorisParserALIAS, 0)
}

func (s *NonReservedContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(DorisParserALWAYS, 0)
}

func (s *NonReservedContext) ANALYZED() antlr.TerminalNode {
	return s.GetToken(DorisParserANALYZED, 0)
}

func (s *NonReservedContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(DorisParserARRAY, 0)
}

func (s *NonReservedContext) ARRAY_RANGE() antlr.TerminalNode {
	return s.GetToken(DorisParserARRAY_RANGE, 0)
}

func (s *NonReservedContext) AT() antlr.TerminalNode {
	return s.GetToken(DorisParserAT, 0)
}

func (s *NonReservedContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTHORS, 0)
}

func (s *NonReservedContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO_INCREMENT, 0)
}

func (s *NonReservedContext) BACKENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKENDS, 0)
}

func (s *NonReservedContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKUP, 0)
}

func (s *NonReservedContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(DorisParserBEGIN, 0)
}

func (s *NonReservedContext) BELONG() antlr.TerminalNode {
	return s.GetToken(DorisParserBELONG, 0)
}

func (s *NonReservedContext) BIN() antlr.TerminalNode {
	return s.GetToken(DorisParserBIN, 0)
}

func (s *NonReservedContext) BITAND() antlr.TerminalNode {
	return s.GetToken(DorisParserBITAND, 0)
}

func (s *NonReservedContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(DorisParserBITMAP, 0)
}

func (s *NonReservedContext) BITMAP_UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserBITMAP_UNION, 0)
}

func (s *NonReservedContext) BITOR() antlr.TerminalNode {
	return s.GetToken(DorisParserBITOR, 0)
}

func (s *NonReservedContext) BITXOR() antlr.TerminalNode {
	return s.GetToken(DorisParserBITXOR, 0)
}

func (s *NonReservedContext) BLOB() antlr.TerminalNode {
	return s.GetToken(DorisParserBLOB, 0)
}

func (s *NonReservedContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(DorisParserBOOLEAN, 0)
}

func (s *NonReservedContext) BRIEF() antlr.TerminalNode {
	return s.GetToken(DorisParserBRIEF, 0)
}

func (s *NonReservedContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserBROKER, 0)
}

func (s *NonReservedContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisParserBUCKETS, 0)
}

func (s *NonReservedContext) BUILD() antlr.TerminalNode {
	return s.GetToken(DorisParserBUILD, 0)
}

func (s *NonReservedContext) BUILTIN() antlr.TerminalNode {
	return s.GetToken(DorisParserBUILTIN, 0)
}

func (s *NonReservedContext) BULK() antlr.TerminalNode {
	return s.GetToken(DorisParserBULK, 0)
}

func (s *NonReservedContext) CACHE() antlr.TerminalNode {
	return s.GetToken(DorisParserCACHE, 0)
}

func (s *NonReservedContext) CACHED() antlr.TerminalNode {
	return s.GetToken(DorisParserCACHED, 0)
}

func (s *NonReservedContext) CALL() antlr.TerminalNode {
	return s.GetToken(DorisParserCALL, 0)
}

func (s *NonReservedContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *NonReservedContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOGS, 0)
}

func (s *NonReservedContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(DorisParserCHAIN, 0)
}

func (s *NonReservedContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserCHAR, 0)
}

func (s *NonReservedContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(DorisParserCHARSET, 0)
}

func (s *NonReservedContext) CHECK() antlr.TerminalNode {
	return s.GetToken(DorisParserCHECK, 0)
}

func (s *NonReservedContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(DorisParserCLUSTER, 0)
}

func (s *NonReservedContext) CLUSTERS() antlr.TerminalNode {
	return s.GetToken(DorisParserCLUSTERS, 0)
}

func (s *NonReservedContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLLATION, 0)
}

func (s *NonReservedContext) COLLECT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLLECT, 0)
}

func (s *NonReservedContext) COLOCATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLOCATE, 0)
}

func (s *NonReservedContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMNS, 0)
}

func (s *NonReservedContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *NonReservedContext) COMMENT_START() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT_START, 0)
}

func (s *NonReservedContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMIT, 0)
}

func (s *NonReservedContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMITTED, 0)
}

func (s *NonReservedContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPACT, 0)
}

func (s *NonReservedContext) COMPLETE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPLETE, 0)
}

func (s *NonReservedContext) COMPRESS_TYPE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPRESS_TYPE, 0)
}

func (s *NonReservedContext) CONDITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserCONDITIONS, 0)
}

func (s *NonReservedContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(DorisParserCONFIG, 0)
}

func (s *NonReservedContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(DorisParserCONNECTION, 0)
}

func (s *NonReservedContext) CONNECTION_ID() antlr.TerminalNode {
	return s.GetToken(DorisParserCONNECTION_ID, 0)
}

func (s *NonReservedContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCONSISTENT, 0)
}

func (s *NonReservedContext) CONSTRAINTS() antlr.TerminalNode {
	return s.GetToken(DorisParserCONSTRAINTS, 0)
}

func (s *NonReservedContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(DorisParserCONVERT, 0)
}

func (s *NonReservedContext) CONVERT_LSC() antlr.TerminalNode {
	return s.GetToken(DorisParserCONVERT_LSC, 0)
}

func (s *NonReservedContext) COPY() antlr.TerminalNode {
	return s.GetToken(DorisParserCOPY, 0)
}

func (s *NonReservedContext) COUNT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOUNT, 0)
}

func (s *NonReservedContext) CREATION() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATION, 0)
}

func (s *NonReservedContext) CRON() antlr.TerminalNode {
	return s.GetToken(DorisParserCRON, 0)
}

func (s *NonReservedContext) CURRENT_CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_CATALOG, 0)
}

func (s *NonReservedContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_DATE, 0)
}

func (s *NonReservedContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_TIME, 0)
}

func (s *NonReservedContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_TIMESTAMP, 0)
}

func (s *NonReservedContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_USER, 0)
}

func (s *NonReservedContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserDATA, 0)
}

func (s *NonReservedContext) DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATE, 0)
}

func (s *NonReservedContext) DATE_ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserDATE_ADD, 0)
}

func (s *NonReservedContext) DATE_CEIL() antlr.TerminalNode {
	return s.GetToken(DorisParserDATE_CEIL, 0)
}

func (s *NonReservedContext) DATE_DIFF() antlr.TerminalNode {
	return s.GetToken(DorisParserDATE_DIFF, 0)
}

func (s *NonReservedContext) DATE_FLOOR() antlr.TerminalNode {
	return s.GetToken(DorisParserDATE_FLOOR, 0)
}

func (s *NonReservedContext) DATE_SUB() antlr.TerminalNode {
	return s.GetToken(DorisParserDATE_SUB, 0)
}

func (s *NonReservedContext) DATEADD() antlr.TerminalNode {
	return s.GetToken(DorisParserDATEADD, 0)
}

func (s *NonReservedContext) DATEDIFF() antlr.TerminalNode {
	return s.GetToken(DorisParserDATEDIFF, 0)
}

func (s *NonReservedContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(DorisParserDATETIME, 0)
}

func (s *NonReservedContext) DATETIMEV1() antlr.TerminalNode {
	return s.GetToken(DorisParserDATETIMEV1, 0)
}

func (s *NonReservedContext) DATETIMEV2() antlr.TerminalNode {
	return s.GetToken(DorisParserDATETIMEV2, 0)
}

func (s *NonReservedContext) DATEV1() antlr.TerminalNode {
	return s.GetToken(DorisParserDATEV1, 0)
}

func (s *NonReservedContext) DATEV2() antlr.TerminalNode {
	return s.GetToken(DorisParserDATEV2, 0)
}

func (s *NonReservedContext) DAY() antlr.TerminalNode {
	return s.GetToken(DorisParserDAY, 0)
}

func (s *NonReservedContext) DAYS_ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserDAYS_ADD, 0)
}

func (s *NonReservedContext) DAYS_SUB() antlr.TerminalNode {
	return s.GetToken(DorisParserDAYS_SUB, 0)
}

func (s *NonReservedContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(DorisParserDECIMAL, 0)
}

func (s *NonReservedContext) DECIMALV2() antlr.TerminalNode {
	return s.GetToken(DorisParserDECIMALV2, 0)
}

func (s *NonReservedContext) DECIMALV3() antlr.TerminalNode {
	return s.GetToken(DorisParserDECIMALV3, 0)
}

func (s *NonReservedContext) DEFERRED() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFERRED, 0)
}

func (s *NonReservedContext) DEMAND() antlr.TerminalNode {
	return s.GetToken(DorisParserDEMAND, 0)
}

func (s *NonReservedContext) DIAGNOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserDIAGNOSE, 0)
}

func (s *NonReservedContext) DISTINCTPC() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTINCTPC, 0)
}

func (s *NonReservedContext) DISTINCTPCSA() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTINCTPCSA, 0)
}

func (s *NonReservedContext) DO() antlr.TerminalNode {
	return s.GetToken(DorisParserDO, 0)
}

func (s *NonReservedContext) DORIS_INTERNAL_TABLE_ID() antlr.TerminalNode {
	return s.GetToken(DorisParserDORIS_INTERNAL_TABLE_ID, 0)
}

func (s *NonReservedContext) DUAL() antlr.TerminalNode {
	return s.GetToken(DorisParserDUAL, 0)
}

func (s *NonReservedContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(DorisParserDYNAMIC, 0)
}

func (s *NonReservedContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserENABLE, 0)
}

func (s *NonReservedContext) ENCRYPTKEY() antlr.TerminalNode {
	return s.GetToken(DorisParserENCRYPTKEY, 0)
}

func (s *NonReservedContext) ENCRYPTKEYS() antlr.TerminalNode {
	return s.GetToken(DorisParserENCRYPTKEYS, 0)
}

func (s *NonReservedContext) END() antlr.TerminalNode {
	return s.GetToken(DorisParserEND, 0)
}

func (s *NonReservedContext) ENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserENDS, 0)
}

func (s *NonReservedContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(DorisParserENGINE, 0)
}

func (s *NonReservedContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(DorisParserENGINES, 0)
}

func (s *NonReservedContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(DorisParserERRORS, 0)
}

func (s *NonReservedContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEVENTS, 0)
}

func (s *NonReservedContext) EVERY() antlr.TerminalNode {
	return s.GetToken(DorisParserEVERY, 0)
}

func (s *NonReservedContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(DorisParserEXCLUDE, 0)
}

func (s *NonReservedContext) EXPIRED() antlr.TerminalNode {
	return s.GetToken(DorisParserEXPIRED, 0)
}

func (s *NonReservedContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisParserEXTERNAL, 0)
}

func (s *NonReservedContext) FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode {
	return s.GetToken(DorisParserFAILED_LOGIN_ATTEMPTS, 0)
}

func (s *NonReservedContext) FAST() antlr.TerminalNode {
	return s.GetToken(DorisParserFAST, 0)
}

func (s *NonReservedContext) FEATURE() antlr.TerminalNode {
	return s.GetToken(DorisParserFEATURE, 0)
}

func (s *NonReservedContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(DorisParserFIELDS, 0)
}

func (s *NonReservedContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisParserFILE, 0)
}

func (s *NonReservedContext) FILTER() antlr.TerminalNode {
	return s.GetToken(DorisParserFILTER, 0)
}

func (s *NonReservedContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DorisParserFIRST, 0)
}

func (s *NonReservedContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DorisParserFORMAT, 0)
}

func (s *NonReservedContext) FREE() antlr.TerminalNode {
	return s.GetToken(DorisParserFREE, 0)
}

func (s *NonReservedContext) FRONTENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserFRONTENDS, 0)
}

func (s *NonReservedContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserFUNCTION, 0)
}

func (s *NonReservedContext) GENERATED() antlr.TerminalNode {
	return s.GetToken(DorisParserGENERATED, 0)
}

func (s *NonReservedContext) GENERIC() antlr.TerminalNode {
	return s.GetToken(DorisParserGENERIC, 0)
}

func (s *NonReservedContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *NonReservedContext) GRAPH() antlr.TerminalNode {
	return s.GetToken(DorisParserGRAPH, 0)
}

func (s *NonReservedContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUPING, 0)
}

func (s *NonReservedContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUPS, 0)
}

func (s *NonReservedContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisParserHASH, 0)
}

func (s *NonReservedContext) HDFS() antlr.TerminalNode {
	return s.GetToken(DorisParserHDFS, 0)
}

func (s *NonReservedContext) HELP() antlr.TerminalNode {
	return s.GetToken(DorisParserHELP, 0)
}

func (s *NonReservedContext) HINT_END() antlr.TerminalNode {
	return s.GetToken(DorisParserHINT_END, 0)
}

func (s *NonReservedContext) HINT_START() antlr.TerminalNode {
	return s.GetToken(DorisParserHINT_START, 0)
}

func (s *NonReservedContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(DorisParserHISTOGRAM, 0)
}

func (s *NonReservedContext) HLL_UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserHLL_UNION, 0)
}

func (s *NonReservedContext) HOSTNAME() antlr.TerminalNode {
	return s.GetToken(DorisParserHOSTNAME, 0)
}

func (s *NonReservedContext) HOTSPOT() antlr.TerminalNode {
	return s.GetToken(DorisParserHOTSPOT, 0)
}

func (s *NonReservedContext) HOUR() antlr.TerminalNode {
	return s.GetToken(DorisParserHOUR, 0)
}

func (s *NonReservedContext) HUB() antlr.TerminalNode {
	return s.GetToken(DorisParserHUB, 0)
}

func (s *NonReservedContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(DorisParserIDENTIFIED, 0)
}

func (s *NonReservedContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(DorisParserIGNORE, 0)
}

func (s *NonReservedContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(DorisParserIMMEDIATE, 0)
}

func (s *NonReservedContext) INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(DorisParserINCREMENTAL, 0)
}

func (s *NonReservedContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEXES, 0)
}

func (s *NonReservedContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserINVERTED, 0)
}

func (s *NonReservedContext) IPV4() antlr.TerminalNode {
	return s.GetToken(DorisParserIPV4, 0)
}

func (s *NonReservedContext) IPV6() antlr.TerminalNode {
	return s.GetToken(DorisParserIPV6, 0)
}

func (s *NonReservedContext) IS_NOT_NULL_PRED() antlr.TerminalNode {
	return s.GetToken(DorisParserIS_NOT_NULL_PRED, 0)
}

func (s *NonReservedContext) IS_NULL_PRED() antlr.TerminalNode {
	return s.GetToken(DorisParserIS_NULL_PRED, 0)
}

func (s *NonReservedContext) ISNULL() antlr.TerminalNode {
	return s.GetToken(DorisParserISNULL, 0)
}

func (s *NonReservedContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(DorisParserISOLATION, 0)
}

func (s *NonReservedContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *NonReservedContext) JOBS() antlr.TerminalNode {
	return s.GetToken(DorisParserJOBS, 0)
}

func (s *NonReservedContext) JSON() antlr.TerminalNode {
	return s.GetToken(DorisParserJSON, 0)
}

func (s *NonReservedContext) JSONB() antlr.TerminalNode {
	return s.GetToken(DorisParserJSONB, 0)
}

func (s *NonReservedContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisParserLABEL, 0)
}

func (s *NonReservedContext) LAST() antlr.TerminalNode {
	return s.GetToken(DorisParserLAST, 0)
}

func (s *NonReservedContext) LDAP() antlr.TerminalNode {
	return s.GetToken(DorisParserLDAP, 0)
}

func (s *NonReservedContext) LDAP_ADMIN_PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisParserLDAP_ADMIN_PASSWORD, 0)
}

func (s *NonReservedContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACE, 0)
}

func (s *NonReservedContext) LESS() antlr.TerminalNode {
	return s.GetToken(DorisParserLESS, 0)
}

func (s *NonReservedContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(DorisParserLEVEL, 0)
}

func (s *NonReservedContext) LINES() antlr.TerminalNode {
	return s.GetToken(DorisParserLINES, 0)
}

func (s *NonReservedContext) LINK() antlr.TerminalNode {
	return s.GetToken(DorisParserLINK, 0)
}

func (s *NonReservedContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *NonReservedContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCALTIME, 0)
}

func (s *NonReservedContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCALTIMESTAMP, 0)
}

func (s *NonReservedContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCATION, 0)
}

func (s *NonReservedContext) LOCK() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCK, 0)
}

func (s *NonReservedContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOGICAL, 0)
}

func (s *NonReservedContext) MANUAL() antlr.TerminalNode {
	return s.GetToken(DorisParserMANUAL, 0)
}

func (s *NonReservedContext) MAP() antlr.TerminalNode {
	return s.GetToken(DorisParserMAP, 0)
}

func (s *NonReservedContext) MATCH_ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_ALL, 0)
}

func (s *NonReservedContext) MATCH_ANY() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_ANY, 0)
}

func (s *NonReservedContext) MATCH_PHRASE() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_PHRASE, 0)
}

func (s *NonReservedContext) MATCH_PHRASE_EDGE() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_PHRASE_EDGE, 0)
}

func (s *NonReservedContext) MATCH_PHRASE_PREFIX() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_PHRASE_PREFIX, 0)
}

func (s *NonReservedContext) MATCH_REGEXP() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_REGEXP, 0)
}

func (s *NonReservedContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *NonReservedContext) MAX() antlr.TerminalNode {
	return s.GetToken(DorisParserMAX, 0)
}

func (s *NonReservedContext) MEMO() antlr.TerminalNode {
	return s.GetToken(DorisParserMEMO, 0)
}

func (s *NonReservedContext) MERGE() antlr.TerminalNode {
	return s.GetToken(DorisParserMERGE, 0)
}

func (s *NonReservedContext) MIGRATE() antlr.TerminalNode {
	return s.GetToken(DorisParserMIGRATE, 0)
}

func (s *NonReservedContext) MIGRATIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserMIGRATIONS, 0)
}

func (s *NonReservedContext) MIN() antlr.TerminalNode {
	return s.GetToken(DorisParserMIN, 0)
}

func (s *NonReservedContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(DorisParserMINUTE, 0)
}

func (s *NonReservedContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *NonReservedContext) MONTH() antlr.TerminalNode {
	return s.GetToken(DorisParserMONTH, 0)
}

func (s *NonReservedContext) MTMV() antlr.TerminalNode {
	return s.GetToken(DorisParserMTMV, 0)
}

func (s *NonReservedContext) NAME() antlr.TerminalNode {
	return s.GetToken(DorisParserNAME, 0)
}

func (s *NonReservedContext) NAMES() antlr.TerminalNode {
	return s.GetToken(DorisParserNAMES, 0)
}

func (s *NonReservedContext) NEGATIVE() antlr.TerminalNode {
	return s.GetToken(DorisParserNEGATIVE, 0)
}

func (s *NonReservedContext) NEVER() antlr.TerminalNode {
	return s.GetToken(DorisParserNEVER, 0)
}

func (s *NonReservedContext) NEXT() antlr.TerminalNode {
	return s.GetToken(DorisParserNEXT, 0)
}

func (s *NonReservedContext) NGRAM_BF() antlr.TerminalNode {
	return s.GetToken(DorisParserNGRAM_BF, 0)
}

func (s *NonReservedContext) NO() antlr.TerminalNode {
	return s.GetToken(DorisParserNO, 0)
}

func (s *NonReservedContext) NON_NULLABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserNON_NULLABLE, 0)
}

func (s *NonReservedContext) NULLS() antlr.TerminalNode {
	return s.GetToken(DorisParserNULLS, 0)
}

func (s *NonReservedContext) OF() antlr.TerminalNode {
	return s.GetToken(DorisParserOF, 0)
}

func (s *NonReservedContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(DorisParserOFFSET, 0)
}

func (s *NonReservedContext) ONLY() antlr.TerminalNode {
	return s.GetToken(DorisParserONLY, 0)
}

func (s *NonReservedContext) OPEN() antlr.TerminalNode {
	return s.GetToken(DorisParserOPEN, 0)
}

func (s *NonReservedContext) OPTIMIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserOPTIMIZED, 0)
}

func (s *NonReservedContext) PARAMETER() antlr.TerminalNode {
	return s.GetToken(DorisParserPARAMETER, 0)
}

func (s *NonReservedContext) PARSED() antlr.TerminalNode {
	return s.GetToken(DorisParserPARSED, 0)
}

func (s *NonReservedContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD, 0)
}

func (s *NonReservedContext) PASSWORD_EXPIRE() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD_EXPIRE, 0)
}

func (s *NonReservedContext) PASSWORD_HISTORY() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD_HISTORY, 0)
}

func (s *NonReservedContext) PASSWORD_LOCK_TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD_LOCK_TIME, 0)
}

func (s *NonReservedContext) PASSWORD_REUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD_REUSE, 0)
}

func (s *NonReservedContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITIONS, 0)
}

func (s *NonReservedContext) PATH() antlr.TerminalNode {
	return s.GetToken(DorisParserPATH, 0)
}

func (s *NonReservedContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserPAUSE, 0)
}

func (s *NonReservedContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(DorisParserPERCENT, 0)
}

func (s *NonReservedContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(DorisParserPERIOD, 0)
}

func (s *NonReservedContext) PERMISSIVE() antlr.TerminalNode {
	return s.GetToken(DorisParserPERMISSIVE, 0)
}

func (s *NonReservedContext) PHYSICAL() antlr.TerminalNode {
	return s.GetToken(DorisParserPHYSICAL, 0)
}

func (s *NonReservedContext) PI() antlr.TerminalNode {
	return s.GetToken(DorisParserPI, 0)
}

func (s *NonReservedContext) PLAN() antlr.TerminalNode {
	return s.GetToken(DorisParserPLAN, 0)
}

func (s *NonReservedContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(DorisParserPLUGIN, 0)
}

func (s *NonReservedContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(DorisParserPLUGINS, 0)
}

func (s *NonReservedContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *NonReservedContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(DorisParserPRIVILEGES, 0)
}

func (s *NonReservedContext) PROC() antlr.TerminalNode {
	return s.GetToken(DorisParserPROC, 0)
}

func (s *NonReservedContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(DorisParserPROCESS, 0)
}

func (s *NonReservedContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(DorisParserPROCESSLIST, 0)
}

func (s *NonReservedContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserPROFILE, 0)
}

func (s *NonReservedContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *NonReservedContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTY, 0)
}

func (s *NonReservedContext) QUANTILE_STATE() antlr.TerminalNode {
	return s.GetToken(DorisParserQUANTILE_STATE, 0)
}

func (s *NonReservedContext) QUANTILE_UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserQUANTILE_UNION, 0)
}

func (s *NonReservedContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DorisParserQUERY, 0)
}

func (s *NonReservedContext) QUOTA() antlr.TerminalNode {
	return s.GetToken(DorisParserQUOTA, 0)
}

func (s *NonReservedContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(DorisParserRANDOM, 0)
}

func (s *NonReservedContext) RECENT() antlr.TerminalNode {
	return s.GetToken(DorisParserRECENT, 0)
}

func (s *NonReservedContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(DorisParserRECOVER, 0)
}

func (s *NonReservedContext) RECYCLE() antlr.TerminalNode {
	return s.GetToken(DorisParserRECYCLE, 0)
}

func (s *NonReservedContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserREFRESH, 0)
}

func (s *NonReservedContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPEATABLE, 0)
}

func (s *NonReservedContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *NonReservedContext) REPLACE_IF_NOT_NULL() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE_IF_NOT_NULL, 0)
}

func (s *NonReservedContext) REPOSITORIES() antlr.TerminalNode {
	return s.GetToken(DorisParserREPOSITORIES, 0)
}

func (s *NonReservedContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisParserREPOSITORY, 0)
}

func (s *NonReservedContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCE, 0)
}

func (s *NonReservedContext) RESOURCES() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCES, 0)
}

func (s *NonReservedContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESTORE, 0)
}

func (s *NonReservedContext) RESTRICTIVE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESTRICTIVE, 0)
}

func (s *NonReservedContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisParserRESUME, 0)
}

func (s *NonReservedContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(DorisParserRETURNS, 0)
}

func (s *NonReservedContext) REWRITTEN() antlr.TerminalNode {
	return s.GetToken(DorisParserREWRITTEN, 0)
}

func (s *NonReservedContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACE, 0)
}

func (s *NonReservedContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserRLIKE, 0)
}

func (s *NonReservedContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLBACK, 0)
}

func (s *NonReservedContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *NonReservedContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserROUTINE, 0)
}

func (s *NonReservedContext) S3() antlr.TerminalNode {
	return s.GetToken(DorisParserS3, 0)
}

func (s *NonReservedContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(DorisParserSAMPLE, 0)
}

func (s *NonReservedContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEDULE, 0)
}

func (s *NonReservedContext) SCHEDULER() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEDULER, 0)
}

func (s *NonReservedContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEMA, 0)
}

func (s *NonReservedContext) SECOND() antlr.TerminalNode {
	return s.GetToken(DorisParserSECOND, 0)
}

func (s *NonReservedContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserSERIALIZABLE, 0)
}

func (s *NonReservedContext) SET_SESSION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserSET_SESSION_VARIABLE, 0)
}

func (s *NonReservedContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(DorisParserSEQUENCE, 0)
}

func (s *NonReservedContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION, 0)
}

func (s *NonReservedContext) SHAPE() antlr.TerminalNode {
	return s.GetToken(DorisParserSHAPE, 0)
}

func (s *NonReservedContext) SKEW() antlr.TerminalNode {
	return s.GetToken(DorisParserSKEW, 0)
}

func (s *NonReservedContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisParserSNAPSHOT, 0)
}

func (s *NonReservedContext) SONAME() antlr.TerminalNode {
	return s.GetToken(DorisParserSONAME, 0)
}

func (s *NonReservedContext) SPLIT() antlr.TerminalNode {
	return s.GetToken(DorisParserSPLIT, 0)
}

func (s *NonReservedContext) SQL() antlr.TerminalNode {
	return s.GetToken(DorisParserSQL, 0)
}

func (s *NonReservedContext) STAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTAGE, 0)
}

func (s *NonReservedContext) STAGES() antlr.TerminalNode {
	return s.GetToken(DorisParserSTAGES, 0)
}

func (s *NonReservedContext) START() antlr.TerminalNode {
	return s.GetToken(DorisParserSTART, 0)
}

func (s *NonReservedContext) STARTS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTARTS, 0)
}

func (s *NonReservedContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *NonReservedContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATUS, 0)
}

func (s *NonReservedContext) STOP() antlr.TerminalNode {
	return s.GetToken(DorisParserSTOP, 0)
}

func (s *NonReservedContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *NonReservedContext) STREAM() antlr.TerminalNode {
	return s.GetToken(DorisParserSTREAM, 0)
}

func (s *NonReservedContext) STREAMING() antlr.TerminalNode {
	return s.GetToken(DorisParserSTREAMING, 0)
}

func (s *NonReservedContext) STRING() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING, 0)
}

func (s *NonReservedContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRUCT, 0)
}

func (s *NonReservedContext) SUBDATE() antlr.TerminalNode {
	return s.GetToken(DorisParserSUBDATE, 0)
}

func (s *NonReservedContext) SUM() antlr.TerminalNode {
	return s.GetToken(DorisParserSUM, 0)
}

func (s *NonReservedContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLES, 0)
}

func (s *NonReservedContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisParserTASK, 0)
}

func (s *NonReservedContext) TASKS() antlr.TerminalNode {
	return s.GetToken(DorisParserTASKS, 0)
}

func (s *NonReservedContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *NonReservedContext) TEXT() antlr.TerminalNode {
	return s.GetToken(DorisParserTEXT, 0)
}

func (s *NonReservedContext) THAN() antlr.TerminalNode {
	return s.GetToken(DorisParserTHAN, 0)
}

func (s *NonReservedContext) TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserTIME, 0)
}

func (s *NonReservedContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserTIMESTAMP, 0)
}

func (s *NonReservedContext) TIMESTAMPADD() antlr.TerminalNode {
	return s.GetToken(DorisParserTIMESTAMPADD, 0)
}

func (s *NonReservedContext) TIMESTAMPDIFF() antlr.TerminalNode {
	return s.GetToken(DorisParserTIMESTAMPDIFF, 0)
}

func (s *NonReservedContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisParserTRANSACTION, 0)
}

func (s *NonReservedContext) TREE() antlr.TerminalNode {
	return s.GetToken(DorisParserTREE, 0)
}

func (s *NonReservedContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(DorisParserTRIGGERS, 0)
}

func (s *NonReservedContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(DorisParserTRUNCATE, 0)
}

func (s *NonReservedContext) TYPE() antlr.TerminalNode {
	return s.GetToken(DorisParserTYPE, 0)
}

func (s *NonReservedContext) TYPES() antlr.TerminalNode {
	return s.GetToken(DorisParserTYPES, 0)
}

func (s *NonReservedContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(DorisParserUNCOMMITTED, 0)
}

func (s *NonReservedContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(DorisParserUNLOCK, 0)
}

func (s *NonReservedContext) UNSET() antlr.TerminalNode {
	return s.GetToken(DorisParserUNSET, 0)
}

func (s *NonReservedContext) UP() antlr.TerminalNode {
	return s.GetToken(DorisParserUP, 0)
}

func (s *NonReservedContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisParserUSER, 0)
}

func (s *NonReservedContext) VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserVALUE, 0)
}

func (s *NonReservedContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserVARCHAR, 0)
}

func (s *NonReservedContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserVARIABLE, 0)
}

func (s *NonReservedContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserVARIABLES, 0)
}

func (s *NonReservedContext) VARIANT() antlr.TerminalNode {
	return s.GetToken(DorisParserVARIANT, 0)
}

func (s *NonReservedContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULT, 0)
}

func (s *NonReservedContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserVERBOSE, 0)
}

func (s *NonReservedContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisParserVERSION, 0)
}

func (s *NonReservedContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *NonReservedContext) WARM() antlr.TerminalNode {
	return s.GetToken(DorisParserWARM, 0)
}

func (s *NonReservedContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(DorisParserWARNINGS, 0)
}

func (s *NonReservedContext) WEEK() antlr.TerminalNode {
	return s.GetToken(DorisParserWEEK, 0)
}

func (s *NonReservedContext) WORK() antlr.TerminalNode {
	return s.GetToken(DorisParserWORK, 0)
}

func (s *NonReservedContext) YEAR() antlr.TerminalNode {
	return s.GetToken(DorisParserYEAR, 0)
}

func (s *NonReservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonReservedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterNonReserved(s)
	}
}

func (s *NonReservedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitNonReserved(s)
	}
}

func (p *DorisParser) NonReserved() (localctx INonReservedContext) {
	localctx = NewNonReservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, DorisParserRULE_nonReserved)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4623)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-9)) & ^0x3f) == 0 && ((int64(1)<<(_la-9))&-254453611183435949) != 0) || ((int64((_la-74)) & ^0x3f) == 0 && ((int64(1)<<(_la-74))&6052837484955959227) != 0) || ((int64((_la-139)) & ^0x3f) == 0 && ((int64(1)<<(_la-139))&8444318919233020697) != 0) || ((int64((_la-204)) & ^0x3f) == 0 && ((int64(1)<<(_la-204))&3704835138813099485) != 0) || ((int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-89811135578243649) != 0) || ((int64((_la-332)) & ^0x3f) == 0 && ((int64(1)<<(_la-332))&-7156229671150084161) != 0) || ((int64((_la-396)) & ^0x3f) == 0 && ((int64(1)<<(_la-396))&-3180798903356594385) != 0) || ((int64((_la-462)) & ^0x3f) == 0 && ((int64(1)<<(_la-462))&8070450825379092011) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *DorisParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 83:
		var t *QueryTermContext = nil
		if localctx != nil {
			t = localctx.(*QueryTermContext)
		}
		return p.QueryTerm_Sempred(t, predIndex)

	case 86:
		var t *QuerySpecificationContext = nil
		if localctx != nil {
			t = localctx.(*QuerySpecificationContext)
		}
		return p.QuerySpecification_Sempred(t, predIndex)

	case 154:
		var t *BooleanExpressionContext = nil
		if localctx != nil {
			t = localctx.(*BooleanExpressionContext)
		}
		return p.BooleanExpression_Sempred(t, predIndex)

	case 158:
		var t *ValueExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ValueExpressionContext)
		}
		return p.ValueExpression_Sempred(t, predIndex)

	case 160:
		var t *PrimaryExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryExpressionContext)
		}
		return p.PrimaryExpression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *DorisParser) QueryTerm_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DorisParser) QuerySpecification_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return doris_legacy_SQL_syntax

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DorisParser) BooleanExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DorisParser) ValueExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DorisParser) PrimaryExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
