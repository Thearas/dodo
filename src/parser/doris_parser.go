// Code generated from ./DorisParser.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // DorisParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type DorisParser struct {
	*antlr.BaseParser
}

var DorisParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func dorisparserParserInit() {
	staticData := &DorisParserParserStaticData
	staticData.LiteralNames = []string{
		"", "';'", "'('", "')'", "','", "'.'", "'...'", "'['", "']'", "'{'",
		"'}'", "'ACCOUNT_LOCK'", "'ACCOUNT_UNLOCK'", "'ACTIONS'", "'ADD'", "'ADMIN'",
		"'AFTER'", "'AGG_STATE'", "'AGGREGATE'", "'ALIAS'", "'ALL'", "'ALTER'",
		"'ANALYZE'", "'ANALYZED'", "'ANALYZER'", "'AND'", "'ANTI'", "'APPEND'",
		"'ARRAY'", "'AS'", "'ASC'", "'AT'", "'AUTHORS'", "'AUTO'", "'AUTO_INCREMENT'",
		"'ALWAYS'", "'BACKEND'", "'BACKENDS'", "'BACKUP'", "'BEGIN'", "'BELONG'",
		"'BETWEEN'", "'BIGINT'", "'BIN'", "'BINARY'", "'BINLOG'", "'BITAND'",
		"'BITMAP'", "'BITMAP_EMPTY'", "'BITMAP_UNION'", "'BITOR'", "'BITXOR'",
		"'BLOB'", "'BOOLEAN'", "'BRANCH'", "'BRIEF'", "'BROKER'", "'BUCKETS'",
		"'BUILD'", "'BUILTIN'", "'BULK'", "'BY'", "'CACHE'", "'CACHED'", "'CALL'",
		"'CANCEL'", "'CASE'", "'CAST'", "'CATALOG'", "'CATALOGS'", "'CHAIN'",
		"", "'CHARSET'", "'CHECK'", "'CLEAN'", "'CLUSTER'", "'CLUSTERS'", "'COLLATE'",
		"'COLLATION'", "'COLLECT'", "'COLOCATE'", "'COLUMN'", "'COLUMNS'", "'COMMENT'",
		"'COMMIT'", "'COMMITTED'", "'COMPACT'", "'COMPLETE'", "'COMPRESS_TYPE'",
		"'COMPUTE'", "'CONDITIONS'", "'CONFIG'", "'CONNECTION'", "'CONNECTION_ID'",
		"'CONSISTENT'", "'CONSTRAINT'", "'CONSTRAINTS'", "'CONVERT'", "'CONVERT_LIGHT_SCHEMA_CHANGE_PROCESS'",
		"'COPY'", "'COUNT'", "'CREATE'", "'CREATION'", "'CRON'", "'CROSS'",
		"'CUBE'", "'CURRENT'", "'CURRENT_CATALOG'", "'CURRENT_DATE'", "'CURRENT_TIME'",
		"'CURRENT_TIMESTAMP'", "'CURRENT_USER'", "'DATA'", "'DATABASE'", "'DATABASES'",
		"'DATE'", "'DATETIME'", "'DATETIMEV2'", "'DATEV2'", "'DATETIMEV1'",
		"'DATEV1'", "'DAY'", "'DAYS'", "'DECIMAL'", "'DECIMALV2'", "'DECIMALV3'",
		"'DECOMMISSION'", "'DEFAULT'", "'DEFERRED'", "'DELETE'", "'DEMAND'",
		"'DESC'", "'DESCRIBE'", "'DIAGNOSE'", "'DIAGNOSIS'", "'DICTIONARIES'",
		"'DICTIONARY'", "'DISK'", "'DISTINCT'", "'DISTINCTPC'", "'DISTINCTPCSA'",
		"'DISTRIBUTED'", "'DISTRIBUTION'", "'DIV'", "'DO'", "'DORIS_INTERNAL_TABLE_ID'",
		"'DOUBLE'", "'DROP'", "'DROPP'", "'DUAL'", "'DUMP'", "'DUPLICATE'",
		"'DYNAMIC'", "'E'", "'ELSE'", "'ENABLE'", "'ENCRYPTKEY'", "'ENCRYPTKEYS'",
		"'END'", "'ENDS'", "'ENGINE'", "'ENGINES'", "'ENTER'", "'ERRORS'", "'EVENTS'",
		"'EVERY'", "'EXCEPT'", "'EXCLUDE'", "'EXECUTE'", "'EXISTS'", "'EXPIRED'",
		"'EXPLAIN'", "'EXPORT'", "'EXTENDED'", "'EXTERNAL'", "'EXTRACT'", "'FAILED_LOGIN_ATTEMPTS'",
		"'FALSE'", "'FAST'", "'FEATURE'", "'FIELDS'", "'FILE'", "'FILTER'",
		"'FIRST'", "'FLOAT'", "'FOLLOWER'", "'FOLLOWING'", "'FOR'", "'FOREIGN'",
		"'FORCE'", "'FORMAT'", "'FREE'", "'FROM'", "'FRONTEND'", "'FRONTENDS'",
		"'FULL'", "'FUNCTION'", "'FUNCTIONS'", "'GENERATED'", "'GENERIC'", "'GLOBAL'",
		"'GRANT'", "'GRANTS'", "'GRAPH'", "'GROUP'", "'GROUPING'", "'GROUPS'",
		"'HASH'", "'HASH_MAP'", "'HAVING'", "'HDFS'", "'HELP'", "'HISTOGRAM'",
		"'HLL'", "'HLL_UNION'", "'HOSTNAME'", "'HOTSPOT'", "'HOUR'", "'HOURS'",
		"'HUB'", "'IDENTIFIED'", "'IF'", "'IGNORE'", "'IMMEDIATE'", "'IN'",
		"'INCREMENTAL'", "'INDEX'", "'INDEXES'", "'INFILE'", "'INNER'", "'INSERT'",
		"'INSTALL'", "'INT'", "'INTEGER'", "'INTERMEDIATE'", "'INTERSECT'",
		"'INTERVAL'", "'INTO'", "'INVERTED'", "'IP_TRIE'", "'IPV4'", "'IPV6'",
		"'IS'", "'IS_NOT_NULL_PRED'", "'IS_NULL_PRED'", "'ISNULL'", "'ISOLATION'",
		"'JOB'", "'JOBS'", "'JOIN'", "'JSON'", "'JSONB'", "'KEY'", "'KEYS'",
		"'KILL'", "'LABEL'", "'LARGEINT'", "'LAYOUT'", "'LAST'", "'LATERAL'",
		"'LDAP'", "'LDAP_ADMIN_PASSWORD'", "'LEFT'", "'LESS'", "'LEVEL'", "'LIKE'",
		"'LIMIT'", "'LINES'", "'LINK'", "'LIST'", "'LOAD'", "'LOCAL'", "'LOCALTIME'",
		"'LOCALTIMESTAMP'", "'LOCATION'", "'LOCK'", "'LOGICAL'", "'LOW_PRIORITY'",
		"'MANUAL'", "'MAP'", "'MATCH'", "'MATCH_ALL'", "'MATCH_ANY'", "'MATCH_PHRASE'",
		"'MATCH_PHRASE_EDGE'", "'MATCH_PHRASE_PREFIX'", "'MATCH_REGEXP'", "'MATERIALIZED'",
		"'MAX'", "'MAXVALUE'", "'MEMO'", "'MERGE'", "'MIGRATE'", "'MIGRATIONS'",
		"'MIN'", "'MINUS'", "'MINUTE'", "'MINUTES'", "'MODIFY'", "'MONTH'",
		"'MTMV'", "'NAME'", "'NAMES'", "'NATURAL'", "'NEGATIVE'", "'NEVER'",
		"'NEXT'", "'NGRAM_BF'", "'NO'", "'NO_USE_MV'", "'NON_NULLABLE'", "'NOT'",
		"'NULL'", "'NULLS'", "'OBSERVER'", "'OF'", "'OFFSET'", "'ON'", "'ONLY'",
		"'OPEN'", "'OPTIMIZED'", "'OR'", "'ORDER'", "'OUTER'", "'OUTFILE'",
		"'OVER'", "'OVERWRITE'", "'PARAMETER'", "'PARSED'", "'PARTITION'", "'PARTITIONS'",
		"'PASSWORD'", "'PASSWORD_EXPIRE'", "'PASSWORD_HISTORY'", "'PASSWORD_LOCK_TIME'",
		"'PASSWORD_REUSE'", "'PATH'", "'PAUSE'", "'PERCENT'", "'PERIOD'", "'PERMISSIVE'",
		"'PHYSICAL'", "'PI'", "'?'", "'PLAN'", "'PLAY'", "'PRIVILEGES'", "'PROCESS'",
		"'PLUGIN'", "'PLUGINS'", "'POLICY'", "'PRECEDING'", "'PREPARE'", "'PRIMARY'",
		"'PROC'", "'PROCEDURE'", "'PROCESSLIST'", "'PROFILE'", "'PROPERTIES'",
		"'PROPERTY'", "'QUANTILE_STATE'", "'QUANTILE_UNION'", "'QUERY'", "'QUEUED'",
		"'QUOTA'", "'QUALIFY'", "'QUARTER'", "'RANDOM'", "'RANGE'", "'READ'",
		"'REAL'", "'REBALANCE'", "'RECENT'", "'RECOVER'", "'RECYCLE'", "'REFRESH'",
		"'REFERENCES'", "'REGEXP'", "'RELEASE'", "'RENAME'", "'REPAIR'", "'REPEATABLE'",
		"'REPLACE'", "'REPLACE_IF_NOT_NULL'", "'REPLAYER'", "'REPLICA'", "'REPOSITORIES'",
		"'REPOSITORY'", "'RESOURCE'", "'RESOURCES'", "'RESTORE'", "'RESTRICTIVE'",
		"'RESUME'", "'RETAIN'", "'RETENTION'", "'RETURNS'", "'REVOKE'", "'REWRITTEN'",
		"'RIGHT'", "'RLIKE'", "'ROLE'", "'ROLES'", "'ROLLBACK'", "'ROLLUP'",
		"'ROUTINE'", "'ROW'", "'ROWS'", "'S3'", "'SAMPLE'", "'SCHEDULE'", "'SCHEDULER'",
		"'SCHEMA'", "'SCHEMAS'", "'SECOND'", "'SELECT'", "'SEMI'", "'SERIALIZABLE'",
		"'SESSION'", "'SESSION_USER'", "'SET'", "'SETS'", "'SET_SESSION_VARIABLE'",
		"'SHAPE'", "'SHOW'", "'SIGNED'", "'SKEW'", "'SMALLINT'", "'SNAPSHOT'",
		"'SNAPSHOTS'", "'SONAME'", "'SPLIT'", "'SQL'", "'SQL_BLOCK_RULE'", "'STAGE'",
		"'STAGES'", "'START'", "'STARTS'", "'STATS'", "'STATUS'", "'STOP'",
		"'STORAGE'", "'STREAM'", "'STREAMING'", "'STRING'", "'STRUCT'", "'SUM'",
		"'SUPERUSER'", "'SWITCH'", "'SYNC'", "'SYSTEM'", "'TABLE'", "'TABLES'",
		"'TABLESAMPLE'", "'TABLET'", "'TABLETS'", "'TAG'", "'TASK'", "'TASKS'",
		"'TEMPORARY'", "'TERMINATED'", "'TEXT'", "'THAN'", "'THEN'", "'TIME'",
		"'TIMESTAMP'", "'TINYINT'", "'TO'", "'TOKENIZER'", "'TOKEN_FILTER'",
		"'TRANSACTION'", "'TRASH'", "'TREE'", "'TRIGGERS'", "'TRIM'", "'TRUE'",
		"'TRUNCATE'", "'TYPE'", "'TYPE_CAST'", "'TYPES'", "'UNBOUNDED'", "'UNCOMMITTED'",
		"'UNINSTALL'", "'UNION'", "'UNIQUE'", "'UNLOCK'", "'UNSET'", "'UNSIGNED'",
		"'UP'", "'UPDATE'", "'USE'", "'USER'", "'USE_MV'", "'USING'", "'VALUE'",
		"'VALUES'", "'VARCHAR'", "'VARIABLE'", "'VARIABLES'", "'VARIANT'", "'VAULT'",
		"'VAULTS'", "'VERBOSE'", "'VERSION'", "'VIEW'", "'VIEWS'", "'WARM'",
		"'WARNINGS'", "'WEEK'", "'WHEN'", "'WHERE'", "'WHITELIST'", "'WITH'",
		"'WORK'", "'WORKLOAD'", "'WRITE'", "'XOR'", "'YEAR'", "", "'<=>'", "",
		"'<'", "", "'>'", "", "'+'", "'-'", "'*'", "'/'", "'%'", "'~'", "'&'",
		"'&&'", "'!'", "'|'", "'||'", "'^'", "':'", "'->'", "'/*+'", "'*/'",
		"'/*'", "'@'", "'@@'",
	}
	staticData.SymbolicNames = []string{
		"", "SEMICOLON", "LEFT_PAREN", "RIGHT_PAREN", "COMMA", "DOT", "DOTDOTDOT",
		"LEFT_BRACKET", "RIGHT_BRACKET", "LEFT_BRACE", "RIGHT_BRACE", "ACCOUNT_LOCK",
		"ACCOUNT_UNLOCK", "ACTIONS", "ADD", "ADMIN", "AFTER", "AGG_STATE", "AGGREGATE",
		"ALIAS", "ALL", "ALTER", "ANALYZE", "ANALYZED", "ANALYZER", "AND", "ANTI",
		"APPEND", "ARRAY", "AS", "ASC", "AT", "AUTHORS", "AUTO", "AUTO_INCREMENT",
		"ALWAYS", "BACKEND", "BACKENDS", "BACKUP", "BEGIN", "BELONG", "BETWEEN",
		"BIGINT", "BIN", "BINARY", "BINLOG", "BITAND", "BITMAP", "BITMAP_EMPTY",
		"BITMAP_UNION", "BITOR", "BITXOR", "BLOB", "BOOLEAN", "BRANCH", "BRIEF",
		"BROKER", "BUCKETS", "BUILD", "BUILTIN", "BULK", "BY", "CACHE", "CACHED",
		"CALL", "CANCEL", "CASE", "CAST", "CATALOG", "CATALOGS", "CHAIN", "CHAR",
		"CHARSET", "CHECK", "CLEAN", "CLUSTER", "CLUSTERS", "COLLATE", "COLLATION",
		"COLLECT", "COLOCATE", "COLUMN", "COLUMNS", "COMMENT", "COMMIT", "COMMITTED",
		"COMPACT", "COMPLETE", "COMPRESS_TYPE", "COMPUTE", "CONDITIONS", "CONFIG",
		"CONNECTION", "CONNECTION_ID", "CONSISTENT", "CONSTRAINT", "CONSTRAINTS",
		"CONVERT", "CONVERT_LSC", "COPY", "COUNT", "CREATE", "CREATION", "CRON",
		"CROSS", "CUBE", "CURRENT", "CURRENT_CATALOG", "CURRENT_DATE", "CURRENT_TIME",
		"CURRENT_TIMESTAMP", "CURRENT_USER", "DATA", "DATABASE", "DATABASES",
		"DATE", "DATETIME", "DATETIMEV2", "DATEV2", "DATETIMEV1", "DATEV1",
		"DAY", "DAYS", "DECIMAL", "DECIMALV2", "DECIMALV3", "DECOMMISSION",
		"DEFAULT", "DEFERRED", "DELETE", "DEMAND", "DESC", "DESCRIBE", "DIAGNOSE",
		"DIAGNOSIS", "DICTIONARIES", "DICTIONARY", "DISK", "DISTINCT", "DISTINCTPC",
		"DISTINCTPCSA", "DISTRIBUTED", "DISTRIBUTION", "DIV", "DO", "DORIS_INTERNAL_TABLE_ID",
		"DOUBLE", "DROP", "DROPP", "DUAL", "DUMP", "DUPLICATE", "DYNAMIC", "E",
		"ELSE", "ENABLE", "ENCRYPTKEY", "ENCRYPTKEYS", "END", "ENDS", "ENGINE",
		"ENGINES", "ENTER", "ERRORS", "EVENTS", "EVERY", "EXCEPT", "EXCLUDE",
		"EXECUTE", "EXISTS", "EXPIRED", "EXPLAIN", "EXPORT", "EXTENDED", "EXTERNAL",
		"EXTRACT", "FAILED_LOGIN_ATTEMPTS", "FALSE", "FAST", "FEATURE", "FIELDS",
		"FILE", "FILTER", "FIRST", "FLOAT", "FOLLOWER", "FOLLOWING", "FOR",
		"FOREIGN", "FORCE", "FORMAT", "FREE", "FROM", "FRONTEND", "FRONTENDS",
		"FULL", "FUNCTION", "FUNCTIONS", "GENERATED", "GENERIC", "GLOBAL", "GRANT",
		"GRANTS", "GRAPH", "GROUP", "GROUPING", "GROUPS", "HASH", "HASH_MAP",
		"HAVING", "HDFS", "HELP", "HISTOGRAM", "HLL", "HLL_UNION", "HOSTNAME",
		"HOTSPOT", "HOUR", "HOURS", "HUB", "IDENTIFIED", "IF", "IGNORE", "IMMEDIATE",
		"IN", "INCREMENTAL", "INDEX", "INDEXES", "INFILE", "INNER", "INSERT",
		"INSTALL", "INT", "INTEGER", "INTERMEDIATE", "INTERSECT", "INTERVAL",
		"INTO", "INVERTED", "IP_TRIE", "IPV4", "IPV6", "IS", "IS_NOT_NULL_PRED",
		"IS_NULL_PRED", "ISNULL", "ISOLATION", "JOB", "JOBS", "JOIN", "JSON",
		"JSONB", "KEY", "KEYS", "KILL", "LABEL", "LARGEINT", "LAYOUT", "LAST",
		"LATERAL", "LDAP", "LDAP_ADMIN_PASSWORD", "LEFT", "LESS", "LEVEL", "LIKE",
		"LIMIT", "LINES", "LINK", "LIST", "LOAD", "LOCAL", "LOCALTIME", "LOCALTIMESTAMP",
		"LOCATION", "LOCK", "LOGICAL", "LOW_PRIORITY", "MANUAL", "MAP", "MATCH",
		"MATCH_ALL", "MATCH_ANY", "MATCH_PHRASE", "MATCH_PHRASE_EDGE", "MATCH_PHRASE_PREFIX",
		"MATCH_REGEXP", "MATERIALIZED", "MAX", "MAXVALUE", "MEMO", "MERGE",
		"MIGRATE", "MIGRATIONS", "MIN", "MINUS", "MINUTE", "MINUTES", "MODIFY",
		"MONTH", "MTMV", "NAME", "NAMES", "NATURAL", "NEGATIVE", "NEVER", "NEXT",
		"NGRAM_BF", "NO", "NO_USE_MV", "NON_NULLABLE", "NOT", "NULL", "NULLS",
		"OBSERVER", "OF", "OFFSET", "ON", "ONLY", "OPEN", "OPTIMIZED", "OR",
		"ORDER", "OUTER", "OUTFILE", "OVER", "OVERWRITE", "PARAMETER", "PARSED",
		"PARTITION", "PARTITIONS", "PASSWORD", "PASSWORD_EXPIRE", "PASSWORD_HISTORY",
		"PASSWORD_LOCK_TIME", "PASSWORD_REUSE", "PATH", "PAUSE", "PERCENT",
		"PERIOD", "PERMISSIVE", "PHYSICAL", "PI", "PLACEHOLDER", "PLAN", "PLAY",
		"PRIVILEGES", "PROCESS", "PLUGIN", "PLUGINS", "POLICY", "PRECEDING",
		"PREPARE", "PRIMARY", "PROC", "PROCEDURE", "PROCESSLIST", "PROFILE",
		"PROPERTIES", "PROPERTY", "QUANTILE_STATE", "QUANTILE_UNION", "QUERY",
		"QUEUED", "QUOTA", "QUALIFY", "QUARTER", "RANDOM", "RANGE", "READ",
		"REAL", "REBALANCE", "RECENT", "RECOVER", "RECYCLE", "REFRESH", "REFERENCES",
		"REGEXP", "RELEASE", "RENAME", "REPAIR", "REPEATABLE", "REPLACE", "REPLACE_IF_NOT_NULL",
		"REPLAYER", "REPLICA", "REPOSITORIES", "REPOSITORY", "RESOURCE", "RESOURCES",
		"RESTORE", "RESTRICTIVE", "RESUME", "RETAIN", "RETENTION", "RETURNS",
		"REVOKE", "REWRITTEN", "RIGHT", "RLIKE", "ROLE", "ROLES", "ROLLBACK",
		"ROLLUP", "ROUTINE", "ROW", "ROWS", "S3", "SAMPLE", "SCHEDULE", "SCHEDULER",
		"SCHEMA", "SCHEMAS", "SECOND", "SELECT", "SEMI", "SERIALIZABLE", "SESSION",
		"SESSION_USER", "SET", "SETS", "SET_SESSION_VARIABLE", "SHAPE", "SHOW",
		"SIGNED", "SKEW", "SMALLINT", "SNAPSHOT", "SNAPSHOTS", "SONAME", "SPLIT",
		"SQL", "SQL_BLOCK_RULE", "STAGE", "STAGES", "START", "STARTS", "STATS",
		"STATUS", "STOP", "STORAGE", "STREAM", "STREAMING", "STRING", "STRUCT",
		"SUM", "SUPERUSER", "SWITCH", "SYNC", "SYSTEM", "TABLE", "TABLES", "TABLESAMPLE",
		"TABLET", "TABLETS", "TAG", "TASK", "TASKS", "TEMPORARY", "TERMINATED",
		"TEXT", "THAN", "THEN", "TIME", "TIMESTAMP", "TINYINT", "TO", "TOKENIZER",
		"TOKEN_FILTER", "TRANSACTION", "TRASH", "TREE", "TRIGGERS", "TRIM",
		"TRUE", "TRUNCATE", "TYPE", "TYPECAST", "TYPES", "UNBOUNDED", "UNCOMMITTED",
		"UNINSTALL", "UNION", "UNIQUE", "UNLOCK", "UNSET", "UNSIGNED", "UP",
		"UPDATE", "USE", "USER", "USE_MV", "USING", "VALUE", "VALUES", "VARCHAR",
		"VARIABLE", "VARIABLES", "VARIANT", "VAULT", "VAULTS", "VERBOSE", "VERSION",
		"VIEW", "VIEWS", "WARM", "WARNINGS", "WEEK", "WHEN", "WHERE", "WHITELIST",
		"WITH", "WORK", "WORKLOAD", "WRITE", "XOR", "YEAR", "EQ", "NSEQ", "NEQ",
		"LT", "LTE", "GT", "GTE", "PLUS", "SUBTRACT", "ASTERISK", "SLASH", "MOD",
		"TILDE", "AMPERSAND", "LOGICALAND", "LOGICALNOT", "PIPE", "DOUBLEPIPES",
		"HAT", "COLON", "ARROW", "HINT_START", "HINT_END", "COMMENT_START",
		"ATSIGN", "DOUBLEATSIGN", "STRING_LITERAL", "LEADING_STRING", "BIGINT_LITERAL",
		"SMALLINT_LITERAL", "TINYINT_LITERAL", "INTEGER_VALUE", "EXPONENT_VALUE",
		"DECIMAL_VALUE", "BIGDECIMAL_LITERAL", "IDENTIFIER", "BACKQUOTED_IDENTIFIER",
		"SIMPLE_COMMENT", "BRACKETED_COMMENT", "FROM_DUAL", "WS", "UNRECOGNIZED",
	}
	staticData.RuleNames = []string{
		"multiStatements", "singleStatement", "statement", "statementBase",
		"unsupportedStatement", "materializedViewStatement", "supportedJobStatement",
		"constraintStatement", "supportedDmlStatement", "supportedCreateStatement",
		"dictionaryColumnDefs", "dictionaryColumnDef", "supportedAlterStatement",
		"supportedDropStatement", "supportedShowStatement", "supportedLoadStatement",
		"supportedKillStatement", "supportedOtherStatement", "unsupportedOtherStatement",
		"warmUpItem", "lockTable", "createRoutineLoad", "unsupportedLoadStatement",
		"loadProperty", "importSequenceStatement", "importDeleteOnStatement",
		"importWhereStatement", "importPrecedingFilterStatement", "importColumnsStatement",
		"importColumnDesc", "supportedRefreshStatement", "supportedCleanStatement",
		"supportedCancelStatement", "supportedAdminStatement", "supportedRecoverStatement",
		"unsupportedAdminStatement", "baseTableRef", "wildWhere", "supportedTransactionStatement",
		"supportedGrantRevokeStatement", "privilege", "privilegeList", "alterSystemClause",
		"dropRollupClause", "addRollupClause", "alterTableClause", "createOrReplaceTagClause",
		"createOrReplaceBranchClause", "tagOptions", "branchOptions", "retainTime",
		"retentionSnapshot", "minSnapshotsToKeep", "timeValueWithUnit", "columnPosition",
		"toRollup", "fromRollup", "supportedStatsStatement", "unsupportedStatsStatement",
		"analyzeProperties", "workloadPolicyActions", "workloadPolicyAction",
		"workloadPolicyConditions", "workloadPolicyCondition", "storageBackend",
		"passwordOption", "functionArguments", "dataTypeList", "supportedSetStatement",
		"optionWithType", "optionWithoutType", "variable", "transactionAccessMode",
		"isolationLevel", "supportedUnsetStatement", "supportedUseStatement",
		"stageAndPattern", "supportedDescribeStatement", "constraint", "partitionSpec",
		"partitionTable", "identityOrFunctionList", "identityOrFunction", "dataDesc",
		"statementScope", "buildMode", "refreshTrigger", "refreshSchedule",
		"refreshMethod", "mvPartition", "identifierOrText", "identifierOrTextOrAsterisk",
		"multipartIdentifierOrAsterisk", "identifierOrAsterisk", "userIdentify",
		"grantUserIdentify", "explain", "explainCommand", "planType", "replayCommand",
		"replayType", "mergeType", "preFilterClause", "deleteOnClause", "sequenceColClause",
		"colFromPath", "colMappingList", "mappingExpr", "withRemoteStorageSystem",
		"resourceDesc", "mysqlDataDesc", "skipLines", "outFileClause", "query",
		"queryTerm", "setQuantifier", "queryPrimary", "querySpecification",
		"cte", "aliasQuery", "columnAliases", "selectClause", "selectColumnClause",
		"whereClause", "fromClause", "intoClause", "bulkCollectClause", "tableRow",
		"relations", "relation", "joinRelation", "distributeType", "relationHint",
		"aggClause", "groupingElement", "groupingSet", "havingClause", "qualifyClause",
		"selectHint", "hintStatement", "hintAssignment", "updateAssignment",
		"updateAssignmentSeq", "lateralView", "queryOrganization", "sortClause",
		"sortItem", "limitClause", "partitionClause", "joinType", "joinCriteria",
		"identifierList", "identifierSeq", "optScanParams", "relationPrimary",
		"materializedViewName", "propertyClause", "propertyItemList", "propertyItem",
		"propertyKey", "propertyValue", "tableAlias", "multipartIdentifier",
		"simpleColumnDefs", "simpleColumnDef", "columnDefs", "columnDef", "indexDefs",
		"indexDef", "partitionsDef", "partitionDef", "lessThanPartitionDef",
		"fixedPartitionDef", "stepPartitionDef", "inPartitionDef", "partitionValueList",
		"partitionValueDef", "rollupDefs", "rollupDef", "aggTypeDef", "tabletList",
		"inlineTable", "namedExpression", "namedExpressionSeq", "expression",
		"lambdaExpression", "booleanExpression", "rowConstructor", "rowConstructorItem",
		"predicate", "valueExpression", "primaryExpression", "exceptOrReplace",
		"castDataType", "functionCallExpression", "functionIdentifier", "functionNameIdentifier",
		"windowSpec", "windowFrame", "frameUnits", "frameBoundary", "qualifiedName",
		"specifiedPartition", "constant", "comparisonOperator", "booleanValue",
		"whenClause", "interval", "unitIdentifier", "dataTypeWithNullable",
		"dataType", "primitiveColType", "complexColTypeList", "complexColType",
		"commentSpec", "sample", "sampleMethod", "tableSnapshot", "errorCapturingIdentifier",
		"errorCapturingIdentifierExtra", "identifier", "strictIdentifier", "quotedIdentifier",
		"number", "nonReserved",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 558, 6285, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7,
		198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2,
		203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7,
		207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2,
		212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7,
		216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2,
		221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 1, 0, 5, 0,
		452, 8, 0, 10, 0, 12, 0, 455, 9, 0, 1, 0, 3, 0, 458, 8, 0, 1, 0, 4, 0,
		461, 8, 0, 11, 0, 12, 0, 462, 1, 0, 5, 0, 466, 8, 0, 10, 0, 12, 0, 469,
		9, 0, 1, 0, 5, 0, 472, 8, 0, 10, 0, 12, 0, 475, 9, 0, 1, 0, 1, 0, 1, 1,
		5, 1, 480, 8, 1, 10, 1, 12, 1, 483, 9, 1, 1, 1, 3, 1, 486, 8, 1, 1, 1,
		5, 1, 489, 8, 1, 10, 1, 12, 1, 492, 9, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 5, 2, 503, 8, 2, 10, 2, 12, 2, 506, 9, 2, 3, 2,
		508, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 516, 8, 2, 1, 2, 3,
		2, 519, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 5, 2, 525, 8, 2, 10, 2, 12, 2, 528,
		9, 2, 1, 2, 1, 2, 5, 2, 532, 8, 2, 10, 2, 12, 2, 535, 9, 2, 1, 2, 1, 2,
		1, 2, 1, 2, 3, 2, 541, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		3, 2, 550, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 557, 8, 2, 1, 2, 1,
		2, 1, 2, 1, 2, 1, 2, 3, 2, 564, 8, 2, 1, 2, 1, 2, 3, 2, 568, 8, 2, 3, 2,
		570, 8, 2, 1, 3, 3, 3, 573, 8, 3, 1, 3, 1, 3, 3, 3, 577, 8, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 603,
		8, 3, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 609, 8, 4, 1, 5, 1, 5, 1, 5, 1, 5,
		1, 5, 1, 5, 3, 5, 617, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 624, 8,
		5, 1, 5, 3, 5, 627, 8, 5, 1, 5, 1, 5, 3, 5, 631, 8, 5, 1, 5, 3, 5, 634,
		8, 5, 3, 5, 636, 8, 5, 1, 5, 3, 5, 639, 8, 5, 1, 5, 1, 5, 3, 5, 643, 8,
		5, 1, 5, 1, 5, 3, 5, 647, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3,
		5, 655, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 662, 8, 5, 1, 5, 1, 5,
		3, 5, 666, 8, 5, 3, 5, 668, 8, 5, 1, 5, 3, 5, 671, 8, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 683, 8, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 697,
		8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 705, 8, 5, 1, 5, 1, 5,
		1, 5, 1, 5, 1, 5, 3, 5, 712, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5,
		719, 8, 5, 1, 5, 1, 5, 1, 5, 3, 5, 724, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 750, 8, 5, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 763, 8,
		6, 3, 6, 765, 8, 6, 1, 6, 1, 6, 3, 6, 769, 8, 6, 1, 6, 1, 6, 1, 6, 3, 6,
		774, 8, 6, 3, 6, 776, 8, 6, 1, 6, 3, 6, 779, 8, 6, 1, 6, 1, 6, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 795,
		8, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6,
		1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6,
		3, 6, 820, 8, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7,
		1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 841,
		8, 7, 1, 8, 3, 8, 844, 8, 8, 1, 8, 3, 8, 847, 8, 8, 1, 8, 1, 8, 1, 8, 1,
		8, 3, 8, 853, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 860, 8, 8, 1, 8,
		3, 8, 863, 8, 8, 1, 8, 1, 8, 1, 8, 3, 8, 868, 8, 8, 1, 8, 3, 8, 871, 8,
		8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 877, 8, 8, 1, 8, 1, 8, 3, 8, 881, 8, 8,
		1, 8, 3, 8, 884, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 892, 8,
		8, 1, 8, 3, 8, 895, 8, 8, 1, 8, 3, 8, 898, 8, 8, 1, 8, 3, 8, 901, 8, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 907, 8, 8, 1, 8, 1, 8, 1, 8, 3, 8, 912, 8,
		8, 1, 8, 3, 8, 915, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 5,
		8, 924, 8, 8, 10, 8, 12, 8, 927, 9, 8, 1, 8, 1, 8, 3, 8, 931, 8, 8, 1,
		8, 3, 8, 934, 8, 8, 1, 8, 3, 8, 937, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		3, 8, 944, 8, 8, 1, 8, 3, 8, 947, 8, 8, 1, 8, 1, 8, 1, 8, 3, 8, 952, 8,
		8, 1, 8, 3, 8, 955, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 961, 8, 8, 1, 8,
		1, 8, 3, 8, 965, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		3, 8, 975, 8, 8, 1, 8, 1, 8, 3, 8, 979, 8, 8, 1, 8, 3, 8, 982, 8, 8, 1,
		8, 1, 8, 1, 8, 1, 8, 3, 8, 988, 8, 8, 1, 8, 3, 8, 991, 8, 8, 3, 8, 993,
		8, 8, 1, 9, 1, 9, 3, 9, 997, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1003,
		8, 9, 1, 9, 1, 9, 3, 9, 1007, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1013,
		8, 9, 1, 9, 3, 9, 1016, 8, 9, 1, 9, 1, 9, 3, 9, 1020, 8, 9, 1, 9, 1, 9,
		1, 9, 3, 9, 1025, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1033,
		8, 9, 3, 9, 1035, 8, 9, 1, 9, 1, 9, 3, 9, 1039, 8, 9, 1, 9, 3, 9, 1042,
		8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1049, 8, 9, 1, 9, 1, 9, 1, 9,
		3, 9, 1054, 8, 9, 3, 9, 1056, 8, 9, 3, 9, 1058, 8, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 3, 9, 1065, 8, 9, 1, 9, 3, 9, 1068, 8, 9, 1, 9, 1, 9, 3, 9,
		1072, 8, 9, 1, 9, 1, 9, 3, 9, 1076, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1081,
		8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1087, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 3, 9, 1094, 8, 9, 1, 9, 1, 9, 3, 9, 1098, 8, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1108, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9,
		1113, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1119, 8, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 3, 9, 1127, 8, 9, 3, 9, 1129, 8, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 3, 9, 1136, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1141, 8, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1149, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9,
		1154, 8, 9, 1, 9, 3, 9, 1157, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9,
		1164, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1170, 8, 9, 1, 9, 1, 9, 3, 9,
		1174, 8, 9, 1, 9, 3, 9, 1177, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		3, 9, 1185, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		3, 9, 1196, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 3, 9, 1209, 8, 9, 1, 9, 1, 9, 3, 9, 1213, 8, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1221, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		3, 9, 1228, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1236, 8, 9,
		1, 9, 3, 9, 1239, 8, 9, 1, 9, 1, 9, 3, 9, 1243, 8, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 3, 9, 1251, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		3, 9, 1259, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1266, 8, 9, 1, 9,
		3, 9, 1269, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1276, 8, 9, 1, 9,
		1, 9, 3, 9, 1280, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1287, 8, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1295, 8, 9, 1, 9, 3, 9, 1298,
		8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1304, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9,
		1309, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1316, 8, 9, 1, 9, 3, 9,
		1319, 8, 9, 1, 9, 1, 9, 3, 9, 1323, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		3, 9, 1330, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1335, 8, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 3, 9, 1342, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 3, 9, 1353, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1360,
		8, 9, 1, 9, 1, 9, 3, 9, 1364, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9,
		1371, 8, 9, 1, 9, 1, 9, 3, 9, 1375, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1380,
		8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1389, 8, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 3, 9, 1395, 8, 9, 1, 9, 1, 9, 3, 9, 1399, 8, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1406, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1419, 8, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 3, 9, 1426, 8, 9, 1, 9, 1, 9, 3, 9, 1430, 8, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1438, 8, 9, 1, 9, 1, 9, 3, 9, 1442, 8, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1451, 8, 9, 1, 9, 1, 9,
		3, 9, 1455, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1464,
		8, 9, 1, 9, 1, 9, 3, 9, 1468, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 3, 9, 1477, 8, 9, 1, 9, 1, 9, 3, 9, 1481, 8, 9, 3, 9, 1483, 8, 9,
		1, 10, 1, 10, 1, 10, 5, 10, 1488, 8, 10, 10, 10, 12, 10, 1491, 9, 10, 1,
		11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1508, 8, 12, 1, 12, 1, 12, 3, 12, 1512,
		8, 12, 1, 12, 1, 12, 3, 12, 1516, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1541, 8,
		12, 1, 12, 3, 12, 1544, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1560, 8,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1566, 8, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 5, 12, 1593, 8, 12, 10, 12, 12, 12, 1596, 9, 12, 1, 12, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 5, 12, 1606, 8, 12, 10, 12, 12,
		12, 1609, 9, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		5, 12, 1619, 8, 12, 10, 12, 12, 12, 1622, 9, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 3, 12, 1640, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1663, 8, 12, 1, 12, 1, 12, 1,
		12, 1, 12, 3, 12, 1669, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		3, 12, 1677, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1685,
		8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 3, 12, 1700, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		3, 12, 1706, 8, 12, 3, 12, 1708, 8, 12, 1, 13, 1, 13, 1, 13, 1, 13, 1,
		13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1722, 8, 13,
		1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1729, 8, 13, 1, 13, 1, 13, 1,
		13, 1, 13, 1, 13, 3, 13, 1736, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13,
		3, 13, 1743, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1751,
		8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1759, 8, 13, 1,
		13, 1, 13, 1, 13, 3, 13, 1764, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13,
		1770, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1778, 8,
		13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1786, 8, 13, 1, 13,
		1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1796, 8, 13, 1,
		13, 1, 13, 3, 13, 1800, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1806,
		8, 13, 1, 13, 1, 13, 3, 13, 1810, 8, 13, 1, 13, 1, 13, 3, 13, 1814, 8,
		13, 1, 13, 1, 13, 1, 13, 3, 13, 1819, 8, 13, 1, 13, 1, 13, 1, 13, 3, 13,
		1824, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1832, 8,
		13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1842,
		8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1850, 8, 13, 1,
		13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1859, 8, 13, 3, 13,
		1861, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1867, 8, 13, 1, 13, 1,
		13, 1, 13, 1, 13, 1, 13, 3, 13, 1874, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13,
		1, 13, 3, 13, 1881, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1,
		13, 3, 13, 1890, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13,
		3, 13, 1899, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3,
		13, 1908, 8, 13, 1, 13, 3, 13, 1911, 8, 13, 1, 14, 1, 14, 3, 14, 1915,
		8, 14, 1, 14, 1, 14, 3, 14, 1919, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 1930, 8, 14, 1, 14, 1, 14, 3, 14,
		1934, 8, 14, 1, 14, 3, 14, 1937, 8, 14, 1, 14, 3, 14, 1940, 8, 14, 1, 14,
		3, 14, 1943, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 3, 14, 1953, 8, 14, 1, 14, 3, 14, 1956, 8, 14, 1, 14, 1, 14, 1, 14,
		1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 1965, 8, 14, 1, 14, 3, 14, 1968, 8,
		14, 1, 14, 3, 14, 1971, 8, 14, 1, 14, 3, 14, 1974, 8, 14, 1, 14, 1, 14,
		1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 1982, 8, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 3, 14, 1988, 8, 14, 1, 14, 3, 14, 1991, 8, 14, 1, 14, 1, 14, 1, 14,
		1, 14, 3, 14, 1997, 8, 14, 1, 14, 3, 14, 2000, 8, 14, 1, 14, 3, 14, 2003,
		8, 14, 1, 14, 3, 14, 2006, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 3, 14, 2015, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2021,
		8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2026, 8, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 3, 14, 2032, 8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2037, 8, 14, 1, 14,
		1, 14, 3, 14, 2041, 8, 14, 1, 14, 3, 14, 2044, 8, 14, 1, 14, 1, 14, 1,
		14, 3, 14, 2049, 8, 14, 1, 14, 1, 14, 3, 14, 2053, 8, 14, 1, 14, 1, 14,
		1, 14, 3, 14, 2058, 8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2063, 8, 14, 1,
		14, 1, 14, 3, 14, 2067, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14,
		1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2079, 8, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 3, 14, 2085, 8, 14, 1, 14, 3, 14, 2088, 8, 14, 1, 14, 1, 14, 1, 14,
		1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2101, 8,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14,
		1, 14, 3, 14, 2114, 8, 14, 1, 14, 1, 14, 3, 14, 2118, 8, 14, 1, 14, 1,
		14, 3, 14, 2122, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2129,
		8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2134, 8, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 3, 14, 2140, 8, 14, 1, 14, 3, 14, 2143, 8, 14, 1, 14, 3, 14, 2146,
		8, 14, 1, 14, 1, 14, 3, 14, 2150, 8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2155,
		8, 14, 1, 14, 3, 14, 2158, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2174,
		8, 14, 1, 14, 1, 14, 3, 14, 2178, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2191, 8, 14, 1, 14,
		1, 14, 1, 14, 1, 14, 3, 14, 2197, 8, 14, 1, 14, 1, 14, 3, 14, 2201, 8,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2208, 8, 14, 1, 14, 1, 14,
		1, 14, 3, 14, 2213, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 3, 14, 2222, 8, 14, 3, 14, 2224, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14,
		1, 14, 1, 14, 3, 14, 2232, 8, 14, 3, 14, 2234, 8, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 3, 14, 2240, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14,
		1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2252, 8, 14, 1, 14, 1, 14, 3, 14, 2256,
		8, 14, 1, 14, 3, 14, 2259, 8, 14, 1, 14, 3, 14, 2262, 8, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14,
		2275, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14,
		2295, 8, 14, 1, 14, 3, 14, 2298, 8, 14, 1, 14, 3, 14, 2301, 8, 14, 1, 14,
		1, 14, 3, 14, 2305, 8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2310, 8, 14, 1,
		14, 3, 14, 2313, 8, 14, 1, 14, 3, 14, 2316, 8, 14, 1, 14, 3, 14, 2319,
		8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2326, 8, 14, 1, 14, 3,
		14, 2329, 8, 14, 1, 14, 3, 14, 2332, 8, 14, 1, 14, 1, 14, 3, 14, 2336,
		8, 14, 1, 14, 1, 14, 3, 14, 2340, 8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2345,
		8, 14, 1, 14, 3, 14, 2348, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 3, 14, 2359, 8, 14, 1, 14, 3, 14, 2362, 8, 14,
		1, 14, 1, 14, 1, 14, 3, 14, 2367, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 3, 14, 2374, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2381,
		8, 14, 1, 14, 3, 14, 2384, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 3, 14, 2393, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2399,
		8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2405, 8, 14, 1, 14, 1, 14, 3,
		14, 2409, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14,
		1, 14, 5, 14, 2420, 8, 14, 10, 14, 12, 14, 2423, 9, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2435, 8, 14,
		1, 14, 1, 14, 3, 14, 2439, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3,
		14, 2446, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2452, 8, 14, 1, 14,
		3, 14, 2455, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2461, 8, 14, 1,
		14, 1, 14, 3, 14, 2465, 8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2470, 8, 14,
		1, 14, 3, 14, 2473, 8, 14, 1, 14, 1, 14, 3, 14, 2477, 8, 14, 1, 14, 1,
		14, 1, 14, 3, 14, 2482, 8, 14, 1, 14, 3, 14, 2485, 8, 14, 1, 14, 1, 14,
		1, 14, 1, 14, 1, 14, 3, 14, 2492, 8, 14, 1, 14, 3, 14, 2495, 8, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 3, 14, 2501, 8, 14, 1, 14, 3, 14, 2504, 8, 14,
		1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2511, 8, 14, 1, 14, 3, 14, 2514,
		8, 14, 1, 14, 3, 14, 2517, 8, 14, 1, 14, 3, 14, 2520, 8, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2528, 8, 14, 1, 14, 1, 14, 1, 14,
		1, 14, 1, 14, 1, 14, 3, 14, 2536, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3,
		14, 2542, 8, 14, 1, 14, 3, 14, 2545, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14,
		1, 14, 1, 14, 3, 14, 2553, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3,
		14, 2560, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2566, 8, 14, 1, 14,
		3, 14, 2569, 8, 14, 1, 14, 3, 14, 2572, 8, 14, 1, 14, 3, 14, 2575, 8, 14,
		1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2586,
		8, 14, 3, 14, 2588, 8, 14, 3, 14, 2590, 8, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 3, 14, 2598, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14,
		3, 14, 2605, 8, 14, 3, 14, 2607, 8, 14, 1, 15, 1, 15, 1, 15, 1, 15, 3,
		15, 2613, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15,
		1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15,
		1, 15, 3, 15, 2645, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3,
		15, 2653, 8, 15, 3, 15, 2655, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15,
		1, 15, 3, 15, 2663, 8, 15, 1, 15, 3, 15, 2666, 8, 15, 1, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15,
		2680, 8, 15, 1, 16, 1, 16, 3, 16, 2684, 8, 16, 1, 16, 1, 16, 1, 16, 1,
		16, 3, 16, 2690, 8, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17,
		1, 17, 1, 17, 3, 17, 2701, 8, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1,
		17, 1, 17, 1, 17, 5, 17, 2711, 8, 17, 10, 17, 12, 17, 2714, 9, 17, 3, 17,
		2716, 8, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 2723, 8, 17, 1,
		17, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 2730, 8, 17, 1, 17, 1, 17, 1, 17,
		1, 17, 5, 17, 2736, 8, 17, 10, 17, 12, 17, 2739, 9, 17, 3, 17, 2741, 8,
		17, 1, 17, 3, 17, 2744, 8, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17,
		1, 17, 1, 17, 1, 17, 1, 17, 5, 17, 2756, 8, 17, 10, 17, 12, 17, 2759, 9,
		17, 1, 17, 1, 17, 3, 17, 2763, 8, 17, 1, 17, 3, 17, 2766, 8, 17, 3, 17,
		2768, 8, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 1, 18, 5, 18, 2780, 8, 18, 10, 18, 12, 18, 2783, 9, 18, 1, 18, 1, 18,
		3, 18, 2787, 8, 18, 1, 18, 3, 18, 2790, 8, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 1, 18, 3, 18, 2797, 8, 18, 3, 18, 2799, 8, 18, 1, 19, 1, 19, 1, 19,
		1, 19, 3, 19, 2805, 8, 19, 1, 20, 1, 20, 1, 20, 3, 20, 2810, 8, 20, 1,
		20, 1, 20, 3, 20, 2814, 8, 20, 1, 20, 3, 20, 2817, 8, 20, 1, 20, 3, 20,
		2820, 8, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 3, 21, 2828, 8,
		21, 1, 21, 1, 21, 3, 21, 2832, 8, 21, 1, 21, 1, 21, 1, 21, 5, 21, 2837,
		8, 21, 10, 21, 12, 21, 2840, 9, 21, 3, 21, 2842, 8, 21, 1, 21, 3, 21, 2845,
		8, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 3, 21, 2853, 8, 21, 1,
		22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 2862, 8, 22, 1, 22,
		3, 22, 2865, 8, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 2872, 8,
		22, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23,
		3, 23, 2884, 8, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1, 25, 1,
		25, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1, 27, 1, 28, 1, 28, 1, 28,
		1, 28, 1, 28, 5, 28, 2906, 8, 28, 10, 28, 12, 28, 2909, 9, 28, 1, 28, 1,
		28, 1, 29, 1, 29, 1, 29, 3, 29, 2916, 8, 29, 1, 29, 1, 29, 1, 29, 1, 29,
		3, 29, 2922, 8, 29, 1, 29, 1, 29, 3, 29, 2926, 8, 29, 1, 30, 1, 30, 1,
		30, 1, 30, 3, 30, 2932, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 2938,
		8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 1, 30, 3, 30, 2951, 8, 30, 3, 30, 2953, 8, 30, 1, 31, 1, 31, 1, 31,
		1, 31, 1, 31, 1, 31, 3, 31, 2961, 8, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1,
		31, 1, 31, 1, 31, 1, 31, 1, 31, 3, 31, 2972, 8, 31, 1, 31, 1, 31, 1, 31,
		1, 31, 3, 31, 2978, 8, 31, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 2984, 8,
		32, 1, 32, 3, 32, 2987, 8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 2993,
		8, 32, 1, 32, 3, 32, 2996, 8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3,
		32, 3003, 8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 5, 32, 3011,
		8, 32, 10, 32, 12, 32, 3014, 9, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32,
		3020, 8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 3026, 8, 32, 1, 32, 1,
		32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 5, 32, 3037, 8, 32,
		10, 32, 12, 32, 3040, 9, 32, 1, 32, 3, 32, 3043, 8, 32, 1, 32, 1, 32, 1,
		32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 3052, 8, 32, 1, 32, 1, 32, 1, 32,
		1, 32, 1, 32, 1, 32, 5, 32, 3060, 8, 32, 10, 32, 12, 32, 3063, 9, 32, 1,
		32, 3, 32, 3066, 8, 32, 3, 32, 3068, 8, 32, 1, 33, 1, 33, 1, 33, 1, 33,
		1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 5,
		33, 3084, 8, 33, 10, 33, 12, 33, 3087, 9, 33, 1, 33, 3, 33, 3090, 8, 33,
		1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 5, 33, 3101,
		8, 33, 10, 33, 12, 33, 3104, 9, 33, 1, 33, 3, 33, 3107, 8, 33, 1, 33, 1,
		33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33,
		1, 33, 1, 33, 1, 33, 3, 33, 3124, 8, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1,
		33, 1, 33, 1, 33, 1, 33, 3, 33, 3134, 8, 33, 1, 33, 1, 33, 1, 33, 1, 33,
		3, 33, 3140, 8, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 3148,
		8, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 3155, 8, 33, 1, 33, 1,
		33, 1, 33, 1, 33, 1, 33, 3, 33, 3162, 8, 33, 1, 33, 3, 33, 3165, 8, 33,
		1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 5, 33, 3175, 8,
		33, 10, 33, 12, 33, 3178, 9, 33, 1, 33, 3, 33, 3181, 8, 33, 1, 33, 1, 33,
		1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1,
		33, 1, 33, 1, 33, 3, 33, 3198, 8, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33,
		1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1,
		33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 3223, 8, 33,
		3, 33, 3225, 8, 33, 1, 34, 1, 34, 1, 34, 1, 34, 3, 34, 3231, 8, 34, 1,
		34, 1, 34, 3, 34, 3235, 8, 34, 1, 34, 1, 34, 1, 34, 1, 34, 3, 34, 3241,
		8, 34, 1, 34, 1, 34, 3, 34, 3245, 8, 34, 1, 34, 1, 34, 1, 34, 1, 34, 3,
		34, 3251, 8, 34, 1, 34, 1, 34, 3, 34, 3255, 8, 34, 1, 34, 1, 34, 1, 34,
		3, 34, 3260, 8, 34, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 3,
		35, 3269, 8, 35, 1, 36, 1, 36, 3, 36, 3273, 8, 36, 1, 36, 3, 36, 3276,
		8, 36, 1, 36, 3, 36, 3279, 8, 36, 1, 36, 3, 36, 3282, 8, 36, 1, 36, 1,
		36, 3, 36, 3286, 8, 36, 1, 36, 3, 36, 3289, 8, 36, 1, 37, 1, 37, 1, 37,
		1, 37, 3, 37, 3295, 8, 37, 1, 38, 1, 38, 1, 38, 1, 38, 3, 38, 3301, 8,
		38, 3, 38, 3303, 8, 38, 1, 38, 1, 38, 3, 38, 3307, 8, 38, 1, 38, 1, 38,
		3, 38, 3311, 8, 38, 1, 38, 3, 38, 3314, 8, 38, 1, 38, 3, 38, 3317, 8, 38,
		1, 38, 3, 38, 3320, 8, 38, 1, 38, 1, 38, 3, 38, 3324, 8, 38, 1, 38, 1,
		38, 3, 38, 3328, 8, 38, 1, 38, 3, 38, 3331, 8, 38, 1, 38, 3, 38, 3334,
		8, 38, 1, 38, 3, 38, 3337, 8, 38, 3, 38, 3339, 8, 38, 1, 39, 1, 39, 1,
		39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 3, 39, 3349, 8, 39, 1, 39, 1, 39,
		1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 3,
		39, 3363, 8, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 3, 39, 3370, 8, 39,
		1, 39, 1, 39, 1, 39, 1, 39, 5, 39, 3376, 8, 39, 10, 39, 12, 39, 3379, 9,
		39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 5, 39, 3388, 8, 39,
		10, 39, 12, 39, 3391, 9, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39,
		1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 3, 39, 3408,
		8, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 3, 39, 3415, 8, 39, 1, 39, 1,
		39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 3, 39, 3425, 8, 39, 3, 39,
		3427, 8, 39, 1, 40, 1, 40, 3, 40, 3431, 8, 40, 1, 40, 3, 40, 3434, 8, 40,
		1, 41, 1, 41, 1, 41, 5, 41, 3439, 8, 41, 10, 41, 12, 41, 3442, 9, 41, 1,
		42, 1, 42, 1, 42, 1, 42, 1, 42, 5, 42, 3449, 8, 42, 10, 42, 12, 42, 3452,
		9, 42, 1, 42, 3, 42, 3455, 8, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 5,
		42, 3462, 8, 42, 10, 42, 12, 42, 3465, 9, 42, 1, 42, 1, 42, 1, 42, 1, 42,
		1, 42, 5, 42, 3472, 8, 42, 10, 42, 12, 42, 3475, 9, 42, 1, 42, 1, 42, 1,
		42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42,
		1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 5, 42, 3495, 8, 42, 10, 42, 12, 42,
		3498, 9, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 5, 42, 3506, 8,
		42, 10, 42, 12, 42, 3509, 9, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1,
		42, 1, 42, 1, 42, 1, 42, 3, 42, 3520, 8, 42, 1, 42, 1, 42, 1, 42, 1, 42,
		1, 42, 5, 42, 3527, 8, 42, 10, 42, 12, 42, 3530, 9, 42, 1, 42, 1, 42, 1,
		42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 3542, 8, 42,
		1, 43, 1, 43, 3, 43, 3546, 8, 43, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 3,
		44, 3553, 8, 44, 1, 44, 3, 44, 3556, 8, 44, 1, 44, 3, 44, 3559, 8, 44,
		1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 3565, 8, 45, 1, 45, 3, 45, 3568, 8,
		45, 1, 45, 3, 45, 3571, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45,
		3, 45, 3579, 8, 45, 1, 45, 3, 45, 3582, 8, 45, 1, 45, 1, 45, 1, 45, 1,
		45, 3, 45, 3588, 8, 45, 1, 45, 3, 45, 3591, 8, 45, 1, 45, 1, 45, 1, 45,
		1, 45, 3, 45, 3597, 8, 45, 1, 45, 3, 45, 3600, 8, 45, 1, 45, 3, 45, 3603,
		8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 3609, 8, 45, 1, 45, 3, 45, 3612,
		8, 45, 1, 45, 1, 45, 3, 45, 3616, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1,
		45, 1, 45, 3, 45, 3624, 8, 45, 1, 45, 1, 45, 1, 45, 3, 45, 3629, 8, 45,
		3, 45, 3631, 8, 45, 3, 45, 3633, 8, 45, 1, 45, 3, 45, 3636, 8, 45, 1, 45,
		1, 45, 3, 45, 3640, 8, 45, 1, 45, 1, 45, 1, 45, 3, 45, 3645, 8, 45, 1,
		45, 1, 45, 3, 45, 3649, 8, 45, 1, 45, 1, 45, 1, 45, 3, 45, 3654, 8, 45,
		1, 45, 1, 45, 3, 45, 3658, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1,
		45, 3, 45, 3666, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45,
		3, 45, 3675, 8, 45, 1, 45, 1, 45, 3, 45, 3679, 8, 45, 1, 45, 3, 45, 3682,
		8, 45, 1, 45, 3, 45, 3685, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3,
		45, 3692, 8, 45, 1, 45, 3, 45, 3695, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45,
		1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1,
		45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 3720,
		8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 3728, 8, 45, 1,
		45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 3737, 8, 45, 1, 45,
		1, 45, 1, 45, 3, 45, 3742, 8, 45, 3, 45, 3744, 8, 45, 3, 45, 3746, 8, 45,
		1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1,
		45, 1, 45, 1, 45, 1, 45, 3, 45, 3762, 8, 45, 1, 45, 1, 45, 3, 45, 3766,
		8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 3776,
		8, 45, 1, 45, 3, 45, 3779, 8, 45, 1, 45, 1, 45, 3, 45, 3783, 8, 45, 1,
		46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 3790, 8, 46, 1, 46, 1, 46, 1, 46,
		1, 46, 1, 46, 3, 46, 3797, 8, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3,
		46, 3804, 8, 46, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 3811, 8, 47,
		1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 3818, 8, 47, 1, 47, 1, 47, 1,
		47, 1, 47, 1, 47, 3, 47, 3825, 8, 47, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48,
		3831, 8, 48, 1, 48, 3, 48, 3834, 8, 48, 1, 49, 1, 49, 1, 49, 1, 49, 3,
		49, 3840, 8, 49, 1, 49, 3, 49, 3843, 8, 49, 1, 49, 3, 49, 3846, 8, 49,
		1, 50, 1, 50, 1, 50, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1,
		51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 3, 51, 3865, 8, 51, 1, 52,
		1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 1, 54, 1, 54, 1, 54, 3, 54, 3876, 8,
		54, 1, 55, 1, 55, 1, 55, 1, 56, 1, 56, 1, 56, 1, 57, 1, 57, 3, 57, 3886,
		8, 57, 1, 57, 1, 57, 1, 57, 3, 57, 3891, 8, 57, 1, 57, 1, 57, 1, 57, 1,
		57, 1, 57, 3, 57, 3898, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57,
		3905, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 3912, 8, 57, 1,
		57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57,
		5, 57, 3925, 8, 57, 10, 57, 12, 57, 3928, 9, 57, 1, 57, 3, 57, 3931, 8,
		57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 3937, 8, 57, 1, 57, 3, 57, 3940,
		8, 57, 1, 57, 1, 57, 5, 57, 3944, 8, 57, 10, 57, 12, 57, 3947, 9, 57, 1,
		57, 3, 57, 3950, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57,
		1, 57, 1, 57, 3, 57, 3961, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3,
		57, 3968, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57,
		1, 57, 3, 57, 3979, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1,
		57, 1, 57, 1, 57, 1, 57, 3, 57, 3991, 8, 57, 1, 57, 3, 57, 3994, 8, 57,
		1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1,
		57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 4015,
		8, 57, 1, 57, 3, 57, 4018, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 4024,
		8, 57, 1, 58, 1, 58, 1, 58, 3, 58, 4029, 8, 58, 1, 58, 1, 58, 1, 58, 3,
		58, 4034, 8, 58, 1, 58, 3, 58, 4037, 8, 58, 1, 58, 1, 58, 1, 58, 1, 58,
		1, 58, 3, 58, 4044, 8, 58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1,
		59, 1, 59, 1, 59, 1, 59, 3, 59, 4056, 8, 59, 1, 59, 1, 59, 1, 59, 1, 59,
		1, 59, 1, 59, 3, 59, 4064, 8, 59, 1, 60, 1, 60, 1, 60, 5, 60, 4069, 8,
		60, 10, 60, 12, 60, 4072, 9, 60, 1, 61, 1, 61, 1, 61, 1, 61, 3, 61, 4078,
		8, 61, 3, 61, 4080, 8, 61, 1, 62, 1, 62, 1, 62, 5, 62, 4085, 8, 62, 10,
		62, 12, 62, 4088, 9, 62, 1, 63, 1, 63, 1, 63, 1, 63, 3, 63, 4094, 8, 63,
		1, 64, 1, 64, 3, 64, 4098, 8, 64, 1, 64, 1, 64, 1, 64, 1, 64, 3, 64, 4104,
		8, 64, 1, 65, 1, 65, 1, 65, 3, 65, 4109, 8, 65, 3, 65, 4111, 8, 65, 1,
		65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 4119, 8, 65, 3, 65, 4121,
		8, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 4128, 8, 65, 3, 65, 4130,
		8, 65, 1, 65, 1, 65, 3, 65, 4134, 8, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3,
		65, 4140, 8, 65, 3, 65, 4142, 8, 65, 1, 65, 3, 65, 4145, 8, 65, 1, 66,
		1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66, 4153, 8, 66, 1, 67, 1, 67, 1,
		67, 5, 67, 4158, 8, 67, 10, 67, 12, 67, 4161, 9, 67, 1, 68, 1, 68, 1, 68,
		3, 68, 4166, 8, 68, 1, 68, 1, 68, 1, 68, 3, 68, 4171, 8, 68, 5, 68, 4173,
		8, 68, 10, 68, 12, 68, 4176, 9, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68,
		1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 3, 68, 4189, 8, 68, 1, 68, 1,
		68, 1, 68, 3, 68, 4194, 8, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68,
		1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 3, 68, 4207, 8, 68, 3, 68, 4209, 8,
		68, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 3, 69, 4216, 8, 69, 1, 70, 1, 70,
		1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 4224, 8, 70, 1, 70, 1, 70, 3, 70, 4228,
		8, 70, 1, 70, 1, 70, 1, 70, 3, 70, 4233, 8, 70, 1, 70, 1, 70, 1, 70, 3,
		70, 4238, 8, 70, 1, 70, 1, 70, 1, 70, 3, 70, 4243, 8, 70, 1, 70, 1, 70,
		1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 4251, 8, 70, 1, 70, 1, 70, 1, 70, 1,
		70, 1, 70, 1, 70, 1, 70, 3, 70, 4260, 8, 70, 1, 70, 3, 70, 4263, 8, 70,
		1, 71, 1, 71, 1, 71, 1, 71, 3, 71, 4269, 8, 71, 3, 71, 4271, 8, 71, 1,
		71, 1, 71, 1, 71, 1, 71, 3, 71, 4277, 8, 71, 1, 71, 1, 71, 1, 71, 1, 71,
		1, 71, 3, 71, 4284, 8, 71, 1, 72, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73, 1,
		73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 4298, 8, 73, 1, 74, 1, 74,
		3, 74, 4302, 8, 74, 1, 74, 1, 74, 1, 74, 3, 74, 4307, 8, 74, 1, 74, 1,
		74, 1, 74, 1, 74, 3, 74, 4313, 8, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75,
		1, 75, 3, 75, 4321, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 4328,
		8, 75, 1, 75, 3, 75, 4331, 8, 75, 1, 75, 1, 75, 3, 75, 4335, 8, 75, 1,
		76, 1, 76, 1, 76, 3, 76, 4340, 8, 76, 1, 76, 1, 76, 1, 76, 3, 76, 4345,
		8, 76, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 4352, 8, 77, 1, 77, 1,
		77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 4364,
		8, 77, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 4370, 8, 77, 1, 78, 1, 78, 1,
		78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78,
		4384, 8, 78, 1, 79, 3, 79, 4387, 8, 79, 1, 79, 1, 79, 1, 79, 3, 79, 4392,
		8, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 4400, 8, 79, 1,
		80, 3, 80, 4403, 8, 80, 1, 80, 1, 80, 1, 80, 3, 80, 4408, 8, 80, 1, 80,
		1, 80, 1, 80, 3, 80, 4413, 8, 80, 1, 80, 1, 80, 1, 81, 1, 81, 1, 81, 1,
		81, 5, 81, 4421, 8, 81, 10, 81, 12, 81, 4424, 9, 81, 1, 81, 1, 81, 1, 82,
		1, 82, 3, 82, 4430, 8, 82, 1, 83, 3, 83, 4433, 8, 83, 1, 83, 3, 83, 4436,
		8, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 5, 83, 4444, 8, 83, 10,
		83, 12, 83, 4447, 9, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 3, 83, 4454,
		8, 83, 1, 83, 1, 83, 1, 83, 1, 83, 3, 83, 4460, 8, 83, 1, 83, 1, 83, 1,
		83, 1, 83, 3, 83, 4466, 8, 83, 1, 83, 1, 83, 1, 83, 3, 83, 4471, 8, 83,
		1, 83, 1, 83, 1, 83, 3, 83, 4476, 8, 83, 1, 83, 3, 83, 4479, 8, 83, 1,
		83, 3, 83, 4482, 8, 83, 1, 83, 3, 83, 4485, 8, 83, 1, 83, 3, 83, 4488,
		8, 83, 1, 83, 3, 83, 4491, 8, 83, 1, 83, 3, 83, 4494, 8, 83, 1, 83, 3,
		83, 4497, 8, 83, 1, 83, 3, 83, 4500, 8, 83, 1, 83, 3, 83, 4503, 8, 83,
		1, 83, 3, 83, 4506, 8, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1,
		83, 1, 83, 1, 83, 3, 83, 4517, 8, 83, 1, 83, 3, 83, 4520, 8, 83, 1, 83,
		3, 83, 4523, 8, 83, 1, 83, 3, 83, 4526, 8, 83, 1, 83, 3, 83, 4529, 8, 83,
		3, 83, 4531, 8, 83, 1, 84, 1, 84, 1, 85, 1, 85, 1, 85, 1, 86, 1, 86, 1,
		86, 1, 86, 1, 86, 1, 86, 1, 86, 3, 86, 4545, 8, 86, 1, 87, 1, 87, 1, 87,
		1, 87, 1, 87, 3, 87, 4552, 8, 87, 1, 88, 1, 88, 1, 89, 1, 89, 3, 89, 4558,
		8, 89, 1, 90, 1, 90, 3, 90, 4562, 8, 90, 1, 91, 1, 91, 1, 91, 3, 91, 4567,
		8, 91, 1, 92, 1, 92, 1, 92, 5, 92, 4572, 8, 92, 10, 92, 12, 92, 4575, 9,
		92, 1, 93, 1, 93, 3, 93, 4579, 8, 93, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94,
		1, 94, 1, 94, 3, 94, 4588, 8, 94, 3, 94, 4590, 8, 94, 1, 95, 1, 95, 1,
		95, 1, 95, 3, 95, 4596, 8, 95, 1, 95, 3, 95, 4599, 8, 95, 1, 96, 1, 96,
		3, 96, 4603, 8, 96, 1, 96, 3, 96, 4606, 8, 96, 1, 96, 3, 96, 4609, 8, 96,
		1, 97, 1, 97, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 1, 99, 1, 100, 1, 100,
		1, 100, 1, 100, 3, 100, 4623, 8, 100, 1, 101, 1, 101, 1, 102, 1, 102, 1,
		102, 1, 102, 1, 103, 1, 103, 1, 103, 1, 103, 1, 104, 1, 104, 1, 104, 1,
		104, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 106, 1, 106, 1,
		106, 1, 106, 1, 106, 5, 106, 4650, 8, 106, 10, 106, 12, 106, 4653, 9, 106,
		1, 106, 1, 106, 1, 107, 1, 107, 1, 107, 1, 107, 1, 108, 1, 108, 1, 108,
		1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108,
		1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108,
		1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 3, 108, 4687, 8, 108, 3, 108, 4689,
		8, 108, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 3, 109,
		4698, 8, 109, 1, 110, 1, 110, 3, 110, 4702, 8, 110, 1, 110, 1, 110, 1,
		110, 1, 110, 1, 110, 1, 110, 1, 110, 3, 110, 4711, 8, 110, 1, 110, 1, 110,
		1, 110, 1, 110, 3, 110, 4717, 8, 110, 1, 110, 1, 110, 1, 110, 1, 110, 3,
		110, 4723, 8, 110, 1, 110, 3, 110, 4726, 8, 110, 1, 110, 3, 110, 4729,
		8, 110, 1, 110, 3, 110, 4732, 8, 110, 1, 110, 3, 110, 4735, 8, 110, 1,
		111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 3, 111, 4743, 8, 111, 1, 112,
		1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 3, 112, 4751, 8, 112, 1, 112, 3,
		112, 4754, 8, 112, 1, 113, 3, 113, 4757, 8, 113, 1, 113, 1, 113, 1, 113,
		1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 3, 114, 4768, 8, 114, 1,
		114, 1, 114, 1, 114, 1, 114, 3, 114, 4774, 8, 114, 1, 114, 5, 114, 4777,
		8, 114, 10, 114, 12, 114, 4780, 9, 114, 1, 115, 1, 115, 1, 116, 1, 116,
		1, 116, 1, 116, 1, 116, 1, 116, 3, 116, 4790, 8, 116, 1, 117, 1, 117, 3,
		117, 4794, 8, 117, 1, 117, 3, 117, 4797, 8, 117, 1, 117, 3, 117, 4800,
		8, 117, 1, 117, 3, 117, 4803, 8, 117, 1, 117, 3, 117, 4806, 8, 117, 1,
		117, 3, 117, 4809, 8, 117, 1, 117, 1, 117, 1, 117, 3, 117, 4814, 8, 117,
		1, 118, 1, 118, 1, 118, 1, 118, 5, 118, 4820, 8, 118, 10, 118, 12, 118,
		4823, 9, 118, 1, 119, 1, 119, 3, 119, 4827, 8, 119, 1, 119, 1, 119, 1,
		119, 1, 119, 1, 119, 1, 120, 1, 120, 1, 120, 1, 120, 5, 120, 4838, 8, 120,
		10, 120, 12, 120, 4841, 9, 120, 1, 120, 1, 120, 1, 121, 1, 121, 3, 121,
		4847, 8, 121, 1, 121, 1, 121, 1, 122, 1, 122, 1, 123, 1, 123, 1, 123, 1,
		124, 1, 124, 1, 124, 1, 125, 3, 125, 4860, 8, 125, 1, 125, 1, 125, 1, 125,
		3, 125, 4865, 8, 125, 1, 125, 1, 125, 1, 125, 3, 125, 4870, 8, 125, 5,
		125, 4872, 8, 125, 10, 125, 12, 125, 4875, 9, 125, 1, 126, 1, 126, 1, 126,
		1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 128, 1, 128, 1, 128, 5, 128,
		4888, 8, 128, 10, 128, 12, 128, 4891, 9, 128, 1, 129, 1, 129, 5, 129, 4895,
		8, 129, 10, 129, 12, 129, 4898, 9, 129, 1, 130, 1, 130, 1, 130, 3, 130,
		4903, 8, 130, 1, 130, 1, 130, 3, 130, 4907, 8, 130, 1, 131, 1, 131, 1,
		131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 3, 131, 4917, 8, 131, 1, 132,
		1, 132, 1, 132, 1, 132, 5, 132, 4923, 8, 132, 10, 132, 12, 132, 4926, 9,
		132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 5, 132, 4934, 8, 132,
		10, 132, 12, 132, 4937, 9, 132, 1, 132, 1, 132, 3, 132, 4941, 8, 132, 1,
		133, 1, 133, 1, 133, 1, 133, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 5,
		134, 4952, 8, 134, 10, 134, 12, 134, 4955, 9, 134, 3, 134, 4957, 8, 134,
		1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 5, 134, 4965, 8, 134, 10,
		134, 12, 134, 4968, 9, 134, 3, 134, 4970, 8, 134, 1, 134, 1, 134, 1, 134,
		1, 134, 1, 134, 1, 134, 1, 134, 5, 134, 4979, 8, 134, 10, 134, 12, 134,
		4982, 9, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 5, 134, 4989, 8,
		134, 10, 134, 12, 134, 4992, 9, 134, 1, 134, 1, 134, 3, 134, 4996, 8, 134,
		3, 134, 4998, 8, 134, 1, 135, 1, 135, 1, 135, 1, 135, 5, 135, 5004, 8,
		135, 10, 135, 12, 135, 5007, 9, 135, 3, 135, 5009, 8, 135, 1, 135, 1, 135,
		1, 136, 1, 136, 1, 136, 1, 137, 1, 137, 1, 137, 1, 138, 1, 138, 3, 138,
		5021, 8, 138, 1, 138, 5, 138, 5024, 8, 138, 10, 138, 12, 138, 5027, 9,
		138, 1, 138, 1, 138, 1, 139, 1, 139, 1, 139, 1, 139, 3, 139, 5035, 8, 139,
		1, 139, 5, 139, 5038, 8, 139, 10, 139, 12, 139, 5041, 9, 139, 1, 139, 1,
		139, 3, 139, 5045, 8, 139, 1, 139, 1, 139, 1, 139, 1, 139, 1, 139, 5, 139,
		5052, 8, 139, 10, 139, 12, 139, 5055, 9, 139, 1, 139, 1, 139, 3, 139, 5059,
		8, 139, 3, 139, 5061, 8, 139, 1, 140, 1, 140, 1, 140, 1, 140, 3, 140, 5067,
		8, 140, 3, 140, 5069, 8, 140, 1, 140, 3, 140, 5072, 8, 140, 1, 141, 1,
		141, 1, 141, 1, 141, 3, 141, 5078, 8, 141, 1, 142, 1, 142, 1, 142, 5, 142,
		5083, 8, 142, 10, 142, 12, 142, 5086, 9, 142, 1, 143, 1, 143, 1, 143, 1,
		143, 1, 143, 1, 143, 1, 143, 5, 143, 5095, 8, 143, 10, 143, 12, 143, 5098,
		9, 143, 3, 143, 5100, 8, 143, 1, 143, 1, 143, 1, 143, 1, 143, 1, 143, 1,
		143, 5, 143, 5108, 8, 143, 10, 143, 12, 143, 5111, 9, 143, 1, 144, 3, 144,
		5114, 8, 144, 1, 144, 3, 144, 5117, 8, 144, 1, 145, 1, 145, 1, 145, 1,
		145, 1, 145, 5, 145, 5124, 8, 145, 10, 145, 12, 145, 5127, 9, 145, 1, 146,
		1, 146, 3, 146, 5131, 8, 146, 1, 146, 1, 146, 3, 146, 5135, 8, 146, 1,
		147, 1, 147, 1, 147, 1, 147, 1, 147, 1, 147, 1, 147, 1, 147, 1, 147, 1,
		147, 3, 147, 5147, 8, 147, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 5, 148,
		5154, 8, 148, 10, 148, 12, 148, 5157, 9, 148, 1, 149, 3, 149, 5160, 8,
		149, 1, 149, 1, 149, 1, 149, 3, 149, 5165, 8, 149, 1, 149, 1, 149, 3, 149,
		5169, 8, 149, 1, 149, 1, 149, 3, 149, 5173, 8, 149, 1, 149, 1, 149, 1,
		149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 3, 149, 5183, 8, 149, 1, 150,
		1, 150, 1, 150, 1, 150, 3, 150, 5189, 8, 150, 1, 151, 1, 151, 1, 151, 1,
		151, 1, 152, 1, 152, 1, 152, 5, 152, 5198, 8, 152, 10, 152, 12, 152, 5201,
		9, 152, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 3, 153, 5208, 8, 153, 1,
		153, 1, 153, 1, 154, 1, 154, 3, 154, 5214, 8, 154, 1, 154, 3, 154, 5217,
		8, 154, 1, 154, 3, 154, 5220, 8, 154, 1, 154, 3, 154, 5223, 8, 154, 1,
		154, 3, 154, 5226, 8, 154, 1, 154, 1, 154, 3, 154, 5230, 8, 154, 1, 154,
		3, 154, 5233, 8, 154, 1, 154, 5, 154, 5236, 8, 154, 10, 154, 12, 154, 5239,
		9, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 5, 154, 5246, 8, 154, 10,
		154, 12, 154, 5249, 9, 154, 1, 154, 1, 154, 1, 154, 3, 154, 5254, 8, 154,
		1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 3, 154, 5263, 8,
		154, 1, 155, 1, 155, 1, 155, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1,
		157, 1, 157, 1, 157, 5, 157, 5276, 8, 157, 10, 157, 12, 157, 5279, 9, 157,
		1, 158, 1, 158, 1, 158, 1, 158, 1, 159, 1, 159, 3, 159, 5287, 8, 159, 1,
		160, 1, 160, 3, 160, 5291, 8, 160, 1, 161, 3, 161, 5294, 8, 161, 1, 161,
		1, 161, 3, 161, 5298, 8, 161, 3, 161, 5300, 8, 161, 1, 162, 1, 162, 1,
		162, 5, 162, 5305, 8, 162, 10, 162, 12, 162, 5308, 9, 162, 1, 163, 1, 163,
		1, 163, 5, 163, 5313, 8, 163, 10, 163, 12, 163, 5316, 9, 163, 1, 164, 1,
		164, 1, 164, 3, 164, 5321, 8, 164, 1, 165, 1, 165, 1, 165, 5, 165, 5326,
		8, 165, 10, 165, 12, 165, 5329, 9, 165, 1, 166, 1, 166, 1, 166, 3, 166,
		5334, 8, 166, 1, 166, 3, 166, 5337, 8, 166, 1, 166, 1, 166, 3, 166, 5341,
		8, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 3, 166, 5348, 8, 166, 1,
		166, 3, 166, 5351, 8, 166, 1, 166, 3, 166, 5354, 8, 166, 1, 166, 1, 166,
		1, 166, 1, 166, 1, 166, 3, 166, 5361, 8, 166, 3, 166, 5363, 8, 166, 1,
		166, 1, 166, 1, 166, 3, 166, 5368, 8, 166, 1, 166, 1, 166, 3, 166, 5372,
		8, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166,
		1, 166, 1, 166, 1, 166, 3, 166, 5385, 8, 166, 3, 166, 5387, 8, 166, 3,
		166, 5389, 8, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166,
		3, 166, 5398, 8, 166, 3, 166, 5400, 8, 166, 1, 166, 1, 166, 3, 166, 5404,
		8, 166, 1, 167, 1, 167, 1, 167, 5, 167, 5409, 8, 167, 10, 167, 12, 167,
		5412, 9, 167, 1, 168, 1, 168, 1, 168, 1, 168, 3, 168, 5418, 8, 168, 1,
		168, 1, 168, 1, 168, 1, 168, 3, 168, 5424, 8, 168, 1, 168, 1, 168, 1, 168,
		1, 168, 1, 168, 3, 168, 5431, 8, 168, 1, 168, 1, 168, 3, 168, 5435, 8,
		168, 1, 169, 1, 169, 1, 169, 5, 169, 5440, 8, 169, 10, 169, 12, 169, 5443,
		9, 169, 1, 170, 1, 170, 1, 170, 1, 170, 3, 170, 5449, 8, 170, 1, 170, 1,
		170, 1, 170, 1, 170, 3, 170, 5455, 8, 170, 1, 171, 1, 171, 1, 171, 1, 171,
		3, 171, 5461, 8, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 3,
		171, 5469, 8, 171, 1, 172, 1, 172, 1, 172, 1, 172, 3, 172, 5475, 8, 172,
		1, 172, 1, 172, 1, 172, 1, 172, 1, 172, 1, 172, 1, 172, 1, 172, 1, 173,
		1, 173, 1, 173, 1, 173, 1, 173, 1, 173, 1, 173, 3, 173, 5492, 8, 173, 1,
		174, 1, 174, 1, 174, 1, 174, 3, 174, 5498, 8, 174, 1, 174, 1, 174, 1, 174,
		1, 174, 1, 174, 1, 174, 1, 174, 5, 174, 5507, 8, 174, 10, 174, 12, 174,
		5510, 9, 174, 1, 174, 1, 174, 1, 174, 3, 174, 5515, 8, 174, 3, 174, 5517,
		8, 174, 1, 175, 1, 175, 1, 175, 1, 175, 5, 175, 5523, 8, 175, 10, 175,
		12, 175, 5526, 9, 175, 1, 175, 1, 175, 1, 176, 3, 176, 5531, 8, 176, 1,
		176, 1, 176, 1, 176, 1, 176, 3, 176, 5537, 8, 176, 1, 177, 1, 177, 1, 177,
		5, 177, 5542, 8, 177, 10, 177, 12, 177, 5545, 9, 177, 1, 178, 1, 178, 1,
		178, 1, 178, 1, 178, 3, 178, 5552, 8, 178, 1, 178, 3, 178, 5555, 8, 178,
		1, 179, 1, 179, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 5, 180, 5564, 8,
		180, 10, 180, 12, 180, 5567, 9, 180, 1, 180, 1, 180, 1, 181, 1, 181, 1,
		181, 1, 181, 5, 181, 5575, 8, 181, 10, 181, 12, 181, 5578, 9, 181, 1, 182,
		1, 182, 3, 182, 5582, 8, 182, 1, 182, 3, 182, 5585, 8, 182, 1, 183, 1,
		183, 1, 183, 5, 183, 5590, 8, 183, 10, 183, 12, 183, 5593, 9, 183, 1, 184,
		1, 184, 3, 184, 5597, 8, 184, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1,
		185, 1, 185, 1, 185, 4, 185, 5607, 8, 185, 11, 185, 12, 185, 5608, 1, 185,
		1, 185, 1, 185, 1, 185, 3, 185, 5615, 8, 185, 1, 186, 1, 186, 1, 186, 1,
		186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1,
		186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 3, 186, 5637,
		8, 186, 1, 186, 1, 186, 3, 186, 5641, 8, 186, 1, 186, 1, 186, 1, 186, 1,
		186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 5,
		186, 5655, 8, 186, 10, 186, 12, 186, 5658, 9, 186, 1, 187, 1, 187, 1, 187,
		1, 187, 5, 187, 5664, 8, 187, 10, 187, 12, 187, 5667, 9, 187, 3, 187, 5669,
		8, 187, 1, 187, 1, 187, 1, 188, 1, 188, 1, 188, 3, 188, 5676, 8, 188, 1,
		189, 3, 189, 5679, 8, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189,
		3, 189, 5687, 8, 189, 1, 189, 1, 189, 1, 189, 3, 189, 5692, 8, 189, 1,
		189, 1, 189, 1, 189, 3, 189, 5697, 8, 189, 1, 189, 1, 189, 1, 189, 1, 189,
		1, 189, 1, 189, 3, 189, 5705, 8, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1,
		189, 5, 189, 5712, 8, 189, 10, 189, 12, 189, 5715, 9, 189, 1, 189, 1, 189,
		1, 189, 1, 189, 3, 189, 5721, 8, 189, 1, 189, 1, 189, 1, 189, 3, 189, 5726,
		8, 189, 1, 189, 3, 189, 5729, 8, 189, 1, 190, 1, 190, 1, 190, 1, 190, 3,
		190, 5735, 8, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190,
		1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190,
		1, 190, 1, 190, 1, 190, 5, 190, 5756, 8, 190, 10, 190, 12, 190, 5759, 9,
		190, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1,
		191, 1, 191, 4, 191, 5771, 8, 191, 11, 191, 12, 191, 5772, 1, 191, 1, 191,
		3, 191, 5777, 8, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 4, 191, 5784,
		8, 191, 11, 191, 12, 191, 5785, 1, 191, 1, 191, 3, 191, 5790, 8, 191, 1,
		191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1,
		191, 1, 191, 1, 191, 1, 191, 5, 191, 5805, 8, 191, 10, 191, 12, 191, 5808,
		9, 191, 1, 191, 1, 191, 1, 191, 1, 191, 5, 191, 5814, 8, 191, 10, 191,
		12, 191, 5817, 9, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 5, 191,
		5824, 8, 191, 10, 191, 12, 191, 5827, 9, 191, 1, 191, 1, 191, 3, 191, 5831,
		8, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191,
		1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191,
		1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191,
		3, 191, 5859, 8, 191, 1, 191, 1, 191, 3, 191, 5863, 8, 191, 1, 191, 1,
		191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 3, 191, 5874,
		8, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 3, 191, 5882, 8,
		191, 1, 191, 1, 191, 1, 191, 3, 191, 5887, 8, 191, 1, 191, 1, 191, 1, 191,
		1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 3, 191, 5899, 8,
		191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1,
		191, 1, 191, 3, 191, 5911, 8, 191, 5, 191, 5913, 8, 191, 10, 191, 12, 191,
		5916, 9, 191, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 1,
		192, 1, 192, 1, 192, 3, 192, 5928, 8, 192, 1, 193, 1, 193, 1, 193, 3, 193,
		5933, 8, 193, 3, 193, 5935, 8, 193, 1, 194, 1, 194, 1, 194, 3, 194, 5940,
		8, 194, 1, 194, 1, 194, 1, 194, 5, 194, 5945, 8, 194, 10, 194, 12, 194,
		5948, 9, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 5, 194, 5955, 8,
		194, 10, 194, 12, 194, 5958, 9, 194, 3, 194, 5960, 8, 194, 3, 194, 5962,
		8, 194, 1, 194, 1, 194, 1, 194, 3, 194, 5967, 8, 194, 1, 195, 1, 195, 1,
		195, 3, 195, 5972, 8, 195, 1, 195, 1, 195, 1, 196, 1, 196, 1, 196, 1, 196,
		1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196,
		1, 196, 1, 196, 1, 196, 3, 196, 5992, 8, 196, 1, 197, 1, 197, 3, 197, 5996,
		8, 197, 1, 197, 3, 197, 5999, 8, 197, 1, 197, 3, 197, 6002, 8, 197, 1,
		197, 1, 197, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 1,
		198, 1, 198, 3, 198, 6015, 8, 198, 1, 199, 1, 199, 1, 200, 1, 200, 1, 200,
		1, 200, 1, 200, 1, 200, 1, 200, 3, 200, 6026, 8, 200, 1, 201, 1, 201, 1,
		201, 5, 201, 6031, 8, 201, 10, 201, 12, 201, 6034, 9, 201, 1, 202, 3, 202,
		6037, 8, 202, 1, 202, 1, 202, 1, 202, 3, 202, 6042, 8, 202, 1, 202, 3,
		202, 6045, 8, 202, 1, 202, 1, 202, 3, 202, 6049, 8, 202, 1, 203, 1, 203,
		1, 203, 1, 203, 1, 203, 1, 203, 3, 203, 6057, 8, 203, 1, 203, 1, 203, 1,
		203, 3, 203, 6062, 8, 203, 1, 203, 1, 203, 5, 203, 6066, 8, 203, 10, 203,
		12, 203, 6069, 9, 203, 1, 203, 1, 203, 1, 203, 1, 203, 1, 203, 1, 203,
		3, 203, 6077, 8, 203, 1, 203, 1, 203, 1, 203, 1, 203, 1, 203, 5, 203, 6084,
		8, 203, 10, 203, 12, 203, 6087, 9, 203, 1, 203, 1, 203, 1, 203, 1, 203,
		1, 203, 5, 203, 6094, 8, 203, 10, 203, 12, 203, 6097, 9, 203, 1, 203, 1,
		203, 1, 203, 3, 203, 6102, 8, 203, 1, 204, 1, 204, 1, 205, 1, 205, 1, 206,
		1, 206, 1, 206, 1, 206, 1, 206, 1, 207, 1, 207, 1, 207, 1, 207, 1, 208,
		1, 208, 1, 209, 1, 209, 3, 209, 6121, 8, 209, 1, 209, 3, 209, 6124, 8,
		209, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1,
		210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1,
		210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 5, 210, 6150, 8, 210,
		10, 210, 12, 210, 6153, 9, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210,
		1, 210, 1, 210, 1, 210, 5, 210, 6163, 8, 210, 10, 210, 12, 210, 6166, 9,
		210, 1, 210, 3, 210, 6169, 8, 210, 3, 210, 6171, 8, 210, 1, 211, 1, 211,
		1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211,
		1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211,
		1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211,
		1, 211, 1, 211, 1, 211, 3, 211, 6205, 8, 211, 1, 212, 1, 212, 1, 212, 5,
		212, 6210, 8, 212, 10, 212, 12, 212, 6213, 9, 212, 1, 213, 1, 213, 1, 213,
		1, 213, 3, 213, 6219, 8, 213, 1, 214, 1, 214, 1, 214, 1, 215, 1, 215, 1,
		215, 3, 215, 6227, 8, 215, 1, 215, 1, 215, 1, 215, 3, 215, 6232, 8, 215,
		1, 216, 1, 216, 1, 216, 1, 216, 3, 216, 6238, 8, 216, 1, 217, 1, 217, 1,
		217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 3, 217, 6250,
		8, 217, 1, 218, 1, 218, 1, 218, 1, 219, 1, 219, 4, 219, 6257, 8, 219, 11,
		219, 12, 219, 6258, 1, 219, 3, 219, 6262, 8, 219, 1, 220, 1, 220, 1, 221,
		1, 221, 1, 221, 3, 221, 6269, 8, 221, 1, 222, 1, 222, 1, 223, 3, 223, 6274,
		8, 223, 1, 223, 1, 223, 3, 223, 6278, 8, 223, 1, 223, 3, 223, 6281, 8,
		223, 1, 224, 1, 224, 1, 224, 2, 526, 533, 4, 228, 372, 380, 382, 225, 0,
		2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,
		40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
		76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108,
		110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138,
		140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168,
		170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198,
		200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228,
		230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258,
		260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288,
		290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318,
		320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348,
		350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378,
		380, 382, 384, 386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408,
		410, 412, 414, 416, 418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438,
		440, 442, 444, 446, 448, 0, 62, 1, 0, 354, 355, 2, 0, 196, 196, 355, 355,
		2, 0, 36, 36, 193, 193, 2, 0, 33, 33, 548, 548, 2, 0, 174, 174, 458, 458,
		3, 0, 18, 18, 151, 151, 483, 483, 2, 0, 192, 192, 224, 224, 2, 0, 340,
		340, 391, 391, 3, 0, 47, 47, 238, 238, 307, 307, 2, 0, 18, 18, 451, 451,
		2, 0, 113, 113, 411, 411, 2, 0, 252, 252, 493, 493, 3, 0, 112, 112, 385,
		385, 469, 469, 1, 0, 499, 500, 2, 0, 163, 163, 506, 506, 2, 0, 82, 82,
		180, 180, 2, 0, 114, 114, 412, 412, 2, 0, 226, 227, 252, 253, 2, 0, 543,
		543, 548, 548, 2, 0, 167, 167, 317, 317, 3, 0, 27, 27, 129, 129, 291, 291,
		1, 0, 147, 148, 3, 0, 122, 122, 218, 218, 297, 297, 2, 0, 224, 224, 466,
		466, 4, 0, 56, 56, 210, 210, 271, 271, 407, 407, 3, 0, 121, 121, 217, 217,
		413, 413, 1, 0, 11, 12, 2, 0, 318, 318, 514, 514, 1, 0, 329, 330, 2, 0,
		269, 269, 368, 368, 3, 0, 200, 200, 271, 271, 417, 417, 2, 0, 128, 128,
		223, 223, 2, 0, 33, 33, 87, 87, 5, 0, 150, 150, 203, 203, 344, 344, 471,
		471, 501, 501, 2, 0, 131, 132, 171, 171, 10, 0, 20, 20, 23, 23, 141, 141,
		276, 276, 290, 290, 320, 320, 328, 328, 341, 341, 397, 397, 422, 422, 3,
		0, 166, 166, 295, 295, 482, 482, 2, 0, 20, 20, 138, 138, 2, 0, 309, 309,
		491, 491, 2, 0, 30, 30, 131, 131, 2, 0, 183, 183, 258, 258, 8, 0, 49, 49,
		199, 199, 214, 214, 288, 288, 294, 294, 361, 361, 382, 383, 445, 445, 1,
		0, 244, 245, 2, 0, 25, 25, 531, 531, 3, 0, 265, 265, 377, 377, 399, 399,
		1, 0, 280, 286, 2, 0, 177, 177, 474, 474, 2, 0, 524, 525, 529, 529, 2,
		0, 143, 143, 526, 528, 1, 0, 524, 525, 2, 0, 200, 200, 417, 417, 2, 0,
		115, 115, 464, 464, 2, 0, 424, 424, 486, 486, 1, 0, 232, 233, 2, 0, 368,
		368, 406, 406, 2, 0, 186, 186, 351, 351, 4, 0, 115, 115, 118, 118, 120,
		120, 464, 464, 1, 0, 517, 523, 8, 0, 121, 121, 217, 217, 296, 296, 299,
		299, 366, 366, 413, 413, 507, 507, 516, 516, 2, 0, 526, 526, 548, 548,
		1, 0, 549, 550, 98, 0, 9, 10, 13, 13, 16, 19, 23, 23, 28, 28, 31, 32, 34,
		35, 37, 40, 43, 43, 46, 60, 62, 64, 68, 73, 75, 76, 78, 80, 82, 94, 96,
		100, 102, 103, 107, 112, 115, 125, 128, 128, 130, 130, 133, 136, 139, 140,
		144, 145, 149, 149, 152, 153, 155, 161, 163, 165, 167, 167, 170, 170, 174,
		174, 176, 176, 178, 183, 190, 191, 194, 194, 196, 196, 198, 200, 203, 203,
		205, 208, 210, 212, 214, 220, 222, 223, 225, 225, 227, 227, 238, 241, 243,
		248, 250, 251, 255, 255, 258, 258, 260, 261, 263, 264, 267, 268, 271, 276,
		278, 279, 281, 288, 290, 294, 296, 302, 304, 308, 310, 310, 313, 313, 315,
		316, 318, 320, 327, 328, 330, 342, 344, 344, 346, 350, 354, 354, 356, 367,
		372, 375, 381, 384, 386, 395, 397, 397, 399, 399, 402, 404, 407, 411, 413,
		413, 416, 418, 421, 422, 425, 425, 427, 431, 433, 445, 451, 451, 455, 458,
		460, 461, 463, 464, 469, 469, 471, 472, 475, 476, 478, 478, 480, 480, 484,
		485, 487, 487, 490, 490, 493, 493, 495, 507, 512, 512, 516, 516, 538, 540,
		7428, 0, 453, 1, 0, 0, 0, 2, 481, 1, 0, 0, 0, 4, 569, 1, 0, 0, 0, 6, 602,
		1, 0, 0, 0, 8, 608, 1, 0, 0, 0, 10, 749, 1, 0, 0, 0, 12, 819, 1, 0, 0,
		0, 14, 840, 1, 0, 0, 0, 16, 992, 1, 0, 0, 0, 18, 1482, 1, 0, 0, 0, 20,
		1484, 1, 0, 0, 0, 22, 1492, 1, 0, 0, 0, 24, 1707, 1, 0, 0, 0, 26, 1910,
		1, 0, 0, 0, 28, 2606, 1, 0, 0, 0, 30, 2679, 1, 0, 0, 0, 32, 2689, 1, 0,
		0, 0, 34, 2767, 1, 0, 0, 0, 36, 2798, 1, 0, 0, 0, 38, 2800, 1, 0, 0, 0,
		40, 2806, 1, 0, 0, 0, 42, 2821, 1, 0, 0, 0, 44, 2871, 1, 0, 0, 0, 46, 2883,
		1, 0, 0, 0, 48, 2885, 1, 0, 0, 0, 50, 2889, 1, 0, 0, 0, 52, 2893, 1, 0,
		0, 0, 54, 2896, 1, 0, 0, 0, 56, 2900, 1, 0, 0, 0, 58, 2925, 1, 0, 0, 0,
		60, 2952, 1, 0, 0, 0, 62, 2977, 1, 0, 0, 0, 64, 3067, 1, 0, 0, 0, 66, 3224,
		1, 0, 0, 0, 68, 3259, 1, 0, 0, 0, 70, 3261, 1, 0, 0, 0, 72, 3270, 1, 0,
		0, 0, 74, 3294, 1, 0, 0, 0, 76, 3338, 1, 0, 0, 0, 78, 3426, 1, 0, 0, 0,
		80, 3433, 1, 0, 0, 0, 82, 3435, 1, 0, 0, 0, 84, 3541, 1, 0, 0, 0, 86, 3543,
		1, 0, 0, 0, 88, 3547, 1, 0, 0, 0, 90, 3782, 1, 0, 0, 0, 92, 3803, 1, 0,
		0, 0, 94, 3824, 1, 0, 0, 0, 96, 3830, 1, 0, 0, 0, 98, 3839, 1, 0, 0, 0,
		100, 3847, 1, 0, 0, 0, 102, 3864, 1, 0, 0, 0, 104, 3866, 1, 0, 0, 0, 106,
		3869, 1, 0, 0, 0, 108, 3875, 1, 0, 0, 0, 110, 3877, 1, 0, 0, 0, 112, 3880,
		1, 0, 0, 0, 114, 4023, 1, 0, 0, 0, 116, 4043, 1, 0, 0, 0, 118, 4063, 1,
		0, 0, 0, 120, 4065, 1, 0, 0, 0, 122, 4079, 1, 0, 0, 0, 124, 4081, 1, 0,
		0, 0, 126, 4089, 1, 0, 0, 0, 128, 4095, 1, 0, 0, 0, 130, 4110, 1, 0, 0,
		0, 132, 4152, 1, 0, 0, 0, 134, 4154, 1, 0, 0, 0, 136, 4208, 1, 0, 0, 0,
		138, 4210, 1, 0, 0, 0, 140, 4262, 1, 0, 0, 0, 142, 4283, 1, 0, 0, 0, 144,
		4285, 1, 0, 0, 0, 146, 4288, 1, 0, 0, 0, 148, 4312, 1, 0, 0, 0, 150, 4334,
		1, 0, 0, 0, 152, 4336, 1, 0, 0, 0, 154, 4369, 1, 0, 0, 0, 156, 4383, 1,
		0, 0, 0, 158, 4399, 1, 0, 0, 0, 160, 4402, 1, 0, 0, 0, 162, 4416, 1, 0,
		0, 0, 164, 4429, 1, 0, 0, 0, 166, 4530, 1, 0, 0, 0, 168, 4532, 1, 0, 0,
		0, 170, 4534, 1, 0, 0, 0, 172, 4544, 1, 0, 0, 0, 174, 4546, 1, 0, 0, 0,
		176, 4553, 1, 0, 0, 0, 178, 4557, 1, 0, 0, 0, 180, 4561, 1, 0, 0, 0, 182,
		4566, 1, 0, 0, 0, 184, 4568, 1, 0, 0, 0, 186, 4578, 1, 0, 0, 0, 188, 4580,
		1, 0, 0, 0, 190, 4591, 1, 0, 0, 0, 192, 4600, 1, 0, 0, 0, 194, 4610, 1,
		0, 0, 0, 196, 4612, 1, 0, 0, 0, 198, 4614, 1, 0, 0, 0, 200, 4622, 1, 0,
		0, 0, 202, 4624, 1, 0, 0, 0, 204, 4626, 1, 0, 0, 0, 206, 4630, 1, 0, 0,
		0, 208, 4634, 1, 0, 0, 0, 210, 4638, 1, 0, 0, 0, 212, 4644, 1, 0, 0, 0,
		214, 4656, 1, 0, 0, 0, 216, 4688, 1, 0, 0, 0, 218, 4690, 1, 0, 0, 0, 220,
		4699, 1, 0, 0, 0, 222, 4742, 1, 0, 0, 0, 224, 4744, 1, 0, 0, 0, 226, 4756,
		1, 0, 0, 0, 228, 4761, 1, 0, 0, 0, 230, 4781, 1, 0, 0, 0, 232, 4789, 1,
		0, 0, 0, 234, 4791, 1, 0, 0, 0, 236, 4815, 1, 0, 0, 0, 238, 4824, 1, 0,
		0, 0, 240, 4833, 1, 0, 0, 0, 242, 4844, 1, 0, 0, 0, 244, 4850, 1, 0, 0,
		0, 246, 4852, 1, 0, 0, 0, 248, 4855, 1, 0, 0, 0, 250, 4859, 1, 0, 0, 0,
		252, 4876, 1, 0, 0, 0, 254, 4879, 1, 0, 0, 0, 256, 4884, 1, 0, 0, 0, 258,
		4892, 1, 0, 0, 0, 260, 4899, 1, 0, 0, 0, 262, 4916, 1, 0, 0, 0, 264, 4940,
		1, 0, 0, 0, 266, 4942, 1, 0, 0, 0, 268, 4997, 1, 0, 0, 0, 270, 4999, 1,
		0, 0, 0, 272, 5012, 1, 0, 0, 0, 274, 5015, 1, 0, 0, 0, 276, 5018, 1, 0,
		0, 0, 278, 5060, 1, 0, 0, 0, 280, 5071, 1, 0, 0, 0, 282, 5073, 1, 0, 0,
		0, 284, 5079, 1, 0, 0, 0, 286, 5087, 1, 0, 0, 0, 288, 5113, 1, 0, 0, 0,
		290, 5118, 1, 0, 0, 0, 292, 5128, 1, 0, 0, 0, 294, 5146, 1, 0, 0, 0, 296,
		5148, 1, 0, 0, 0, 298, 5182, 1, 0, 0, 0, 300, 5188, 1, 0, 0, 0, 302, 5190,
		1, 0, 0, 0, 304, 5194, 1, 0, 0, 0, 306, 5202, 1, 0, 0, 0, 308, 5262, 1,
		0, 0, 0, 310, 5264, 1, 0, 0, 0, 312, 5267, 1, 0, 0, 0, 314, 5272, 1, 0,
		0, 0, 316, 5280, 1, 0, 0, 0, 318, 5286, 1, 0, 0, 0, 320, 5290, 1, 0, 0,
		0, 322, 5299, 1, 0, 0, 0, 324, 5301, 1, 0, 0, 0, 326, 5309, 1, 0, 0, 0,
		328, 5317, 1, 0, 0, 0, 330, 5322, 1, 0, 0, 0, 332, 5330, 1, 0, 0, 0, 334,
		5405, 1, 0, 0, 0, 336, 5413, 1, 0, 0, 0, 338, 5436, 1, 0, 0, 0, 340, 5448,
		1, 0, 0, 0, 342, 5456, 1, 0, 0, 0, 344, 5470, 1, 0, 0, 0, 346, 5484, 1,
		0, 0, 0, 348, 5493, 1, 0, 0, 0, 350, 5518, 1, 0, 0, 0, 352, 5536, 1, 0,
		0, 0, 354, 5538, 1, 0, 0, 0, 356, 5546, 1, 0, 0, 0, 358, 5556, 1, 0, 0,
		0, 360, 5558, 1, 0, 0, 0, 362, 5570, 1, 0, 0, 0, 364, 5579, 1, 0, 0, 0,
		366, 5586, 1, 0, 0, 0, 368, 5596, 1, 0, 0, 0, 370, 5614, 1, 0, 0, 0, 372,
		5640, 1, 0, 0, 0, 374, 5659, 1, 0, 0, 0, 376, 5675, 1, 0, 0, 0, 378, 5728,
		1, 0, 0, 0, 380, 5734, 1, 0, 0, 0, 382, 5886, 1, 0, 0, 0, 384, 5927, 1,
		0, 0, 0, 386, 5934, 1, 0, 0, 0, 388, 5936, 1, 0, 0, 0, 390, 5971, 1, 0,
		0, 0, 392, 5991, 1, 0, 0, 0, 394, 5993, 1, 0, 0, 0, 396, 6014, 1, 0, 0,
		0, 398, 6016, 1, 0, 0, 0, 400, 6025, 1, 0, 0, 0, 402, 6027, 1, 0, 0, 0,
		404, 6048, 1, 0, 0, 0, 406, 6101, 1, 0, 0, 0, 408, 6103, 1, 0, 0, 0, 410,
		6105, 1, 0, 0, 0, 412, 6107, 1, 0, 0, 0, 414, 6112, 1, 0, 0, 0, 416, 6116,
		1, 0, 0, 0, 418, 6118, 1, 0, 0, 0, 420, 6170, 1, 0, 0, 0, 422, 6204, 1,
		0, 0, 0, 424, 6206, 1, 0, 0, 0, 426, 6214, 1, 0, 0, 0, 428, 6220, 1, 0,
		0, 0, 430, 6223, 1, 0, 0, 0, 432, 6237, 1, 0, 0, 0, 434, 6249, 1, 0, 0,
		0, 436, 6251, 1, 0, 0, 0, 438, 6261, 1, 0, 0, 0, 440, 6263, 1, 0, 0, 0,
		442, 6268, 1, 0, 0, 0, 444, 6270, 1, 0, 0, 0, 446, 6280, 1, 0, 0, 0, 448,
		6282, 1, 0, 0, 0, 450, 452, 5, 1, 0, 0, 451, 450, 1, 0, 0, 0, 452, 455,
		1, 0, 0, 0, 453, 451, 1, 0, 0, 0, 453, 454, 1, 0, 0, 0, 454, 457, 1, 0,
		0, 0, 455, 453, 1, 0, 0, 0, 456, 458, 3, 4, 2, 0, 457, 456, 1, 0, 0, 0,
		457, 458, 1, 0, 0, 0, 458, 467, 1, 0, 0, 0, 459, 461, 5, 1, 0, 0, 460,
		459, 1, 0, 0, 0, 461, 462, 1, 0, 0, 0, 462, 460, 1, 0, 0, 0, 462, 463,
		1, 0, 0, 0, 463, 464, 1, 0, 0, 0, 464, 466, 3, 4, 2, 0, 465, 460, 1, 0,
		0, 0, 466, 469, 1, 0, 0, 0, 467, 465, 1, 0, 0, 0, 467, 468, 1, 0, 0, 0,
		468, 473, 1, 0, 0, 0, 469, 467, 1, 0, 0, 0, 470, 472, 5, 1, 0, 0, 471,
		470, 1, 0, 0, 0, 472, 475, 1, 0, 0, 0, 473, 471, 1, 0, 0, 0, 473, 474,
		1, 0, 0, 0, 474, 476, 1, 0, 0, 0, 475, 473, 1, 0, 0, 0, 476, 477, 5, 0,
		0, 1, 477, 1, 1, 0, 0, 0, 478, 480, 5, 1, 0, 0, 479, 478, 1, 0, 0, 0, 480,
		483, 1, 0, 0, 0, 481, 479, 1, 0, 0, 0, 481, 482, 1, 0, 0, 0, 482, 485,
		1, 0, 0, 0, 483, 481, 1, 0, 0, 0, 484, 486, 3, 4, 2, 0, 485, 484, 1, 0,
		0, 0, 485, 486, 1, 0, 0, 0, 486, 490, 1, 0, 0, 0, 487, 489, 5, 1, 0, 0,
		488, 487, 1, 0, 0, 0, 489, 492, 1, 0, 0, 0, 490, 488, 1, 0, 0, 0, 490,
		491, 1, 0, 0, 0, 491, 493, 1, 0, 0, 0, 492, 490, 1, 0, 0, 0, 493, 494,
		5, 0, 0, 1, 494, 3, 1, 0, 0, 0, 495, 570, 3, 6, 3, 0, 496, 497, 5, 64,
		0, 0, 497, 498, 3, 324, 162, 0, 498, 507, 5, 2, 0, 0, 499, 504, 3, 368,
		184, 0, 500, 501, 5, 4, 0, 0, 501, 503, 3, 368, 184, 0, 502, 500, 1, 0,
		0, 0, 503, 506, 1, 0, 0, 0, 504, 502, 1, 0, 0, 0, 504, 505, 1, 0, 0, 0,
		505, 508, 1, 0, 0, 0, 506, 504, 1, 0, 0, 0, 507, 499, 1, 0, 0, 0, 507,
		508, 1, 0, 0, 0, 508, 509, 1, 0, 0, 0, 509, 510, 5, 3, 0, 0, 510, 570,
		1, 0, 0, 0, 511, 519, 5, 21, 0, 0, 512, 515, 5, 101, 0, 0, 513, 514, 5,
		321, 0, 0, 514, 516, 5, 382, 0, 0, 515, 513, 1, 0, 0, 0, 515, 516, 1, 0,
		0, 0, 516, 519, 1, 0, 0, 0, 517, 519, 5, 382, 0, 0, 518, 511, 1, 0, 0,
		0, 518, 512, 1, 0, 0, 0, 518, 517, 1, 0, 0, 0, 519, 520, 1, 0, 0, 0, 520,
		521, 7, 0, 0, 0, 521, 522, 3, 324, 162, 0, 522, 526, 5, 2, 0, 0, 523, 525,
		9, 0, 0, 0, 524, 523, 1, 0, 0, 0, 525, 528, 1, 0, 0, 0, 526, 527, 1, 0,
		0, 0, 526, 524, 1, 0, 0, 0, 527, 529, 1, 0, 0, 0, 528, 526, 1, 0, 0, 0,
		529, 533, 5, 3, 0, 0, 530, 532, 9, 0, 0, 0, 531, 530, 1, 0, 0, 0, 532,
		535, 1, 0, 0, 0, 533, 534, 1, 0, 0, 0, 533, 531, 1, 0, 0, 0, 534, 570,
		1, 0, 0, 0, 535, 533, 1, 0, 0, 0, 536, 537, 5, 147, 0, 0, 537, 540, 7,
		0, 0, 0, 538, 539, 5, 221, 0, 0, 539, 541, 5, 169, 0, 0, 540, 538, 1, 0,
		0, 0, 540, 541, 1, 0, 0, 0, 541, 542, 1, 0, 0, 0, 542, 570, 3, 324, 162,
		0, 543, 544, 5, 423, 0, 0, 544, 545, 7, 1, 0, 0, 545, 549, 5, 438, 0, 0,
		546, 547, 5, 265, 0, 0, 547, 550, 3, 380, 190, 0, 548, 550, 3, 246, 123,
		0, 549, 546, 1, 0, 0, 0, 549, 548, 1, 0, 0, 0, 549, 550, 1, 0, 0, 0, 550,
		570, 1, 0, 0, 0, 551, 552, 5, 423, 0, 0, 552, 553, 5, 101, 0, 0, 553, 554,
		5, 355, 0, 0, 554, 570, 3, 324, 162, 0, 555, 557, 5, 15, 0, 0, 556, 555,
		1, 0, 0, 0, 556, 557, 1, 0, 0, 0, 557, 558, 1, 0, 0, 0, 558, 559, 5, 423,
		0, 0, 559, 560, 7, 2, 0, 0, 560, 563, 5, 91, 0, 0, 561, 562, 5, 265, 0,
		0, 562, 564, 3, 380, 190, 0, 563, 561, 1, 0, 0, 0, 563, 564, 1, 0, 0, 0,
		564, 567, 1, 0, 0, 0, 565, 566, 5, 192, 0, 0, 566, 568, 5, 548, 0, 0, 567,
		565, 1, 0, 0, 0, 567, 568, 1, 0, 0, 0, 568, 570, 1, 0, 0, 0, 569, 495,
		1, 0, 0, 0, 569, 496, 1, 0, 0, 0, 569, 518, 1, 0, 0, 0, 569, 536, 1, 0,
		0, 0, 569, 543, 1, 0, 0, 0, 569, 551, 1, 0, 0, 0, 569, 556, 1, 0, 0, 0,
		570, 5, 1, 0, 0, 0, 571, 573, 3, 192, 96, 0, 572, 571, 1, 0, 0, 0, 572,
		573, 1, 0, 0, 0, 573, 574, 1, 0, 0, 0, 574, 576, 3, 226, 113, 0, 575, 577,
		3, 224, 112, 0, 576, 575, 1, 0, 0, 0, 576, 577, 1, 0, 0, 0, 577, 603, 1,
		0, 0, 0, 578, 603, 3, 16, 8, 0, 579, 603, 3, 18, 9, 0, 580, 603, 3, 24,
		12, 0, 581, 603, 3, 10, 5, 0, 582, 603, 3, 12, 6, 0, 583, 603, 3, 14, 7,
		0, 584, 603, 3, 62, 31, 0, 585, 603, 3, 154, 77, 0, 586, 603, 3, 26, 13,
		0, 587, 603, 3, 136, 68, 0, 588, 603, 3, 148, 74, 0, 589, 603, 3, 60, 30,
		0, 590, 603, 3, 28, 14, 0, 591, 603, 3, 30, 15, 0, 592, 603, 3, 64, 32,
		0, 593, 603, 3, 68, 34, 0, 594, 603, 3, 66, 33, 0, 595, 603, 3, 150, 75,
		0, 596, 603, 3, 34, 17, 0, 597, 603, 3, 32, 16, 0, 598, 603, 3, 114, 57,
		0, 599, 603, 3, 76, 38, 0, 600, 603, 3, 78, 39, 0, 601, 603, 3, 8, 4, 0,
		602, 572, 1, 0, 0, 0, 602, 578, 1, 0, 0, 0, 602, 579, 1, 0, 0, 0, 602,
		580, 1, 0, 0, 0, 602, 581, 1, 0, 0, 0, 602, 582, 1, 0, 0, 0, 602, 583,
		1, 0, 0, 0, 602, 584, 1, 0, 0, 0, 602, 585, 1, 0, 0, 0, 602, 586, 1, 0,
		0, 0, 602, 587, 1, 0, 0, 0, 602, 588, 1, 0, 0, 0, 602, 589, 1, 0, 0, 0,
		602, 590, 1, 0, 0, 0, 602, 591, 1, 0, 0, 0, 602, 592, 1, 0, 0, 0, 602,
		593, 1, 0, 0, 0, 602, 594, 1, 0, 0, 0, 602, 595, 1, 0, 0, 0, 602, 596,
		1, 0, 0, 0, 602, 597, 1, 0, 0, 0, 602, 598, 1, 0, 0, 0, 602, 599, 1, 0,
		0, 0, 602, 600, 1, 0, 0, 0, 602, 601, 1, 0, 0, 0, 603, 7, 1, 0, 0, 0, 604,
		609, 3, 116, 58, 0, 605, 609, 3, 70, 35, 0, 606, 609, 3, 44, 22, 0, 607,
		609, 3, 36, 18, 0, 608, 604, 1, 0, 0, 0, 608, 605, 1, 0, 0, 0, 608, 606,
		1, 0, 0, 0, 608, 607, 1, 0, 0, 0, 609, 9, 1, 0, 0, 0, 610, 611, 5, 101,
		0, 0, 611, 612, 5, 287, 0, 0, 612, 616, 5, 503, 0, 0, 613, 614, 5, 221,
		0, 0, 614, 615, 5, 311, 0, 0, 615, 617, 5, 169, 0, 0, 616, 613, 1, 0, 0,
		0, 616, 617, 1, 0, 0, 0, 617, 618, 1, 0, 0, 0, 618, 623, 3, 324, 162, 0,
		619, 620, 5, 2, 0, 0, 620, 621, 3, 326, 163, 0, 621, 622, 5, 3, 0, 0, 622,
		624, 1, 0, 0, 0, 623, 619, 1, 0, 0, 0, 623, 624, 1, 0, 0, 0, 624, 626,
		1, 0, 0, 0, 625, 627, 3, 170, 85, 0, 626, 625, 1, 0, 0, 0, 626, 627, 1,
		0, 0, 0, 627, 635, 1, 0, 0, 0, 628, 630, 5, 375, 0, 0, 629, 631, 3, 176,
		88, 0, 630, 629, 1, 0, 0, 0, 630, 631, 1, 0, 0, 0, 631, 633, 1, 0, 0, 0,
		632, 634, 3, 172, 86, 0, 633, 632, 1, 0, 0, 0, 633, 634, 1, 0, 0, 0, 634,
		636, 1, 0, 0, 0, 635, 628, 1, 0, 0, 0, 635, 636, 1, 0, 0, 0, 636, 642,
		1, 0, 0, 0, 637, 639, 5, 151, 0, 0, 638, 637, 1, 0, 0, 0, 638, 639, 1,
		0, 0, 0, 639, 640, 1, 0, 0, 0, 640, 641, 5, 252, 0, 0, 641, 643, 3, 302,
		151, 0, 642, 638, 1, 0, 0, 0, 642, 643, 1, 0, 0, 0, 643, 646, 1, 0, 0,
		0, 644, 645, 5, 83, 0, 0, 645, 647, 5, 543, 0, 0, 646, 644, 1, 0, 0, 0,
		646, 647, 1, 0, 0, 0, 647, 654, 1, 0, 0, 0, 648, 649, 5, 329, 0, 0, 649,
		650, 5, 61, 0, 0, 650, 651, 5, 2, 0, 0, 651, 652, 3, 178, 89, 0, 652, 653,
		5, 3, 0, 0, 653, 655, 1, 0, 0, 0, 654, 648, 1, 0, 0, 0, 654, 655, 1, 0,
		0, 0, 655, 667, 1, 0, 0, 0, 656, 657, 5, 141, 0, 0, 657, 661, 5, 61, 0,
		0, 658, 659, 5, 207, 0, 0, 659, 662, 3, 302, 151, 0, 660, 662, 5, 367,
		0, 0, 661, 658, 1, 0, 0, 0, 661, 660, 1, 0, 0, 0, 662, 665, 1, 0, 0, 0,
		663, 664, 5, 57, 0, 0, 664, 666, 7, 3, 0, 0, 665, 663, 1, 0, 0, 0, 665,
		666, 1, 0, 0, 0, 666, 668, 1, 0, 0, 0, 667, 656, 1, 0, 0, 0, 667, 668,
		1, 0, 0, 0, 668, 670, 1, 0, 0, 0, 669, 671, 3, 312, 156, 0, 670, 669, 1,
		0, 0, 0, 670, 671, 1, 0, 0, 0, 671, 672, 1, 0, 0, 0, 672, 673, 5, 29, 0,
		0, 673, 674, 3, 226, 113, 0, 674, 750, 1, 0, 0, 0, 675, 676, 5, 375, 0,
		0, 676, 677, 5, 287, 0, 0, 677, 678, 5, 503, 0, 0, 678, 682, 3, 324, 162,
		0, 679, 683, 3, 158, 79, 0, 680, 683, 5, 87, 0, 0, 681, 683, 5, 33, 0,
		0, 682, 679, 1, 0, 0, 0, 682, 680, 1, 0, 0, 0, 682, 681, 1, 0, 0, 0, 683,
		750, 1, 0, 0, 0, 684, 685, 5, 21, 0, 0, 685, 686, 5, 287, 0, 0, 686, 687,
		5, 503, 0, 0, 687, 711, 3, 324, 162, 0, 688, 689, 5, 379, 0, 0, 689, 712,
		3, 440, 220, 0, 690, 696, 5, 375, 0, 0, 691, 697, 3, 176, 88, 0, 692, 697,
		3, 172, 86, 0, 693, 694, 3, 176, 88, 0, 694, 695, 3, 172, 86, 0, 695, 697,
		1, 0, 0, 0, 696, 691, 1, 0, 0, 0, 696, 692, 1, 0, 0, 0, 696, 693, 1, 0,
		0, 0, 697, 712, 1, 0, 0, 0, 698, 699, 5, 382, 0, 0, 699, 700, 5, 511, 0,
		0, 700, 701, 5, 287, 0, 0, 701, 702, 5, 503, 0, 0, 702, 704, 3, 440, 220,
		0, 703, 705, 3, 312, 156, 0, 704, 703, 1, 0, 0, 0, 704, 705, 1, 0, 0, 0,
		705, 712, 1, 0, 0, 0, 706, 707, 5, 419, 0, 0, 707, 708, 5, 2, 0, 0, 708,
		709, 3, 314, 157, 0, 709, 710, 5, 3, 0, 0, 710, 712, 1, 0, 0, 0, 711, 688,
		1, 0, 0, 0, 711, 690, 1, 0, 0, 0, 711, 698, 1, 0, 0, 0, 711, 706, 1, 0,
		0, 0, 712, 750, 1, 0, 0, 0, 713, 714, 5, 147, 0, 0, 714, 715, 5, 287, 0,
		0, 715, 718, 5, 503, 0, 0, 716, 717, 5, 221, 0, 0, 717, 719, 5, 169, 0,
		0, 718, 716, 1, 0, 0, 0, 718, 719, 1, 0, 0, 0, 719, 720, 1, 0, 0, 0, 720,
		723, 3, 324, 162, 0, 721, 722, 5, 317, 0, 0, 722, 724, 3, 324, 162, 0,
		723, 721, 1, 0, 0, 0, 723, 724, 1, 0, 0, 0, 724, 750, 1, 0, 0, 0, 725,
		726, 5, 337, 0, 0, 726, 727, 5, 287, 0, 0, 727, 728, 5, 503, 0, 0, 728,
		729, 5, 247, 0, 0, 729, 730, 5, 317, 0, 0, 730, 750, 3, 324, 162, 0, 731,
		732, 5, 392, 0, 0, 732, 733, 5, 287, 0, 0, 733, 734, 5, 503, 0, 0, 734,
		735, 5, 247, 0, 0, 735, 736, 5, 317, 0, 0, 736, 750, 3, 324, 162, 0, 737,
		738, 5, 65, 0, 0, 738, 739, 5, 287, 0, 0, 739, 740, 5, 503, 0, 0, 740,
		741, 5, 456, 0, 0, 741, 742, 5, 548, 0, 0, 742, 743, 5, 317, 0, 0, 743,
		750, 3, 324, 162, 0, 744, 745, 5, 423, 0, 0, 745, 746, 5, 101, 0, 0, 746,
		747, 5, 287, 0, 0, 747, 748, 5, 503, 0, 0, 748, 750, 3, 324, 162, 0, 749,
		610, 1, 0, 0, 0, 749, 675, 1, 0, 0, 0, 749, 684, 1, 0, 0, 0, 749, 713,
		1, 0, 0, 0, 749, 725, 1, 0, 0, 0, 749, 731, 1, 0, 0, 0, 749, 737, 1, 0,
		0, 0, 749, 744, 1, 0, 0, 0, 750, 11, 1, 0, 0, 0, 751, 752, 5, 101, 0, 0,
		752, 753, 5, 247, 0, 0, 753, 754, 3, 324, 162, 0, 754, 755, 5, 317, 0,
		0, 755, 775, 5, 409, 0, 0, 756, 757, 5, 165, 0, 0, 757, 758, 5, 548, 0,
		0, 758, 764, 3, 440, 220, 0, 759, 762, 5, 436, 0, 0, 760, 763, 5, 543,
		0, 0, 761, 763, 5, 110, 0, 0, 762, 760, 1, 0, 0, 0, 762, 761, 1, 0, 0,
		0, 763, 765, 1, 0, 0, 0, 764, 759, 1, 0, 0, 0, 764, 765, 1, 0, 0, 0, 765,
		768, 1, 0, 0, 0, 766, 767, 5, 159, 0, 0, 767, 769, 5, 543, 0, 0, 768, 766,
		1, 0, 0, 0, 768, 769, 1, 0, 0, 0, 769, 776, 1, 0, 0, 0, 770, 773, 5, 31,
		0, 0, 771, 774, 5, 543, 0, 0, 772, 774, 5, 110, 0, 0, 773, 771, 1, 0, 0,
		0, 773, 772, 1, 0, 0, 0, 774, 776, 1, 0, 0, 0, 775, 756, 1, 0, 0, 0, 775,
		770, 1, 0, 0, 0, 776, 778, 1, 0, 0, 0, 777, 779, 3, 428, 214, 0, 778, 777,
		1, 0, 0, 0, 778, 779, 1, 0, 0, 0, 779, 780, 1, 0, 0, 0, 780, 781, 5, 144,
		0, 0, 781, 782, 3, 16, 8, 0, 782, 820, 1, 0, 0, 0, 783, 784, 5, 337, 0,
		0, 784, 785, 5, 247, 0, 0, 785, 786, 5, 509, 0, 0, 786, 787, 3, 440, 220,
		0, 787, 788, 5, 517, 0, 0, 788, 789, 5, 543, 0, 0, 789, 820, 1, 0, 0, 0,
		790, 791, 5, 147, 0, 0, 791, 794, 5, 247, 0, 0, 792, 793, 5, 221, 0, 0,
		793, 795, 5, 169, 0, 0, 794, 792, 1, 0, 0, 0, 794, 795, 1, 0, 0, 0, 795,
		796, 1, 0, 0, 0, 796, 797, 5, 509, 0, 0, 797, 798, 3, 440, 220, 0, 798,
		799, 5, 517, 0, 0, 799, 800, 5, 543, 0, 0, 800, 820, 1, 0, 0, 0, 801, 802,
		5, 392, 0, 0, 802, 803, 5, 247, 0, 0, 803, 804, 5, 509, 0, 0, 804, 805,
		3, 440, 220, 0, 805, 806, 5, 517, 0, 0, 806, 807, 5, 543, 0, 0, 807, 820,
		1, 0, 0, 0, 808, 809, 5, 65, 0, 0, 809, 810, 5, 456, 0, 0, 810, 811, 5,
		509, 0, 0, 811, 812, 3, 440, 220, 0, 812, 813, 5, 517, 0, 0, 813, 814,
		5, 543, 0, 0, 814, 815, 5, 25, 0, 0, 815, 816, 3, 440, 220, 0, 816, 817,
		5, 517, 0, 0, 817, 818, 5, 548, 0, 0, 818, 820, 1, 0, 0, 0, 819, 751, 1,
		0, 0, 0, 819, 783, 1, 0, 0, 0, 819, 790, 1, 0, 0, 0, 819, 801, 1, 0, 0,
		0, 819, 808, 1, 0, 0, 0, 820, 13, 1, 0, 0, 0, 821, 822, 5, 21, 0, 0, 822,
		823, 5, 450, 0, 0, 823, 824, 3, 324, 162, 0, 824, 825, 5, 14, 0, 0, 825,
		826, 5, 95, 0, 0, 826, 827, 3, 436, 218, 0, 827, 828, 3, 156, 78, 0, 828,
		841, 1, 0, 0, 0, 829, 830, 5, 21, 0, 0, 830, 831, 5, 450, 0, 0, 831, 832,
		3, 324, 162, 0, 832, 833, 5, 147, 0, 0, 833, 834, 5, 95, 0, 0, 834, 835,
		3, 436, 218, 0, 835, 841, 1, 0, 0, 0, 836, 837, 5, 423, 0, 0, 837, 838,
		5, 96, 0, 0, 838, 839, 5, 192, 0, 0, 839, 841, 3, 324, 162, 0, 840, 821,
		1, 0, 0, 0, 840, 829, 1, 0, 0, 0, 840, 836, 1, 0, 0, 0, 841, 15, 1, 0,
		0, 0, 842, 844, 3, 192, 96, 0, 843, 842, 1, 0, 0, 0, 843, 844, 1, 0, 0,
		0, 844, 846, 1, 0, 0, 0, 845, 847, 3, 236, 118, 0, 846, 845, 1, 0, 0, 0,
		846, 847, 1, 0, 0, 0, 847, 848, 1, 0, 0, 0, 848, 852, 5, 230, 0, 0, 849,
		853, 5, 237, 0, 0, 850, 851, 5, 326, 0, 0, 851, 853, 5, 450, 0, 0, 852,
		849, 1, 0, 0, 0, 852, 850, 1, 0, 0, 0, 853, 859, 1, 0, 0, 0, 854, 860,
		3, 324, 162, 0, 855, 856, 5, 145, 0, 0, 856, 857, 5, 2, 0, 0, 857, 858,
		5, 548, 0, 0, 858, 860, 5, 3, 0, 0, 859, 854, 1, 0, 0, 0, 859, 855, 1,
		0, 0, 0, 860, 862, 1, 0, 0, 0, 861, 863, 3, 158, 79, 0, 862, 861, 1, 0,
		0, 0, 862, 863, 1, 0, 0, 0, 863, 867, 1, 0, 0, 0, 864, 865, 5, 511, 0,
		0, 865, 866, 5, 255, 0, 0, 866, 868, 3, 440, 220, 0, 867, 864, 1, 0, 0,
		0, 867, 868, 1, 0, 0, 0, 868, 870, 1, 0, 0, 0, 869, 871, 3, 302, 151, 0,
		870, 869, 1, 0, 0, 0, 870, 871, 1, 0, 0, 0, 871, 876, 1, 0, 0, 0, 872,
		873, 5, 7, 0, 0, 873, 874, 3, 304, 152, 0, 874, 875, 5, 8, 0, 0, 875, 877,
		1, 0, 0, 0, 876, 872, 1, 0, 0, 0, 876, 877, 1, 0, 0, 0, 877, 878, 1, 0,
		0, 0, 878, 993, 3, 226, 113, 0, 879, 881, 3, 192, 96, 0, 880, 879, 1, 0,
		0, 0, 880, 881, 1, 0, 0, 0, 881, 883, 1, 0, 0, 0, 882, 884, 3, 236, 118,
		0, 883, 882, 1, 0, 0, 0, 883, 884, 1, 0, 0, 0, 884, 885, 1, 0, 0, 0, 885,
		886, 5, 488, 0, 0, 886, 887, 3, 324, 162, 0, 887, 888, 3, 322, 161, 0,
		888, 889, 5, 419, 0, 0, 889, 891, 3, 284, 142, 0, 890, 892, 3, 248, 124,
		0, 891, 890, 1, 0, 0, 0, 891, 892, 1, 0, 0, 0, 892, 894, 1, 0, 0, 0, 893,
		895, 3, 246, 123, 0, 894, 893, 1, 0, 0, 0, 894, 895, 1, 0, 0, 0, 895, 993,
		1, 0, 0, 0, 896, 898, 3, 192, 96, 0, 897, 896, 1, 0, 0, 0, 897, 898, 1,
		0, 0, 0, 898, 900, 1, 0, 0, 0, 899, 901, 3, 236, 118, 0, 900, 899, 1, 0,
		0, 0, 900, 901, 1, 0, 0, 0, 901, 902, 1, 0, 0, 0, 902, 903, 5, 129, 0,
		0, 903, 904, 5, 192, 0, 0, 904, 906, 3, 324, 162, 0, 905, 907, 3, 158,
		79, 0, 906, 905, 1, 0, 0, 0, 906, 907, 1, 0, 0, 0, 907, 908, 1, 0, 0, 0,
		908, 911, 3, 322, 161, 0, 909, 910, 5, 492, 0, 0, 910, 912, 3, 256, 128,
		0, 911, 909, 1, 0, 0, 0, 911, 912, 1, 0, 0, 0, 912, 914, 1, 0, 0, 0, 913,
		915, 3, 246, 123, 0, 914, 913, 1, 0, 0, 0, 914, 915, 1, 0, 0, 0, 915, 993,
		1, 0, 0, 0, 916, 917, 5, 270, 0, 0, 917, 918, 5, 255, 0, 0, 918, 919, 3,
		324, 162, 0, 919, 920, 5, 2, 0, 0, 920, 925, 3, 166, 83, 0, 921, 922, 5,
		4, 0, 0, 922, 924, 3, 166, 83, 0, 923, 921, 1, 0, 0, 0, 924, 927, 1, 0,
		0, 0, 925, 923, 1, 0, 0, 0, 925, 926, 1, 0, 0, 0, 926, 928, 1, 0, 0, 0,
		927, 925, 1, 0, 0, 0, 928, 930, 5, 3, 0, 0, 929, 931, 3, 216, 108, 0, 930,
		929, 1, 0, 0, 0, 930, 931, 1, 0, 0, 0, 931, 933, 1, 0, 0, 0, 932, 934,
		3, 312, 156, 0, 933, 932, 1, 0, 0, 0, 933, 934, 1, 0, 0, 0, 934, 936, 1,
		0, 0, 0, 935, 937, 3, 428, 214, 0, 936, 935, 1, 0, 0, 0, 936, 937, 1, 0,
		0, 0, 937, 993, 1, 0, 0, 0, 938, 939, 5, 172, 0, 0, 939, 940, 5, 450, 0,
		0, 940, 943, 3, 324, 162, 0, 941, 942, 5, 329, 0, 0, 942, 944, 3, 302,
		151, 0, 943, 941, 1, 0, 0, 0, 943, 944, 1, 0, 0, 0, 944, 946, 1, 0, 0,
		0, 945, 947, 3, 246, 123, 0, 946, 945, 1, 0, 0, 0, 946, 947, 1, 0, 0, 0,
		947, 948, 1, 0, 0, 0, 948, 949, 5, 466, 0, 0, 949, 951, 5, 543, 0, 0, 950,
		952, 3, 312, 156, 0, 951, 950, 1, 0, 0, 0, 951, 952, 1, 0, 0, 0, 952, 954,
		1, 0, 0, 0, 953, 955, 3, 216, 108, 0, 954, 953, 1, 0, 0, 0, 954, 955, 1,
		0, 0, 0, 955, 993, 1, 0, 0, 0, 956, 993, 3, 198, 99, 0, 957, 958, 5, 99,
		0, 0, 958, 960, 5, 237, 0, 0, 959, 961, 3, 276, 138, 0, 960, 959, 1, 0,
		0, 0, 960, 961, 1, 0, 0, 0, 961, 962, 1, 0, 0, 0, 962, 964, 3, 324, 162,
		0, 963, 965, 3, 302, 151, 0, 964, 963, 1, 0, 0, 0, 964, 965, 1, 0, 0, 0,
		965, 966, 1, 0, 0, 0, 966, 978, 5, 192, 0, 0, 967, 979, 3, 152, 76, 0,
		968, 969, 5, 2, 0, 0, 969, 970, 5, 414, 0, 0, 970, 971, 3, 244, 122, 0,
		971, 972, 5, 192, 0, 0, 972, 974, 3, 152, 76, 0, 973, 975, 3, 246, 123,
		0, 974, 973, 1, 0, 0, 0, 974, 975, 1, 0, 0, 0, 975, 976, 1, 0, 0, 0, 976,
		977, 5, 3, 0, 0, 977, 979, 1, 0, 0, 0, 978, 967, 1, 0, 0, 0, 978, 968,
		1, 0, 0, 0, 979, 981, 1, 0, 0, 0, 980, 982, 3, 312, 156, 0, 981, 980, 1,
		0, 0, 0, 981, 982, 1, 0, 0, 0, 982, 993, 1, 0, 0, 0, 983, 984, 5, 475,
		0, 0, 984, 985, 5, 450, 0, 0, 985, 987, 3, 324, 162, 0, 986, 988, 3, 404,
		202, 0, 987, 986, 1, 0, 0, 0, 987, 988, 1, 0, 0, 0, 988, 990, 1, 0, 0,
		0, 989, 991, 5, 189, 0, 0, 990, 989, 1, 0, 0, 0, 990, 991, 1, 0, 0, 0,
		991, 993, 1, 0, 0, 0, 992, 843, 1, 0, 0, 0, 992, 880, 1, 0, 0, 0, 992,
		897, 1, 0, 0, 0, 992, 916, 1, 0, 0, 0, 992, 938, 1, 0, 0, 0, 992, 956,
		1, 0, 0, 0, 992, 957, 1, 0, 0, 0, 992, 983, 1, 0, 0, 0, 993, 17, 1, 0,
		0, 0, 994, 996, 5, 101, 0, 0, 995, 997, 7, 4, 0, 0, 996, 995, 1, 0, 0,
		0, 996, 997, 1, 0, 0, 0, 997, 998, 1, 0, 0, 0, 998, 1002, 5, 450, 0, 0,
		999, 1000, 5, 221, 0, 0, 1000, 1001, 5, 311, 0, 0, 1001, 1003, 5, 169,
		0, 0, 1002, 999, 1, 0, 0, 0, 1002, 1003, 1, 0, 0, 0, 1003, 1004, 1, 0,
		0, 0, 1004, 1019, 3, 324, 162, 0, 1005, 1007, 3, 302, 151, 0, 1006, 1005,
		1, 0, 0, 0, 1006, 1007, 1, 0, 0, 0, 1007, 1020, 1, 0, 0, 0, 1008, 1009,
		5, 2, 0, 0, 1009, 1012, 3, 330, 165, 0, 1010, 1011, 5, 4, 0, 0, 1011, 1013,
		3, 334, 167, 0, 1012, 1010, 1, 0, 0, 0, 1012, 1013, 1, 0, 0, 0, 1013, 1015,
		1, 0, 0, 0, 1014, 1016, 5, 4, 0, 0, 1015, 1014, 1, 0, 0, 0, 1015, 1016,
		1, 0, 0, 0, 1016, 1017, 1, 0, 0, 0, 1017, 1018, 5, 3, 0, 0, 1018, 1020,
		1, 0, 0, 0, 1019, 1006, 1, 0, 0, 0, 1019, 1008, 1, 0, 0, 0, 1020, 1024,
		1, 0, 0, 0, 1021, 1022, 5, 160, 0, 0, 1022, 1023, 5, 517, 0, 0, 1023, 1025,
		3, 440, 220, 0, 1024, 1021, 1, 0, 0, 0, 1024, 1025, 1, 0, 0, 0, 1025, 1034,
		1, 0, 0, 0, 1026, 1027, 7, 5, 0, 0, 1027, 1028, 5, 252, 0, 0, 1028, 1032,
		3, 302, 151, 0, 1029, 1030, 5, 75, 0, 0, 1030, 1031, 5, 61, 0, 0, 1031,
		1033, 3, 302, 151, 0, 1032, 1029, 1, 0, 0, 0, 1032, 1033, 1, 0, 0, 0, 1033,
		1035, 1, 0, 0, 0, 1034, 1026, 1, 0, 0, 0, 1034, 1035, 1, 0, 0, 0, 1035,
		1038, 1, 0, 0, 0, 1036, 1037, 5, 83, 0, 0, 1037, 1039, 5, 543, 0, 0, 1038,
		1036, 1, 0, 0, 0, 1038, 1039, 1, 0, 0, 0, 1039, 1041, 1, 0, 0, 0, 1040,
		1042, 3, 160, 80, 0, 1041, 1040, 1, 0, 0, 0, 1041, 1042, 1, 0, 0, 0, 1042,
		1057, 1, 0, 0, 0, 1043, 1044, 5, 141, 0, 0, 1044, 1048, 5, 61, 0, 0, 1045,
		1046, 5, 207, 0, 0, 1046, 1049, 3, 302, 151, 0, 1047, 1049, 5, 367, 0,
		0, 1048, 1045, 1, 0, 0, 0, 1048, 1047, 1, 0, 0, 0, 1049, 1055, 1, 0, 0,
		0, 1050, 1053, 5, 57, 0, 0, 1051, 1054, 5, 548, 0, 0, 1052, 1054, 5, 33,
		0, 0, 1053, 1051, 1, 0, 0, 0, 1053, 1052, 1, 0, 0, 0, 1054, 1056, 1, 0,
		0, 0, 1055, 1050, 1, 0, 0, 0, 1055, 1056, 1, 0, 0, 0, 1056, 1058, 1, 0,
		0, 0, 1057, 1043, 1, 0, 0, 0, 1057, 1058, 1, 0, 0, 0, 1058, 1064, 1, 0,
		0, 0, 1059, 1060, 5, 403, 0, 0, 1060, 1061, 5, 2, 0, 0, 1061, 1062, 3,
		354, 177, 0, 1062, 1063, 5, 3, 0, 0, 1063, 1065, 1, 0, 0, 0, 1064, 1059,
		1, 0, 0, 0, 1064, 1065, 1, 0, 0, 0, 1065, 1067, 1, 0, 0, 0, 1066, 1068,
		3, 312, 156, 0, 1067, 1066, 1, 0, 0, 0, 1067, 1068, 1, 0, 0, 0, 1068, 1071,
		1, 0, 0, 0, 1069, 1070, 5, 56, 0, 0, 1070, 1072, 3, 312, 156, 0, 1071,
		1069, 1, 0, 0, 0, 1071, 1072, 1, 0, 0, 0, 1072, 1075, 1, 0, 0, 0, 1073,
		1074, 5, 29, 0, 0, 1074, 1076, 3, 226, 113, 0, 1075, 1073, 1, 0, 0, 0,
		1075, 1076, 1, 0, 0, 0, 1076, 1483, 1, 0, 0, 0, 1077, 1080, 5, 101, 0,
		0, 1078, 1079, 5, 321, 0, 0, 1079, 1081, 5, 382, 0, 0, 1080, 1078, 1, 0,
		0, 0, 1080, 1081, 1, 0, 0, 0, 1081, 1082, 1, 0, 0, 0, 1082, 1086, 5, 503,
		0, 0, 1083, 1084, 5, 221, 0, 0, 1084, 1085, 5, 311, 0, 0, 1085, 1087, 5,
		169, 0, 0, 1086, 1083, 1, 0, 0, 0, 1086, 1087, 1, 0, 0, 0, 1087, 1088,
		1, 0, 0, 0, 1088, 1093, 3, 324, 162, 0, 1089, 1090, 5, 2, 0, 0, 1090, 1091,
		3, 326, 163, 0, 1091, 1092, 5, 3, 0, 0, 1092, 1094, 1, 0, 0, 0, 1093, 1089,
		1, 0, 0, 0, 1093, 1094, 1, 0, 0, 0, 1094, 1097, 1, 0, 0, 0, 1095, 1096,
		5, 83, 0, 0, 1096, 1098, 5, 543, 0, 0, 1097, 1095, 1, 0, 0, 0, 1097, 1098,
		1, 0, 0, 0, 1098, 1099, 1, 0, 0, 0, 1099, 1100, 5, 29, 0, 0, 1100, 1101,
		3, 226, 113, 0, 1101, 1483, 1, 0, 0, 0, 1102, 1103, 5, 101, 0, 0, 1103,
		1104, 5, 181, 0, 0, 1104, 1107, 5, 543, 0, 0, 1105, 1106, 7, 6, 0, 0, 1106,
		1108, 3, 440, 220, 0, 1107, 1105, 1, 0, 0, 0, 1107, 1108, 1, 0, 0, 0, 1108,
		1109, 1, 0, 0, 0, 1109, 1483, 3, 312, 156, 0, 1110, 1112, 5, 101, 0, 0,
		1111, 1113, 7, 4, 0, 0, 1112, 1111, 1, 0, 0, 0, 1112, 1113, 1, 0, 0, 0,
		1113, 1114, 1, 0, 0, 0, 1114, 1118, 5, 450, 0, 0, 1115, 1116, 5, 221, 0,
		0, 1116, 1117, 5, 311, 0, 0, 1117, 1119, 5, 169, 0, 0, 1118, 1115, 1, 0,
		0, 0, 1118, 1119, 1, 0, 0, 0, 1119, 1120, 1, 0, 0, 0, 1120, 1121, 3, 324,
		162, 0, 1121, 1122, 5, 265, 0, 0, 1122, 1128, 3, 324, 162, 0, 1123, 1124,
		5, 511, 0, 0, 1124, 1126, 5, 403, 0, 0, 1125, 1127, 3, 302, 151, 0, 1126,
		1125, 1, 0, 0, 0, 1126, 1127, 1, 0, 0, 0, 1127, 1129, 1, 0, 0, 0, 1128,
		1123, 1, 0, 0, 0, 1128, 1129, 1, 0, 0, 0, 1129, 1483, 1, 0, 0, 0, 1130,
		1131, 5, 101, 0, 0, 1131, 1135, 5, 400, 0, 0, 1132, 1133, 5, 221, 0, 0,
		1133, 1134, 5, 311, 0, 0, 1134, 1136, 5, 169, 0, 0, 1135, 1132, 1, 0, 0,
		0, 1135, 1136, 1, 0, 0, 0, 1136, 1137, 1, 0, 0, 0, 1137, 1140, 3, 180,
		90, 0, 1138, 1139, 5, 83, 0, 0, 1139, 1141, 5, 543, 0, 0, 1140, 1138, 1,
		0, 0, 0, 1140, 1141, 1, 0, 0, 0, 1141, 1483, 1, 0, 0, 0, 1142, 1143, 5,
		101, 0, 0, 1143, 1144, 5, 513, 0, 0, 1144, 1148, 5, 204, 0, 0, 1145, 1146,
		5, 221, 0, 0, 1146, 1147, 5, 311, 0, 0, 1147, 1149, 5, 169, 0, 0, 1148,
		1145, 1, 0, 0, 0, 1148, 1149, 1, 0, 0, 0, 1149, 1150, 1, 0, 0, 0, 1150,
		1153, 3, 180, 90, 0, 1151, 1152, 5, 187, 0, 0, 1152, 1154, 3, 180, 90,
		0, 1153, 1151, 1, 0, 0, 0, 1153, 1154, 1, 0, 0, 0, 1154, 1156, 1, 0, 0,
		0, 1155, 1157, 3, 312, 156, 0, 1156, 1155, 1, 0, 0, 0, 1156, 1157, 1, 0,
		0, 0, 1157, 1483, 1, 0, 0, 0, 1158, 1159, 5, 101, 0, 0, 1159, 1163, 5,
		68, 0, 0, 1160, 1161, 5, 221, 0, 0, 1161, 1162, 5, 311, 0, 0, 1162, 1164,
		5, 169, 0, 0, 1163, 1160, 1, 0, 0, 0, 1163, 1164, 1, 0, 0, 0, 1164, 1165,
		1, 0, 0, 0, 1165, 1169, 3, 440, 220, 0, 1166, 1167, 5, 511, 0, 0, 1167,
		1168, 5, 388, 0, 0, 1168, 1170, 3, 440, 220, 0, 1169, 1166, 1, 0, 0, 0,
		1169, 1170, 1, 0, 0, 0, 1170, 1173, 1, 0, 0, 0, 1171, 1172, 5, 83, 0, 0,
		1172, 1174, 5, 543, 0, 0, 1173, 1171, 1, 0, 0, 0, 1173, 1174, 1, 0, 0,
		0, 1174, 1176, 1, 0, 0, 0, 1175, 1177, 3, 312, 156, 0, 1176, 1175, 1, 0,
		0, 0, 1176, 1177, 1, 0, 0, 0, 1177, 1483, 1, 0, 0, 0, 1178, 1179, 5, 101,
		0, 0, 1179, 1180, 5, 405, 0, 0, 1180, 1184, 5, 350, 0, 0, 1181, 1182, 5,
		221, 0, 0, 1182, 1183, 5, 311, 0, 0, 1183, 1185, 5, 169, 0, 0, 1184, 1181,
		1, 0, 0, 0, 1184, 1185, 1, 0, 0, 0, 1185, 1186, 1, 0, 0, 0, 1186, 1187,
		3, 440, 220, 0, 1187, 1188, 5, 317, 0, 0, 1188, 1189, 3, 324, 162, 0, 1189,
		1190, 5, 29, 0, 0, 1190, 1191, 7, 7, 0, 0, 1191, 1195, 5, 466, 0, 0, 1192,
		1196, 3, 188, 94, 0, 1193, 1194, 5, 400, 0, 0, 1194, 1196, 3, 180, 90,
		0, 1195, 1192, 1, 0, 0, 0, 1195, 1193, 1, 0, 0, 0, 1196, 1197, 1, 0, 0,
		0, 1197, 1198, 5, 492, 0, 0, 1198, 1199, 5, 2, 0, 0, 1199, 1200, 3, 372,
		186, 0, 1200, 1201, 5, 3, 0, 0, 1201, 1483, 1, 0, 0, 0, 1202, 1203, 5,
		101, 0, 0, 1203, 1204, 5, 440, 0, 0, 1204, 1208, 5, 350, 0, 0, 1205, 1206,
		5, 221, 0, 0, 1206, 1207, 5, 311, 0, 0, 1207, 1209, 5, 169, 0, 0, 1208,
		1205, 1, 0, 0, 0, 1208, 1209, 1, 0, 0, 0, 1209, 1210, 1, 0, 0, 0, 1210,
		1212, 3, 440, 220, 0, 1211, 1213, 3, 312, 156, 0, 1212, 1211, 1, 0, 0,
		0, 1212, 1213, 1, 0, 0, 0, 1213, 1483, 1, 0, 0, 0, 1214, 1215, 5, 58, 0,
		0, 1215, 1216, 5, 226, 0, 0, 1216, 1217, 3, 440, 220, 0, 1217, 1218, 5,
		317, 0, 0, 1218, 1220, 3, 324, 162, 0, 1219, 1221, 3, 158, 79, 0, 1220,
		1219, 1, 0, 0, 0, 1220, 1221, 1, 0, 0, 0, 1221, 1483, 1, 0, 0, 0, 1222,
		1223, 5, 101, 0, 0, 1223, 1227, 5, 226, 0, 0, 1224, 1225, 5, 221, 0, 0,
		1225, 1226, 5, 311, 0, 0, 1226, 1228, 5, 169, 0, 0, 1227, 1224, 1, 0, 0,
		0, 1227, 1228, 1, 0, 0, 0, 1228, 1229, 1, 0, 0, 0, 1229, 1230, 3, 440,
		220, 0, 1230, 1231, 5, 317, 0, 0, 1231, 1232, 3, 324, 162, 0, 1232, 1235,
		3, 302, 151, 0, 1233, 1234, 5, 492, 0, 0, 1234, 1236, 7, 8, 0, 0, 1235,
		1233, 1, 0, 0, 0, 1235, 1236, 1, 0, 0, 0, 1236, 1238, 1, 0, 0, 0, 1237,
		1239, 3, 312, 156, 0, 1238, 1237, 1, 0, 0, 0, 1238, 1239, 1, 0, 0, 0, 1239,
		1242, 1, 0, 0, 0, 1240, 1241, 5, 83, 0, 0, 1241, 1243, 5, 543, 0, 0, 1242,
		1240, 1, 0, 0, 0, 1242, 1243, 1, 0, 0, 0, 1243, 1483, 1, 0, 0, 0, 1244,
		1245, 5, 101, 0, 0, 1245, 1246, 5, 513, 0, 0, 1246, 1250, 5, 350, 0, 0,
		1247, 1248, 5, 221, 0, 0, 1248, 1249, 5, 311, 0, 0, 1249, 1251, 5, 169,
		0, 0, 1250, 1247, 1, 0, 0, 0, 1250, 1251, 1, 0, 0, 0, 1251, 1252, 1, 0,
		0, 0, 1252, 1258, 3, 180, 90, 0, 1253, 1254, 5, 90, 0, 0, 1254, 1255, 5,
		2, 0, 0, 1255, 1256, 3, 124, 62, 0, 1256, 1257, 5, 3, 0, 0, 1257, 1259,
		1, 0, 0, 0, 1258, 1253, 1, 0, 0, 0, 1258, 1259, 1, 0, 0, 0, 1259, 1265,
		1, 0, 0, 0, 1260, 1261, 5, 13, 0, 0, 1261, 1262, 5, 2, 0, 0, 1262, 1263,
		3, 120, 60, 0, 1263, 1264, 5, 3, 0, 0, 1264, 1266, 1, 0, 0, 0, 1265, 1260,
		1, 0, 0, 0, 1265, 1266, 1, 0, 0, 0, 1266, 1268, 1, 0, 0, 0, 1267, 1269,
		3, 312, 156, 0, 1268, 1267, 1, 0, 0, 0, 1268, 1269, 1, 0, 0, 0, 1269, 1483,
		1, 0, 0, 0, 1270, 1271, 5, 101, 0, 0, 1271, 1275, 5, 432, 0, 0, 1272, 1273,
		5, 221, 0, 0, 1273, 1274, 5, 311, 0, 0, 1274, 1276, 5, 169, 0, 0, 1275,
		1272, 1, 0, 0, 0, 1275, 1276, 1, 0, 0, 0, 1276, 1277, 1, 0, 0, 0, 1277,
		1279, 3, 440, 220, 0, 1278, 1280, 3, 312, 156, 0, 1279, 1278, 1, 0, 0,
		0, 1279, 1280, 1, 0, 0, 0, 1280, 1483, 1, 0, 0, 0, 1281, 1282, 5, 101,
		0, 0, 1282, 1286, 5, 156, 0, 0, 1283, 1284, 5, 221, 0, 0, 1284, 1285, 5,
		311, 0, 0, 1285, 1287, 5, 169, 0, 0, 1286, 1283, 1, 0, 0, 0, 1286, 1287,
		1, 0, 0, 0, 1287, 1288, 1, 0, 0, 0, 1288, 1289, 3, 324, 162, 0, 1289, 1290,
		5, 29, 0, 0, 1290, 1291, 5, 543, 0, 0, 1291, 1483, 1, 0, 0, 0, 1292, 1294,
		5, 101, 0, 0, 1293, 1295, 3, 168, 84, 0, 1294, 1293, 1, 0, 0, 0, 1294,
		1295, 1, 0, 0, 0, 1295, 1297, 1, 0, 0, 0, 1296, 1298, 7, 9, 0, 0, 1297,
		1296, 1, 0, 0, 0, 1297, 1298, 1, 0, 0, 0, 1298, 1299, 1, 0, 0, 0, 1299,
		1303, 5, 196, 0, 0, 1300, 1301, 5, 221, 0, 0, 1301, 1302, 5, 311, 0, 0,
		1302, 1304, 5, 169, 0, 0, 1303, 1300, 1, 0, 0, 0, 1303, 1304, 1, 0, 0,
		0, 1304, 1305, 1, 0, 0, 0, 1305, 1306, 3, 390, 195, 0, 1306, 1308, 5, 2,
		0, 0, 1307, 1309, 3, 132, 66, 0, 1308, 1307, 1, 0, 0, 0, 1308, 1309, 1,
		0, 0, 0, 1309, 1310, 1, 0, 0, 0, 1310, 1311, 5, 3, 0, 0, 1311, 1312, 5,
		395, 0, 0, 1312, 1315, 3, 420, 210, 0, 1313, 1314, 5, 234, 0, 0, 1314,
		1316, 3, 420, 210, 0, 1315, 1313, 1, 0, 0, 0, 1315, 1316, 1, 0, 0, 0, 1316,
		1318, 1, 0, 0, 0, 1317, 1319, 3, 312, 156, 0, 1318, 1317, 1, 0, 0, 0, 1318,
		1319, 1, 0, 0, 0, 1319, 1483, 1, 0, 0, 0, 1320, 1322, 5, 101, 0, 0, 1321,
		1323, 3, 168, 84, 0, 1322, 1321, 1, 0, 0, 0, 1322, 1323, 1, 0, 0, 0, 1323,
		1324, 1, 0, 0, 0, 1324, 1325, 5, 19, 0, 0, 1325, 1329, 5, 196, 0, 0, 1326,
		1327, 5, 221, 0, 0, 1327, 1328, 5, 311, 0, 0, 1328, 1330, 5, 169, 0, 0,
		1329, 1326, 1, 0, 0, 0, 1329, 1330, 1, 0, 0, 0, 1330, 1331, 1, 0, 0, 0,
		1331, 1332, 3, 390, 195, 0, 1332, 1334, 5, 2, 0, 0, 1333, 1335, 3, 132,
		66, 0, 1334, 1333, 1, 0, 0, 0, 1334, 1335, 1, 0, 0, 0, 1335, 1336, 1, 0,
		0, 0, 1336, 1337, 5, 3, 0, 0, 1337, 1338, 5, 511, 0, 0, 1338, 1339, 5,
		327, 0, 0, 1339, 1341, 5, 2, 0, 0, 1340, 1342, 3, 304, 152, 0, 1341, 1340,
		1, 0, 0, 0, 1341, 1342, 1, 0, 0, 0, 1342, 1343, 1, 0, 0, 0, 1343, 1344,
		5, 3, 0, 0, 1344, 1345, 5, 29, 0, 0, 1345, 1346, 3, 368, 184, 0, 1346,
		1483, 1, 0, 0, 0, 1347, 1348, 5, 101, 0, 0, 1348, 1352, 5, 490, 0, 0, 1349,
		1350, 5, 221, 0, 0, 1350, 1351, 5, 311, 0, 0, 1351, 1353, 5, 169, 0, 0,
		1352, 1349, 1, 0, 0, 0, 1352, 1353, 1, 0, 0, 0, 1353, 1354, 1, 0, 0, 0,
		1354, 1359, 3, 190, 95, 0, 1355, 1360, 5, 446, 0, 0, 1356, 1357, 5, 127,
		0, 0, 1357, 1358, 5, 400, 0, 0, 1358, 1360, 5, 543, 0, 0, 1359, 1355, 1,
		0, 0, 0, 1359, 1356, 1, 0, 0, 0, 1359, 1360, 1, 0, 0, 0, 1360, 1361, 1,
		0, 0, 0, 1361, 1363, 3, 130, 65, 0, 1362, 1364, 3, 428, 214, 0, 1363, 1362,
		1, 0, 0, 0, 1363, 1364, 1, 0, 0, 0, 1364, 1483, 1, 0, 0, 0, 1365, 1366,
		5, 101, 0, 0, 1366, 1370, 7, 10, 0, 0, 1367, 1368, 5, 221, 0, 0, 1368,
		1369, 5, 311, 0, 0, 1369, 1371, 5, 169, 0, 0, 1370, 1367, 1, 0, 0, 0, 1370,
		1371, 1, 0, 0, 0, 1371, 1372, 1, 0, 0, 0, 1372, 1374, 3, 324, 162, 0, 1373,
		1375, 3, 312, 156, 0, 1374, 1373, 1, 0, 0, 0, 1374, 1375, 1, 0, 0, 0, 1375,
		1483, 1, 0, 0, 0, 1376, 1379, 5, 101, 0, 0, 1377, 1378, 5, 369, 0, 0, 1378,
		1380, 5, 318, 0, 0, 1379, 1377, 1, 0, 0, 0, 1379, 1380, 1, 0, 0, 0, 1380,
		1381, 1, 0, 0, 0, 1381, 1382, 5, 387, 0, 0, 1382, 1383, 3, 440, 220, 0,
		1383, 1384, 5, 511, 0, 0, 1384, 1385, 3, 128, 64, 0, 1385, 1483, 1, 0,
		0, 0, 1386, 1388, 5, 101, 0, 0, 1387, 1389, 5, 174, 0, 0, 1388, 1387, 1,
		0, 0, 0, 1388, 1389, 1, 0, 0, 0, 1389, 1390, 1, 0, 0, 0, 1390, 1394, 5,
		388, 0, 0, 1391, 1392, 5, 221, 0, 0, 1392, 1393, 5, 311, 0, 0, 1393, 1395,
		5, 169, 0, 0, 1394, 1391, 1, 0, 0, 0, 1394, 1395, 1, 0, 0, 0, 1395, 1396,
		1, 0, 0, 0, 1396, 1398, 3, 180, 90, 0, 1397, 1399, 3, 312, 156, 0, 1398,
		1397, 1, 0, 0, 0, 1398, 1399, 1, 0, 0, 0, 1399, 1483, 1, 0, 0, 0, 1400,
		1401, 5, 101, 0, 0, 1401, 1405, 5, 136, 0, 0, 1402, 1403, 5, 221, 0, 0,
		1403, 1404, 5, 311, 0, 0, 1404, 1406, 5, 169, 0, 0, 1405, 1402, 1, 0, 0,
		0, 1405, 1406, 1, 0, 0, 0, 1406, 1407, 1, 0, 0, 0, 1407, 1408, 3, 324,
		162, 0, 1408, 1409, 5, 492, 0, 0, 1409, 1410, 3, 324, 162, 0, 1410, 1411,
		5, 2, 0, 0, 1411, 1412, 3, 20, 10, 0, 1412, 1413, 5, 3, 0, 0, 1413, 1414,
		5, 257, 0, 0, 1414, 1415, 5, 2, 0, 0, 1415, 1416, 3, 440, 220, 0, 1416,
		1418, 5, 3, 0, 0, 1417, 1419, 3, 312, 156, 0, 1418, 1417, 1, 0, 0, 0, 1418,
		1419, 1, 0, 0, 0, 1419, 1483, 1, 0, 0, 0, 1420, 1421, 5, 101, 0, 0, 1421,
		1425, 5, 433, 0, 0, 1422, 1423, 5, 221, 0, 0, 1423, 1424, 5, 311, 0, 0,
		1424, 1426, 5, 169, 0, 0, 1425, 1422, 1, 0, 0, 0, 1425, 1426, 1, 0, 0,
		0, 1426, 1427, 1, 0, 0, 0, 1427, 1429, 3, 440, 220, 0, 1428, 1430, 3, 312,
		156, 0, 1429, 1428, 1, 0, 0, 0, 1429, 1430, 1, 0, 0, 0, 1430, 1483, 1,
		0, 0, 0, 1431, 1432, 5, 101, 0, 0, 1432, 1433, 5, 440, 0, 0, 1433, 1437,
		5, 499, 0, 0, 1434, 1435, 5, 221, 0, 0, 1435, 1436, 5, 311, 0, 0, 1436,
		1438, 5, 169, 0, 0, 1437, 1434, 1, 0, 0, 0, 1437, 1438, 1, 0, 0, 0, 1438,
		1439, 1, 0, 0, 0, 1439, 1441, 3, 180, 90, 0, 1440, 1442, 3, 312, 156, 0,
		1441, 1440, 1, 0, 0, 0, 1441, 1442, 1, 0, 0, 0, 1442, 1483, 1, 0, 0, 0,
		1443, 1444, 5, 101, 0, 0, 1444, 1445, 5, 238, 0, 0, 1445, 1446, 5, 226,
		0, 0, 1446, 1450, 5, 24, 0, 0, 1447, 1448, 5, 221, 0, 0, 1448, 1449, 5,
		311, 0, 0, 1449, 1451, 5, 169, 0, 0, 1450, 1447, 1, 0, 0, 0, 1450, 1451,
		1, 0, 0, 0, 1451, 1452, 1, 0, 0, 0, 1452, 1454, 3, 440, 220, 0, 1453, 1455,
		3, 312, 156, 0, 1454, 1453, 1, 0, 0, 0, 1454, 1455, 1, 0, 0, 0, 1455, 1483,
		1, 0, 0, 0, 1456, 1457, 5, 101, 0, 0, 1457, 1458, 5, 238, 0, 0, 1458, 1459,
		5, 226, 0, 0, 1459, 1463, 5, 467, 0, 0, 1460, 1461, 5, 221, 0, 0, 1461,
		1462, 5, 311, 0, 0, 1462, 1464, 5, 169, 0, 0, 1463, 1460, 1, 0, 0, 0, 1463,
		1464, 1, 0, 0, 0, 1464, 1465, 1, 0, 0, 0, 1465, 1467, 3, 440, 220, 0, 1466,
		1468, 3, 312, 156, 0, 1467, 1466, 1, 0, 0, 0, 1467, 1468, 1, 0, 0, 0, 1468,
		1483, 1, 0, 0, 0, 1469, 1470, 5, 101, 0, 0, 1470, 1471, 5, 238, 0, 0, 1471,
		1472, 5, 226, 0, 0, 1472, 1476, 5, 468, 0, 0, 1473, 1474, 5, 221, 0, 0,
		1474, 1475, 5, 311, 0, 0, 1475, 1477, 5, 169, 0, 0, 1476, 1473, 1, 0, 0,
		0, 1476, 1477, 1, 0, 0, 0, 1477, 1478, 1, 0, 0, 0, 1478, 1480, 3, 440,
		220, 0, 1479, 1481, 3, 312, 156, 0, 1480, 1479, 1, 0, 0, 0, 1480, 1481,
		1, 0, 0, 0, 1481, 1483, 1, 0, 0, 0, 1482, 994, 1, 0, 0, 0, 1482, 1077,
		1, 0, 0, 0, 1482, 1102, 1, 0, 0, 0, 1482, 1110, 1, 0, 0, 0, 1482, 1130,
		1, 0, 0, 0, 1482, 1142, 1, 0, 0, 0, 1482, 1158, 1, 0, 0, 0, 1482, 1178,
		1, 0, 0, 0, 1482, 1202, 1, 0, 0, 0, 1482, 1214, 1, 0, 0, 0, 1482, 1222,
		1, 0, 0, 0, 1482, 1244, 1, 0, 0, 0, 1482, 1270, 1, 0, 0, 0, 1482, 1281,
		1, 0, 0, 0, 1482, 1292, 1, 0, 0, 0, 1482, 1320, 1, 0, 0, 0, 1482, 1347,
		1, 0, 0, 0, 1482, 1365, 1, 0, 0, 0, 1482, 1376, 1, 0, 0, 0, 1482, 1386,
		1, 0, 0, 0, 1482, 1400, 1, 0, 0, 0, 1482, 1420, 1, 0, 0, 0, 1482, 1431,
		1, 0, 0, 0, 1482, 1443, 1, 0, 0, 0, 1482, 1456, 1, 0, 0, 0, 1482, 1469,
		1, 0, 0, 0, 1483, 19, 1, 0, 0, 0, 1484, 1489, 3, 22, 11, 0, 1485, 1486,
		5, 4, 0, 0, 1486, 1488, 3, 22, 11, 0, 1487, 1485, 1, 0, 0, 0, 1488, 1491,
		1, 0, 0, 0, 1489, 1487, 1, 0, 0, 0, 1489, 1490, 1, 0, 0, 0, 1490, 21, 1,
		0, 0, 0, 1491, 1489, 1, 0, 0, 0, 1492, 1493, 3, 440, 220, 0, 1493, 1494,
		7, 11, 0, 0, 1494, 23, 1, 0, 0, 0, 1495, 1496, 5, 21, 0, 0, 1496, 1497,
		5, 449, 0, 0, 1497, 1708, 3, 84, 42, 0, 1498, 1499, 5, 21, 0, 0, 1499,
		1500, 5, 503, 0, 0, 1500, 1515, 3, 324, 162, 0, 1501, 1502, 5, 298, 0,
		0, 1502, 1516, 3, 428, 214, 0, 1503, 1504, 5, 2, 0, 0, 1504, 1505, 3, 326,
		163, 0, 1505, 1506, 5, 3, 0, 0, 1506, 1508, 1, 0, 0, 0, 1507, 1503, 1,
		0, 0, 0, 1507, 1508, 1, 0, 0, 0, 1508, 1511, 1, 0, 0, 0, 1509, 1510, 5,
		83, 0, 0, 1510, 1512, 5, 543, 0, 0, 1511, 1509, 1, 0, 0, 0, 1511, 1512,
		1, 0, 0, 0, 1512, 1513, 1, 0, 0, 0, 1513, 1514, 5, 29, 0, 0, 1514, 1516,
		3, 226, 113, 0, 1515, 1501, 1, 0, 0, 0, 1515, 1507, 1, 0, 0, 0, 1516, 1708,
		1, 0, 0, 0, 1517, 1518, 5, 21, 0, 0, 1518, 1519, 5, 68, 0, 0, 1519, 1520,
		3, 440, 220, 0, 1520, 1521, 5, 379, 0, 0, 1521, 1522, 3, 440, 220, 0, 1522,
		1708, 1, 0, 0, 0, 1523, 1524, 5, 21, 0, 0, 1524, 1525, 5, 400, 0, 0, 1525,
		1526, 3, 180, 90, 0, 1526, 1527, 3, 428, 214, 0, 1527, 1708, 1, 0, 0, 0,
		1528, 1529, 5, 21, 0, 0, 1529, 1530, 5, 440, 0, 0, 1530, 1531, 5, 499,
		0, 0, 1531, 1532, 3, 324, 162, 0, 1532, 1533, 3, 312, 156, 0, 1533, 1708,
		1, 0, 0, 0, 1534, 1535, 5, 21, 0, 0, 1535, 1536, 5, 513, 0, 0, 1536, 1537,
		5, 204, 0, 0, 1537, 1540, 3, 180, 90, 0, 1538, 1539, 5, 187, 0, 0, 1539,
		1541, 3, 180, 90, 0, 1540, 1538, 1, 0, 0, 0, 1540, 1541, 1, 0, 0, 0, 1541,
		1543, 1, 0, 0, 0, 1542, 1544, 3, 312, 156, 0, 1543, 1542, 1, 0, 0, 0, 1543,
		1544, 1, 0, 0, 0, 1544, 1708, 1, 0, 0, 0, 1545, 1546, 5, 21, 0, 0, 1546,
		1547, 5, 68, 0, 0, 1547, 1548, 3, 440, 220, 0, 1548, 1549, 5, 419, 0, 0,
		1549, 1550, 5, 358, 0, 0, 1550, 1551, 5, 2, 0, 0, 1551, 1552, 3, 314, 157,
		0, 1552, 1553, 5, 3, 0, 0, 1553, 1708, 1, 0, 0, 0, 1554, 1555, 5, 21, 0,
		0, 1555, 1556, 5, 513, 0, 0, 1556, 1557, 5, 350, 0, 0, 1557, 1559, 3, 180,
		90, 0, 1558, 1560, 3, 312, 156, 0, 1559, 1558, 1, 0, 0, 0, 1559, 1560,
		1, 0, 0, 0, 1560, 1708, 1, 0, 0, 0, 1561, 1562, 5, 21, 0, 0, 1562, 1563,
		5, 432, 0, 0, 1563, 1565, 3, 440, 220, 0, 1564, 1566, 3, 312, 156, 0, 1565,
		1564, 1, 0, 0, 0, 1565, 1566, 1, 0, 0, 0, 1566, 1708, 1, 0, 0, 0, 1567,
		1568, 5, 21, 0, 0, 1568, 1569, 5, 68, 0, 0, 1569, 1570, 3, 440, 220, 0,
		1570, 1571, 5, 298, 0, 0, 1571, 1572, 5, 83, 0, 0, 1572, 1573, 5, 543,
		0, 0, 1573, 1708, 1, 0, 0, 0, 1574, 1575, 5, 21, 0, 0, 1575, 1576, 5, 113,
		0, 0, 1576, 1577, 3, 440, 220, 0, 1577, 1578, 5, 379, 0, 0, 1578, 1579,
		3, 440, 220, 0, 1579, 1708, 1, 0, 0, 0, 1580, 1581, 5, 21, 0, 0, 1581,
		1582, 5, 440, 0, 0, 1582, 1583, 5, 350, 0, 0, 1583, 1584, 3, 180, 90, 0,
		1584, 1585, 3, 312, 156, 0, 1585, 1708, 1, 0, 0, 0, 1586, 1587, 5, 21,
		0, 0, 1587, 1588, 5, 450, 0, 0, 1588, 1589, 3, 324, 162, 0, 1589, 1594,
		3, 90, 45, 0, 1590, 1591, 5, 4, 0, 0, 1591, 1593, 3, 90, 45, 0, 1592, 1590,
		1, 0, 0, 0, 1593, 1596, 1, 0, 0, 0, 1594, 1592, 1, 0, 0, 0, 1594, 1595,
		1, 0, 0, 0, 1595, 1708, 1, 0, 0, 0, 1596, 1594, 1, 0, 0, 0, 1597, 1598,
		5, 21, 0, 0, 1598, 1599, 5, 450, 0, 0, 1599, 1600, 3, 324, 162, 0, 1600,
		1601, 5, 14, 0, 0, 1601, 1602, 5, 403, 0, 0, 1602, 1607, 3, 88, 44, 0,
		1603, 1604, 5, 4, 0, 0, 1604, 1606, 3, 88, 44, 0, 1605, 1603, 1, 0, 0,
		0, 1606, 1609, 1, 0, 0, 0, 1607, 1605, 1, 0, 0, 0, 1607, 1608, 1, 0, 0,
		0, 1608, 1708, 1, 0, 0, 0, 1609, 1607, 1, 0, 0, 0, 1610, 1611, 5, 21, 0,
		0, 1611, 1612, 5, 450, 0, 0, 1612, 1613, 3, 324, 162, 0, 1613, 1614, 5,
		147, 0, 0, 1614, 1615, 5, 403, 0, 0, 1615, 1620, 3, 86, 43, 0, 1616, 1617,
		5, 4, 0, 0, 1617, 1619, 3, 86, 43, 0, 1618, 1616, 1, 0, 0, 0, 1619, 1622,
		1, 0, 0, 0, 1620, 1618, 1, 0, 0, 0, 1620, 1621, 1, 0, 0, 0, 1621, 1708,
		1, 0, 0, 0, 1622, 1620, 1, 0, 0, 0, 1623, 1624, 5, 21, 0, 0, 1624, 1625,
		5, 450, 0, 0, 1625, 1626, 3, 324, 162, 0, 1626, 1627, 5, 419, 0, 0, 1627,
		1628, 5, 2, 0, 0, 1628, 1629, 3, 314, 157, 0, 1629, 1630, 5, 3, 0, 0, 1630,
		1708, 1, 0, 0, 0, 1631, 1632, 5, 21, 0, 0, 1632, 1633, 5, 113, 0, 0, 1633,
		1634, 3, 440, 220, 0, 1634, 1635, 5, 419, 0, 0, 1635, 1636, 7, 12, 0, 0,
		1636, 1639, 5, 364, 0, 0, 1637, 1640, 3, 440, 220, 0, 1638, 1640, 5, 548,
		0, 0, 1639, 1637, 1, 0, 0, 0, 1639, 1638, 1, 0, 0, 0, 1640, 1708, 1, 0,
		0, 0, 1641, 1642, 5, 21, 0, 0, 1642, 1643, 5, 113, 0, 0, 1643, 1644, 3,
		440, 220, 0, 1644, 1645, 5, 419, 0, 0, 1645, 1646, 5, 358, 0, 0, 1646,
		1647, 5, 2, 0, 0, 1647, 1648, 3, 314, 157, 0, 1648, 1649, 5, 3, 0, 0, 1649,
		1708, 1, 0, 0, 0, 1650, 1651, 5, 21, 0, 0, 1651, 1652, 5, 449, 0, 0, 1652,
		1653, 5, 379, 0, 0, 1653, 1654, 5, 89, 0, 0, 1654, 1655, 5, 204, 0, 0,
		1655, 1656, 3, 440, 220, 0, 1656, 1657, 3, 440, 220, 0, 1657, 1708, 1,
		0, 0, 0, 1658, 1659, 5, 21, 0, 0, 1659, 1660, 5, 388, 0, 0, 1660, 1662,
		3, 180, 90, 0, 1661, 1663, 3, 312, 156, 0, 1662, 1661, 1, 0, 0, 0, 1662,
		1663, 1, 0, 0, 0, 1663, 1708, 1, 0, 0, 0, 1664, 1665, 5, 21, 0, 0, 1665,
		1666, 5, 387, 0, 0, 1666, 1668, 3, 440, 220, 0, 1667, 1669, 3, 312, 156,
		0, 1668, 1667, 1, 0, 0, 0, 1668, 1669, 1, 0, 0, 0, 1669, 1708, 1, 0, 0,
		0, 1670, 1671, 5, 21, 0, 0, 1671, 1672, 5, 404, 0, 0, 1672, 1673, 5, 270,
		0, 0, 1673, 1674, 5, 187, 0, 0, 1674, 1676, 3, 324, 162, 0, 1675, 1677,
		3, 312, 156, 0, 1676, 1675, 1, 0, 0, 0, 1676, 1677, 1, 0, 0, 0, 1677, 1684,
		1, 0, 0, 0, 1678, 1679, 5, 192, 0, 0, 1679, 1680, 3, 440, 220, 0, 1680,
		1681, 5, 2, 0, 0, 1681, 1682, 3, 314, 157, 0, 1682, 1683, 5, 3, 0, 0, 1683,
		1685, 1, 0, 0, 0, 1684, 1678, 1, 0, 0, 0, 1684, 1685, 1, 0, 0, 0, 1685,
		1708, 1, 0, 0, 0, 1686, 1687, 5, 21, 0, 0, 1687, 1688, 5, 80, 0, 0, 1688,
		1689, 5, 204, 0, 0, 1689, 1690, 3, 324, 162, 0, 1690, 1691, 5, 419, 0,
		0, 1691, 1692, 5, 2, 0, 0, 1692, 1693, 3, 314, 157, 0, 1693, 1694, 5, 3,
		0, 0, 1694, 1708, 1, 0, 0, 0, 1695, 1696, 5, 21, 0, 0, 1696, 1699, 5, 490,
		0, 0, 1697, 1698, 5, 221, 0, 0, 1698, 1700, 5, 169, 0, 0, 1699, 1697, 1,
		0, 0, 0, 1699, 1700, 1, 0, 0, 0, 1700, 1701, 1, 0, 0, 0, 1701, 1702, 3,
		190, 95, 0, 1702, 1705, 3, 130, 65, 0, 1703, 1704, 5, 83, 0, 0, 1704, 1706,
		5, 543, 0, 0, 1705, 1703, 1, 0, 0, 0, 1705, 1706, 1, 0, 0, 0, 1706, 1708,
		1, 0, 0, 0, 1707, 1495, 1, 0, 0, 0, 1707, 1498, 1, 0, 0, 0, 1707, 1517,
		1, 0, 0, 0, 1707, 1523, 1, 0, 0, 0, 1707, 1528, 1, 0, 0, 0, 1707, 1534,
		1, 0, 0, 0, 1707, 1545, 1, 0, 0, 0, 1707, 1554, 1, 0, 0, 0, 1707, 1561,
		1, 0, 0, 0, 1707, 1567, 1, 0, 0, 0, 1707, 1574, 1, 0, 0, 0, 1707, 1580,
		1, 0, 0, 0, 1707, 1586, 1, 0, 0, 0, 1707, 1597, 1, 0, 0, 0, 1707, 1610,
		1, 0, 0, 0, 1707, 1623, 1, 0, 0, 0, 1707, 1631, 1, 0, 0, 0, 1707, 1641,
		1, 0, 0, 0, 1707, 1650, 1, 0, 0, 0, 1707, 1658, 1, 0, 0, 0, 1707, 1664,
		1, 0, 0, 0, 1707, 1670, 1, 0, 0, 0, 1707, 1686, 1, 0, 0, 0, 1707, 1695,
		1, 0, 0, 0, 1708, 25, 1, 0, 0, 0, 1709, 1710, 5, 147, 0, 0, 1710, 1711,
		5, 68, 0, 0, 1711, 1712, 5, 374, 0, 0, 1712, 1713, 5, 43, 0, 0, 1713, 1714,
		5, 509, 0, 0, 1714, 1715, 5, 543, 0, 0, 1715, 1716, 5, 517, 0, 0, 1716,
		1911, 5, 548, 0, 0, 1717, 1718, 5, 147, 0, 0, 1718, 1721, 5, 156, 0, 0,
		1719, 1720, 5, 221, 0, 0, 1720, 1722, 5, 169, 0, 0, 1721, 1719, 1, 0, 0,
		0, 1721, 1722, 1, 0, 0, 0, 1722, 1723, 1, 0, 0, 0, 1723, 1911, 3, 324,
		162, 0, 1724, 1725, 5, 147, 0, 0, 1725, 1728, 5, 400, 0, 0, 1726, 1727,
		5, 221, 0, 0, 1727, 1729, 5, 169, 0, 0, 1728, 1726, 1, 0, 0, 0, 1728, 1729,
		1, 0, 0, 0, 1729, 1730, 1, 0, 0, 0, 1730, 1911, 3, 180, 90, 0, 1731, 1732,
		5, 147, 0, 0, 1732, 1735, 5, 432, 0, 0, 1733, 1734, 5, 221, 0, 0, 1734,
		1736, 5, 169, 0, 0, 1735, 1733, 1, 0, 0, 0, 1735, 1736, 1, 0, 0, 0, 1736,
		1737, 1, 0, 0, 0, 1737, 1911, 3, 304, 152, 0, 1738, 1739, 5, 147, 0, 0,
		1739, 1742, 5, 490, 0, 0, 1740, 1741, 5, 221, 0, 0, 1741, 1743, 5, 169,
		0, 0, 1742, 1740, 1, 0, 0, 0, 1742, 1743, 1, 0, 0, 0, 1743, 1744, 1, 0,
		0, 0, 1744, 1911, 3, 188, 94, 0, 1745, 1746, 5, 147, 0, 0, 1746, 1747,
		5, 440, 0, 0, 1747, 1750, 5, 350, 0, 0, 1748, 1749, 5, 221, 0, 0, 1749,
		1751, 5, 169, 0, 0, 1750, 1748, 1, 0, 0, 0, 1750, 1751, 1, 0, 0, 0, 1751,
		1752, 1, 0, 0, 0, 1752, 1911, 3, 440, 220, 0, 1753, 1754, 5, 147, 0, 0,
		1754, 1755, 5, 513, 0, 0, 1755, 1758, 5, 204, 0, 0, 1756, 1757, 5, 221,
		0, 0, 1757, 1759, 5, 169, 0, 0, 1758, 1756, 1, 0, 0, 0, 1758, 1759, 1,
		0, 0, 0, 1759, 1760, 1, 0, 0, 0, 1760, 1763, 3, 180, 90, 0, 1761, 1762,
		5, 187, 0, 0, 1762, 1764, 3, 180, 90, 0, 1763, 1761, 1, 0, 0, 0, 1763,
		1764, 1, 0, 0, 0, 1764, 1911, 1, 0, 0, 0, 1765, 1766, 5, 147, 0, 0, 1766,
		1769, 5, 68, 0, 0, 1767, 1768, 5, 221, 0, 0, 1768, 1770, 5, 169, 0, 0,
		1769, 1767, 1, 0, 0, 0, 1769, 1770, 1, 0, 0, 0, 1770, 1771, 1, 0, 0, 0,
		1771, 1911, 3, 440, 220, 0, 1772, 1773, 5, 147, 0, 0, 1773, 1774, 5, 181,
		0, 0, 1774, 1777, 5, 543, 0, 0, 1775, 1776, 7, 6, 0, 0, 1776, 1778, 3,
		440, 220, 0, 1777, 1775, 1, 0, 0, 0, 1777, 1778, 1, 0, 0, 0, 1778, 1779,
		1, 0, 0, 0, 1779, 1911, 3, 312, 156, 0, 1780, 1781, 5, 147, 0, 0, 1781,
		1782, 5, 513, 0, 0, 1782, 1785, 5, 350, 0, 0, 1783, 1784, 5, 221, 0, 0,
		1784, 1786, 5, 169, 0, 0, 1785, 1783, 1, 0, 0, 0, 1785, 1786, 1, 0, 0,
		0, 1786, 1787, 1, 0, 0, 0, 1787, 1911, 3, 180, 90, 0, 1788, 1789, 5, 147,
		0, 0, 1789, 1790, 5, 387, 0, 0, 1790, 1911, 3, 440, 220, 0, 1791, 1792,
		5, 147, 0, 0, 1792, 1795, 5, 450, 0, 0, 1793, 1794, 5, 221, 0, 0, 1794,
		1796, 5, 169, 0, 0, 1795, 1793, 1, 0, 0, 0, 1795, 1796, 1, 0, 0, 0, 1796,
		1797, 1, 0, 0, 0, 1797, 1799, 3, 324, 162, 0, 1798, 1800, 5, 189, 0, 0,
		1799, 1798, 1, 0, 0, 0, 1799, 1800, 1, 0, 0, 0, 1800, 1911, 1, 0, 0, 0,
		1801, 1802, 5, 147, 0, 0, 1802, 1805, 7, 10, 0, 0, 1803, 1804, 5, 221,
		0, 0, 1804, 1806, 5, 169, 0, 0, 1805, 1803, 1, 0, 0, 0, 1805, 1806, 1,
		0, 0, 0, 1806, 1807, 1, 0, 0, 0, 1807, 1809, 3, 324, 162, 0, 1808, 1810,
		5, 189, 0, 0, 1809, 1808, 1, 0, 0, 0, 1809, 1810, 1, 0, 0, 0, 1810, 1911,
		1, 0, 0, 0, 1811, 1813, 5, 147, 0, 0, 1812, 1814, 3, 168, 84, 0, 1813,
		1812, 1, 0, 0, 0, 1813, 1814, 1, 0, 0, 0, 1814, 1815, 1, 0, 0, 0, 1815,
		1818, 5, 196, 0, 0, 1816, 1817, 5, 221, 0, 0, 1817, 1819, 5, 169, 0, 0,
		1818, 1816, 1, 0, 0, 0, 1818, 1819, 1, 0, 0, 0, 1819, 1820, 1, 0, 0, 0,
		1820, 1821, 3, 390, 195, 0, 1821, 1823, 5, 2, 0, 0, 1822, 1824, 3, 132,
		66, 0, 1823, 1822, 1, 0, 0, 0, 1823, 1824, 1, 0, 0, 0, 1824, 1825, 1, 0,
		0, 0, 1825, 1826, 5, 3, 0, 0, 1826, 1911, 1, 0, 0, 0, 1827, 1828, 5, 147,
		0, 0, 1828, 1831, 5, 226, 0, 0, 1829, 1830, 5, 221, 0, 0, 1830, 1832, 5,
		169, 0, 0, 1831, 1829, 1, 0, 0, 0, 1831, 1832, 1, 0, 0, 0, 1832, 1833,
		1, 0, 0, 0, 1833, 1834, 3, 440, 220, 0, 1834, 1835, 5, 317, 0, 0, 1835,
		1836, 3, 324, 162, 0, 1836, 1911, 1, 0, 0, 0, 1837, 1838, 5, 147, 0, 0,
		1838, 1841, 5, 388, 0, 0, 1839, 1840, 5, 221, 0, 0, 1840, 1842, 5, 169,
		0, 0, 1841, 1839, 1, 0, 0, 0, 1841, 1842, 1, 0, 0, 0, 1842, 1843, 1, 0,
		0, 0, 1843, 1911, 3, 180, 90, 0, 1844, 1845, 5, 147, 0, 0, 1845, 1846,
		5, 405, 0, 0, 1846, 1849, 5, 350, 0, 0, 1847, 1848, 5, 221, 0, 0, 1848,
		1850, 5, 169, 0, 0, 1849, 1847, 1, 0, 0, 0, 1849, 1850, 1, 0, 0, 0, 1850,
		1851, 1, 0, 0, 0, 1851, 1852, 3, 440, 220, 0, 1852, 1853, 5, 317, 0, 0,
		1853, 1860, 3, 324, 162, 0, 1854, 1858, 5, 187, 0, 0, 1855, 1859, 3, 188,
		94, 0, 1856, 1857, 5, 400, 0, 0, 1857, 1859, 3, 440, 220, 0, 1858, 1855,
		1, 0, 0, 0, 1858, 1856, 1, 0, 0, 0, 1859, 1861, 1, 0, 0, 0, 1860, 1854,
		1, 0, 0, 0, 1860, 1861, 1, 0, 0, 0, 1861, 1911, 1, 0, 0, 0, 1862, 1863,
		5, 147, 0, 0, 1863, 1866, 5, 136, 0, 0, 1864, 1865, 5, 221, 0, 0, 1865,
		1867, 5, 169, 0, 0, 1866, 1864, 1, 0, 0, 0, 1866, 1867, 1, 0, 0, 0, 1867,
		1868, 1, 0, 0, 0, 1868, 1911, 3, 324, 162, 0, 1869, 1870, 5, 147, 0, 0,
		1870, 1873, 5, 433, 0, 0, 1871, 1872, 5, 221, 0, 0, 1872, 1874, 5, 169,
		0, 0, 1873, 1871, 1, 0, 0, 0, 1873, 1874, 1, 0, 0, 0, 1874, 1875, 1, 0,
		0, 0, 1875, 1911, 3, 440, 220, 0, 1876, 1877, 5, 147, 0, 0, 1877, 1880,
		5, 503, 0, 0, 1878, 1879, 5, 221, 0, 0, 1879, 1881, 5, 169, 0, 0, 1880,
		1878, 1, 0, 0, 0, 1880, 1881, 1, 0, 0, 0, 1881, 1882, 1, 0, 0, 0, 1882,
		1911, 3, 324, 162, 0, 1883, 1884, 5, 147, 0, 0, 1884, 1885, 5, 238, 0,
		0, 1885, 1886, 5, 226, 0, 0, 1886, 1889, 5, 24, 0, 0, 1887, 1888, 5, 221,
		0, 0, 1888, 1890, 5, 169, 0, 0, 1889, 1887, 1, 0, 0, 0, 1889, 1890, 1,
		0, 0, 0, 1890, 1891, 1, 0, 0, 0, 1891, 1911, 3, 440, 220, 0, 1892, 1893,
		5, 147, 0, 0, 1893, 1894, 5, 238, 0, 0, 1894, 1895, 5, 226, 0, 0, 1895,
		1898, 5, 467, 0, 0, 1896, 1897, 5, 221, 0, 0, 1897, 1899, 5, 169, 0, 0,
		1898, 1896, 1, 0, 0, 0, 1898, 1899, 1, 0, 0, 0, 1899, 1900, 1, 0, 0, 0,
		1900, 1911, 3, 440, 220, 0, 1901, 1902, 5, 147, 0, 0, 1902, 1903, 5, 238,
		0, 0, 1903, 1904, 5, 226, 0, 0, 1904, 1907, 5, 468, 0, 0, 1905, 1906, 5,
		221, 0, 0, 1906, 1908, 5, 169, 0, 0, 1907, 1905, 1, 0, 0, 0, 1907, 1908,
		1, 0, 0, 0, 1908, 1909, 1, 0, 0, 0, 1909, 1911, 3, 440, 220, 0, 1910, 1709,
		1, 0, 0, 0, 1910, 1717, 1, 0, 0, 0, 1910, 1724, 1, 0, 0, 0, 1910, 1731,
		1, 0, 0, 0, 1910, 1738, 1, 0, 0, 0, 1910, 1745, 1, 0, 0, 0, 1910, 1753,
		1, 0, 0, 0, 1910, 1765, 1, 0, 0, 0, 1910, 1772, 1, 0, 0, 0, 1910, 1780,
		1, 0, 0, 0, 1910, 1788, 1, 0, 0, 0, 1910, 1791, 1, 0, 0, 0, 1910, 1801,
		1, 0, 0, 0, 1910, 1811, 1, 0, 0, 0, 1910, 1827, 1, 0, 0, 0, 1910, 1837,
		1, 0, 0, 0, 1910, 1844, 1, 0, 0, 0, 1910, 1862, 1, 0, 0, 0, 1910, 1869,
		1, 0, 0, 0, 1910, 1876, 1, 0, 0, 0, 1910, 1883, 1, 0, 0, 0, 1910, 1892,
		1, 0, 0, 0, 1910, 1901, 1, 0, 0, 0, 1911, 27, 1, 0, 0, 0, 1912, 1914, 5,
		423, 0, 0, 1913, 1915, 3, 168, 84, 0, 1914, 1913, 1, 0, 0, 0, 1914, 1915,
		1, 0, 0, 0, 1915, 1916, 1, 0, 0, 0, 1916, 1918, 5, 497, 0, 0, 1917, 1919,
		3, 74, 37, 0, 1918, 1917, 1, 0, 0, 0, 1918, 1919, 1, 0, 0, 0, 1919, 2607,
		1, 0, 0, 0, 1920, 1921, 5, 423, 0, 0, 1921, 2607, 5, 32, 0, 0, 1922, 1923,
		5, 423, 0, 0, 1923, 1924, 5, 21, 0, 0, 1924, 1929, 5, 450, 0, 0, 1925,
		1930, 5, 403, 0, 0, 1926, 1927, 5, 287, 0, 0, 1927, 1930, 5, 503, 0, 0,
		1928, 1930, 5, 81, 0, 0, 1929, 1925, 1, 0, 0, 0, 1929, 1926, 1, 0, 0, 0,
		1929, 1928, 1, 0, 0, 0, 1930, 1933, 1, 0, 0, 0, 1931, 1932, 7, 6, 0, 0,
		1932, 1934, 3, 324, 162, 0, 1933, 1931, 1, 0, 0, 0, 1933, 1934, 1, 0, 0,
		0, 1934, 1936, 1, 0, 0, 0, 1935, 1937, 3, 74, 37, 0, 1936, 1935, 1, 0,
		0, 0, 1936, 1937, 1, 0, 0, 0, 1937, 1939, 1, 0, 0, 0, 1938, 1940, 3, 290,
		145, 0, 1939, 1938, 1, 0, 0, 0, 1939, 1940, 1, 0, 0, 0, 1940, 1942, 1,
		0, 0, 0, 1941, 1943, 3, 294, 147, 0, 1942, 1941, 1, 0, 0, 0, 1942, 1943,
		1, 0, 0, 0, 1943, 2607, 1, 0, 0, 0, 1944, 1945, 5, 423, 0, 0, 1945, 1946,
		5, 101, 0, 0, 1946, 1947, 7, 10, 0, 0, 1947, 2607, 3, 324, 162, 0, 1948,
		1949, 5, 423, 0, 0, 1949, 1952, 5, 38, 0, 0, 1950, 1951, 7, 6, 0, 0, 1951,
		1953, 3, 440, 220, 0, 1952, 1950, 1, 0, 0, 0, 1952, 1953, 1, 0, 0, 0, 1953,
		1955, 1, 0, 0, 0, 1954, 1956, 3, 74, 37, 0, 1955, 1954, 1, 0, 0, 0, 1955,
		1956, 1, 0, 0, 0, 1956, 2607, 1, 0, 0, 0, 1957, 1958, 5, 423, 0, 0, 1958,
		2607, 5, 56, 0, 0, 1959, 1960, 5, 423, 0, 0, 1960, 1961, 5, 58, 0, 0, 1961,
		1964, 5, 226, 0, 0, 1962, 1963, 7, 6, 0, 0, 1963, 1965, 3, 440, 220, 0,
		1964, 1962, 1, 0, 0, 0, 1964, 1965, 1, 0, 0, 0, 1965, 1967, 1, 0, 0, 0,
		1966, 1968, 3, 74, 37, 0, 1967, 1966, 1, 0, 0, 0, 1967, 1968, 1, 0, 0,
		0, 1968, 1970, 1, 0, 0, 0, 1969, 1971, 3, 290, 145, 0, 1970, 1969, 1, 0,
		0, 0, 1970, 1971, 1, 0, 0, 0, 1971, 1973, 1, 0, 0, 0, 1972, 1974, 3, 294,
		147, 0, 1973, 1972, 1, 0, 0, 0, 1973, 1974, 1, 0, 0, 0, 1974, 2607, 1,
		0, 0, 0, 1975, 1976, 5, 423, 0, 0, 1976, 1977, 5, 152, 0, 0, 1977, 1978,
		5, 329, 0, 0, 1978, 1981, 5, 451, 0, 0, 1979, 1980, 7, 6, 0, 0, 1980, 1982,
		3, 324, 162, 0, 1981, 1979, 1, 0, 0, 0, 1981, 1982, 1, 0, 0, 0, 1982, 2607,
		1, 0, 0, 0, 1983, 1984, 5, 423, 0, 0, 1984, 1987, 5, 164, 0, 0, 1985, 1986,
		7, 6, 0, 0, 1986, 1988, 3, 324, 162, 0, 1987, 1985, 1, 0, 0, 0, 1987, 1988,
		1, 0, 0, 0, 1988, 1990, 1, 0, 0, 0, 1989, 1991, 3, 74, 37, 0, 1990, 1989,
		1, 0, 0, 0, 1990, 1991, 1, 0, 0, 0, 1991, 2607, 1, 0, 0, 0, 1992, 1993,
		5, 423, 0, 0, 1993, 1996, 5, 172, 0, 0, 1994, 1995, 7, 6, 0, 0, 1995, 1997,
		3, 324, 162, 0, 1996, 1994, 1, 0, 0, 0, 1996, 1997, 1, 0, 0, 0, 1997, 1999,
		1, 0, 0, 0, 1998, 2000, 3, 74, 37, 0, 1999, 1998, 1, 0, 0, 0, 1999, 2000,
		1, 0, 0, 0, 2000, 2002, 1, 0, 0, 0, 2001, 2003, 3, 290, 145, 0, 2002, 2001,
		1, 0, 0, 0, 2002, 2003, 1, 0, 0, 0, 2003, 2005, 1, 0, 0, 0, 2004, 2006,
		3, 294, 147, 0, 2005, 2004, 1, 0, 0, 0, 2005, 2006, 1, 0, 0, 0, 2006, 2607,
		1, 0, 0, 0, 2007, 2008, 5, 423, 0, 0, 2008, 2009, 5, 258, 0, 0, 2009, 2607,
		5, 230, 0, 0, 2010, 2014, 5, 423, 0, 0, 2011, 2012, 5, 71, 0, 0, 2012,
		2015, 5, 419, 0, 0, 2013, 2015, 5, 72, 0, 0, 2014, 2011, 1, 0, 0, 0, 2014,
		2013, 1, 0, 0, 0, 2015, 2607, 1, 0, 0, 0, 2016, 2017, 5, 423, 0, 0, 2017,
		2020, 5, 129, 0, 0, 2018, 2019, 7, 6, 0, 0, 2019, 2021, 3, 324, 162, 0,
		2020, 2018, 1, 0, 0, 0, 2020, 2021, 1, 0, 0, 0, 2021, 2607, 1, 0, 0, 0,
		2022, 2023, 5, 423, 0, 0, 2023, 2025, 5, 101, 0, 0, 2024, 2026, 3, 168,
		84, 0, 2025, 2024, 1, 0, 0, 0, 2025, 2026, 1, 0, 0, 0, 2026, 2027, 1, 0,
		0, 0, 2027, 2028, 5, 196, 0, 0, 2028, 2029, 3, 390, 195, 0, 2029, 2031,
		5, 2, 0, 0, 2030, 2032, 3, 132, 66, 0, 2031, 2030, 1, 0, 0, 0, 2031, 2032,
		1, 0, 0, 0, 2032, 2033, 1, 0, 0, 0, 2033, 2036, 5, 3, 0, 0, 2034, 2035,
		7, 6, 0, 0, 2035, 2037, 3, 324, 162, 0, 2036, 2034, 1, 0, 0, 0, 2036, 2037,
		1, 0, 0, 0, 2037, 2607, 1, 0, 0, 0, 2038, 2040, 5, 423, 0, 0, 2039, 2041,
		5, 195, 0, 0, 2040, 2039, 1, 0, 0, 0, 2040, 2041, 1, 0, 0, 0, 2041, 2043,
		1, 0, 0, 0, 2042, 2044, 5, 59, 0, 0, 2043, 2042, 1, 0, 0, 0, 2043, 2044,
		1, 0, 0, 0, 2044, 2045, 1, 0, 0, 0, 2045, 2048, 5, 197, 0, 0, 2046, 2047,
		7, 6, 0, 0, 2047, 2049, 3, 324, 162, 0, 2048, 2046, 1, 0, 0, 0, 2048, 2049,
		1, 0, 0, 0, 2049, 2052, 1, 0, 0, 0, 2050, 2051, 5, 265, 0, 0, 2051, 2053,
		5, 543, 0, 0, 2052, 2050, 1, 0, 0, 0, 2052, 2053, 1, 0, 0, 0, 2053, 2607,
		1, 0, 0, 0, 2054, 2055, 5, 423, 0, 0, 2055, 2057, 5, 200, 0, 0, 2056, 2058,
		5, 195, 0, 0, 2057, 2056, 1, 0, 0, 0, 2057, 2058, 1, 0, 0, 0, 2058, 2059,
		1, 0, 0, 0, 2059, 2062, 5, 197, 0, 0, 2060, 2061, 5, 265, 0, 0, 2061, 2063,
		5, 543, 0, 0, 2062, 2060, 1, 0, 0, 0, 2062, 2063, 1, 0, 0, 0, 2063, 2607,
		1, 0, 0, 0, 2064, 2066, 5, 423, 0, 0, 2065, 2067, 5, 20, 0, 0, 2066, 2065,
		1, 0, 0, 0, 2066, 2067, 1, 0, 0, 0, 2067, 2068, 1, 0, 0, 0, 2068, 2607,
		5, 202, 0, 0, 2069, 2070, 5, 423, 0, 0, 2070, 2071, 5, 202, 0, 0, 2071,
		2072, 5, 187, 0, 0, 2072, 2607, 3, 188, 94, 0, 2073, 2074, 5, 423, 0, 0,
		2074, 2075, 5, 427, 0, 0, 2075, 2076, 5, 317, 0, 0, 2076, 2078, 3, 440,
		220, 0, 2077, 2079, 3, 74, 37, 0, 2078, 2077, 1, 0, 0, 0, 2078, 2079, 1,
		0, 0, 0, 2079, 2607, 1, 0, 0, 0, 2080, 2081, 5, 423, 0, 0, 2081, 2082,
		5, 270, 0, 0, 2082, 2084, 5, 357, 0, 0, 2083, 2085, 5, 543, 0, 0, 2084,
		2083, 1, 0, 0, 0, 2084, 2085, 1, 0, 0, 0, 2085, 2087, 1, 0, 0, 0, 2086,
		2088, 3, 294, 147, 0, 2087, 2086, 1, 0, 0, 0, 2087, 2088, 1, 0, 0, 0, 2088,
		2607, 1, 0, 0, 0, 2089, 2090, 5, 423, 0, 0, 2090, 2091, 5, 101, 0, 0, 2091,
		2092, 5, 387, 0, 0, 2092, 2093, 5, 187, 0, 0, 2093, 2607, 3, 440, 220,
		0, 2094, 2095, 5, 423, 0, 0, 2095, 2096, 5, 503, 0, 0, 2096, 2097, 7, 6,
		0, 0, 2097, 2100, 3, 324, 162, 0, 2098, 2099, 7, 6, 0, 0, 2099, 2101, 3,
		440, 220, 0, 2100, 2098, 1, 0, 0, 0, 2100, 2101, 1, 0, 0, 0, 2101, 2607,
		1, 0, 0, 0, 2102, 2103, 5, 423, 0, 0, 2103, 2607, 5, 349, 0, 0, 2104, 2105,
		5, 423, 0, 0, 2105, 2106, 5, 440, 0, 0, 2106, 2607, 7, 13, 0, 0, 2107,
		2108, 5, 423, 0, 0, 2108, 2607, 5, 386, 0, 0, 2109, 2110, 5, 423, 0, 0,
		2110, 2113, 5, 157, 0, 0, 2111, 2112, 7, 6, 0, 0, 2112, 2114, 3, 324, 162,
		0, 2113, 2111, 1, 0, 0, 0, 2113, 2114, 1, 0, 0, 0, 2114, 2117, 1, 0, 0,
		0, 2115, 2116, 5, 265, 0, 0, 2116, 2118, 5, 543, 0, 0, 2117, 2115, 1, 0,
		0, 0, 2117, 2118, 1, 0, 0, 0, 2118, 2607, 1, 0, 0, 0, 2119, 2121, 5, 423,
		0, 0, 2120, 2122, 5, 55, 0, 0, 2121, 2120, 1, 0, 0, 0, 2121, 2122, 1, 0,
		0, 0, 2122, 2123, 1, 0, 0, 0, 2123, 2124, 5, 101, 0, 0, 2124, 2125, 5,
		450, 0, 0, 2125, 2607, 3, 324, 162, 0, 2126, 2128, 5, 423, 0, 0, 2127,
		2129, 5, 195, 0, 0, 2128, 2127, 1, 0, 0, 0, 2128, 2129, 1, 0, 0, 0, 2129,
		2130, 1, 0, 0, 0, 2130, 2607, 5, 356, 0, 0, 2131, 2133, 5, 423, 0, 0, 2132,
		2134, 5, 458, 0, 0, 2133, 2132, 1, 0, 0, 0, 2133, 2134, 1, 0, 0, 0, 2134,
		2135, 1, 0, 0, 0, 2135, 2136, 5, 330, 0, 0, 2136, 2137, 5, 192, 0, 0, 2137,
		2139, 3, 324, 162, 0, 2138, 2140, 3, 74, 37, 0, 2139, 2138, 1, 0, 0, 0,
		2139, 2140, 1, 0, 0, 0, 2140, 2142, 1, 0, 0, 0, 2141, 2143, 3, 290, 145,
		0, 2142, 2141, 1, 0, 0, 0, 2142, 2143, 1, 0, 0, 0, 2143, 2145, 1, 0, 0,
		0, 2144, 2146, 3, 294, 147, 0, 2145, 2144, 1, 0, 0, 0, 2145, 2146, 1, 0,
		0, 0, 2146, 2607, 1, 0, 0, 0, 2147, 2149, 5, 423, 0, 0, 2148, 2150, 5,
		55, 0, 0, 2149, 2148, 1, 0, 0, 0, 2149, 2150, 1, 0, 0, 0, 2150, 2151, 1,
		0, 0, 0, 2151, 2154, 5, 390, 0, 0, 2152, 2153, 7, 6, 0, 0, 2153, 2155,
		3, 440, 220, 0, 2154, 2152, 1, 0, 0, 0, 2154, 2155, 1, 0, 0, 0, 2155, 2157,
		1, 0, 0, 0, 2156, 2158, 3, 74, 37, 0, 2157, 2156, 1, 0, 0, 0, 2157, 2158,
		1, 0, 0, 0, 2158, 2607, 1, 0, 0, 0, 2159, 2160, 5, 423, 0, 0, 2160, 2607,
		5, 401, 0, 0, 2161, 2162, 5, 423, 0, 0, 2162, 2163, 5, 329, 0, 0, 2163,
		2607, 5, 548, 0, 0, 2164, 2165, 5, 423, 0, 0, 2165, 2607, 5, 346, 0, 0,
		2166, 2167, 5, 423, 0, 0, 2167, 2168, 5, 354, 0, 0, 2168, 2607, 5, 543,
		0, 0, 2169, 2170, 5, 423, 0, 0, 2170, 2173, 5, 181, 0, 0, 2171, 2172, 7,
		6, 0, 0, 2172, 2174, 3, 324, 162, 0, 2173, 2171, 1, 0, 0, 0, 2173, 2174,
		1, 0, 0, 0, 2174, 2607, 1, 0, 0, 0, 2175, 2177, 5, 423, 0, 0, 2176, 2178,
		5, 440, 0, 0, 2177, 2176, 1, 0, 0, 0, 2177, 2178, 1, 0, 0, 0, 2178, 2179,
		1, 0, 0, 0, 2179, 2607, 5, 161, 0, 0, 2180, 2181, 5, 423, 0, 0, 2181, 2182,
		5, 101, 0, 0, 2182, 2183, 5, 68, 0, 0, 2183, 2607, 3, 440, 220, 0, 2184,
		2185, 5, 423, 0, 0, 2185, 2186, 5, 68, 0, 0, 2186, 2607, 3, 440, 220, 0,
		2187, 2188, 5, 423, 0, 0, 2188, 2190, 5, 69, 0, 0, 2189, 2191, 3, 74, 37,
		0, 2190, 2189, 1, 0, 0, 0, 2190, 2191, 1, 0, 0, 0, 2191, 2607, 1, 0, 0,
		0, 2192, 2193, 5, 423, 0, 0, 2193, 2196, 5, 359, 0, 0, 2194, 2195, 5, 187,
		0, 0, 2195, 2197, 3, 180, 90, 0, 2196, 2194, 1, 0, 0, 0, 2196, 2197, 1,
		0, 0, 0, 2197, 2200, 1, 0, 0, 0, 2198, 2199, 5, 265, 0, 0, 2199, 2201,
		5, 543, 0, 0, 2200, 2198, 1, 0, 0, 0, 2200, 2201, 1, 0, 0, 0, 2201, 2607,
		1, 0, 0, 0, 2202, 2203, 5, 423, 0, 0, 2203, 2204, 5, 20, 0, 0, 2204, 2207,
		5, 358, 0, 0, 2205, 2206, 5, 265, 0, 0, 2206, 2208, 5, 543, 0, 0, 2207,
		2205, 1, 0, 0, 0, 2207, 2208, 1, 0, 0, 0, 2208, 2607, 1, 0, 0, 0, 2209,
		2210, 5, 423, 0, 0, 2210, 2212, 5, 78, 0, 0, 2211, 2213, 3, 74, 37, 0,
		2212, 2211, 1, 0, 0, 0, 2212, 2213, 1, 0, 0, 0, 2213, 2607, 1, 0, 0, 0,
		2214, 2215, 5, 423, 0, 0, 2215, 2216, 5, 405, 0, 0, 2216, 2223, 5, 350,
		0, 0, 2217, 2221, 5, 187, 0, 0, 2218, 2222, 3, 188, 94, 0, 2219, 2220,
		5, 400, 0, 0, 2220, 2222, 3, 440, 220, 0, 2221, 2218, 1, 0, 0, 0, 2221,
		2219, 1, 0, 0, 0, 2222, 2224, 1, 0, 0, 0, 2223, 2217, 1, 0, 0, 0, 2223,
		2224, 1, 0, 0, 0, 2224, 2607, 1, 0, 0, 0, 2225, 2226, 5, 423, 0, 0, 2226,
		2227, 5, 440, 0, 0, 2227, 2233, 5, 350, 0, 0, 2228, 2231, 5, 492, 0, 0,
		2229, 2230, 5, 187, 0, 0, 2230, 2232, 3, 180, 90, 0, 2231, 2229, 1, 0,
		0, 0, 2231, 2232, 1, 0, 0, 0, 2232, 2234, 1, 0, 0, 0, 2233, 2228, 1, 0,
		0, 0, 2233, 2234, 1, 0, 0, 0, 2234, 2607, 1, 0, 0, 0, 2235, 2236, 5, 423,
		0, 0, 2236, 2239, 5, 432, 0, 0, 2237, 2238, 5, 187, 0, 0, 2238, 2240, 3,
		440, 220, 0, 2239, 2237, 1, 0, 0, 0, 2239, 2240, 1, 0, 0, 0, 2240, 2607,
		1, 0, 0, 0, 2241, 2242, 5, 423, 0, 0, 2242, 2243, 5, 101, 0, 0, 2243, 2244,
		5, 503, 0, 0, 2244, 2607, 3, 324, 162, 0, 2245, 2246, 5, 423, 0, 0, 2246,
		2247, 5, 112, 0, 0, 2247, 2607, 5, 478, 0, 0, 2248, 2249, 5, 423, 0, 0,
		2249, 2251, 5, 112, 0, 0, 2250, 2252, 5, 20, 0, 0, 2251, 2250, 1, 0, 0,
		0, 2251, 2252, 1, 0, 0, 0, 2252, 2255, 1, 0, 0, 0, 2253, 2254, 5, 192,
		0, 0, 2254, 2256, 3, 324, 162, 0, 2255, 2253, 1, 0, 0, 0, 2255, 2256, 1,
		0, 0, 0, 2256, 2258, 1, 0, 0, 0, 2257, 2259, 3, 290, 145, 0, 2258, 2257,
		1, 0, 0, 0, 2258, 2259, 1, 0, 0, 0, 2259, 2261, 1, 0, 0, 0, 2260, 2262,
		3, 312, 156, 0, 2261, 2260, 1, 0, 0, 0, 2261, 2262, 1, 0, 0, 0, 2262, 2607,
		1, 0, 0, 0, 2263, 2264, 5, 423, 0, 0, 2264, 2265, 5, 101, 0, 0, 2265, 2266,
		5, 287, 0, 0, 2266, 2267, 5, 503, 0, 0, 2267, 2268, 3, 440, 220, 0, 2268,
		2269, 5, 317, 0, 0, 2269, 2270, 3, 324, 162, 0, 2270, 2607, 1, 0, 0, 0,
		2271, 2272, 5, 423, 0, 0, 2272, 2274, 7, 14, 0, 0, 2273, 2275, 3, 294,
		147, 0, 2274, 2273, 1, 0, 0, 0, 2274, 2275, 1, 0, 0, 0, 2275, 2607, 1,
		0, 0, 0, 2276, 2277, 5, 423, 0, 0, 2277, 2278, 5, 100, 0, 0, 2278, 2279,
		5, 2, 0, 0, 2279, 2280, 5, 526, 0, 0, 2280, 2281, 5, 3, 0, 0, 2281, 2607,
		7, 14, 0, 0, 2282, 2283, 5, 423, 0, 0, 2283, 2607, 5, 37, 0, 0, 2284, 2285,
		5, 423, 0, 0, 2285, 2607, 5, 434, 0, 0, 2286, 2287, 5, 423, 0, 0, 2287,
		2288, 5, 385, 0, 0, 2288, 2289, 5, 142, 0, 0, 2289, 2290, 5, 192, 0, 0,
		2290, 2607, 3, 72, 36, 0, 2291, 2292, 5, 423, 0, 0, 2292, 2294, 5, 389,
		0, 0, 2293, 2295, 3, 74, 37, 0, 2294, 2293, 1, 0, 0, 0, 2294, 2295, 1,
		0, 0, 0, 2295, 2297, 1, 0, 0, 0, 2296, 2298, 3, 290, 145, 0, 2297, 2296,
		1, 0, 0, 0, 2297, 2298, 1, 0, 0, 0, 2298, 2300, 1, 0, 0, 0, 2299, 2301,
		3, 294, 147, 0, 2300, 2299, 1, 0, 0, 0, 2300, 2301, 1, 0, 0, 0, 2301, 2607,
		1, 0, 0, 0, 2302, 2304, 5, 423, 0, 0, 2303, 2305, 5, 441, 0, 0, 2304, 2303,
		1, 0, 0, 0, 2304, 2305, 1, 0, 0, 0, 2305, 2306, 1, 0, 0, 0, 2306, 2309,
		5, 270, 0, 0, 2307, 2308, 7, 6, 0, 0, 2308, 2310, 3, 440, 220, 0, 2309,
		2307, 1, 0, 0, 0, 2309, 2310, 1, 0, 0, 0, 2310, 2312, 1, 0, 0, 0, 2311,
		2313, 3, 74, 37, 0, 2312, 2311, 1, 0, 0, 0, 2312, 2313, 1, 0, 0, 0, 2313,
		2315, 1, 0, 0, 0, 2314, 2316, 3, 290, 145, 0, 2315, 2314, 1, 0, 0, 0, 2315,
		2316, 1, 0, 0, 0, 2316, 2318, 1, 0, 0, 0, 2317, 2319, 3, 294, 147, 0, 2318,
		2317, 1, 0, 0, 0, 2318, 2319, 1, 0, 0, 0, 2319, 2607, 1, 0, 0, 0, 2320,
		2321, 5, 423, 0, 0, 2321, 2322, 5, 270, 0, 0, 2322, 2335, 5, 506, 0, 0,
		2323, 2324, 7, 6, 0, 0, 2324, 2326, 3, 440, 220, 0, 2325, 2323, 1, 0, 0,
		0, 2325, 2326, 1, 0, 0, 0, 2326, 2328, 1, 0, 0, 0, 2327, 2329, 3, 74, 37,
		0, 2328, 2327, 1, 0, 0, 0, 2328, 2329, 1, 0, 0, 0, 2329, 2331, 1, 0, 0,
		0, 2330, 2332, 3, 294, 147, 0, 2331, 2330, 1, 0, 0, 0, 2331, 2332, 1, 0,
		0, 0, 2332, 2336, 1, 0, 0, 0, 2333, 2334, 5, 317, 0, 0, 2334, 2336, 5,
		543, 0, 0, 2335, 2325, 1, 0, 0, 0, 2335, 2333, 1, 0, 0, 0, 2336, 2607,
		1, 0, 0, 0, 2337, 2339, 5, 423, 0, 0, 2338, 2340, 5, 195, 0, 0, 2339, 2338,
		1, 0, 0, 0, 2339, 2340, 1, 0, 0, 0, 2340, 2341, 1, 0, 0, 0, 2341, 2344,
		5, 472, 0, 0, 2342, 2343, 7, 6, 0, 0, 2343, 2345, 3, 324, 162, 0, 2344,
		2342, 1, 0, 0, 0, 2344, 2345, 1, 0, 0, 0, 2345, 2347, 1, 0, 0, 0, 2346,
		2348, 3, 74, 37, 0, 2347, 2346, 1, 0, 0, 0, 2347, 2348, 1, 0, 0, 0, 2348,
		2607, 1, 0, 0, 0, 2349, 2350, 5, 423, 0, 0, 2350, 2351, 5, 453, 0, 0, 2351,
		2352, 5, 134, 0, 0, 2352, 2607, 5, 548, 0, 0, 2353, 2354, 5, 423, 0, 0,
		2354, 2355, 5, 319, 0, 0, 2355, 2358, 5, 451, 0, 0, 2356, 2357, 7, 6, 0,
		0, 2357, 2359, 3, 324, 162, 0, 2358, 2356, 1, 0, 0, 0, 2358, 2359, 1, 0,
		0, 0, 2359, 2361, 1, 0, 0, 0, 2360, 2362, 3, 74, 37, 0, 2361, 2360, 1,
		0, 0, 0, 2361, 2362, 1, 0, 0, 0, 2362, 2607, 1, 0, 0, 0, 2363, 2364, 5,
		423, 0, 0, 2364, 2366, 5, 194, 0, 0, 2365, 2367, 3, 440, 220, 0, 2366,
		2365, 1, 0, 0, 0, 2366, 2367, 1, 0, 0, 0, 2367, 2607, 1, 0, 0, 0, 2368,
		2369, 5, 423, 0, 0, 2369, 2370, 5, 113, 0, 0, 2370, 2607, 5, 548, 0, 0,
		2371, 2373, 5, 423, 0, 0, 2372, 2374, 5, 195, 0, 0, 2373, 2372, 1, 0, 0,
		0, 2373, 2374, 1, 0, 0, 0, 2374, 2375, 1, 0, 0, 0, 2375, 2376, 7, 15, 0,
		0, 2376, 2377, 7, 6, 0, 0, 2377, 2380, 3, 324, 162, 0, 2378, 2379, 7, 6,
		0, 0, 2379, 2381, 3, 324, 162, 0, 2380, 2378, 1, 0, 0, 0, 2380, 2381, 1,
		0, 0, 0, 2381, 2383, 1, 0, 0, 0, 2382, 2384, 3, 74, 37, 0, 2383, 2382,
		1, 0, 0, 0, 2383, 2384, 1, 0, 0, 0, 2384, 2607, 1, 0, 0, 0, 2385, 2386,
		5, 423, 0, 0, 2386, 2387, 5, 450, 0, 0, 2387, 2607, 5, 548, 0, 0, 2388,
		2389, 5, 423, 0, 0, 2389, 2392, 5, 470, 0, 0, 2390, 2391, 5, 317, 0, 0,
		2391, 2393, 5, 543, 0, 0, 2392, 2390, 1, 0, 0, 0, 2392, 2393, 1, 0, 0,
		0, 2393, 2607, 1, 0, 0, 0, 2394, 2395, 5, 423, 0, 0, 2395, 2398, 5, 477,
		0, 0, 2396, 2397, 7, 6, 0, 0, 2397, 2399, 3, 440, 220, 0, 2398, 2396, 1,
		0, 0, 0, 2398, 2399, 1, 0, 0, 0, 2399, 2607, 1, 0, 0, 0, 2400, 2404, 5,
		423, 0, 0, 2401, 2405, 5, 76, 0, 0, 2402, 2403, 5, 89, 0, 0, 2403, 2405,
		5, 206, 0, 0, 2404, 2401, 1, 0, 0, 0, 2404, 2402, 1, 0, 0, 0, 2405, 2607,
		1, 0, 0, 0, 2406, 2408, 5, 423, 0, 0, 2407, 2409, 3, 168, 84, 0, 2408,
		2407, 1, 0, 0, 0, 2408, 2409, 1, 0, 0, 0, 2409, 2410, 1, 0, 0, 0, 2410,
		2607, 5, 438, 0, 0, 2411, 2412, 5, 423, 0, 0, 2412, 2607, 5, 510, 0, 0,
		2413, 2414, 5, 423, 0, 0, 2414, 2415, 5, 454, 0, 0, 2415, 2416, 5, 40,
		0, 0, 2416, 2421, 5, 548, 0, 0, 2417, 2418, 5, 4, 0, 0, 2418, 2420, 5,
		548, 0, 0, 2419, 2417, 1, 0, 0, 0, 2420, 2423, 1, 0, 0, 0, 2421, 2419,
		1, 0, 0, 0, 2421, 2422, 1, 0, 0, 0, 2422, 2607, 1, 0, 0, 0, 2423, 2421,
		1, 0, 0, 0, 2424, 2425, 5, 423, 0, 0, 2425, 2426, 5, 112, 0, 0, 2426, 2427,
		5, 425, 0, 0, 2427, 2428, 5, 192, 0, 0, 2428, 2607, 3, 72, 36, 0, 2429,
		2430, 5, 423, 0, 0, 2430, 2431, 5, 450, 0, 0, 2431, 2434, 5, 102, 0, 0,
		2432, 2433, 7, 6, 0, 0, 2433, 2435, 3, 324, 162, 0, 2434, 2432, 1, 0, 0,
		0, 2434, 2435, 1, 0, 0, 0, 2435, 2438, 1, 0, 0, 0, 2436, 2437, 5, 265,
		0, 0, 2437, 2439, 5, 543, 0, 0, 2438, 2436, 1, 0, 0, 0, 2438, 2439, 1,
		0, 0, 0, 2439, 2607, 1, 0, 0, 0, 2440, 2441, 5, 423, 0, 0, 2441, 2442,
		5, 453, 0, 0, 2442, 2443, 5, 440, 0, 0, 2443, 2445, 5, 190, 0, 0, 2444,
		2446, 5, 501, 0, 0, 2445, 2444, 1, 0, 0, 0, 2445, 2446, 1, 0, 0, 0, 2446,
		2607, 1, 0, 0, 0, 2447, 2448, 5, 423, 0, 0, 2448, 2449, 5, 362, 0, 0, 2449,
		2451, 5, 357, 0, 0, 2450, 2452, 5, 543, 0, 0, 2451, 2450, 1, 0, 0, 0, 2451,
		2452, 1, 0, 0, 0, 2452, 2454, 1, 0, 0, 0, 2453, 2455, 3, 294, 147, 0, 2454,
		2453, 1, 0, 0, 0, 2454, 2455, 1, 0, 0, 0, 2455, 2607, 1, 0, 0, 0, 2456,
		2457, 5, 423, 0, 0, 2457, 2460, 5, 98, 0, 0, 2458, 2459, 7, 6, 0, 0, 2459,
		2461, 3, 324, 162, 0, 2460, 2458, 1, 0, 0, 0, 2460, 2461, 1, 0, 0, 0, 2461,
		2607, 1, 0, 0, 0, 2462, 2464, 5, 423, 0, 0, 2463, 2465, 5, 195, 0, 0, 2464,
		2463, 1, 0, 0, 0, 2464, 2465, 1, 0, 0, 0, 2465, 2466, 1, 0, 0, 0, 2466,
		2469, 5, 451, 0, 0, 2467, 2468, 7, 6, 0, 0, 2468, 2470, 3, 324, 162, 0,
		2469, 2467, 1, 0, 0, 0, 2469, 2470, 1, 0, 0, 0, 2470, 2472, 1, 0, 0, 0,
		2471, 2473, 3, 74, 37, 0, 2472, 2471, 1, 0, 0, 0, 2472, 2473, 1, 0, 0,
		0, 2473, 2607, 1, 0, 0, 0, 2474, 2476, 5, 423, 0, 0, 2475, 2477, 5, 195,
		0, 0, 2476, 2475, 1, 0, 0, 0, 2476, 2477, 1, 0, 0, 0, 2477, 2478, 1, 0,
		0, 0, 2478, 2481, 5, 504, 0, 0, 2479, 2480, 7, 6, 0, 0, 2480, 2482, 3,
		324, 162, 0, 2481, 2479, 1, 0, 0, 0, 2481, 2482, 1, 0, 0, 0, 2482, 2484,
		1, 0, 0, 0, 2483, 2485, 3, 74, 37, 0, 2484, 2483, 1, 0, 0, 0, 2484, 2485,
		1, 0, 0, 0, 2485, 2607, 1, 0, 0, 0, 2486, 2487, 5, 423, 0, 0, 2487, 2488,
		5, 450, 0, 0, 2488, 2491, 5, 438, 0, 0, 2489, 2490, 7, 6, 0, 0, 2490, 2492,
		3, 324, 162, 0, 2491, 2489, 1, 0, 0, 0, 2491, 2492, 1, 0, 0, 0, 2492, 2494,
		1, 0, 0, 0, 2493, 2495, 3, 74, 37, 0, 2494, 2493, 1, 0, 0, 0, 2494, 2495,
		1, 0, 0, 0, 2495, 2607, 1, 0, 0, 0, 2496, 2497, 5, 423, 0, 0, 2497, 2500,
		7, 16, 0, 0, 2498, 2499, 5, 192, 0, 0, 2499, 2501, 3, 440, 220, 0, 2500,
		2498, 1, 0, 0, 0, 2500, 2501, 1, 0, 0, 0, 2501, 2503, 1, 0, 0, 0, 2502,
		2504, 3, 74, 37, 0, 2503, 2502, 1, 0, 0, 0, 2503, 2504, 1, 0, 0, 0, 2504,
		2607, 1, 0, 0, 0, 2505, 2506, 5, 423, 0, 0, 2506, 2507, 5, 454, 0, 0, 2507,
		2508, 5, 192, 0, 0, 2508, 2510, 3, 324, 162, 0, 2509, 2511, 3, 158, 79,
		0, 2510, 2509, 1, 0, 0, 0, 2510, 2511, 1, 0, 0, 0, 2511, 2513, 1, 0, 0,
		0, 2512, 2514, 3, 74, 37, 0, 2513, 2512, 1, 0, 0, 0, 2513, 2514, 1, 0,
		0, 0, 2514, 2516, 1, 0, 0, 0, 2515, 2517, 3, 290, 145, 0, 2516, 2515, 1,
		0, 0, 0, 2516, 2517, 1, 0, 0, 0, 2517, 2519, 1, 0, 0, 0, 2518, 2520, 3,
		294, 147, 0, 2519, 2518, 1, 0, 0, 0, 2519, 2520, 1, 0, 0, 0, 2520, 2607,
		1, 0, 0, 0, 2521, 2522, 5, 423, 0, 0, 2522, 2523, 5, 68, 0, 0, 2523, 2524,
		5, 374, 0, 0, 2524, 2527, 5, 43, 0, 0, 2525, 2526, 5, 509, 0, 0, 2526,
		2528, 3, 368, 184, 0, 2527, 2525, 1, 0, 0, 0, 2527, 2528, 1, 0, 0, 0, 2528,
		2607, 1, 0, 0, 0, 2529, 2530, 5, 423, 0, 0, 2530, 2531, 5, 453, 0, 0, 2531,
		2607, 5, 548, 0, 0, 2532, 2533, 5, 423, 0, 0, 2533, 2535, 5, 135, 0, 0,
		2534, 2536, 3, 74, 37, 0, 2535, 2534, 1, 0, 0, 0, 2535, 2536, 1, 0, 0,
		0, 2536, 2607, 1, 0, 0, 0, 2537, 2538, 5, 423, 0, 0, 2538, 2541, 5, 469,
		0, 0, 2539, 2540, 7, 6, 0, 0, 2540, 2542, 3, 324, 162, 0, 2541, 2539, 1,
		0, 0, 0, 2541, 2542, 1, 0, 0, 0, 2542, 2544, 1, 0, 0, 0, 2543, 2545, 3,
		74, 37, 0, 2544, 2543, 1, 0, 0, 0, 2544, 2545, 1, 0, 0, 0, 2545, 2607,
		1, 0, 0, 0, 2546, 2547, 5, 423, 0, 0, 2547, 2548, 5, 385, 0, 0, 2548, 2549,
		5, 438, 0, 0, 2549, 2550, 5, 192, 0, 0, 2550, 2552, 3, 72, 36, 0, 2551,
		2553, 3, 246, 123, 0, 2552, 2551, 1, 0, 0, 0, 2552, 2553, 1, 0, 0, 0, 2553,
		2607, 1, 0, 0, 0, 2554, 2555, 5, 423, 0, 0, 2555, 2556, 5, 513, 0, 0, 2556,
		2559, 5, 206, 0, 0, 2557, 2558, 5, 265, 0, 0, 2558, 2560, 5, 543, 0, 0,
		2559, 2557, 1, 0, 0, 0, 2559, 2560, 1, 0, 0, 0, 2560, 2607, 1, 0, 0, 0,
		2561, 2562, 5, 423, 0, 0, 2562, 2565, 5, 99, 0, 0, 2563, 2564, 7, 6, 0,
		0, 2564, 2566, 3, 440, 220, 0, 2565, 2563, 1, 0, 0, 0, 2565, 2566, 1, 0,
		0, 0, 2566, 2568, 1, 0, 0, 0, 2567, 2569, 3, 246, 123, 0, 2568, 2567, 1,
		0, 0, 0, 2568, 2569, 1, 0, 0, 0, 2569, 2571, 1, 0, 0, 0, 2570, 2572, 3,
		290, 145, 0, 2571, 2570, 1, 0, 0, 0, 2571, 2572, 1, 0, 0, 0, 2572, 2574,
		1, 0, 0, 0, 2573, 2575, 3, 294, 147, 0, 2574, 2573, 1, 0, 0, 0, 2574, 2575,
		1, 0, 0, 0, 2575, 2607, 1, 0, 0, 0, 2576, 2577, 5, 423, 0, 0, 2577, 2578,
		5, 362, 0, 0, 2578, 2589, 5, 437, 0, 0, 2579, 2580, 5, 187, 0, 0, 2580,
		2590, 3, 440, 220, 0, 2581, 2582, 5, 192, 0, 0, 2582, 2587, 3, 324, 162,
		0, 2583, 2585, 5, 20, 0, 0, 2584, 2586, 5, 501, 0, 0, 2585, 2584, 1, 0,
		0, 0, 2585, 2586, 1, 0, 0, 0, 2586, 2588, 1, 0, 0, 0, 2587, 2583, 1, 0,
		0, 0, 2587, 2588, 1, 0, 0, 0, 2588, 2590, 1, 0, 0, 0, 2589, 2579, 1, 0,
		0, 0, 2589, 2581, 1, 0, 0, 0, 2589, 2590, 1, 0, 0, 0, 2590, 2607, 1, 0,
		0, 0, 2591, 2592, 5, 423, 0, 0, 2592, 2593, 7, 17, 0, 0, 2593, 2594, 7,
		6, 0, 0, 2594, 2597, 3, 324, 162, 0, 2595, 2596, 7, 6, 0, 0, 2596, 2598,
		3, 324, 162, 0, 2597, 2595, 1, 0, 0, 0, 2597, 2598, 1, 0, 0, 0, 2598, 2607,
		1, 0, 0, 0, 2599, 2600, 5, 423, 0, 0, 2600, 2601, 5, 505, 0, 0, 2601, 2602,
		5, 487, 0, 0, 2602, 2604, 5, 247, 0, 0, 2603, 2605, 3, 74, 37, 0, 2604,
		2603, 1, 0, 0, 0, 2604, 2605, 1, 0, 0, 0, 2605, 2607, 1, 0, 0, 0, 2606,
		1912, 1, 0, 0, 0, 2606, 1920, 1, 0, 0, 0, 2606, 1922, 1, 0, 0, 0, 2606,
		1944, 1, 0, 0, 0, 2606, 1948, 1, 0, 0, 0, 2606, 1957, 1, 0, 0, 0, 2606,
		1959, 1, 0, 0, 0, 2606, 1975, 1, 0, 0, 0, 2606, 1983, 1, 0, 0, 0, 2606,
		1992, 1, 0, 0, 0, 2606, 2007, 1, 0, 0, 0, 2606, 2010, 1, 0, 0, 0, 2606,
		2016, 1, 0, 0, 0, 2606, 2022, 1, 0, 0, 0, 2606, 2038, 1, 0, 0, 0, 2606,
		2054, 1, 0, 0, 0, 2606, 2064, 1, 0, 0, 0, 2606, 2069, 1, 0, 0, 0, 2606,
		2073, 1, 0, 0, 0, 2606, 2080, 1, 0, 0, 0, 2606, 2089, 1, 0, 0, 0, 2606,
		2094, 1, 0, 0, 0, 2606, 2102, 1, 0, 0, 0, 2606, 2104, 1, 0, 0, 0, 2606,
		2107, 1, 0, 0, 0, 2606, 2109, 1, 0, 0, 0, 2606, 2119, 1, 0, 0, 0, 2606,
		2126, 1, 0, 0, 0, 2606, 2131, 1, 0, 0, 0, 2606, 2147, 1, 0, 0, 0, 2606,
		2159, 1, 0, 0, 0, 2606, 2161, 1, 0, 0, 0, 2606, 2164, 1, 0, 0, 0, 2606,
		2166, 1, 0, 0, 0, 2606, 2169, 1, 0, 0, 0, 2606, 2175, 1, 0, 0, 0, 2606,
		2180, 1, 0, 0, 0, 2606, 2184, 1, 0, 0, 0, 2606, 2187, 1, 0, 0, 0, 2606,
		2192, 1, 0, 0, 0, 2606, 2202, 1, 0, 0, 0, 2606, 2209, 1, 0, 0, 0, 2606,
		2214, 1, 0, 0, 0, 2606, 2225, 1, 0, 0, 0, 2606, 2235, 1, 0, 0, 0, 2606,
		2241, 1, 0, 0, 0, 2606, 2245, 1, 0, 0, 0, 2606, 2248, 1, 0, 0, 0, 2606,
		2263, 1, 0, 0, 0, 2606, 2271, 1, 0, 0, 0, 2606, 2276, 1, 0, 0, 0, 2606,
		2282, 1, 0, 0, 0, 2606, 2284, 1, 0, 0, 0, 2606, 2286, 1, 0, 0, 0, 2606,
		2291, 1, 0, 0, 0, 2606, 2302, 1, 0, 0, 0, 2606, 2320, 1, 0, 0, 0, 2606,
		2337, 1, 0, 0, 0, 2606, 2349, 1, 0, 0, 0, 2606, 2353, 1, 0, 0, 0, 2606,
		2363, 1, 0, 0, 0, 2606, 2368, 1, 0, 0, 0, 2606, 2371, 1, 0, 0, 0, 2606,
		2385, 1, 0, 0, 0, 2606, 2388, 1, 0, 0, 0, 2606, 2394, 1, 0, 0, 0, 2606,
		2400, 1, 0, 0, 0, 2606, 2406, 1, 0, 0, 0, 2606, 2411, 1, 0, 0, 0, 2606,
		2413, 1, 0, 0, 0, 2606, 2424, 1, 0, 0, 0, 2606, 2429, 1, 0, 0, 0, 2606,
		2440, 1, 0, 0, 0, 2606, 2447, 1, 0, 0, 0, 2606, 2456, 1, 0, 0, 0, 2606,
		2462, 1, 0, 0, 0, 2606, 2474, 1, 0, 0, 0, 2606, 2486, 1, 0, 0, 0, 2606,
		2496, 1, 0, 0, 0, 2606, 2505, 1, 0, 0, 0, 2606, 2521, 1, 0, 0, 0, 2606,
		2529, 1, 0, 0, 0, 2606, 2532, 1, 0, 0, 0, 2606, 2537, 1, 0, 0, 0, 2606,
		2546, 1, 0, 0, 0, 2606, 2554, 1, 0, 0, 0, 2606, 2561, 1, 0, 0, 0, 2606,
		2576, 1, 0, 0, 0, 2606, 2591, 1, 0, 0, 0, 2606, 2599, 1, 0, 0, 0, 2607,
		29, 1, 0, 0, 0, 2608, 2680, 5, 448, 0, 0, 2609, 2680, 3, 42, 21, 0, 2610,
		2612, 5, 423, 0, 0, 2611, 2613, 5, 20, 0, 0, 2612, 2611, 1, 0, 0, 0, 2612,
		2613, 1, 0, 0, 0, 2613, 2614, 1, 0, 0, 0, 2614, 2615, 5, 101, 0, 0, 2615,
		2616, 5, 404, 0, 0, 2616, 2617, 5, 270, 0, 0, 2617, 2618, 5, 187, 0, 0,
		2618, 2680, 3, 324, 162, 0, 2619, 2620, 5, 337, 0, 0, 2620, 2621, 5, 404,
		0, 0, 2621, 2622, 5, 270, 0, 0, 2622, 2623, 5, 187, 0, 0, 2623, 2680, 3,
		324, 162, 0, 2624, 2625, 5, 337, 0, 0, 2625, 2626, 5, 20, 0, 0, 2626, 2627,
		5, 404, 0, 0, 2627, 2680, 5, 270, 0, 0, 2628, 2629, 5, 392, 0, 0, 2629,
		2630, 5, 404, 0, 0, 2630, 2631, 5, 270, 0, 0, 2631, 2632, 5, 187, 0, 0,
		2632, 2680, 3, 324, 162, 0, 2633, 2634, 5, 392, 0, 0, 2634, 2635, 5, 20,
		0, 0, 2635, 2636, 5, 404, 0, 0, 2636, 2680, 5, 270, 0, 0, 2637, 2638, 5,
		439, 0, 0, 2638, 2639, 5, 404, 0, 0, 2639, 2640, 5, 270, 0, 0, 2640, 2641,
		5, 187, 0, 0, 2641, 2680, 3, 324, 162, 0, 2642, 2644, 5, 423, 0, 0, 2643,
		2645, 5, 20, 0, 0, 2644, 2643, 1, 0, 0, 0, 2644, 2645, 1, 0, 0, 0, 2645,
		2646, 1, 0, 0, 0, 2646, 2647, 5, 404, 0, 0, 2647, 2654, 5, 270, 0, 0, 2648,
		2649, 5, 187, 0, 0, 2649, 2655, 3, 324, 162, 0, 2650, 2651, 5, 265, 0,
		0, 2651, 2653, 5, 543, 0, 0, 2652, 2650, 1, 0, 0, 0, 2652, 2653, 1, 0,
		0, 0, 2653, 2655, 1, 0, 0, 0, 2654, 2648, 1, 0, 0, 0, 2654, 2652, 1, 0,
		0, 0, 2655, 2680, 1, 0, 0, 0, 2656, 2657, 5, 423, 0, 0, 2657, 2658, 5,
		404, 0, 0, 2658, 2659, 5, 270, 0, 0, 2659, 2662, 5, 456, 0, 0, 2660, 2661,
		7, 6, 0, 0, 2661, 2663, 3, 440, 220, 0, 2662, 2660, 1, 0, 0, 0, 2662, 2663,
		1, 0, 0, 0, 2663, 2665, 1, 0, 0, 0, 2664, 2666, 3, 74, 37, 0, 2665, 2664,
		1, 0, 0, 0, 2665, 2666, 1, 0, 0, 0, 2666, 2680, 1, 0, 0, 0, 2667, 2668,
		5, 423, 0, 0, 2668, 2669, 5, 238, 0, 0, 2669, 2670, 5, 226, 0, 0, 2670,
		2680, 5, 24, 0, 0, 2671, 2672, 5, 423, 0, 0, 2672, 2673, 5, 238, 0, 0,
		2673, 2674, 5, 226, 0, 0, 2674, 2680, 5, 467, 0, 0, 2675, 2676, 5, 423,
		0, 0, 2676, 2677, 5, 238, 0, 0, 2677, 2678, 5, 226, 0, 0, 2678, 2680, 5,
		468, 0, 0, 2679, 2608, 1, 0, 0, 0, 2679, 2609, 1, 0, 0, 0, 2679, 2610,
		1, 0, 0, 0, 2679, 2619, 1, 0, 0, 0, 2679, 2624, 1, 0, 0, 0, 2679, 2628,
		1, 0, 0, 0, 2679, 2633, 1, 0, 0, 0, 2679, 2637, 1, 0, 0, 0, 2679, 2642,
		1, 0, 0, 0, 2679, 2656, 1, 0, 0, 0, 2679, 2667, 1, 0, 0, 0, 2679, 2671,
		1, 0, 0, 0, 2679, 2675, 1, 0, 0, 0, 2680, 31, 1, 0, 0, 0, 2681, 2683, 5,
		254, 0, 0, 2682, 2684, 5, 92, 0, 0, 2683, 2682, 1, 0, 0, 0, 2683, 2684,
		1, 0, 0, 0, 2684, 2685, 1, 0, 0, 0, 2685, 2690, 5, 548, 0, 0, 2686, 2687,
		5, 254, 0, 0, 2687, 2688, 5, 362, 0, 0, 2688, 2690, 7, 18, 0, 0, 2689,
		2681, 1, 0, 0, 0, 2689, 2686, 1, 0, 0, 0, 2690, 33, 1, 0, 0, 0, 2691, 2692,
		5, 211, 0, 0, 2692, 2768, 3, 180, 90, 0, 2693, 2694, 5, 484, 0, 0, 2694,
		2768, 5, 451, 0, 0, 2695, 2696, 5, 231, 0, 0, 2696, 2697, 5, 348, 0, 0,
		2697, 2698, 5, 192, 0, 0, 2698, 2700, 3, 180, 90, 0, 2699, 2701, 3, 312,
		156, 0, 2700, 2699, 1, 0, 0, 0, 2700, 2701, 1, 0, 0, 0, 2701, 2768, 1,
		0, 0, 0, 2702, 2703, 5, 481, 0, 0, 2703, 2704, 5, 348, 0, 0, 2704, 2768,
		3, 180, 90, 0, 2705, 2706, 5, 275, 0, 0, 2706, 2715, 5, 451, 0, 0, 2707,
		2712, 3, 40, 20, 0, 2708, 2709, 5, 4, 0, 0, 2709, 2711, 3, 40, 20, 0, 2710,
		2708, 1, 0, 0, 0, 2711, 2714, 1, 0, 0, 0, 2712, 2710, 1, 0, 0, 0, 2712,
		2713, 1, 0, 0, 0, 2713, 2716, 1, 0, 0, 0, 2714, 2712, 1, 0, 0, 0, 2715,
		2707, 1, 0, 0, 0, 2715, 2716, 1, 0, 0, 0, 2716, 2768, 1, 0, 0, 0, 2717,
		2718, 5, 505, 0, 0, 2718, 2722, 5, 487, 0, 0, 2719, 2723, 5, 75, 0, 0,
		2720, 2721, 5, 89, 0, 0, 2721, 2723, 5, 204, 0, 0, 2722, 2719, 1, 0, 0,
		0, 2722, 2720, 1, 0, 0, 0, 2723, 2724, 1, 0, 0, 0, 2724, 2725, 3, 440,
		220, 0, 2725, 2740, 5, 511, 0, 0, 2726, 2730, 5, 75, 0, 0, 2727, 2728,
		5, 89, 0, 0, 2728, 2730, 5, 204, 0, 0, 2729, 2726, 1, 0, 0, 0, 2729, 2727,
		1, 0, 0, 0, 2730, 2731, 1, 0, 0, 0, 2731, 2741, 3, 440, 220, 0, 2732, 2737,
		3, 38, 19, 0, 2733, 2734, 5, 25, 0, 0, 2734, 2736, 3, 38, 19, 0, 2735,
		2733, 1, 0, 0, 0, 2736, 2739, 1, 0, 0, 0, 2737, 2735, 1, 0, 0, 0, 2737,
		2738, 1, 0, 0, 0, 2738, 2741, 1, 0, 0, 0, 2739, 2737, 1, 0, 0, 0, 2740,
		2729, 1, 0, 0, 0, 2740, 2732, 1, 0, 0, 0, 2741, 2743, 1, 0, 0, 0, 2742,
		2744, 5, 189, 0, 0, 2743, 2742, 1, 0, 0, 0, 2743, 2744, 1, 0, 0, 0, 2744,
		2768, 1, 0, 0, 0, 2745, 2746, 5, 38, 0, 0, 2746, 2747, 5, 427, 0, 0, 2747,
		2748, 3, 324, 162, 0, 2748, 2749, 5, 466, 0, 0, 2749, 2762, 3, 440, 220,
		0, 2750, 2751, 7, 19, 0, 0, 2751, 2752, 5, 2, 0, 0, 2752, 2757, 3, 72,
		36, 0, 2753, 2754, 5, 4, 0, 0, 2754, 2756, 3, 72, 36, 0, 2755, 2753, 1,
		0, 0, 0, 2756, 2759, 1, 0, 0, 0, 2757, 2755, 1, 0, 0, 0, 2757, 2758, 1,
		0, 0, 0, 2758, 2760, 1, 0, 0, 0, 2759, 2757, 1, 0, 0, 0, 2760, 2761, 5,
		3, 0, 0, 2761, 2763, 1, 0, 0, 0, 2762, 2750, 1, 0, 0, 0, 2762, 2763, 1,
		0, 0, 0, 2763, 2765, 1, 0, 0, 0, 2764, 2766, 3, 312, 156, 0, 2765, 2764,
		1, 0, 0, 0, 2765, 2766, 1, 0, 0, 0, 2766, 2768, 1, 0, 0, 0, 2767, 2691,
		1, 0, 0, 0, 2767, 2693, 1, 0, 0, 0, 2767, 2695, 1, 0, 0, 0, 2767, 2702,
		1, 0, 0, 0, 2767, 2705, 1, 0, 0, 0, 2767, 2717, 1, 0, 0, 0, 2767, 2745,
		1, 0, 0, 0, 2768, 35, 1, 0, 0, 0, 2769, 2770, 5, 390, 0, 0, 2770, 2771,
		5, 427, 0, 0, 2771, 2772, 3, 324, 162, 0, 2772, 2773, 5, 192, 0, 0, 2773,
		2786, 3, 440, 220, 0, 2774, 2775, 7, 19, 0, 0, 2775, 2776, 5, 2, 0, 0,
		2776, 2781, 3, 72, 36, 0, 2777, 2778, 5, 4, 0, 0, 2778, 2780, 3, 72, 36,
		0, 2779, 2777, 1, 0, 0, 0, 2780, 2783, 1, 0, 0, 0, 2781, 2779, 1, 0, 0,
		0, 2781, 2782, 1, 0, 0, 0, 2782, 2784, 1, 0, 0, 0, 2783, 2781, 1, 0, 0,
		0, 2784, 2785, 5, 3, 0, 0, 2785, 2787, 1, 0, 0, 0, 2786, 2774, 1, 0, 0,
		0, 2786, 2787, 1, 0, 0, 0, 2787, 2789, 1, 0, 0, 0, 2788, 2790, 3, 312,
		156, 0, 2789, 2788, 1, 0, 0, 0, 2789, 2790, 1, 0, 0, 0, 2790, 2799, 1,
		0, 0, 0, 2791, 2792, 5, 435, 0, 0, 2792, 2796, 5, 469, 0, 0, 2793, 2794,
		5, 511, 0, 0, 2794, 2795, 5, 94, 0, 0, 2795, 2797, 5, 427, 0, 0, 2796,
		2793, 1, 0, 0, 0, 2796, 2797, 1, 0, 0, 0, 2797, 2799, 1, 0, 0, 0, 2798,
		2769, 1, 0, 0, 0, 2798, 2791, 1, 0, 0, 0, 2799, 37, 1, 0, 0, 0, 2800, 2801,
		5, 450, 0, 0, 2801, 2804, 3, 324, 162, 0, 2802, 2803, 5, 329, 0, 0, 2803,
		2805, 3, 440, 220, 0, 2804, 2802, 1, 0, 0, 0, 2804, 2805, 1, 0, 0, 0, 2805,
		39, 1, 0, 0, 0, 2806, 2809, 3, 324, 162, 0, 2807, 2808, 5, 29, 0, 0, 2808,
		2810, 3, 180, 90, 0, 2809, 2807, 1, 0, 0, 0, 2809, 2810, 1, 0, 0, 0, 2810,
		2819, 1, 0, 0, 0, 2811, 2813, 5, 369, 0, 0, 2812, 2814, 5, 271, 0, 0, 2813,
		2812, 1, 0, 0, 0, 2813, 2814, 1, 0, 0, 0, 2814, 2820, 1, 0, 0, 0, 2815,
		2817, 5, 277, 0, 0, 2816, 2815, 1, 0, 0, 0, 2816, 2817, 1, 0, 0, 0, 2817,
		2818, 1, 0, 0, 0, 2818, 2820, 5, 514, 0, 0, 2819, 2811, 1, 0, 0, 0, 2819,
		2816, 1, 0, 0, 0, 2820, 41, 1, 0, 0, 0, 2821, 2822, 5, 101, 0, 0, 2822,
		2823, 5, 404, 0, 0, 2823, 2824, 5, 270, 0, 0, 2824, 2827, 3, 324, 162,
		0, 2825, 2826, 5, 317, 0, 0, 2826, 2828, 3, 440, 220, 0, 2827, 2825, 1,
		0, 0, 0, 2827, 2828, 1, 0, 0, 0, 2828, 2831, 1, 0, 0, 0, 2829, 2830, 5,
		511, 0, 0, 2830, 2832, 7, 20, 0, 0, 2831, 2829, 1, 0, 0, 0, 2831, 2832,
		1, 0, 0, 0, 2832, 2841, 1, 0, 0, 0, 2833, 2838, 3, 46, 23, 0, 2834, 2835,
		5, 4, 0, 0, 2835, 2837, 3, 46, 23, 0, 2836, 2834, 1, 0, 0, 0, 2837, 2840,
		1, 0, 0, 0, 2838, 2836, 1, 0, 0, 0, 2838, 2839, 1, 0, 0, 0, 2839, 2842,
		1, 0, 0, 0, 2840, 2838, 1, 0, 0, 0, 2841, 2833, 1, 0, 0, 0, 2841, 2842,
		1, 0, 0, 0, 2842, 2844, 1, 0, 0, 0, 2843, 2845, 3, 312, 156, 0, 2844, 2843,
		1, 0, 0, 0, 2844, 2845, 1, 0, 0, 0, 2845, 2846, 1, 0, 0, 0, 2846, 2847,
		5, 192, 0, 0, 2847, 2848, 3, 440, 220, 0, 2848, 2849, 5, 2, 0, 0, 2849,
		2850, 3, 314, 157, 0, 2850, 2852, 5, 3, 0, 0, 2851, 2853, 3, 428, 214,
		0, 2852, 2851, 1, 0, 0, 0, 2852, 2853, 1, 0, 0, 0, 2853, 43, 1, 0, 0, 0,
		2854, 2855, 5, 270, 0, 0, 2855, 2861, 3, 220, 110, 0, 2856, 2857, 5, 358,
		0, 0, 2857, 2858, 5, 2, 0, 0, 2858, 2859, 3, 314, 157, 0, 2859, 2860, 5,
		3, 0, 0, 2860, 2862, 1, 0, 0, 0, 2861, 2856, 1, 0, 0, 0, 2861, 2862, 1,
		0, 0, 0, 2862, 2864, 1, 0, 0, 0, 2863, 2865, 3, 428, 214, 0, 2864, 2863,
		1, 0, 0, 0, 2864, 2865, 1, 0, 0, 0, 2865, 2872, 1, 0, 0, 0, 2866, 2867,
		5, 423, 0, 0, 2867, 2868, 5, 101, 0, 0, 2868, 2869, 5, 270, 0, 0, 2869,
		2870, 5, 187, 0, 0, 2870, 2872, 3, 324, 162, 0, 2871, 2854, 1, 0, 0, 0,
		2871, 2866, 1, 0, 0, 0, 2872, 45, 1, 0, 0, 0, 2873, 2874, 5, 82, 0, 0,
		2874, 2875, 5, 459, 0, 0, 2875, 2876, 5, 61, 0, 0, 2876, 2884, 5, 543,
		0, 0, 2877, 2884, 3, 56, 28, 0, 2878, 2884, 3, 54, 27, 0, 2879, 2884, 3,
		52, 26, 0, 2880, 2884, 3, 50, 25, 0, 2881, 2884, 3, 48, 24, 0, 2882, 2884,
		3, 158, 79, 0, 2883, 2873, 1, 0, 0, 0, 2883, 2877, 1, 0, 0, 0, 2883, 2878,
		1, 0, 0, 0, 2883, 2879, 1, 0, 0, 0, 2883, 2880, 1, 0, 0, 0, 2883, 2881,
		1, 0, 0, 0, 2883, 2882, 1, 0, 0, 0, 2884, 47, 1, 0, 0, 0, 2885, 2886, 5,
		322, 0, 0, 2886, 2887, 5, 61, 0, 0, 2887, 2888, 3, 440, 220, 0, 2888, 49,
		1, 0, 0, 0, 2889, 2890, 5, 129, 0, 0, 2890, 2891, 5, 317, 0, 0, 2891, 2892,
		3, 372, 186, 0, 2892, 51, 1, 0, 0, 0, 2893, 2894, 5, 509, 0, 0, 2894, 2895,
		3, 372, 186, 0, 2895, 53, 1, 0, 0, 0, 2896, 2897, 5, 351, 0, 0, 2897, 2898,
		5, 182, 0, 0, 2898, 2899, 3, 372, 186, 0, 2899, 55, 1, 0, 0, 0, 2900, 2901,
		5, 82, 0, 0, 2901, 2902, 5, 2, 0, 0, 2902, 2907, 3, 58, 29, 0, 2903, 2904,
		5, 4, 0, 0, 2904, 2906, 3, 58, 29, 0, 2905, 2903, 1, 0, 0, 0, 2906, 2909,
		1, 0, 0, 0, 2907, 2905, 1, 0, 0, 0, 2907, 2908, 1, 0, 0, 0, 2908, 2910,
		1, 0, 0, 0, 2909, 2907, 1, 0, 0, 0, 2910, 2911, 5, 3, 0, 0, 2911, 57, 1,
		0, 0, 0, 2912, 2915, 3, 440, 220, 0, 2913, 2914, 5, 517, 0, 0, 2914, 2916,
		3, 372, 186, 0, 2915, 2913, 1, 0, 0, 0, 2915, 2916, 1, 0, 0, 0, 2916, 2926,
		1, 0, 0, 0, 2917, 2918, 5, 2, 0, 0, 2918, 2921, 3, 440, 220, 0, 2919, 2920,
		5, 517, 0, 0, 2920, 2922, 3, 372, 186, 0, 2921, 2919, 1, 0, 0, 0, 2921,
		2922, 1, 0, 0, 0, 2922, 2923, 1, 0, 0, 0, 2923, 2924, 5, 3, 0, 0, 2924,
		2926, 1, 0, 0, 0, 2925, 2912, 1, 0, 0, 0, 2925, 2917, 1, 0, 0, 0, 2926,
		59, 1, 0, 0, 0, 2927, 2928, 5, 375, 0, 0, 2928, 2929, 5, 68, 0, 0, 2929,
		2931, 3, 440, 220, 0, 2930, 2932, 3, 312, 156, 0, 2931, 2930, 1, 0, 0,
		0, 2931, 2932, 1, 0, 0, 0, 2932, 2953, 1, 0, 0, 0, 2933, 2934, 5, 375,
		0, 0, 2934, 2935, 5, 113, 0, 0, 2935, 2937, 3, 324, 162, 0, 2936, 2938,
		3, 312, 156, 0, 2937, 2936, 1, 0, 0, 0, 2937, 2938, 1, 0, 0, 0, 2938, 2953,
		1, 0, 0, 0, 2939, 2940, 5, 375, 0, 0, 2940, 2941, 5, 450, 0, 0, 2941, 2953,
		3, 324, 162, 0, 2942, 2943, 5, 375, 0, 0, 2943, 2944, 5, 136, 0, 0, 2944,
		2953, 3, 324, 162, 0, 2945, 2946, 5, 375, 0, 0, 2946, 2950, 5, 260, 0,
		0, 2947, 2951, 5, 20, 0, 0, 2948, 2949, 5, 187, 0, 0, 2949, 2951, 3, 180,
		90, 0, 2950, 2947, 1, 0, 0, 0, 2950, 2948, 1, 0, 0, 0, 2951, 2953, 1, 0,
		0, 0, 2952, 2927, 1, 0, 0, 0, 2952, 2933, 1, 0, 0, 0, 2952, 2939, 1, 0,
		0, 0, 2952, 2942, 1, 0, 0, 0, 2952, 2945, 1, 0, 0, 0, 2953, 61, 1, 0, 0,
		0, 2954, 2955, 5, 74, 0, 0, 2955, 2956, 5, 20, 0, 0, 2956, 2978, 5, 357,
		0, 0, 2957, 2958, 5, 74, 0, 0, 2958, 2960, 5, 255, 0, 0, 2959, 2961, 3,
		440, 220, 0, 2960, 2959, 1, 0, 0, 0, 2960, 2961, 1, 0, 0, 0, 2961, 2962,
		1, 0, 0, 0, 2962, 2963, 7, 6, 0, 0, 2963, 2978, 3, 440, 220, 0, 2964, 2965,
		5, 74, 0, 0, 2965, 2966, 5, 362, 0, 0, 2966, 2971, 5, 437, 0, 0, 2967,
		2968, 5, 187, 0, 0, 2968, 2972, 3, 440, 220, 0, 2969, 2970, 7, 6, 0, 0,
		2970, 2972, 3, 324, 162, 0, 2971, 2967, 1, 0, 0, 0, 2971, 2969, 1, 0, 0,
		0, 2972, 2978, 1, 0, 0, 0, 2973, 2974, 5, 74, 0, 0, 2974, 2975, 5, 20,
		0, 0, 2975, 2976, 5, 362, 0, 0, 2976, 2978, 5, 437, 0, 0, 2977, 2954, 1,
		0, 0, 0, 2977, 2957, 1, 0, 0, 0, 2977, 2964, 1, 0, 0, 0, 2977, 2973, 1,
		0, 0, 0, 2978, 63, 1, 0, 0, 0, 2979, 2980, 5, 65, 0, 0, 2980, 2983, 5,
		270, 0, 0, 2981, 2982, 7, 6, 0, 0, 2982, 2984, 3, 440, 220, 0, 2983, 2981,
		1, 0, 0, 0, 2983, 2984, 1, 0, 0, 0, 2984, 2986, 1, 0, 0, 0, 2985, 2987,
		3, 74, 37, 0, 2986, 2985, 1, 0, 0, 0, 2986, 2987, 1, 0, 0, 0, 2987, 3068,
		1, 0, 0, 0, 2988, 2989, 5, 65, 0, 0, 2989, 2992, 5, 172, 0, 0, 2990, 2991,
		7, 6, 0, 0, 2991, 2993, 3, 440, 220, 0, 2992, 2990, 1, 0, 0, 0, 2992, 2993,
		1, 0, 0, 0, 2993, 2995, 1, 0, 0, 0, 2994, 2996, 3, 74, 37, 0, 2995, 2994,
		1, 0, 0, 0, 2995, 2996, 1, 0, 0, 0, 2996, 3068, 1, 0, 0, 0, 2997, 2998,
		5, 65, 0, 0, 2998, 2999, 5, 505, 0, 0, 2999, 3000, 5, 487, 0, 0, 3000,
		3002, 5, 247, 0, 0, 3001, 3003, 3, 74, 37, 0, 3002, 3001, 1, 0, 0, 0, 3002,
		3003, 1, 0, 0, 0, 3003, 3068, 1, 0, 0, 0, 3004, 3005, 5, 65, 0, 0, 3005,
		3006, 5, 126, 0, 0, 3006, 3007, 5, 36, 0, 0, 3007, 3012, 5, 543, 0, 0,
		3008, 3009, 5, 4, 0, 0, 3009, 3011, 5, 543, 0, 0, 3010, 3008, 1, 0, 0,
		0, 3011, 3014, 1, 0, 0, 0, 3012, 3010, 1, 0, 0, 0, 3012, 3013, 1, 0, 0,
		0, 3013, 3068, 1, 0, 0, 0, 3014, 3012, 1, 0, 0, 0, 3015, 3016, 5, 65, 0,
		0, 3016, 3019, 5, 38, 0, 0, 3017, 3018, 7, 6, 0, 0, 3018, 3020, 3, 440,
		220, 0, 3019, 3017, 1, 0, 0, 0, 3019, 3020, 1, 0, 0, 0, 3020, 3068, 1,
		0, 0, 0, 3021, 3022, 5, 65, 0, 0, 3022, 3025, 5, 390, 0, 0, 3023, 3024,
		7, 6, 0, 0, 3024, 3026, 3, 440, 220, 0, 3025, 3023, 1, 0, 0, 0, 3025, 3026,
		1, 0, 0, 0, 3026, 3068, 1, 0, 0, 0, 3027, 3028, 5, 65, 0, 0, 3028, 3029,
		5, 58, 0, 0, 3029, 3030, 5, 226, 0, 0, 3030, 3031, 5, 317, 0, 0, 3031,
		3042, 3, 324, 162, 0, 3032, 3033, 5, 2, 0, 0, 3033, 3038, 5, 548, 0, 0,
		3034, 3035, 5, 4, 0, 0, 3035, 3037, 5, 548, 0, 0, 3036, 3034, 1, 0, 0,
		0, 3037, 3040, 1, 0, 0, 0, 3038, 3036, 1, 0, 0, 0, 3038, 3039, 1, 0, 0,
		0, 3039, 3041, 1, 0, 0, 0, 3040, 3038, 1, 0, 0, 0, 3041, 3043, 5, 3, 0,
		0, 3042, 3032, 1, 0, 0, 0, 3042, 3043, 1, 0, 0, 0, 3043, 3068, 1, 0, 0,
		0, 3044, 3045, 5, 65, 0, 0, 3045, 3046, 5, 21, 0, 0, 3046, 3051, 5, 450,
		0, 0, 3047, 3052, 5, 403, 0, 0, 3048, 3049, 5, 287, 0, 0, 3049, 3052, 5,
		503, 0, 0, 3050, 3052, 5, 81, 0, 0, 3051, 3047, 1, 0, 0, 0, 3051, 3048,
		1, 0, 0, 0, 3051, 3050, 1, 0, 0, 0, 3052, 3053, 1, 0, 0, 0, 3053, 3054,
		5, 192, 0, 0, 3054, 3065, 3, 324, 162, 0, 3055, 3056, 5, 2, 0, 0, 3056,
		3061, 5, 548, 0, 0, 3057, 3058, 5, 4, 0, 0, 3058, 3060, 5, 548, 0, 0, 3059,
		3057, 1, 0, 0, 0, 3060, 3063, 1, 0, 0, 0, 3061, 3059, 1, 0, 0, 0, 3061,
		3062, 1, 0, 0, 0, 3062, 3064, 1, 0, 0, 0, 3063, 3061, 1, 0, 0, 0, 3064,
		3066, 5, 3, 0, 0, 3065, 3055, 1, 0, 0, 0, 3065, 3066, 1, 0, 0, 0, 3066,
		3068, 1, 0, 0, 0, 3067, 2979, 1, 0, 0, 0, 3067, 2988, 1, 0, 0, 0, 3067,
		2997, 1, 0, 0, 0, 3067, 3004, 1, 0, 0, 0, 3067, 3015, 1, 0, 0, 0, 3067,
		3021, 1, 0, 0, 0, 3067, 3027, 1, 0, 0, 0, 3067, 3044, 1, 0, 0, 0, 3068,
		65, 1, 0, 0, 0, 3069, 3070, 5, 15, 0, 0, 3070, 3071, 5, 423, 0, 0, 3071,
		3072, 5, 385, 0, 0, 3072, 3073, 5, 142, 0, 0, 3073, 3074, 5, 192, 0, 0,
		3074, 3225, 3, 72, 36, 0, 3075, 3076, 5, 15, 0, 0, 3076, 3077, 5, 371,
		0, 0, 3077, 3089, 5, 137, 0, 0, 3078, 3079, 5, 317, 0, 0, 3079, 3080, 5,
		2, 0, 0, 3080, 3085, 5, 543, 0, 0, 3081, 3082, 5, 4, 0, 0, 3082, 3084,
		5, 543, 0, 0, 3083, 3081, 1, 0, 0, 0, 3084, 3087, 1, 0, 0, 0, 3085, 3083,
		1, 0, 0, 0, 3085, 3086, 1, 0, 0, 0, 3086, 3088, 1, 0, 0, 0, 3087, 3085,
		1, 0, 0, 0, 3088, 3090, 5, 3, 0, 0, 3089, 3078, 1, 0, 0, 0, 3089, 3090,
		1, 0, 0, 0, 3090, 3225, 1, 0, 0, 0, 3091, 3092, 5, 15, 0, 0, 3092, 3093,
		5, 65, 0, 0, 3093, 3094, 5, 371, 0, 0, 3094, 3106, 5, 137, 0, 0, 3095,
		3096, 5, 317, 0, 0, 3096, 3097, 5, 2, 0, 0, 3097, 3102, 5, 543, 0, 0, 3098,
		3099, 5, 4, 0, 0, 3099, 3101, 5, 543, 0, 0, 3100, 3098, 1, 0, 0, 0, 3101,
		3104, 1, 0, 0, 0, 3102, 3100, 1, 0, 0, 0, 3102, 3103, 1, 0, 0, 0, 3103,
		3105, 1, 0, 0, 0, 3104, 3102, 1, 0, 0, 0, 3105, 3107, 5, 3, 0, 0, 3106,
		3095, 1, 0, 0, 0, 3106, 3107, 1, 0, 0, 0, 3107, 3225, 1, 0, 0, 0, 3108,
		3109, 5, 15, 0, 0, 3109, 3110, 5, 133, 0, 0, 3110, 3111, 5, 453, 0, 0,
		3111, 3225, 5, 548, 0, 0, 3112, 3113, 5, 15, 0, 0, 3113, 3114, 5, 423,
		0, 0, 3114, 3115, 5, 385, 0, 0, 3115, 3116, 5, 438, 0, 0, 3116, 3117, 5,
		192, 0, 0, 3117, 3123, 3, 72, 36, 0, 3118, 3119, 5, 509, 0, 0, 3119, 3120,
		5, 438, 0, 0, 3120, 3124, 5, 517, 0, 0, 3121, 3122, 5, 519, 0, 0, 3122,
		3124, 5, 543, 0, 0, 3123, 3118, 1, 0, 0, 0, 3123, 3121, 1, 0, 0, 0, 3123,
		3124, 1, 0, 0, 0, 3124, 3225, 1, 0, 0, 0, 3125, 3126, 5, 15, 0, 0, 3126,
		3127, 5, 86, 0, 0, 3127, 3128, 5, 450, 0, 0, 3128, 3133, 3, 72, 36, 0,
		3129, 3130, 5, 509, 0, 0, 3130, 3131, 5, 476, 0, 0, 3131, 3132, 5, 517,
		0, 0, 3132, 3134, 5, 543, 0, 0, 3133, 3129, 1, 0, 0, 0, 3133, 3134, 1,
		0, 0, 0, 3134, 3225, 1, 0, 0, 0, 3135, 3136, 5, 15, 0, 0, 3136, 3137, 5,
		73, 0, 0, 3137, 3139, 3, 360, 180, 0, 3138, 3140, 3, 312, 156, 0, 3139,
		3138, 1, 0, 0, 0, 3139, 3140, 1, 0, 0, 0, 3140, 3225, 1, 0, 0, 0, 3141,
		3142, 5, 15, 0, 0, 3142, 3143, 5, 423, 0, 0, 3143, 3144, 5, 453, 0, 0,
		3144, 3145, 5, 440, 0, 0, 3145, 3147, 5, 190, 0, 0, 3146, 3148, 5, 501,
		0, 0, 3147, 3146, 1, 0, 0, 0, 3147, 3148, 1, 0, 0, 0, 3148, 3225, 1, 0,
		0, 0, 3149, 3150, 5, 15, 0, 0, 3150, 3154, 5, 419, 0, 0, 3151, 3155, 5,
		193, 0, 0, 3152, 3153, 5, 20, 0, 0, 3153, 3155, 5, 194, 0, 0, 3154, 3151,
		1, 0, 0, 0, 3154, 3152, 1, 0, 0, 0, 3155, 3156, 1, 0, 0, 0, 3156, 3161,
		5, 91, 0, 0, 3157, 3158, 5, 2, 0, 0, 3158, 3159, 3, 314, 157, 0, 3159,
		3160, 5, 3, 0, 0, 3160, 3162, 1, 0, 0, 0, 3161, 3157, 1, 0, 0, 0, 3161,
		3162, 1, 0, 0, 0, 3162, 3164, 1, 0, 0, 0, 3163, 3165, 5, 20, 0, 0, 3164,
		3163, 1, 0, 0, 0, 3164, 3165, 1, 0, 0, 0, 3165, 3225, 1, 0, 0, 0, 3166,
		3167, 5, 15, 0, 0, 3167, 3168, 5, 74, 0, 0, 3168, 3180, 5, 470, 0, 0, 3169,
		3170, 5, 317, 0, 0, 3170, 3171, 5, 2, 0, 0, 3171, 3176, 5, 543, 0, 0, 3172,
		3173, 5, 4, 0, 0, 3173, 3175, 5, 543, 0, 0, 3174, 3172, 1, 0, 0, 0, 3175,
		3178, 1, 0, 0, 0, 3176, 3174, 1, 0, 0, 0, 3176, 3177, 1, 0, 0, 0, 3177,
		3179, 1, 0, 0, 0, 3178, 3176, 1, 0, 0, 0, 3179, 3181, 5, 3, 0, 0, 3180,
		3169, 1, 0, 0, 0, 3180, 3181, 1, 0, 0, 0, 3181, 3225, 1, 0, 0, 0, 3182,
		3183, 5, 15, 0, 0, 3183, 3184, 5, 419, 0, 0, 3184, 3185, 5, 385, 0, 0,
		3185, 3186, 5, 502, 0, 0, 3186, 3187, 5, 358, 0, 0, 3187, 3188, 5, 2, 0,
		0, 3188, 3189, 3, 314, 157, 0, 3189, 3190, 5, 3, 0, 0, 3190, 3225, 1, 0,
		0, 0, 3191, 3192, 5, 15, 0, 0, 3192, 3193, 5, 419, 0, 0, 3193, 3194, 5,
		450, 0, 0, 3194, 3195, 3, 324, 162, 0, 3195, 3197, 5, 438, 0, 0, 3196,
		3198, 3, 312, 156, 0, 3197, 3196, 1, 0, 0, 0, 3197, 3198, 1, 0, 0, 0, 3198,
		3225, 1, 0, 0, 0, 3199, 3200, 5, 15, 0, 0, 3200, 3201, 5, 419, 0, 0, 3201,
		3202, 5, 385, 0, 0, 3202, 3203, 5, 438, 0, 0, 3203, 3204, 5, 358, 0, 0,
		3204, 3205, 5, 2, 0, 0, 3205, 3206, 3, 314, 157, 0, 3206, 3207, 5, 3, 0,
		0, 3207, 3225, 1, 0, 0, 0, 3208, 3209, 5, 15, 0, 0, 3209, 3210, 5, 380,
		0, 0, 3210, 3211, 5, 450, 0, 0, 3211, 3225, 3, 72, 36, 0, 3212, 3213, 5,
		15, 0, 0, 3213, 3214, 5, 65, 0, 0, 3214, 3215, 5, 380, 0, 0, 3215, 3216,
		5, 450, 0, 0, 3216, 3225, 3, 72, 36, 0, 3217, 3218, 5, 15, 0, 0, 3218,
		3219, 5, 99, 0, 0, 3219, 3220, 5, 453, 0, 0, 3220, 3222, 5, 548, 0, 0,
		3221, 3223, 3, 312, 156, 0, 3222, 3221, 1, 0, 0, 0, 3222, 3223, 1, 0, 0,
		0, 3223, 3225, 1, 0, 0, 0, 3224, 3069, 1, 0, 0, 0, 3224, 3075, 1, 0, 0,
		0, 3224, 3091, 1, 0, 0, 0, 3224, 3108, 1, 0, 0, 0, 3224, 3112, 1, 0, 0,
		0, 3224, 3125, 1, 0, 0, 0, 3224, 3135, 1, 0, 0, 0, 3224, 3141, 1, 0, 0,
		0, 3224, 3149, 1, 0, 0, 0, 3224, 3166, 1, 0, 0, 0, 3224, 3182, 1, 0, 0,
		0, 3224, 3191, 1, 0, 0, 0, 3224, 3199, 1, 0, 0, 0, 3224, 3208, 1, 0, 0,
		0, 3224, 3212, 1, 0, 0, 0, 3224, 3217, 1, 0, 0, 0, 3225, 67, 1, 0, 0, 0,
		3226, 3227, 5, 373, 0, 0, 3227, 3228, 5, 113, 0, 0, 3228, 3230, 3, 440,
		220, 0, 3229, 3231, 5, 548, 0, 0, 3230, 3229, 1, 0, 0, 0, 3230, 3231, 1,
		0, 0, 0, 3231, 3234, 1, 0, 0, 0, 3232, 3233, 5, 29, 0, 0, 3233, 3235, 3,
		440, 220, 0, 3234, 3232, 1, 0, 0, 0, 3234, 3235, 1, 0, 0, 0, 3235, 3260,
		1, 0, 0, 0, 3236, 3237, 5, 373, 0, 0, 3237, 3238, 5, 450, 0, 0, 3238, 3240,
		3, 324, 162, 0, 3239, 3241, 5, 548, 0, 0, 3240, 3239, 1, 0, 0, 0, 3240,
		3241, 1, 0, 0, 0, 3241, 3244, 1, 0, 0, 0, 3242, 3243, 5, 29, 0, 0, 3243,
		3245, 3, 440, 220, 0, 3244, 3242, 1, 0, 0, 0, 3244, 3245, 1, 0, 0, 0, 3245,
		3260, 1, 0, 0, 0, 3246, 3247, 5, 373, 0, 0, 3247, 3248, 5, 329, 0, 0, 3248,
		3250, 3, 440, 220, 0, 3249, 3251, 5, 548, 0, 0, 3250, 3249, 1, 0, 0, 0,
		3250, 3251, 1, 0, 0, 0, 3251, 3254, 1, 0, 0, 0, 3252, 3253, 5, 29, 0, 0,
		3253, 3255, 3, 440, 220, 0, 3254, 3252, 1, 0, 0, 0, 3254, 3255, 1, 0, 0,
		0, 3255, 3256, 1, 0, 0, 0, 3256, 3257, 5, 192, 0, 0, 3257, 3258, 3, 324,
		162, 0, 3258, 3260, 1, 0, 0, 0, 3259, 3226, 1, 0, 0, 0, 3259, 3236, 1,
		0, 0, 0, 3259, 3246, 1, 0, 0, 0, 3260, 69, 1, 0, 0, 0, 3261, 3262, 5, 15,
		0, 0, 3262, 3263, 5, 419, 0, 0, 3263, 3264, 5, 450, 0, 0, 3264, 3265, 3,
		324, 162, 0, 3265, 3266, 5, 329, 0, 0, 3266, 3268, 5, 502, 0, 0, 3267,
		3269, 3, 312, 156, 0, 3268, 3267, 1, 0, 0, 0, 3268, 3269, 1, 0, 0, 0, 3269,
		71, 1, 0, 0, 0, 3270, 3272, 3, 324, 162, 0, 3271, 3273, 3, 306, 153, 0,
		3272, 3271, 1, 0, 0, 0, 3272, 3273, 1, 0, 0, 0, 3273, 3275, 1, 0, 0, 0,
		3274, 3276, 3, 434, 217, 0, 3275, 3274, 1, 0, 0, 0, 3275, 3276, 1, 0, 0,
		0, 3276, 3278, 1, 0, 0, 0, 3277, 3279, 3, 404, 202, 0, 3278, 3277, 1, 0,
		0, 0, 3278, 3279, 1, 0, 0, 0, 3279, 3281, 1, 0, 0, 0, 3280, 3282, 3, 360,
		180, 0, 3281, 3280, 1, 0, 0, 0, 3281, 3282, 1, 0, 0, 0, 3282, 3283, 1,
		0, 0, 0, 3283, 3285, 3, 322, 161, 0, 3284, 3286, 3, 430, 215, 0, 3285,
		3284, 1, 0, 0, 0, 3285, 3286, 1, 0, 0, 0, 3286, 3288, 1, 0, 0, 0, 3287,
		3289, 3, 264, 132, 0, 3288, 3287, 1, 0, 0, 0, 3288, 3289, 1, 0, 0, 0, 3289,
		73, 1, 0, 0, 0, 3290, 3291, 5, 265, 0, 0, 3291, 3295, 5, 543, 0, 0, 3292,
		3293, 5, 509, 0, 0, 3293, 3295, 3, 368, 184, 0, 3294, 3290, 1, 0, 0, 0,
		3294, 3292, 1, 0, 0, 0, 3295, 75, 1, 0, 0, 0, 3296, 3302, 5, 39, 0, 0,
		3297, 3298, 5, 511, 0, 0, 3298, 3300, 5, 255, 0, 0, 3299, 3301, 3, 440,
		220, 0, 3300, 3299, 1, 0, 0, 0, 3300, 3301, 1, 0, 0, 0, 3301, 3303, 1,
		0, 0, 0, 3302, 3297, 1, 0, 0, 0, 3302, 3303, 1, 0, 0, 0, 3303, 3339, 1,
		0, 0, 0, 3304, 3306, 5, 84, 0, 0, 3305, 3307, 5, 512, 0, 0, 3306, 3305,
		1, 0, 0, 0, 3306, 3307, 1, 0, 0, 0, 3307, 3313, 1, 0, 0, 0, 3308, 3310,
		5, 25, 0, 0, 3309, 3311, 5, 308, 0, 0, 3310, 3309, 1, 0, 0, 0, 3310, 3311,
		1, 0, 0, 0, 3311, 3312, 1, 0, 0, 0, 3312, 3314, 5, 70, 0, 0, 3313, 3308,
		1, 0, 0, 0, 3313, 3314, 1, 0, 0, 0, 3314, 3319, 1, 0, 0, 0, 3315, 3317,
		5, 308, 0, 0, 3316, 3315, 1, 0, 0, 0, 3316, 3317, 1, 0, 0, 0, 3317, 3318,
		1, 0, 0, 0, 3318, 3320, 5, 378, 0, 0, 3319, 3316, 1, 0, 0, 0, 3319, 3320,
		1, 0, 0, 0, 3320, 3339, 1, 0, 0, 0, 3321, 3323, 5, 402, 0, 0, 3322, 3324,
		5, 512, 0, 0, 3323, 3322, 1, 0, 0, 0, 3323, 3324, 1, 0, 0, 0, 3324, 3330,
		1, 0, 0, 0, 3325, 3327, 5, 25, 0, 0, 3326, 3328, 5, 308, 0, 0, 3327, 3326,
		1, 0, 0, 0, 3327, 3328, 1, 0, 0, 0, 3328, 3329, 1, 0, 0, 0, 3329, 3331,
		5, 70, 0, 0, 3330, 3325, 1, 0, 0, 0, 3330, 3331, 1, 0, 0, 0, 3331, 3336,
		1, 0, 0, 0, 3332, 3334, 5, 308, 0, 0, 3333, 3332, 1, 0, 0, 0, 3333, 3334,
		1, 0, 0, 0, 3334, 3335, 1, 0, 0, 0, 3335, 3337, 5, 378, 0, 0, 3336, 3333,
		1, 0, 0, 0, 3336, 3337, 1, 0, 0, 0, 3337, 3339, 1, 0, 0, 0, 3338, 3296,
		1, 0, 0, 0, 3338, 3304, 1, 0, 0, 0, 3338, 3321, 1, 0, 0, 0, 3339, 77, 1,
		0, 0, 0, 3340, 3341, 5, 201, 0, 0, 3341, 3342, 3, 82, 41, 0, 3342, 3343,
		5, 317, 0, 0, 3343, 3344, 3, 184, 92, 0, 3344, 3348, 5, 466, 0, 0, 3345,
		3349, 3, 188, 94, 0, 3346, 3347, 5, 400, 0, 0, 3347, 3349, 3, 180, 90,
		0, 3348, 3345, 1, 0, 0, 0, 3348, 3346, 1, 0, 0, 0, 3349, 3427, 1, 0, 0,
		0, 3350, 3351, 5, 201, 0, 0, 3351, 3352, 3, 82, 41, 0, 3352, 3362, 5, 317,
		0, 0, 3353, 3363, 5, 388, 0, 0, 3354, 3363, 5, 75, 0, 0, 3355, 3356, 5,
		89, 0, 0, 3356, 3363, 5, 204, 0, 0, 3357, 3363, 5, 433, 0, 0, 3358, 3359,
		5, 440, 0, 0, 3359, 3363, 5, 499, 0, 0, 3360, 3361, 5, 513, 0, 0, 3361,
		3363, 5, 204, 0, 0, 3362, 3353, 1, 0, 0, 0, 3362, 3354, 1, 0, 0, 0, 3362,
		3355, 1, 0, 0, 0, 3362, 3357, 1, 0, 0, 0, 3362, 3358, 1, 0, 0, 0, 3362,
		3360, 1, 0, 0, 0, 3363, 3364, 1, 0, 0, 0, 3364, 3365, 3, 182, 91, 0, 3365,
		3369, 5, 466, 0, 0, 3366, 3370, 3, 188, 94, 0, 3367, 3368, 5, 400, 0, 0,
		3368, 3370, 3, 180, 90, 0, 3369, 3366, 1, 0, 0, 0, 3369, 3367, 1, 0, 0,
		0, 3370, 3427, 1, 0, 0, 0, 3371, 3372, 5, 201, 0, 0, 3372, 3377, 3, 180,
		90, 0, 3373, 3374, 5, 4, 0, 0, 3374, 3376, 3, 180, 90, 0, 3375, 3373, 1,
		0, 0, 0, 3376, 3379, 1, 0, 0, 0, 3377, 3375, 1, 0, 0, 0, 3377, 3378, 1,
		0, 0, 0, 3378, 3380, 1, 0, 0, 0, 3379, 3377, 1, 0, 0, 0, 3380, 3381, 5,
		466, 0, 0, 3381, 3382, 3, 188, 94, 0, 3382, 3427, 1, 0, 0, 0, 3383, 3384,
		5, 396, 0, 0, 3384, 3389, 3, 180, 90, 0, 3385, 3386, 5, 4, 0, 0, 3386,
		3388, 3, 180, 90, 0, 3387, 3385, 1, 0, 0, 0, 3388, 3391, 1, 0, 0, 0, 3389,
		3387, 1, 0, 0, 0, 3389, 3390, 1, 0, 0, 0, 3390, 3392, 1, 0, 0, 0, 3391,
		3389, 1, 0, 0, 0, 3392, 3393, 5, 192, 0, 0, 3393, 3394, 3, 188, 94, 0,
		3394, 3427, 1, 0, 0, 0, 3395, 3396, 5, 396, 0, 0, 3396, 3397, 3, 82, 41,
		0, 3397, 3407, 5, 317, 0, 0, 3398, 3408, 5, 388, 0, 0, 3399, 3408, 5, 75,
		0, 0, 3400, 3401, 5, 89, 0, 0, 3401, 3408, 5, 204, 0, 0, 3402, 3408, 5,
		433, 0, 0, 3403, 3404, 5, 440, 0, 0, 3404, 3408, 5, 499, 0, 0, 3405, 3406,
		5, 513, 0, 0, 3406, 3408, 5, 204, 0, 0, 3407, 3398, 1, 0, 0, 0, 3407, 3399,
		1, 0, 0, 0, 3407, 3400, 1, 0, 0, 0, 3407, 3402, 1, 0, 0, 0, 3407, 3403,
		1, 0, 0, 0, 3407, 3405, 1, 0, 0, 0, 3408, 3409, 1, 0, 0, 0, 3409, 3410,
		3, 182, 91, 0, 3410, 3414, 5, 192, 0, 0, 3411, 3415, 3, 188, 94, 0, 3412,
		3413, 5, 400, 0, 0, 3413, 3415, 3, 180, 90, 0, 3414, 3411, 1, 0, 0, 0,
		3414, 3412, 1, 0, 0, 0, 3415, 3427, 1, 0, 0, 0, 3416, 3417, 5, 396, 0,
		0, 3417, 3418, 3, 82, 41, 0, 3418, 3419, 5, 317, 0, 0, 3419, 3420, 3, 184,
		92, 0, 3420, 3424, 5, 192, 0, 0, 3421, 3425, 3, 188, 94, 0, 3422, 3423,
		5, 400, 0, 0, 3423, 3425, 3, 180, 90, 0, 3424, 3421, 1, 0, 0, 0, 3424,
		3422, 1, 0, 0, 0, 3425, 3427, 1, 0, 0, 0, 3426, 3340, 1, 0, 0, 0, 3426,
		3350, 1, 0, 0, 0, 3426, 3371, 1, 0, 0, 0, 3426, 3383, 1, 0, 0, 0, 3426,
		3395, 1, 0, 0, 0, 3426, 3416, 1, 0, 0, 0, 3427, 79, 1, 0, 0, 0, 3428, 3430,
		3, 440, 220, 0, 3429, 3431, 3, 302, 151, 0, 3430, 3429, 1, 0, 0, 0, 3430,
		3431, 1, 0, 0, 0, 3431, 3434, 1, 0, 0, 0, 3432, 3434, 5, 20, 0, 0, 3433,
		3428, 1, 0, 0, 0, 3433, 3432, 1, 0, 0, 0, 3434, 81, 1, 0, 0, 0, 3435, 3440,
		3, 80, 40, 0, 3436, 3437, 5, 4, 0, 0, 3437, 3439, 3, 80, 40, 0, 3438, 3436,
		1, 0, 0, 0, 3439, 3442, 1, 0, 0, 0, 3440, 3438, 1, 0, 0, 0, 3440, 3441,
		1, 0, 0, 0, 3441, 83, 1, 0, 0, 0, 3442, 3440, 1, 0, 0, 0, 3443, 3444, 5,
		14, 0, 0, 3444, 3445, 5, 36, 0, 0, 3445, 3450, 5, 543, 0, 0, 3446, 3447,
		5, 4, 0, 0, 3447, 3449, 5, 543, 0, 0, 3448, 3446, 1, 0, 0, 0, 3449, 3452,
		1, 0, 0, 0, 3450, 3448, 1, 0, 0, 0, 3450, 3451, 1, 0, 0, 0, 3451, 3454,
		1, 0, 0, 0, 3452, 3450, 1, 0, 0, 0, 3453, 3455, 3, 312, 156, 0, 3454, 3453,
		1, 0, 0, 0, 3454, 3455, 1, 0, 0, 0, 3455, 3542, 1, 0, 0, 0, 3456, 3457,
		7, 21, 0, 0, 3457, 3458, 5, 36, 0, 0, 3458, 3463, 5, 543, 0, 0, 3459, 3460,
		5, 4, 0, 0, 3460, 3462, 5, 543, 0, 0, 3461, 3459, 1, 0, 0, 0, 3462, 3465,
		1, 0, 0, 0, 3463, 3461, 1, 0, 0, 0, 3463, 3464, 1, 0, 0, 0, 3464, 3542,
		1, 0, 0, 0, 3465, 3463, 1, 0, 0, 0, 3466, 3467, 5, 126, 0, 0, 3467, 3468,
		5, 36, 0, 0, 3468, 3473, 5, 543, 0, 0, 3469, 3470, 5, 4, 0, 0, 3470, 3472,
		5, 543, 0, 0, 3471, 3469, 1, 0, 0, 0, 3472, 3475, 1, 0, 0, 0, 3473, 3471,
		1, 0, 0, 0, 3473, 3474, 1, 0, 0, 0, 3474, 3542, 1, 0, 0, 0, 3475, 3473,
		1, 0, 0, 0, 3476, 3477, 5, 14, 0, 0, 3477, 3478, 5, 314, 0, 0, 3478, 3542,
		5, 543, 0, 0, 3479, 3480, 5, 147, 0, 0, 3480, 3481, 5, 314, 0, 0, 3481,
		3542, 5, 543, 0, 0, 3482, 3483, 5, 14, 0, 0, 3483, 3484, 5, 185, 0, 0,
		3484, 3542, 5, 543, 0, 0, 3485, 3486, 5, 147, 0, 0, 3486, 3487, 5, 185,
		0, 0, 3487, 3542, 5, 543, 0, 0, 3488, 3489, 5, 14, 0, 0, 3489, 3490, 5,
		56, 0, 0, 3490, 3491, 3, 180, 90, 0, 3491, 3496, 5, 543, 0, 0, 3492, 3493,
		5, 4, 0, 0, 3493, 3495, 5, 543, 0, 0, 3494, 3492, 1, 0, 0, 0, 3495, 3498,
		1, 0, 0, 0, 3496, 3494, 1, 0, 0, 0, 3496, 3497, 1, 0, 0, 0, 3497, 3542,
		1, 0, 0, 0, 3498, 3496, 1, 0, 0, 0, 3499, 3500, 5, 147, 0, 0, 3500, 3501,
		5, 56, 0, 0, 3501, 3502, 3, 180, 90, 0, 3502, 3507, 5, 543, 0, 0, 3503,
		3504, 5, 4, 0, 0, 3504, 3506, 5, 543, 0, 0, 3505, 3503, 1, 0, 0, 0, 3506,
		3509, 1, 0, 0, 0, 3507, 3505, 1, 0, 0, 0, 3507, 3508, 1, 0, 0, 0, 3508,
		3542, 1, 0, 0, 0, 3509, 3507, 1, 0, 0, 0, 3510, 3511, 5, 147, 0, 0, 3511,
		3512, 5, 20, 0, 0, 3512, 3513, 5, 56, 0, 0, 3513, 3542, 3, 180, 90, 0,
		3514, 3515, 5, 419, 0, 0, 3515, 3516, 5, 270, 0, 0, 3516, 3517, 5, 163,
		0, 0, 3517, 3519, 5, 219, 0, 0, 3518, 3520, 3, 312, 156, 0, 3519, 3518,
		1, 0, 0, 0, 3519, 3520, 1, 0, 0, 0, 3520, 3542, 1, 0, 0, 0, 3521, 3522,
		5, 298, 0, 0, 3522, 3523, 5, 36, 0, 0, 3523, 3528, 5, 543, 0, 0, 3524,
		3525, 5, 4, 0, 0, 3525, 3527, 5, 543, 0, 0, 3526, 3524, 1, 0, 0, 0, 3527,
		3530, 1, 0, 0, 0, 3528, 3526, 1, 0, 0, 0, 3528, 3529, 1, 0, 0, 0, 3529,
		3531, 1, 0, 0, 0, 3530, 3528, 1, 0, 0, 0, 3531, 3532, 5, 419, 0, 0, 3532,
		3533, 5, 2, 0, 0, 3533, 3534, 3, 314, 157, 0, 3534, 3535, 5, 3, 0, 0, 3535,
		3542, 1, 0, 0, 0, 3536, 3537, 5, 298, 0, 0, 3537, 3538, 7, 2, 0, 0, 3538,
		3539, 5, 543, 0, 0, 3539, 3540, 5, 215, 0, 0, 3540, 3542, 5, 543, 0, 0,
		3541, 3443, 1, 0, 0, 0, 3541, 3456, 1, 0, 0, 0, 3541, 3466, 1, 0, 0, 0,
		3541, 3476, 1, 0, 0, 0, 3541, 3479, 1, 0, 0, 0, 3541, 3482, 1, 0, 0, 0,
		3541, 3485, 1, 0, 0, 0, 3541, 3488, 1, 0, 0, 0, 3541, 3499, 1, 0, 0, 0,
		3541, 3510, 1, 0, 0, 0, 3541, 3514, 1, 0, 0, 0, 3541, 3521, 1, 0, 0, 0,
		3541, 3536, 1, 0, 0, 0, 3542, 85, 1, 0, 0, 0, 3543, 3545, 3, 440, 220,
		0, 3544, 3546, 3, 312, 156, 0, 3545, 3544, 1, 0, 0, 0, 3545, 3546, 1, 0,
		0, 0, 3546, 87, 1, 0, 0, 0, 3547, 3548, 3, 440, 220, 0, 3548, 3552, 3,
		302, 151, 0, 3549, 3550, 5, 151, 0, 0, 3550, 3551, 5, 252, 0, 0, 3551,
		3553, 3, 302, 151, 0, 3552, 3549, 1, 0, 0, 0, 3552, 3553, 1, 0, 0, 0, 3553,
		3555, 1, 0, 0, 0, 3554, 3556, 3, 112, 56, 0, 3555, 3554, 1, 0, 0, 0, 3555,
		3556, 1, 0, 0, 0, 3556, 3558, 1, 0, 0, 0, 3557, 3559, 3, 312, 156, 0, 3558,
		3557, 1, 0, 0, 0, 3558, 3559, 1, 0, 0, 0, 3559, 89, 1, 0, 0, 0, 3560, 3561,
		5, 14, 0, 0, 3561, 3562, 5, 81, 0, 0, 3562, 3564, 3, 332, 166, 0, 3563,
		3565, 3, 108, 54, 0, 3564, 3563, 1, 0, 0, 0, 3564, 3565, 1, 0, 0, 0, 3565,
		3567, 1, 0, 0, 0, 3566, 3568, 3, 110, 55, 0, 3567, 3566, 1, 0, 0, 0, 3567,
		3568, 1, 0, 0, 0, 3568, 3570, 1, 0, 0, 0, 3569, 3571, 3, 312, 156, 0, 3570,
		3569, 1, 0, 0, 0, 3570, 3571, 1, 0, 0, 0, 3571, 3783, 1, 0, 0, 0, 3572,
		3573, 5, 14, 0, 0, 3573, 3574, 5, 81, 0, 0, 3574, 3575, 5, 2, 0, 0, 3575,
		3576, 3, 330, 165, 0, 3576, 3578, 5, 3, 0, 0, 3577, 3579, 3, 110, 55, 0,
		3578, 3577, 1, 0, 0, 0, 3578, 3579, 1, 0, 0, 0, 3579, 3581, 1, 0, 0, 0,
		3580, 3582, 3, 312, 156, 0, 3581, 3580, 1, 0, 0, 0, 3581, 3582, 1, 0, 0,
		0, 3582, 3783, 1, 0, 0, 0, 3583, 3584, 5, 147, 0, 0, 3584, 3585, 5, 81,
		0, 0, 3585, 3587, 3, 440, 220, 0, 3586, 3588, 3, 112, 56, 0, 3587, 3586,
		1, 0, 0, 0, 3587, 3588, 1, 0, 0, 0, 3588, 3590, 1, 0, 0, 0, 3589, 3591,
		3, 312, 156, 0, 3590, 3589, 1, 0, 0, 0, 3590, 3591, 1, 0, 0, 0, 3591, 3783,
		1, 0, 0, 0, 3592, 3593, 5, 298, 0, 0, 3593, 3594, 5, 81, 0, 0, 3594, 3596,
		3, 332, 166, 0, 3595, 3597, 3, 108, 54, 0, 3596, 3595, 1, 0, 0, 0, 3596,
		3597, 1, 0, 0, 0, 3597, 3599, 1, 0, 0, 0, 3598, 3600, 3, 112, 56, 0, 3599,
		3598, 1, 0, 0, 0, 3599, 3600, 1, 0, 0, 0, 3600, 3602, 1, 0, 0, 0, 3601,
		3603, 3, 312, 156, 0, 3602, 3601, 1, 0, 0, 0, 3602, 3603, 1, 0, 0, 0, 3603,
		3783, 1, 0, 0, 0, 3604, 3605, 5, 322, 0, 0, 3605, 3606, 5, 61, 0, 0, 3606,
		3608, 3, 302, 151, 0, 3607, 3609, 3, 112, 56, 0, 3608, 3607, 1, 0, 0, 0,
		3608, 3609, 1, 0, 0, 0, 3609, 3611, 1, 0, 0, 0, 3610, 3612, 3, 312, 156,
		0, 3611, 3610, 1, 0, 0, 0, 3611, 3612, 1, 0, 0, 0, 3612, 3783, 1, 0, 0,
		0, 3613, 3615, 5, 14, 0, 0, 3614, 3616, 5, 458, 0, 0, 3615, 3614, 1, 0,
		0, 0, 3615, 3616, 1, 0, 0, 0, 3616, 3617, 1, 0, 0, 0, 3617, 3632, 3, 340,
		170, 0, 3618, 3619, 5, 141, 0, 0, 3619, 3623, 5, 61, 0, 0, 3620, 3621,
		5, 207, 0, 0, 3621, 3624, 3, 302, 151, 0, 3622, 3624, 5, 367, 0, 0, 3623,
		3620, 1, 0, 0, 0, 3623, 3622, 1, 0, 0, 0, 3624, 3630, 1, 0, 0, 0, 3625,
		3628, 5, 57, 0, 0, 3626, 3629, 5, 548, 0, 0, 3627, 3629, 5, 33, 0, 0, 3628,
		3626, 1, 0, 0, 0, 3628, 3627, 1, 0, 0, 0, 3629, 3631, 1, 0, 0, 0, 3630,
		3625, 1, 0, 0, 0, 3630, 3631, 1, 0, 0, 0, 3631, 3633, 1, 0, 0, 0, 3632,
		3618, 1, 0, 0, 0, 3632, 3633, 1, 0, 0, 0, 3633, 3635, 1, 0, 0, 0, 3634,
		3636, 3, 312, 156, 0, 3635, 3634, 1, 0, 0, 0, 3635, 3636, 1, 0, 0, 0, 3636,
		3783, 1, 0, 0, 0, 3637, 3639, 5, 147, 0, 0, 3638, 3640, 5, 458, 0, 0, 3639,
		3638, 1, 0, 0, 0, 3639, 3640, 1, 0, 0, 0, 3640, 3641, 1, 0, 0, 0, 3641,
		3644, 5, 329, 0, 0, 3642, 3643, 5, 221, 0, 0, 3643, 3645, 5, 169, 0, 0,
		3644, 3642, 1, 0, 0, 0, 3644, 3645, 1, 0, 0, 0, 3645, 3646, 1, 0, 0, 0,
		3646, 3648, 3, 440, 220, 0, 3647, 3649, 5, 189, 0, 0, 3648, 3647, 1, 0,
		0, 0, 3648, 3649, 1, 0, 0, 0, 3649, 3653, 1, 0, 0, 0, 3650, 3651, 5, 192,
		0, 0, 3651, 3652, 5, 226, 0, 0, 3652, 3654, 3, 440, 220, 0, 3653, 3650,
		1, 0, 0, 0, 3653, 3654, 1, 0, 0, 0, 3654, 3783, 1, 0, 0, 0, 3655, 3657,
		5, 298, 0, 0, 3656, 3658, 5, 458, 0, 0, 3657, 3656, 1, 0, 0, 0, 3657, 3658,
		1, 0, 0, 0, 3658, 3659, 1, 0, 0, 0, 3659, 3665, 5, 329, 0, 0, 3660, 3666,
		3, 440, 220, 0, 3661, 3666, 3, 302, 151, 0, 3662, 3663, 5, 2, 0, 0, 3663,
		3664, 5, 526, 0, 0, 3664, 3666, 5, 3, 0, 0, 3665, 3660, 1, 0, 0, 0, 3665,
		3661, 1, 0, 0, 0, 3665, 3662, 1, 0, 0, 0, 3666, 3667, 1, 0, 0, 0, 3667,
		3668, 5, 419, 0, 0, 3668, 3669, 5, 2, 0, 0, 3669, 3670, 3, 314, 157, 0,
		3670, 3671, 5, 3, 0, 0, 3671, 3783, 1, 0, 0, 0, 3672, 3674, 5, 382, 0,
		0, 3673, 3675, 3, 158, 79, 0, 3674, 3673, 1, 0, 0, 0, 3674, 3675, 1, 0,
		0, 0, 3675, 3676, 1, 0, 0, 0, 3676, 3678, 5, 511, 0, 0, 3677, 3679, 3,
		158, 79, 0, 3678, 3677, 1, 0, 0, 0, 3678, 3679, 1, 0, 0, 0, 3679, 3681,
		1, 0, 0, 0, 3680, 3682, 5, 189, 0, 0, 3681, 3680, 1, 0, 0, 0, 3681, 3682,
		1, 0, 0, 0, 3682, 3684, 1, 0, 0, 0, 3683, 3685, 3, 312, 156, 0, 3684, 3683,
		1, 0, 0, 0, 3684, 3685, 1, 0, 0, 0, 3685, 3783, 1, 0, 0, 0, 3686, 3687,
		5, 382, 0, 0, 3687, 3688, 5, 511, 0, 0, 3688, 3689, 5, 450, 0, 0, 3689,
		3691, 3, 440, 220, 0, 3690, 3692, 3, 312, 156, 0, 3691, 3690, 1, 0, 0,
		0, 3691, 3692, 1, 0, 0, 0, 3692, 3694, 1, 0, 0, 0, 3693, 3695, 5, 189,
		0, 0, 3694, 3693, 1, 0, 0, 0, 3694, 3695, 1, 0, 0, 0, 3695, 3783, 1, 0,
		0, 0, 3696, 3697, 5, 379, 0, 0, 3697, 3783, 3, 440, 220, 0, 3698, 3699,
		5, 379, 0, 0, 3699, 3700, 5, 403, 0, 0, 3700, 3701, 3, 440, 220, 0, 3701,
		3702, 3, 440, 220, 0, 3702, 3783, 1, 0, 0, 0, 3703, 3704, 5, 379, 0, 0,
		3704, 3705, 5, 329, 0, 0, 3705, 3706, 3, 440, 220, 0, 3706, 3707, 3, 440,
		220, 0, 3707, 3783, 1, 0, 0, 0, 3708, 3709, 5, 379, 0, 0, 3709, 3710, 5,
		81, 0, 0, 3710, 3711, 3, 440, 220, 0, 3711, 3712, 3, 440, 220, 0, 3712,
		3783, 1, 0, 0, 0, 3713, 3714, 5, 14, 0, 0, 3714, 3783, 3, 336, 168, 0,
		3715, 3716, 5, 147, 0, 0, 3716, 3719, 5, 226, 0, 0, 3717, 3718, 5, 221,
		0, 0, 3718, 3720, 5, 169, 0, 0, 3719, 3717, 1, 0, 0, 0, 3719, 3720, 1,
		0, 0, 0, 3720, 3721, 1, 0, 0, 0, 3721, 3783, 3, 440, 220, 0, 3722, 3723,
		5, 155, 0, 0, 3723, 3724, 5, 179, 0, 0, 3724, 3727, 5, 543, 0, 0, 3725,
		3726, 5, 511, 0, 0, 3726, 3728, 3, 312, 156, 0, 3727, 3725, 1, 0, 0, 0,
		3727, 3728, 1, 0, 0, 0, 3728, 3783, 1, 0, 0, 0, 3729, 3730, 5, 298, 0,
		0, 3730, 3745, 5, 142, 0, 0, 3731, 3732, 5, 141, 0, 0, 3732, 3736, 5, 61,
		0, 0, 3733, 3734, 5, 207, 0, 0, 3734, 3737, 3, 302, 151, 0, 3735, 3737,
		5, 367, 0, 0, 3736, 3733, 1, 0, 0, 0, 3736, 3735, 1, 0, 0, 0, 3737, 3743,
		1, 0, 0, 0, 3738, 3741, 5, 57, 0, 0, 3739, 3742, 5, 548, 0, 0, 3740, 3742,
		5, 33, 0, 0, 3741, 3739, 1, 0, 0, 0, 3741, 3740, 1, 0, 0, 0, 3742, 3744,
		1, 0, 0, 0, 3743, 3738, 1, 0, 0, 0, 3743, 3744, 1, 0, 0, 0, 3744, 3746,
		1, 0, 0, 0, 3745, 3731, 1, 0, 0, 0, 3745, 3746, 1, 0, 0, 0, 3746, 3783,
		1, 0, 0, 0, 3747, 3748, 5, 298, 0, 0, 3748, 3749, 5, 83, 0, 0, 3749, 3783,
		5, 543, 0, 0, 3750, 3751, 5, 298, 0, 0, 3751, 3752, 5, 81, 0, 0, 3752,
		3753, 3, 440, 220, 0, 3753, 3754, 5, 83, 0, 0, 3754, 3755, 5, 543, 0, 0,
		3755, 3783, 1, 0, 0, 0, 3756, 3757, 5, 298, 0, 0, 3757, 3758, 5, 160, 0,
		0, 3758, 3759, 5, 466, 0, 0, 3759, 3761, 3, 440, 220, 0, 3760, 3762, 3,
		312, 156, 0, 3761, 3760, 1, 0, 0, 0, 3761, 3762, 1, 0, 0, 0, 3762, 3783,
		1, 0, 0, 0, 3763, 3765, 5, 14, 0, 0, 3764, 3766, 5, 458, 0, 0, 3765, 3764,
		1, 0, 0, 0, 3765, 3766, 1, 0, 0, 0, 3766, 3767, 1, 0, 0, 0, 3767, 3768,
		5, 330, 0, 0, 3768, 3769, 5, 192, 0, 0, 3769, 3770, 3, 350, 175, 0, 3770,
		3771, 5, 466, 0, 0, 3771, 3772, 3, 350, 175, 0, 3772, 3773, 5, 236, 0,
		0, 3773, 3775, 5, 548, 0, 0, 3774, 3776, 3, 440, 220, 0, 3775, 3774, 1,
		0, 0, 0, 3775, 3776, 1, 0, 0, 0, 3776, 3778, 1, 0, 0, 0, 3777, 3779, 3,
		312, 156, 0, 3778, 3777, 1, 0, 0, 0, 3778, 3779, 1, 0, 0, 0, 3779, 3783,
		1, 0, 0, 0, 3780, 3783, 3, 92, 46, 0, 3781, 3783, 3, 94, 47, 0, 3782, 3560,
		1, 0, 0, 0, 3782, 3572, 1, 0, 0, 0, 3782, 3583, 1, 0, 0, 0, 3782, 3592,
		1, 0, 0, 0, 3782, 3604, 1, 0, 0, 0, 3782, 3613, 1, 0, 0, 0, 3782, 3637,
		1, 0, 0, 0, 3782, 3655, 1, 0, 0, 0, 3782, 3672, 1, 0, 0, 0, 3782, 3686,
		1, 0, 0, 0, 3782, 3696, 1, 0, 0, 0, 3782, 3698, 1, 0, 0, 0, 3782, 3703,
		1, 0, 0, 0, 3782, 3708, 1, 0, 0, 0, 3782, 3713, 1, 0, 0, 0, 3782, 3715,
		1, 0, 0, 0, 3782, 3722, 1, 0, 0, 0, 3782, 3729, 1, 0, 0, 0, 3782, 3747,
		1, 0, 0, 0, 3782, 3750, 1, 0, 0, 0, 3782, 3756, 1, 0, 0, 0, 3782, 3763,
		1, 0, 0, 0, 3782, 3780, 1, 0, 0, 0, 3782, 3781, 1, 0, 0, 0, 3783, 91, 1,
		0, 0, 0, 3784, 3785, 5, 101, 0, 0, 3785, 3789, 5, 455, 0, 0, 3786, 3787,
		5, 221, 0, 0, 3787, 3788, 5, 311, 0, 0, 3788, 3790, 5, 169, 0, 0, 3789,
		3786, 1, 0, 0, 0, 3789, 3790, 1, 0, 0, 0, 3790, 3791, 1, 0, 0, 0, 3791,
		3792, 3, 440, 220, 0, 3792, 3793, 3, 96, 48, 0, 3793, 3804, 1, 0, 0, 0,
		3794, 3795, 5, 101, 0, 0, 3795, 3797, 5, 321, 0, 0, 3796, 3794, 1, 0, 0,
		0, 3796, 3797, 1, 0, 0, 0, 3797, 3798, 1, 0, 0, 0, 3798, 3799, 5, 382,
		0, 0, 3799, 3800, 5, 455, 0, 0, 3800, 3801, 3, 440, 220, 0, 3801, 3802,
		3, 96, 48, 0, 3802, 3804, 1, 0, 0, 0, 3803, 3784, 1, 0, 0, 0, 3803, 3796,
		1, 0, 0, 0, 3804, 93, 1, 0, 0, 0, 3805, 3806, 5, 101, 0, 0, 3806, 3810,
		5, 54, 0, 0, 3807, 3808, 5, 221, 0, 0, 3808, 3809, 5, 311, 0, 0, 3809,
		3811, 5, 169, 0, 0, 3810, 3807, 1, 0, 0, 0, 3810, 3811, 1, 0, 0, 0, 3811,
		3812, 1, 0, 0, 0, 3812, 3813, 3, 440, 220, 0, 3813, 3814, 3, 98, 49, 0,
		3814, 3825, 1, 0, 0, 0, 3815, 3816, 5, 101, 0, 0, 3816, 3818, 5, 321, 0,
		0, 3817, 3815, 1, 0, 0, 0, 3817, 3818, 1, 0, 0, 0, 3818, 3819, 1, 0, 0,
		0, 3819, 3820, 5, 382, 0, 0, 3820, 3821, 5, 54, 0, 0, 3821, 3822, 3, 440,
		220, 0, 3822, 3823, 3, 98, 49, 0, 3823, 3825, 1, 0, 0, 0, 3824, 3805, 1,
		0, 0, 0, 3824, 3817, 1, 0, 0, 0, 3825, 95, 1, 0, 0, 0, 3826, 3827, 5, 29,
		0, 0, 3827, 3828, 5, 315, 0, 0, 3828, 3829, 5, 502, 0, 0, 3829, 3831, 5,
		548, 0, 0, 3830, 3826, 1, 0, 0, 0, 3830, 3831, 1, 0, 0, 0, 3831, 3833,
		1, 0, 0, 0, 3832, 3834, 3, 100, 50, 0, 3833, 3832, 1, 0, 0, 0, 3833, 3834,
		1, 0, 0, 0, 3834, 97, 1, 0, 0, 0, 3835, 3836, 5, 29, 0, 0, 3836, 3837,
		5, 315, 0, 0, 3837, 3838, 5, 502, 0, 0, 3838, 3840, 5, 548, 0, 0, 3839,
		3835, 1, 0, 0, 0, 3839, 3840, 1, 0, 0, 0, 3840, 3842, 1, 0, 0, 0, 3841,
		3843, 3, 100, 50, 0, 3842, 3841, 1, 0, 0, 0, 3842, 3843, 1, 0, 0, 0, 3843,
		3845, 1, 0, 0, 0, 3844, 3846, 3, 102, 51, 0, 3845, 3844, 1, 0, 0, 0, 3845,
		3846, 1, 0, 0, 0, 3846, 99, 1, 0, 0, 0, 3847, 3848, 5, 393, 0, 0, 3848,
		3849, 3, 106, 53, 0, 3849, 101, 1, 0, 0, 0, 3850, 3851, 5, 511, 0, 0, 3851,
		3852, 5, 427, 0, 0, 3852, 3853, 5, 394, 0, 0, 3853, 3865, 3, 104, 52, 0,
		3854, 3855, 5, 511, 0, 0, 3855, 3856, 5, 427, 0, 0, 3856, 3857, 5, 394,
		0, 0, 3857, 3865, 3, 106, 53, 0, 3858, 3859, 5, 511, 0, 0, 3859, 3860,
		5, 427, 0, 0, 3860, 3861, 5, 394, 0, 0, 3861, 3862, 3, 104, 52, 0, 3862,
		3863, 3, 106, 53, 0, 3863, 3865, 1, 0, 0, 0, 3864, 3850, 1, 0, 0, 0, 3864,
		3854, 1, 0, 0, 0, 3864, 3858, 1, 0, 0, 0, 3865, 103, 1, 0, 0, 0, 3866,
		3867, 5, 548, 0, 0, 3867, 3868, 5, 428, 0, 0, 3868, 105, 1, 0, 0, 0, 3869,
		3870, 5, 548, 0, 0, 3870, 3871, 7, 22, 0, 0, 3871, 107, 1, 0, 0, 0, 3872,
		3876, 5, 183, 0, 0, 3873, 3874, 5, 16, 0, 0, 3874, 3876, 3, 440, 220, 0,
		3875, 3872, 1, 0, 0, 0, 3875, 3873, 1, 0, 0, 0, 3876, 109, 1, 0, 0, 0,
		3877, 3878, 7, 23, 0, 0, 3878, 3879, 3, 440, 220, 0, 3879, 111, 1, 0, 0,
		0, 3880, 3881, 5, 192, 0, 0, 3881, 3882, 3, 440, 220, 0, 3882, 113, 1,
		0, 0, 0, 3883, 3885, 5, 423, 0, 0, 3884, 3886, 5, 33, 0, 0, 3885, 3884,
		1, 0, 0, 0, 3885, 3886, 1, 0, 0, 0, 3886, 3887, 1, 0, 0, 0, 3887, 3890,
		5, 22, 0, 0, 3888, 3891, 5, 548, 0, 0, 3889, 3891, 3, 324, 162, 0, 3890,
		3888, 1, 0, 0, 0, 3890, 3889, 1, 0, 0, 0, 3890, 3891, 1, 0, 0, 0, 3891,
		3897, 1, 0, 0, 0, 3892, 3893, 5, 509, 0, 0, 3893, 3894, 3, 440, 220, 0,
		3894, 3895, 5, 517, 0, 0, 3895, 3896, 5, 543, 0, 0, 3896, 3898, 1, 0, 0,
		0, 3897, 3892, 1, 0, 0, 0, 3897, 3898, 1, 0, 0, 0, 3898, 4024, 1, 0, 0,
		0, 3899, 3900, 5, 423, 0, 0, 3900, 3901, 5, 363, 0, 0, 3901, 3902, 5, 22,
		0, 0, 3902, 3904, 5, 248, 0, 0, 3903, 3905, 3, 324, 162, 0, 3904, 3903,
		1, 0, 0, 0, 3904, 3905, 1, 0, 0, 0, 3905, 3911, 1, 0, 0, 0, 3906, 3907,
		5, 509, 0, 0, 3907, 3908, 3, 440, 220, 0, 3908, 3909, 5, 517, 0, 0, 3909,
		3910, 5, 543, 0, 0, 3910, 3912, 1, 0, 0, 0, 3911, 3906, 1, 0, 0, 0, 3911,
		3912, 1, 0, 0, 0, 3912, 4024, 1, 0, 0, 0, 3913, 3914, 5, 423, 0, 0, 3914,
		3915, 5, 81, 0, 0, 3915, 3916, 5, 212, 0, 0, 3916, 3917, 3, 324, 162, 0,
		3917, 3918, 3, 302, 151, 0, 3918, 4024, 1, 0, 0, 0, 3919, 3920, 5, 22,
		0, 0, 3920, 3921, 5, 113, 0, 0, 3921, 3926, 3, 324, 162, 0, 3922, 3923,
		5, 511, 0, 0, 3923, 3925, 3, 118, 59, 0, 3924, 3922, 1, 0, 0, 0, 3925,
		3928, 1, 0, 0, 0, 3926, 3924, 1, 0, 0, 0, 3926, 3927, 1, 0, 0, 0, 3927,
		3930, 1, 0, 0, 0, 3928, 3926, 1, 0, 0, 0, 3929, 3931, 3, 312, 156, 0, 3930,
		3929, 1, 0, 0, 0, 3930, 3931, 1, 0, 0, 0, 3931, 4024, 1, 0, 0, 0, 3932,
		3933, 5, 22, 0, 0, 3933, 3934, 5, 450, 0, 0, 3934, 3936, 3, 324, 162, 0,
		3935, 3937, 3, 158, 79, 0, 3936, 3935, 1, 0, 0, 0, 3936, 3937, 1, 0, 0,
		0, 3937, 3939, 1, 0, 0, 0, 3938, 3940, 3, 302, 151, 0, 3939, 3938, 1, 0,
		0, 0, 3939, 3940, 1, 0, 0, 0, 3940, 3945, 1, 0, 0, 0, 3941, 3942, 5, 511,
		0, 0, 3942, 3944, 3, 118, 59, 0, 3943, 3941, 1, 0, 0, 0, 3944, 3947, 1,
		0, 0, 0, 3945, 3943, 1, 0, 0, 0, 3945, 3946, 1, 0, 0, 0, 3946, 3949, 1,
		0, 0, 0, 3947, 3945, 1, 0, 0, 0, 3948, 3950, 3, 312, 156, 0, 3949, 3948,
		1, 0, 0, 0, 3949, 3950, 1, 0, 0, 0, 3950, 4024, 1, 0, 0, 0, 3951, 3952,
		5, 21, 0, 0, 3952, 3953, 5, 450, 0, 0, 3953, 3954, 3, 324, 162, 0, 3954,
		3955, 5, 419, 0, 0, 3955, 3956, 5, 437, 0, 0, 3956, 3957, 5, 2, 0, 0, 3957,
		3958, 3, 314, 157, 0, 3958, 3960, 5, 3, 0, 0, 3959, 3961, 3, 158, 79, 0,
		3960, 3959, 1, 0, 0, 0, 3960, 3961, 1, 0, 0, 0, 3961, 4024, 1, 0, 0, 0,
		3962, 3963, 5, 21, 0, 0, 3963, 3964, 5, 450, 0, 0, 3964, 3967, 3, 324,
		162, 0, 3965, 3966, 5, 226, 0, 0, 3966, 3968, 3, 440, 220, 0, 3967, 3965,
		1, 0, 0, 0, 3967, 3968, 1, 0, 0, 0, 3968, 3969, 1, 0, 0, 0, 3969, 3970,
		5, 298, 0, 0, 3970, 3971, 5, 81, 0, 0, 3971, 3972, 3, 440, 220, 0, 3972,
		3973, 5, 419, 0, 0, 3973, 3974, 5, 437, 0, 0, 3974, 3975, 5, 2, 0, 0, 3975,
		3976, 3, 314, 157, 0, 3976, 3978, 5, 3, 0, 0, 3977, 3979, 3, 158, 79, 0,
		3978, 3977, 1, 0, 0, 0, 3978, 3979, 1, 0, 0, 0, 3979, 4024, 1, 0, 0, 0,
		3980, 3981, 5, 423, 0, 0, 3981, 3982, 5, 226, 0, 0, 3982, 3983, 5, 437,
		0, 0, 3983, 3984, 3, 324, 162, 0, 3984, 3985, 3, 440, 220, 0, 3985, 4024,
		1, 0, 0, 0, 3986, 3987, 5, 147, 0, 0, 3987, 3988, 5, 437, 0, 0, 3988, 3990,
		3, 324, 162, 0, 3989, 3991, 3, 302, 151, 0, 3990, 3989, 1, 0, 0, 0, 3990,
		3991, 1, 0, 0, 0, 3991, 3993, 1, 0, 0, 0, 3992, 3994, 3, 158, 79, 0, 3993,
		3992, 1, 0, 0, 0, 3993, 3994, 1, 0, 0, 0, 3994, 4024, 1, 0, 0, 0, 3995,
		3996, 5, 147, 0, 0, 3996, 3997, 5, 63, 0, 0, 3997, 3998, 5, 437, 0, 0,
		3998, 4024, 3, 324, 162, 0, 3999, 4000, 5, 147, 0, 0, 4000, 4001, 5, 170,
		0, 0, 4001, 4024, 5, 437, 0, 0, 4002, 4003, 5, 254, 0, 0, 4003, 4004, 5,
		22, 0, 0, 4004, 4024, 5, 548, 0, 0, 4005, 4006, 5, 147, 0, 0, 4006, 4007,
		5, 22, 0, 0, 4007, 4008, 5, 247, 0, 0, 4008, 4024, 5, 548, 0, 0, 4009,
		4010, 5, 423, 0, 0, 4010, 4011, 5, 450, 0, 0, 4011, 4012, 5, 437, 0, 0,
		4012, 4014, 3, 324, 162, 0, 4013, 4015, 3, 158, 79, 0, 4014, 4013, 1, 0,
		0, 0, 4014, 4015, 1, 0, 0, 0, 4015, 4017, 1, 0, 0, 0, 4016, 4018, 3, 302,
		151, 0, 4017, 4016, 1, 0, 0, 0, 4017, 4018, 1, 0, 0, 0, 4018, 4024, 1,
		0, 0, 0, 4019, 4020, 5, 423, 0, 0, 4020, 4021, 5, 450, 0, 0, 4021, 4022,
		5, 437, 0, 0, 4022, 4024, 5, 548, 0, 0, 4023, 3883, 1, 0, 0, 0, 4023, 3899,
		1, 0, 0, 0, 4023, 3913, 1, 0, 0, 0, 4023, 3919, 1, 0, 0, 0, 4023, 3932,
		1, 0, 0, 0, 4023, 3951, 1, 0, 0, 0, 4023, 3962, 1, 0, 0, 0, 4023, 3980,
		1, 0, 0, 0, 4023, 3986, 1, 0, 0, 0, 4023, 3995, 1, 0, 0, 0, 4023, 3999,
		1, 0, 0, 0, 4023, 4002, 1, 0, 0, 0, 4023, 4005, 1, 0, 0, 0, 4023, 4009,
		1, 0, 0, 0, 4023, 4019, 1, 0, 0, 0, 4024, 115, 1, 0, 0, 0, 4025, 4026,
		5, 423, 0, 0, 4026, 4028, 5, 81, 0, 0, 4027, 4029, 5, 63, 0, 0, 4028, 4027,
		1, 0, 0, 0, 4028, 4029, 1, 0, 0, 0, 4029, 4030, 1, 0, 0, 0, 4030, 4031,
		5, 437, 0, 0, 4031, 4033, 3, 324, 162, 0, 4032, 4034, 3, 302, 151, 0, 4033,
		4032, 1, 0, 0, 0, 4033, 4034, 1, 0, 0, 0, 4034, 4036, 1, 0, 0, 0, 4035,
		4037, 3, 158, 79, 0, 4036, 4035, 1, 0, 0, 0, 4036, 4037, 1, 0, 0, 0, 4037,
		4044, 1, 0, 0, 0, 4038, 4039, 5, 423, 0, 0, 4039, 4040, 5, 22, 0, 0, 4040,
		4041, 5, 456, 0, 0, 4041, 4042, 5, 438, 0, 0, 4042, 4044, 5, 548, 0, 0,
		4043, 4025, 1, 0, 0, 0, 4043, 4038, 1, 0, 0, 0, 4044, 117, 1, 0, 0, 0,
		4045, 4064, 5, 448, 0, 0, 4046, 4064, 5, 225, 0, 0, 4047, 4064, 5, 195,
		0, 0, 4048, 4064, 5, 431, 0, 0, 4049, 4064, 5, 212, 0, 0, 4050, 4055, 5,
		408, 0, 0, 4051, 4052, 5, 406, 0, 0, 4052, 4056, 5, 548, 0, 0, 4053, 4054,
		5, 338, 0, 0, 4054, 4056, 5, 548, 0, 0, 4055, 4051, 1, 0, 0, 0, 4055, 4053,
		1, 0, 0, 0, 4056, 4064, 1, 0, 0, 0, 4057, 4058, 5, 57, 0, 0, 4058, 4064,
		5, 548, 0, 0, 4059, 4060, 5, 339, 0, 0, 4060, 4064, 5, 548, 0, 0, 4061,
		4062, 5, 103, 0, 0, 4062, 4064, 5, 543, 0, 0, 4063, 4045, 1, 0, 0, 0, 4063,
		4046, 1, 0, 0, 0, 4063, 4047, 1, 0, 0, 0, 4063, 4048, 1, 0, 0, 0, 4063,
		4049, 1, 0, 0, 0, 4063, 4050, 1, 0, 0, 0, 4063, 4057, 1, 0, 0, 0, 4063,
		4059, 1, 0, 0, 0, 4063, 4061, 1, 0, 0, 0, 4064, 119, 1, 0, 0, 0, 4065,
		4070, 3, 122, 61, 0, 4066, 4067, 5, 4, 0, 0, 4067, 4069, 3, 122, 61, 0,
		4068, 4066, 1, 0, 0, 0, 4069, 4072, 1, 0, 0, 0, 4070, 4068, 1, 0, 0, 0,
		4070, 4071, 1, 0, 0, 0, 4071, 121, 1, 0, 0, 0, 4072, 4070, 1, 0, 0, 0,
		4073, 4074, 5, 421, 0, 0, 4074, 4080, 5, 543, 0, 0, 4075, 4077, 3, 440,
		220, 0, 4076, 4078, 5, 543, 0, 0, 4077, 4076, 1, 0, 0, 0, 4077, 4078, 1,
		0, 0, 0, 4078, 4080, 1, 0, 0, 0, 4079, 4073, 1, 0, 0, 0, 4079, 4075, 1,
		0, 0, 0, 4080, 123, 1, 0, 0, 0, 4081, 4086, 3, 126, 63, 0, 4082, 4083,
		5, 4, 0, 0, 4083, 4085, 3, 126, 63, 0, 4084, 4082, 1, 0, 0, 0, 4085, 4088,
		1, 0, 0, 0, 4086, 4084, 1, 0, 0, 0, 4086, 4087, 1, 0, 0, 0, 4087, 125,
		1, 0, 0, 0, 4088, 4086, 1, 0, 0, 0, 4089, 4090, 3, 440, 220, 0, 4090, 4093,
		3, 408, 204, 0, 4091, 4094, 3, 446, 223, 0, 4092, 4094, 5, 543, 0, 0, 4093,
		4091, 1, 0, 0, 0, 4093, 4092, 1, 0, 0, 0, 4094, 127, 1, 0, 0, 0, 4095,
		4097, 7, 24, 0, 0, 4096, 4098, 3, 440, 220, 0, 4097, 4096, 1, 0, 0, 0,
		4097, 4098, 1, 0, 0, 0, 4098, 4099, 1, 0, 0, 0, 4099, 4100, 5, 317, 0,
		0, 4100, 4101, 5, 274, 0, 0, 4101, 4103, 5, 543, 0, 0, 4102, 4104, 3, 312,
		156, 0, 4103, 4102, 1, 0, 0, 0, 4103, 4104, 1, 0, 0, 0, 4104, 129, 1, 0,
		0, 0, 4105, 4108, 5, 333, 0, 0, 4106, 4109, 5, 127, 0, 0, 4107, 4109, 5,
		548, 0, 0, 4108, 4106, 1, 0, 0, 0, 4108, 4107, 1, 0, 0, 0, 4109, 4111,
		1, 0, 0, 0, 4110, 4105, 1, 0, 0, 0, 4110, 4111, 1, 0, 0, 0, 4111, 4120,
		1, 0, 0, 0, 4112, 4118, 5, 332, 0, 0, 4113, 4119, 5, 127, 0, 0, 4114, 4119,
		5, 305, 0, 0, 4115, 4116, 5, 236, 0, 0, 4116, 4117, 5, 548, 0, 0, 4117,
		4119, 7, 25, 0, 0, 4118, 4113, 1, 0, 0, 0, 4118, 4114, 1, 0, 0, 0, 4118,
		4115, 1, 0, 0, 0, 4119, 4121, 1, 0, 0, 0, 4120, 4112, 1, 0, 0, 0, 4120,
		4121, 1, 0, 0, 0, 4121, 4129, 1, 0, 0, 0, 4122, 4123, 5, 335, 0, 0, 4123,
		4127, 5, 236, 0, 0, 4124, 4128, 5, 127, 0, 0, 4125, 4126, 5, 548, 0, 0,
		4126, 4128, 5, 121, 0, 0, 4127, 4124, 1, 0, 0, 0, 4127, 4125, 1, 0, 0,
		0, 4128, 4130, 1, 0, 0, 0, 4129, 4122, 1, 0, 0, 0, 4129, 4130, 1, 0, 0,
		0, 4130, 4133, 1, 0, 0, 0, 4131, 4132, 5, 176, 0, 0, 4132, 4134, 5, 548,
		0, 0, 4133, 4131, 1, 0, 0, 0, 4133, 4134, 1, 0, 0, 0, 4134, 4141, 1, 0,
		0, 0, 4135, 4139, 5, 334, 0, 0, 4136, 4140, 5, 479, 0, 0, 4137, 4138, 5,
		548, 0, 0, 4138, 4140, 7, 25, 0, 0, 4139, 4136, 1, 0, 0, 0, 4139, 4137,
		1, 0, 0, 0, 4140, 4142, 1, 0, 0, 0, 4141, 4135, 1, 0, 0, 0, 4141, 4142,
		1, 0, 0, 0, 4142, 4144, 1, 0, 0, 0, 4143, 4145, 7, 26, 0, 0, 4144, 4143,
		1, 0, 0, 0, 4144, 4145, 1, 0, 0, 0, 4145, 131, 1, 0, 0, 0, 4146, 4153,
		5, 6, 0, 0, 4147, 4153, 3, 134, 67, 0, 4148, 4149, 3, 134, 67, 0, 4149,
		4150, 5, 4, 0, 0, 4150, 4151, 5, 6, 0, 0, 4151, 4153, 1, 0, 0, 0, 4152,
		4146, 1, 0, 0, 0, 4152, 4147, 1, 0, 0, 0, 4152, 4148, 1, 0, 0, 0, 4153,
		133, 1, 0, 0, 0, 4154, 4159, 3, 420, 210, 0, 4155, 4156, 5, 4, 0, 0, 4156,
		4158, 3, 420, 210, 0, 4157, 4155, 1, 0, 0, 0, 4158, 4161, 1, 0, 0, 0, 4159,
		4157, 1, 0, 0, 0, 4159, 4160, 1, 0, 0, 0, 4160, 135, 1, 0, 0, 0, 4161,
		4159, 1, 0, 0, 0, 4162, 4165, 5, 419, 0, 0, 4163, 4166, 3, 138, 69, 0,
		4164, 4166, 3, 140, 70, 0, 4165, 4163, 1, 0, 0, 0, 4165, 4164, 1, 0, 0,
		0, 4166, 4174, 1, 0, 0, 0, 4167, 4170, 5, 4, 0, 0, 4168, 4171, 3, 138,
		69, 0, 4169, 4171, 3, 140, 70, 0, 4170, 4168, 1, 0, 0, 0, 4170, 4169, 1,
		0, 0, 0, 4171, 4173, 1, 0, 0, 0, 4172, 4167, 1, 0, 0, 0, 4173, 4176, 1,
		0, 0, 0, 4174, 4172, 1, 0, 0, 0, 4174, 4175, 1, 0, 0, 0, 4175, 4209, 1,
		0, 0, 0, 4176, 4174, 1, 0, 0, 0, 4177, 4178, 5, 419, 0, 0, 4178, 4179,
		3, 440, 220, 0, 4179, 4180, 5, 29, 0, 0, 4180, 4181, 5, 127, 0, 0, 4181,
		4182, 5, 440, 0, 0, 4182, 4183, 5, 499, 0, 0, 4183, 4209, 1, 0, 0, 0, 4184,
		4185, 5, 419, 0, 0, 4185, 4188, 5, 359, 0, 0, 4186, 4187, 5, 187, 0, 0,
		4187, 4189, 3, 180, 90, 0, 4188, 4186, 1, 0, 0, 0, 4188, 4189, 1, 0, 0,
		0, 4189, 4190, 1, 0, 0, 0, 4190, 4209, 3, 314, 157, 0, 4191, 4193, 5, 419,
		0, 0, 4192, 4194, 3, 168, 84, 0, 4193, 4192, 1, 0, 0, 0, 4193, 4194, 1,
		0, 0, 0, 4194, 4195, 1, 0, 0, 0, 4195, 4206, 5, 469, 0, 0, 4196, 4207,
		3, 144, 72, 0, 4197, 4207, 3, 146, 73, 0, 4198, 4199, 3, 144, 72, 0, 4199,
		4200, 5, 4, 0, 0, 4200, 4201, 3, 146, 73, 0, 4201, 4207, 1, 0, 0, 0, 4202,
		4203, 3, 146, 73, 0, 4203, 4204, 5, 4, 0, 0, 4204, 4205, 3, 144, 72, 0,
		4205, 4207, 1, 0, 0, 0, 4206, 4196, 1, 0, 0, 0, 4206, 4197, 1, 0, 0, 0,
		4206, 4198, 1, 0, 0, 0, 4206, 4202, 1, 0, 0, 0, 4207, 4209, 1, 0, 0, 0,
		4208, 4162, 1, 0, 0, 0, 4208, 4177, 1, 0, 0, 0, 4208, 4184, 1, 0, 0, 0,
		4208, 4191, 1, 0, 0, 0, 4209, 137, 1, 0, 0, 0, 4210, 4211, 3, 168, 84,
		0, 4211, 4212, 3, 440, 220, 0, 4212, 4215, 5, 517, 0, 0, 4213, 4216, 3,
		368, 184, 0, 4214, 4216, 5, 127, 0, 0, 4215, 4213, 1, 0, 0, 0, 4215, 4214,
		1, 0, 0, 0, 4216, 139, 1, 0, 0, 0, 4217, 4218, 5, 302, 0, 0, 4218, 4219,
		5, 517, 0, 0, 4219, 4263, 3, 368, 184, 0, 4220, 4221, 5, 71, 0, 0, 4221,
		4224, 5, 419, 0, 0, 4222, 4224, 5, 72, 0, 0, 4223, 4220, 1, 0, 0, 0, 4223,
		4222, 1, 0, 0, 0, 4224, 4227, 1, 0, 0, 0, 4225, 4228, 3, 180, 90, 0, 4226,
		4228, 5, 127, 0, 0, 4227, 4225, 1, 0, 0, 0, 4227, 4226, 1, 0, 0, 0, 4228,
		4263, 1, 0, 0, 0, 4229, 4232, 5, 302, 0, 0, 4230, 4233, 3, 180, 90, 0,
		4231, 4233, 5, 127, 0, 0, 4232, 4230, 1, 0, 0, 0, 4232, 4231, 1, 0, 0,
		0, 4233, 4237, 1, 0, 0, 0, 4234, 4235, 5, 77, 0, 0, 4235, 4238, 3, 180,
		90, 0, 4236, 4238, 5, 127, 0, 0, 4237, 4234, 1, 0, 0, 0, 4237, 4236, 1,
		0, 0, 0, 4237, 4238, 1, 0, 0, 0, 4238, 4263, 1, 0, 0, 0, 4239, 4242, 5,
		331, 0, 0, 4240, 4241, 5, 187, 0, 0, 4241, 4243, 3, 188, 94, 0, 4242, 4240,
		1, 0, 0, 0, 4242, 4243, 1, 0, 0, 0, 4243, 4244, 1, 0, 0, 0, 4244, 4250,
		5, 517, 0, 0, 4245, 4251, 5, 543, 0, 0, 4246, 4247, 5, 331, 0, 0, 4247,
		4248, 5, 2, 0, 0, 4248, 4249, 5, 543, 0, 0, 4249, 4251, 5, 3, 0, 0, 4250,
		4245, 1, 0, 0, 0, 4250, 4246, 1, 0, 0, 0, 4251, 4263, 1, 0, 0, 0, 4252,
		4253, 5, 261, 0, 0, 4253, 4259, 5, 517, 0, 0, 4254, 4260, 5, 543, 0, 0,
		4255, 4256, 5, 331, 0, 0, 4256, 4257, 5, 2, 0, 0, 4257, 4258, 5, 543, 0,
		0, 4258, 4260, 5, 3, 0, 0, 4259, 4254, 1, 0, 0, 0, 4259, 4255, 1, 0, 0,
		0, 4260, 4263, 1, 0, 0, 0, 4261, 4263, 3, 142, 71, 0, 4262, 4217, 1, 0,
		0, 0, 4262, 4223, 1, 0, 0, 0, 4262, 4229, 1, 0, 0, 0, 4262, 4239, 1, 0,
		0, 0, 4262, 4252, 1, 0, 0, 0, 4262, 4261, 1, 0, 0, 0, 4263, 141, 1, 0,
		0, 0, 4264, 4268, 5, 542, 0, 0, 4265, 4266, 3, 168, 84, 0, 4266, 4267,
		5, 5, 0, 0, 4267, 4269, 1, 0, 0, 0, 4268, 4265, 1, 0, 0, 0, 4268, 4269,
		1, 0, 0, 0, 4269, 4271, 1, 0, 0, 0, 4270, 4264, 1, 0, 0, 0, 4270, 4271,
		1, 0, 0, 0, 4271, 4272, 1, 0, 0, 0, 4272, 4273, 3, 440, 220, 0, 4273, 4276,
		5, 517, 0, 0, 4274, 4277, 3, 368, 184, 0, 4275, 4277, 5, 127, 0, 0, 4276,
		4274, 1, 0, 0, 0, 4276, 4275, 1, 0, 0, 0, 4277, 4284, 1, 0, 0, 0, 4278,
		4279, 5, 541, 0, 0, 4279, 4280, 3, 440, 220, 0, 4280, 4281, 5, 517, 0,
		0, 4281, 4282, 3, 368, 184, 0, 4282, 4284, 1, 0, 0, 0, 4283, 4270, 1, 0,
		0, 0, 4283, 4278, 1, 0, 0, 0, 4284, 143, 1, 0, 0, 0, 4285, 4286, 5, 369,
		0, 0, 4286, 4287, 7, 27, 0, 0, 4287, 145, 1, 0, 0, 0, 4288, 4289, 5, 246,
		0, 0, 4289, 4297, 5, 264, 0, 0, 4290, 4291, 5, 369, 0, 0, 4291, 4298, 5,
		480, 0, 0, 4292, 4293, 5, 369, 0, 0, 4293, 4298, 5, 85, 0, 0, 4294, 4295,
		5, 381, 0, 0, 4295, 4298, 5, 369, 0, 0, 4296, 4298, 5, 416, 0, 0, 4297,
		4290, 1, 0, 0, 0, 4297, 4292, 1, 0, 0, 0, 4297, 4294, 1, 0, 0, 0, 4297,
		4296, 1, 0, 0, 0, 4298, 147, 1, 0, 0, 0, 4299, 4301, 5, 485, 0, 0, 4300,
		4302, 3, 168, 84, 0, 4301, 4300, 1, 0, 0, 0, 4301, 4302, 1, 0, 0, 0, 4302,
		4303, 1, 0, 0, 0, 4303, 4306, 5, 496, 0, 0, 4304, 4307, 5, 20, 0, 0, 4305,
		4307, 3, 440, 220, 0, 4306, 4304, 1, 0, 0, 0, 4306, 4305, 1, 0, 0, 0, 4307,
		4313, 1, 0, 0, 0, 4308, 4309, 5, 485, 0, 0, 4309, 4310, 5, 127, 0, 0, 4310,
		4311, 5, 440, 0, 0, 4311, 4313, 5, 499, 0, 0, 4312, 4299, 1, 0, 0, 0, 4312,
		4308, 1, 0, 0, 0, 4313, 149, 1, 0, 0, 0, 4314, 4315, 5, 447, 0, 0, 4315,
		4335, 3, 440, 220, 0, 4316, 4320, 5, 489, 0, 0, 4317, 4318, 3, 440, 220,
		0, 4318, 4319, 5, 5, 0, 0, 4319, 4321, 1, 0, 0, 0, 4320, 4317, 1, 0, 0,
		0, 4320, 4321, 1, 0, 0, 0, 4321, 4322, 1, 0, 0, 0, 4322, 4335, 3, 440,
		220, 0, 4323, 4330, 5, 489, 0, 0, 4324, 4325, 3, 440, 220, 0, 4325, 4326,
		5, 5, 0, 0, 4326, 4328, 1, 0, 0, 0, 4327, 4324, 1, 0, 0, 0, 4327, 4328,
		1, 0, 0, 0, 4328, 4329, 1, 0, 0, 0, 4329, 4331, 3, 440, 220, 0, 4330, 4327,
		1, 0, 0, 0, 4330, 4331, 1, 0, 0, 0, 4331, 4332, 1, 0, 0, 0, 4332, 4333,
		5, 541, 0, 0, 4333, 4335, 3, 440, 220, 0, 4334, 4314, 1, 0, 0, 0, 4334,
		4316, 1, 0, 0, 0, 4334, 4323, 1, 0, 0, 0, 4335, 151, 1, 0, 0, 0, 4336,
		4339, 5, 541, 0, 0, 4337, 4340, 3, 440, 220, 0, 4338, 4340, 5, 529, 0,
		0, 4339, 4337, 1, 0, 0, 0, 4339, 4338, 1, 0, 0, 0, 4340, 4344, 1, 0, 0,
		0, 4341, 4342, 5, 2, 0, 0, 4342, 4343, 5, 543, 0, 0, 4343, 4345, 5, 3,
		0, 0, 4344, 4341, 1, 0, 0, 0, 4344, 4345, 1, 0, 0, 0, 4345, 153, 1, 0,
		0, 0, 4346, 4347, 3, 194, 97, 0, 4347, 4348, 5, 196, 0, 0, 4348, 4349,
		3, 440, 220, 0, 4349, 4351, 5, 2, 0, 0, 4350, 4352, 3, 314, 157, 0, 4351,
		4350, 1, 0, 0, 0, 4351, 4352, 1, 0, 0, 0, 4352, 4353, 1, 0, 0, 0, 4353,
		4354, 5, 3, 0, 0, 4354, 4355, 3, 322, 161, 0, 4355, 4370, 1, 0, 0, 0, 4356,
		4357, 3, 194, 97, 0, 4357, 4358, 3, 324, 162, 0, 4358, 4359, 5, 20, 0,
		0, 4359, 4370, 1, 0, 0, 0, 4360, 4361, 3, 194, 97, 0, 4361, 4363, 3, 324,
		162, 0, 4362, 4364, 3, 404, 202, 0, 4363, 4362, 1, 0, 0, 0, 4363, 4364,
		1, 0, 0, 0, 4364, 4370, 1, 0, 0, 0, 4365, 4366, 3, 194, 97, 0, 4366, 4367,
		5, 136, 0, 0, 4367, 4368, 3, 324, 162, 0, 4368, 4370, 1, 0, 0, 0, 4369,
		4346, 1, 0, 0, 0, 4369, 4356, 1, 0, 0, 0, 4369, 4360, 1, 0, 0, 0, 4369,
		4365, 1, 0, 0, 0, 4370, 155, 1, 0, 0, 0, 4371, 4372, 5, 353, 0, 0, 4372,
		4373, 5, 252, 0, 0, 4373, 4384, 3, 302, 151, 0, 4374, 4375, 5, 483, 0,
		0, 4375, 4384, 3, 302, 151, 0, 4376, 4377, 5, 188, 0, 0, 4377, 4378, 5,
		252, 0, 0, 4378, 4379, 3, 302, 151, 0, 4379, 4380, 5, 376, 0, 0, 4380,
		4381, 3, 324, 162, 0, 4381, 4382, 3, 302, 151, 0, 4382, 4384, 1, 0, 0,
		0, 4383, 4371, 1, 0, 0, 0, 4383, 4374, 1, 0, 0, 0, 4383, 4376, 1, 0, 0,
		0, 4384, 157, 1, 0, 0, 0, 4385, 4387, 5, 458, 0, 0, 4386, 4385, 1, 0, 0,
		0, 4386, 4387, 1, 0, 0, 0, 4387, 4388, 1, 0, 0, 0, 4388, 4389, 7, 28, 0,
		0, 4389, 4400, 3, 302, 151, 0, 4390, 4392, 5, 458, 0, 0, 4391, 4390, 1,
		0, 0, 0, 4391, 4392, 1, 0, 0, 0, 4392, 4393, 1, 0, 0, 0, 4393, 4394, 5,
		329, 0, 0, 4394, 4400, 3, 436, 218, 0, 4395, 4396, 7, 28, 0, 0, 4396, 4397,
		5, 2, 0, 0, 4397, 4398, 5, 526, 0, 0, 4398, 4400, 5, 3, 0, 0, 4399, 4386,
		1, 0, 0, 0, 4399, 4391, 1, 0, 0, 0, 4399, 4395, 1, 0, 0, 0, 4400, 159,
		1, 0, 0, 0, 4401, 4403, 5, 33, 0, 0, 4402, 4401, 1, 0, 0, 0, 4402, 4403,
		1, 0, 0, 0, 4403, 4404, 1, 0, 0, 0, 4404, 4405, 5, 329, 0, 0, 4405, 4407,
		5, 61, 0, 0, 4406, 4408, 7, 29, 0, 0, 4407, 4406, 1, 0, 0, 0, 4407, 4408,
		1, 0, 0, 0, 4408, 4409, 1, 0, 0, 0, 4409, 4410, 3, 162, 81, 0, 4410, 4412,
		5, 2, 0, 0, 4411, 4413, 3, 338, 169, 0, 4412, 4411, 1, 0, 0, 0, 4412, 4413,
		1, 0, 0, 0, 4413, 4414, 1, 0, 0, 0, 4414, 4415, 5, 3, 0, 0, 4415, 161,
		1, 0, 0, 0, 4416, 4417, 5, 2, 0, 0, 4417, 4422, 3, 164, 82, 0, 4418, 4419,
		5, 4, 0, 0, 4419, 4421, 3, 164, 82, 0, 4420, 4418, 1, 0, 0, 0, 4421, 4424,
		1, 0, 0, 0, 4422, 4420, 1, 0, 0, 0, 4422, 4423, 1, 0, 0, 0, 4423, 4425,
		1, 0, 0, 0, 4424, 4422, 1, 0, 0, 0, 4425, 4426, 5, 3, 0, 0, 4426, 163,
		1, 0, 0, 0, 4427, 4430, 3, 440, 220, 0, 4428, 4430, 3, 388, 194, 0, 4429,
		4427, 1, 0, 0, 0, 4429, 4428, 1, 0, 0, 0, 4430, 165, 1, 0, 0, 0, 4431,
		4433, 5, 511, 0, 0, 4432, 4431, 1, 0, 0, 0, 4432, 4433, 1, 0, 0, 0, 4433,
		4434, 1, 0, 0, 0, 4434, 4436, 3, 202, 101, 0, 4435, 4432, 1, 0, 0, 0, 4435,
		4436, 1, 0, 0, 0, 4436, 4437, 1, 0, 0, 0, 4437, 4438, 5, 112, 0, 0, 4438,
		4439, 5, 228, 0, 0, 4439, 4440, 5, 2, 0, 0, 4440, 4445, 5, 543, 0, 0, 4441,
		4442, 5, 4, 0, 0, 4442, 4444, 5, 543, 0, 0, 4443, 4441, 1, 0, 0, 0, 4444,
		4447, 1, 0, 0, 0, 4445, 4443, 1, 0, 0, 0, 4445, 4446, 1, 0, 0, 0, 4446,
		4448, 1, 0, 0, 0, 4447, 4445, 1, 0, 0, 0, 4448, 4449, 5, 3, 0, 0, 4449,
		4450, 5, 237, 0, 0, 4450, 4451, 5, 450, 0, 0, 4451, 4453, 3, 440, 220,
		0, 4452, 4454, 3, 158, 79, 0, 4453, 4452, 1, 0, 0, 0, 4453, 4454, 1, 0,
		0, 0, 4454, 4459, 1, 0, 0, 0, 4455, 4456, 5, 82, 0, 0, 4456, 4457, 5, 459,
		0, 0, 4457, 4458, 5, 61, 0, 0, 4458, 4460, 5, 543, 0, 0, 4459, 4455, 1,
		0, 0, 0, 4459, 4460, 1, 0, 0, 0, 4460, 4465, 1, 0, 0, 0, 4461, 4462, 5,
		267, 0, 0, 4462, 4463, 5, 459, 0, 0, 4463, 4464, 5, 61, 0, 0, 4464, 4466,
		5, 543, 0, 0, 4465, 4461, 1, 0, 0, 0, 4465, 4466, 1, 0, 0, 0, 4466, 4470,
		1, 0, 0, 0, 4467, 4468, 5, 190, 0, 0, 4468, 4469, 5, 29, 0, 0, 4469, 4471,
		3, 180, 90, 0, 4470, 4467, 1, 0, 0, 0, 4470, 4471, 1, 0, 0, 0, 4471, 4475,
		1, 0, 0, 0, 4472, 4473, 5, 88, 0, 0, 4473, 4474, 5, 29, 0, 0, 4474, 4476,
		3, 180, 90, 0, 4475, 4472, 1, 0, 0, 0, 4475, 4476, 1, 0, 0, 0, 4476, 4478,
		1, 0, 0, 0, 4477, 4479, 3, 302, 151, 0, 4478, 4477, 1, 0, 0, 0, 4478, 4479,
		1, 0, 0, 0, 4479, 4481, 1, 0, 0, 0, 4480, 4482, 3, 210, 105, 0, 4481, 4480,
		1, 0, 0, 0, 4481, 4482, 1, 0, 0, 0, 4482, 4484, 1, 0, 0, 0, 4483, 4485,
		3, 212, 106, 0, 4484, 4483, 1, 0, 0, 0, 4484, 4485, 1, 0, 0, 0, 4485, 4487,
		1, 0, 0, 0, 4486, 4488, 3, 204, 102, 0, 4487, 4486, 1, 0, 0, 0, 4487, 4488,
		1, 0, 0, 0, 4488, 4490, 1, 0, 0, 0, 4489, 4491, 3, 246, 123, 0, 4490, 4489,
		1, 0, 0, 0, 4490, 4491, 1, 0, 0, 0, 4491, 4493, 1, 0, 0, 0, 4492, 4494,
		3, 206, 103, 0, 4493, 4492, 1, 0, 0, 0, 4493, 4494, 1, 0, 0, 0, 4494, 4496,
		1, 0, 0, 0, 4495, 4497, 3, 208, 104, 0, 4496, 4495, 1, 0, 0, 0, 4496, 4497,
		1, 0, 0, 0, 4497, 4499, 1, 0, 0, 0, 4498, 4500, 3, 312, 156, 0, 4499, 4498,
		1, 0, 0, 0, 4499, 4500, 1, 0, 0, 0, 4500, 4531, 1, 0, 0, 0, 4501, 4503,
		5, 511, 0, 0, 4502, 4501, 1, 0, 0, 0, 4502, 4503, 1, 0, 0, 0, 4503, 4504,
		1, 0, 0, 0, 4504, 4506, 3, 202, 101, 0, 4505, 4502, 1, 0, 0, 0, 4505, 4506,
		1, 0, 0, 0, 4506, 4507, 1, 0, 0, 0, 4507, 4508, 5, 112, 0, 0, 4508, 4509,
		5, 192, 0, 0, 4509, 4510, 5, 450, 0, 0, 4510, 4511, 3, 440, 220, 0, 4511,
		4512, 5, 237, 0, 0, 4512, 4513, 5, 450, 0, 0, 4513, 4516, 3, 440, 220,
		0, 4514, 4515, 5, 329, 0, 0, 4515, 4517, 3, 302, 151, 0, 4516, 4514, 1,
		0, 0, 0, 4516, 4517, 1, 0, 0, 0, 4517, 4519, 1, 0, 0, 0, 4518, 4520, 3,
		212, 106, 0, 4519, 4518, 1, 0, 0, 0, 4519, 4520, 1, 0, 0, 0, 4520, 4522,
		1, 0, 0, 0, 4521, 4523, 3, 246, 123, 0, 4522, 4521, 1, 0, 0, 0, 4522, 4523,
		1, 0, 0, 0, 4523, 4525, 1, 0, 0, 0, 4524, 4526, 3, 206, 103, 0, 4525, 4524,
		1, 0, 0, 0, 4525, 4526, 1, 0, 0, 0, 4526, 4528, 1, 0, 0, 0, 4527, 4529,
		3, 312, 156, 0, 4528, 4527, 1, 0, 0, 0, 4528, 4529, 1, 0, 0, 0, 4529, 4531,
		1, 0, 0, 0, 4530, 4435, 1, 0, 0, 0, 4530, 4505, 1, 0, 0, 0, 4531, 167,
		1, 0, 0, 0, 4532, 4533, 7, 30, 0, 0, 4533, 169, 1, 0, 0, 0, 4534, 4535,
		5, 58, 0, 0, 4535, 4536, 7, 31, 0, 0, 4536, 171, 1, 0, 0, 0, 4537, 4538,
		5, 317, 0, 0, 4538, 4545, 5, 278, 0, 0, 4539, 4540, 5, 317, 0, 0, 4540,
		4541, 5, 409, 0, 0, 4541, 4545, 3, 174, 87, 0, 4542, 4543, 5, 317, 0, 0,
		4543, 4545, 5, 84, 0, 0, 4544, 4537, 1, 0, 0, 0, 4544, 4539, 1, 0, 0, 0,
		4544, 4542, 1, 0, 0, 0, 4545, 173, 1, 0, 0, 0, 4546, 4547, 5, 165, 0, 0,
		4547, 4548, 5, 548, 0, 0, 4548, 4551, 3, 440, 220, 0, 4549, 4550, 5, 436,
		0, 0, 4550, 4552, 5, 543, 0, 0, 4551, 4549, 1, 0, 0, 0, 4551, 4552, 1,
		0, 0, 0, 4552, 175, 1, 0, 0, 0, 4553, 4554, 7, 32, 0, 0, 4554, 177, 1,
		0, 0, 0, 4555, 4558, 3, 440, 220, 0, 4556, 4558, 3, 388, 194, 0, 4557,
		4555, 1, 0, 0, 0, 4557, 4556, 1, 0, 0, 0, 4558, 179, 1, 0, 0, 0, 4559,
		4562, 3, 440, 220, 0, 4560, 4562, 5, 543, 0, 0, 4561, 4559, 1, 0, 0, 0,
		4561, 4560, 1, 0, 0, 0, 4562, 181, 1, 0, 0, 0, 4563, 4567, 3, 440, 220,
		0, 4564, 4567, 5, 543, 0, 0, 4565, 4567, 5, 526, 0, 0, 4566, 4563, 1, 0,
		0, 0, 4566, 4564, 1, 0, 0, 0, 4566, 4565, 1, 0, 0, 0, 4567, 183, 1, 0,
		0, 0, 4568, 4573, 3, 186, 93, 0, 4569, 4570, 5, 5, 0, 0, 4570, 4572, 3,
		186, 93, 0, 4571, 4569, 1, 0, 0, 0, 4572, 4575, 1, 0, 0, 0, 4573, 4571,
		1, 0, 0, 0, 4573, 4574, 1, 0, 0, 0, 4574, 185, 1, 0, 0, 0, 4575, 4573,
		1, 0, 0, 0, 4576, 4579, 3, 180, 90, 0, 4577, 4579, 5, 526, 0, 0, 4578,
		4576, 1, 0, 0, 0, 4578, 4577, 1, 0, 0, 0, 4579, 187, 1, 0, 0, 0, 4580,
		4589, 3, 180, 90, 0, 4581, 4587, 5, 541, 0, 0, 4582, 4588, 3, 180, 90,
		0, 4583, 4584, 5, 2, 0, 0, 4584, 4585, 3, 180, 90, 0, 4585, 4586, 5, 3,
		0, 0, 4586, 4588, 1, 0, 0, 0, 4587, 4582, 1, 0, 0, 0, 4587, 4583, 1, 0,
		0, 0, 4588, 4590, 1, 0, 0, 0, 4589, 4581, 1, 0, 0, 0, 4589, 4590, 1, 0,
		0, 0, 4590, 189, 1, 0, 0, 0, 4591, 4598, 3, 188, 94, 0, 4592, 4593, 5,
		220, 0, 0, 4593, 4595, 5, 61, 0, 0, 4594, 4596, 5, 331, 0, 0, 4595, 4594,
		1, 0, 0, 0, 4595, 4596, 1, 0, 0, 0, 4596, 4597, 1, 0, 0, 0, 4597, 4599,
		5, 543, 0, 0, 4598, 4592, 1, 0, 0, 0, 4598, 4599, 1, 0, 0, 0, 4599, 191,
		1, 0, 0, 0, 4600, 4602, 3, 194, 97, 0, 4601, 4603, 3, 196, 98, 0, 4602,
		4601, 1, 0, 0, 0, 4602, 4603, 1, 0, 0, 0, 4603, 4605, 1, 0, 0, 0, 4604,
		4606, 7, 33, 0, 0, 4605, 4604, 1, 0, 0, 0, 4605, 4606, 1, 0, 0, 0, 4606,
		4608, 1, 0, 0, 0, 4607, 4609, 5, 347, 0, 0, 4608, 4607, 1, 0, 0, 0, 4608,
		4609, 1, 0, 0, 0, 4609, 193, 1, 0, 0, 0, 4610, 4611, 7, 34, 0, 0, 4611,
		195, 1, 0, 0, 0, 4612, 4613, 7, 35, 0, 0, 4613, 197, 1, 0, 0, 0, 4614,
		4615, 5, 344, 0, 0, 4615, 4616, 5, 384, 0, 0, 4616, 4617, 3, 200, 100,
		0, 4617, 199, 1, 0, 0, 0, 4618, 4619, 5, 150, 0, 0, 4619, 4623, 3, 226,
		113, 0, 4620, 4621, 5, 345, 0, 0, 4621, 4623, 5, 543, 0, 0, 4622, 4618,
		1, 0, 0, 0, 4622, 4620, 1, 0, 0, 0, 4623, 201, 1, 0, 0, 0, 4624, 4625,
		7, 20, 0, 0, 4625, 203, 1, 0, 0, 0, 4626, 4627, 5, 351, 0, 0, 4627, 4628,
		5, 182, 0, 0, 4628, 4629, 3, 368, 184, 0, 4629, 205, 1, 0, 0, 0, 4630,
		4631, 5, 129, 0, 0, 4631, 4632, 5, 317, 0, 0, 4632, 4633, 3, 368, 184,
		0, 4633, 207, 1, 0, 0, 0, 4634, 4635, 5, 322, 0, 0, 4635, 4636, 5, 61,
		0, 0, 4636, 4637, 3, 440, 220, 0, 4637, 209, 1, 0, 0, 0, 4638, 4639, 5,
		82, 0, 0, 4639, 4640, 5, 192, 0, 0, 4640, 4641, 5, 336, 0, 0, 4641, 4642,
		5, 29, 0, 0, 4642, 4643, 3, 302, 151, 0, 4643, 211, 1, 0, 0, 0, 4644, 4645,
		5, 419, 0, 0, 4645, 4646, 5, 2, 0, 0, 4646, 4651, 3, 214, 107, 0, 4647,
		4648, 5, 4, 0, 0, 4648, 4650, 3, 214, 107, 0, 4649, 4647, 1, 0, 0, 0, 4650,
		4653, 1, 0, 0, 0, 4651, 4649, 1, 0, 0, 0, 4651, 4652, 1, 0, 0, 0, 4652,
		4654, 1, 0, 0, 0, 4653, 4651, 1, 0, 0, 0, 4654, 4655, 5, 3, 0, 0, 4655,
		213, 1, 0, 0, 0, 4656, 4657, 3, 440, 220, 0, 4657, 4658, 5, 517, 0, 0,
		4658, 4659, 3, 368, 184, 0, 4659, 215, 1, 0, 0, 0, 4660, 4689, 3, 218,
		109, 0, 4661, 4662, 5, 511, 0, 0, 4662, 4663, 5, 407, 0, 0, 4663, 4664,
		5, 2, 0, 0, 4664, 4665, 3, 314, 157, 0, 4665, 4666, 5, 3, 0, 0, 4666, 4689,
		1, 0, 0, 0, 4667, 4668, 5, 511, 0, 0, 4668, 4669, 5, 210, 0, 0, 4669, 4670,
		5, 2, 0, 0, 4670, 4671, 3, 314, 157, 0, 4671, 4672, 5, 3, 0, 0, 4672, 4689,
		1, 0, 0, 0, 4673, 4674, 5, 511, 0, 0, 4674, 4675, 5, 271, 0, 0, 4675, 4676,
		5, 2, 0, 0, 4676, 4677, 3, 314, 157, 0, 4677, 4678, 5, 3, 0, 0, 4678, 4689,
		1, 0, 0, 0, 4679, 4680, 5, 511, 0, 0, 4680, 4681, 5, 56, 0, 0, 4681, 4686,
		3, 180, 90, 0, 4682, 4683, 5, 2, 0, 0, 4683, 4684, 3, 314, 157, 0, 4684,
		4685, 5, 3, 0, 0, 4685, 4687, 1, 0, 0, 0, 4686, 4682, 1, 0, 0, 0, 4686,
		4687, 1, 0, 0, 0, 4687, 4689, 1, 0, 0, 0, 4688, 4660, 1, 0, 0, 0, 4688,
		4661, 1, 0, 0, 0, 4688, 4667, 1, 0, 0, 0, 4688, 4673, 1, 0, 0, 0, 4688,
		4679, 1, 0, 0, 0, 4689, 217, 1, 0, 0, 0, 4690, 4691, 5, 511, 0, 0, 4691,
		4692, 5, 388, 0, 0, 4692, 4697, 3, 180, 90, 0, 4693, 4694, 5, 2, 0, 0,
		4694, 4695, 3, 314, 157, 0, 4695, 4696, 5, 3, 0, 0, 4696, 4698, 1, 0, 0,
		0, 4697, 4693, 1, 0, 0, 0, 4697, 4698, 1, 0, 0, 0, 4698, 219, 1, 0, 0,
		0, 4699, 4701, 5, 112, 0, 0, 4700, 4702, 5, 271, 0, 0, 4701, 4700, 1, 0,
		0, 0, 4701, 4702, 1, 0, 0, 0, 4702, 4703, 1, 0, 0, 0, 4703, 4704, 5, 228,
		0, 0, 4704, 4705, 5, 543, 0, 0, 4705, 4706, 5, 237, 0, 0, 4706, 4707, 5,
		450, 0, 0, 4707, 4710, 3, 324, 162, 0, 4708, 4709, 5, 329, 0, 0, 4709,
		4711, 3, 302, 151, 0, 4710, 4708, 1, 0, 0, 0, 4710, 4711, 1, 0, 0, 0, 4711,
		4716, 1, 0, 0, 0, 4712, 4713, 5, 82, 0, 0, 4713, 4714, 5, 459, 0, 0, 4714,
		4715, 5, 61, 0, 0, 4715, 4717, 5, 543, 0, 0, 4716, 4712, 1, 0, 0, 0, 4716,
		4717, 1, 0, 0, 0, 4717, 4722, 1, 0, 0, 0, 4718, 4719, 5, 267, 0, 0, 4719,
		4720, 5, 459, 0, 0, 4720, 4721, 5, 61, 0, 0, 4721, 4723, 5, 543, 0, 0,
		4722, 4718, 1, 0, 0, 0, 4722, 4723, 1, 0, 0, 0, 4723, 4725, 1, 0, 0, 0,
		4724, 4726, 3, 222, 111, 0, 4725, 4724, 1, 0, 0, 0, 4725, 4726, 1, 0, 0,
		0, 4726, 4728, 1, 0, 0, 0, 4727, 4729, 3, 302, 151, 0, 4728, 4727, 1, 0,
		0, 0, 4728, 4729, 1, 0, 0, 0, 4729, 4731, 1, 0, 0, 0, 4730, 4732, 3, 212,
		106, 0, 4731, 4730, 1, 0, 0, 0, 4731, 4732, 1, 0, 0, 0, 4732, 4734, 1,
		0, 0, 0, 4733, 4735, 3, 312, 156, 0, 4734, 4733, 1, 0, 0, 0, 4734, 4735,
		1, 0, 0, 0, 4735, 221, 1, 0, 0, 0, 4736, 4737, 5, 222, 0, 0, 4737, 4738,
		5, 548, 0, 0, 4738, 4743, 5, 267, 0, 0, 4739, 4740, 5, 222, 0, 0, 4740,
		4741, 5, 548, 0, 0, 4741, 4743, 5, 406, 0, 0, 4742, 4736, 1, 0, 0, 0, 4742,
		4739, 1, 0, 0, 0, 4743, 223, 1, 0, 0, 0, 4744, 4745, 5, 237, 0, 0, 4745,
		4746, 5, 324, 0, 0, 4746, 4750, 3, 406, 203, 0, 4747, 4748, 5, 190, 0,
		0, 4748, 4749, 5, 29, 0, 0, 4749, 4751, 3, 440, 220, 0, 4750, 4747, 1,
		0, 0, 0, 4750, 4751, 1, 0, 0, 0, 4751, 4753, 1, 0, 0, 0, 4752, 4754, 3,
		312, 156, 0, 4753, 4752, 1, 0, 0, 0, 4753, 4754, 1, 0, 0, 0, 4754, 225,
		1, 0, 0, 0, 4755, 4757, 3, 236, 118, 0, 4756, 4755, 1, 0, 0, 0, 4756, 4757,
		1, 0, 0, 0, 4757, 4758, 1, 0, 0, 0, 4758, 4759, 3, 228, 114, 0, 4759, 4760,
		3, 288, 144, 0, 4760, 227, 1, 0, 0, 0, 4761, 4762, 6, 114, -1, 0, 4762,
		4763, 3, 232, 116, 0, 4763, 4778, 1, 0, 0, 0, 4764, 4765, 10, 2, 0, 0,
		4765, 4767, 5, 235, 0, 0, 4766, 4768, 3, 230, 115, 0, 4767, 4766, 1, 0,
		0, 0, 4767, 4768, 1, 0, 0, 0, 4768, 4769, 1, 0, 0, 0, 4769, 4777, 3, 228,
		114, 3, 4770, 4771, 10, 1, 0, 0, 4771, 4773, 7, 36, 0, 0, 4772, 4774, 3,
		230, 115, 0, 4773, 4772, 1, 0, 0, 0, 4773, 4774, 1, 0, 0, 0, 4774, 4775,
		1, 0, 0, 0, 4775, 4777, 3, 228, 114, 2, 4776, 4764, 1, 0, 0, 0, 4776, 4770,
		1, 0, 0, 0, 4777, 4780, 1, 0, 0, 0, 4778, 4776, 1, 0, 0, 0, 4778, 4779,
		1, 0, 0, 0, 4779, 229, 1, 0, 0, 0, 4780, 4778, 1, 0, 0, 0, 4781, 4782,
		7, 37, 0, 0, 4782, 231, 1, 0, 0, 0, 4783, 4790, 3, 234, 117, 0, 4784, 4785,
		5, 2, 0, 0, 4785, 4786, 3, 226, 113, 0, 4786, 4787, 5, 3, 0, 0, 4787, 4790,
		1, 0, 0, 0, 4788, 4790, 3, 362, 181, 0, 4789, 4783, 1, 0, 0, 0, 4789, 4784,
		1, 0, 0, 0, 4789, 4788, 1, 0, 0, 0, 4790, 233, 1, 0, 0, 0, 4791, 4793,
		3, 242, 121, 0, 4792, 4794, 3, 250, 125, 0, 4793, 4792, 1, 0, 0, 0, 4793,
		4794, 1, 0, 0, 0, 4794, 4796, 1, 0, 0, 0, 4795, 4797, 3, 248, 124, 0, 4796,
		4795, 1, 0, 0, 0, 4796, 4797, 1, 0, 0, 0, 4797, 4799, 1, 0, 0, 0, 4798,
		4800, 3, 246, 123, 0, 4799, 4798, 1, 0, 0, 0, 4799, 4800, 1, 0, 0, 0, 4800,
		4802, 1, 0, 0, 0, 4801, 4803, 3, 266, 133, 0, 4802, 4801, 1, 0, 0, 0, 4802,
		4803, 1, 0, 0, 0, 4803, 4805, 1, 0, 0, 0, 4804, 4806, 3, 272, 136, 0, 4805,
		4804, 1, 0, 0, 0, 4805, 4806, 1, 0, 0, 0, 4806, 4808, 1, 0, 0, 0, 4807,
		4809, 3, 274, 137, 0, 4808, 4807, 1, 0, 0, 0, 4808, 4809, 1, 0, 0, 0, 4809,
		4813, 1, 0, 0, 0, 4810, 4811, 4, 117, 2, 0, 4811, 4814, 3, 288, 144, 0,
		4812, 4814, 4, 117, 3, 0, 4813, 4810, 1, 0, 0, 0, 4813, 4812, 1, 0, 0,
		0, 4814, 235, 1, 0, 0, 0, 4815, 4816, 5, 511, 0, 0, 4816, 4821, 3, 238,
		119, 0, 4817, 4818, 5, 4, 0, 0, 4818, 4820, 3, 238, 119, 0, 4819, 4817,
		1, 0, 0, 0, 4820, 4823, 1, 0, 0, 0, 4821, 4819, 1, 0, 0, 0, 4821, 4822,
		1, 0, 0, 0, 4822, 237, 1, 0, 0, 0, 4823, 4821, 1, 0, 0, 0, 4824, 4826,
		3, 440, 220, 0, 4825, 4827, 3, 240, 120, 0, 4826, 4825, 1, 0, 0, 0, 4826,
		4827, 1, 0, 0, 0, 4827, 4828, 1, 0, 0, 0, 4828, 4829, 5, 29, 0, 0, 4829,
		4830, 5, 2, 0, 0, 4830, 4831, 3, 226, 113, 0, 4831, 4832, 5, 3, 0, 0, 4832,
		239, 1, 0, 0, 0, 4833, 4834, 5, 2, 0, 0, 4834, 4839, 3, 440, 220, 0, 4835,
		4836, 5, 4, 0, 0, 4836, 4838, 3, 440, 220, 0, 4837, 4835, 1, 0, 0, 0, 4838,
		4841, 1, 0, 0, 0, 4839, 4837, 1, 0, 0, 0, 4839, 4840, 1, 0, 0, 0, 4840,
		4842, 1, 0, 0, 0, 4841, 4839, 1, 0, 0, 0, 4842, 4843, 5, 3, 0, 0, 4843,
		241, 1, 0, 0, 0, 4844, 4846, 5, 414, 0, 0, 4845, 4847, 7, 37, 0, 0, 4846,
		4845, 1, 0, 0, 0, 4846, 4847, 1, 0, 0, 0, 4847, 4848, 1, 0, 0, 0, 4848,
		4849, 3, 244, 122, 0, 4849, 243, 1, 0, 0, 0, 4850, 4851, 3, 366, 183, 0,
		4851, 245, 1, 0, 0, 0, 4852, 4853, 5, 509, 0, 0, 4853, 4854, 3, 372, 186,
		0, 4854, 247, 1, 0, 0, 0, 4855, 4856, 5, 192, 0, 0, 4856, 4857, 3, 256,
		128, 0, 4857, 249, 1, 0, 0, 0, 4858, 4860, 3, 252, 126, 0, 4859, 4858,
		1, 0, 0, 0, 4859, 4860, 1, 0, 0, 0, 4860, 4861, 1, 0, 0, 0, 4861, 4864,
		5, 237, 0, 0, 4862, 4865, 3, 254, 127, 0, 4863, 4865, 3, 440, 220, 0, 4864,
		4862, 1, 0, 0, 0, 4864, 4863, 1, 0, 0, 0, 4865, 4873, 1, 0, 0, 0, 4866,
		4869, 5, 4, 0, 0, 4867, 4870, 3, 254, 127, 0, 4868, 4870, 3, 440, 220,
		0, 4869, 4867, 1, 0, 0, 0, 4869, 4868, 1, 0, 0, 0, 4870, 4872, 1, 0, 0,
		0, 4871, 4866, 1, 0, 0, 0, 4872, 4875, 1, 0, 0, 0, 4873, 4871, 1, 0, 0,
		0, 4873, 4874, 1, 0, 0, 0, 4874, 251, 1, 0, 0, 0, 4875, 4873, 1, 0, 0,
		0, 4876, 4877, 5, 60, 0, 0, 4877, 4878, 5, 79, 0, 0, 4878, 253, 1, 0, 0,
		0, 4879, 4880, 3, 440, 220, 0, 4880, 4881, 5, 2, 0, 0, 4881, 4882, 5, 548,
		0, 0, 4882, 4883, 5, 3, 0, 0, 4883, 255, 1, 0, 0, 0, 4884, 4889, 3, 258,
		129, 0, 4885, 4886, 5, 4, 0, 0, 4886, 4888, 3, 258, 129, 0, 4887, 4885,
		1, 0, 0, 0, 4888, 4891, 1, 0, 0, 0, 4889, 4887, 1, 0, 0, 0, 4889, 4890,
		1, 0, 0, 0, 4890, 257, 1, 0, 0, 0, 4891, 4889, 1, 0, 0, 0, 4892, 4896,
		3, 308, 154, 0, 4893, 4895, 3, 260, 130, 0, 4894, 4893, 1, 0, 0, 0, 4895,
		4898, 1, 0, 0, 0, 4896, 4894, 1, 0, 0, 0, 4896, 4897, 1, 0, 0, 0, 4897,
		259, 1, 0, 0, 0, 4898, 4896, 1, 0, 0, 0, 4899, 4900, 3, 298, 149, 0, 4900,
		4902, 5, 249, 0, 0, 4901, 4903, 3, 262, 131, 0, 4902, 4901, 1, 0, 0, 0,
		4902, 4903, 1, 0, 0, 0, 4903, 4904, 1, 0, 0, 0, 4904, 4906, 3, 308, 154,
		0, 4905, 4907, 3, 300, 150, 0, 4906, 4905, 1, 0, 0, 0, 4906, 4907, 1, 0,
		0, 0, 4907, 261, 1, 0, 0, 0, 4908, 4909, 5, 7, 0, 0, 4909, 4910, 3, 440,
		220, 0, 4910, 4911, 5, 8, 0, 0, 4911, 4917, 1, 0, 0, 0, 4912, 4913, 5,
		538, 0, 0, 4913, 4914, 3, 440, 220, 0, 4914, 4915, 5, 539, 0, 0, 4915,
		4917, 1, 0, 0, 0, 4916, 4908, 1, 0, 0, 0, 4916, 4912, 1, 0, 0, 0, 4917,
		263, 1, 0, 0, 0, 4918, 4919, 5, 7, 0, 0, 4919, 4924, 3, 440, 220, 0, 4920,
		4921, 5, 4, 0, 0, 4921, 4923, 3, 440, 220, 0, 4922, 4920, 1, 0, 0, 0, 4923,
		4926, 1, 0, 0, 0, 4924, 4922, 1, 0, 0, 0, 4924, 4925, 1, 0, 0, 0, 4925,
		4927, 1, 0, 0, 0, 4926, 4924, 1, 0, 0, 0, 4927, 4928, 5, 8, 0, 0, 4928,
		4941, 1, 0, 0, 0, 4929, 4930, 5, 538, 0, 0, 4930, 4935, 3, 440, 220, 0,
		4931, 4932, 5, 4, 0, 0, 4932, 4934, 3, 440, 220, 0, 4933, 4931, 1, 0, 0,
		0, 4934, 4937, 1, 0, 0, 0, 4935, 4933, 1, 0, 0, 0, 4935, 4936, 1, 0, 0,
		0, 4936, 4938, 1, 0, 0, 0, 4937, 4935, 1, 0, 0, 0, 4938, 4939, 5, 539,
		0, 0, 4939, 4941, 1, 0, 0, 0, 4940, 4918, 1, 0, 0, 0, 4940, 4929, 1, 0,
		0, 0, 4941, 265, 1, 0, 0, 0, 4942, 4943, 5, 204, 0, 0, 4943, 4944, 5, 61,
		0, 0, 4944, 4945, 3, 268, 134, 0, 4945, 267, 1, 0, 0, 0, 4946, 4947, 5,
		403, 0, 0, 4947, 4956, 5, 2, 0, 0, 4948, 4953, 3, 368, 184, 0, 4949, 4950,
		5, 4, 0, 0, 4950, 4952, 3, 368, 184, 0, 4951, 4949, 1, 0, 0, 0, 4952, 4955,
		1, 0, 0, 0, 4953, 4951, 1, 0, 0, 0, 4953, 4954, 1, 0, 0, 0, 4954, 4957,
		1, 0, 0, 0, 4955, 4953, 1, 0, 0, 0, 4956, 4948, 1, 0, 0, 0, 4956, 4957,
		1, 0, 0, 0, 4957, 4958, 1, 0, 0, 0, 4958, 4998, 5, 3, 0, 0, 4959, 4960,
		5, 105, 0, 0, 4960, 4969, 5, 2, 0, 0, 4961, 4966, 3, 368, 184, 0, 4962,
		4963, 5, 4, 0, 0, 4963, 4965, 3, 368, 184, 0, 4964, 4962, 1, 0, 0, 0, 4965,
		4968, 1, 0, 0, 0, 4966, 4964, 1, 0, 0, 0, 4966, 4967, 1, 0, 0, 0, 4967,
		4970, 1, 0, 0, 0, 4968, 4966, 1, 0, 0, 0, 4969, 4961, 1, 0, 0, 0, 4969,
		4970, 1, 0, 0, 0, 4970, 4971, 1, 0, 0, 0, 4971, 4998, 5, 3, 0, 0, 4972,
		4973, 5, 205, 0, 0, 4973, 4974, 5, 420, 0, 0, 4974, 4975, 5, 2, 0, 0, 4975,
		4980, 3, 270, 135, 0, 4976, 4977, 5, 4, 0, 0, 4977, 4979, 3, 270, 135,
		0, 4978, 4976, 1, 0, 0, 0, 4979, 4982, 1, 0, 0, 0, 4980, 4978, 1, 0, 0,
		0, 4980, 4981, 1, 0, 0, 0, 4981, 4983, 1, 0, 0, 0, 4982, 4980, 1, 0, 0,
		0, 4983, 4984, 5, 3, 0, 0, 4984, 4998, 1, 0, 0, 0, 4985, 4990, 3, 368,
		184, 0, 4986, 4987, 5, 4, 0, 0, 4987, 4989, 3, 368, 184, 0, 4988, 4986,
		1, 0, 0, 0, 4989, 4992, 1, 0, 0, 0, 4990, 4988, 1, 0, 0, 0, 4990, 4991,
		1, 0, 0, 0, 4991, 4995, 1, 0, 0, 0, 4992, 4990, 1, 0, 0, 0, 4993, 4994,
		5, 511, 0, 0, 4994, 4996, 5, 403, 0, 0, 4995, 4993, 1, 0, 0, 0, 4995, 4996,
		1, 0, 0, 0, 4996, 4998, 1, 0, 0, 0, 4997, 4946, 1, 0, 0, 0, 4997, 4959,
		1, 0, 0, 0, 4997, 4972, 1, 0, 0, 0, 4997, 4985, 1, 0, 0, 0, 4998, 269,
		1, 0, 0, 0, 4999, 5008, 5, 2, 0, 0, 5000, 5005, 3, 368, 184, 0, 5001, 5002,
		5, 4, 0, 0, 5002, 5004, 3, 368, 184, 0, 5003, 5001, 1, 0, 0, 0, 5004, 5007,
		1, 0, 0, 0, 5005, 5003, 1, 0, 0, 0, 5005, 5006, 1, 0, 0, 0, 5006, 5009,
		1, 0, 0, 0, 5007, 5005, 1, 0, 0, 0, 5008, 5000, 1, 0, 0, 0, 5008, 5009,
		1, 0, 0, 0, 5009, 5010, 1, 0, 0, 0, 5010, 5011, 5, 3, 0, 0, 5011, 271,
		1, 0, 0, 0, 5012, 5013, 5, 209, 0, 0, 5013, 5014, 3, 372, 186, 0, 5014,
		273, 1, 0, 0, 0, 5015, 5016, 5, 365, 0, 0, 5016, 5017, 3, 372, 186, 0,
		5017, 275, 1, 0, 0, 0, 5018, 5025, 3, 278, 139, 0, 5019, 5021, 5, 4, 0,
		0, 5020, 5019, 1, 0, 0, 0, 5020, 5021, 1, 0, 0, 0, 5021, 5022, 1, 0, 0,
		0, 5022, 5024, 3, 278, 139, 0, 5023, 5020, 1, 0, 0, 0, 5024, 5027, 1, 0,
		0, 0, 5025, 5023, 1, 0, 0, 0, 5025, 5026, 1, 0, 0, 0, 5026, 5028, 1, 0,
		0, 0, 5027, 5025, 1, 0, 0, 0, 5028, 5029, 5, 539, 0, 0, 5029, 277, 1, 0,
		0, 0, 5030, 5044, 3, 440, 220, 0, 5031, 5032, 5, 2, 0, 0, 5032, 5039, 3,
		280, 140, 0, 5033, 5035, 5, 4, 0, 0, 5034, 5033, 1, 0, 0, 0, 5034, 5035,
		1, 0, 0, 0, 5035, 5036, 1, 0, 0, 0, 5036, 5038, 3, 280, 140, 0, 5037, 5034,
		1, 0, 0, 0, 5038, 5041, 1, 0, 0, 0, 5039, 5037, 1, 0, 0, 0, 5039, 5040,
		1, 0, 0, 0, 5040, 5042, 1, 0, 0, 0, 5041, 5039, 1, 0, 0, 0, 5042, 5043,
		5, 3, 0, 0, 5043, 5045, 1, 0, 0, 0, 5044, 5031, 1, 0, 0, 0, 5044, 5045,
		1, 0, 0, 0, 5045, 5061, 1, 0, 0, 0, 5046, 5058, 7, 38, 0, 0, 5047, 5048,
		5, 2, 0, 0, 5048, 5053, 3, 324, 162, 0, 5049, 5050, 5, 4, 0, 0, 5050, 5052,
		3, 324, 162, 0, 5051, 5049, 1, 0, 0, 0, 5052, 5055, 1, 0, 0, 0, 5053, 5051,
		1, 0, 0, 0, 5053, 5054, 1, 0, 0, 0, 5054, 5056, 1, 0, 0, 0, 5055, 5053,
		1, 0, 0, 0, 5056, 5057, 5, 3, 0, 0, 5057, 5059, 1, 0, 0, 0, 5058, 5047,
		1, 0, 0, 0, 5058, 5059, 1, 0, 0, 0, 5059, 5061, 1, 0, 0, 0, 5060, 5030,
		1, 0, 0, 0, 5060, 5046, 1, 0, 0, 0, 5061, 279, 1, 0, 0, 0, 5062, 5068,
		3, 180, 90, 0, 5063, 5066, 5, 517, 0, 0, 5064, 5067, 3, 406, 203, 0, 5065,
		5067, 3, 440, 220, 0, 5066, 5064, 1, 0, 0, 0, 5066, 5065, 1, 0, 0, 0, 5067,
		5069, 1, 0, 0, 0, 5068, 5063, 1, 0, 0, 0, 5068, 5069, 1, 0, 0, 0, 5069,
		5072, 1, 0, 0, 0, 5070, 5072, 3, 406, 203, 0, 5071, 5062, 1, 0, 0, 0, 5071,
		5070, 1, 0, 0, 0, 5072, 281, 1, 0, 0, 0, 5073, 5074, 3, 324, 162, 0, 5074,
		5077, 5, 517, 0, 0, 5075, 5078, 3, 368, 184, 0, 5076, 5078, 5, 127, 0,
		0, 5077, 5075, 1, 0, 0, 0, 5077, 5076, 1, 0, 0, 0, 5078, 283, 1, 0, 0,
		0, 5079, 5084, 3, 282, 141, 0, 5080, 5081, 5, 4, 0, 0, 5081, 5083, 3, 282,
		141, 0, 5082, 5080, 1, 0, 0, 0, 5083, 5086, 1, 0, 0, 0, 5084, 5082, 1,
		0, 0, 0, 5084, 5085, 1, 0, 0, 0, 5085, 285, 1, 0, 0, 0, 5086, 5084, 1,
		0, 0, 0, 5087, 5088, 5, 259, 0, 0, 5088, 5089, 5, 503, 0, 0, 5089, 5090,
		3, 440, 220, 0, 5090, 5099, 5, 2, 0, 0, 5091, 5096, 3, 368, 184, 0, 5092,
		5093, 5, 4, 0, 0, 5093, 5095, 3, 368, 184, 0, 5094, 5092, 1, 0, 0, 0, 5095,
		5098, 1, 0, 0, 0, 5096, 5094, 1, 0, 0, 0, 5096, 5097, 1, 0, 0, 0, 5097,
		5100, 1, 0, 0, 0, 5098, 5096, 1, 0, 0, 0, 5099, 5091, 1, 0, 0, 0, 5099,
		5100, 1, 0, 0, 0, 5100, 5101, 1, 0, 0, 0, 5101, 5102, 5, 3, 0, 0, 5102,
		5103, 3, 440, 220, 0, 5103, 5104, 5, 29, 0, 0, 5104, 5109, 3, 440, 220,
		0, 5105, 5106, 5, 4, 0, 0, 5106, 5108, 3, 440, 220, 0, 5107, 5105, 1, 0,
		0, 0, 5108, 5111, 1, 0, 0, 0, 5109, 5107, 1, 0, 0, 0, 5109, 5110, 1, 0,
		0, 0, 5110, 287, 1, 0, 0, 0, 5111, 5109, 1, 0, 0, 0, 5112, 5114, 3, 290,
		145, 0, 5113, 5112, 1, 0, 0, 0, 5113, 5114, 1, 0, 0, 0, 5114, 5116, 1,
		0, 0, 0, 5115, 5117, 3, 294, 147, 0, 5116, 5115, 1, 0, 0, 0, 5116, 5117,
		1, 0, 0, 0, 5117, 289, 1, 0, 0, 0, 5118, 5119, 5, 322, 0, 0, 5119, 5120,
		5, 61, 0, 0, 5120, 5125, 3, 292, 146, 0, 5121, 5122, 5, 4, 0, 0, 5122,
		5124, 3, 292, 146, 0, 5123, 5121, 1, 0, 0, 0, 5124, 5127, 1, 0, 0, 0, 5125,
		5123, 1, 0, 0, 0, 5125, 5126, 1, 0, 0, 0, 5126, 291, 1, 0, 0, 0, 5127,
		5125, 1, 0, 0, 0, 5128, 5130, 3, 368, 184, 0, 5129, 5131, 7, 39, 0, 0,
		5130, 5129, 1, 0, 0, 0, 5130, 5131, 1, 0, 0, 0, 5131, 5134, 1, 0, 0, 0,
		5132, 5133, 5, 313, 0, 0, 5133, 5135, 7, 40, 0, 0, 5134, 5132, 1, 0, 0,
		0, 5134, 5135, 1, 0, 0, 0, 5135, 293, 1, 0, 0, 0, 5136, 5137, 5, 266, 0,
		0, 5137, 5147, 5, 548, 0, 0, 5138, 5139, 5, 266, 0, 0, 5139, 5140, 5, 548,
		0, 0, 5140, 5141, 5, 316, 0, 0, 5141, 5147, 5, 548, 0, 0, 5142, 5143, 5,
		266, 0, 0, 5143, 5144, 5, 548, 0, 0, 5144, 5145, 5, 4, 0, 0, 5145, 5147,
		5, 548, 0, 0, 5146, 5136, 1, 0, 0, 0, 5146, 5138, 1, 0, 0, 0, 5146, 5142,
		1, 0, 0, 0, 5147, 295, 1, 0, 0, 0, 5148, 5149, 5, 329, 0, 0, 5149, 5150,
		5, 61, 0, 0, 5150, 5155, 3, 368, 184, 0, 5151, 5152, 5, 4, 0, 0, 5152,
		5154, 3, 368, 184, 0, 5153, 5151, 1, 0, 0, 0, 5154, 5157, 1, 0, 0, 0, 5155,
		5153, 1, 0, 0, 0, 5155, 5156, 1, 0, 0, 0, 5156, 297, 1, 0, 0, 0, 5157,
		5155, 1, 0, 0, 0, 5158, 5160, 5, 229, 0, 0, 5159, 5158, 1, 0, 0, 0, 5159,
		5160, 1, 0, 0, 0, 5160, 5183, 1, 0, 0, 0, 5161, 5183, 5, 104, 0, 0, 5162,
		5164, 5, 262, 0, 0, 5163, 5165, 5, 323, 0, 0, 5164, 5163, 1, 0, 0, 0, 5164,
		5165, 1, 0, 0, 0, 5165, 5183, 1, 0, 0, 0, 5166, 5168, 5, 398, 0, 0, 5167,
		5169, 5, 323, 0, 0, 5168, 5167, 1, 0, 0, 0, 5168, 5169, 1, 0, 0, 0, 5169,
		5183, 1, 0, 0, 0, 5170, 5172, 5, 195, 0, 0, 5171, 5173, 5, 323, 0, 0, 5172,
		5171, 1, 0, 0, 0, 5172, 5173, 1, 0, 0, 0, 5173, 5183, 1, 0, 0, 0, 5174,
		5175, 5, 262, 0, 0, 5175, 5183, 5, 415, 0, 0, 5176, 5177, 5, 398, 0, 0,
		5177, 5183, 5, 415, 0, 0, 5178, 5179, 5, 262, 0, 0, 5179, 5183, 5, 26,
		0, 0, 5180, 5181, 5, 398, 0, 0, 5181, 5183, 5, 26, 0, 0, 5182, 5159, 1,
		0, 0, 0, 5182, 5161, 1, 0, 0, 0, 5182, 5162, 1, 0, 0, 0, 5182, 5166, 1,
		0, 0, 0, 5182, 5170, 1, 0, 0, 0, 5182, 5174, 1, 0, 0, 0, 5182, 5176, 1,
		0, 0, 0, 5182, 5178, 1, 0, 0, 0, 5182, 5180, 1, 0, 0, 0, 5183, 299, 1,
		0, 0, 0, 5184, 5185, 5, 317, 0, 0, 5185, 5189, 3, 372, 186, 0, 5186, 5187,
		5, 492, 0, 0, 5187, 5189, 3, 302, 151, 0, 5188, 5184, 1, 0, 0, 0, 5188,
		5186, 1, 0, 0, 0, 5189, 301, 1, 0, 0, 0, 5190, 5191, 5, 2, 0, 0, 5191,
		5192, 3, 304, 152, 0, 5192, 5193, 5, 3, 0, 0, 5193, 303, 1, 0, 0, 0, 5194,
		5199, 3, 436, 218, 0, 5195, 5196, 5, 4, 0, 0, 5196, 5198, 3, 436, 218,
		0, 5197, 5195, 1, 0, 0, 0, 5198, 5201, 1, 0, 0, 0, 5199, 5197, 1, 0, 0,
		0, 5199, 5200, 1, 0, 0, 0, 5200, 305, 1, 0, 0, 0, 5201, 5199, 1, 0, 0,
		0, 5202, 5203, 5, 541, 0, 0, 5203, 5204, 3, 440, 220, 0, 5204, 5207, 5,
		2, 0, 0, 5205, 5208, 3, 314, 157, 0, 5206, 5208, 3, 304, 152, 0, 5207,
		5205, 1, 0, 0, 0, 5207, 5206, 1, 0, 0, 0, 5207, 5208, 1, 0, 0, 0, 5208,
		5209, 1, 0, 0, 0, 5209, 5210, 5, 3, 0, 0, 5210, 307, 1, 0, 0, 0, 5211,
		5213, 3, 324, 162, 0, 5212, 5214, 3, 306, 153, 0, 5213, 5212, 1, 0, 0,
		0, 5213, 5214, 1, 0, 0, 0, 5214, 5216, 1, 0, 0, 0, 5215, 5217, 3, 310,
		155, 0, 5216, 5215, 1, 0, 0, 0, 5216, 5217, 1, 0, 0, 0, 5217, 5219, 1,
		0, 0, 0, 5218, 5220, 3, 434, 217, 0, 5219, 5218, 1, 0, 0, 0, 5219, 5220,
		1, 0, 0, 0, 5220, 5222, 1, 0, 0, 0, 5221, 5223, 3, 404, 202, 0, 5222, 5221,
		1, 0, 0, 0, 5222, 5223, 1, 0, 0, 0, 5223, 5225, 1, 0, 0, 0, 5224, 5226,
		3, 360, 180, 0, 5225, 5224, 1, 0, 0, 0, 5225, 5226, 1, 0, 0, 0, 5226, 5227,
		1, 0, 0, 0, 5227, 5229, 3, 322, 161, 0, 5228, 5230, 3, 430, 215, 0, 5229,
		5228, 1, 0, 0, 0, 5229, 5230, 1, 0, 0, 0, 5230, 5232, 1, 0, 0, 0, 5231,
		5233, 3, 264, 132, 0, 5232, 5231, 1, 0, 0, 0, 5232, 5233, 1, 0, 0, 0, 5233,
		5237, 1, 0, 0, 0, 5234, 5236, 3, 286, 143, 0, 5235, 5234, 1, 0, 0, 0, 5236,
		5239, 1, 0, 0, 0, 5237, 5235, 1, 0, 0, 0, 5237, 5238, 1, 0, 0, 0, 5238,
		5263, 1, 0, 0, 0, 5239, 5237, 1, 0, 0, 0, 5240, 5241, 5, 2, 0, 0, 5241,
		5242, 3, 226, 113, 0, 5242, 5243, 5, 3, 0, 0, 5243, 5247, 3, 322, 161,
		0, 5244, 5246, 3, 286, 143, 0, 5245, 5244, 1, 0, 0, 0, 5246, 5249, 1, 0,
		0, 0, 5247, 5245, 1, 0, 0, 0, 5247, 5248, 1, 0, 0, 0, 5248, 5263, 1, 0,
		0, 0, 5249, 5247, 1, 0, 0, 0, 5250, 5251, 3, 440, 220, 0, 5251, 5253, 5,
		2, 0, 0, 5252, 5254, 3, 314, 157, 0, 5253, 5252, 1, 0, 0, 0, 5253, 5254,
		1, 0, 0, 0, 5254, 5255, 1, 0, 0, 0, 5255, 5256, 5, 3, 0, 0, 5256, 5257,
		3, 322, 161, 0, 5257, 5263, 1, 0, 0, 0, 5258, 5259, 5, 2, 0, 0, 5259, 5260,
		3, 256, 128, 0, 5260, 5261, 5, 3, 0, 0, 5261, 5263, 1, 0, 0, 0, 5262, 5211,
		1, 0, 0, 0, 5262, 5240, 1, 0, 0, 0, 5262, 5250, 1, 0, 0, 0, 5262, 5258,
		1, 0, 0, 0, 5263, 309, 1, 0, 0, 0, 5264, 5265, 5, 226, 0, 0, 5265, 5266,
		3, 440, 220, 0, 5266, 311, 1, 0, 0, 0, 5267, 5268, 5, 358, 0, 0, 5268,
		5269, 5, 2, 0, 0, 5269, 5270, 3, 314, 157, 0, 5270, 5271, 5, 3, 0, 0, 5271,
		313, 1, 0, 0, 0, 5272, 5277, 3, 316, 158, 0, 5273, 5274, 5, 4, 0, 0, 5274,
		5276, 3, 316, 158, 0, 5275, 5273, 1, 0, 0, 0, 5276, 5279, 1, 0, 0, 0, 5277,
		5275, 1, 0, 0, 0, 5277, 5278, 1, 0, 0, 0, 5278, 315, 1, 0, 0, 0, 5279,
		5277, 1, 0, 0, 0, 5280, 5281, 3, 318, 159, 0, 5281, 5282, 5, 517, 0, 0,
		5282, 5283, 3, 320, 160, 0, 5283, 317, 1, 0, 0, 0, 5284, 5287, 3, 440,
		220, 0, 5285, 5287, 3, 406, 203, 0, 5286, 5284, 1, 0, 0, 0, 5286, 5285,
		1, 0, 0, 0, 5287, 319, 1, 0, 0, 0, 5288, 5291, 3, 440, 220, 0, 5289, 5291,
		3, 406, 203, 0, 5290, 5288, 1, 0, 0, 0, 5290, 5289, 1, 0, 0, 0, 5291, 321,
		1, 0, 0, 0, 5292, 5294, 5, 29, 0, 0, 5293, 5292, 1, 0, 0, 0, 5293, 5294,
		1, 0, 0, 0, 5294, 5295, 1, 0, 0, 0, 5295, 5297, 3, 442, 221, 0, 5296, 5298,
		3, 302, 151, 0, 5297, 5296, 1, 0, 0, 0, 5297, 5298, 1, 0, 0, 0, 5298, 5300,
		1, 0, 0, 0, 5299, 5293, 1, 0, 0, 0, 5299, 5300, 1, 0, 0, 0, 5300, 323,
		1, 0, 0, 0, 5301, 5306, 3, 436, 218, 0, 5302, 5303, 5, 5, 0, 0, 5303, 5305,
		3, 436, 218, 0, 5304, 5302, 1, 0, 0, 0, 5305, 5308, 1, 0, 0, 0, 5306, 5304,
		1, 0, 0, 0, 5306, 5307, 1, 0, 0, 0, 5307, 325, 1, 0, 0, 0, 5308, 5306,
		1, 0, 0, 0, 5309, 5314, 3, 328, 164, 0, 5310, 5311, 5, 4, 0, 0, 5311, 5313,
		3, 328, 164, 0, 5312, 5310, 1, 0, 0, 0, 5313, 5316, 1, 0, 0, 0, 5314, 5312,
		1, 0, 0, 0, 5314, 5315, 1, 0, 0, 0, 5315, 327, 1, 0, 0, 0, 5316, 5314,
		1, 0, 0, 0, 5317, 5320, 3, 440, 220, 0, 5318, 5319, 5, 83, 0, 0, 5319,
		5321, 5, 543, 0, 0, 5320, 5318, 1, 0, 0, 0, 5320, 5321, 1, 0, 0, 0, 5321,
		329, 1, 0, 0, 0, 5322, 5327, 3, 332, 166, 0, 5323, 5324, 5, 4, 0, 0, 5324,
		5326, 3, 332, 166, 0, 5325, 5323, 1, 0, 0, 0, 5326, 5329, 1, 0, 0, 0, 5327,
		5325, 1, 0, 0, 0, 5327, 5328, 1, 0, 0, 0, 5328, 331, 1, 0, 0, 0, 5329,
		5327, 1, 0, 0, 0, 5330, 5331, 3, 440, 220, 0, 5331, 5333, 3, 420, 210,
		0, 5332, 5334, 5, 252, 0, 0, 5333, 5332, 1, 0, 0, 0, 5333, 5334, 1, 0,
		0, 0, 5334, 5336, 1, 0, 0, 0, 5335, 5337, 3, 358, 179, 0, 5336, 5335, 1,
		0, 0, 0, 5336, 5337, 1, 0, 0, 0, 5337, 5347, 1, 0, 0, 0, 5338, 5339, 5,
		198, 0, 0, 5339, 5341, 5, 35, 0, 0, 5340, 5338, 1, 0, 0, 0, 5340, 5341,
		1, 0, 0, 0, 5341, 5342, 1, 0, 0, 0, 5342, 5343, 5, 29, 0, 0, 5343, 5344,
		5, 2, 0, 0, 5344, 5345, 3, 368, 184, 0, 5345, 5346, 5, 3, 0, 0, 5346, 5348,
		1, 0, 0, 0, 5347, 5340, 1, 0, 0, 0, 5347, 5348, 1, 0, 0, 0, 5348, 5353,
		1, 0, 0, 0, 5349, 5351, 5, 311, 0, 0, 5350, 5349, 1, 0, 0, 0, 5350, 5351,
		1, 0, 0, 0, 5351, 5352, 1, 0, 0, 0, 5352, 5354, 5, 312, 0, 0, 5353, 5350,
		1, 0, 0, 0, 5353, 5354, 1, 0, 0, 0, 5354, 5362, 1, 0, 0, 0, 5355, 5360,
		5, 34, 0, 0, 5356, 5357, 5, 2, 0, 0, 5357, 5358, 3, 446, 223, 0, 5358,
		5359, 5, 3, 0, 0, 5359, 5361, 1, 0, 0, 0, 5360, 5356, 1, 0, 0, 0, 5360,
		5361, 1, 0, 0, 0, 5361, 5363, 1, 0, 0, 0, 5362, 5355, 1, 0, 0, 0, 5362,
		5363, 1, 0, 0, 0, 5363, 5388, 1, 0, 0, 0, 5364, 5386, 5, 127, 0, 0, 5365,
		5387, 5, 312, 0, 0, 5366, 5368, 5, 525, 0, 0, 5367, 5366, 1, 0, 0, 0, 5367,
		5368, 1, 0, 0, 0, 5368, 5369, 1, 0, 0, 0, 5369, 5387, 5, 548, 0, 0, 5370,
		5372, 5, 525, 0, 0, 5371, 5370, 1, 0, 0, 0, 5371, 5372, 1, 0, 0, 0, 5372,
		5373, 1, 0, 0, 0, 5373, 5387, 5, 550, 0, 0, 5374, 5387, 5, 342, 0, 0, 5375,
		5387, 5, 153, 0, 0, 5376, 5387, 5, 48, 0, 0, 5377, 5387, 5, 543, 0, 0,
		5378, 5387, 5, 108, 0, 0, 5379, 5384, 5, 110, 0, 0, 5380, 5381, 5, 2, 0,
		0, 5381, 5382, 3, 446, 223, 0, 5382, 5383, 5, 3, 0, 0, 5383, 5385, 1, 0,
		0, 0, 5384, 5380, 1, 0, 0, 0, 5384, 5385, 1, 0, 0, 0, 5385, 5387, 1, 0,
		0, 0, 5386, 5365, 1, 0, 0, 0, 5386, 5367, 1, 0, 0, 0, 5386, 5371, 1, 0,
		0, 0, 5386, 5374, 1, 0, 0, 0, 5386, 5375, 1, 0, 0, 0, 5386, 5376, 1, 0,
		0, 0, 5386, 5377, 1, 0, 0, 0, 5386, 5378, 1, 0, 0, 0, 5386, 5379, 1, 0,
		0, 0, 5387, 5389, 1, 0, 0, 0, 5388, 5364, 1, 0, 0, 0, 5388, 5389, 1, 0,
		0, 0, 5389, 5399, 1, 0, 0, 0, 5390, 5391, 5, 317, 0, 0, 5391, 5392, 5,
		488, 0, 0, 5392, 5397, 5, 110, 0, 0, 5393, 5394, 5, 2, 0, 0, 5394, 5395,
		3, 446, 223, 0, 5395, 5396, 5, 3, 0, 0, 5396, 5398, 1, 0, 0, 0, 5397, 5393,
		1, 0, 0, 0, 5397, 5398, 1, 0, 0, 0, 5398, 5400, 1, 0, 0, 0, 5399, 5390,
		1, 0, 0, 0, 5399, 5400, 1, 0, 0, 0, 5400, 5403, 1, 0, 0, 0, 5401, 5402,
		5, 83, 0, 0, 5402, 5404, 5, 543, 0, 0, 5403, 5401, 1, 0, 0, 0, 5403, 5404,
		1, 0, 0, 0, 5404, 333, 1, 0, 0, 0, 5405, 5410, 3, 336, 168, 0, 5406, 5407,
		5, 4, 0, 0, 5407, 5409, 3, 336, 168, 0, 5408, 5406, 1, 0, 0, 0, 5409, 5412,
		1, 0, 0, 0, 5410, 5408, 1, 0, 0, 0, 5410, 5411, 1, 0, 0, 0, 5411, 335,
		1, 0, 0, 0, 5412, 5410, 1, 0, 0, 0, 5413, 5417, 5, 226, 0, 0, 5414, 5415,
		5, 221, 0, 0, 5415, 5416, 5, 311, 0, 0, 5416, 5418, 5, 169, 0, 0, 5417,
		5414, 1, 0, 0, 0, 5417, 5418, 1, 0, 0, 0, 5418, 5419, 1, 0, 0, 0, 5419,
		5420, 3, 440, 220, 0, 5420, 5423, 3, 302, 151, 0, 5421, 5422, 5, 492, 0,
		0, 5422, 5424, 7, 8, 0, 0, 5423, 5421, 1, 0, 0, 0, 5423, 5424, 1, 0, 0,
		0, 5424, 5430, 1, 0, 0, 0, 5425, 5426, 5, 358, 0, 0, 5426, 5427, 5, 2,
		0, 0, 5427, 5428, 3, 314, 157, 0, 5428, 5429, 5, 3, 0, 0, 5429, 5431, 1,
		0, 0, 0, 5430, 5425, 1, 0, 0, 0, 5430, 5431, 1, 0, 0, 0, 5431, 5434, 1,
		0, 0, 0, 5432, 5433, 5, 83, 0, 0, 5433, 5435, 5, 543, 0, 0, 5434, 5432,
		1, 0, 0, 0, 5434, 5435, 1, 0, 0, 0, 5435, 337, 1, 0, 0, 0, 5436, 5441,
		3, 340, 170, 0, 5437, 5438, 5, 4, 0, 0, 5438, 5440, 3, 340, 170, 0, 5439,
		5437, 1, 0, 0, 0, 5440, 5443, 1, 0, 0, 0, 5441, 5439, 1, 0, 0, 0, 5441,
		5442, 1, 0, 0, 0, 5442, 339, 1, 0, 0, 0, 5443, 5441, 1, 0, 0, 0, 5444,
		5449, 3, 342, 171, 0, 5445, 5449, 3, 344, 172, 0, 5446, 5449, 3, 346, 173,
		0, 5447, 5449, 3, 348, 174, 0, 5448, 5444, 1, 0, 0, 0, 5448, 5445, 1, 0,
		0, 0, 5448, 5446, 1, 0, 0, 0, 5448, 5447, 1, 0, 0, 0, 5449, 5454, 1, 0,
		0, 0, 5450, 5451, 5, 2, 0, 0, 5451, 5452, 3, 314, 157, 0, 5452, 5453, 5,
		3, 0, 0, 5453, 5455, 1, 0, 0, 0, 5454, 5450, 1, 0, 0, 0, 5454, 5455, 1,
		0, 0, 0, 5455, 341, 1, 0, 0, 0, 5456, 5460, 5, 329, 0, 0, 5457, 5458, 5,
		221, 0, 0, 5458, 5459, 5, 311, 0, 0, 5459, 5461, 5, 169, 0, 0, 5460, 5457,
		1, 0, 0, 0, 5460, 5461, 1, 0, 0, 0, 5461, 5462, 1, 0, 0, 0, 5462, 5463,
		3, 440, 220, 0, 5463, 5464, 5, 494, 0, 0, 5464, 5465, 5, 263, 0, 0, 5465,
		5468, 5, 461, 0, 0, 5466, 5469, 5, 289, 0, 0, 5467, 5469, 3, 350, 175,
		0, 5468, 5466, 1, 0, 0, 0, 5468, 5467, 1, 0, 0, 0, 5469, 343, 1, 0, 0,
		0, 5470, 5474, 5, 329, 0, 0, 5471, 5472, 5, 221, 0, 0, 5472, 5473, 5, 311,
		0, 0, 5473, 5475, 5, 169, 0, 0, 5474, 5471, 1, 0, 0, 0, 5474, 5475, 1,
		0, 0, 0, 5475, 5476, 1, 0, 0, 0, 5476, 5477, 3, 440, 220, 0, 5477, 5478,
		5, 494, 0, 0, 5478, 5479, 5, 7, 0, 0, 5479, 5480, 3, 350, 175, 0, 5480,
		5481, 5, 4, 0, 0, 5481, 5482, 3, 350, 175, 0, 5482, 5483, 5, 3, 0, 0, 5483,
		345, 1, 0, 0, 0, 5484, 5485, 5, 192, 0, 0, 5485, 5486, 3, 350, 175, 0,
		5486, 5487, 5, 466, 0, 0, 5487, 5488, 3, 350, 175, 0, 5488, 5489, 5, 236,
		0, 0, 5489, 5491, 5, 548, 0, 0, 5490, 5492, 3, 416, 208, 0, 5491, 5490,
		1, 0, 0, 0, 5491, 5492, 1, 0, 0, 0, 5492, 347, 1, 0, 0, 0, 5493, 5497,
		5, 329, 0, 0, 5494, 5495, 5, 221, 0, 0, 5495, 5496, 5, 311, 0, 0, 5496,
		5498, 5, 169, 0, 0, 5497, 5494, 1, 0, 0, 0, 5497, 5498, 1, 0, 0, 0, 5498,
		5499, 1, 0, 0, 0, 5499, 5516, 3, 440, 220, 0, 5500, 5501, 5, 494, 0, 0,
		5501, 5514, 5, 224, 0, 0, 5502, 5503, 5, 2, 0, 0, 5503, 5508, 3, 350, 175,
		0, 5504, 5505, 5, 4, 0, 0, 5505, 5507, 3, 350, 175, 0, 5506, 5504, 1, 0,
		0, 0, 5507, 5510, 1, 0, 0, 0, 5508, 5506, 1, 0, 0, 0, 5508, 5509, 1, 0,
		0, 0, 5509, 5511, 1, 0, 0, 0, 5510, 5508, 1, 0, 0, 0, 5511, 5512, 5, 3,
		0, 0, 5512, 5515, 1, 0, 0, 0, 5513, 5515, 3, 350, 175, 0, 5514, 5502, 1,
		0, 0, 0, 5514, 5513, 1, 0, 0, 0, 5515, 5517, 1, 0, 0, 0, 5516, 5500, 1,
		0, 0, 0, 5516, 5517, 1, 0, 0, 0, 5517, 349, 1, 0, 0, 0, 5518, 5519, 5,
		2, 0, 0, 5519, 5524, 3, 352, 176, 0, 5520, 5521, 5, 4, 0, 0, 5521, 5523,
		3, 352, 176, 0, 5522, 5520, 1, 0, 0, 0, 5523, 5526, 1, 0, 0, 0, 5524, 5522,
		1, 0, 0, 0, 5524, 5525, 1, 0, 0, 0, 5525, 5527, 1, 0, 0, 0, 5526, 5524,
		1, 0, 0, 0, 5527, 5528, 5, 3, 0, 0, 5528, 351, 1, 0, 0, 0, 5529, 5531,
		5, 525, 0, 0, 5530, 5529, 1, 0, 0, 0, 5530, 5531, 1, 0, 0, 0, 5531, 5532,
		1, 0, 0, 0, 5532, 5537, 5, 548, 0, 0, 5533, 5537, 5, 543, 0, 0, 5534, 5537,
		5, 289, 0, 0, 5535, 5537, 5, 312, 0, 0, 5536, 5530, 1, 0, 0, 0, 5536, 5533,
		1, 0, 0, 0, 5536, 5534, 1, 0, 0, 0, 5536, 5535, 1, 0, 0, 0, 5537, 353,
		1, 0, 0, 0, 5538, 5543, 3, 356, 178, 0, 5539, 5540, 5, 4, 0, 0, 5540, 5542,
		3, 356, 178, 0, 5541, 5539, 1, 0, 0, 0, 5542, 5545, 1, 0, 0, 0, 5543, 5541,
		1, 0, 0, 0, 5543, 5544, 1, 0, 0, 0, 5544, 355, 1, 0, 0, 0, 5545, 5543,
		1, 0, 0, 0, 5546, 5547, 3, 440, 220, 0, 5547, 5551, 3, 302, 151, 0, 5548,
		5549, 5, 151, 0, 0, 5549, 5550, 5, 252, 0, 0, 5550, 5552, 3, 302, 151,
		0, 5551, 5548, 1, 0, 0, 0, 5551, 5552, 1, 0, 0, 0, 5552, 5554, 1, 0, 0,
		0, 5553, 5555, 3, 312, 156, 0, 5554, 5553, 1, 0, 0, 0, 5554, 5555, 1, 0,
		0, 0, 5555, 357, 1, 0, 0, 0, 5556, 5557, 7, 41, 0, 0, 5557, 359, 1, 0,
		0, 0, 5558, 5559, 5, 453, 0, 0, 5559, 5560, 5, 2, 0, 0, 5560, 5565, 5,
		548, 0, 0, 5561, 5562, 5, 4, 0, 0, 5562, 5564, 5, 548, 0, 0, 5563, 5561,
		1, 0, 0, 0, 5564, 5567, 1, 0, 0, 0, 5565, 5563, 1, 0, 0, 0, 5565, 5566,
		1, 0, 0, 0, 5566, 5568, 1, 0, 0, 0, 5567, 5565, 1, 0, 0, 0, 5568, 5569,
		5, 3, 0, 0, 5569, 361, 1, 0, 0, 0, 5570, 5571, 5, 494, 0, 0, 5571, 5576,
		3, 374, 187, 0, 5572, 5573, 5, 4, 0, 0, 5573, 5575, 3, 374, 187, 0, 5574,
		5572, 1, 0, 0, 0, 5575, 5578, 1, 0, 0, 0, 5576, 5574, 1, 0, 0, 0, 5576,
		5577, 1, 0, 0, 0, 5577, 363, 1, 0, 0, 0, 5578, 5576, 1, 0, 0, 0, 5579,
		5584, 3, 368, 184, 0, 5580, 5582, 5, 29, 0, 0, 5581, 5580, 1, 0, 0, 0,
		5581, 5582, 1, 0, 0, 0, 5582, 5583, 1, 0, 0, 0, 5583, 5585, 3, 180, 90,
		0, 5584, 5581, 1, 0, 0, 0, 5584, 5585, 1, 0, 0, 0, 5585, 365, 1, 0, 0,
		0, 5586, 5591, 3, 364, 182, 0, 5587, 5588, 5, 4, 0, 0, 5588, 5590, 3, 364,
		182, 0, 5589, 5587, 1, 0, 0, 0, 5590, 5593, 1, 0, 0, 0, 5591, 5589, 1,
		0, 0, 0, 5591, 5592, 1, 0, 0, 0, 5592, 367, 1, 0, 0, 0, 5593, 5591, 1,
		0, 0, 0, 5594, 5597, 3, 372, 186, 0, 5595, 5597, 3, 370, 185, 0, 5596,
		5594, 1, 0, 0, 0, 5596, 5595, 1, 0, 0, 0, 5597, 369, 1, 0, 0, 0, 5598,
		5599, 3, 436, 218, 0, 5599, 5600, 5, 537, 0, 0, 5600, 5601, 3, 372, 186,
		0, 5601, 5615, 1, 0, 0, 0, 5602, 5603, 5, 2, 0, 0, 5603, 5606, 3, 436,
		218, 0, 5604, 5605, 5, 4, 0, 0, 5605, 5607, 3, 436, 218, 0, 5606, 5604,
		1, 0, 0, 0, 5607, 5608, 1, 0, 0, 0, 5608, 5606, 1, 0, 0, 0, 5608, 5609,
		1, 0, 0, 0, 5609, 5610, 1, 0, 0, 0, 5610, 5611, 5, 3, 0, 0, 5611, 5612,
		5, 537, 0, 0, 5612, 5613, 3, 372, 186, 0, 5613, 5615, 1, 0, 0, 0, 5614,
		5598, 1, 0, 0, 0, 5614, 5602, 1, 0, 0, 0, 5615, 371, 1, 0, 0, 0, 5616,
		5617, 6, 186, -1, 0, 5617, 5618, 5, 532, 0, 0, 5618, 5641, 3, 372, 186,
		10, 5619, 5620, 5, 169, 0, 0, 5620, 5621, 5, 2, 0, 0, 5621, 5622, 3, 226,
		113, 0, 5622, 5623, 5, 3, 0, 0, 5623, 5641, 1, 0, 0, 0, 5624, 5625, 7,
		42, 0, 0, 5625, 5626, 5, 2, 0, 0, 5626, 5627, 3, 380, 190, 0, 5627, 5628,
		5, 3, 0, 0, 5628, 5641, 1, 0, 0, 0, 5629, 5630, 5, 243, 0, 0, 5630, 5631,
		5, 2, 0, 0, 5631, 5632, 3, 380, 190, 0, 5632, 5633, 5, 3, 0, 0, 5633, 5641,
		1, 0, 0, 0, 5634, 5636, 3, 380, 190, 0, 5635, 5637, 3, 378, 189, 0, 5636,
		5635, 1, 0, 0, 0, 5636, 5637, 1, 0, 0, 0, 5637, 5641, 1, 0, 0, 0, 5638,
		5639, 5, 311, 0, 0, 5639, 5641, 3, 372, 186, 5, 5640, 5616, 1, 0, 0, 0,
		5640, 5619, 1, 0, 0, 0, 5640, 5624, 1, 0, 0, 0, 5640, 5629, 1, 0, 0, 0,
		5640, 5634, 1, 0, 0, 0, 5640, 5638, 1, 0, 0, 0, 5641, 5656, 1, 0, 0, 0,
		5642, 5643, 10, 4, 0, 0, 5643, 5644, 7, 43, 0, 0, 5644, 5655, 3, 372, 186,
		5, 5645, 5646, 10, 3, 0, 0, 5646, 5647, 5, 515, 0, 0, 5647, 5655, 3, 372,
		186, 4, 5648, 5649, 10, 2, 0, 0, 5649, 5650, 5, 321, 0, 0, 5650, 5655,
		3, 372, 186, 3, 5651, 5652, 10, 1, 0, 0, 5652, 5653, 5, 534, 0, 0, 5653,
		5655, 3, 372, 186, 2, 5654, 5642, 1, 0, 0, 0, 5654, 5645, 1, 0, 0, 0, 5654,
		5648, 1, 0, 0, 0, 5654, 5651, 1, 0, 0, 0, 5655, 5658, 1, 0, 0, 0, 5656,
		5654, 1, 0, 0, 0, 5656, 5657, 1, 0, 0, 0, 5657, 373, 1, 0, 0, 0, 5658,
		5656, 1, 0, 0, 0, 5659, 5668, 5, 2, 0, 0, 5660, 5665, 3, 376, 188, 0, 5661,
		5662, 5, 4, 0, 0, 5662, 5664, 3, 376, 188, 0, 5663, 5661, 1, 0, 0, 0, 5664,
		5667, 1, 0, 0, 0, 5665, 5663, 1, 0, 0, 0, 5665, 5666, 1, 0, 0, 0, 5666,
		5669, 1, 0, 0, 0, 5667, 5665, 1, 0, 0, 0, 5668, 5660, 1, 0, 0, 0, 5668,
		5669, 1, 0, 0, 0, 5669, 5670, 1, 0, 0, 0, 5670, 5671, 5, 3, 0, 0, 5671,
		375, 1, 0, 0, 0, 5672, 5676, 3, 406, 203, 0, 5673, 5676, 5, 127, 0, 0,
		5674, 5676, 3, 364, 182, 0, 5675, 5672, 1, 0, 0, 0, 5675, 5673, 1, 0, 0,
		0, 5675, 5674, 1, 0, 0, 0, 5676, 377, 1, 0, 0, 0, 5677, 5679, 5, 311, 0,
		0, 5678, 5677, 1, 0, 0, 0, 5678, 5679, 1, 0, 0, 0, 5679, 5680, 1, 0, 0,
		0, 5680, 5681, 5, 41, 0, 0, 5681, 5682, 3, 380, 190, 0, 5682, 5683, 5,
		25, 0, 0, 5683, 5684, 3, 380, 190, 0, 5684, 5729, 1, 0, 0, 0, 5685, 5687,
		5, 311, 0, 0, 5686, 5685, 1, 0, 0, 0, 5686, 5687, 1, 0, 0, 0, 5687, 5688,
		1, 0, 0, 0, 5688, 5689, 7, 44, 0, 0, 5689, 5729, 3, 380, 190, 0, 5690,
		5692, 5, 311, 0, 0, 5691, 5690, 1, 0, 0, 0, 5691, 5692, 1, 0, 0, 0, 5692,
		5693, 1, 0, 0, 0, 5693, 5694, 7, 45, 0, 0, 5694, 5729, 3, 380, 190, 0,
		5695, 5697, 5, 311, 0, 0, 5696, 5695, 1, 0, 0, 0, 5696, 5697, 1, 0, 0,
		0, 5697, 5698, 1, 0, 0, 0, 5698, 5699, 5, 224, 0, 0, 5699, 5700, 5, 2,
		0, 0, 5700, 5701, 3, 226, 113, 0, 5701, 5702, 5, 3, 0, 0, 5702, 5729, 1,
		0, 0, 0, 5703, 5705, 5, 311, 0, 0, 5704, 5703, 1, 0, 0, 0, 5704, 5705,
		1, 0, 0, 0, 5705, 5706, 1, 0, 0, 0, 5706, 5707, 5, 224, 0, 0, 5707, 5708,
		5, 2, 0, 0, 5708, 5713, 3, 368, 184, 0, 5709, 5710, 5, 4, 0, 0, 5710, 5712,
		3, 368, 184, 0, 5711, 5709, 1, 0, 0, 0, 5712, 5715, 1, 0, 0, 0, 5713, 5711,
		1, 0, 0, 0, 5713, 5714, 1, 0, 0, 0, 5714, 5716, 1, 0, 0, 0, 5715, 5713,
		1, 0, 0, 0, 5716, 5717, 5, 3, 0, 0, 5717, 5729, 1, 0, 0, 0, 5718, 5720,
		5, 242, 0, 0, 5719, 5721, 5, 311, 0, 0, 5720, 5719, 1, 0, 0, 0, 5720, 5721,
		1, 0, 0, 0, 5721, 5722, 1, 0, 0, 0, 5722, 5729, 5, 312, 0, 0, 5723, 5725,
		5, 242, 0, 0, 5724, 5726, 5, 311, 0, 0, 5725, 5724, 1, 0, 0, 0, 5725, 5726,
		1, 0, 0, 0, 5726, 5727, 1, 0, 0, 0, 5727, 5729, 7, 46, 0, 0, 5728, 5678,
		1, 0, 0, 0, 5728, 5686, 1, 0, 0, 0, 5728, 5691, 1, 0, 0, 0, 5728, 5696,
		1, 0, 0, 0, 5728, 5704, 1, 0, 0, 0, 5728, 5718, 1, 0, 0, 0, 5728, 5723,
		1, 0, 0, 0, 5729, 379, 1, 0, 0, 0, 5730, 5731, 6, 190, -1, 0, 5731, 5735,
		3, 382, 191, 0, 5732, 5733, 7, 47, 0, 0, 5733, 5735, 3, 380, 190, 7, 5734,
		5730, 1, 0, 0, 0, 5734, 5732, 1, 0, 0, 0, 5735, 5757, 1, 0, 0, 0, 5736,
		5737, 10, 6, 0, 0, 5737, 5738, 5, 535, 0, 0, 5738, 5756, 3, 380, 190, 7,
		5739, 5740, 10, 5, 0, 0, 5740, 5741, 7, 48, 0, 0, 5741, 5756, 3, 380, 190,
		6, 5742, 5743, 10, 4, 0, 0, 5743, 5744, 7, 49, 0, 0, 5744, 5756, 3, 380,
		190, 5, 5745, 5746, 10, 3, 0, 0, 5746, 5747, 5, 530, 0, 0, 5747, 5756,
		3, 380, 190, 4, 5748, 5749, 10, 2, 0, 0, 5749, 5750, 5, 533, 0, 0, 5750,
		5756, 3, 380, 190, 3, 5751, 5752, 10, 1, 0, 0, 5752, 5753, 3, 408, 204,
		0, 5753, 5754, 3, 380, 190, 2, 5754, 5756, 1, 0, 0, 0, 5755, 5736, 1, 0,
		0, 0, 5755, 5739, 1, 0, 0, 0, 5755, 5742, 1, 0, 0, 0, 5755, 5745, 1, 0,
		0, 0, 5755, 5748, 1, 0, 0, 0, 5755, 5751, 1, 0, 0, 0, 5756, 5759, 1, 0,
		0, 0, 5757, 5755, 1, 0, 0, 0, 5757, 5758, 1, 0, 0, 0, 5758, 381, 1, 0,
		0, 0, 5759, 5757, 1, 0, 0, 0, 5760, 5761, 6, 191, -1, 0, 5761, 5887, 5,
		108, 0, 0, 5762, 5887, 5, 109, 0, 0, 5763, 5887, 5, 110, 0, 0, 5764, 5887,
		5, 272, 0, 0, 5765, 5887, 5, 273, 0, 0, 5766, 5887, 5, 111, 0, 0, 5767,
		5887, 5, 418, 0, 0, 5768, 5770, 5, 66, 0, 0, 5769, 5771, 3, 412, 206, 0,
		5770, 5769, 1, 0, 0, 0, 5771, 5772, 1, 0, 0, 0, 5772, 5770, 1, 0, 0, 0,
		5772, 5773, 1, 0, 0, 0, 5773, 5776, 1, 0, 0, 0, 5774, 5775, 5, 154, 0,
		0, 5775, 5777, 3, 368, 184, 0, 5776, 5774, 1, 0, 0, 0, 5776, 5777, 1, 0,
		0, 0, 5777, 5778, 1, 0, 0, 0, 5778, 5779, 5, 158, 0, 0, 5779, 5887, 1,
		0, 0, 0, 5780, 5781, 5, 66, 0, 0, 5781, 5783, 3, 368, 184, 0, 5782, 5784,
		3, 412, 206, 0, 5783, 5782, 1, 0, 0, 0, 5784, 5785, 1, 0, 0, 0, 5785, 5783,
		1, 0, 0, 0, 5785, 5786, 1, 0, 0, 0, 5786, 5789, 1, 0, 0, 0, 5787, 5788,
		5, 154, 0, 0, 5788, 5790, 3, 368, 184, 0, 5789, 5787, 1, 0, 0, 0, 5789,
		5790, 1, 0, 0, 0, 5790, 5791, 1, 0, 0, 0, 5791, 5792, 5, 158, 0, 0, 5792,
		5887, 1, 0, 0, 0, 5793, 5794, 5, 67, 0, 0, 5794, 5795, 5, 2, 0, 0, 5795,
		5796, 3, 368, 184, 0, 5796, 5797, 5, 29, 0, 0, 5797, 5798, 3, 386, 193,
		0, 5798, 5799, 5, 3, 0, 0, 5799, 5887, 1, 0, 0, 0, 5800, 5887, 3, 406,
		203, 0, 5801, 5887, 3, 414, 207, 0, 5802, 5806, 5, 526, 0, 0, 5803, 5805,
		3, 384, 192, 0, 5804, 5803, 1, 0, 0, 0, 5805, 5808, 1, 0, 0, 0, 5806, 5804,
		1, 0, 0, 0, 5806, 5807, 1, 0, 0, 0, 5807, 5887, 1, 0, 0, 0, 5808, 5806,
		1, 0, 0, 0, 5809, 5810, 3, 402, 201, 0, 5810, 5811, 5, 5, 0, 0, 5811, 5815,
		5, 526, 0, 0, 5812, 5814, 3, 384, 192, 0, 5813, 5812, 1, 0, 0, 0, 5814,
		5817, 1, 0, 0, 0, 5815, 5813, 1, 0, 0, 0, 5815, 5816, 1, 0, 0, 0, 5816,
		5887, 1, 0, 0, 0, 5817, 5815, 1, 0, 0, 0, 5818, 5819, 5, 71, 0, 0, 5819,
		5820, 5, 2, 0, 0, 5820, 5825, 3, 368, 184, 0, 5821, 5822, 5, 4, 0, 0, 5822,
		5824, 3, 368, 184, 0, 5823, 5821, 1, 0, 0, 0, 5824, 5827, 1, 0, 0, 0, 5825,
		5823, 1, 0, 0, 0, 5825, 5826, 1, 0, 0, 0, 5826, 5830, 1, 0, 0, 0, 5827,
		5825, 1, 0, 0, 0, 5828, 5829, 5, 492, 0, 0, 5829, 5831, 3, 180, 90, 0,
		5830, 5828, 1, 0, 0, 0, 5830, 5831, 1, 0, 0, 0, 5831, 5832, 1, 0, 0, 0,
		5832, 5833, 5, 3, 0, 0, 5833, 5887, 1, 0, 0, 0, 5834, 5835, 5, 97, 0, 0,
		5835, 5836, 5, 2, 0, 0, 5836, 5837, 3, 368, 184, 0, 5837, 5838, 5, 492,
		0, 0, 5838, 5839, 3, 180, 90, 0, 5839, 5840, 5, 3, 0, 0, 5840, 5887, 1,
		0, 0, 0, 5841, 5842, 5, 97, 0, 0, 5842, 5843, 5, 2, 0, 0, 5843, 5844, 3,
		368, 184, 0, 5844, 5845, 5, 4, 0, 0, 5845, 5846, 3, 386, 193, 0, 5846,
		5847, 5, 3, 0, 0, 5847, 5887, 1, 0, 0, 0, 5848, 5887, 3, 388, 194, 0, 5849,
		5850, 5, 2, 0, 0, 5850, 5851, 3, 226, 113, 0, 5851, 5852, 5, 3, 0, 0, 5852,
		5887, 1, 0, 0, 0, 5853, 5854, 5, 541, 0, 0, 5854, 5887, 3, 180, 90, 0,
		5855, 5858, 5, 542, 0, 0, 5856, 5857, 7, 50, 0, 0, 5857, 5859, 5, 5, 0,
		0, 5858, 5856, 1, 0, 0, 0, 5858, 5859, 1, 0, 0, 0, 5859, 5860, 1, 0, 0,
		0, 5860, 5887, 3, 440, 220, 0, 5861, 5863, 5, 44, 0, 0, 5862, 5861, 1,
		0, 0, 0, 5862, 5863, 1, 0, 0, 0, 5863, 5864, 1, 0, 0, 0, 5864, 5887, 3,
		440, 220, 0, 5865, 5866, 5, 2, 0, 0, 5866, 5867, 3, 368, 184, 0, 5867,
		5868, 5, 3, 0, 0, 5868, 5887, 1, 0, 0, 0, 5869, 5873, 5, 252, 0, 0, 5870,
		5871, 3, 440, 220, 0, 5871, 5872, 5, 5, 0, 0, 5872, 5874, 1, 0, 0, 0, 5873,
		5870, 1, 0, 0, 0, 5873, 5874, 1, 0, 0, 0, 5874, 5875, 1, 0, 0, 0, 5875,
		5887, 3, 440, 220, 0, 5876, 5877, 5, 175, 0, 0, 5877, 5878, 5, 2, 0, 0,
		5878, 5879, 3, 440, 220, 0, 5879, 5881, 5, 192, 0, 0, 5880, 5882, 7, 51,
		0, 0, 5881, 5880, 1, 0, 0, 0, 5881, 5882, 1, 0, 0, 0, 5882, 5883, 1, 0,
		0, 0, 5883, 5884, 3, 380, 190, 0, 5884, 5885, 5, 3, 0, 0, 5885, 5887, 1,
		0, 0, 0, 5886, 5760, 1, 0, 0, 0, 5886, 5762, 1, 0, 0, 0, 5886, 5763, 1,
		0, 0, 0, 5886, 5764, 1, 0, 0, 0, 5886, 5765, 1, 0, 0, 0, 5886, 5766, 1,
		0, 0, 0, 5886, 5767, 1, 0, 0, 0, 5886, 5768, 1, 0, 0, 0, 5886, 5780, 1,
		0, 0, 0, 5886, 5793, 1, 0, 0, 0, 5886, 5800, 1, 0, 0, 0, 5886, 5801, 1,
		0, 0, 0, 5886, 5802, 1, 0, 0, 0, 5886, 5809, 1, 0, 0, 0, 5886, 5818, 1,
		0, 0, 0, 5886, 5834, 1, 0, 0, 0, 5886, 5841, 1, 0, 0, 0, 5886, 5848, 1,
		0, 0, 0, 5886, 5849, 1, 0, 0, 0, 5886, 5853, 1, 0, 0, 0, 5886, 5855, 1,
		0, 0, 0, 5886, 5862, 1, 0, 0, 0, 5886, 5865, 1, 0, 0, 0, 5886, 5869, 1,
		0, 0, 0, 5886, 5876, 1, 0, 0, 0, 5887, 5914, 1, 0, 0, 0, 5888, 5889, 10,
		11, 0, 0, 5889, 5890, 5, 7, 0, 0, 5890, 5891, 3, 380, 190, 0, 5891, 5892,
		5, 8, 0, 0, 5892, 5913, 1, 0, 0, 0, 5893, 5894, 10, 10, 0, 0, 5894, 5895,
		5, 7, 0, 0, 5895, 5896, 3, 380, 190, 0, 5896, 5898, 5, 536, 0, 0, 5897,
		5899, 3, 380, 190, 0, 5898, 5897, 1, 0, 0, 0, 5898, 5899, 1, 0, 0, 0, 5899,
		5900, 1, 0, 0, 0, 5900, 5901, 5, 8, 0, 0, 5901, 5913, 1, 0, 0, 0, 5902,
		5903, 10, 5, 0, 0, 5903, 5904, 5, 5, 0, 0, 5904, 5913, 3, 440, 220, 0,
		5905, 5906, 10, 1, 0, 0, 5906, 5910, 5, 77, 0, 0, 5907, 5911, 3, 440, 220,
		0, 5908, 5911, 5, 543, 0, 0, 5909, 5911, 5, 127, 0, 0, 5910, 5907, 1, 0,
		0, 0, 5910, 5908, 1, 0, 0, 0, 5910, 5909, 1, 0, 0, 0, 5911, 5913, 1, 0,
		0, 0, 5912, 5888, 1, 0, 0, 0, 5912, 5893, 1, 0, 0, 0, 5912, 5902, 1, 0,
		0, 0, 5912, 5905, 1, 0, 0, 0, 5913, 5916, 1, 0, 0, 0, 5914, 5912, 1, 0,
		0, 0, 5914, 5915, 1, 0, 0, 0, 5915, 383, 1, 0, 0, 0, 5916, 5914, 1, 0,
		0, 0, 5917, 5918, 5, 166, 0, 0, 5918, 5919, 5, 2, 0, 0, 5919, 5920, 3,
		366, 183, 0, 5920, 5921, 5, 3, 0, 0, 5921, 5928, 1, 0, 0, 0, 5922, 5923,
		5, 382, 0, 0, 5923, 5924, 5, 2, 0, 0, 5924, 5925, 3, 366, 183, 0, 5925,
		5926, 5, 3, 0, 0, 5926, 5928, 1, 0, 0, 0, 5927, 5917, 1, 0, 0, 0, 5927,
		5922, 1, 0, 0, 0, 5928, 385, 1, 0, 0, 0, 5929, 5935, 3, 420, 210, 0, 5930,
		5932, 7, 52, 0, 0, 5931, 5933, 7, 53, 0, 0, 5932, 5931, 1, 0, 0, 0, 5932,
		5933, 1, 0, 0, 0, 5933, 5935, 1, 0, 0, 0, 5934, 5929, 1, 0, 0, 0, 5934,
		5930, 1, 0, 0, 0, 5935, 387, 1, 0, 0, 0, 5936, 5937, 3, 390, 195, 0, 5937,
		5961, 5, 2, 0, 0, 5938, 5940, 7, 37, 0, 0, 5939, 5938, 1, 0, 0, 0, 5939,
		5940, 1, 0, 0, 0, 5940, 5941, 1, 0, 0, 0, 5941, 5946, 3, 368, 184, 0, 5942,
		5943, 5, 4, 0, 0, 5943, 5945, 3, 368, 184, 0, 5944, 5942, 1, 0, 0, 0, 5945,
		5948, 1, 0, 0, 0, 5946, 5944, 1, 0, 0, 0, 5946, 5947, 1, 0, 0, 0, 5947,
		5959, 1, 0, 0, 0, 5948, 5946, 1, 0, 0, 0, 5949, 5950, 5, 322, 0, 0, 5950,
		5951, 5, 61, 0, 0, 5951, 5956, 3, 292, 146, 0, 5952, 5953, 5, 4, 0, 0,
		5953, 5955, 3, 292, 146, 0, 5954, 5952, 1, 0, 0, 0, 5955, 5958, 1, 0, 0,
		0, 5956, 5954, 1, 0, 0, 0, 5956, 5957, 1, 0, 0, 0, 5957, 5960, 1, 0, 0,
		0, 5958, 5956, 1, 0, 0, 0, 5959, 5949, 1, 0, 0, 0, 5959, 5960, 1, 0, 0,
		0, 5960, 5962, 1, 0, 0, 0, 5961, 5939, 1, 0, 0, 0, 5961, 5962, 1, 0, 0,
		0, 5962, 5963, 1, 0, 0, 0, 5963, 5966, 5, 3, 0, 0, 5964, 5965, 5, 325,
		0, 0, 5965, 5967, 3, 394, 197, 0, 5966, 5964, 1, 0, 0, 0, 5966, 5967, 1,
		0, 0, 0, 5967, 389, 1, 0, 0, 0, 5968, 5969, 3, 440, 220, 0, 5969, 5970,
		5, 5, 0, 0, 5970, 5972, 1, 0, 0, 0, 5971, 5968, 1, 0, 0, 0, 5971, 5972,
		1, 0, 0, 0, 5972, 5973, 1, 0, 0, 0, 5973, 5974, 3, 392, 196, 0, 5974, 391,
		1, 0, 0, 0, 5975, 5992, 3, 440, 220, 0, 5976, 5992, 5, 14, 0, 0, 5977,
		5992, 5, 93, 0, 0, 5978, 5992, 5, 107, 0, 0, 5979, 5992, 5, 111, 0, 0,
		5980, 5992, 5, 113, 0, 0, 5981, 5992, 5, 221, 0, 0, 5982, 5992, 5, 262,
		0, 0, 5983, 5992, 5, 265, 0, 0, 5984, 5992, 5, 331, 0, 0, 5985, 5992, 5,
		377, 0, 0, 5986, 5992, 5, 398, 0, 0, 5987, 5992, 5, 411, 0, 0, 5988, 5992,
		5, 418, 0, 0, 5989, 5992, 5, 473, 0, 0, 5990, 5992, 5, 490, 0, 0, 5991,
		5975, 1, 0, 0, 0, 5991, 5976, 1, 0, 0, 0, 5991, 5977, 1, 0, 0, 0, 5991,
		5978, 1, 0, 0, 0, 5991, 5979, 1, 0, 0, 0, 5991, 5980, 1, 0, 0, 0, 5991,
		5981, 1, 0, 0, 0, 5991, 5982, 1, 0, 0, 0, 5991, 5983, 1, 0, 0, 0, 5991,
		5984, 1, 0, 0, 0, 5991, 5985, 1, 0, 0, 0, 5991, 5986, 1, 0, 0, 0, 5991,
		5987, 1, 0, 0, 0, 5991, 5988, 1, 0, 0, 0, 5991, 5989, 1, 0, 0, 0, 5991,
		5990, 1, 0, 0, 0, 5992, 393, 1, 0, 0, 0, 5993, 5995, 5, 2, 0, 0, 5994,
		5996, 3, 296, 148, 0, 5995, 5994, 1, 0, 0, 0, 5995, 5996, 1, 0, 0, 0, 5996,
		5998, 1, 0, 0, 0, 5997, 5999, 3, 290, 145, 0, 5998, 5997, 1, 0, 0, 0, 5998,
		5999, 1, 0, 0, 0, 5999, 6001, 1, 0, 0, 0, 6000, 6002, 3, 396, 198, 0, 6001,
		6000, 1, 0, 0, 0, 6001, 6002, 1, 0, 0, 0, 6002, 6003, 1, 0, 0, 0, 6003,
		6004, 5, 3, 0, 0, 6004, 395, 1, 0, 0, 0, 6005, 6006, 3, 398, 199, 0, 6006,
		6007, 3, 400, 200, 0, 6007, 6015, 1, 0, 0, 0, 6008, 6009, 3, 398, 199,
		0, 6009, 6010, 5, 41, 0, 0, 6010, 6011, 3, 400, 200, 0, 6011, 6012, 5,
		25, 0, 0, 6012, 6013, 3, 400, 200, 0, 6013, 6015, 1, 0, 0, 0, 6014, 6005,
		1, 0, 0, 0, 6014, 6008, 1, 0, 0, 0, 6015, 397, 1, 0, 0, 0, 6016, 6017,
		7, 54, 0, 0, 6017, 399, 1, 0, 0, 0, 6018, 6019, 5, 479, 0, 0, 6019, 6026,
		7, 55, 0, 0, 6020, 6021, 5, 106, 0, 0, 6021, 6026, 5, 405, 0, 0, 6022,
		6023, 3, 368, 184, 0, 6023, 6024, 7, 55, 0, 0, 6024, 6026, 1, 0, 0, 0,
		6025, 6018, 1, 0, 0, 0, 6025, 6020, 1, 0, 0, 0, 6025, 6022, 1, 0, 0, 0,
		6026, 401, 1, 0, 0, 0, 6027, 6032, 3, 440, 220, 0, 6028, 6029, 5, 5, 0,
		0, 6029, 6031, 3, 440, 220, 0, 6030, 6028, 1, 0, 0, 0, 6031, 6034, 1, 0,
		0, 0, 6032, 6030, 1, 0, 0, 0, 6032, 6033, 1, 0, 0, 0, 6033, 403, 1, 0,
		0, 0, 6034, 6032, 1, 0, 0, 0, 6035, 6037, 5, 458, 0, 0, 6036, 6035, 1,
		0, 0, 0, 6036, 6037, 1, 0, 0, 0, 6037, 6038, 1, 0, 0, 0, 6038, 6041, 5,
		329, 0, 0, 6039, 6042, 3, 440, 220, 0, 6040, 6042, 3, 302, 151, 0, 6041,
		6039, 1, 0, 0, 0, 6041, 6040, 1, 0, 0, 0, 6042, 6049, 1, 0, 0, 0, 6043,
		6045, 5, 458, 0, 0, 6044, 6043, 1, 0, 0, 0, 6044, 6045, 1, 0, 0, 0, 6045,
		6046, 1, 0, 0, 0, 6046, 6047, 5, 330, 0, 0, 6047, 6049, 3, 302, 151, 0,
		6048, 6036, 1, 0, 0, 0, 6048, 6044, 1, 0, 0, 0, 6049, 405, 1, 0, 0, 0,
		6050, 6102, 5, 312, 0, 0, 6051, 6052, 7, 56, 0, 0, 6052, 6102, 5, 543,
		0, 0, 6053, 6102, 3, 446, 223, 0, 6054, 6102, 3, 410, 205, 0, 6055, 6057,
		5, 44, 0, 0, 6056, 6055, 1, 0, 0, 0, 6056, 6057, 1, 0, 0, 0, 6057, 6058,
		1, 0, 0, 0, 6058, 6102, 5, 543, 0, 0, 6059, 6061, 5, 7, 0, 0, 6060, 6062,
		3, 406, 203, 0, 6061, 6060, 1, 0, 0, 0, 6061, 6062, 1, 0, 0, 0, 6062, 6067,
		1, 0, 0, 0, 6063, 6064, 5, 4, 0, 0, 6064, 6066, 3, 406, 203, 0, 6065, 6063,
		1, 0, 0, 0, 6066, 6069, 1, 0, 0, 0, 6067, 6065, 1, 0, 0, 0, 6067, 6068,
		1, 0, 0, 0, 6068, 6070, 1, 0, 0, 0, 6069, 6067, 1, 0, 0, 0, 6070, 6102,
		5, 8, 0, 0, 6071, 6076, 5, 9, 0, 0, 6072, 6073, 3, 406, 203, 0, 6073, 6074,
		5, 536, 0, 0, 6074, 6075, 3, 406, 203, 0, 6075, 6077, 1, 0, 0, 0, 6076,
		6072, 1, 0, 0, 0, 6076, 6077, 1, 0, 0, 0, 6077, 6085, 1, 0, 0, 0, 6078,
		6079, 5, 4, 0, 0, 6079, 6080, 3, 406, 203, 0, 6080, 6081, 5, 536, 0, 0,
		6081, 6082, 3, 406, 203, 0, 6082, 6084, 1, 0, 0, 0, 6083, 6078, 1, 0, 0,
		0, 6084, 6087, 1, 0, 0, 0, 6085, 6083, 1, 0, 0, 0, 6085, 6086, 1, 0, 0,
		0, 6086, 6088, 1, 0, 0, 0, 6087, 6085, 1, 0, 0, 0, 6088, 6102, 5, 10, 0,
		0, 6089, 6090, 5, 9, 0, 0, 6090, 6095, 3, 406, 203, 0, 6091, 6092, 5, 4,
		0, 0, 6092, 6094, 3, 406, 203, 0, 6093, 6091, 1, 0, 0, 0, 6094, 6097, 1,
		0, 0, 0, 6095, 6093, 1, 0, 0, 0, 6095, 6096, 1, 0, 0, 0, 6096, 6098, 1,
		0, 0, 0, 6097, 6095, 1, 0, 0, 0, 6098, 6099, 5, 10, 0, 0, 6099, 6102, 1,
		0, 0, 0, 6100, 6102, 5, 343, 0, 0, 6101, 6050, 1, 0, 0, 0, 6101, 6051,
		1, 0, 0, 0, 6101, 6053, 1, 0, 0, 0, 6101, 6054, 1, 0, 0, 0, 6101, 6056,
		1, 0, 0, 0, 6101, 6059, 1, 0, 0, 0, 6101, 6071, 1, 0, 0, 0, 6101, 6089,
		1, 0, 0, 0, 6101, 6100, 1, 0, 0, 0, 6102, 407, 1, 0, 0, 0, 6103, 6104,
		7, 57, 0, 0, 6104, 409, 1, 0, 0, 0, 6105, 6106, 7, 46, 0, 0, 6106, 411,
		1, 0, 0, 0, 6107, 6108, 5, 508, 0, 0, 6108, 6109, 3, 368, 184, 0, 6109,
		6110, 5, 462, 0, 0, 6110, 6111, 3, 368, 184, 0, 6111, 413, 1, 0, 0, 0,
		6112, 6113, 5, 236, 0, 0, 6113, 6114, 3, 368, 184, 0, 6114, 6115, 3, 416,
		208, 0, 6115, 415, 1, 0, 0, 0, 6116, 6117, 7, 58, 0, 0, 6117, 417, 1, 0,
		0, 0, 6118, 6123, 3, 420, 210, 0, 6119, 6121, 5, 311, 0, 0, 6120, 6119,
		1, 0, 0, 0, 6120, 6121, 1, 0, 0, 0, 6121, 6122, 1, 0, 0, 0, 6122, 6124,
		5, 312, 0, 0, 6123, 6120, 1, 0, 0, 0, 6123, 6124, 1, 0, 0, 0, 6124, 419,
		1, 0, 0, 0, 6125, 6126, 5, 28, 0, 0, 6126, 6127, 5, 520, 0, 0, 6127, 6128,
		3, 420, 210, 0, 6128, 6129, 5, 522, 0, 0, 6129, 6171, 1, 0, 0, 0, 6130,
		6131, 5, 279, 0, 0, 6131, 6132, 5, 520, 0, 0, 6132, 6133, 3, 420, 210,
		0, 6133, 6134, 5, 4, 0, 0, 6134, 6135, 3, 420, 210, 0, 6135, 6136, 5, 522,
		0, 0, 6136, 6171, 1, 0, 0, 0, 6137, 6138, 5, 444, 0, 0, 6138, 6139, 5,
		520, 0, 0, 6139, 6140, 3, 424, 212, 0, 6140, 6141, 5, 522, 0, 0, 6141,
		6171, 1, 0, 0, 0, 6142, 6143, 5, 17, 0, 0, 6143, 6144, 5, 520, 0, 0, 6144,
		6145, 3, 392, 196, 0, 6145, 6146, 5, 2, 0, 0, 6146, 6151, 3, 418, 209,
		0, 6147, 6148, 5, 4, 0, 0, 6148, 6150, 3, 418, 209, 0, 6149, 6147, 1, 0,
		0, 0, 6150, 6153, 1, 0, 0, 0, 6151, 6149, 1, 0, 0, 0, 6151, 6152, 1, 0,
		0, 0, 6152, 6154, 1, 0, 0, 0, 6153, 6151, 1, 0, 0, 0, 6154, 6155, 5, 3,
		0, 0, 6155, 6156, 5, 522, 0, 0, 6156, 6171, 1, 0, 0, 0, 6157, 6168, 3,
		422, 211, 0, 6158, 6159, 5, 2, 0, 0, 6159, 6164, 7, 59, 0, 0, 6160, 6161,
		5, 4, 0, 0, 6161, 6163, 5, 548, 0, 0, 6162, 6160, 1, 0, 0, 0, 6163, 6166,
		1, 0, 0, 0, 6164, 6162, 1, 0, 0, 0, 6164, 6165, 1, 0, 0, 0, 6165, 6167,
		1, 0, 0, 0, 6166, 6164, 1, 0, 0, 0, 6167, 6169, 5, 3, 0, 0, 6168, 6158,
		1, 0, 0, 0, 6168, 6169, 1, 0, 0, 0, 6169, 6171, 1, 0, 0, 0, 6170, 6125,
		1, 0, 0, 0, 6170, 6130, 1, 0, 0, 0, 6170, 6137, 1, 0, 0, 0, 6170, 6142,
		1, 0, 0, 0, 6170, 6157, 1, 0, 0, 0, 6171, 421, 1, 0, 0, 0, 6172, 6205,
		5, 465, 0, 0, 6173, 6205, 5, 426, 0, 0, 6174, 6205, 7, 53, 0, 0, 6175,
		6205, 5, 42, 0, 0, 6176, 6205, 5, 256, 0, 0, 6177, 6205, 5, 53, 0, 0, 6178,
		6205, 5, 184, 0, 0, 6179, 6205, 5, 146, 0, 0, 6180, 6205, 5, 115, 0, 0,
		6181, 6205, 5, 116, 0, 0, 6182, 6205, 5, 463, 0, 0, 6183, 6205, 5, 118,
		0, 0, 6184, 6205, 5, 117, 0, 0, 6185, 6205, 5, 120, 0, 0, 6186, 6205, 5,
		119, 0, 0, 6187, 6205, 5, 47, 0, 0, 6188, 6205, 5, 360, 0, 0, 6189, 6205,
		5, 213, 0, 0, 6190, 6205, 5, 17, 0, 0, 6191, 6205, 5, 443, 0, 0, 6192,
		6205, 5, 250, 0, 0, 6193, 6205, 5, 251, 0, 0, 6194, 6205, 5, 460, 0, 0,
		6195, 6205, 5, 495, 0, 0, 6196, 6205, 5, 71, 0, 0, 6197, 6205, 5, 123,
		0, 0, 6198, 6205, 5, 124, 0, 0, 6199, 6205, 5, 125, 0, 0, 6200, 6205, 5,
		240, 0, 0, 6201, 6205, 5, 241, 0, 0, 6202, 6205, 5, 498, 0, 0, 6203, 6205,
		5, 20, 0, 0, 6204, 6172, 1, 0, 0, 0, 6204, 6173, 1, 0, 0, 0, 6204, 6174,
		1, 0, 0, 0, 6204, 6175, 1, 0, 0, 0, 6204, 6176, 1, 0, 0, 0, 6204, 6177,
		1, 0, 0, 0, 6204, 6178, 1, 0, 0, 0, 6204, 6179, 1, 0, 0, 0, 6204, 6180,
		1, 0, 0, 0, 6204, 6181, 1, 0, 0, 0, 6204, 6182, 1, 0, 0, 0, 6204, 6183,
		1, 0, 0, 0, 6204, 6184, 1, 0, 0, 0, 6204, 6185, 1, 0, 0, 0, 6204, 6186,
		1, 0, 0, 0, 6204, 6187, 1, 0, 0, 0, 6204, 6188, 1, 0, 0, 0, 6204, 6189,
		1, 0, 0, 0, 6204, 6190, 1, 0, 0, 0, 6204, 6191, 1, 0, 0, 0, 6204, 6192,
		1, 0, 0, 0, 6204, 6193, 1, 0, 0, 0, 6204, 6194, 1, 0, 0, 0, 6204, 6195,
		1, 0, 0, 0, 6204, 6196, 1, 0, 0, 0, 6204, 6197, 1, 0, 0, 0, 6204, 6198,
		1, 0, 0, 0, 6204, 6199, 1, 0, 0, 0, 6204, 6200, 1, 0, 0, 0, 6204, 6201,
		1, 0, 0, 0, 6204, 6202, 1, 0, 0, 0, 6204, 6203, 1, 0, 0, 0, 6205, 423,
		1, 0, 0, 0, 6206, 6211, 3, 426, 213, 0, 6207, 6208, 5, 4, 0, 0, 6208, 6210,
		3, 426, 213, 0, 6209, 6207, 1, 0, 0, 0, 6210, 6213, 1, 0, 0, 0, 6211, 6209,
		1, 0, 0, 0, 6211, 6212, 1, 0, 0, 0, 6212, 425, 1, 0, 0, 0, 6213, 6211,
		1, 0, 0, 0, 6214, 6215, 3, 440, 220, 0, 6215, 6216, 5, 536, 0, 0, 6216,
		6218, 3, 420, 210, 0, 6217, 6219, 3, 428, 214, 0, 6218, 6217, 1, 0, 0,
		0, 6218, 6219, 1, 0, 0, 0, 6219, 427, 1, 0, 0, 0, 6220, 6221, 5, 83, 0,
		0, 6221, 6222, 5, 543, 0, 0, 6222, 429, 1, 0, 0, 0, 6223, 6224, 5, 452,
		0, 0, 6224, 6226, 5, 2, 0, 0, 6225, 6227, 3, 432, 216, 0, 6226, 6225, 1,
		0, 0, 0, 6226, 6227, 1, 0, 0, 0, 6227, 6228, 1, 0, 0, 0, 6228, 6231, 5,
		3, 0, 0, 6229, 6230, 5, 381, 0, 0, 6230, 6232, 5, 548, 0, 0, 6231, 6229,
		1, 0, 0, 0, 6231, 6232, 1, 0, 0, 0, 6232, 431, 1, 0, 0, 0, 6233, 6234,
		5, 548, 0, 0, 6234, 6238, 5, 338, 0, 0, 6235, 6236, 5, 548, 0, 0, 6236,
		6238, 5, 406, 0, 0, 6237, 6233, 1, 0, 0, 0, 6237, 6235, 1, 0, 0, 0, 6238,
		433, 1, 0, 0, 0, 6239, 6240, 5, 187, 0, 0, 6240, 6241, 5, 502, 0, 0, 6241,
		6242, 5, 29, 0, 0, 6242, 6243, 5, 315, 0, 0, 6243, 6250, 7, 18, 0, 0, 6244,
		6245, 5, 187, 0, 0, 6245, 6246, 5, 463, 0, 0, 6246, 6247, 5, 29, 0, 0,
		6247, 6248, 5, 315, 0, 0, 6248, 6250, 5, 543, 0, 0, 6249, 6239, 1, 0, 0,
		0, 6249, 6244, 1, 0, 0, 0, 6250, 435, 1, 0, 0, 0, 6251, 6252, 3, 440, 220,
		0, 6252, 6253, 3, 438, 219, 0, 6253, 437, 1, 0, 0, 0, 6254, 6255, 5, 525,
		0, 0, 6255, 6257, 3, 440, 220, 0, 6256, 6254, 1, 0, 0, 0, 6257, 6258, 1,
		0, 0, 0, 6258, 6256, 1, 0, 0, 0, 6258, 6259, 1, 0, 0, 0, 6259, 6262, 1,
		0, 0, 0, 6260, 6262, 1, 0, 0, 0, 6261, 6256, 1, 0, 0, 0, 6261, 6260, 1,
		0, 0, 0, 6262, 439, 1, 0, 0, 0, 6263, 6264, 3, 442, 221, 0, 6264, 441,
		1, 0, 0, 0, 6265, 6269, 5, 552, 0, 0, 6266, 6269, 3, 444, 222, 0, 6267,
		6269, 3, 448, 224, 0, 6268, 6265, 1, 0, 0, 0, 6268, 6266, 1, 0, 0, 0, 6268,
		6267, 1, 0, 0, 0, 6269, 443, 1, 0, 0, 0, 6270, 6271, 5, 553, 0, 0, 6271,
		445, 1, 0, 0, 0, 6272, 6274, 5, 525, 0, 0, 6273, 6272, 1, 0, 0, 0, 6273,
		6274, 1, 0, 0, 0, 6274, 6275, 1, 0, 0, 0, 6275, 6281, 5, 548, 0, 0, 6276,
		6278, 5, 525, 0, 0, 6277, 6276, 1, 0, 0, 0, 6277, 6278, 1, 0, 0, 0, 6278,
		6279, 1, 0, 0, 0, 6279, 6281, 7, 60, 0, 0, 6280, 6273, 1, 0, 0, 0, 6280,
		6277, 1, 0, 0, 0, 6281, 447, 1, 0, 0, 0, 6282, 6283, 7, 61, 0, 0, 6283,
		449, 1, 0, 0, 0, 895, 453, 457, 462, 467, 473, 481, 485, 490, 504, 507,
		515, 518, 526, 533, 540, 549, 556, 563, 567, 569, 572, 576, 602, 608, 616,
		623, 626, 630, 633, 635, 638, 642, 646, 654, 661, 665, 667, 670, 682, 696,
		704, 711, 718, 723, 749, 762, 764, 768, 773, 775, 778, 794, 819, 840, 843,
		846, 852, 859, 862, 867, 870, 876, 880, 883, 891, 894, 897, 900, 906, 911,
		914, 925, 930, 933, 936, 943, 946, 951, 954, 960, 964, 974, 978, 981, 987,
		990, 992, 996, 1002, 1006, 1012, 1015, 1019, 1024, 1032, 1034, 1038, 1041,
		1048, 1053, 1055, 1057, 1064, 1067, 1071, 1075, 1080, 1086, 1093, 1097,
		1107, 1112, 1118, 1126, 1128, 1135, 1140, 1148, 1153, 1156, 1163, 1169,
		1173, 1176, 1184, 1195, 1208, 1212, 1220, 1227, 1235, 1238, 1242, 1250,
		1258, 1265, 1268, 1275, 1279, 1286, 1294, 1297, 1303, 1308, 1315, 1318,
		1322, 1329, 1334, 1341, 1352, 1359, 1363, 1370, 1374, 1379, 1388, 1394,
		1398, 1405, 1418, 1425, 1429, 1437, 1441, 1450, 1454, 1463, 1467, 1476,
		1480, 1482, 1489, 1507, 1511, 1515, 1540, 1543, 1559, 1565, 1594, 1607,
		1620, 1639, 1662, 1668, 1676, 1684, 1699, 1705, 1707, 1721, 1728, 1735,
		1742, 1750, 1758, 1763, 1769, 1777, 1785, 1795, 1799, 1805, 1809, 1813,
		1818, 1823, 1831, 1841, 1849, 1858, 1860, 1866, 1873, 1880, 1889, 1898,
		1907, 1910, 1914, 1918, 1929, 1933, 1936, 1939, 1942, 1952, 1955, 1964,
		1967, 1970, 1973, 1981, 1987, 1990, 1996, 1999, 2002, 2005, 2014, 2020,
		2025, 2031, 2036, 2040, 2043, 2048, 2052, 2057, 2062, 2066, 2078, 2084,
		2087, 2100, 2113, 2117, 2121, 2128, 2133, 2139, 2142, 2145, 2149, 2154,
		2157, 2173, 2177, 2190, 2196, 2200, 2207, 2212, 2221, 2223, 2231, 2233,
		2239, 2251, 2255, 2258, 2261, 2274, 2294, 2297, 2300, 2304, 2309, 2312,
		2315, 2318, 2325, 2328, 2331, 2335, 2339, 2344, 2347, 2358, 2361, 2366,
		2373, 2380, 2383, 2392, 2398, 2404, 2408, 2421, 2434, 2438, 2445, 2451,
		2454, 2460, 2464, 2469, 2472, 2476, 2481, 2484, 2491, 2494, 2500, 2503,
		2510, 2513, 2516, 2519, 2527, 2535, 2541, 2544, 2552, 2559, 2565, 2568,
		2571, 2574, 2585, 2587, 2589, 2597, 2604, 2606, 2612, 2644, 2652, 2654,
		2662, 2665, 2679, 2683, 2689, 2700, 2712, 2715, 2722, 2729, 2737, 2740,
		2743, 2757, 2762, 2765, 2767, 2781, 2786, 2789, 2796, 2798, 2804, 2809,
		2813, 2816, 2819, 2827, 2831, 2838, 2841, 2844, 2852, 2861, 2864, 2871,
		2883, 2907, 2915, 2921, 2925, 2931, 2937, 2950, 2952, 2960, 2971, 2977,
		2983, 2986, 2992, 2995, 3002, 3012, 3019, 3025, 3038, 3042, 3051, 3061,
		3065, 3067, 3085, 3089, 3102, 3106, 3123, 3133, 3139, 3147, 3154, 3161,
		3164, 3176, 3180, 3197, 3222, 3224, 3230, 3234, 3240, 3244, 3250, 3254,
		3259, 3268, 3272, 3275, 3278, 3281, 3285, 3288, 3294, 3300, 3302, 3306,
		3310, 3313, 3316, 3319, 3323, 3327, 3330, 3333, 3336, 3338, 3348, 3362,
		3369, 3377, 3389, 3407, 3414, 3424, 3426, 3430, 3433, 3440, 3450, 3454,
		3463, 3473, 3496, 3507, 3519, 3528, 3541, 3545, 3552, 3555, 3558, 3564,
		3567, 3570, 3578, 3581, 3587, 3590, 3596, 3599, 3602, 3608, 3611, 3615,
		3623, 3628, 3630, 3632, 3635, 3639, 3644, 3648, 3653, 3657, 3665, 3674,
		3678, 3681, 3684, 3691, 3694, 3719, 3727, 3736, 3741, 3743, 3745, 3761,
		3765, 3775, 3778, 3782, 3789, 3796, 3803, 3810, 3817, 3824, 3830, 3833,
		3839, 3842, 3845, 3864, 3875, 3885, 3890, 3897, 3904, 3911, 3926, 3930,
		3936, 3939, 3945, 3949, 3960, 3967, 3978, 3990, 3993, 4014, 4017, 4023,
		4028, 4033, 4036, 4043, 4055, 4063, 4070, 4077, 4079, 4086, 4093, 4097,
		4103, 4108, 4110, 4118, 4120, 4127, 4129, 4133, 4139, 4141, 4144, 4152,
		4159, 4165, 4170, 4174, 4188, 4193, 4206, 4208, 4215, 4223, 4227, 4232,
		4237, 4242, 4250, 4259, 4262, 4268, 4270, 4276, 4283, 4297, 4301, 4306,
		4312, 4320, 4327, 4330, 4334, 4339, 4344, 4351, 4363, 4369, 4383, 4386,
		4391, 4399, 4402, 4407, 4412, 4422, 4429, 4432, 4435, 4445, 4453, 4459,
		4465, 4470, 4475, 4478, 4481, 4484, 4487, 4490, 4493, 4496, 4499, 4502,
		4505, 4516, 4519, 4522, 4525, 4528, 4530, 4544, 4551, 4557, 4561, 4566,
		4573, 4578, 4587, 4589, 4595, 4598, 4602, 4605, 4608, 4622, 4651, 4686,
		4688, 4697, 4701, 4710, 4716, 4722, 4725, 4728, 4731, 4734, 4742, 4750,
		4753, 4756, 4767, 4773, 4776, 4778, 4789, 4793, 4796, 4799, 4802, 4805,
		4808, 4813, 4821, 4826, 4839, 4846, 4859, 4864, 4869, 4873, 4889, 4896,
		4902, 4906, 4916, 4924, 4935, 4940, 4953, 4956, 4966, 4969, 4980, 4990,
		4995, 4997, 5005, 5008, 5020, 5025, 5034, 5039, 5044, 5053, 5058, 5060,
		5066, 5068, 5071, 5077, 5084, 5096, 5099, 5109, 5113, 5116, 5125, 5130,
		5134, 5146, 5155, 5159, 5164, 5168, 5172, 5182, 5188, 5199, 5207, 5213,
		5216, 5219, 5222, 5225, 5229, 5232, 5237, 5247, 5253, 5262, 5277, 5286,
		5290, 5293, 5297, 5299, 5306, 5314, 5320, 5327, 5333, 5336, 5340, 5347,
		5350, 5353, 5360, 5362, 5367, 5371, 5384, 5386, 5388, 5397, 5399, 5403,
		5410, 5417, 5423, 5430, 5434, 5441, 5448, 5454, 5460, 5468, 5474, 5491,
		5497, 5508, 5514, 5516, 5524, 5530, 5536, 5543, 5551, 5554, 5565, 5576,
		5581, 5584, 5591, 5596, 5608, 5614, 5636, 5640, 5654, 5656, 5665, 5668,
		5675, 5678, 5686, 5691, 5696, 5704, 5713, 5720, 5725, 5728, 5734, 5755,
		5757, 5772, 5776, 5785, 5789, 5806, 5815, 5825, 5830, 5858, 5862, 5873,
		5881, 5886, 5898, 5910, 5912, 5914, 5927, 5932, 5934, 5939, 5946, 5956,
		5959, 5961, 5966, 5971, 5991, 5995, 5998, 6001, 6014, 6025, 6032, 6036,
		6041, 6044, 6048, 6056, 6061, 6067, 6076, 6085, 6095, 6101, 6120, 6123,
		6151, 6164, 6168, 6170, 6204, 6211, 6218, 6226, 6231, 6237, 6249, 6258,
		6261, 6268, 6273, 6277, 6280,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// DorisParserInit initializes any static state used to implement DorisParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewDorisParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func DorisParserInit() {
	staticData := &DorisParserParserStaticData
	staticData.once.Do(dorisparserParserInit)
}

// NewDorisParser produces a new parser instance for the optional input antlr.TokenStream.
func NewDorisParser(input antlr.TokenStream) *DorisParser {
	DorisParserInit()
	this := new(DorisParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &DorisParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "DorisParser.g4"

	return this
}

// Note that '@members' cannot be changed now, but this should have been 'globals'
// If you are looking to have variables for each instance, use '@structmembers'

var ansiSQLSyntax = false

// DorisParser tokens.
const (
	DorisParserEOF                     = antlr.TokenEOF
	DorisParserSEMICOLON               = 1
	DorisParserLEFT_PAREN              = 2
	DorisParserRIGHT_PAREN             = 3
	DorisParserCOMMA                   = 4
	DorisParserDOT                     = 5
	DorisParserDOTDOTDOT               = 6
	DorisParserLEFT_BRACKET            = 7
	DorisParserRIGHT_BRACKET           = 8
	DorisParserLEFT_BRACE              = 9
	DorisParserRIGHT_BRACE             = 10
	DorisParserACCOUNT_LOCK            = 11
	DorisParserACCOUNT_UNLOCK          = 12
	DorisParserACTIONS                 = 13
	DorisParserADD                     = 14
	DorisParserADMIN                   = 15
	DorisParserAFTER                   = 16
	DorisParserAGG_STATE               = 17
	DorisParserAGGREGATE               = 18
	DorisParserALIAS                   = 19
	DorisParserALL                     = 20
	DorisParserALTER                   = 21
	DorisParserANALYZE                 = 22
	DorisParserANALYZED                = 23
	DorisParserANALYZER                = 24
	DorisParserAND                     = 25
	DorisParserANTI                    = 26
	DorisParserAPPEND                  = 27
	DorisParserARRAY                   = 28
	DorisParserAS                      = 29
	DorisParserASC                     = 30
	DorisParserAT                      = 31
	DorisParserAUTHORS                 = 32
	DorisParserAUTO                    = 33
	DorisParserAUTO_INCREMENT          = 34
	DorisParserALWAYS                  = 35
	DorisParserBACKEND                 = 36
	DorisParserBACKENDS                = 37
	DorisParserBACKUP                  = 38
	DorisParserBEGIN                   = 39
	DorisParserBELONG                  = 40
	DorisParserBETWEEN                 = 41
	DorisParserBIGINT                  = 42
	DorisParserBIN                     = 43
	DorisParserBINARY                  = 44
	DorisParserBINLOG                  = 45
	DorisParserBITAND                  = 46
	DorisParserBITMAP                  = 47
	DorisParserBITMAP_EMPTY            = 48
	DorisParserBITMAP_UNION            = 49
	DorisParserBITOR                   = 50
	DorisParserBITXOR                  = 51
	DorisParserBLOB                    = 52
	DorisParserBOOLEAN                 = 53
	DorisParserBRANCH                  = 54
	DorisParserBRIEF                   = 55
	DorisParserBROKER                  = 56
	DorisParserBUCKETS                 = 57
	DorisParserBUILD                   = 58
	DorisParserBUILTIN                 = 59
	DorisParserBULK                    = 60
	DorisParserBY                      = 61
	DorisParserCACHE                   = 62
	DorisParserCACHED                  = 63
	DorisParserCALL                    = 64
	DorisParserCANCEL                  = 65
	DorisParserCASE                    = 66
	DorisParserCAST                    = 67
	DorisParserCATALOG                 = 68
	DorisParserCATALOGS                = 69
	DorisParserCHAIN                   = 70
	DorisParserCHAR                    = 71
	DorisParserCHARSET                 = 72
	DorisParserCHECK                   = 73
	DorisParserCLEAN                   = 74
	DorisParserCLUSTER                 = 75
	DorisParserCLUSTERS                = 76
	DorisParserCOLLATE                 = 77
	DorisParserCOLLATION               = 78
	DorisParserCOLLECT                 = 79
	DorisParserCOLOCATE                = 80
	DorisParserCOLUMN                  = 81
	DorisParserCOLUMNS                 = 82
	DorisParserCOMMENT                 = 83
	DorisParserCOMMIT                  = 84
	DorisParserCOMMITTED               = 85
	DorisParserCOMPACT                 = 86
	DorisParserCOMPLETE                = 87
	DorisParserCOMPRESS_TYPE           = 88
	DorisParserCOMPUTE                 = 89
	DorisParserCONDITIONS              = 90
	DorisParserCONFIG                  = 91
	DorisParserCONNECTION              = 92
	DorisParserCONNECTION_ID           = 93
	DorisParserCONSISTENT              = 94
	DorisParserCONSTRAINT              = 95
	DorisParserCONSTRAINTS             = 96
	DorisParserCONVERT                 = 97
	DorisParserCONVERT_LSC             = 98
	DorisParserCOPY                    = 99
	DorisParserCOUNT                   = 100
	DorisParserCREATE                  = 101
	DorisParserCREATION                = 102
	DorisParserCRON                    = 103
	DorisParserCROSS                   = 104
	DorisParserCUBE                    = 105
	DorisParserCURRENT                 = 106
	DorisParserCURRENT_CATALOG         = 107
	DorisParserCURRENT_DATE            = 108
	DorisParserCURRENT_TIME            = 109
	DorisParserCURRENT_TIMESTAMP       = 110
	DorisParserCURRENT_USER            = 111
	DorisParserDATA                    = 112
	DorisParserDATABASE                = 113
	DorisParserDATABASES               = 114
	DorisParserDATE                    = 115
	DorisParserDATETIME                = 116
	DorisParserDATETIMEV2              = 117
	DorisParserDATEV2                  = 118
	DorisParserDATETIMEV1              = 119
	DorisParserDATEV1                  = 120
	DorisParserDAY                     = 121
	DorisParserDAYS                    = 122
	DorisParserDECIMAL                 = 123
	DorisParserDECIMALV2               = 124
	DorisParserDECIMALV3               = 125
	DorisParserDECOMMISSION            = 126
	DorisParserDEFAULT                 = 127
	DorisParserDEFERRED                = 128
	DorisParserDELETE                  = 129
	DorisParserDEMAND                  = 130
	DorisParserDESC                    = 131
	DorisParserDESCRIBE                = 132
	DorisParserDIAGNOSE                = 133
	DorisParserDIAGNOSIS               = 134
	DorisParserDICTIONARIES            = 135
	DorisParserDICTIONARY              = 136
	DorisParserDISK                    = 137
	DorisParserDISTINCT                = 138
	DorisParserDISTINCTPC              = 139
	DorisParserDISTINCTPCSA            = 140
	DorisParserDISTRIBUTED             = 141
	DorisParserDISTRIBUTION            = 142
	DorisParserDIV                     = 143
	DorisParserDO                      = 144
	DorisParserDORIS_INTERNAL_TABLE_ID = 145
	DorisParserDOUBLE                  = 146
	DorisParserDROP                    = 147
	DorisParserDROPP                   = 148
	DorisParserDUAL                    = 149
	DorisParserDUMP                    = 150
	DorisParserDUPLICATE               = 151
	DorisParserDYNAMIC                 = 152
	DorisParserE                       = 153
	DorisParserELSE                    = 154
	DorisParserENABLE                  = 155
	DorisParserENCRYPTKEY              = 156
	DorisParserENCRYPTKEYS             = 157
	DorisParserEND                     = 158
	DorisParserENDS                    = 159
	DorisParserENGINE                  = 160
	DorisParserENGINES                 = 161
	DorisParserENTER                   = 162
	DorisParserERRORS                  = 163
	DorisParserEVENTS                  = 164
	DorisParserEVERY                   = 165
	DorisParserEXCEPT                  = 166
	DorisParserEXCLUDE                 = 167
	DorisParserEXECUTE                 = 168
	DorisParserEXISTS                  = 169
	DorisParserEXPIRED                 = 170
	DorisParserEXPLAIN                 = 171
	DorisParserEXPORT                  = 172
	DorisParserEXTENDED                = 173
	DorisParserEXTERNAL                = 174
	DorisParserEXTRACT                 = 175
	DorisParserFAILED_LOGIN_ATTEMPTS   = 176
	DorisParserFALSE                   = 177
	DorisParserFAST                    = 178
	DorisParserFEATURE                 = 179
	DorisParserFIELDS                  = 180
	DorisParserFILE                    = 181
	DorisParserFILTER                  = 182
	DorisParserFIRST                   = 183
	DorisParserFLOAT                   = 184
	DorisParserFOLLOWER                = 185
	DorisParserFOLLOWING               = 186
	DorisParserFOR                     = 187
	DorisParserFOREIGN                 = 188
	DorisParserFORCE                   = 189
	DorisParserFORMAT                  = 190
	DorisParserFREE                    = 191
	DorisParserFROM                    = 192
	DorisParserFRONTEND                = 193
	DorisParserFRONTENDS               = 194
	DorisParserFULL                    = 195
	DorisParserFUNCTION                = 196
	DorisParserFUNCTIONS               = 197
	DorisParserGENERATED               = 198
	DorisParserGENERIC                 = 199
	DorisParserGLOBAL                  = 200
	DorisParserGRANT                   = 201
	DorisParserGRANTS                  = 202
	DorisParserGRAPH                   = 203
	DorisParserGROUP                   = 204
	DorisParserGROUPING                = 205
	DorisParserGROUPS                  = 206
	DorisParserHASH                    = 207
	DorisParserHASH_MAP                = 208
	DorisParserHAVING                  = 209
	DorisParserHDFS                    = 210
	DorisParserHELP                    = 211
	DorisParserHISTOGRAM               = 212
	DorisParserHLL                     = 213
	DorisParserHLL_UNION               = 214
	DorisParserHOSTNAME                = 215
	DorisParserHOTSPOT                 = 216
	DorisParserHOUR                    = 217
	DorisParserHOURS                   = 218
	DorisParserHUB                     = 219
	DorisParserIDENTIFIED              = 220
	DorisParserIF                      = 221
	DorisParserIGNORE                  = 222
	DorisParserIMMEDIATE               = 223
	DorisParserIN                      = 224
	DorisParserINCREMENTAL             = 225
	DorisParserINDEX                   = 226
	DorisParserINDEXES                 = 227
	DorisParserINFILE                  = 228
	DorisParserINNER                   = 229
	DorisParserINSERT                  = 230
	DorisParserINSTALL                 = 231
	DorisParserINT                     = 232
	DorisParserINTEGER                 = 233
	DorisParserINTERMEDIATE            = 234
	DorisParserINTERSECT               = 235
	DorisParserINTERVAL                = 236
	DorisParserINTO                    = 237
	DorisParserINVERTED                = 238
	DorisParserIP_TRIE                 = 239
	DorisParserIPV4                    = 240
	DorisParserIPV6                    = 241
	DorisParserIS                      = 242
	DorisParserIS_NOT_NULL_PRED        = 243
	DorisParserIS_NULL_PRED            = 244
	DorisParserISNULL                  = 245
	DorisParserISOLATION               = 246
	DorisParserJOB                     = 247
	DorisParserJOBS                    = 248
	DorisParserJOIN                    = 249
	DorisParserJSON                    = 250
	DorisParserJSONB                   = 251
	DorisParserKEY                     = 252
	DorisParserKEYS                    = 253
	DorisParserKILL                    = 254
	DorisParserLABEL                   = 255
	DorisParserLARGEINT                = 256
	DorisParserLAYOUT                  = 257
	DorisParserLAST                    = 258
	DorisParserLATERAL                 = 259
	DorisParserLDAP                    = 260
	DorisParserLDAP_ADMIN_PASSWORD     = 261
	DorisParserLEFT                    = 262
	DorisParserLESS                    = 263
	DorisParserLEVEL                   = 264
	DorisParserLIKE                    = 265
	DorisParserLIMIT                   = 266
	DorisParserLINES                   = 267
	DorisParserLINK                    = 268
	DorisParserLIST                    = 269
	DorisParserLOAD                    = 270
	DorisParserLOCAL                   = 271
	DorisParserLOCALTIME               = 272
	DorisParserLOCALTIMESTAMP          = 273
	DorisParserLOCATION                = 274
	DorisParserLOCK                    = 275
	DorisParserLOGICAL                 = 276
	DorisParserLOW_PRIORITY            = 277
	DorisParserMANUAL                  = 278
	DorisParserMAP                     = 279
	DorisParserMATCH                   = 280
	DorisParserMATCH_ALL               = 281
	DorisParserMATCH_ANY               = 282
	DorisParserMATCH_PHRASE            = 283
	DorisParserMATCH_PHRASE_EDGE       = 284
	DorisParserMATCH_PHRASE_PREFIX     = 285
	DorisParserMATCH_REGEXP            = 286
	DorisParserMATERIALIZED            = 287
	DorisParserMAX                     = 288
	DorisParserMAXVALUE                = 289
	DorisParserMEMO                    = 290
	DorisParserMERGE                   = 291
	DorisParserMIGRATE                 = 292
	DorisParserMIGRATIONS              = 293
	DorisParserMIN                     = 294
	DorisParserMINUS                   = 295
	DorisParserMINUTE                  = 296
	DorisParserMINUTES                 = 297
	DorisParserMODIFY                  = 298
	DorisParserMONTH                   = 299
	DorisParserMTMV                    = 300
	DorisParserNAME                    = 301
	DorisParserNAMES                   = 302
	DorisParserNATURAL                 = 303
	DorisParserNEGATIVE                = 304
	DorisParserNEVER                   = 305
	DorisParserNEXT                    = 306
	DorisParserNGRAM_BF                = 307
	DorisParserNO                      = 308
	DorisParserNO_USE_MV               = 309
	DorisParserNON_NULLABLE            = 310
	DorisParserNOT                     = 311
	DorisParserNULL                    = 312
	DorisParserNULLS                   = 313
	DorisParserOBSERVER                = 314
	DorisParserOF                      = 315
	DorisParserOFFSET                  = 316
	DorisParserON                      = 317
	DorisParserONLY                    = 318
	DorisParserOPEN                    = 319
	DorisParserOPTIMIZED               = 320
	DorisParserOR                      = 321
	DorisParserORDER                   = 322
	DorisParserOUTER                   = 323
	DorisParserOUTFILE                 = 324
	DorisParserOVER                    = 325
	DorisParserOVERWRITE               = 326
	DorisParserPARAMETER               = 327
	DorisParserPARSED                  = 328
	DorisParserPARTITION               = 329
	DorisParserPARTITIONS              = 330
	DorisParserPASSWORD                = 331
	DorisParserPASSWORD_EXPIRE         = 332
	DorisParserPASSWORD_HISTORY        = 333
	DorisParserPASSWORD_LOCK_TIME      = 334
	DorisParserPASSWORD_REUSE          = 335
	DorisParserPATH                    = 336
	DorisParserPAUSE                   = 337
	DorisParserPERCENT                 = 338
	DorisParserPERIOD                  = 339
	DorisParserPERMISSIVE              = 340
	DorisParserPHYSICAL                = 341
	DorisParserPI                      = 342
	DorisParserPLACEHOLDER             = 343
	DorisParserPLAN                    = 344
	DorisParserPLAY                    = 345
	DorisParserPRIVILEGES              = 346
	DorisParserPROCESS                 = 347
	DorisParserPLUGIN                  = 348
	DorisParserPLUGINS                 = 349
	DorisParserPOLICY                  = 350
	DorisParserPRECEDING               = 351
	DorisParserPREPARE                 = 352
	DorisParserPRIMARY                 = 353
	DorisParserPROC                    = 354
	DorisParserPROCEDURE               = 355
	DorisParserPROCESSLIST             = 356
	DorisParserPROFILE                 = 357
	DorisParserPROPERTIES              = 358
	DorisParserPROPERTY                = 359
	DorisParserQUANTILE_STATE          = 360
	DorisParserQUANTILE_UNION          = 361
	DorisParserQUERY                   = 362
	DorisParserQUEUED                  = 363
	DorisParserQUOTA                   = 364
	DorisParserQUALIFY                 = 365
	DorisParserQUARTER                 = 366
	DorisParserRANDOM                  = 367
	DorisParserRANGE                   = 368
	DorisParserREAD                    = 369
	DorisParserREAL                    = 370
	DorisParserREBALANCE               = 371
	DorisParserRECENT                  = 372
	DorisParserRECOVER                 = 373
	DorisParserRECYCLE                 = 374
	DorisParserREFRESH                 = 375
	DorisParserREFERENCES              = 376
	DorisParserREGEXP                  = 377
	DorisParserRELEASE                 = 378
	DorisParserRENAME                  = 379
	DorisParserREPAIR                  = 380
	DorisParserREPEATABLE              = 381
	DorisParserREPLACE                 = 382
	DorisParserREPLACE_IF_NOT_NULL     = 383
	DorisParserREPLAYER                = 384
	DorisParserREPLICA                 = 385
	DorisParserREPOSITORIES            = 386
	DorisParserREPOSITORY              = 387
	DorisParserRESOURCE                = 388
	DorisParserRESOURCES               = 389
	DorisParserRESTORE                 = 390
	DorisParserRESTRICTIVE             = 391
	DorisParserRESUME                  = 392
	DorisParserRETAIN                  = 393
	DorisParserRETENTION               = 394
	DorisParserRETURNS                 = 395
	DorisParserREVOKE                  = 396
	DorisParserREWRITTEN               = 397
	DorisParserRIGHT                   = 398
	DorisParserRLIKE                   = 399
	DorisParserROLE                    = 400
	DorisParserROLES                   = 401
	DorisParserROLLBACK                = 402
	DorisParserROLLUP                  = 403
	DorisParserROUTINE                 = 404
	DorisParserROW                     = 405
	DorisParserROWS                    = 406
	DorisParserS3                      = 407
	DorisParserSAMPLE                  = 408
	DorisParserSCHEDULE                = 409
	DorisParserSCHEDULER               = 410
	DorisParserSCHEMA                  = 411
	DorisParserSCHEMAS                 = 412
	DorisParserSECOND                  = 413
	DorisParserSELECT                  = 414
	DorisParserSEMI                    = 415
	DorisParserSERIALIZABLE            = 416
	DorisParserSESSION                 = 417
	DorisParserSESSION_USER            = 418
	DorisParserSET                     = 419
	DorisParserSETS                    = 420
	DorisParserSET_SESSION_VARIABLE    = 421
	DorisParserSHAPE                   = 422
	DorisParserSHOW                    = 423
	DorisParserSIGNED                  = 424
	DorisParserSKEW                    = 425
	DorisParserSMALLINT                = 426
	DorisParserSNAPSHOT                = 427
	DorisParserSNAPSHOTS               = 428
	DorisParserSONAME                  = 429
	DorisParserSPLIT                   = 430
	DorisParserSQL                     = 431
	DorisParserSQL_BLOCK_RULE          = 432
	DorisParserSTAGE                   = 433
	DorisParserSTAGES                  = 434
	DorisParserSTART                   = 435
	DorisParserSTARTS                  = 436
	DorisParserSTATS                   = 437
	DorisParserSTATUS                  = 438
	DorisParserSTOP                    = 439
	DorisParserSTORAGE                 = 440
	DorisParserSTREAM                  = 441
	DorisParserSTREAMING               = 442
	DorisParserSTRING                  = 443
	DorisParserSTRUCT                  = 444
	DorisParserSUM                     = 445
	DorisParserSUPERUSER               = 446
	DorisParserSWITCH                  = 447
	DorisParserSYNC                    = 448
	DorisParserSYSTEM                  = 449
	DorisParserTABLE                   = 450
	DorisParserTABLES                  = 451
	DorisParserTABLESAMPLE             = 452
	DorisParserTABLET                  = 453
	DorisParserTABLETS                 = 454
	DorisParserTAG                     = 455
	DorisParserTASK                    = 456
	DorisParserTASKS                   = 457
	DorisParserTEMPORARY               = 458
	DorisParserTERMINATED              = 459
	DorisParserTEXT                    = 460
	DorisParserTHAN                    = 461
	DorisParserTHEN                    = 462
	DorisParserTIME                    = 463
	DorisParserTIMESTAMP               = 464
	DorisParserTINYINT                 = 465
	DorisParserTO                      = 466
	DorisParserTOKENIZER               = 467
	DorisParserTOKEN_FILTER            = 468
	DorisParserTRANSACTION             = 469
	DorisParserTRASH                   = 470
	DorisParserTREE                    = 471
	DorisParserTRIGGERS                = 472
	DorisParserTRIM                    = 473
	DorisParserTRUE                    = 474
	DorisParserTRUNCATE                = 475
	DorisParserTYPE                    = 476
	DorisParserTYPECAST                = 477
	DorisParserTYPES                   = 478
	DorisParserUNBOUNDED               = 479
	DorisParserUNCOMMITTED             = 480
	DorisParserUNINSTALL               = 481
	DorisParserUNION                   = 482
	DorisParserUNIQUE                  = 483
	DorisParserUNLOCK                  = 484
	DorisParserUNSET                   = 485
	DorisParserUNSIGNED                = 486
	DorisParserUP                      = 487
	DorisParserUPDATE                  = 488
	DorisParserUSE                     = 489
	DorisParserUSER                    = 490
	DorisParserUSE_MV                  = 491
	DorisParserUSING                   = 492
	DorisParserVALUE                   = 493
	DorisParserVALUES                  = 494
	DorisParserVARCHAR                 = 495
	DorisParserVARIABLE                = 496
	DorisParserVARIABLES               = 497
	DorisParserVARIANT                 = 498
	DorisParserVAULT                   = 499
	DorisParserVAULTS                  = 500
	DorisParserVERBOSE                 = 501
	DorisParserVERSION                 = 502
	DorisParserVIEW                    = 503
	DorisParserVIEWS                   = 504
	DorisParserWARM                    = 505
	DorisParserWARNINGS                = 506
	DorisParserWEEK                    = 507
	DorisParserWHEN                    = 508
	DorisParserWHERE                   = 509
	DorisParserWHITELIST               = 510
	DorisParserWITH                    = 511
	DorisParserWORK                    = 512
	DorisParserWORKLOAD                = 513
	DorisParserWRITE                   = 514
	DorisParserXOR                     = 515
	DorisParserYEAR                    = 516
	DorisParserEQ                      = 517
	DorisParserNSEQ                    = 518
	DorisParserNEQ                     = 519
	DorisParserLT                      = 520
	DorisParserLTE                     = 521
	DorisParserGT                      = 522
	DorisParserGTE                     = 523
	DorisParserPLUS                    = 524
	DorisParserSUBTRACT                = 525
	DorisParserASTERISK                = 526
	DorisParserSLASH                   = 527
	DorisParserMOD                     = 528
	DorisParserTILDE                   = 529
	DorisParserAMPERSAND               = 530
	DorisParserLOGICALAND              = 531
	DorisParserLOGICALNOT              = 532
	DorisParserPIPE                    = 533
	DorisParserDOUBLEPIPES             = 534
	DorisParserHAT                     = 535
	DorisParserCOLON                   = 536
	DorisParserARROW                   = 537
	DorisParserHINT_START              = 538
	DorisParserHINT_END                = 539
	DorisParserCOMMENT_START           = 540
	DorisParserATSIGN                  = 541
	DorisParserDOUBLEATSIGN            = 542
	DorisParserSTRING_LITERAL          = 543
	DorisParserLEADING_STRING          = 544
	DorisParserBIGINT_LITERAL          = 545
	DorisParserSMALLINT_LITERAL        = 546
	DorisParserTINYINT_LITERAL         = 547
	DorisParserINTEGER_VALUE           = 548
	DorisParserEXPONENT_VALUE          = 549
	DorisParserDECIMAL_VALUE           = 550
	DorisParserBIGDECIMAL_LITERAL      = 551
	DorisParserIDENTIFIER              = 552
	DorisParserBACKQUOTED_IDENTIFIER   = 553
	DorisParserSIMPLE_COMMENT          = 554
	DorisParserBRACKETED_COMMENT       = 555
	DorisParserFROM_DUAL               = 556
	DorisParserWS                      = 557
	DorisParserUNRECOGNIZED            = 558
)

// DorisParser rules.
const (
	DorisParserRULE_multiStatements                = 0
	DorisParserRULE_singleStatement                = 1
	DorisParserRULE_statement                      = 2
	DorisParserRULE_statementBase                  = 3
	DorisParserRULE_unsupportedStatement           = 4
	DorisParserRULE_materializedViewStatement      = 5
	DorisParserRULE_supportedJobStatement          = 6
	DorisParserRULE_constraintStatement            = 7
	DorisParserRULE_supportedDmlStatement          = 8
	DorisParserRULE_supportedCreateStatement       = 9
	DorisParserRULE_dictionaryColumnDefs           = 10
	DorisParserRULE_dictionaryColumnDef            = 11
	DorisParserRULE_supportedAlterStatement        = 12
	DorisParserRULE_supportedDropStatement         = 13
	DorisParserRULE_supportedShowStatement         = 14
	DorisParserRULE_supportedLoadStatement         = 15
	DorisParserRULE_supportedKillStatement         = 16
	DorisParserRULE_supportedOtherStatement        = 17
	DorisParserRULE_unsupportedOtherStatement      = 18
	DorisParserRULE_warmUpItem                     = 19
	DorisParserRULE_lockTable                      = 20
	DorisParserRULE_createRoutineLoad              = 21
	DorisParserRULE_unsupportedLoadStatement       = 22
	DorisParserRULE_loadProperty                   = 23
	DorisParserRULE_importSequenceStatement        = 24
	DorisParserRULE_importDeleteOnStatement        = 25
	DorisParserRULE_importWhereStatement           = 26
	DorisParserRULE_importPrecedingFilterStatement = 27
	DorisParserRULE_importColumnsStatement         = 28
	DorisParserRULE_importColumnDesc               = 29
	DorisParserRULE_supportedRefreshStatement      = 30
	DorisParserRULE_supportedCleanStatement        = 31
	DorisParserRULE_supportedCancelStatement       = 32
	DorisParserRULE_supportedAdminStatement        = 33
	DorisParserRULE_supportedRecoverStatement      = 34
	DorisParserRULE_unsupportedAdminStatement      = 35
	DorisParserRULE_baseTableRef                   = 36
	DorisParserRULE_wildWhere                      = 37
	DorisParserRULE_supportedTransactionStatement  = 38
	DorisParserRULE_supportedGrantRevokeStatement  = 39
	DorisParserRULE_privilege                      = 40
	DorisParserRULE_privilegeList                  = 41
	DorisParserRULE_alterSystemClause              = 42
	DorisParserRULE_dropRollupClause               = 43
	DorisParserRULE_addRollupClause                = 44
	DorisParserRULE_alterTableClause               = 45
	DorisParserRULE_createOrReplaceTagClause       = 46
	DorisParserRULE_createOrReplaceBranchClause    = 47
	DorisParserRULE_tagOptions                     = 48
	DorisParserRULE_branchOptions                  = 49
	DorisParserRULE_retainTime                     = 50
	DorisParserRULE_retentionSnapshot              = 51
	DorisParserRULE_minSnapshotsToKeep             = 52
	DorisParserRULE_timeValueWithUnit              = 53
	DorisParserRULE_columnPosition                 = 54
	DorisParserRULE_toRollup                       = 55
	DorisParserRULE_fromRollup                     = 56
	DorisParserRULE_supportedStatsStatement        = 57
	DorisParserRULE_unsupportedStatsStatement      = 58
	DorisParserRULE_analyzeProperties              = 59
	DorisParserRULE_workloadPolicyActions          = 60
	DorisParserRULE_workloadPolicyAction           = 61
	DorisParserRULE_workloadPolicyConditions       = 62
	DorisParserRULE_workloadPolicyCondition        = 63
	DorisParserRULE_storageBackend                 = 64
	DorisParserRULE_passwordOption                 = 65
	DorisParserRULE_functionArguments              = 66
	DorisParserRULE_dataTypeList                   = 67
	DorisParserRULE_supportedSetStatement          = 68
	DorisParserRULE_optionWithType                 = 69
	DorisParserRULE_optionWithoutType              = 70
	DorisParserRULE_variable                       = 71
	DorisParserRULE_transactionAccessMode          = 72
	DorisParserRULE_isolationLevel                 = 73
	DorisParserRULE_supportedUnsetStatement        = 74
	DorisParserRULE_supportedUseStatement          = 75
	DorisParserRULE_stageAndPattern                = 76
	DorisParserRULE_supportedDescribeStatement     = 77
	DorisParserRULE_constraint                     = 78
	DorisParserRULE_partitionSpec                  = 79
	DorisParserRULE_partitionTable                 = 80
	DorisParserRULE_identityOrFunctionList         = 81
	DorisParserRULE_identityOrFunction             = 82
	DorisParserRULE_dataDesc                       = 83
	DorisParserRULE_statementScope                 = 84
	DorisParserRULE_buildMode                      = 85
	DorisParserRULE_refreshTrigger                 = 86
	DorisParserRULE_refreshSchedule                = 87
	DorisParserRULE_refreshMethod                  = 88
	DorisParserRULE_mvPartition                    = 89
	DorisParserRULE_identifierOrText               = 90
	DorisParserRULE_identifierOrTextOrAsterisk     = 91
	DorisParserRULE_multipartIdentifierOrAsterisk  = 92
	DorisParserRULE_identifierOrAsterisk           = 93
	DorisParserRULE_userIdentify                   = 94
	DorisParserRULE_grantUserIdentify              = 95
	DorisParserRULE_explain                        = 96
	DorisParserRULE_explainCommand                 = 97
	DorisParserRULE_planType                       = 98
	DorisParserRULE_replayCommand                  = 99
	DorisParserRULE_replayType                     = 100
	DorisParserRULE_mergeType                      = 101
	DorisParserRULE_preFilterClause                = 102
	DorisParserRULE_deleteOnClause                 = 103
	DorisParserRULE_sequenceColClause              = 104
	DorisParserRULE_colFromPath                    = 105
	DorisParserRULE_colMappingList                 = 106
	DorisParserRULE_mappingExpr                    = 107
	DorisParserRULE_withRemoteStorageSystem        = 108
	DorisParserRULE_resourceDesc                   = 109
	DorisParserRULE_mysqlDataDesc                  = 110
	DorisParserRULE_skipLines                      = 111
	DorisParserRULE_outFileClause                  = 112
	DorisParserRULE_query                          = 113
	DorisParserRULE_queryTerm                      = 114
	DorisParserRULE_setQuantifier                  = 115
	DorisParserRULE_queryPrimary                   = 116
	DorisParserRULE_querySpecification             = 117
	DorisParserRULE_cte                            = 118
	DorisParserRULE_aliasQuery                     = 119
	DorisParserRULE_columnAliases                  = 120
	DorisParserRULE_selectClause                   = 121
	DorisParserRULE_selectColumnClause             = 122
	DorisParserRULE_whereClause                    = 123
	DorisParserRULE_fromClause                     = 124
	DorisParserRULE_intoClause                     = 125
	DorisParserRULE_bulkCollectClause              = 126
	DorisParserRULE_tableRow                       = 127
	DorisParserRULE_relations                      = 128
	DorisParserRULE_relation                       = 129
	DorisParserRULE_joinRelation                   = 130
	DorisParserRULE_distributeType                 = 131
	DorisParserRULE_relationHint                   = 132
	DorisParserRULE_aggClause                      = 133
	DorisParserRULE_groupingElement                = 134
	DorisParserRULE_groupingSet                    = 135
	DorisParserRULE_havingClause                   = 136
	DorisParserRULE_qualifyClause                  = 137
	DorisParserRULE_selectHint                     = 138
	DorisParserRULE_hintStatement                  = 139
	DorisParserRULE_hintAssignment                 = 140
	DorisParserRULE_updateAssignment               = 141
	DorisParserRULE_updateAssignmentSeq            = 142
	DorisParserRULE_lateralView                    = 143
	DorisParserRULE_queryOrganization              = 144
	DorisParserRULE_sortClause                     = 145
	DorisParserRULE_sortItem                       = 146
	DorisParserRULE_limitClause                    = 147
	DorisParserRULE_partitionClause                = 148
	DorisParserRULE_joinType                       = 149
	DorisParserRULE_joinCriteria                   = 150
	DorisParserRULE_identifierList                 = 151
	DorisParserRULE_identifierSeq                  = 152
	DorisParserRULE_optScanParams                  = 153
	DorisParserRULE_relationPrimary                = 154
	DorisParserRULE_materializedViewName           = 155
	DorisParserRULE_propertyClause                 = 156
	DorisParserRULE_propertyItemList               = 157
	DorisParserRULE_propertyItem                   = 158
	DorisParserRULE_propertyKey                    = 159
	DorisParserRULE_propertyValue                  = 160
	DorisParserRULE_tableAlias                     = 161
	DorisParserRULE_multipartIdentifier            = 162
	DorisParserRULE_simpleColumnDefs               = 163
	DorisParserRULE_simpleColumnDef                = 164
	DorisParserRULE_columnDefs                     = 165
	DorisParserRULE_columnDef                      = 166
	DorisParserRULE_indexDefs                      = 167
	DorisParserRULE_indexDef                       = 168
	DorisParserRULE_partitionsDef                  = 169
	DorisParserRULE_partitionDef                   = 170
	DorisParserRULE_lessThanPartitionDef           = 171
	DorisParserRULE_fixedPartitionDef              = 172
	DorisParserRULE_stepPartitionDef               = 173
	DorisParserRULE_inPartitionDef                 = 174
	DorisParserRULE_partitionValueList             = 175
	DorisParserRULE_partitionValueDef              = 176
	DorisParserRULE_rollupDefs                     = 177
	DorisParserRULE_rollupDef                      = 178
	DorisParserRULE_aggTypeDef                     = 179
	DorisParserRULE_tabletList                     = 180
	DorisParserRULE_inlineTable                    = 181
	DorisParserRULE_namedExpression                = 182
	DorisParserRULE_namedExpressionSeq             = 183
	DorisParserRULE_expression                     = 184
	DorisParserRULE_lambdaExpression               = 185
	DorisParserRULE_booleanExpression              = 186
	DorisParserRULE_rowConstructor                 = 187
	DorisParserRULE_rowConstructorItem             = 188
	DorisParserRULE_predicate                      = 189
	DorisParserRULE_valueExpression                = 190
	DorisParserRULE_primaryExpression              = 191
	DorisParserRULE_exceptOrReplace                = 192
	DorisParserRULE_castDataType                   = 193
	DorisParserRULE_functionCallExpression         = 194
	DorisParserRULE_functionIdentifier             = 195
	DorisParserRULE_functionNameIdentifier         = 196
	DorisParserRULE_windowSpec                     = 197
	DorisParserRULE_windowFrame                    = 198
	DorisParserRULE_frameUnits                     = 199
	DorisParserRULE_frameBoundary                  = 200
	DorisParserRULE_qualifiedName                  = 201
	DorisParserRULE_specifiedPartition             = 202
	DorisParserRULE_constant                       = 203
	DorisParserRULE_comparisonOperator             = 204
	DorisParserRULE_booleanValue                   = 205
	DorisParserRULE_whenClause                     = 206
	DorisParserRULE_interval                       = 207
	DorisParserRULE_unitIdentifier                 = 208
	DorisParserRULE_dataTypeWithNullable           = 209
	DorisParserRULE_dataType                       = 210
	DorisParserRULE_primitiveColType               = 211
	DorisParserRULE_complexColTypeList             = 212
	DorisParserRULE_complexColType                 = 213
	DorisParserRULE_commentSpec                    = 214
	DorisParserRULE_sample                         = 215
	DorisParserRULE_sampleMethod                   = 216
	DorisParserRULE_tableSnapshot                  = 217
	DorisParserRULE_errorCapturingIdentifier       = 218
	DorisParserRULE_errorCapturingIdentifierExtra  = 219
	DorisParserRULE_identifier                     = 220
	DorisParserRULE_strictIdentifier               = 221
	DorisParserRULE_quotedIdentifier               = 222
	DorisParserRULE_number                         = 223
	DorisParserRULE_nonReserved                    = 224
)

// IMultiStatementsContext is an interface to support dynamic dispatch.
type IMultiStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsMultiStatementsContext differentiates from other interfaces.
	IsMultiStatementsContext()
}

type MultiStatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiStatementsContext() *MultiStatementsContext {
	var p = new(MultiStatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_multiStatements
	return p
}

func InitEmptyMultiStatementsContext(p *MultiStatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_multiStatements
}

func (*MultiStatementsContext) IsMultiStatementsContext() {}

func NewMultiStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiStatementsContext {
	var p = new(MultiStatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_multiStatements

	return p
}

func (s *MultiStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiStatementsContext) EOF() antlr.TerminalNode {
	return s.GetToken(DorisParserEOF, 0)
}

func (s *MultiStatementsContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSEMICOLON)
}

func (s *MultiStatementsContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSEMICOLON, i)
}

func (s *MultiStatementsContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *MultiStatementsContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *MultiStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMultiStatements(s)
	}
}

func (s *MultiStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMultiStatements(s)
	}
}

func (p *DorisParser) MultiStatements() (localctx IMultiStatementsContext) {
	localctx = NewMultiStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, DorisParserRULE_multiStatements)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(453)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(450)
				p.Match(DorisParserSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(455)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(457)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&288231200791756804) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&171799741443) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&13194139795469) != 0) || ((int64((_la-201)) & ^0x3f) == 0 && ((int64(1)<<(_la-201))&9007200865354753) != 0) || _la == DorisParserLOAD || _la == DorisParserLOCK || ((int64((_la-337)) & ^0x3f) == 0 && ((int64(1)<<(_la-337))&621532276546601089) != 0) || ((int64((_la-402)) & ^0x3f) == 0 && ((int64(1)<<(_la-402))&105699147386881) != 0) || ((int64((_la-475)) & ^0x3f) == 0 && ((int64(1)<<(_la-475))&69793769025) != 0) {
		{
			p.SetState(456)
			p.Statement()
		}

	}
	p.SetState(467)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(460)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == DorisParserSEMICOLON {
				{
					p.SetState(459)
					p.Match(DorisParserSEMICOLON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(462)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(464)
				p.Statement()
			}

		}
		p.SetState(469)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(473)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserSEMICOLON {
		{
			p.SetState(470)
			p.Match(DorisParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(475)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(476)
		p.Match(DorisParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleStatementContext is an interface to support dynamic dispatch.
type ISingleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	Statement() IStatementContext

	// IsSingleStatementContext differentiates from other interfaces.
	IsSingleStatementContext()
}

type SingleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleStatementContext() *SingleStatementContext {
	var p = new(SingleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_singleStatement
	return p
}

func InitEmptySingleStatementContext(p *SingleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_singleStatement
}

func (*SingleStatementContext) IsSingleStatementContext() {}

func NewSingleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleStatementContext {
	var p = new(SingleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_singleStatement

	return p
}

func (s *SingleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleStatementContext) EOF() antlr.TerminalNode {
	return s.GetToken(DorisParserEOF, 0)
}

func (s *SingleStatementContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSEMICOLON)
}

func (s *SingleStatementContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSEMICOLON, i)
}

func (s *SingleStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SingleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSingleStatement(s)
	}
}

func (s *SingleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSingleStatement(s)
	}
}

func (p *DorisParser) SingleStatement() (localctx ISingleStatementContext) {
	localctx = NewSingleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, DorisParserRULE_singleStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(481)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(478)
				p.Match(DorisParserSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(483)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(485)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&288231200791756804) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&171799741443) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&13194139795469) != 0) || ((int64((_la-201)) & ^0x3f) == 0 && ((int64(1)<<(_la-201))&9007200865354753) != 0) || _la == DorisParserLOAD || _la == DorisParserLOCK || ((int64((_la-337)) & ^0x3f) == 0 && ((int64(1)<<(_la-337))&621532276546601089) != 0) || ((int64((_la-402)) & ^0x3f) == 0 && ((int64(1)<<(_la-402))&105699147386881) != 0) || ((int64((_la-475)) & ^0x3f) == 0 && ((int64(1)<<(_la-475))&69793769025) != 0) {
		{
			p.SetState(484)
			p.Statement()
		}

	}
	p.SetState(490)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserSEMICOLON {
		{
			p.SetState(487)
			p.Match(DorisParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(492)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(493)
		p.Match(DorisParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) CopyAll(ctx *StatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowCreateProcedureContext struct {
	StatementContext
	name IMultipartIdentifierContext
}

func NewShowCreateProcedureContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateProcedureContext {
	var p = new(ShowCreateProcedureContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowCreateProcedureContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *ShowCreateProcedureContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *ShowCreateProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateProcedureContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCreateProcedureContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowCreateProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(DorisParserPROCEDURE, 0)
}

func (s *ShowCreateProcedureContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCreateProcedure(s)
	}
}

func (s *ShowCreateProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCreateProcedure(s)
	}
}

type StatementBaseAliasContext struct {
	StatementContext
}

func NewStatementBaseAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StatementBaseAliasContext {
	var p = new(StatementBaseAliasContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *StatementBaseAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementBaseAliasContext) StatementBase() IStatementBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementBaseContext)
}

func (s *StatementBaseAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStatementBaseAlias(s)
	}
}

func (s *StatementBaseAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStatementBaseAlias(s)
	}
}

type ShowProcedureStatusContext struct {
	StatementContext
	pattern IValueExpressionContext
}

func NewShowProcedureStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowProcedureStatusContext {
	var p = new(ShowProcedureStatusContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowProcedureStatusContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *ShowProcedureStatusContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *ShowProcedureStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProcedureStatusContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowProcedureStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATUS, 0)
}

func (s *ShowProcedureStatusContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(DorisParserPROCEDURE, 0)
}

func (s *ShowProcedureStatusContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserFUNCTION, 0)
}

func (s *ShowProcedureStatusContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *ShowProcedureStatusContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *ShowProcedureStatusContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ShowProcedureStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowProcedureStatus(s)
	}
}

func (s *ShowProcedureStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowProcedureStatus(s)
	}
}

type CreateProcedureContext struct {
	StatementContext
	name IMultipartIdentifierContext
}

func NewCreateProcedureContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateProcedureContext {
	var p = new(CreateProcedureContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateProcedureContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CreateProcedureContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CreateProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateProcedureContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CreateProcedureContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CreateProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(DorisParserPROCEDURE, 0)
}

func (s *CreateProcedureContext) PROC() antlr.TerminalNode {
	return s.GetToken(DorisParserPROC, 0)
}

func (s *CreateProcedureContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateProcedureContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *CreateProcedureContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateProcedureContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *CreateProcedureContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisParserOR, 0)
}

func (s *CreateProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateProcedure(s)
	}
}

func (s *CreateProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateProcedure(s)
	}
}

type ShowConfigContext struct {
	StatementContext
	type_     antlr.Token
	pattern   IValueExpressionContext
	backendId antlr.Token
}

func NewShowConfigContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowConfigContext {
	var p = new(ShowConfigContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowConfigContext) GetType_() antlr.Token { return s.type_ }

func (s *ShowConfigContext) GetBackendId() antlr.Token { return s.backendId }

func (s *ShowConfigContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *ShowConfigContext) SetBackendId(v antlr.Token) { s.backendId = v }

func (s *ShowConfigContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *ShowConfigContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *ShowConfigContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowConfigContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowConfigContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(DorisParserCONFIG, 0)
}

func (s *ShowConfigContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(DorisParserFRONTEND, 0)
}

func (s *ShowConfigContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKEND, 0)
}

func (s *ShowConfigContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *ShowConfigContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *ShowConfigContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowConfigContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ShowConfigContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ShowConfigContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowConfig(s)
	}
}

func (s *ShowConfigContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowConfig(s)
	}
}

type CallProcedureContext struct {
	StatementContext
	name IMultipartIdentifierContext
}

func NewCallProcedureContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CallProcedureContext {
	var p = new(CallProcedureContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CallProcedureContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CallProcedureContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CallProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallProcedureContext) CALL() antlr.TerminalNode {
	return s.GetToken(DorisParserCALL, 0)
}

func (s *CallProcedureContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CallProcedureContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CallProcedureContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CallProcedureContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CallProcedureContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CallProcedureContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *CallProcedureContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *CallProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCallProcedure(s)
	}
}

func (s *CallProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCallProcedure(s)
	}
}

type DropProcedureContext struct {
	StatementContext
	name IMultipartIdentifierContext
}

func NewDropProcedureContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropProcedureContext {
	var p = new(DropProcedureContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropProcedureContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *DropProcedureContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *DropProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropProcedureContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(DorisParserPROCEDURE, 0)
}

func (s *DropProcedureContext) PROC() antlr.TerminalNode {
	return s.GetToken(DorisParserPROC, 0)
}

func (s *DropProcedureContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropProcedureContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropProcedureContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropProcedure(s)
	}
}

func (s *DropProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropProcedure(s)
	}
}

func (p *DorisParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, DorisParserRULE_statement)
	var _la int

	var _alt int

	p.SetState(569)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStatementBaseAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(495)
			p.StatementBase()
		}

	case 2:
		localctx = NewCallProcedureContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(496)
			p.Match(DorisParserCALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(497)

			var _x = p.MultipartIdentifier()

			localctx.(*CallProcedureContext).name = _x
		}
		{
			p.SetState(498)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(507)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305884869834611068) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4610552282352573437) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4539691388691605019) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&2845980307192511093) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&8572566566736488189) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-304588910535901189) != 0) || ((int64((_la-391)) & ^0x3f) == 0 && ((int64(1)<<(_la-391))&1188948054525295071) != 0) || ((int64((_la-455)) & ^0x3f) == 0 && ((int64(1)<<(_la-455))&2458964612221977455) != 0) || ((int64((_la-524)) & ^0x3f) == 0 && ((int64(1)<<(_la-524))&923779367) != 0) {
			{
				p.SetState(499)
				p.Expression()
			}
			p.SetState(504)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(500)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(501)
					p.Expression()
				}

				p.SetState(506)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(509)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewCreateProcedureContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(518)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserALTER:
			{
				p.SetState(511)
				p.Match(DorisParserALTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCREATE:
			{
				p.SetState(512)
				p.Match(DorisParserCREATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(515)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserOR {
				{
					p.SetState(513)
					p.Match(DorisParserOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(514)
					p.Match(DorisParserREPLACE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		case DorisParserREPLACE:
			{
				p.SetState(517)
				p.Match(DorisParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(520)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserPROC || _la == DorisParserPROCEDURE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(521)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateProcedureContext).name = _x
		}
		{
			p.SetState(522)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(526)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				p.SetState(523)
				p.MatchWildcard()

			}
			p.SetState(528)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(529)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(533)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				p.SetState(530)
				p.MatchWildcard()

			}
			p.SetState(535)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 4:
		localctx = NewDropProcedureContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(536)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(537)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserPROC || _la == DorisParserPROCEDURE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(540)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(538)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(539)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(542)

			var _x = p.MultipartIdentifier()

			localctx.(*DropProcedureContext).name = _x
		}

	case 5:
		localctx = NewShowProcedureStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(543)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(544)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserFUNCTION || _la == DorisParserPROCEDURE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(545)
			p.Match(DorisParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(549)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case DorisParserLIKE:
			{
				p.SetState(546)
				p.Match(DorisParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(547)

				var _x = p.valueExpression(0)

				localctx.(*ShowProcedureStatusContext).pattern = _x
			}

		case DorisParserWHERE:
			{
				p.SetState(548)
				p.WhereClause()
			}

		case DorisParserEOF, DorisParserSEMICOLON:

		default:
		}

	case 6:
		localctx = NewShowCreateProcedureContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(551)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(552)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(553)
			p.Match(DorisParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(554)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateProcedureContext).name = _x
		}

	case 7:
		localctx = NewShowConfigContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		p.SetState(556)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserADMIN {
			{
				p.SetState(555)
				p.Match(DorisParserADMIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(558)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(559)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowConfigContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserBACKEND || _la == DorisParserFRONTEND) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowConfigContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(560)
			p.Match(DorisParserCONFIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(563)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE {
			{
				p.SetState(561)
				p.Match(DorisParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(562)

				var _x = p.valueExpression(0)

				localctx.(*ShowConfigContext).pattern = _x
			}

		}
		p.SetState(567)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(565)
				p.Match(DorisParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(566)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*ShowConfigContext).backendId = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementBaseContext is an interface to support dynamic dispatch.
type IStatementBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStatementBaseContext differentiates from other interfaces.
	IsStatementBaseContext()
}

type StatementBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementBaseContext() *StatementBaseContext {
	var p = new(StatementBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_statementBase
	return p
}

func InitEmptyStatementBaseContext(p *StatementBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_statementBase
}

func (*StatementBaseContext) IsStatementBaseContext() {}

func NewStatementBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementBaseContext {
	var p = new(StatementBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_statementBase

	return p
}

func (s *StatementBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementBaseContext) CopyAll(ctx *StatementBaseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StatementBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SupportedSetStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedSetStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedSetStatementAliasContext {
	var p = new(SupportedSetStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedSetStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedSetStatementAliasContext) SupportedSetStatement() ISupportedSetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedSetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedSetStatementContext)
}

func (s *SupportedSetStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedSetStatementAlias(s)
	}
}

func (s *SupportedSetStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedSetStatementAlias(s)
	}
}

type ConstraintStatementAliasContext struct {
	StatementBaseContext
}

func NewConstraintStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstraintStatementAliasContext {
	var p = new(ConstraintStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *ConstraintStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintStatementAliasContext) ConstraintStatement() IConstraintStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintStatementContext)
}

func (s *ConstraintStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterConstraintStatementAlias(s)
	}
}

func (s *ConstraintStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitConstraintStatementAlias(s)
	}
}

type SupportedKillStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedKillStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedKillStatementAliasContext {
	var p = new(SupportedKillStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedKillStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedKillStatementAliasContext) SupportedKillStatement() ISupportedKillStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedKillStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedKillStatementContext)
}

func (s *SupportedKillStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedKillStatementAlias(s)
	}
}

func (s *SupportedKillStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedKillStatementAlias(s)
	}
}

type SupportedRecoverStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedRecoverStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedRecoverStatementAliasContext {
	var p = new(SupportedRecoverStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedRecoverStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedRecoverStatementAliasContext) SupportedRecoverStatement() ISupportedRecoverStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedRecoverStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedRecoverStatementContext)
}

func (s *SupportedRecoverStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedRecoverStatementAlias(s)
	}
}

func (s *SupportedRecoverStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedRecoverStatementAlias(s)
	}
}

type SupportedJobStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedJobStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedJobStatementAliasContext {
	var p = new(SupportedJobStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedJobStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedJobStatementAliasContext) SupportedJobStatement() ISupportedJobStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedJobStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedJobStatementContext)
}

func (s *SupportedJobStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedJobStatementAlias(s)
	}
}

func (s *SupportedJobStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedJobStatementAlias(s)
	}
}

type UnsupportedContext struct {
	StatementBaseContext
}

func NewUnsupportedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnsupportedContext {
	var p = new(UnsupportedContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *UnsupportedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedContext) UnsupportedStatement() IUnsupportedStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedStatementContext)
}

func (s *UnsupportedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUnsupported(s)
	}
}

func (s *UnsupportedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUnsupported(s)
	}
}

type StatementDefaultContext struct {
	StatementBaseContext
}

func NewStatementDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StatementDefaultContext {
	var p = new(StatementDefaultContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *StatementDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementDefaultContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *StatementDefaultContext) Explain() IExplainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainContext)
}

func (s *StatementDefaultContext) OutFileClause() IOutFileClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOutFileClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOutFileClauseContext)
}

func (s *StatementDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStatementDefault(s)
	}
}

func (s *StatementDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStatementDefault(s)
	}
}

type SupportedAdminStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedAdminStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedAdminStatementAliasContext {
	var p = new(SupportedAdminStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedAdminStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedAdminStatementAliasContext) SupportedAdminStatement() ISupportedAdminStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedAdminStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedAdminStatementContext)
}

func (s *SupportedAdminStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedAdminStatementAlias(s)
	}
}

func (s *SupportedAdminStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedAdminStatementAlias(s)
	}
}

type SupportedStatsStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedStatsStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedStatsStatementAliasContext {
	var p = new(SupportedStatsStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedStatsStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedStatsStatementAliasContext) SupportedStatsStatement() ISupportedStatsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedStatsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedStatsStatementContext)
}

func (s *SupportedStatsStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedStatsStatementAlias(s)
	}
}

func (s *SupportedStatsStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedStatsStatementAlias(s)
	}
}

type SupportedDescribeStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedDescribeStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedDescribeStatementAliasContext {
	var p = new(SupportedDescribeStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedDescribeStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedDescribeStatementAliasContext) SupportedDescribeStatement() ISupportedDescribeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedDescribeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedDescribeStatementContext)
}

func (s *SupportedDescribeStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedDescribeStatementAlias(s)
	}
}

func (s *SupportedDescribeStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedDescribeStatementAlias(s)
	}
}

type SupportedCancelStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedCancelStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedCancelStatementAliasContext {
	var p = new(SupportedCancelStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedCancelStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedCancelStatementAliasContext) SupportedCancelStatement() ISupportedCancelStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedCancelStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedCancelStatementContext)
}

func (s *SupportedCancelStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedCancelStatementAlias(s)
	}
}

func (s *SupportedCancelStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedCancelStatementAlias(s)
	}
}

type SupportedOtherStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedOtherStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedOtherStatementAliasContext {
	var p = new(SupportedOtherStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedOtherStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedOtherStatementAliasContext) SupportedOtherStatement() ISupportedOtherStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedOtherStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedOtherStatementContext)
}

func (s *SupportedOtherStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedOtherStatementAlias(s)
	}
}

func (s *SupportedOtherStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedOtherStatementAlias(s)
	}
}

type SupportedDmlStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedDmlStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedDmlStatementAliasContext {
	var p = new(SupportedDmlStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedDmlStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedDmlStatementAliasContext) SupportedDmlStatement() ISupportedDmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedDmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedDmlStatementContext)
}

func (s *SupportedDmlStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedDmlStatementAlias(s)
	}
}

func (s *SupportedDmlStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedDmlStatementAlias(s)
	}
}

type SupportedLoadStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedLoadStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedLoadStatementAliasContext {
	var p = new(SupportedLoadStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedLoadStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedLoadStatementAliasContext) SupportedLoadStatement() ISupportedLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedLoadStatementContext)
}

func (s *SupportedLoadStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedLoadStatementAlias(s)
	}
}

func (s *SupportedLoadStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedLoadStatementAlias(s)
	}
}

type SupportedTransactionStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedTransactionStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedTransactionStatementAliasContext {
	var p = new(SupportedTransactionStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedTransactionStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedTransactionStatementAliasContext) SupportedTransactionStatement() ISupportedTransactionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedTransactionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedTransactionStatementContext)
}

func (s *SupportedTransactionStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedTransactionStatementAlias(s)
	}
}

func (s *SupportedTransactionStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedTransactionStatementAlias(s)
	}
}

type SupportedGrantRevokeStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedGrantRevokeStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedGrantRevokeStatementAliasContext {
	var p = new(SupportedGrantRevokeStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedGrantRevokeStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedGrantRevokeStatementAliasContext) SupportedGrantRevokeStatement() ISupportedGrantRevokeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedGrantRevokeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedGrantRevokeStatementContext)
}

func (s *SupportedGrantRevokeStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedGrantRevokeStatementAlias(s)
	}
}

func (s *SupportedGrantRevokeStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedGrantRevokeStatementAlias(s)
	}
}

type SupportedAlterStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedAlterStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedAlterStatementAliasContext {
	var p = new(SupportedAlterStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedAlterStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedAlterStatementAliasContext) SupportedAlterStatement() ISupportedAlterStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedAlterStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedAlterStatementContext)
}

func (s *SupportedAlterStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedAlterStatementAlias(s)
	}
}

func (s *SupportedAlterStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedAlterStatementAlias(s)
	}
}

type SupportedCleanStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedCleanStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedCleanStatementAliasContext {
	var p = new(SupportedCleanStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedCleanStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedCleanStatementAliasContext) SupportedCleanStatement() ISupportedCleanStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedCleanStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedCleanStatementContext)
}

func (s *SupportedCleanStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedCleanStatementAlias(s)
	}
}

func (s *SupportedCleanStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedCleanStatementAlias(s)
	}
}

type SupportedUnsetStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedUnsetStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedUnsetStatementAliasContext {
	var p = new(SupportedUnsetStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedUnsetStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedUnsetStatementAliasContext) SupportedUnsetStatement() ISupportedUnsetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedUnsetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedUnsetStatementContext)
}

func (s *SupportedUnsetStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedUnsetStatementAlias(s)
	}
}

func (s *SupportedUnsetStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedUnsetStatementAlias(s)
	}
}

type SupportedUseStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedUseStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedUseStatementAliasContext {
	var p = new(SupportedUseStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedUseStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedUseStatementAliasContext) SupportedUseStatement() ISupportedUseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedUseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedUseStatementContext)
}

func (s *SupportedUseStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedUseStatementAlias(s)
	}
}

func (s *SupportedUseStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedUseStatementAlias(s)
	}
}

type MaterializedViewStatementAliasContext struct {
	StatementBaseContext
}

func NewMaterializedViewStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MaterializedViewStatementAliasContext {
	var p = new(MaterializedViewStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *MaterializedViewStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaterializedViewStatementAliasContext) MaterializedViewStatement() IMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaterializedViewStatementContext)
}

func (s *MaterializedViewStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMaterializedViewStatementAlias(s)
	}
}

func (s *MaterializedViewStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMaterializedViewStatementAlias(s)
	}
}

type SupportedDropStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedDropStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedDropStatementAliasContext {
	var p = new(SupportedDropStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedDropStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedDropStatementAliasContext) SupportedDropStatement() ISupportedDropStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedDropStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedDropStatementContext)
}

func (s *SupportedDropStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedDropStatementAlias(s)
	}
}

func (s *SupportedDropStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedDropStatementAlias(s)
	}
}

type SupportedCreateStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedCreateStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedCreateStatementAliasContext {
	var p = new(SupportedCreateStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedCreateStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedCreateStatementAliasContext) SupportedCreateStatement() ISupportedCreateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedCreateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedCreateStatementContext)
}

func (s *SupportedCreateStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedCreateStatementAlias(s)
	}
}

func (s *SupportedCreateStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedCreateStatementAlias(s)
	}
}

type SupportedShowStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedShowStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedShowStatementAliasContext {
	var p = new(SupportedShowStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedShowStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedShowStatementAliasContext) SupportedShowStatement() ISupportedShowStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedShowStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedShowStatementContext)
}

func (s *SupportedShowStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedShowStatementAlias(s)
	}
}

func (s *SupportedShowStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedShowStatementAlias(s)
	}
}

type SupportedRefreshStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedRefreshStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedRefreshStatementAliasContext {
	var p = new(SupportedRefreshStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedRefreshStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedRefreshStatementAliasContext) SupportedRefreshStatement() ISupportedRefreshStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedRefreshStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedRefreshStatementContext)
}

func (s *SupportedRefreshStatementAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedRefreshStatementAlias(s)
	}
}

func (s *SupportedRefreshStatementAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedRefreshStatementAlias(s)
	}
}

func (p *DorisParser) StatementBase() (localctx IStatementBaseContext) {
	localctx = NewStatementBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, DorisParserRULE_statementBase)
	var _la int

	p.SetState(602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStatementDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(572)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&1099511627779) != 0 {
			{
				p.SetState(571)
				p.Explain()
			}

		}
		{
			p.SetState(574)
			p.Query()
		}
		p.SetState(576)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserINTO {
			{
				p.SetState(575)
				p.OutFileClause()
			}

		}

	case 2:
		localctx = NewSupportedDmlStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(578)
			p.SupportedDmlStatement()
		}

	case 3:
		localctx = NewSupportedCreateStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(579)
			p.SupportedCreateStatement()
		}

	case 4:
		localctx = NewSupportedAlterStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(580)
			p.SupportedAlterStatement()
		}

	case 5:
		localctx = NewMaterializedViewStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(581)
			p.MaterializedViewStatement()
		}

	case 6:
		localctx = NewSupportedJobStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(582)
			p.SupportedJobStatement()
		}

	case 7:
		localctx = NewConstraintStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(583)
			p.ConstraintStatement()
		}

	case 8:
		localctx = NewSupportedCleanStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(584)
			p.SupportedCleanStatement()
		}

	case 9:
		localctx = NewSupportedDescribeStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(585)
			p.SupportedDescribeStatement()
		}

	case 10:
		localctx = NewSupportedDropStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(586)
			p.SupportedDropStatement()
		}

	case 11:
		localctx = NewSupportedSetStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(587)
			p.SupportedSetStatement()
		}

	case 12:
		localctx = NewSupportedUnsetStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(588)
			p.SupportedUnsetStatement()
		}

	case 13:
		localctx = NewSupportedRefreshStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(589)
			p.SupportedRefreshStatement()
		}

	case 14:
		localctx = NewSupportedShowStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(590)
			p.SupportedShowStatement()
		}

	case 15:
		localctx = NewSupportedLoadStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(591)
			p.SupportedLoadStatement()
		}

	case 16:
		localctx = NewSupportedCancelStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(592)
			p.SupportedCancelStatement()
		}

	case 17:
		localctx = NewSupportedRecoverStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(593)
			p.SupportedRecoverStatement()
		}

	case 18:
		localctx = NewSupportedAdminStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(594)
			p.SupportedAdminStatement()
		}

	case 19:
		localctx = NewSupportedUseStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(595)
			p.SupportedUseStatement()
		}

	case 20:
		localctx = NewSupportedOtherStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(596)
			p.SupportedOtherStatement()
		}

	case 21:
		localctx = NewSupportedKillStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(597)
			p.SupportedKillStatement()
		}

	case 22:
		localctx = NewSupportedStatsStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(598)
			p.SupportedStatsStatement()
		}

	case 23:
		localctx = NewSupportedTransactionStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(599)
			p.SupportedTransactionStatement()
		}

	case 24:
		localctx = NewSupportedGrantRevokeStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(600)
			p.SupportedGrantRevokeStatement()
		}

	case 25:
		localctx = NewUnsupportedContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(601)
			p.UnsupportedStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedStatementContext is an interface to support dynamic dispatch.
type IUnsupportedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsupportedStatsStatement() IUnsupportedStatsStatementContext
	UnsupportedAdminStatement() IUnsupportedAdminStatementContext
	UnsupportedLoadStatement() IUnsupportedLoadStatementContext
	UnsupportedOtherStatement() IUnsupportedOtherStatementContext

	// IsUnsupportedStatementContext differentiates from other interfaces.
	IsUnsupportedStatementContext()
}

type UnsupportedStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedStatementContext() *UnsupportedStatementContext {
	var p = new(UnsupportedStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedStatement
	return p
}

func InitEmptyUnsupportedStatementContext(p *UnsupportedStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedStatement
}

func (*UnsupportedStatementContext) IsUnsupportedStatementContext() {}

func NewUnsupportedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedStatementContext {
	var p = new(UnsupportedStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedStatement

	return p
}

func (s *UnsupportedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedStatementContext) UnsupportedStatsStatement() IUnsupportedStatsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedStatsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedStatsStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedAdminStatement() IUnsupportedAdminStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedAdminStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedAdminStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedLoadStatement() IUnsupportedLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedLoadStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedOtherStatement() IUnsupportedOtherStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedOtherStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedOtherStatementContext)
}

func (s *UnsupportedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsupportedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUnsupportedStatement(s)
	}
}

func (s *UnsupportedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUnsupportedStatement(s)
	}
}

func (p *DorisParser) UnsupportedStatement() (localctx IUnsupportedStatementContext) {
	localctx = NewUnsupportedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, DorisParserRULE_unsupportedStatement)
	p.SetState(608)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(604)
			p.UnsupportedStatsStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(605)
			p.UnsupportedAdminStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(606)
			p.UnsupportedLoadStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(607)
			p.UnsupportedOtherStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaterializedViewStatementContext is an interface to support dynamic dispatch.
type IMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsMaterializedViewStatementContext differentiates from other interfaces.
	IsMaterializedViewStatementContext()
}

type MaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaterializedViewStatementContext() *MaterializedViewStatementContext {
	var p = new(MaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_materializedViewStatement
	return p
}

func InitEmptyMaterializedViewStatementContext(p *MaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_materializedViewStatement
}

func (*MaterializedViewStatementContext) IsMaterializedViewStatementContext() {}

func NewMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaterializedViewStatementContext {
	var p = new(MaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_materializedViewStatement

	return p
}

func (s *MaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MaterializedViewStatementContext) CopyAll(ctx *MaterializedViewStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *MaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RefreshMTMVContext struct {
	MaterializedViewStatementContext
	mvName IMultipartIdentifierContext
}

func NewRefreshMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RefreshMTMVContext {
	var p = new(RefreshMTMVContext)

	InitEmptyMaterializedViewStatementContext(&p.MaterializedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterializedViewStatementContext))

	return p
}

func (s *RefreshMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *RefreshMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *RefreshMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshMTMVContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserREFRESH, 0)
}

func (s *RefreshMTMVContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *RefreshMTMVContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *RefreshMTMVContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *RefreshMTMVContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *RefreshMTMVContext) COMPLETE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPLETE, 0)
}

func (s *RefreshMTMVContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO, 0)
}

func (s *RefreshMTMVContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRefreshMTMV(s)
	}
}

func (s *RefreshMTMVContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRefreshMTMV(s)
	}
}

type AlterMTMVContext struct {
	MaterializedViewStatementContext
	mvName         IMultipartIdentifierContext
	newName        IIdentifierContext
	fileProperties IPropertyItemListContext
}

func NewAlterMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterMTMVContext {
	var p = new(AlterMTMVContext)

	InitEmptyMaterializedViewStatementContext(&p.MaterializedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterializedViewStatementContext))

	return p
}

func (s *AlterMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *AlterMTMVContext) GetNewName() IIdentifierContext { return s.newName }

func (s *AlterMTMVContext) GetFileProperties() IPropertyItemListContext { return s.fileProperties }

func (s *AlterMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *AlterMTMVContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *AlterMTMVContext) SetFileProperties(v IPropertyItemListContext) { s.fileProperties = v }

func (s *AlterMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterMTMVContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterMTMVContext) AllMATERIALIZED() []antlr.TerminalNode {
	return s.GetTokens(DorisParserMATERIALIZED)
}

func (s *AlterMTMVContext) MATERIALIZED(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, i)
}

func (s *AlterMTMVContext) AllVIEW() []antlr.TerminalNode {
	return s.GetTokens(DorisParserVIEW)
}

func (s *AlterMTMVContext) VIEW(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, i)
}

func (s *AlterMTMVContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterMTMVContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *AlterMTMVContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *AlterMTMVContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterMTMVContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserRENAME, 0)
}

func (s *AlterMTMVContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserREFRESH, 0)
}

func (s *AlterMTMVContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterMTMVContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterMTMVContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterMTMVContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterMTMVContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterMTMVContext) RefreshMethod() IRefreshMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshMethodContext)
}

func (s *AlterMTMVContext) RefreshTrigger() IRefreshTriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshTriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshTriggerContext)
}

func (s *AlterMTMVContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterMTMV(s)
	}
}

func (s *AlterMTMVContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterMTMV(s)
	}
}

type CreateMTMVContext struct {
	MaterializedViewStatementContext
	mvName   IMultipartIdentifierContext
	cols     ISimpleColumnDefsContext
	keys     IIdentifierListContext
	hashKeys IIdentifierListContext
}

func NewCreateMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateMTMVContext {
	var p = new(CreateMTMVContext)

	InitEmptyMaterializedViewStatementContext(&p.MaterializedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterializedViewStatementContext))

	return p
}

func (s *CreateMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *CreateMTMVContext) GetCols() ISimpleColumnDefsContext { return s.cols }

func (s *CreateMTMVContext) GetKeys() IIdentifierListContext { return s.keys }

func (s *CreateMTMVContext) GetHashKeys() IIdentifierListContext { return s.hashKeys }

func (s *CreateMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *CreateMTMVContext) SetCols(v ISimpleColumnDefsContext) { s.cols = v }

func (s *CreateMTMVContext) SetKeys(v IIdentifierListContext) { s.keys = v }

func (s *CreateMTMVContext) SetHashKeys(v IIdentifierListContext) { s.hashKeys = v }

func (s *CreateMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateMTMVContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateMTMVContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *CreateMTMVContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *CreateMTMVContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *CreateMTMVContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateMTMVContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateMTMVContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateMTMVContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateMTMVContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateMTMVContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserLEFT_PAREN)
}

func (s *CreateMTMVContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, i)
}

func (s *CreateMTMVContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserRIGHT_PAREN)
}

func (s *CreateMTMVContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, i)
}

func (s *CreateMTMVContext) BuildMode() IBuildModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBuildModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBuildModeContext)
}

func (s *CreateMTMVContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserREFRESH, 0)
}

func (s *CreateMTMVContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserKEY, 0)
}

func (s *CreateMTMVContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *CreateMTMVContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateMTMVContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *CreateMTMVContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(DorisParserBY)
}

func (s *CreateMTMVContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserBY, i)
}

func (s *CreateMTMVContext) MvPartition() IMvPartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMvPartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMvPartitionContext)
}

func (s *CreateMTMVContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTRIBUTED, 0)
}

func (s *CreateMTMVContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateMTMVContext) SimpleColumnDefs() ISimpleColumnDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleColumnDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleColumnDefsContext)
}

func (s *CreateMTMVContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *CreateMTMVContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateMTMVContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisParserHASH, 0)
}

func (s *CreateMTMVContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(DorisParserRANDOM, 0)
}

func (s *CreateMTMVContext) RefreshMethod() IRefreshMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshMethodContext)
}

func (s *CreateMTMVContext) RefreshTrigger() IRefreshTriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshTriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshTriggerContext)
}

func (s *CreateMTMVContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(DorisParserDUPLICATE, 0)
}

func (s *CreateMTMVContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisParserBUCKETS, 0)
}

func (s *CreateMTMVContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *CreateMTMVContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO, 0)
}

func (s *CreateMTMVContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateMTMV(s)
	}
}

func (s *CreateMTMVContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateMTMV(s)
	}
}

type ResumeMTMVContext struct {
	MaterializedViewStatementContext
	mvName IMultipartIdentifierContext
}

func NewResumeMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ResumeMTMVContext {
	var p = new(ResumeMTMVContext)

	InitEmptyMaterializedViewStatementContext(&p.MaterializedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterializedViewStatementContext))

	return p
}

func (s *ResumeMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *ResumeMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *ResumeMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumeMTMVContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisParserRESUME, 0)
}

func (s *ResumeMTMVContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *ResumeMTMVContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *ResumeMTMVContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *ResumeMTMVContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *ResumeMTMVContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ResumeMTMVContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterResumeMTMV(s)
	}
}

func (s *ResumeMTMVContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitResumeMTMV(s)
	}
}

type ShowCreateMTMVContext struct {
	MaterializedViewStatementContext
	mvName IMultipartIdentifierContext
}

func NewShowCreateMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateMTMVContext {
	var p = new(ShowCreateMTMVContext)

	InitEmptyMaterializedViewStatementContext(&p.MaterializedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterializedViewStatementContext))

	return p
}

func (s *ShowCreateMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *ShowCreateMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *ShowCreateMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateMTMVContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCreateMTMVContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowCreateMTMVContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *ShowCreateMTMVContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *ShowCreateMTMVContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateMTMVContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCreateMTMV(s)
	}
}

func (s *ShowCreateMTMVContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCreateMTMV(s)
	}
}

type CancelMTMVTaskContext struct {
	MaterializedViewStatementContext
	taskId antlr.Token
	mvName IMultipartIdentifierContext
}

func NewCancelMTMVTaskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelMTMVTaskContext {
	var p = new(CancelMTMVTaskContext)

	InitEmptyMaterializedViewStatementContext(&p.MaterializedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterializedViewStatementContext))

	return p
}

func (s *CancelMTMVTaskContext) GetTaskId() antlr.Token { return s.taskId }

func (s *CancelMTMVTaskContext) SetTaskId(v antlr.Token) { s.taskId = v }

func (s *CancelMTMVTaskContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *CancelMTMVTaskContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *CancelMTMVTaskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelMTMVTaskContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *CancelMTMVTaskContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *CancelMTMVTaskContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *CancelMTMVTaskContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisParserTASK, 0)
}

func (s *CancelMTMVTaskContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *CancelMTMVTaskContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *CancelMTMVTaskContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CancelMTMVTaskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCancelMTMVTask(s)
	}
}

func (s *CancelMTMVTaskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCancelMTMVTask(s)
	}
}

type PauseMTMVContext struct {
	MaterializedViewStatementContext
	mvName IMultipartIdentifierContext
}

func NewPauseMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PauseMTMVContext {
	var p = new(PauseMTMVContext)

	InitEmptyMaterializedViewStatementContext(&p.MaterializedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterializedViewStatementContext))

	return p
}

func (s *PauseMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *PauseMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *PauseMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PauseMTMVContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserPAUSE, 0)
}

func (s *PauseMTMVContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *PauseMTMVContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *PauseMTMVContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *PauseMTMVContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *PauseMTMVContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *PauseMTMVContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPauseMTMV(s)
	}
}

func (s *PauseMTMVContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPauseMTMV(s)
	}
}

type DropMTMVContext struct {
	MaterializedViewStatementContext
	mvName    IMultipartIdentifierContext
	tableName IMultipartIdentifierContext
}

func NewDropMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropMTMVContext {
	var p = new(DropMTMVContext)

	InitEmptyMaterializedViewStatementContext(&p.MaterializedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterializedViewStatementContext))

	return p
}

func (s *DropMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *DropMTMVContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DropMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *DropMTMVContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DropMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropMTMVContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropMTMVContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *DropMTMVContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *DropMTMVContext) AllMultipartIdentifier() []IMultipartIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultipartIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipartIdentifierContext); ok {
			tst[i] = t.(IMultipartIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DropMTMVContext) MultipartIdentifier(i int) IMultipartIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropMTMVContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropMTMVContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropMTMVContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *DropMTMVContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropMTMV(s)
	}
}

func (s *DropMTMVContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropMTMV(s)
	}
}

func (p *DorisParser) MaterializedViewStatement() (localctx IMaterializedViewStatementContext) {
	localctx = NewMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, DorisParserRULE_materializedViewStatement)
	var _la int

	p.SetState(749)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserCREATE:
		localctx = NewCreateMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(610)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(611)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(612)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(616)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(613)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(614)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(615)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(618)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateMTMVContext).mvName = _x
		}
		p.SetState(623)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(619)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(620)

				var _x = p.SimpleColumnDefs()

				localctx.(*CreateMTMVContext).cols = _x
			}
			{
				p.SetState(621)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(626)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserBUILD {
			{
				p.SetState(625)
				p.BuildMode()
			}

		}
		p.SetState(635)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserREFRESH {
			{
				p.SetState(628)
				p.Match(DorisParserREFRESH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(630)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserAUTO || _la == DorisParserCOMPLETE {
				{
					p.SetState(629)
					p.RefreshMethod()
				}

			}
			p.SetState(633)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserON {
				{
					p.SetState(632)
					p.RefreshTrigger()
				}

			}

		}
		p.SetState(642)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserDUPLICATE || _la == DorisParserKEY {
			p.SetState(638)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserDUPLICATE {
				{
					p.SetState(637)
					p.Match(DorisParserDUPLICATE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(640)
				p.Match(DorisParserKEY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(641)

				var _x = p.IdentifierList()

				localctx.(*CreateMTMVContext).keys = _x
			}

		}
		p.SetState(646)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(644)
				p.Match(DorisParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(645)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(654)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION {
			{
				p.SetState(648)
				p.Match(DorisParserPARTITION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(649)
				p.Match(DorisParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(650)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(651)
				p.MvPartition()
			}
			{
				p.SetState(652)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(667)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserDISTRIBUTED {
			{
				p.SetState(656)
				p.Match(DorisParserDISTRIBUTED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(657)
				p.Match(DorisParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(661)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserHASH:
				{
					p.SetState(658)
					p.Match(DorisParserHASH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(659)

					var _x = p.IdentifierList()

					localctx.(*CreateMTMVContext).hashKeys = _x
				}

			case DorisParserRANDOM:
				{
					p.SetState(660)
					p.Match(DorisParserRANDOM)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			p.SetState(665)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserBUCKETS {
				{
					p.SetState(663)
					p.Match(DorisParserBUCKETS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(664)
					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisParserAUTO || _la == DorisParserINTEGER_VALUE) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}

		}
		p.SetState(670)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(669)
				p.PropertyClause()
			}

		}
		{
			p.SetState(672)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(673)
			p.Query()
		}

	case DorisParserREFRESH:
		localctx = NewRefreshMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(675)
			p.Match(DorisParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(676)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(677)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(678)

			var _x = p.MultipartIdentifier()

			localctx.(*RefreshMTMVContext).mvName = _x
		}
		p.SetState(682)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserPARTITION, DorisParserPARTITIONS, DorisParserTEMPORARY:
			{
				p.SetState(679)
				p.PartitionSpec()
			}

		case DorisParserCOMPLETE:
			{
				p.SetState(680)
				p.Match(DorisParserCOMPLETE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserAUTO:
			{
				p.SetState(681)
				p.Match(DorisParserAUTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case DorisParserALTER:
		localctx = NewAlterMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(684)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(685)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(686)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(687)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterMTMVContext).mvName = _x
		}
		p.SetState(711)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserRENAME:
			{
				p.SetState(688)
				p.Match(DorisParserRENAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(689)

				var _x = p.Identifier()

				localctx.(*AlterMTMVContext).newName = _x
			}

		case DorisParserREFRESH:
			{
				p.SetState(690)
				p.Match(DorisParserREFRESH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(696)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(691)
					p.RefreshMethod()
				}

			case 2:
				{
					p.SetState(692)
					p.RefreshTrigger()
				}

			case 3:
				{
					p.SetState(693)
					p.RefreshMethod()
				}
				{
					p.SetState(694)
					p.RefreshTrigger()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		case DorisParserREPLACE:
			{
				p.SetState(698)
				p.Match(DorisParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(699)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(700)
				p.Match(DorisParserMATERIALIZED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(701)
				p.Match(DorisParserVIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(702)

				var _x = p.Identifier()

				localctx.(*AlterMTMVContext).newName = _x
			}
			p.SetState(704)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserPROPERTIES {
				{
					p.SetState(703)
					p.PropertyClause()
				}

			}

		case DorisParserSET:
			{
				p.SetState(706)
				p.Match(DorisParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(707)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(708)

				var _x = p.PropertyItemList()

				localctx.(*AlterMTMVContext).fileProperties = _x
			}
			{
				p.SetState(709)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case DorisParserDROP:
		localctx = NewDropMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(713)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(714)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(715)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(718)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(716)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(717)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(720)

			var _x = p.MultipartIdentifier()

			localctx.(*DropMTMVContext).mvName = _x
		}
		p.SetState(723)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserON {
			{
				p.SetState(721)
				p.Match(DorisParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(722)

				var _x = p.MultipartIdentifier()

				localctx.(*DropMTMVContext).tableName = _x
			}

		}

	case DorisParserPAUSE:
		localctx = NewPauseMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(725)
			p.Match(DorisParserPAUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(726)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(727)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(728)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(729)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(730)

			var _x = p.MultipartIdentifier()

			localctx.(*PauseMTMVContext).mvName = _x
		}

	case DorisParserRESUME:
		localctx = NewResumeMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(731)
			p.Match(DorisParserRESUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(732)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(733)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(734)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(735)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(736)

			var _x = p.MultipartIdentifier()

			localctx.(*ResumeMTMVContext).mvName = _x
		}

	case DorisParserCANCEL:
		localctx = NewCancelMTMVTaskContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(737)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(738)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(739)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(740)
			p.Match(DorisParserTASK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(741)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*CancelMTMVTaskContext).taskId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(742)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(743)

			var _x = p.MultipartIdentifier()

			localctx.(*CancelMTMVTaskContext).mvName = _x
		}

	case DorisParserSHOW:
		localctx = NewShowCreateMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(744)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(745)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(746)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(747)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(748)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateMTMVContext).mvName = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedJobStatementContext is an interface to support dynamic dispatch.
type ISupportedJobStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedJobStatementContext differentiates from other interfaces.
	IsSupportedJobStatementContext()
}

type SupportedJobStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedJobStatementContext() *SupportedJobStatementContext {
	var p = new(SupportedJobStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedJobStatement
	return p
}

func InitEmptySupportedJobStatementContext(p *SupportedJobStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedJobStatement
}

func (*SupportedJobStatementContext) IsSupportedJobStatementContext() {}

func NewSupportedJobStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedJobStatementContext {
	var p = new(SupportedJobStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedJobStatement

	return p
}

func (s *SupportedJobStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedJobStatementContext) CopyAll(ctx *SupportedJobStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedJobStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedJobStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CancelJobTaskContext struct {
	SupportedJobStatementContext
	jobNameKey   IIdentifierContext
	jobNameValue antlr.Token
	taskIdKey    IIdentifierContext
	taskIdValue  antlr.Token
}

func NewCancelJobTaskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelJobTaskContext {
	var p = new(CancelJobTaskContext)

	InitEmptySupportedJobStatementContext(&p.SupportedJobStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedJobStatementContext))

	return p
}

func (s *CancelJobTaskContext) GetJobNameValue() antlr.Token { return s.jobNameValue }

func (s *CancelJobTaskContext) GetTaskIdValue() antlr.Token { return s.taskIdValue }

func (s *CancelJobTaskContext) SetJobNameValue(v antlr.Token) { s.jobNameValue = v }

func (s *CancelJobTaskContext) SetTaskIdValue(v antlr.Token) { s.taskIdValue = v }

func (s *CancelJobTaskContext) GetJobNameKey() IIdentifierContext { return s.jobNameKey }

func (s *CancelJobTaskContext) GetTaskIdKey() IIdentifierContext { return s.taskIdKey }

func (s *CancelJobTaskContext) SetJobNameKey(v IIdentifierContext) { s.jobNameKey = v }

func (s *CancelJobTaskContext) SetTaskIdKey(v IIdentifierContext) { s.taskIdKey = v }

func (s *CancelJobTaskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelJobTaskContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *CancelJobTaskContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisParserTASK, 0)
}

func (s *CancelJobTaskContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserWHERE, 0)
}

func (s *CancelJobTaskContext) AllEQ() []antlr.TerminalNode {
	return s.GetTokens(DorisParserEQ)
}

func (s *CancelJobTaskContext) EQ(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, i)
}

func (s *CancelJobTaskContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisParserAND, 0)
}

func (s *CancelJobTaskContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CancelJobTaskContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelJobTaskContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CancelJobTaskContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *CancelJobTaskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCancelJobTask(s)
	}
}

func (s *CancelJobTaskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCancelJobTask(s)
	}
}

type ResumeJobContext struct {
	SupportedJobStatementContext
	jobNameKey   IIdentifierContext
	jobNameValue antlr.Token
}

func NewResumeJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ResumeJobContext {
	var p = new(ResumeJobContext)

	InitEmptySupportedJobStatementContext(&p.SupportedJobStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedJobStatementContext))

	return p
}

func (s *ResumeJobContext) GetJobNameValue() antlr.Token { return s.jobNameValue }

func (s *ResumeJobContext) SetJobNameValue(v antlr.Token) { s.jobNameValue = v }

func (s *ResumeJobContext) GetJobNameKey() IIdentifierContext { return s.jobNameKey }

func (s *ResumeJobContext) SetJobNameKey(v IIdentifierContext) { s.jobNameKey = v }

func (s *ResumeJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumeJobContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisParserRESUME, 0)
}

func (s *ResumeJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *ResumeJobContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserWHERE, 0)
}

func (s *ResumeJobContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *ResumeJobContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ResumeJobContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ResumeJobContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterResumeJob(s)
	}
}

func (s *ResumeJobContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitResumeJob(s)
	}
}

type DropJobContext struct {
	SupportedJobStatementContext
	jobNameKey   IIdentifierContext
	jobNameValue antlr.Token
}

func NewDropJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropJobContext {
	var p = new(DropJobContext)

	InitEmptySupportedJobStatementContext(&p.SupportedJobStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedJobStatementContext))

	return p
}

func (s *DropJobContext) GetJobNameValue() antlr.Token { return s.jobNameValue }

func (s *DropJobContext) SetJobNameValue(v antlr.Token) { s.jobNameValue = v }

func (s *DropJobContext) GetJobNameKey() IIdentifierContext { return s.jobNameKey }

func (s *DropJobContext) SetJobNameKey(v IIdentifierContext) { s.jobNameKey = v }

func (s *DropJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropJobContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *DropJobContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserWHERE, 0)
}

func (s *DropJobContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *DropJobContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropJobContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropJobContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropJobContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *DropJobContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropJob(s)
	}
}

func (s *DropJobContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropJob(s)
	}
}

type CreateScheduledJobContext struct {
	SupportedJobStatementContext
	label        IMultipartIdentifierContext
	timeInterval antlr.Token
	timeUnit     IIdentifierContext
	startTime    antlr.Token
	endsTime     antlr.Token
	atTime       antlr.Token
}

func NewCreateScheduledJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateScheduledJobContext {
	var p = new(CreateScheduledJobContext)

	InitEmptySupportedJobStatementContext(&p.SupportedJobStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedJobStatementContext))

	return p
}

func (s *CreateScheduledJobContext) GetTimeInterval() antlr.Token { return s.timeInterval }

func (s *CreateScheduledJobContext) GetStartTime() antlr.Token { return s.startTime }

func (s *CreateScheduledJobContext) GetEndsTime() antlr.Token { return s.endsTime }

func (s *CreateScheduledJobContext) GetAtTime() antlr.Token { return s.atTime }

func (s *CreateScheduledJobContext) SetTimeInterval(v antlr.Token) { s.timeInterval = v }

func (s *CreateScheduledJobContext) SetStartTime(v antlr.Token) { s.startTime = v }

func (s *CreateScheduledJobContext) SetEndsTime(v antlr.Token) { s.endsTime = v }

func (s *CreateScheduledJobContext) SetAtTime(v antlr.Token) { s.atTime = v }

func (s *CreateScheduledJobContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *CreateScheduledJobContext) GetTimeUnit() IIdentifierContext { return s.timeUnit }

func (s *CreateScheduledJobContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *CreateScheduledJobContext) SetTimeUnit(v IIdentifierContext) { s.timeUnit = v }

func (s *CreateScheduledJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateScheduledJobContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateScheduledJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *CreateScheduledJobContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *CreateScheduledJobContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEDULE, 0)
}

func (s *CreateScheduledJobContext) DO() antlr.TerminalNode {
	return s.GetToken(DorisParserDO, 0)
}

func (s *CreateScheduledJobContext) SupportedDmlStatement() ISupportedDmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedDmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedDmlStatementContext)
}

func (s *CreateScheduledJobContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateScheduledJobContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *CreateScheduledJobContext) EVERY() antlr.TerminalNode {
	return s.GetToken(DorisParserEVERY, 0)
}

func (s *CreateScheduledJobContext) AT() antlr.TerminalNode {
	return s.GetToken(DorisParserAT, 0)
}

func (s *CreateScheduledJobContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *CreateScheduledJobContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateScheduledJobContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_TIMESTAMP, 0)
}

func (s *CreateScheduledJobContext) STARTS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTARTS, 0)
}

func (s *CreateScheduledJobContext) ENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserENDS, 0)
}

func (s *CreateScheduledJobContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *CreateScheduledJobContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *CreateScheduledJobContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateScheduledJob(s)
	}
}

func (s *CreateScheduledJobContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateScheduledJob(s)
	}
}

type PauseJobContext struct {
	SupportedJobStatementContext
	jobNameKey   IIdentifierContext
	jobNameValue antlr.Token
}

func NewPauseJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PauseJobContext {
	var p = new(PauseJobContext)

	InitEmptySupportedJobStatementContext(&p.SupportedJobStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedJobStatementContext))

	return p
}

func (s *PauseJobContext) GetJobNameValue() antlr.Token { return s.jobNameValue }

func (s *PauseJobContext) SetJobNameValue(v antlr.Token) { s.jobNameValue = v }

func (s *PauseJobContext) GetJobNameKey() IIdentifierContext { return s.jobNameKey }

func (s *PauseJobContext) SetJobNameKey(v IIdentifierContext) { s.jobNameKey = v }

func (s *PauseJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PauseJobContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserPAUSE, 0)
}

func (s *PauseJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *PauseJobContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserWHERE, 0)
}

func (s *PauseJobContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *PauseJobContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PauseJobContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *PauseJobContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPauseJob(s)
	}
}

func (s *PauseJobContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPauseJob(s)
	}
}

func (p *DorisParser) SupportedJobStatement() (localctx ISupportedJobStatementContext) {
	localctx = NewSupportedJobStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, DorisParserRULE_supportedJobStatement)
	var _la int

	p.SetState(819)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserCREATE:
		localctx = NewCreateScheduledJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(751)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(752)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(753)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateScheduledJobContext).label = _x
		}
		{
			p.SetState(754)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(755)
			p.Match(DorisParserSCHEDULE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(775)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserEVERY:
			{
				p.SetState(756)
				p.Match(DorisParserEVERY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(757)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*CreateScheduledJobContext).timeInterval = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(758)

				var _x = p.Identifier()

				localctx.(*CreateScheduledJobContext).timeUnit = _x
			}
			p.SetState(764)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserSTARTS {
				{
					p.SetState(759)
					p.Match(DorisParserSTARTS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(762)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DorisParserSTRING_LITERAL:
					{
						p.SetState(760)

						var _m = p.Match(DorisParserSTRING_LITERAL)

						localctx.(*CreateScheduledJobContext).startTime = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case DorisParserCURRENT_TIMESTAMP:
					{
						p.SetState(761)
						p.Match(DorisParserCURRENT_TIMESTAMP)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			}
			p.SetState(768)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserENDS {
				{
					p.SetState(766)
					p.Match(DorisParserENDS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(767)

					var _m = p.Match(DorisParserSTRING_LITERAL)

					localctx.(*CreateScheduledJobContext).endsTime = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		case DorisParserAT:
			{
				p.SetState(770)
				p.Match(DorisParserAT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(773)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserSTRING_LITERAL:
				{
					p.SetState(771)

					var _m = p.Match(DorisParserSTRING_LITERAL)

					localctx.(*CreateScheduledJobContext).atTime = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case DorisParserCURRENT_TIMESTAMP:
				{
					p.SetState(772)
					p.Match(DorisParserCURRENT_TIMESTAMP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(778)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(777)
				p.CommentSpec()
			}

		}
		{
			p.SetState(780)
			p.Match(DorisParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(781)
			p.SupportedDmlStatement()
		}

	case DorisParserPAUSE:
		localctx = NewPauseJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(783)
			p.Match(DorisParserPAUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(784)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(785)
			p.Match(DorisParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(786)

			var _x = p.Identifier()

			localctx.(*PauseJobContext).jobNameKey = _x
		}

		{
			p.SetState(787)
			p.Match(DorisParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(788)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*PauseJobContext).jobNameValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDROP:
		localctx = NewDropJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(790)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(791)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(794)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(792)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(793)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(796)
			p.Match(DorisParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(797)

			var _x = p.Identifier()

			localctx.(*DropJobContext).jobNameKey = _x
		}

		{
			p.SetState(798)
			p.Match(DorisParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(799)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*DropJobContext).jobNameValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserRESUME:
		localctx = NewResumeJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(801)
			p.Match(DorisParserRESUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(802)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(803)
			p.Match(DorisParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(804)

			var _x = p.Identifier()

			localctx.(*ResumeJobContext).jobNameKey = _x
		}

		{
			p.SetState(805)
			p.Match(DorisParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(806)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ResumeJobContext).jobNameValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserCANCEL:
		localctx = NewCancelJobTaskContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(808)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(809)
			p.Match(DorisParserTASK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(810)
			p.Match(DorisParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(811)

			var _x = p.Identifier()

			localctx.(*CancelJobTaskContext).jobNameKey = _x
		}

		{
			p.SetState(812)
			p.Match(DorisParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(813)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*CancelJobTaskContext).jobNameValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(814)
			p.Match(DorisParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(815)

			var _x = p.Identifier()

			localctx.(*CancelJobTaskContext).taskIdKey = _x
		}

		{
			p.SetState(816)
			p.Match(DorisParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(817)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*CancelJobTaskContext).taskIdValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstraintStatementContext is an interface to support dynamic dispatch.
type IConstraintStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsConstraintStatementContext differentiates from other interfaces.
	IsConstraintStatementContext()
}

type ConstraintStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintStatementContext() *ConstraintStatementContext {
	var p = new(ConstraintStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_constraintStatement
	return p
}

func InitEmptyConstraintStatementContext(p *ConstraintStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_constraintStatement
}

func (*ConstraintStatementContext) IsConstraintStatementContext() {}

func NewConstraintStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintStatementContext {
	var p = new(ConstraintStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_constraintStatement

	return p
}

func (s *ConstraintStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintStatementContext) CopyAll(ctx *ConstraintStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ConstraintStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowConstraintContext struct {
	ConstraintStatementContext
	table IMultipartIdentifierContext
}

func NewShowConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowConstraintContext {
	var p = new(ShowConstraintContext)

	InitEmptyConstraintStatementContext(&p.ConstraintStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstraintStatementContext))

	return p
}

func (s *ShowConstraintContext) GetTable() IMultipartIdentifierContext { return s.table }

func (s *ShowConstraintContext) SetTable(v IMultipartIdentifierContext) { s.table = v }

func (s *ShowConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowConstraintContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowConstraintContext) CONSTRAINTS() antlr.TerminalNode {
	return s.GetToken(DorisParserCONSTRAINTS, 0)
}

func (s *ShowConstraintContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowConstraintContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowConstraint(s)
	}
}

func (s *ShowConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowConstraint(s)
	}
}

type DropConstraintContext struct {
	ConstraintStatementContext
	table          IMultipartIdentifierContext
	constraintName IErrorCapturingIdentifierContext
}

func NewDropConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropConstraintContext {
	var p = new(DropConstraintContext)

	InitEmptyConstraintStatementContext(&p.ConstraintStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstraintStatementContext))

	return p
}

func (s *DropConstraintContext) GetTable() IMultipartIdentifierContext { return s.table }

func (s *DropConstraintContext) GetConstraintName() IErrorCapturingIdentifierContext {
	return s.constraintName
}

func (s *DropConstraintContext) SetTable(v IMultipartIdentifierContext) { s.table = v }

func (s *DropConstraintContext) SetConstraintName(v IErrorCapturingIdentifierContext) {
	s.constraintName = v
}

func (s *DropConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropConstraintContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *DropConstraintContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *DropConstraintContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(DorisParserCONSTRAINT, 0)
}

func (s *DropConstraintContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropConstraintContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *DropConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropConstraint(s)
	}
}

func (s *DropConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropConstraint(s)
	}
}

type AddConstraintContext struct {
	ConstraintStatementContext
	table          IMultipartIdentifierContext
	constraintName IErrorCapturingIdentifierContext
}

func NewAddConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddConstraintContext {
	var p = new(AddConstraintContext)

	InitEmptyConstraintStatementContext(&p.ConstraintStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstraintStatementContext))

	return p
}

func (s *AddConstraintContext) GetTable() IMultipartIdentifierContext { return s.table }

func (s *AddConstraintContext) GetConstraintName() IErrorCapturingIdentifierContext {
	return s.constraintName
}

func (s *AddConstraintContext) SetTable(v IMultipartIdentifierContext) { s.table = v }

func (s *AddConstraintContext) SetConstraintName(v IErrorCapturingIdentifierContext) {
	s.constraintName = v
}

func (s *AddConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddConstraintContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AddConstraintContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AddConstraintContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(DorisParserCONSTRAINT, 0)
}

func (s *AddConstraintContext) Constraint() IConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintContext)
}

func (s *AddConstraintContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AddConstraintContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *AddConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddConstraint(s)
	}
}

func (s *AddConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddConstraint(s)
	}
}

func (p *DorisParser) ConstraintStatement() (localctx IConstraintStatementContext) {
	localctx = NewConstraintStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, DorisParserRULE_constraintStatement)
	p.SetState(840)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAddConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(821)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(822)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(823)

			var _x = p.MultipartIdentifier()

			localctx.(*AddConstraintContext).table = _x
		}
		{
			p.SetState(824)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(825)
			p.Match(DorisParserCONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(826)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*AddConstraintContext).constraintName = _x
		}
		{
			p.SetState(827)
			p.Constraint()
		}

	case 2:
		localctx = NewDropConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(829)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(830)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(831)

			var _x = p.MultipartIdentifier()

			localctx.(*DropConstraintContext).table = _x
		}
		{
			p.SetState(832)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(833)
			p.Match(DorisParserCONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(834)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*DropConstraintContext).constraintName = _x
		}

	case 3:
		localctx = NewShowConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(836)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(837)
			p.Match(DorisParserCONSTRAINTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(838)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(839)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowConstraintContext).table = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedDmlStatementContext is an interface to support dynamic dispatch.
type ISupportedDmlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedDmlStatementContext differentiates from other interfaces.
	IsSupportedDmlStatementContext()
}

type SupportedDmlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedDmlStatementContext() *SupportedDmlStatementContext {
	var p = new(SupportedDmlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedDmlStatement
	return p
}

func InitEmptySupportedDmlStatementContext(p *SupportedDmlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedDmlStatement
}

func (*SupportedDmlStatementContext) IsSupportedDmlStatementContext() {}

func NewSupportedDmlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedDmlStatementContext {
	var p = new(SupportedDmlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedDmlStatement

	return p
}

func (s *SupportedDmlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedDmlStatementContext) CopyAll(ctx *SupportedDmlStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedDmlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedDmlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type InsertTableContext struct {
	SupportedDmlStatementContext
	tableName IMultipartIdentifierContext
	tableId   antlr.Token
	labelName IIdentifierContext
	cols      IIdentifierListContext
	hints     IIdentifierSeqContext
}

func NewInsertTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertTableContext {
	var p = new(InsertTableContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *InsertTableContext) GetTableId() antlr.Token { return s.tableId }

func (s *InsertTableContext) SetTableId(v antlr.Token) { s.tableId = v }

func (s *InsertTableContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *InsertTableContext) GetLabelName() IIdentifierContext { return s.labelName }

func (s *InsertTableContext) GetCols() IIdentifierListContext { return s.cols }

func (s *InsertTableContext) GetHints() IIdentifierSeqContext { return s.hints }

func (s *InsertTableContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *InsertTableContext) SetLabelName(v IIdentifierContext) { s.labelName = v }

func (s *InsertTableContext) SetCols(v IIdentifierListContext) { s.cols = v }

func (s *InsertTableContext) SetHints(v IIdentifierSeqContext) { s.hints = v }

func (s *InsertTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertTableContext) INSERT() antlr.TerminalNode {
	return s.GetToken(DorisParserINSERT, 0)
}

func (s *InsertTableContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *InsertTableContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserINTO, 0)
}

func (s *InsertTableContext) OVERWRITE() antlr.TerminalNode {
	return s.GetToken(DorisParserOVERWRITE, 0)
}

func (s *InsertTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *InsertTableContext) DORIS_INTERNAL_TABLE_ID() antlr.TerminalNode {
	return s.GetToken(DorisParserDORIS_INTERNAL_TABLE_ID, 0)
}

func (s *InsertTableContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *InsertTableContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *InsertTableContext) Explain() IExplainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainContext)
}

func (s *InsertTableContext) Cte() ICteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteContext)
}

func (s *InsertTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *InsertTableContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *InsertTableContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *InsertTableContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *InsertTableContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisParserLABEL, 0)
}

func (s *InsertTableContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACKET, 0)
}

func (s *InsertTableContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACKET, 0)
}

func (s *InsertTableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InsertTableContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *InsertTableContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *InsertTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterInsertTable(s)
	}
}

func (s *InsertTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitInsertTable(s)
	}
}

type LoadContext struct {
	SupportedDmlStatementContext
	lableName IMultipartIdentifierContext
	_dataDesc IDataDescContext
	dataDescs []IDataDescContext
}

func NewLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LoadContext {
	var p = new(LoadContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *LoadContext) GetLableName() IMultipartIdentifierContext { return s.lableName }

func (s *LoadContext) Get_dataDesc() IDataDescContext { return s._dataDesc }

func (s *LoadContext) SetLableName(v IMultipartIdentifierContext) { s.lableName = v }

func (s *LoadContext) Set_dataDesc(v IDataDescContext) { s._dataDesc = v }

func (s *LoadContext) GetDataDescs() []IDataDescContext { return s.dataDescs }

func (s *LoadContext) SetDataDescs(v []IDataDescContext) { s.dataDescs = v }

func (s *LoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *LoadContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisParserLABEL, 0)
}

func (s *LoadContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *LoadContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *LoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *LoadContext) AllDataDesc() []IDataDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataDescContext); ok {
			len++
		}
	}

	tst := make([]IDataDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataDescContext); ok {
			tst[i] = t.(IDataDescContext)
			i++
		}
	}

	return tst
}

func (s *LoadContext) DataDesc(i int) IDataDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescContext)
}

func (s *LoadContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *LoadContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *LoadContext) WithRemoteStorageSystem() IWithRemoteStorageSystemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithRemoteStorageSystemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithRemoteStorageSystemContext)
}

func (s *LoadContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *LoadContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *LoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLoad(s)
	}
}

func (s *LoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLoad(s)
	}
}

type CopyIntoContext struct {
	SupportedDmlStatementContext
	name       IMultipartIdentifierContext
	columns    IIdentifierListContext
	properties IPropertyClauseContext
}

func NewCopyIntoContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CopyIntoContext {
	var p = new(CopyIntoContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *CopyIntoContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CopyIntoContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *CopyIntoContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CopyIntoContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CopyIntoContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *CopyIntoContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CopyIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CopyIntoContext) COPY() antlr.TerminalNode {
	return s.GetToken(DorisParserCOPY, 0)
}

func (s *CopyIntoContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserINTO, 0)
}

func (s *CopyIntoContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(DorisParserFROM)
}

func (s *CopyIntoContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, i)
}

func (s *CopyIntoContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CopyIntoContext) StageAndPattern() IStageAndPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStageAndPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStageAndPatternContext)
}

func (s *CopyIntoContext) SelectHint() ISelectHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectHintContext)
}

func (s *CopyIntoContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CopyIntoContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CopyIntoContext) SELECT() antlr.TerminalNode {
	return s.GetToken(DorisParserSELECT, 0)
}

func (s *CopyIntoContext) SelectColumnClause() ISelectColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectColumnClauseContext)
}

func (s *CopyIntoContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CopyIntoContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CopyIntoContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *CopyIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCopyInto(s)
	}
}

func (s *CopyIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCopyInto(s)
	}
}

type UpdateContext struct {
	SupportedDmlStatementContext
	tableName IMultipartIdentifierContext
}

func NewUpdateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UpdateContext {
	var p = new(UpdateContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *UpdateContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *UpdateContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *UpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(DorisParserUPDATE, 0)
}

func (s *UpdateContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *UpdateContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *UpdateContext) UpdateAssignmentSeq() IUpdateAssignmentSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateAssignmentSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateAssignmentSeqContext)
}

func (s *UpdateContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *UpdateContext) Explain() IExplainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainContext)
}

func (s *UpdateContext) Cte() ICteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteContext)
}

func (s *UpdateContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *UpdateContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *UpdateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUpdate(s)
	}
}

func (s *UpdateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUpdate(s)
	}
}

type TruncateTableContext struct {
	SupportedDmlStatementContext
}

func NewTruncateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TruncateTableContext {
	var p = new(TruncateTableContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *TruncateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncateTableContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(DorisParserTRUNCATE, 0)
}

func (s *TruncateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *TruncateTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *TruncateTableContext) SpecifiedPartition() ISpecifiedPartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecifiedPartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecifiedPartitionContext)
}

func (s *TruncateTableContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserFORCE, 0)
}

func (s *TruncateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTruncateTable(s)
	}
}

func (s *TruncateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTruncateTable(s)
	}
}

type ReplayContext struct {
	SupportedDmlStatementContext
}

func NewReplayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReplayContext {
	var p = new(ReplayContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *ReplayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplayContext) ReplayCommand() IReplayCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplayCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplayCommandContext)
}

func (s *ReplayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterReplay(s)
	}
}

func (s *ReplayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitReplay(s)
	}
}

type DeleteContext struct {
	SupportedDmlStatementContext
	tableName IMultipartIdentifierContext
}

func NewDeleteContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeleteContext {
	var p = new(DeleteContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *DeleteContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DeleteContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisParserDELETE, 0)
}

func (s *DeleteContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *DeleteContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *DeleteContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DeleteContext) Explain() IExplainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainContext)
}

func (s *DeleteContext) Cte() ICteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteContext)
}

func (s *DeleteContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *DeleteContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserUSING, 0)
}

func (s *DeleteContext) Relations() IRelationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationsContext)
}

func (s *DeleteContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *DeleteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDelete(s)
	}
}

func (s *DeleteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDelete(s)
	}
}

type ExportContext struct {
	SupportedDmlStatementContext
	tableName IMultipartIdentifierContext
	partition IIdentifierListContext
	filePath  antlr.Token
}

func NewExportContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExportContext {
	var p = new(ExportContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *ExportContext) GetFilePath() antlr.Token { return s.filePath }

func (s *ExportContext) SetFilePath(v antlr.Token) { s.filePath = v }

func (s *ExportContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ExportContext) GetPartition() IIdentifierListContext { return s.partition }

func (s *ExportContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ExportContext) SetPartition(v IIdentifierListContext) { s.partition = v }

func (s *ExportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(DorisParserEXPORT, 0)
}

func (s *ExportContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *ExportContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *ExportContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ExportContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ExportContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *ExportContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *ExportContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ExportContext) WithRemoteStorageSystem() IWithRemoteStorageSystemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithRemoteStorageSystemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithRemoteStorageSystemContext)
}

func (s *ExportContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ExportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterExport(s)
	}
}

func (s *ExportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitExport(s)
	}
}

func (p *DorisParser) SupportedDmlStatement() (localctx ISupportedDmlStatementContext) {
	localctx = NewSupportedDmlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, DorisParserRULE_supportedDmlStatement)
	var _la int

	p.SetState(992)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		localctx = NewInsertTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(843)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&1099511627779) != 0 {
			{
				p.SetState(842)
				p.Explain()
			}

		}
		p.SetState(846)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(845)
				p.Cte()
			}

		}
		{
			p.SetState(848)
			p.Match(DorisParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(852)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserINTO:
			{
				p.SetState(849)
				p.Match(DorisParserINTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserOVERWRITE:
			{
				p.SetState(850)
				p.Match(DorisParserOVERWRITE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(851)
				p.Match(DorisParserTABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(859)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(854)

				var _x = p.MultipartIdentifier()

				localctx.(*InsertTableContext).tableName = _x
			}

		case 2:
			{
				p.SetState(855)
				p.Match(DorisParserDORIS_INTERNAL_TABLE_ID)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(856)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(857)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*InsertTableContext).tableId = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(858)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(862)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(861)
				p.PartitionSpec()
			}

		}
		p.SetState(867)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(864)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(865)
				p.Match(DorisParserLABEL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(866)

				var _x = p.Identifier()

				localctx.(*InsertTableContext).labelName = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(870)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(869)

				var _x = p.IdentifierList()

				localctx.(*InsertTableContext).cols = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(876)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_BRACKET {
			{
				p.SetState(872)
				p.Match(DorisParserLEFT_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(873)

				var _x = p.IdentifierSeq()

				localctx.(*InsertTableContext).hints = _x
			}
			{
				p.SetState(874)
				p.Match(DorisParserRIGHT_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(878)
			p.Query()
		}

	case 2:
		localctx = NewUpdateContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(880)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&1099511627779) != 0 {
			{
				p.SetState(879)
				p.Explain()
			}

		}
		p.SetState(883)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(882)
				p.Cte()
			}

		}
		{
			p.SetState(885)
			p.Match(DorisParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(886)

			var _x = p.MultipartIdentifier()

			localctx.(*UpdateContext).tableName = _x
		}
		{
			p.SetState(887)
			p.TableAlias()
		}
		{
			p.SetState(888)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(889)
			p.UpdateAssignmentSeq()
		}
		p.SetState(891)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(890)
				p.FromClause()
			}

		}
		p.SetState(894)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWHERE {
			{
				p.SetState(893)
				p.WhereClause()
			}

		}

	case 3:
		localctx = NewDeleteContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(897)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&1099511627779) != 0 {
			{
				p.SetState(896)
				p.Explain()
			}

		}
		p.SetState(900)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(899)
				p.Cte()
			}

		}
		{
			p.SetState(902)
			p.Match(DorisParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(903)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(904)

			var _x = p.MultipartIdentifier()

			localctx.(*DeleteContext).tableName = _x
		}
		p.SetState(906)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(905)
				p.PartitionSpec()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(908)
			p.TableAlias()
		}
		p.SetState(911)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserUSING {
			{
				p.SetState(909)
				p.Match(DorisParserUSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(910)
				p.Relations()
			}

		}
		p.SetState(914)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWHERE {
			{
				p.SetState(913)
				p.WhereClause()
			}

		}

	case 4:
		localctx = NewLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(916)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(917)
			p.Match(DorisParserLABEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(918)

			var _x = p.MultipartIdentifier()

			localctx.(*LoadContext).lableName = _x
		}
		{
			p.SetState(919)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(920)

			var _x = p.DataDesc()

			localctx.(*LoadContext)._dataDesc = _x
		}
		localctx.(*LoadContext).dataDescs = append(localctx.(*LoadContext).dataDescs, localctx.(*LoadContext)._dataDesc)
		p.SetState(925)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(921)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(922)

				var _x = p.DataDesc()

				localctx.(*LoadContext)._dataDesc = _x
			}
			localctx.(*LoadContext).dataDescs = append(localctx.(*LoadContext).dataDescs, localctx.(*LoadContext)._dataDesc)

			p.SetState(927)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(928)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(930)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(929)
				p.WithRemoteStorageSystem()
			}

		}
		p.SetState(933)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(932)
				p.PropertyClause()
			}

		}
		p.SetState(936)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(935)
				p.CommentSpec()
			}

		}

	case 5:
		localctx = NewExportContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(938)
			p.Match(DorisParserEXPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(939)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(940)

			var _x = p.MultipartIdentifier()

			localctx.(*ExportContext).tableName = _x
		}
		p.SetState(943)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION {
			{
				p.SetState(941)
				p.Match(DorisParserPARTITION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(942)

				var _x = p.IdentifierList()

				localctx.(*ExportContext).partition = _x
			}

		}
		p.SetState(946)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWHERE {
			{
				p.SetState(945)
				p.WhereClause()
			}

		}
		{
			p.SetState(948)
			p.Match(DorisParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(949)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ExportContext).filePath = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(951)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(950)
				p.PropertyClause()
			}

		}
		p.SetState(954)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(953)
				p.WithRemoteStorageSystem()
			}

		}

	case 6:
		localctx = NewReplayContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(956)
			p.ReplayCommand()
		}

	case 7:
		localctx = NewCopyIntoContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(957)
			p.Match(DorisParserCOPY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(958)
			p.Match(DorisParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(960)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(959)
				p.SelectHint()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(962)

			var _x = p.MultipartIdentifier()

			localctx.(*CopyIntoContext).name = _x
		}
		p.SetState(964)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(963)

				var _x = p.IdentifierList()

				localctx.(*CopyIntoContext).columns = _x
			}

		}
		{
			p.SetState(966)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(978)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserATSIGN:
			{
				p.SetState(967)
				p.StageAndPattern()
			}

		case DorisParserLEFT_PAREN:
			{
				p.SetState(968)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(969)
				p.Match(DorisParserSELECT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(970)
				p.SelectColumnClause()
			}
			{
				p.SetState(971)
				p.Match(DorisParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(972)
				p.StageAndPattern()
			}
			p.SetState(974)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserWHERE {
				{
					p.SetState(973)
					p.WhereClause()
				}

			}
			{
				p.SetState(976)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(981)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(980)

				var _x = p.PropertyClause()

				localctx.(*CopyIntoContext).properties = _x
			}

		}

	case 8:
		localctx = NewTruncateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(983)
			p.Match(DorisParserTRUNCATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(984)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(985)
			p.MultipartIdentifier()
		}
		p.SetState(987)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(986)
				p.SpecifiedPartition()
			}

		}
		p.SetState(990)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFORCE {
			{
				p.SetState(989)
				p.Match(DorisParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedCreateStatementContext is an interface to support dynamic dispatch.
type ISupportedCreateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedCreateStatementContext differentiates from other interfaces.
	IsSupportedCreateStatementContext()
}

type SupportedCreateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedCreateStatementContext() *SupportedCreateStatementContext {
	var p = new(SupportedCreateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedCreateStatement
	return p
}

func InitEmptySupportedCreateStatementContext(p *SupportedCreateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedCreateStatement
}

func (*SupportedCreateStatementContext) IsSupportedCreateStatementContext() {}

func NewSupportedCreateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedCreateStatementContext {
	var p = new(SupportedCreateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedCreateStatement

	return p
}

func (s *SupportedCreateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedCreateStatementContext) CopyAll(ctx *SupportedCreateStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedCreateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedCreateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CreateTableContext struct {
	SupportedCreateStatementContext
	name          IMultipartIdentifierContext
	ctasCols      IIdentifierListContext
	engine        IIdentifierContext
	keys          IIdentifierListContext
	clusterKeys   IIdentifierListContext
	partition     IPartitionTableContext
	hashKeys      IIdentifierListContext
	autoBucket    antlr.Token
	properties    IPropertyClauseContext
	extProperties IPropertyClauseContext
}

func NewCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableContext {
	var p = new(CreateTableContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateTableContext) GetAutoBucket() antlr.Token { return s.autoBucket }

func (s *CreateTableContext) SetAutoBucket(v antlr.Token) { s.autoBucket = v }

func (s *CreateTableContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CreateTableContext) GetCtasCols() IIdentifierListContext { return s.ctasCols }

func (s *CreateTableContext) GetEngine() IIdentifierContext { return s.engine }

func (s *CreateTableContext) GetKeys() IIdentifierListContext { return s.keys }

func (s *CreateTableContext) GetClusterKeys() IIdentifierListContext { return s.clusterKeys }

func (s *CreateTableContext) GetPartition() IPartitionTableContext { return s.partition }

func (s *CreateTableContext) GetHashKeys() IIdentifierListContext { return s.hashKeys }

func (s *CreateTableContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateTableContext) GetExtProperties() IPropertyClauseContext { return s.extProperties }

func (s *CreateTableContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CreateTableContext) SetCtasCols(v IIdentifierListContext) { s.ctasCols = v }

func (s *CreateTableContext) SetEngine(v IIdentifierContext) { s.engine = v }

func (s *CreateTableContext) SetKeys(v IIdentifierListContext) { s.keys = v }

func (s *CreateTableContext) SetClusterKeys(v IIdentifierListContext) { s.clusterKeys = v }

func (s *CreateTableContext) SetPartition(v IPartitionTableContext) { s.partition = v }

func (s *CreateTableContext) SetHashKeys(v IIdentifierListContext) { s.hashKeys = v }

func (s *CreateTableContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateTableContext) SetExtProperties(v IPropertyClauseContext) { s.extProperties = v }

func (s *CreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *CreateTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateTableContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateTableContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateTableContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(DorisParserENGINE, 0)
}

func (s *CreateTableContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *CreateTableContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserKEY, 0)
}

func (s *CreateTableContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *CreateTableContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateTableContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTRIBUTED, 0)
}

func (s *CreateTableContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(DorisParserBY)
}

func (s *CreateTableContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserBY, i)
}

func (s *CreateTableContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *CreateTableContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserLEFT_PAREN)
}

func (s *CreateTableContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, i)
}

func (s *CreateTableContext) RollupDefs() IRollupDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupDefsContext)
}

func (s *CreateTableContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserRIGHT_PAREN)
}

func (s *CreateTableContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, i)
}

func (s *CreateTableContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserBROKER, 0)
}

func (s *CreateTableContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *CreateTableContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateTableContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisParserEXTERNAL, 0)
}

func (s *CreateTableContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *CreateTableContext) ColumnDefs() IColumnDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefsContext)
}

func (s *CreateTableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateTableContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(DorisParserAGGREGATE, 0)
}

func (s *CreateTableContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(DorisParserUNIQUE, 0)
}

func (s *CreateTableContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(DorisParserDUPLICATE, 0)
}

func (s *CreateTableContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateTableContext) PartitionTable() IPartitionTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionTableContext)
}

func (s *CreateTableContext) AllPropertyClause() []IPropertyClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			len++
		}
	}

	tst := make([]IPropertyClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyClauseContext); ok {
			tst[i] = t.(IPropertyClauseContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableContext) PropertyClause(i int) IPropertyClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateTableContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisParserHASH, 0)
}

func (s *CreateTableContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(DorisParserRANDOM, 0)
}

func (s *CreateTableContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(DorisParserCLUSTER, 0)
}

func (s *CreateTableContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisParserBUCKETS, 0)
}

func (s *CreateTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *CreateTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *CreateTableContext) IndexDefs() IIndexDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexDefsContext)
}

func (s *CreateTableContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *CreateTableContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO, 0)
}

func (s *CreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateTable(s)
	}
}

func (s *CreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateTable(s)
	}
}

type CreateWorkloadPolicyContext struct {
	SupportedCreateStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewCreateWorkloadPolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateWorkloadPolicyContext {
	var p = new(CreateWorkloadPolicyContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateWorkloadPolicyContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *CreateWorkloadPolicyContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateWorkloadPolicyContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *CreateWorkloadPolicyContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateWorkloadPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateWorkloadPolicyContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateWorkloadPolicyContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserWORKLOAD, 0)
}

func (s *CreateWorkloadPolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *CreateWorkloadPolicyContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CreateWorkloadPolicyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateWorkloadPolicyContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateWorkloadPolicyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateWorkloadPolicyContext) CONDITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserCONDITIONS, 0)
}

func (s *CreateWorkloadPolicyContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserLEFT_PAREN)
}

func (s *CreateWorkloadPolicyContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, i)
}

func (s *CreateWorkloadPolicyContext) WorkloadPolicyConditions() IWorkloadPolicyConditionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWorkloadPolicyConditionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWorkloadPolicyConditionsContext)
}

func (s *CreateWorkloadPolicyContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserRIGHT_PAREN)
}

func (s *CreateWorkloadPolicyContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, i)
}

func (s *CreateWorkloadPolicyContext) ACTIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserACTIONS, 0)
}

func (s *CreateWorkloadPolicyContext) WorkloadPolicyActions() IWorkloadPolicyActionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWorkloadPolicyActionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWorkloadPolicyActionsContext)
}

func (s *CreateWorkloadPolicyContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateWorkloadPolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateWorkloadPolicy(s)
	}
}

func (s *CreateWorkloadPolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateWorkloadPolicy(s)
	}
}

type CreateResourceContext struct {
	SupportedCreateStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewCreateResourceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateResourceContext {
	var p = new(CreateResourceContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateResourceContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *CreateResourceContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateResourceContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *CreateResourceContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateResourceContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateResourceContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCE, 0)
}

func (s *CreateResourceContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CreateResourceContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisParserEXTERNAL, 0)
}

func (s *CreateResourceContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateResourceContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateResourceContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateResourceContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateResourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateResource(s)
	}
}

func (s *CreateResourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateResource(s)
	}
}

type CreateWorkloadGroupContext struct {
	SupportedCreateStatementContext
	name         IIdentifierOrTextContext
	computeGroup IIdentifierOrTextContext
	properties   IPropertyClauseContext
}

func NewCreateWorkloadGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateWorkloadGroupContext {
	var p = new(CreateWorkloadGroupContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateWorkloadGroupContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *CreateWorkloadGroupContext) GetComputeGroup() IIdentifierOrTextContext {
	return s.computeGroup
}

func (s *CreateWorkloadGroupContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateWorkloadGroupContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *CreateWorkloadGroupContext) SetComputeGroup(v IIdentifierOrTextContext) { s.computeGroup = v }

func (s *CreateWorkloadGroupContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateWorkloadGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateWorkloadGroupContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateWorkloadGroupContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserWORKLOAD, 0)
}

func (s *CreateWorkloadGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUP, 0)
}

func (s *CreateWorkloadGroupContext) AllIdentifierOrText() []IIdentifierOrTextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrTextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrTextContext); ok {
			tst[i] = t.(IIdentifierOrTextContext)
			i++
		}
	}

	return tst
}

func (s *CreateWorkloadGroupContext) IdentifierOrText(i int) IIdentifierOrTextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CreateWorkloadGroupContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateWorkloadGroupContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateWorkloadGroupContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateWorkloadGroupContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *CreateWorkloadGroupContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateWorkloadGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateWorkloadGroup(s)
	}
}

func (s *CreateWorkloadGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateWorkloadGroup(s)
	}
}

type CreateDictionaryContext struct {
	SupportedCreateStatementContext
	name       IMultipartIdentifierContext
	source     IMultipartIdentifierContext
	layoutType IIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateDictionaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateDictionaryContext {
	var p = new(CreateDictionaryContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateDictionaryContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CreateDictionaryContext) GetSource() IMultipartIdentifierContext { return s.source }

func (s *CreateDictionaryContext) GetLayoutType() IIdentifierContext { return s.layoutType }

func (s *CreateDictionaryContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateDictionaryContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CreateDictionaryContext) SetSource(v IMultipartIdentifierContext) { s.source = v }

func (s *CreateDictionaryContext) SetLayoutType(v IIdentifierContext) { s.layoutType = v }

func (s *CreateDictionaryContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateDictionaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDictionaryContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateDictionaryContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(DorisParserDICTIONARY, 0)
}

func (s *CreateDictionaryContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserUSING, 0)
}

func (s *CreateDictionaryContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserLEFT_PAREN)
}

func (s *CreateDictionaryContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, i)
}

func (s *CreateDictionaryContext) DictionaryColumnDefs() IDictionaryColumnDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDictionaryColumnDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDictionaryColumnDefsContext)
}

func (s *CreateDictionaryContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserRIGHT_PAREN)
}

func (s *CreateDictionaryContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, i)
}

func (s *CreateDictionaryContext) LAYOUT() antlr.TerminalNode {
	return s.GetToken(DorisParserLAYOUT, 0)
}

func (s *CreateDictionaryContext) AllMultipartIdentifier() []IMultipartIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultipartIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipartIdentifierContext); ok {
			tst[i] = t.(IMultipartIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateDictionaryContext) MultipartIdentifier(i int) IMultipartIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateDictionaryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateDictionaryContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateDictionaryContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateDictionaryContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateDictionaryContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateDictionaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateDictionary(s)
	}
}

func (s *CreateDictionaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateDictionary(s)
	}
}

type CreateTableLikeContext struct {
	SupportedCreateStatementContext
	name         IMultipartIdentifierContext
	existedTable IMultipartIdentifierContext
	rollupNames  IIdentifierListContext
}

func NewCreateTableLikeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableLikeContext {
	var p = new(CreateTableLikeContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateTableLikeContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CreateTableLikeContext) GetExistedTable() IMultipartIdentifierContext { return s.existedTable }

func (s *CreateTableLikeContext) GetRollupNames() IIdentifierListContext { return s.rollupNames }

func (s *CreateTableLikeContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CreateTableLikeContext) SetExistedTable(v IMultipartIdentifierContext) { s.existedTable = v }

func (s *CreateTableLikeContext) SetRollupNames(v IIdentifierListContext) { s.rollupNames = v }

func (s *CreateTableLikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableLikeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateTableLikeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *CreateTableLikeContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *CreateTableLikeContext) AllMultipartIdentifier() []IMultipartIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultipartIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipartIdentifierContext); ok {
			tst[i] = t.(IMultipartIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableLikeContext) MultipartIdentifier(i int) IMultipartIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateTableLikeContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateTableLikeContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateTableLikeContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateTableLikeContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *CreateTableLikeContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *CreateTableLikeContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisParserEXTERNAL, 0)
}

func (s *CreateTableLikeContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *CreateTableLikeContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateTableLikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateTableLike(s)
	}
}

func (s *CreateTableLikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateTableLike(s)
	}
}

type CreateRoleContext struct {
	SupportedCreateStatementContext
	name IIdentifierOrTextContext
}

func NewCreateRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateRoleContext {
	var p = new(CreateRoleContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateRoleContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *CreateRoleContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *CreateRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoleContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *CreateRoleContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CreateRoleContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateRoleContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateRoleContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateRoleContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *CreateRoleContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateRole(s)
	}
}

func (s *CreateRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateRole(s)
	}
}

type CreateStageContext struct {
	SupportedCreateStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateStageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateStageContext {
	var p = new(CreateStageContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateStageContext) GetName() IIdentifierContext { return s.name }

func (s *CreateStageContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateStageContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateStageContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateStageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStageContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateStageContext) STAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTAGE, 0)
}

func (s *CreateStageContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateStageContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateStageContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateStageContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateStageContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateStageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateStage(s)
	}
}

func (s *CreateStageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateStage(s)
	}
}

type CreateIndexAnalyzerContext struct {
	SupportedCreateStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateIndexAnalyzerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateIndexAnalyzerContext {
	var p = new(CreateIndexAnalyzerContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateIndexAnalyzerContext) GetName() IIdentifierContext { return s.name }

func (s *CreateIndexAnalyzerContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateIndexAnalyzerContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateIndexAnalyzerContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateIndexAnalyzerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexAnalyzerContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateIndexAnalyzerContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserINVERTED, 0)
}

func (s *CreateIndexAnalyzerContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *CreateIndexAnalyzerContext) ANALYZER() antlr.TerminalNode {
	return s.GetToken(DorisParserANALYZER, 0)
}

func (s *CreateIndexAnalyzerContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateIndexAnalyzerContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateIndexAnalyzerContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateIndexAnalyzerContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateIndexAnalyzerContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateIndexAnalyzerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateIndexAnalyzer(s)
	}
}

func (s *CreateIndexAnalyzerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateIndexAnalyzer(s)
	}
}

type CreateIndexTokenizerContext struct {
	SupportedCreateStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateIndexTokenizerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateIndexTokenizerContext {
	var p = new(CreateIndexTokenizerContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateIndexTokenizerContext) GetName() IIdentifierContext { return s.name }

func (s *CreateIndexTokenizerContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateIndexTokenizerContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateIndexTokenizerContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateIndexTokenizerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexTokenizerContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateIndexTokenizerContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserINVERTED, 0)
}

func (s *CreateIndexTokenizerContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *CreateIndexTokenizerContext) TOKENIZER() antlr.TerminalNode {
	return s.GetToken(DorisParserTOKENIZER, 0)
}

func (s *CreateIndexTokenizerContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateIndexTokenizerContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateIndexTokenizerContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateIndexTokenizerContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateIndexTokenizerContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateIndexTokenizerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateIndexTokenizer(s)
	}
}

func (s *CreateIndexTokenizerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateIndexTokenizer(s)
	}
}

type CreateFileContext struct {
	SupportedCreateStatementContext
	name       antlr.Token
	database   IIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateFileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateFileContext {
	var p = new(CreateFileContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateFileContext) GetName() antlr.Token { return s.name }

func (s *CreateFileContext) SetName(v antlr.Token) { s.name = v }

func (s *CreateFileContext) GetDatabase() IIdentifierContext { return s.database }

func (s *CreateFileContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateFileContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *CreateFileContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFileContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateFileContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisParserFILE, 0)
}

func (s *CreateFileContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateFileContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateFileContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *CreateFileContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *CreateFileContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateFile(s)
	}
}

func (s *CreateFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateFile(s)
	}
}

type CreateRowPolicyContext struct {
	SupportedCreateStatementContext
	name     IIdentifierContext
	table    IMultipartIdentifierContext
	type_    antlr.Token
	user     IUserIdentifyContext
	roleName IIdentifierOrTextContext
}

func NewCreateRowPolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateRowPolicyContext {
	var p = new(CreateRowPolicyContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateRowPolicyContext) GetType_() antlr.Token { return s.type_ }

func (s *CreateRowPolicyContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *CreateRowPolicyContext) GetName() IIdentifierContext { return s.name }

func (s *CreateRowPolicyContext) GetTable() IMultipartIdentifierContext { return s.table }

func (s *CreateRowPolicyContext) GetUser() IUserIdentifyContext { return s.user }

func (s *CreateRowPolicyContext) GetRoleName() IIdentifierOrTextContext { return s.roleName }

func (s *CreateRowPolicyContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateRowPolicyContext) SetTable(v IMultipartIdentifierContext) { s.table = v }

func (s *CreateRowPolicyContext) SetUser(v IUserIdentifyContext) { s.user = v }

func (s *CreateRowPolicyContext) SetRoleName(v IIdentifierOrTextContext) { s.roleName = v }

func (s *CreateRowPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRowPolicyContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateRowPolicyContext) ROW() antlr.TerminalNode {
	return s.GetToken(DorisParserROW, 0)
}

func (s *CreateRowPolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *CreateRowPolicyContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *CreateRowPolicyContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *CreateRowPolicyContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *CreateRowPolicyContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserUSING, 0)
}

func (s *CreateRowPolicyContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CreateRowPolicyContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *CreateRowPolicyContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CreateRowPolicyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRowPolicyContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateRowPolicyContext) RESTRICTIVE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESTRICTIVE, 0)
}

func (s *CreateRowPolicyContext) PERMISSIVE() antlr.TerminalNode {
	return s.GetToken(DorisParserPERMISSIVE, 0)
}

func (s *CreateRowPolicyContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *CreateRowPolicyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateRowPolicyContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateRowPolicyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateRowPolicyContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *CreateRowPolicyContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CreateRowPolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateRowPolicy(s)
	}
}

func (s *CreateRowPolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateRowPolicy(s)
	}
}

type CreateEncryptkeyContext struct {
	SupportedCreateStatementContext
}

func NewCreateEncryptkeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateEncryptkeyContext {
	var p = new(CreateEncryptkeyContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateEncryptkeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateEncryptkeyContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateEncryptkeyContext) ENCRYPTKEY() antlr.TerminalNode {
	return s.GetToken(DorisParserENCRYPTKEY, 0)
}

func (s *CreateEncryptkeyContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateEncryptkeyContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *CreateEncryptkeyContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateEncryptkeyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateEncryptkeyContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateEncryptkeyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateEncryptkeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateEncryptkey(s)
	}
}

func (s *CreateEncryptkeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateEncryptkey(s)
	}
}

type CreateViewContext struct {
	SupportedCreateStatementContext
	name IMultipartIdentifierContext
	cols ISimpleColumnDefsContext
}

func NewCreateViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateViewContext {
	var p = new(CreateViewContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateViewContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CreateViewContext) GetCols() ISimpleColumnDefsContext { return s.cols }

func (s *CreateViewContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CreateViewContext) SetCols(v ISimpleColumnDefsContext) { s.cols = v }

func (s *CreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *CreateViewContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *CreateViewContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateViewContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateViewContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisParserOR, 0)
}

func (s *CreateViewContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *CreateViewContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateViewContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateViewContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateViewContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CreateViewContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CreateViewContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *CreateViewContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateViewContext) SimpleColumnDefs() ISimpleColumnDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleColumnDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleColumnDefsContext)
}

func (s *CreateViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateView(s)
	}
}

func (s *CreateViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateView(s)
	}
}

type CreateStorageVaultContext struct {
	SupportedCreateStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewCreateStorageVaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateStorageVaultContext {
	var p = new(CreateStorageVaultContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateStorageVaultContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *CreateStorageVaultContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateStorageVaultContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *CreateStorageVaultContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateStorageVaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStorageVaultContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateStorageVaultContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *CreateStorageVaultContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULT, 0)
}

func (s *CreateStorageVaultContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CreateStorageVaultContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateStorageVaultContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateStorageVaultContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateStorageVaultContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateStorageVaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateStorageVault(s)
	}
}

func (s *CreateStorageVaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateStorageVault(s)
	}
}

type CreateUserDefineFunctionContext struct {
	SupportedCreateStatementContext
	returnType       IDataTypeContext
	intermediateType IDataTypeContext
	properties       IPropertyClauseContext
}

func NewCreateUserDefineFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateUserDefineFunctionContext {
	var p = new(CreateUserDefineFunctionContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateUserDefineFunctionContext) GetReturnType() IDataTypeContext { return s.returnType }

func (s *CreateUserDefineFunctionContext) GetIntermediateType() IDataTypeContext {
	return s.intermediateType
}

func (s *CreateUserDefineFunctionContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateUserDefineFunctionContext) SetReturnType(v IDataTypeContext) { s.returnType = v }

func (s *CreateUserDefineFunctionContext) SetIntermediateType(v IDataTypeContext) {
	s.intermediateType = v
}

func (s *CreateUserDefineFunctionContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateUserDefineFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserDefineFunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateUserDefineFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserFUNCTION, 0)
}

func (s *CreateUserDefineFunctionContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *CreateUserDefineFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CreateUserDefineFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CreateUserDefineFunctionContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(DorisParserRETURNS, 0)
}

func (s *CreateUserDefineFunctionContext) AllDataType() []IDataTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeContext); ok {
			tst[i] = t.(IDataTypeContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserDefineFunctionContext) DataType(i int) IDataTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CreateUserDefineFunctionContext) StatementScope() IStatementScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementScopeContext)
}

func (s *CreateUserDefineFunctionContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateUserDefineFunctionContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateUserDefineFunctionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateUserDefineFunctionContext) FunctionArguments() IFunctionArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgumentsContext)
}

func (s *CreateUserDefineFunctionContext) INTERMEDIATE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTERMEDIATE, 0)
}

func (s *CreateUserDefineFunctionContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLES, 0)
}

func (s *CreateUserDefineFunctionContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(DorisParserAGGREGATE, 0)
}

func (s *CreateUserDefineFunctionContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateUserDefineFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateUserDefineFunction(s)
	}
}

func (s *CreateUserDefineFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateUserDefineFunction(s)
	}
}

type CreateStoragePolicyContext struct {
	SupportedCreateStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateStoragePolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateStoragePolicyContext {
	var p = new(CreateStoragePolicyContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateStoragePolicyContext) GetName() IIdentifierContext { return s.name }

func (s *CreateStoragePolicyContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateStoragePolicyContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateStoragePolicyContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateStoragePolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStoragePolicyContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateStoragePolicyContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *CreateStoragePolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *CreateStoragePolicyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateStoragePolicyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateStoragePolicyContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateStoragePolicyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateStoragePolicyContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateStoragePolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateStoragePolicy(s)
	}
}

func (s *CreateStoragePolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateStoragePolicy(s)
	}
}

type CreateIndexContext struct {
	SupportedCreateStatementContext
	name       IIdentifierContext
	tableName  IMultipartIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateIndexContext {
	var p = new(CreateIndexContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateIndexContext) GetName() IIdentifierContext { return s.name }

func (s *CreateIndexContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *CreateIndexContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateIndexContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateIndexContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *CreateIndexContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *CreateIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *CreateIndexContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateIndexContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateIndexContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateIndexContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateIndexContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateIndexContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateIndexContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserUSING, 0)
}

func (s *CreateIndexContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *CreateIndexContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateIndexContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(DorisParserBITMAP, 0)
}

func (s *CreateIndexContext) NGRAM_BF() antlr.TerminalNode {
	return s.GetToken(DorisParserNGRAM_BF, 0)
}

func (s *CreateIndexContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserINVERTED, 0)
}

func (s *CreateIndexContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateIndex(s)
	}
}

func (s *CreateIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateIndex(s)
	}
}

type CreateRepositoryContext struct {
	SupportedCreateStatementContext
	name IIdentifierContext
}

func NewCreateRepositoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateRepositoryContext {
	var p = new(CreateRepositoryContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateRepositoryContext) GetName() IIdentifierContext { return s.name }

func (s *CreateRepositoryContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateRepositoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRepositoryContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateRepositoryContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisParserREPOSITORY, 0)
}

func (s *CreateRepositoryContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *CreateRepositoryContext) StorageBackend() IStorageBackendContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStorageBackendContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStorageBackendContext)
}

func (s *CreateRepositoryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRepositoryContext) READ() antlr.TerminalNode {
	return s.GetToken(DorisParserREAD, 0)
}

func (s *CreateRepositoryContext) ONLY() antlr.TerminalNode {
	return s.GetToken(DorisParserONLY, 0)
}

func (s *CreateRepositoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateRepository(s)
	}
}

func (s *CreateRepositoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateRepository(s)
	}
}

type CreateDatabaseContext struct {
	SupportedCreateStatementContext
	name       IMultipartIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateDatabaseContext {
	var p = new(CreateDatabaseContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateDatabaseContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CreateDatabaseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateDatabaseContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CreateDatabaseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDatabaseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *CreateDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEMA, 0)
}

func (s *CreateDatabaseContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateDatabaseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateDatabaseContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateDatabaseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateDatabaseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateDatabase(s)
	}
}

func (s *CreateDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateDatabase(s)
	}
}

type BuildIndexContext struct {
	SupportedCreateStatementContext
	name      IIdentifierContext
	tableName IMultipartIdentifierContext
}

func NewBuildIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BuildIndexContext {
	var p = new(BuildIndexContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *BuildIndexContext) GetName() IIdentifierContext { return s.name }

func (s *BuildIndexContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *BuildIndexContext) SetName(v IIdentifierContext) { s.name = v }

func (s *BuildIndexContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *BuildIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BuildIndexContext) BUILD() antlr.TerminalNode {
	return s.GetToken(DorisParserBUILD, 0)
}

func (s *BuildIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *BuildIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *BuildIndexContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BuildIndexContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *BuildIndexContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *BuildIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBuildIndex(s)
	}
}

func (s *BuildIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBuildIndex(s)
	}
}

type CreateUserContext struct {
	SupportedCreateStatementContext
	role antlr.Token
}

func NewCreateUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateUserContext {
	var p = new(CreateUserContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateUserContext) GetRole() antlr.Token { return s.role }

func (s *CreateUserContext) SetRole(v antlr.Token) { s.role = v }

func (s *CreateUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateUserContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisParserUSER, 0)
}

func (s *CreateUserContext) GrantUserIdentify() IGrantUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantUserIdentifyContext)
}

func (s *CreateUserContext) PasswordOption() IPasswordOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordOptionContext)
}

func (s *CreateUserContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateUserContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateUserContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateUserContext) SUPERUSER() antlr.TerminalNode {
	return s.GetToken(DorisParserSUPERUSER, 0)
}

func (s *CreateUserContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *CreateUserContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *CreateUserContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *CreateUserContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateUser(s)
	}
}

func (s *CreateUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateUser(s)
	}
}

type CreateCatalogContext struct {
	SupportedCreateStatementContext
	catalogName  IIdentifierContext
	resourceName IIdentifierContext
	properties   IPropertyClauseContext
}

func NewCreateCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateCatalogContext {
	var p = new(CreateCatalogContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateCatalogContext) GetCatalogName() IIdentifierContext { return s.catalogName }

func (s *CreateCatalogContext) GetResourceName() IIdentifierContext { return s.resourceName }

func (s *CreateCatalogContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateCatalogContext) SetCatalogName(v IIdentifierContext) { s.catalogName = v }

func (s *CreateCatalogContext) SetResourceName(v IIdentifierContext) { s.resourceName = v }

func (s *CreateCatalogContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateCatalogContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateCatalogContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *CreateCatalogContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateCatalogContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateCatalogContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateCatalogContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateCatalogContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateCatalogContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *CreateCatalogContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCE, 0)
}

func (s *CreateCatalogContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *CreateCatalogContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CreateCatalogContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateCatalogContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateCatalog(s)
	}
}

func (s *CreateCatalogContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateCatalog(s)
	}
}

type CreateAliasFunctionContext struct {
	SupportedCreateStatementContext
	parameters IIdentifierSeqContext
}

func NewCreateAliasFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateAliasFunctionContext {
	var p = new(CreateAliasFunctionContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateAliasFunctionContext) GetParameters() IIdentifierSeqContext { return s.parameters }

func (s *CreateAliasFunctionContext) SetParameters(v IIdentifierSeqContext) { s.parameters = v }

func (s *CreateAliasFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateAliasFunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateAliasFunctionContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(DorisParserALIAS, 0)
}

func (s *CreateAliasFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserFUNCTION, 0)
}

func (s *CreateAliasFunctionContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *CreateAliasFunctionContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserLEFT_PAREN)
}

func (s *CreateAliasFunctionContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, i)
}

func (s *CreateAliasFunctionContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserRIGHT_PAREN)
}

func (s *CreateAliasFunctionContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, i)
}

func (s *CreateAliasFunctionContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *CreateAliasFunctionContext) PARAMETER() antlr.TerminalNode {
	return s.GetToken(DorisParserPARAMETER, 0)
}

func (s *CreateAliasFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *CreateAliasFunctionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CreateAliasFunctionContext) StatementScope() IStatementScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementScopeContext)
}

func (s *CreateAliasFunctionContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateAliasFunctionContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateAliasFunctionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateAliasFunctionContext) FunctionArguments() IFunctionArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgumentsContext)
}

func (s *CreateAliasFunctionContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *CreateAliasFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateAliasFunction(s)
	}
}

func (s *CreateAliasFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateAliasFunction(s)
	}
}

type CreateSqlBlockRuleContext struct {
	SupportedCreateStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateSqlBlockRuleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateSqlBlockRuleContext {
	var p = new(CreateSqlBlockRuleContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateSqlBlockRuleContext) GetName() IIdentifierContext { return s.name }

func (s *CreateSqlBlockRuleContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateSqlBlockRuleContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateSqlBlockRuleContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateSqlBlockRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateSqlBlockRuleContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateSqlBlockRuleContext) SQL_BLOCK_RULE() antlr.TerminalNode {
	return s.GetToken(DorisParserSQL_BLOCK_RULE, 0)
}

func (s *CreateSqlBlockRuleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateSqlBlockRuleContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateSqlBlockRuleContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateSqlBlockRuleContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateSqlBlockRuleContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateSqlBlockRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateSqlBlockRule(s)
	}
}

func (s *CreateSqlBlockRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateSqlBlockRule(s)
	}
}

type CreateIndexTokenFilterContext struct {
	SupportedCreateStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateIndexTokenFilterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateIndexTokenFilterContext {
	var p = new(CreateIndexTokenFilterContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateIndexTokenFilterContext) GetName() IIdentifierContext { return s.name }

func (s *CreateIndexTokenFilterContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateIndexTokenFilterContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateIndexTokenFilterContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateIndexTokenFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexTokenFilterContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateIndexTokenFilterContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserINVERTED, 0)
}

func (s *CreateIndexTokenFilterContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *CreateIndexTokenFilterContext) TOKEN_FILTER() antlr.TerminalNode {
	return s.GetToken(DorisParserTOKEN_FILTER, 0)
}

func (s *CreateIndexTokenFilterContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateIndexTokenFilterContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateIndexTokenFilterContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateIndexTokenFilterContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateIndexTokenFilterContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateIndexTokenFilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateIndexTokenFilter(s)
	}
}

func (s *CreateIndexTokenFilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateIndexTokenFilter(s)
	}
}

func (p *DorisParser) SupportedCreateStatement() (localctx ISupportedCreateStatementContext) {
	localctx = NewSupportedCreateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, DorisParserRULE_supportedCreateStatement)
	var _la int

	p.SetState(1482)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 171, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(994)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(996)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserEXTERNAL || _la == DorisParserTEMPORARY {
			{
				p.SetState(995)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserEXTERNAL || _la == DorisParserTEMPORARY) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(998)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1002)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(999)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1000)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1001)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1004)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateTableContext).name = _x
		}
		p.SetState(1019)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext()) {
		case 1:
			p.SetState(1006)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserLEFT_PAREN {
				{
					p.SetState(1005)

					var _x = p.IdentifierList()

					localctx.(*CreateTableContext).ctasCols = _x
				}

			}

		case 2:
			{
				p.SetState(1008)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1009)
				p.ColumnDefs()
			}
			p.SetState(1012)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1010)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1011)
					p.IndexDefs()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			p.SetState(1015)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserCOMMA {
				{
					p.SetState(1014)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1017)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(1024)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserENGINE {
			{
				p.SetState(1021)
				p.Match(DorisParserENGINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1022)
				p.Match(DorisParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1023)

				var _x = p.Identifier()

				localctx.(*CreateTableContext).engine = _x
			}

		}
		p.SetState(1034)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAGGREGATE || _la == DorisParserDUPLICATE || _la == DorisParserUNIQUE {
			{
				p.SetState(1026)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserAGGREGATE || _la == DorisParserDUPLICATE || _la == DorisParserUNIQUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1027)
				p.Match(DorisParserKEY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1028)

				var _x = p.IdentifierList()

				localctx.(*CreateTableContext).keys = _x
			}
			p.SetState(1032)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserCLUSTER {
				{
					p.SetState(1029)
					p.Match(DorisParserCLUSTER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1030)
					p.Match(DorisParserBY)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1031)

					var _x = p.IdentifierList()

					localctx.(*CreateTableContext).clusterKeys = _x
				}

			}

		}
		p.SetState(1038)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(1036)
				p.Match(DorisParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1037)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1041)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAUTO || _la == DorisParserPARTITION {
			{
				p.SetState(1040)

				var _x = p.PartitionTable()

				localctx.(*CreateTableContext).partition = _x
			}

		}
		p.SetState(1057)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserDISTRIBUTED {
			{
				p.SetState(1043)
				p.Match(DorisParserDISTRIBUTED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1044)
				p.Match(DorisParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1048)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserHASH:
				{
					p.SetState(1045)
					p.Match(DorisParserHASH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1046)

					var _x = p.IdentifierList()

					localctx.(*CreateTableContext).hashKeys = _x
				}

			case DorisParserRANDOM:
				{
					p.SetState(1047)
					p.Match(DorisParserRANDOM)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			p.SetState(1055)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserBUCKETS {
				{
					p.SetState(1050)
					p.Match(DorisParserBUCKETS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1053)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DorisParserINTEGER_VALUE:
					{
						p.SetState(1051)
						p.Match(DorisParserINTEGER_VALUE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case DorisParserAUTO:
					{
						p.SetState(1052)

						var _m = p.Match(DorisParserAUTO)

						localctx.(*CreateTableContext).autoBucket = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			}

		}
		p.SetState(1064)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserROLLUP {
			{
				p.SetState(1059)
				p.Match(DorisParserROLLUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1060)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1061)
				p.RollupDefs()
			}
			{
				p.SetState(1062)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1067)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1066)

				var _x = p.PropertyClause()

				localctx.(*CreateTableContext).properties = _x
			}

		}
		p.SetState(1071)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserBROKER {
			{
				p.SetState(1069)
				p.Match(DorisParserBROKER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1070)

				var _x = p.PropertyClause()

				localctx.(*CreateTableContext).extProperties = _x
			}

		}
		p.SetState(1075)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAS {
			{
				p.SetState(1073)
				p.Match(DorisParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1074)
				p.Query()
			}

		}

	case 2:
		localctx = NewCreateViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1077)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1080)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserOR {
			{
				p.SetState(1078)
				p.Match(DorisParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1079)
				p.Match(DorisParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1082)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1086)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1083)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1084)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1085)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1088)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateViewContext).name = _x
		}
		p.SetState(1093)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(1089)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1090)

				var _x = p.SimpleColumnDefs()

				localctx.(*CreateViewContext).cols = _x
			}
			{
				p.SetState(1091)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1097)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(1095)
				p.Match(DorisParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1096)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1099)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1100)
			p.Query()
		}

	case 3:
		localctx = NewCreateFileContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1102)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1103)
			p.Match(DorisParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1104)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*CreateFileContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1107)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1105)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1106)

				var _x = p.Identifier()

				localctx.(*CreateFileContext).database = _x
			}

		}
		{
			p.SetState(1109)

			var _x = p.PropertyClause()

			localctx.(*CreateFileContext).properties = _x
		}

	case 4:
		localctx = NewCreateTableLikeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1110)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1112)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserEXTERNAL || _la == DorisParserTEMPORARY {
			{
				p.SetState(1111)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserEXTERNAL || _la == DorisParserTEMPORARY) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1114)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1118)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1115)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1116)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1117)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1120)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateTableLikeContext).name = _x
		}
		{
			p.SetState(1121)
			p.Match(DorisParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1122)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateTableLikeContext).existedTable = _x
		}
		p.SetState(1128)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(1123)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1124)
				p.Match(DorisParserROLLUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1126)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserLEFT_PAREN {
				{
					p.SetState(1125)

					var _x = p.IdentifierList()

					localctx.(*CreateTableLikeContext).rollupNames = _x
				}

			}

		}

	case 5:
		localctx = NewCreateRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1130)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1131)
			p.Match(DorisParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1135)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1132)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1133)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1134)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1137)

			var _x = p.IdentifierOrText()

			localctx.(*CreateRoleContext).name = _x
		}
		p.SetState(1140)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(1138)
				p.Match(DorisParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1139)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		localctx = NewCreateWorkloadGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1142)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1143)
			p.Match(DorisParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1144)
			p.Match(DorisParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1148)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1145)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1146)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1147)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1150)

			var _x = p.IdentifierOrText()

			localctx.(*CreateWorkloadGroupContext).name = _x
		}
		p.SetState(1153)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFOR {
			{
				p.SetState(1151)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1152)

				var _x = p.IdentifierOrText()

				localctx.(*CreateWorkloadGroupContext).computeGroup = _x
			}

		}
		p.SetState(1156)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1155)

				var _x = p.PropertyClause()

				localctx.(*CreateWorkloadGroupContext).properties = _x
			}

		}

	case 7:
		localctx = NewCreateCatalogContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1158)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1159)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1163)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1160)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1161)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1162)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1165)

			var _x = p.Identifier()

			localctx.(*CreateCatalogContext).catalogName = _x
		}
		p.SetState(1169)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(1166)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1167)
				p.Match(DorisParserRESOURCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1168)

				var _x = p.Identifier()

				localctx.(*CreateCatalogContext).resourceName = _x
			}

		}
		p.SetState(1173)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(1171)
				p.Match(DorisParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1172)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1176)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1175)

				var _x = p.PropertyClause()

				localctx.(*CreateCatalogContext).properties = _x
			}

		}

	case 8:
		localctx = NewCreateRowPolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1178)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1179)
			p.Match(DorisParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1180)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1184)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1181)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1182)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1183)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1186)

			var _x = p.Identifier()

			localctx.(*CreateRowPolicyContext).name = _x
		}
		{
			p.SetState(1187)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1188)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateRowPolicyContext).table = _x
		}
		{
			p.SetState(1189)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1190)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateRowPolicyContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserPERMISSIVE || _la == DorisParserRESTRICTIVE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateRowPolicyContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1191)
			p.Match(DorisParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1195)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(1192)

				var _x = p.UserIdentify()

				localctx.(*CreateRowPolicyContext).user = _x
			}

		case DorisParserROLE:
			{
				p.SetState(1193)
				p.Match(DorisParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1194)

				var _x = p.IdentifierOrText()

				localctx.(*CreateRowPolicyContext).roleName = _x
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(1197)
			p.Match(DorisParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1198)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1199)
			p.booleanExpression(0)
		}
		{
			p.SetState(1200)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewCreateStoragePolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1202)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1203)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1204)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1208)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1205)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1206)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1207)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1210)

			var _x = p.Identifier()

			localctx.(*CreateStoragePolicyContext).name = _x
		}
		p.SetState(1212)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1211)

				var _x = p.PropertyClause()

				localctx.(*CreateStoragePolicyContext).properties = _x
			}

		}

	case 10:
		localctx = NewBuildIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1214)
			p.Match(DorisParserBUILD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1215)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1216)

			var _x = p.Identifier()

			localctx.(*BuildIndexContext).name = _x
		}
		{
			p.SetState(1217)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1218)

			var _x = p.MultipartIdentifier()

			localctx.(*BuildIndexContext).tableName = _x
		}
		p.SetState(1220)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(1219)
				p.PartitionSpec()
			}

		}

	case 11:
		localctx = NewCreateIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1222)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1223)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1227)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1224)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1225)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1226)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1229)

			var _x = p.Identifier()

			localctx.(*CreateIndexContext).name = _x
		}
		{
			p.SetState(1230)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1231)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateIndexContext).tableName = _x
		}
		{
			p.SetState(1232)
			p.IdentifierList()
		}
		p.SetState(1235)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserUSING {
			{
				p.SetState(1233)
				p.Match(DorisParserUSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1234)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserBITMAP || _la == DorisParserINVERTED || _la == DorisParserNGRAM_BF) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1238)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1237)

				var _x = p.PropertyClause()

				localctx.(*CreateIndexContext).properties = _x
			}

		}
		p.SetState(1242)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(1240)
				p.Match(DorisParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1241)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 12:
		localctx = NewCreateWorkloadPolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1244)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1245)
			p.Match(DorisParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1246)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1250)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1247)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1248)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1249)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1252)

			var _x = p.IdentifierOrText()

			localctx.(*CreateWorkloadPolicyContext).name = _x
		}
		p.SetState(1258)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCONDITIONS {
			{
				p.SetState(1253)
				p.Match(DorisParserCONDITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1254)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1255)
				p.WorkloadPolicyConditions()
			}
			{
				p.SetState(1256)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1265)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserACTIONS {
			{
				p.SetState(1260)
				p.Match(DorisParserACTIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1261)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1262)
				p.WorkloadPolicyActions()
			}
			{
				p.SetState(1263)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1268)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1267)

				var _x = p.PropertyClause()

				localctx.(*CreateWorkloadPolicyContext).properties = _x
			}

		}

	case 13:
		localctx = NewCreateSqlBlockRuleContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1270)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1271)
			p.Match(DorisParserSQL_BLOCK_RULE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1275)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1272)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1273)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1274)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1277)

			var _x = p.Identifier()

			localctx.(*CreateSqlBlockRuleContext).name = _x
		}
		p.SetState(1279)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1278)

				var _x = p.PropertyClause()

				localctx.(*CreateSqlBlockRuleContext).properties = _x
			}

		}

	case 14:
		localctx = NewCreateEncryptkeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1281)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1282)
			p.Match(DorisParserENCRYPTKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1286)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1283)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1284)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1285)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1288)
			p.MultipartIdentifier()
		}
		{
			p.SetState(1289)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1290)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		localctx = NewCreateUserDefineFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1292)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1294)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION {
			{
				p.SetState(1293)
				p.StatementScope()
			}

		}
		p.SetState(1297)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAGGREGATE || _la == DorisParserTABLES {
			{
				p.SetState(1296)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserAGGREGATE || _la == DorisParserTABLES) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1299)
			p.Match(DorisParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1303)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1300)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1301)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1302)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1305)
			p.FunctionIdentifier()
		}
		{
			p.SetState(1306)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1308)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&9152335059222592) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&32633505112391681) != 0) || _la == DorisParserDOUBLE || _la == DorisParserFLOAT || ((int64((_la-213)) & ^0x3f) == 0 && ((int64(1)<<(_la-213))&9208814108673) != 0) || _la == DorisParserMAP || _la == DorisParserQUANTILE_STATE || ((int64((_la-426)) & ^0x3f) == 0 && ((int64(1)<<(_la-426))&704375029761) != 0) || _la == DorisParserVARCHAR || _la == DorisParserVARIANT {
			{
				p.SetState(1307)
				p.FunctionArguments()
			}

		}
		{
			p.SetState(1310)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1311)
			p.Match(DorisParserRETURNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1312)

			var _x = p.DataType()

			localctx.(*CreateUserDefineFunctionContext).returnType = _x
		}
		p.SetState(1315)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserINTERMEDIATE {
			{
				p.SetState(1313)
				p.Match(DorisParserINTERMEDIATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1314)

				var _x = p.DataType()

				localctx.(*CreateUserDefineFunctionContext).intermediateType = _x
			}

		}
		p.SetState(1318)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1317)

				var _x = p.PropertyClause()

				localctx.(*CreateUserDefineFunctionContext).properties = _x
			}

		}

	case 16:
		localctx = NewCreateAliasFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1320)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1322)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION {
			{
				p.SetState(1321)
				p.StatementScope()
			}

		}
		{
			p.SetState(1324)
			p.Match(DorisParserALIAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1325)
			p.Match(DorisParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1329)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1326)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1327)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1328)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1331)
			p.FunctionIdentifier()
		}
		{
			p.SetState(1332)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1334)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&9152335059222592) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&32633505112391681) != 0) || _la == DorisParserDOUBLE || _la == DorisParserFLOAT || ((int64((_la-213)) & ^0x3f) == 0 && ((int64(1)<<(_la-213))&9208814108673) != 0) || _la == DorisParserMAP || _la == DorisParserQUANTILE_STATE || ((int64((_la-426)) & ^0x3f) == 0 && ((int64(1)<<(_la-426))&704375029761) != 0) || _la == DorisParserVARCHAR || _la == DorisParserVARIANT {
			{
				p.SetState(1333)
				p.FunctionArguments()
			}

		}
		{
			p.SetState(1336)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1337)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1338)
			p.Match(DorisParserPARAMETER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1339)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1341)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305902462020672000) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4609989332399152113) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4540397275156637211) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&2557745532860070517) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&8545544968972265069) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-305714810442809349) != 0) || ((int64((_la-391)) & ^0x3f) == 0 && ((int64(1)<<(_la-391))&1188948054525294943) != 0) || ((int64((_la-455)) & ^0x3f) == 0 && ((int64(1)<<(_la-455))&2458964612221191023) != 0) || ((int64((_la-538)) & ^0x3f) == 0 && ((int64(1)<<(_la-538))&49159) != 0) {
			{
				p.SetState(1340)

				var _x = p.IdentifierSeq()

				localctx.(*CreateAliasFunctionContext).parameters = _x
			}

		}
		{
			p.SetState(1343)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1344)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1345)
			p.Expression()
		}

	case 17:
		localctx = NewCreateUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1347)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1348)
			p.Match(DorisParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1352)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1349)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1350)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1351)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1354)
			p.GrantUserIdentify()
		}
		p.SetState(1359)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case DorisParserSUPERUSER:
			{
				p.SetState(1355)
				p.Match(DorisParserSUPERUSER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserDEFAULT:
			{
				p.SetState(1356)
				p.Match(DorisParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1357)
				p.Match(DorisParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1358)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*CreateUserContext).role = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserEOF, DorisParserSEMICOLON, DorisParserACCOUNT_LOCK, DorisParserACCOUNT_UNLOCK, DorisParserCOMMENT, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE:

		default:
		}
		{
			p.SetState(1361)
			p.PasswordOption()
		}
		p.SetState(1363)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(1362)
				p.CommentSpec()
			}

		}

	case 18:
		localctx = NewCreateDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1365)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1366)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserDATABASE || _la == DorisParserSCHEMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1370)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1367)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1368)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1369)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1372)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateDatabaseContext).name = _x
		}
		p.SetState(1374)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1373)

				var _x = p.PropertyClause()

				localctx.(*CreateDatabaseContext).properties = _x
			}

		}

	case 19:
		localctx = NewCreateRepositoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1376)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1379)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserREAD {
			{
				p.SetState(1377)
				p.Match(DorisParserREAD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1378)
				p.Match(DorisParserONLY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1381)
			p.Match(DorisParserREPOSITORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1382)

			var _x = p.Identifier()

			localctx.(*CreateRepositoryContext).name = _x
		}
		{
			p.SetState(1383)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1384)
			p.StorageBackend()
		}

	case 20:
		localctx = NewCreateResourceContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1386)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1388)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserEXTERNAL {
			{
				p.SetState(1387)
				p.Match(DorisParserEXTERNAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1390)
			p.Match(DorisParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1394)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1391)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1392)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1393)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1396)

			var _x = p.IdentifierOrText()

			localctx.(*CreateResourceContext).name = _x
		}
		p.SetState(1398)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1397)

				var _x = p.PropertyClause()

				localctx.(*CreateResourceContext).properties = _x
			}

		}

	case 21:
		localctx = NewCreateDictionaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1400)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1401)
			p.Match(DorisParserDICTIONARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1405)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1402)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1403)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1404)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1407)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateDictionaryContext).name = _x
		}
		{
			p.SetState(1408)
			p.Match(DorisParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1409)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateDictionaryContext).source = _x
		}
		{
			p.SetState(1410)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1411)
			p.DictionaryColumnDefs()
		}
		{
			p.SetState(1412)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1413)
			p.Match(DorisParserLAYOUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1414)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1415)

			var _x = p.Identifier()

			localctx.(*CreateDictionaryContext).layoutType = _x
		}
		{
			p.SetState(1416)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1418)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1417)

				var _x = p.PropertyClause()

				localctx.(*CreateDictionaryContext).properties = _x
			}

		}

	case 22:
		localctx = NewCreateStageContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1420)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1421)
			p.Match(DorisParserSTAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1425)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1422)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1423)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1424)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1427)

			var _x = p.Identifier()

			localctx.(*CreateStageContext).name = _x
		}
		p.SetState(1429)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1428)

				var _x = p.PropertyClause()

				localctx.(*CreateStageContext).properties = _x
			}

		}

	case 23:
		localctx = NewCreateStorageVaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1431)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1432)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1433)
			p.Match(DorisParserVAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1437)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1434)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1435)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1436)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1439)

			var _x = p.IdentifierOrText()

			localctx.(*CreateStorageVaultContext).name = _x
		}
		p.SetState(1441)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1440)

				var _x = p.PropertyClause()

				localctx.(*CreateStorageVaultContext).properties = _x
			}

		}

	case 24:
		localctx = NewCreateIndexAnalyzerContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1443)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1444)
			p.Match(DorisParserINVERTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1445)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1446)
			p.Match(DorisParserANALYZER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1450)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1447)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1448)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1449)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1452)

			var _x = p.Identifier()

			localctx.(*CreateIndexAnalyzerContext).name = _x
		}
		p.SetState(1454)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1453)

				var _x = p.PropertyClause()

				localctx.(*CreateIndexAnalyzerContext).properties = _x
			}

		}

	case 25:
		localctx = NewCreateIndexTokenizerContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1456)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1457)
			p.Match(DorisParserINVERTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1458)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1459)
			p.Match(DorisParserTOKENIZER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1463)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1460)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1461)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1462)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1465)

			var _x = p.Identifier()

			localctx.(*CreateIndexTokenizerContext).name = _x
		}
		p.SetState(1467)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1466)

				var _x = p.PropertyClause()

				localctx.(*CreateIndexTokenizerContext).properties = _x
			}

		}

	case 26:
		localctx = NewCreateIndexTokenFilterContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1469)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1470)
			p.Match(DorisParserINVERTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1471)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1472)
			p.Match(DorisParserTOKEN_FILTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1476)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1473)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1474)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1475)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1478)

			var _x = p.Identifier()

			localctx.(*CreateIndexTokenFilterContext).name = _x
		}
		p.SetState(1480)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1479)

				var _x = p.PropertyClause()

				localctx.(*CreateIndexTokenFilterContext).properties = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDictionaryColumnDefsContext is an interface to support dynamic dispatch.
type IDictionaryColumnDefsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDictionaryColumnDef() []IDictionaryColumnDefContext
	DictionaryColumnDef(i int) IDictionaryColumnDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDictionaryColumnDefsContext differentiates from other interfaces.
	IsDictionaryColumnDefsContext()
}

type DictionaryColumnDefsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryColumnDefsContext() *DictionaryColumnDefsContext {
	var p = new(DictionaryColumnDefsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dictionaryColumnDefs
	return p
}

func InitEmptyDictionaryColumnDefsContext(p *DictionaryColumnDefsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dictionaryColumnDefs
}

func (*DictionaryColumnDefsContext) IsDictionaryColumnDefsContext() {}

func NewDictionaryColumnDefsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryColumnDefsContext {
	var p = new(DictionaryColumnDefsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_dictionaryColumnDefs

	return p
}

func (s *DictionaryColumnDefsContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryColumnDefsContext) AllDictionaryColumnDef() []IDictionaryColumnDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDictionaryColumnDefContext); ok {
			len++
		}
	}

	tst := make([]IDictionaryColumnDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDictionaryColumnDefContext); ok {
			tst[i] = t.(IDictionaryColumnDefContext)
			i++
		}
	}

	return tst
}

func (s *DictionaryColumnDefsContext) DictionaryColumnDef(i int) IDictionaryColumnDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDictionaryColumnDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDictionaryColumnDefContext)
}

func (s *DictionaryColumnDefsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *DictionaryColumnDefsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *DictionaryColumnDefsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryColumnDefsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryColumnDefsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDictionaryColumnDefs(s)
	}
}

func (s *DictionaryColumnDefsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDictionaryColumnDefs(s)
	}
}

func (p *DorisParser) DictionaryColumnDefs() (localctx IDictionaryColumnDefsContext) {
	localctx = NewDictionaryColumnDefsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, DorisParserRULE_dictionaryColumnDefs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1484)
		p.DictionaryColumnDef()
	}
	p.SetState(1489)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(1485)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1486)
			p.DictionaryColumnDef()
		}

		p.SetState(1491)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDictionaryColumnDefContext is an interface to support dynamic dispatch.
type IDictionaryColumnDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetColumnType returns the columnType token.
	GetColumnType() antlr.Token

	// SetColumnType sets the columnType token.
	SetColumnType(antlr.Token)

	// GetColName returns the colName rule contexts.
	GetColName() IIdentifierContext

	// SetColName sets the colName rule contexts.
	SetColName(IIdentifierContext)

	// Getter signatures
	Identifier() IIdentifierContext
	KEY() antlr.TerminalNode
	VALUE() antlr.TerminalNode

	// IsDictionaryColumnDefContext differentiates from other interfaces.
	IsDictionaryColumnDefContext()
}

type DictionaryColumnDefContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	colName    IIdentifierContext
	columnType antlr.Token
}

func NewEmptyDictionaryColumnDefContext() *DictionaryColumnDefContext {
	var p = new(DictionaryColumnDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dictionaryColumnDef
	return p
}

func InitEmptyDictionaryColumnDefContext(p *DictionaryColumnDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dictionaryColumnDef
}

func (*DictionaryColumnDefContext) IsDictionaryColumnDefContext() {}

func NewDictionaryColumnDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryColumnDefContext {
	var p = new(DictionaryColumnDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_dictionaryColumnDef

	return p
}

func (s *DictionaryColumnDefContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryColumnDefContext) GetColumnType() antlr.Token { return s.columnType }

func (s *DictionaryColumnDefContext) SetColumnType(v antlr.Token) { s.columnType = v }

func (s *DictionaryColumnDefContext) GetColName() IIdentifierContext { return s.colName }

func (s *DictionaryColumnDefContext) SetColName(v IIdentifierContext) { s.colName = v }

func (s *DictionaryColumnDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DictionaryColumnDefContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserKEY, 0)
}

func (s *DictionaryColumnDefContext) VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserVALUE, 0)
}

func (s *DictionaryColumnDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryColumnDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryColumnDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDictionaryColumnDef(s)
	}
}

func (s *DictionaryColumnDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDictionaryColumnDef(s)
	}
}

func (p *DorisParser) DictionaryColumnDef() (localctx IDictionaryColumnDefContext) {
	localctx = NewDictionaryColumnDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, DorisParserRULE_dictionaryColumnDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1492)

		var _x = p.Identifier()

		localctx.(*DictionaryColumnDefContext).colName = _x
	}
	{
		p.SetState(1493)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*DictionaryColumnDefContext).columnType = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserKEY || _la == DorisParserVALUE) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*DictionaryColumnDefContext).columnType = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedAlterStatementContext is an interface to support dynamic dispatch.
type ISupportedAlterStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedAlterStatementContext differentiates from other interfaces.
	IsSupportedAlterStatementContext()
}

type SupportedAlterStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedAlterStatementContext() *SupportedAlterStatementContext {
	var p = new(SupportedAlterStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedAlterStatement
	return p
}

func InitEmptySupportedAlterStatementContext(p *SupportedAlterStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedAlterStatement
}

func (*SupportedAlterStatementContext) IsSupportedAlterStatementContext() {}

func NewSupportedAlterStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedAlterStatementContext {
	var p = new(SupportedAlterStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedAlterStatement

	return p
}

func (s *SupportedAlterStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedAlterStatementContext) CopyAll(ctx *SupportedAlterStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedAlterStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedAlterStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AlterSystemRenameComputeGroupContext struct {
	SupportedAlterStatementContext
	name    IIdentifierContext
	newName IIdentifierContext
}

func NewAlterSystemRenameComputeGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterSystemRenameComputeGroupContext {
	var p = new(AlterSystemRenameComputeGroupContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterSystemRenameComputeGroupContext) GetName() IIdentifierContext { return s.name }

func (s *AlterSystemRenameComputeGroupContext) GetNewName() IIdentifierContext { return s.newName }

func (s *AlterSystemRenameComputeGroupContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterSystemRenameComputeGroupContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *AlterSystemRenameComputeGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSystemRenameComputeGroupContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterSystemRenameComputeGroupContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(DorisParserSYSTEM, 0)
}

func (s *AlterSystemRenameComputeGroupContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserRENAME, 0)
}

func (s *AlterSystemRenameComputeGroupContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPUTE, 0)
}

func (s *AlterSystemRenameComputeGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUP, 0)
}

func (s *AlterSystemRenameComputeGroupContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterSystemRenameComputeGroupContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterSystemRenameComputeGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterSystemRenameComputeGroup(s)
	}
}

func (s *AlterSystemRenameComputeGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterSystemRenameComputeGroup(s)
	}
}

type AlterSystemContext struct {
	SupportedAlterStatementContext
}

func NewAlterSystemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterSystemContext {
	var p = new(AlterSystemContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterSystemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSystemContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterSystemContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(DorisParserSYSTEM, 0)
}

func (s *AlterSystemContext) AlterSystemClause() IAlterSystemClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterSystemClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterSystemClauseContext)
}

func (s *AlterSystemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterSystem(s)
	}
}

func (s *AlterSystemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterSystem(s)
	}
}

type AlterCatalogRenameContext struct {
	SupportedAlterStatementContext
	name    IIdentifierContext
	newName IIdentifierContext
}

func NewAlterCatalogRenameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterCatalogRenameContext {
	var p = new(AlterCatalogRenameContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterCatalogRenameContext) GetName() IIdentifierContext { return s.name }

func (s *AlterCatalogRenameContext) GetNewName() IIdentifierContext { return s.newName }

func (s *AlterCatalogRenameContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterCatalogRenameContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *AlterCatalogRenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterCatalogRenameContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterCatalogRenameContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *AlterCatalogRenameContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserRENAME, 0)
}

func (s *AlterCatalogRenameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterCatalogRenameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterCatalogRenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterCatalogRename(s)
	}
}

func (s *AlterCatalogRenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterCatalogRename(s)
	}
}

type AlterDatabaseSetQuotaContext struct {
	SupportedAlterStatementContext
	name  IIdentifierContext
	quota IIdentifierContext
}

func NewAlterDatabaseSetQuotaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterDatabaseSetQuotaContext {
	var p = new(AlterDatabaseSetQuotaContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterDatabaseSetQuotaContext) GetName() IIdentifierContext { return s.name }

func (s *AlterDatabaseSetQuotaContext) GetQuota() IIdentifierContext { return s.quota }

func (s *AlterDatabaseSetQuotaContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterDatabaseSetQuotaContext) SetQuota(v IIdentifierContext) { s.quota = v }

func (s *AlterDatabaseSetQuotaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseSetQuotaContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterDatabaseSetQuotaContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *AlterDatabaseSetQuotaContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterDatabaseSetQuotaContext) QUOTA() antlr.TerminalNode {
	return s.GetToken(DorisParserQUOTA, 0)
}

func (s *AlterDatabaseSetQuotaContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterDatabaseSetQuotaContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterDatabaseSetQuotaContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserDATA, 0)
}

func (s *AlterDatabaseSetQuotaContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLICA, 0)
}

func (s *AlterDatabaseSetQuotaContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisParserTRANSACTION, 0)
}

func (s *AlterDatabaseSetQuotaContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *AlterDatabaseSetQuotaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterDatabaseSetQuota(s)
	}
}

func (s *AlterDatabaseSetQuotaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterDatabaseSetQuota(s)
	}
}

type AlterStorageVaultContext struct {
	SupportedAlterStatementContext
	name       IMultipartIdentifierContext
	properties IPropertyClauseContext
}

func NewAlterStorageVaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterStorageVaultContext {
	var p = new(AlterStorageVaultContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterStorageVaultContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterStorageVaultContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterStorageVaultContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterStorageVaultContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterStorageVaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStorageVaultContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterStorageVaultContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *AlterStorageVaultContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULT, 0)
}

func (s *AlterStorageVaultContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterStorageVaultContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterStorageVaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterStorageVault(s)
	}
}

func (s *AlterStorageVaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterStorageVault(s)
	}
}

type AlterWorkloadGroupContext struct {
	SupportedAlterStatementContext
	name         IIdentifierOrTextContext
	computeGroup IIdentifierOrTextContext
	properties   IPropertyClauseContext
}

func NewAlterWorkloadGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterWorkloadGroupContext {
	var p = new(AlterWorkloadGroupContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterWorkloadGroupContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *AlterWorkloadGroupContext) GetComputeGroup() IIdentifierOrTextContext { return s.computeGroup }

func (s *AlterWorkloadGroupContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterWorkloadGroupContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *AlterWorkloadGroupContext) SetComputeGroup(v IIdentifierOrTextContext) { s.computeGroup = v }

func (s *AlterWorkloadGroupContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterWorkloadGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterWorkloadGroupContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterWorkloadGroupContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserWORKLOAD, 0)
}

func (s *AlterWorkloadGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUP, 0)
}

func (s *AlterWorkloadGroupContext) AllIdentifierOrText() []IIdentifierOrTextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrTextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrTextContext); ok {
			tst[i] = t.(IIdentifierOrTextContext)
			i++
		}
	}

	return tst
}

func (s *AlterWorkloadGroupContext) IdentifierOrText(i int) IIdentifierOrTextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *AlterWorkloadGroupContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *AlterWorkloadGroupContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterWorkloadGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterWorkloadGroup(s)
	}
}

func (s *AlterWorkloadGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterWorkloadGroup(s)
	}
}

type AlterTableDropRollupContext struct {
	SupportedAlterStatementContext
	tableName IMultipartIdentifierContext
}

func NewAlterTableDropRollupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableDropRollupContext {
	var p = new(AlterTableDropRollupContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterTableDropRollupContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *AlterTableDropRollupContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *AlterTableDropRollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableDropRollupContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterTableDropRollupContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AlterTableDropRollupContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *AlterTableDropRollupContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *AlterTableDropRollupContext) AllDropRollupClause() []IDropRollupClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDropRollupClauseContext); ok {
			len++
		}
	}

	tst := make([]IDropRollupClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDropRollupClauseContext); ok {
			tst[i] = t.(IDropRollupClauseContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableDropRollupContext) DropRollupClause(i int) IDropRollupClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropRollupClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropRollupClauseContext)
}

func (s *AlterTableDropRollupContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterTableDropRollupContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AlterTableDropRollupContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AlterTableDropRollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterTableDropRollup(s)
	}
}

func (s *AlterTableDropRollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterTableDropRollup(s)
	}
}

type AlterTablePropertiesContext struct {
	SupportedAlterStatementContext
	name IMultipartIdentifierContext
}

func NewAlterTablePropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTablePropertiesContext {
	var p = new(AlterTablePropertiesContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterTablePropertiesContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterTablePropertiesContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterTablePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTablePropertiesContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterTablePropertiesContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AlterTablePropertiesContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterTablePropertiesContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterTablePropertiesContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterTablePropertiesContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterTablePropertiesContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterTablePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterTableProperties(s)
	}
}

func (s *AlterTablePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterTableProperties(s)
	}
}

type AlterUserContext struct {
	SupportedAlterStatementContext
}

func NewAlterUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterUserContext {
	var p = new(AlterUserContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterUserContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisParserUSER, 0)
}

func (s *AlterUserContext) GrantUserIdentify() IGrantUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantUserIdentifyContext)
}

func (s *AlterUserContext) PasswordOption() IPasswordOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordOptionContext)
}

func (s *AlterUserContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *AlterUserContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *AlterUserContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *AlterUserContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *AlterUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterUser(s)
	}
}

func (s *AlterUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterUser(s)
	}
}

type AlterRoleContext struct {
	SupportedAlterStatementContext
	role IIdentifierOrTextContext
}

func NewAlterRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterRoleContext {
	var p = new(AlterRoleContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterRoleContext) GetRole() IIdentifierOrTextContext { return s.role }

func (s *AlterRoleContext) SetRole(v IIdentifierOrTextContext) { s.role = v }

func (s *AlterRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRoleContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *AlterRoleContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *AlterRoleContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *AlterRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterRole(s)
	}
}

func (s *AlterRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterRole(s)
	}
}

type AlterWorkloadPolicyContext struct {
	SupportedAlterStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewAlterWorkloadPolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterWorkloadPolicyContext {
	var p = new(AlterWorkloadPolicyContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterWorkloadPolicyContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *AlterWorkloadPolicyContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterWorkloadPolicyContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *AlterWorkloadPolicyContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterWorkloadPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterWorkloadPolicyContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterWorkloadPolicyContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserWORKLOAD, 0)
}

func (s *AlterWorkloadPolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *AlterWorkloadPolicyContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *AlterWorkloadPolicyContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterWorkloadPolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterWorkloadPolicy(s)
	}
}

func (s *AlterWorkloadPolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterWorkloadPolicy(s)
	}
}

type AlterDatabaseRenameContext struct {
	SupportedAlterStatementContext
	name    IIdentifierContext
	newName IIdentifierContext
}

func NewAlterDatabaseRenameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterDatabaseRenameContext {
	var p = new(AlterDatabaseRenameContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterDatabaseRenameContext) GetName() IIdentifierContext { return s.name }

func (s *AlterDatabaseRenameContext) GetNewName() IIdentifierContext { return s.newName }

func (s *AlterDatabaseRenameContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterDatabaseRenameContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *AlterDatabaseRenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseRenameContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterDatabaseRenameContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *AlterDatabaseRenameContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserRENAME, 0)
}

func (s *AlterDatabaseRenameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterDatabaseRenameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterDatabaseRenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterDatabaseRename(s)
	}
}

func (s *AlterDatabaseRenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterDatabaseRename(s)
	}
}

type AlterCatalogPropertiesContext struct {
	SupportedAlterStatementContext
	name IIdentifierContext
}

func NewAlterCatalogPropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterCatalogPropertiesContext {
	var p = new(AlterCatalogPropertiesContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterCatalogPropertiesContext) GetName() IIdentifierContext { return s.name }

func (s *AlterCatalogPropertiesContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterCatalogPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterCatalogPropertiesContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterCatalogPropertiesContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *AlterCatalogPropertiesContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterCatalogPropertiesContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *AlterCatalogPropertiesContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterCatalogPropertiesContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterCatalogPropertiesContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterCatalogPropertiesContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterCatalogPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterCatalogProperties(s)
	}
}

func (s *AlterCatalogPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterCatalogProperties(s)
	}
}

type AlterDatabasePropertiesContext struct {
	SupportedAlterStatementContext
	name IIdentifierContext
}

func NewAlterDatabasePropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterDatabasePropertiesContext {
	var p = new(AlterDatabasePropertiesContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterDatabasePropertiesContext) GetName() IIdentifierContext { return s.name }

func (s *AlterDatabasePropertiesContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterDatabasePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabasePropertiesContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterDatabasePropertiesContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *AlterDatabasePropertiesContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterDatabasePropertiesContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *AlterDatabasePropertiesContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterDatabasePropertiesContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterDatabasePropertiesContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterDatabasePropertiesContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterDatabasePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterDatabaseProperties(s)
	}
}

func (s *AlterDatabasePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterDatabaseProperties(s)
	}
}

type AlterCatalogCommentContext struct {
	SupportedAlterStatementContext
	name    IIdentifierContext
	comment antlr.Token
}

func NewAlterCatalogCommentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterCatalogCommentContext {
	var p = new(AlterCatalogCommentContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterCatalogCommentContext) GetComment() antlr.Token { return s.comment }

func (s *AlterCatalogCommentContext) SetComment(v antlr.Token) { s.comment = v }

func (s *AlterCatalogCommentContext) GetName() IIdentifierContext { return s.name }

func (s *AlterCatalogCommentContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterCatalogCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterCatalogCommentContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterCatalogCommentContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *AlterCatalogCommentContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *AlterCatalogCommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *AlterCatalogCommentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterCatalogCommentContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *AlterCatalogCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterCatalogComment(s)
	}
}

func (s *AlterCatalogCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterCatalogComment(s)
	}
}

type AlterViewContext struct {
	SupportedAlterStatementContext
	name IMultipartIdentifierContext
	cols ISimpleColumnDefsContext
}

func NewAlterViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterViewContext {
	var p = new(AlterViewContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterViewContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterViewContext) GetCols() ISimpleColumnDefsContext { return s.cols }

func (s *AlterViewContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterViewContext) SetCols(v ISimpleColumnDefsContext) { s.cols = v }

func (s *AlterViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterViewContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *AlterViewContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterViewContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *AlterViewContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *AlterViewContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *AlterViewContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *AlterViewContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterViewContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterViewContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *AlterViewContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *AlterViewContext) SimpleColumnDefs() ISimpleColumnDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleColumnDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleColumnDefsContext)
}

func (s *AlterViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterView(s)
	}
}

func (s *AlterViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterView(s)
	}
}

type AlterStoragePolicyContext struct {
	SupportedAlterStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewAlterStoragePolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterStoragePolicyContext {
	var p = new(AlterStoragePolicyContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterStoragePolicyContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *AlterStoragePolicyContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterStoragePolicyContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *AlterStoragePolicyContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterStoragePolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStoragePolicyContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterStoragePolicyContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *AlterStoragePolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *AlterStoragePolicyContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *AlterStoragePolicyContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterStoragePolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterStoragePolicy(s)
	}
}

func (s *AlterStoragePolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterStoragePolicy(s)
	}
}

type AlterSqlBlockRuleContext struct {
	SupportedAlterStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewAlterSqlBlockRuleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterSqlBlockRuleContext {
	var p = new(AlterSqlBlockRuleContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterSqlBlockRuleContext) GetName() IIdentifierContext { return s.name }

func (s *AlterSqlBlockRuleContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterSqlBlockRuleContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterSqlBlockRuleContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterSqlBlockRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSqlBlockRuleContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterSqlBlockRuleContext) SQL_BLOCK_RULE() antlr.TerminalNode {
	return s.GetToken(DorisParserSQL_BLOCK_RULE, 0)
}

func (s *AlterSqlBlockRuleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterSqlBlockRuleContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterSqlBlockRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterSqlBlockRule(s)
	}
}

func (s *AlterSqlBlockRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterSqlBlockRule(s)
	}
}

type AlterResourceContext struct {
	SupportedAlterStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewAlterResourceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterResourceContext {
	var p = new(AlterResourceContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterResourceContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *AlterResourceContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterResourceContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *AlterResourceContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterResourceContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterResourceContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCE, 0)
}

func (s *AlterResourceContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *AlterResourceContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterResourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterResource(s)
	}
}

func (s *AlterResourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterResource(s)
	}
}

type AlterRoutineLoadContext struct {
	SupportedAlterStatementContext
	name       IMultipartIdentifierContext
	properties IPropertyClauseContext
	type_      IIdentifierContext
}

func NewAlterRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterRoutineLoadContext {
	var p = new(AlterRoutineLoadContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterRoutineLoadContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterRoutineLoadContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterRoutineLoadContext) GetType_() IIdentifierContext { return s.type_ }

func (s *AlterRoutineLoadContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterRoutineLoadContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterRoutineLoadContext) SetType_(v IIdentifierContext) { s.type_ = v }

func (s *AlterRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRoutineLoadContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserROUTINE, 0)
}

func (s *AlterRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *AlterRoutineLoadContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *AlterRoutineLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterRoutineLoadContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *AlterRoutineLoadContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterRoutineLoadContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterRoutineLoadContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterRoutineLoadContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterRoutineLoadContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterRoutineLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterRoutineLoad(s)
	}
}

func (s *AlterRoutineLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterRoutineLoad(s)
	}
}

type AlterTableAddRollupContext struct {
	SupportedAlterStatementContext
	tableName IMultipartIdentifierContext
}

func NewAlterTableAddRollupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableAddRollupContext {
	var p = new(AlterTableAddRollupContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterTableAddRollupContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *AlterTableAddRollupContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *AlterTableAddRollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableAddRollupContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterTableAddRollupContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AlterTableAddRollupContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AlterTableAddRollupContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *AlterTableAddRollupContext) AllAddRollupClause() []IAddRollupClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAddRollupClauseContext); ok {
			len++
		}
	}

	tst := make([]IAddRollupClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAddRollupClauseContext); ok {
			tst[i] = t.(IAddRollupClauseContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableAddRollupContext) AddRollupClause(i int) IAddRollupClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddRollupClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddRollupClauseContext)
}

func (s *AlterTableAddRollupContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterTableAddRollupContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AlterTableAddRollupContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AlterTableAddRollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterTableAddRollup(s)
	}
}

func (s *AlterTableAddRollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterTableAddRollup(s)
	}
}

type AlterRepositoryContext struct {
	SupportedAlterStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewAlterRepositoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterRepositoryContext {
	var p = new(AlterRepositoryContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterRepositoryContext) GetName() IIdentifierContext { return s.name }

func (s *AlterRepositoryContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterRepositoryContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterRepositoryContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterRepositoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRepositoryContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterRepositoryContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisParserREPOSITORY, 0)
}

func (s *AlterRepositoryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterRepositoryContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterRepositoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterRepository(s)
	}
}

func (s *AlterRepositoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterRepository(s)
	}
}

type AlterTableContext struct {
	SupportedAlterStatementContext
	tableName IMultipartIdentifierContext
}

func NewAlterTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableContext {
	var p = new(AlterTableContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterTableContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *AlterTableContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *AlterTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AlterTableContext) AllAlterTableClause() []IAlterTableClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterTableClauseContext); ok {
			len++
		}
	}

	tst := make([]IAlterTableClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterTableClauseContext); ok {
			tst[i] = t.(IAlterTableClauseContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableContext) AlterTableClause(i int) IAlterTableClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableClauseContext)
}

func (s *AlterTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AlterTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AlterTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterTable(s)
	}
}

func (s *AlterTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterTable(s)
	}
}

type AlterColocateGroupContext struct {
	SupportedAlterStatementContext
	name IMultipartIdentifierContext
}

func NewAlterColocateGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterColocateGroupContext {
	var p = new(AlterColocateGroupContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterColocateGroupContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterColocateGroupContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterColocateGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterColocateGroupContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterColocateGroupContext) COLOCATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLOCATE, 0)
}

func (s *AlterColocateGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUP, 0)
}

func (s *AlterColocateGroupContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterColocateGroupContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterColocateGroupContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterColocateGroupContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterColocateGroupContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterColocateGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterColocateGroup(s)
	}
}

func (s *AlterColocateGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterColocateGroup(s)
	}
}

func (p *DorisParser) SupportedAlterStatement() (localctx ISupportedAlterStatementContext) {
	localctx = NewSupportedAlterStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, DorisParserRULE_supportedAlterStatement)
	var _la int

	p.SetState(1707)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 190, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAlterSystemContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1495)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1496)
			p.Match(DorisParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1497)
			p.AlterSystemClause()
		}

	case 2:
		localctx = NewAlterViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1498)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1499)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1500)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterViewContext).name = _x
		}
		p.SetState(1515)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserMODIFY:
			{
				p.SetState(1501)
				p.Match(DorisParserMODIFY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1502)
				p.CommentSpec()
			}

		case DorisParserLEFT_PAREN, DorisParserAS, DorisParserCOMMENT:
			p.SetState(1507)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserLEFT_PAREN {
				{
					p.SetState(1503)
					p.Match(DorisParserLEFT_PAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1504)

					var _x = p.SimpleColumnDefs()

					localctx.(*AlterViewContext).cols = _x
				}
				{
					p.SetState(1505)
					p.Match(DorisParserRIGHT_PAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1511)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserCOMMENT {
				{
					p.SetState(1509)
					p.Match(DorisParserCOMMENT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1510)
					p.Match(DorisParserSTRING_LITERAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1513)
				p.Match(DorisParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1514)
				p.Query()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		localctx = NewAlterCatalogRenameContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1517)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1518)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1519)

			var _x = p.Identifier()

			localctx.(*AlterCatalogRenameContext).name = _x
		}
		{
			p.SetState(1520)
			p.Match(DorisParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1521)

			var _x = p.Identifier()

			localctx.(*AlterCatalogRenameContext).newName = _x
		}

	case 4:
		localctx = NewAlterRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1523)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1524)
			p.Match(DorisParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1525)

			var _x = p.IdentifierOrText()

			localctx.(*AlterRoleContext).role = _x
		}
		{
			p.SetState(1526)
			p.CommentSpec()
		}

	case 5:
		localctx = NewAlterStorageVaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1528)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1529)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1530)
			p.Match(DorisParserVAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1531)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterStorageVaultContext).name = _x
		}
		{
			p.SetState(1532)

			var _x = p.PropertyClause()

			localctx.(*AlterStorageVaultContext).properties = _x
		}

	case 6:
		localctx = NewAlterWorkloadGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1534)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1535)
			p.Match(DorisParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1536)
			p.Match(DorisParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1537)

			var _x = p.IdentifierOrText()

			localctx.(*AlterWorkloadGroupContext).name = _x
		}
		p.SetState(1540)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFOR {
			{
				p.SetState(1538)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1539)

				var _x = p.IdentifierOrText()

				localctx.(*AlterWorkloadGroupContext).computeGroup = _x
			}

		}
		p.SetState(1543)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1542)

				var _x = p.PropertyClause()

				localctx.(*AlterWorkloadGroupContext).properties = _x
			}

		}

	case 7:
		localctx = NewAlterCatalogPropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1545)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1546)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1547)

			var _x = p.Identifier()

			localctx.(*AlterCatalogPropertiesContext).name = _x
		}
		{
			p.SetState(1548)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1549)
			p.Match(DorisParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1550)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1551)
			p.PropertyItemList()
		}
		{
			p.SetState(1552)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewAlterWorkloadPolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1554)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1555)
			p.Match(DorisParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1556)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1557)

			var _x = p.IdentifierOrText()

			localctx.(*AlterWorkloadPolicyContext).name = _x
		}
		p.SetState(1559)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1558)

				var _x = p.PropertyClause()

				localctx.(*AlterWorkloadPolicyContext).properties = _x
			}

		}

	case 9:
		localctx = NewAlterSqlBlockRuleContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1561)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1562)
			p.Match(DorisParserSQL_BLOCK_RULE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1563)

			var _x = p.Identifier()

			localctx.(*AlterSqlBlockRuleContext).name = _x
		}
		p.SetState(1565)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1564)

				var _x = p.PropertyClause()

				localctx.(*AlterSqlBlockRuleContext).properties = _x
			}

		}

	case 10:
		localctx = NewAlterCatalogCommentContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1567)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1568)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1569)

			var _x = p.Identifier()

			localctx.(*AlterCatalogCommentContext).name = _x
		}
		{
			p.SetState(1570)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1571)
			p.Match(DorisParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1572)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*AlterCatalogCommentContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewAlterDatabaseRenameContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1574)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1575)
			p.Match(DorisParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1576)

			var _x = p.Identifier()

			localctx.(*AlterDatabaseRenameContext).name = _x
		}
		{
			p.SetState(1577)
			p.Match(DorisParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1578)

			var _x = p.Identifier()

			localctx.(*AlterDatabaseRenameContext).newName = _x
		}

	case 12:
		localctx = NewAlterStoragePolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1580)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1581)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1582)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1583)

			var _x = p.IdentifierOrText()

			localctx.(*AlterStoragePolicyContext).name = _x
		}
		{
			p.SetState(1584)

			var _x = p.PropertyClause()

			localctx.(*AlterStoragePolicyContext).properties = _x
		}

	case 13:
		localctx = NewAlterTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1586)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1587)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1588)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterTableContext).tableName = _x
		}
		{
			p.SetState(1589)
			p.AlterTableClause()
		}
		p.SetState(1594)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(1590)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1591)
				p.AlterTableClause()
			}

			p.SetState(1596)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 14:
		localctx = NewAlterTableAddRollupContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1597)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1598)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1599)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterTableAddRollupContext).tableName = _x
		}
		{
			p.SetState(1600)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1601)
			p.Match(DorisParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1602)
			p.AddRollupClause()
		}
		p.SetState(1607)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(1603)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1604)
				p.AddRollupClause()
			}

			p.SetState(1609)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 15:
		localctx = NewAlterTableDropRollupContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1610)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1611)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1612)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterTableDropRollupContext).tableName = _x
		}
		{
			p.SetState(1613)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1614)
			p.Match(DorisParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1615)
			p.DropRollupClause()
		}
		p.SetState(1620)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(1616)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1617)
				p.DropRollupClause()
			}

			p.SetState(1622)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 16:
		localctx = NewAlterTablePropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1623)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1624)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1625)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterTablePropertiesContext).name = _x
		}
		{
			p.SetState(1626)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1627)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1628)
			p.PropertyItemList()
		}
		{
			p.SetState(1629)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		localctx = NewAlterDatabaseSetQuotaContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1631)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1632)
			p.Match(DorisParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1633)

			var _x = p.Identifier()

			localctx.(*AlterDatabaseSetQuotaContext).name = _x
		}
		{
			p.SetState(1634)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1635)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserDATA || _la == DorisParserREPLICA || _la == DorisParserTRANSACTION) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1636)
			p.Match(DorisParserQUOTA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1639)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(1637)

				var _x = p.Identifier()

				localctx.(*AlterDatabaseSetQuotaContext).quota = _x
			}

		case DorisParserINTEGER_VALUE:
			{
				p.SetState(1638)
				p.Match(DorisParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 18:
		localctx = NewAlterDatabasePropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1641)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1642)
			p.Match(DorisParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1643)

			var _x = p.Identifier()

			localctx.(*AlterDatabasePropertiesContext).name = _x
		}
		{
			p.SetState(1644)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1645)
			p.Match(DorisParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1646)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1647)
			p.PropertyItemList()
		}
		{
			p.SetState(1648)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		localctx = NewAlterSystemRenameComputeGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1650)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1651)
			p.Match(DorisParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1652)
			p.Match(DorisParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1653)
			p.Match(DorisParserCOMPUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1654)
			p.Match(DorisParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1655)

			var _x = p.Identifier()

			localctx.(*AlterSystemRenameComputeGroupContext).name = _x
		}
		{
			p.SetState(1656)

			var _x = p.Identifier()

			localctx.(*AlterSystemRenameComputeGroupContext).newName = _x
		}

	case 20:
		localctx = NewAlterResourceContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1658)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1659)
			p.Match(DorisParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1660)

			var _x = p.IdentifierOrText()

			localctx.(*AlterResourceContext).name = _x
		}
		p.SetState(1662)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1661)

				var _x = p.PropertyClause()

				localctx.(*AlterResourceContext).properties = _x
			}

		}

	case 21:
		localctx = NewAlterRepositoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1664)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1665)
			p.Match(DorisParserREPOSITORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1666)

			var _x = p.Identifier()

			localctx.(*AlterRepositoryContext).name = _x
		}
		p.SetState(1668)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1667)

				var _x = p.PropertyClause()

				localctx.(*AlterRepositoryContext).properties = _x
			}

		}

	case 22:
		localctx = NewAlterRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1670)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1671)
			p.Match(DorisParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1672)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1673)
			p.Match(DorisParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1674)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterRoutineLoadContext).name = _x
		}
		p.SetState(1676)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(1675)

				var _x = p.PropertyClause()

				localctx.(*AlterRoutineLoadContext).properties = _x
			}

		}
		p.SetState(1684)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(1678)
				p.Match(DorisParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1679)

				var _x = p.Identifier()

				localctx.(*AlterRoutineLoadContext).type_ = _x
			}
			{
				p.SetState(1680)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1681)
				p.PropertyItemList()
			}
			{
				p.SetState(1682)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 23:
		localctx = NewAlterColocateGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1686)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1687)
			p.Match(DorisParserCOLOCATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1688)
			p.Match(DorisParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1689)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterColocateGroupContext).name = _x
		}
		{
			p.SetState(1690)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1691)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1692)
			p.PropertyItemList()
		}
		{
			p.SetState(1693)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		localctx = NewAlterUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1695)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1696)
			p.Match(DorisParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1699)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1697)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1698)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1701)
			p.GrantUserIdentify()
		}
		{
			p.SetState(1702)
			p.PasswordOption()
		}
		p.SetState(1705)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(1703)
				p.Match(DorisParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1704)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedDropStatementContext is an interface to support dynamic dispatch.
type ISupportedDropStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedDropStatementContext differentiates from other interfaces.
	IsSupportedDropStatementContext()
}

type SupportedDropStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedDropStatementContext() *SupportedDropStatementContext {
	var p = new(SupportedDropStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedDropStatement
	return p
}

func InitEmptySupportedDropStatementContext(p *SupportedDropStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedDropStatement
}

func (*SupportedDropStatementContext) IsSupportedDropStatementContext() {}

func NewSupportedDropStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedDropStatementContext {
	var p = new(SupportedDropStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedDropStatement

	return p
}

func (s *SupportedDropStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedDropStatementContext) CopyAll(ctx *SupportedDropStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedDropStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedDropStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DropUserContext struct {
	SupportedDropStatementContext
}

func NewDropUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropUserContext {
	var p = new(DropUserContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropUserContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropUserContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisParserUSER, 0)
}

func (s *DropUserContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *DropUserContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropUserContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropUser(s)
	}
}

func (s *DropUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropUser(s)
	}
}

type DropDatabaseContext struct {
	SupportedDropStatementContext
	name IMultipartIdentifierContext
}

func NewDropDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropDatabaseContext {
	var p = new(DropDatabaseContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropDatabaseContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *DropDatabaseContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *DropDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDatabaseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *DropDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEMA, 0)
}

func (s *DropDatabaseContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropDatabaseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropDatabaseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropDatabaseContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserFORCE, 0)
}

func (s *DropDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropDatabase(s)
	}
}

func (s *DropDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropDatabase(s)
	}
}

type DropDictionaryContext struct {
	SupportedDropStatementContext
	name IMultipartIdentifierContext
}

func NewDropDictionaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropDictionaryContext {
	var p = new(DropDictionaryContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropDictionaryContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *DropDictionaryContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *DropDictionaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDictionaryContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropDictionaryContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(DorisParserDICTIONARY, 0)
}

func (s *DropDictionaryContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropDictionaryContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropDictionaryContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropDictionaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropDictionary(s)
	}
}

func (s *DropDictionaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropDictionary(s)
	}
}

type DropWorkloadPolicyContext struct {
	SupportedDropStatementContext
	name IIdentifierOrTextContext
}

func NewDropWorkloadPolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropWorkloadPolicyContext {
	var p = new(DropWorkloadPolicyContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropWorkloadPolicyContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *DropWorkloadPolicyContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *DropWorkloadPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropWorkloadPolicyContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropWorkloadPolicyContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserWORKLOAD, 0)
}

func (s *DropWorkloadPolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *DropWorkloadPolicyContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DropWorkloadPolicyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropWorkloadPolicyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropWorkloadPolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropWorkloadPolicy(s)
	}
}

func (s *DropWorkloadPolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropWorkloadPolicy(s)
	}
}

type DropRowPolicyContext struct {
	SupportedDropStatementContext
	policyName IIdentifierContext
	tableName  IMultipartIdentifierContext
	roleName   IIdentifierContext
}

func NewDropRowPolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropRowPolicyContext {
	var p = new(DropRowPolicyContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropRowPolicyContext) GetPolicyName() IIdentifierContext { return s.policyName }

func (s *DropRowPolicyContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DropRowPolicyContext) GetRoleName() IIdentifierContext { return s.roleName }

func (s *DropRowPolicyContext) SetPolicyName(v IIdentifierContext) { s.policyName = v }

func (s *DropRowPolicyContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DropRowPolicyContext) SetRoleName(v IIdentifierContext) { s.roleName = v }

func (s *DropRowPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRowPolicyContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropRowPolicyContext) ROW() antlr.TerminalNode {
	return s.GetToken(DorisParserROW, 0)
}

func (s *DropRowPolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *DropRowPolicyContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *DropRowPolicyContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DropRowPolicyContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropRowPolicyContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropRowPolicyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropRowPolicyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropRowPolicyContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *DropRowPolicyContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *DropRowPolicyContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *DropRowPolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropRowPolicy(s)
	}
}

func (s *DropRowPolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropRowPolicy(s)
	}
}

type DropFunctionContext struct {
	SupportedDropStatementContext
}

func NewDropFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropFunctionContext {
	var p = new(DropFunctionContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFunctionContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserFUNCTION, 0)
}

func (s *DropFunctionContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *DropFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *DropFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *DropFunctionContext) StatementScope() IStatementScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementScopeContext)
}

func (s *DropFunctionContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropFunctionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropFunctionContext) FunctionArguments() IFunctionArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgumentsContext)
}

func (s *DropFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropFunction(s)
	}
}

func (s *DropFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropFunction(s)
	}
}

type DropWorkloadGroupContext struct {
	SupportedDropStatementContext
	name         IIdentifierOrTextContext
	computeGroup IIdentifierOrTextContext
}

func NewDropWorkloadGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropWorkloadGroupContext {
	var p = new(DropWorkloadGroupContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropWorkloadGroupContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *DropWorkloadGroupContext) GetComputeGroup() IIdentifierOrTextContext { return s.computeGroup }

func (s *DropWorkloadGroupContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *DropWorkloadGroupContext) SetComputeGroup(v IIdentifierOrTextContext) { s.computeGroup = v }

func (s *DropWorkloadGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropWorkloadGroupContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropWorkloadGroupContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserWORKLOAD, 0)
}

func (s *DropWorkloadGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUP, 0)
}

func (s *DropWorkloadGroupContext) AllIdentifierOrText() []IIdentifierOrTextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrTextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrTextContext); ok {
			tst[i] = t.(IIdentifierOrTextContext)
			i++
		}
	}

	return tst
}

func (s *DropWorkloadGroupContext) IdentifierOrText(i int) IIdentifierOrTextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DropWorkloadGroupContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropWorkloadGroupContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropWorkloadGroupContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *DropWorkloadGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropWorkloadGroup(s)
	}
}

func (s *DropWorkloadGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropWorkloadGroup(s)
	}
}

type DropSqlBlockRuleContext struct {
	SupportedDropStatementContext
}

func NewDropSqlBlockRuleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropSqlBlockRuleContext {
	var p = new(DropSqlBlockRuleContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropSqlBlockRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropSqlBlockRuleContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropSqlBlockRuleContext) SQL_BLOCK_RULE() antlr.TerminalNode {
	return s.GetToken(DorisParserSQL_BLOCK_RULE, 0)
}

func (s *DropSqlBlockRuleContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *DropSqlBlockRuleContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropSqlBlockRuleContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropSqlBlockRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropSqlBlockRule(s)
	}
}

func (s *DropSqlBlockRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropSqlBlockRule(s)
	}
}

type DropViewContext struct {
	SupportedDropStatementContext
	name IMultipartIdentifierContext
}

func NewDropViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropViewContext {
	var p = new(DropViewContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropViewContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *DropViewContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *DropViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropViewContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *DropViewContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropViewContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropViewContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropView(s)
	}
}

func (s *DropViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropView(s)
	}
}

type DropIndexContext struct {
	SupportedDropStatementContext
	name      IIdentifierContext
	tableName IMultipartIdentifierContext
}

func NewDropIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropIndexContext {
	var p = new(DropIndexContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropIndexContext) GetName() IIdentifierContext { return s.name }

func (s *DropIndexContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DropIndexContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropIndexContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DropIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *DropIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *DropIndexContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropIndexContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropIndexContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropIndexContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropIndex(s)
	}
}

func (s *DropIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropIndex(s)
	}
}

type DropEncryptkeyContext struct {
	SupportedDropStatementContext
	name IMultipartIdentifierContext
}

func NewDropEncryptkeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropEncryptkeyContext {
	var p = new(DropEncryptkeyContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropEncryptkeyContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *DropEncryptkeyContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *DropEncryptkeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropEncryptkeyContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropEncryptkeyContext) ENCRYPTKEY() antlr.TerminalNode {
	return s.GetToken(DorisParserENCRYPTKEY, 0)
}

func (s *DropEncryptkeyContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropEncryptkeyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropEncryptkeyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropEncryptkeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropEncryptkey(s)
	}
}

func (s *DropEncryptkeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropEncryptkey(s)
	}
}

type DropRepositoryContext struct {
	SupportedDropStatementContext
	name IIdentifierContext
}

func NewDropRepositoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropRepositoryContext {
	var p = new(DropRepositoryContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropRepositoryContext) GetName() IIdentifierContext { return s.name }

func (s *DropRepositoryContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropRepositoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRepositoryContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropRepositoryContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisParserREPOSITORY, 0)
}

func (s *DropRepositoryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropRepositoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropRepository(s)
	}
}

func (s *DropRepositoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropRepository(s)
	}
}

type DropRoleContext struct {
	SupportedDropStatementContext
	name IIdentifierOrTextContext
}

func NewDropRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropRoleContext {
	var p = new(DropRoleContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropRoleContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *DropRoleContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *DropRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRoleContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *DropRoleContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DropRoleContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropRoleContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropRole(s)
	}
}

func (s *DropRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropRole(s)
	}
}

type DropIndexAnalyzerContext struct {
	SupportedDropStatementContext
	name IIdentifierContext
}

func NewDropIndexAnalyzerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropIndexAnalyzerContext {
	var p = new(DropIndexAnalyzerContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropIndexAnalyzerContext) GetName() IIdentifierContext { return s.name }

func (s *DropIndexAnalyzerContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropIndexAnalyzerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexAnalyzerContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropIndexAnalyzerContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserINVERTED, 0)
}

func (s *DropIndexAnalyzerContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *DropIndexAnalyzerContext) ANALYZER() antlr.TerminalNode {
	return s.GetToken(DorisParserANALYZER, 0)
}

func (s *DropIndexAnalyzerContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropIndexAnalyzerContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropIndexAnalyzerContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropIndexAnalyzerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropIndexAnalyzer(s)
	}
}

func (s *DropIndexAnalyzerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropIndexAnalyzer(s)
	}
}

type DropStageContext struct {
	SupportedDropStatementContext
	name IIdentifierContext
}

func NewDropStageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropStageContext {
	var p = new(DropStageContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropStageContext) GetName() IIdentifierContext { return s.name }

func (s *DropStageContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropStageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStageContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropStageContext) STAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTAGE, 0)
}

func (s *DropStageContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropStageContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropStageContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropStageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropStage(s)
	}
}

func (s *DropStageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropStage(s)
	}
}

type DropIndexTokenizerContext struct {
	SupportedDropStatementContext
	name IIdentifierContext
}

func NewDropIndexTokenizerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropIndexTokenizerContext {
	var p = new(DropIndexTokenizerContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropIndexTokenizerContext) GetName() IIdentifierContext { return s.name }

func (s *DropIndexTokenizerContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropIndexTokenizerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexTokenizerContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropIndexTokenizerContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserINVERTED, 0)
}

func (s *DropIndexTokenizerContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *DropIndexTokenizerContext) TOKENIZER() antlr.TerminalNode {
	return s.GetToken(DorisParserTOKENIZER, 0)
}

func (s *DropIndexTokenizerContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropIndexTokenizerContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropIndexTokenizerContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropIndexTokenizerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropIndexTokenizer(s)
	}
}

func (s *DropIndexTokenizerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropIndexTokenizer(s)
	}
}

type DropResourceContext struct {
	SupportedDropStatementContext
	name IIdentifierOrTextContext
}

func NewDropResourceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropResourceContext {
	var p = new(DropResourceContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropResourceContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *DropResourceContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *DropResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropResourceContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropResourceContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCE, 0)
}

func (s *DropResourceContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DropResourceContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropResourceContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropResourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropResource(s)
	}
}

func (s *DropResourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropResource(s)
	}
}

type DropFileContext struct {
	SupportedDropStatementContext
	name       antlr.Token
	database   IIdentifierContext
	properties IPropertyClauseContext
}

func NewDropFileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropFileContext {
	var p = new(DropFileContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropFileContext) GetName() antlr.Token { return s.name }

func (s *DropFileContext) SetName(v antlr.Token) { s.name = v }

func (s *DropFileContext) GetDatabase() IIdentifierContext { return s.database }

func (s *DropFileContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *DropFileContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *DropFileContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *DropFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFileContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropFileContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisParserFILE, 0)
}

func (s *DropFileContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *DropFileContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *DropFileContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *DropFileContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *DropFileContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropFile(s)
	}
}

func (s *DropFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropFile(s)
	}
}

type DropCatalogContext struct {
	SupportedDropStatementContext
	name IIdentifierContext
}

func NewDropCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropCatalogContext {
	var p = new(DropCatalogContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropCatalogContext) GetName() IIdentifierContext { return s.name }

func (s *DropCatalogContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropCatalogContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropCatalogContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *DropCatalogContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropCatalogContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropCatalogContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropCatalogContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropCatalog(s)
	}
}

func (s *DropCatalogContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropCatalog(s)
	}
}

type DropCatalogRecycleBinContext struct {
	SupportedDropStatementContext
	idType antlr.Token
	id     antlr.Token
}

func NewDropCatalogRecycleBinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropCatalogRecycleBinContext {
	var p = new(DropCatalogRecycleBinContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropCatalogRecycleBinContext) GetIdType() antlr.Token { return s.idType }

func (s *DropCatalogRecycleBinContext) GetId() antlr.Token { return s.id }

func (s *DropCatalogRecycleBinContext) SetIdType(v antlr.Token) { s.idType = v }

func (s *DropCatalogRecycleBinContext) SetId(v antlr.Token) { s.id = v }

func (s *DropCatalogRecycleBinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropCatalogRecycleBinContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropCatalogRecycleBinContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *DropCatalogRecycleBinContext) RECYCLE() antlr.TerminalNode {
	return s.GetToken(DorisParserRECYCLE, 0)
}

func (s *DropCatalogRecycleBinContext) BIN() antlr.TerminalNode {
	return s.GetToken(DorisParserBIN, 0)
}

func (s *DropCatalogRecycleBinContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserWHERE, 0)
}

func (s *DropCatalogRecycleBinContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *DropCatalogRecycleBinContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *DropCatalogRecycleBinContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *DropCatalogRecycleBinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropCatalogRecycleBin(s)
	}
}

func (s *DropCatalogRecycleBinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropCatalogRecycleBin(s)
	}
}

type DropIndexTokenFilterContext struct {
	SupportedDropStatementContext
	name IIdentifierContext
}

func NewDropIndexTokenFilterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropIndexTokenFilterContext {
	var p = new(DropIndexTokenFilterContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropIndexTokenFilterContext) GetName() IIdentifierContext { return s.name }

func (s *DropIndexTokenFilterContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropIndexTokenFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexTokenFilterContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropIndexTokenFilterContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserINVERTED, 0)
}

func (s *DropIndexTokenFilterContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *DropIndexTokenFilterContext) TOKEN_FILTER() antlr.TerminalNode {
	return s.GetToken(DorisParserTOKEN_FILTER, 0)
}

func (s *DropIndexTokenFilterContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropIndexTokenFilterContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropIndexTokenFilterContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropIndexTokenFilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropIndexTokenFilter(s)
	}
}

func (s *DropIndexTokenFilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropIndexTokenFilter(s)
	}
}

type DropTableContext struct {
	SupportedDropStatementContext
	name IMultipartIdentifierContext
}

func NewDropTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropTableContext {
	var p = new(DropTableContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropTableContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *DropTableContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *DropTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *DropTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropTableContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropTableContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserFORCE, 0)
}

func (s *DropTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropTable(s)
	}
}

func (s *DropTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropTable(s)
	}
}

type DropStoragePolicyContext struct {
	SupportedDropStatementContext
	name IIdentifierContext
}

func NewDropStoragePolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropStoragePolicyContext {
	var p = new(DropStoragePolicyContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropStoragePolicyContext) GetName() IIdentifierContext { return s.name }

func (s *DropStoragePolicyContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropStoragePolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStoragePolicyContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropStoragePolicyContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *DropStoragePolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *DropStoragePolicyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropStoragePolicyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropStoragePolicyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropStoragePolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropStoragePolicy(s)
	}
}

func (s *DropStoragePolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropStoragePolicy(s)
	}
}

func (p *DorisParser) SupportedDropStatement() (localctx ISupportedDropStatementContext) {
	localctx = NewSupportedDropStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, DorisParserRULE_supportedDropStatement)
	var _la int

	p.SetState(1910)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 219, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDropCatalogRecycleBinContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1709)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1710)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1711)
			p.Match(DorisParserRECYCLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1712)
			p.Match(DorisParserBIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1713)
			p.Match(DorisParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1714)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*DropCatalogRecycleBinContext).idType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1715)
			p.Match(DorisParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1716)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*DropCatalogRecycleBinContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewDropEncryptkeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1717)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1718)
			p.Match(DorisParserENCRYPTKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1721)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1719)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1720)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1723)

			var _x = p.MultipartIdentifier()

			localctx.(*DropEncryptkeyContext).name = _x
		}

	case 3:
		localctx = NewDropRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1724)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1725)
			p.Match(DorisParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1728)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1726)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1727)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1730)

			var _x = p.IdentifierOrText()

			localctx.(*DropRoleContext).name = _x
		}

	case 4:
		localctx = NewDropSqlBlockRuleContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1731)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1732)
			p.Match(DorisParserSQL_BLOCK_RULE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1735)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1733)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1734)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1737)
			p.IdentifierSeq()
		}

	case 5:
		localctx = NewDropUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1738)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1739)
			p.Match(DorisParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1742)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1740)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1741)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1744)
			p.UserIdentify()
		}

	case 6:
		localctx = NewDropStoragePolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1745)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1746)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1747)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1750)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1748)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1749)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1752)

			var _x = p.Identifier()

			localctx.(*DropStoragePolicyContext).name = _x
		}

	case 7:
		localctx = NewDropWorkloadGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1753)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1754)
			p.Match(DorisParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1755)
			p.Match(DorisParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1758)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1756)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1757)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1760)

			var _x = p.IdentifierOrText()

			localctx.(*DropWorkloadGroupContext).name = _x
		}
		p.SetState(1763)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFOR {
			{
				p.SetState(1761)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1762)

				var _x = p.IdentifierOrText()

				localctx.(*DropWorkloadGroupContext).computeGroup = _x
			}

		}

	case 8:
		localctx = NewDropCatalogContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1765)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1766)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1769)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1767)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1768)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1771)

			var _x = p.Identifier()

			localctx.(*DropCatalogContext).name = _x
		}

	case 9:
		localctx = NewDropFileContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1772)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1773)
			p.Match(DorisParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1774)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*DropFileContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1777)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1775)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1776)

				var _x = p.Identifier()

				localctx.(*DropFileContext).database = _x
			}

		}
		{
			p.SetState(1779)

			var _x = p.PropertyClause()

			localctx.(*DropFileContext).properties = _x
		}

	case 10:
		localctx = NewDropWorkloadPolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1780)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1781)
			p.Match(DorisParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1782)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1785)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1783)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1784)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1787)

			var _x = p.IdentifierOrText()

			localctx.(*DropWorkloadPolicyContext).name = _x
		}

	case 11:
		localctx = NewDropRepositoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1788)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1789)
			p.Match(DorisParserREPOSITORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1790)

			var _x = p.Identifier()

			localctx.(*DropRepositoryContext).name = _x
		}

	case 12:
		localctx = NewDropTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1791)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1792)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1795)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1793)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1794)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1797)

			var _x = p.MultipartIdentifier()

			localctx.(*DropTableContext).name = _x
		}
		p.SetState(1799)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFORCE {
			{
				p.SetState(1798)
				p.Match(DorisParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 13:
		localctx = NewDropDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1801)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1802)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserDATABASE || _la == DorisParserSCHEMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1805)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1803)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1804)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1807)

			var _x = p.MultipartIdentifier()

			localctx.(*DropDatabaseContext).name = _x
		}
		p.SetState(1809)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFORCE {
			{
				p.SetState(1808)
				p.Match(DorisParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 14:
		localctx = NewDropFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1811)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1813)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION {
			{
				p.SetState(1812)
				p.StatementScope()
			}

		}
		{
			p.SetState(1815)
			p.Match(DorisParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1818)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1816)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1817)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1820)
			p.FunctionIdentifier()
		}
		{
			p.SetState(1821)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1823)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&9152335059222592) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&32633505112391681) != 0) || _la == DorisParserDOUBLE || _la == DorisParserFLOAT || ((int64((_la-213)) & ^0x3f) == 0 && ((int64(1)<<(_la-213))&9208814108673) != 0) || _la == DorisParserMAP || _la == DorisParserQUANTILE_STATE || ((int64((_la-426)) & ^0x3f) == 0 && ((int64(1)<<(_la-426))&704375029761) != 0) || _la == DorisParserVARCHAR || _la == DorisParserVARIANT {
			{
				p.SetState(1822)
				p.FunctionArguments()
			}

		}
		{
			p.SetState(1825)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		localctx = NewDropIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1827)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1828)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1831)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1829)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1830)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1833)

			var _x = p.Identifier()

			localctx.(*DropIndexContext).name = _x
		}
		{
			p.SetState(1834)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1835)

			var _x = p.MultipartIdentifier()

			localctx.(*DropIndexContext).tableName = _x
		}

	case 16:
		localctx = NewDropResourceContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1837)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1838)
			p.Match(DorisParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1841)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1839)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1840)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1843)

			var _x = p.IdentifierOrText()

			localctx.(*DropResourceContext).name = _x
		}

	case 17:
		localctx = NewDropRowPolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1844)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1845)
			p.Match(DorisParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1846)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1849)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1847)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1848)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1851)

			var _x = p.Identifier()

			localctx.(*DropRowPolicyContext).policyName = _x
		}
		{
			p.SetState(1852)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1853)

			var _x = p.MultipartIdentifier()

			localctx.(*DropRowPolicyContext).tableName = _x
		}
		p.SetState(1860)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFOR {
			{
				p.SetState(1854)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1858)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
				{
					p.SetState(1855)
					p.UserIdentify()
				}

			case DorisParserROLE:
				{
					p.SetState(1856)
					p.Match(DorisParserROLE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1857)

					var _x = p.Identifier()

					localctx.(*DropRowPolicyContext).roleName = _x
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}

	case 18:
		localctx = NewDropDictionaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1862)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1863)
			p.Match(DorisParserDICTIONARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1866)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1864)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1865)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1868)

			var _x = p.MultipartIdentifier()

			localctx.(*DropDictionaryContext).name = _x
		}

	case 19:
		localctx = NewDropStageContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1869)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1870)
			p.Match(DorisParserSTAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1873)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1871)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1872)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1875)

			var _x = p.Identifier()

			localctx.(*DropStageContext).name = _x
		}

	case 20:
		localctx = NewDropViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1876)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1877)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1880)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1878)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1879)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1882)

			var _x = p.MultipartIdentifier()

			localctx.(*DropViewContext).name = _x
		}

	case 21:
		localctx = NewDropIndexAnalyzerContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1883)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1884)
			p.Match(DorisParserINVERTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1885)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1886)
			p.Match(DorisParserANALYZER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1889)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1887)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1888)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1891)

			var _x = p.Identifier()

			localctx.(*DropIndexAnalyzerContext).name = _x
		}

	case 22:
		localctx = NewDropIndexTokenizerContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1892)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1893)
			p.Match(DorisParserINVERTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1894)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1895)
			p.Match(DorisParserTOKENIZER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1898)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1896)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1897)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1900)

			var _x = p.Identifier()

			localctx.(*DropIndexTokenizerContext).name = _x
		}

	case 23:
		localctx = NewDropIndexTokenFilterContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1901)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1902)
			p.Match(DorisParserINVERTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1903)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1904)
			p.Match(DorisParserTOKEN_FILTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1907)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(1905)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1906)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1909)

			var _x = p.Identifier()

			localctx.(*DropIndexTokenFilterContext).name = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedShowStatementContext is an interface to support dynamic dispatch.
type ISupportedShowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedShowStatementContext differentiates from other interfaces.
	IsSupportedShowStatementContext()
}

type SupportedShowStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedShowStatementContext() *SupportedShowStatementContext {
	var p = new(SupportedShowStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedShowStatement
	return p
}

func InitEmptySupportedShowStatementContext(p *SupportedShowStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedShowStatement
}

func (*SupportedShowStatementContext) IsSupportedShowStatementContext() {}

func NewSupportedShowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedShowStatementContext {
	var p = new(SupportedShowStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedShowStatement

	return p
}

func (s *SupportedShowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedShowStatementContext) CopyAll(ctx *SupportedShowStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedShowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedShowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowRepositoriesContext struct {
	SupportedShowStatementContext
}

func NewShowRepositoriesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRepositoriesContext {
	var p = new(ShowRepositoriesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowRepositoriesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRepositoriesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowRepositoriesContext) REPOSITORIES() antlr.TerminalNode {
	return s.GetToken(DorisParserREPOSITORIES, 0)
}

func (s *ShowRepositoriesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowRepositories(s)
	}
}

func (s *ShowRepositoriesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowRepositories(s)
	}
}

type ShowDataContext struct {
	SupportedShowStatementContext
	tableName IMultipartIdentifierContext
}

func NewShowDataContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDataContext {
	var p = new(ShowDataContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowDataContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowDataContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDataContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowDataContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserDATA, 0)
}

func (s *ShowDataContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *ShowDataContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowDataContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowDataContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ShowDataContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowData(s)
	}
}

func (s *ShowDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowData(s)
	}
}

type ShowIndexContext struct {
	SupportedShowStatementContext
	tableName IMultipartIdentifierContext
	database  IMultipartIdentifierContext
}

func NewShowIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowIndexContext {
	var p = new(ShowIndexContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowIndexContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowIndexContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowIndexContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowIndexContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowIndexContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowIndexContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserKEY, 0)
}

func (s *ShowIndexContext) KEYS() antlr.TerminalNode {
	return s.GetToken(DorisParserKEYS, 0)
}

func (s *ShowIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *ShowIndexContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEXES, 0)
}

func (s *ShowIndexContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(DorisParserFROM)
}

func (s *ShowIndexContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, i)
}

func (s *ShowIndexContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserIN)
}

func (s *ShowIndexContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserIN, i)
}

func (s *ShowIndexContext) AllMultipartIdentifier() []IMultipartIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultipartIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipartIdentifierContext); ok {
			tst[i] = t.(IMultipartIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ShowIndexContext) MultipartIdentifier(i int) IMultipartIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowIndex(s)
	}
}

func (s *ShowIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowIndex(s)
	}
}

type ShowDynamicPartitionContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowDynamicPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDynamicPartitionContext {
	var p = new(ShowDynamicPartitionContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowDynamicPartitionContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowDynamicPartitionContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowDynamicPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDynamicPartitionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowDynamicPartitionContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(DorisParserDYNAMIC, 0)
}

func (s *ShowDynamicPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *ShowDynamicPartitionContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLES, 0)
}

func (s *ShowDynamicPartitionContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowDynamicPartitionContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowDynamicPartitionContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowDynamicPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowDynamicPartition(s)
	}
}

func (s *ShowDynamicPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowDynamicPartition(s)
	}
}

type ShowTableStatusContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowTableStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTableStatusContext {
	var p = new(ShowTableStatusContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTableStatusContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowTableStatusContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowTableStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTableStatusContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTableStatusContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *ShowTableStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATUS, 0)
}

func (s *ShowTableStatusContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowTableStatusContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowTableStatusContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowTableStatusContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowTableStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTableStatus(s)
	}
}

func (s *ShowTableStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTableStatus(s)
	}
}

type ShowBackupContext struct {
	SupportedShowStatementContext
	database IIdentifierContext
}

func NewShowBackupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowBackupContext {
	var p = new(ShowBackupContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowBackupContext) GetDatabase() IIdentifierContext { return s.database }

func (s *ShowBackupContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *ShowBackupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBackupContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowBackupContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKUP, 0)
}

func (s *ShowBackupContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowBackupContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowBackupContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowBackupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowBackupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowBackup(s)
	}
}

func (s *ShowBackupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowBackup(s)
	}
}

type ShowCreateFunctionContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowCreateFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateFunctionContext {
	var p = new(ShowCreateFunctionContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCreateFunctionContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowCreateFunctionContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowCreateFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateFunctionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCreateFunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowCreateFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserFUNCTION, 0)
}

func (s *ShowCreateFunctionContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *ShowCreateFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ShowCreateFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ShowCreateFunctionContext) StatementScope() IStatementScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementScopeContext)
}

func (s *ShowCreateFunctionContext) FunctionArguments() IFunctionArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgumentsContext)
}

func (s *ShowCreateFunctionContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowCreateFunctionContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowCreateFunctionContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCreateFunction(s)
	}
}

func (s *ShowCreateFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCreateFunction(s)
	}
}

type ShowGrantsForUserContext struct {
	SupportedShowStatementContext
}

func NewShowGrantsForUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowGrantsForUserContext {
	var p = new(ShowGrantsForUserContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowGrantsForUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGrantsForUserContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowGrantsForUserContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(DorisParserGRANTS, 0)
}

func (s *ShowGrantsForUserContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *ShowGrantsForUserContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *ShowGrantsForUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowGrantsForUser(s)
	}
}

func (s *ShowGrantsForUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowGrantsForUser(s)
	}
}

type ShowViewContext struct {
	SupportedShowStatementContext
	tableName IMultipartIdentifierContext
	database  IIdentifierContext
}

func NewShowViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowViewContext {
	var p = new(ShowViewContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowViewContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowViewContext) GetDatabase() IIdentifierContext { return s.database }

func (s *ShowViewContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowViewContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *ShowViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowViewContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *ShowViewContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(DorisParserFROM)
}

func (s *ShowViewContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, i)
}

func (s *ShowViewContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserIN)
}

func (s *ShowViewContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserIN, i)
}

func (s *ShowViewContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowViewContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowView(s)
	}
}

func (s *ShowViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowView(s)
	}
}

type ShowTablesContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTablesContext {
	var p = new(ShowTablesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTablesContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowTablesContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLES, 0)
}

func (s *ShowTablesContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserFULL, 0)
}

func (s *ShowTablesContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowTablesContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowTablesContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowTablesContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTables(s)
	}
}

func (s *ShowTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTables(s)
	}
}

type ShowExportContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowExportContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowExportContext {
	var p = new(ShowExportContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowExportContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowExportContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowExportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowExportContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowExportContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(DorisParserEXPORT, 0)
}

func (s *ShowExportContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowExportContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowExportContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowExportContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowExportContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowExportContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowExportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowExport(s)
	}
}

func (s *ShowExportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowExport(s)
	}
}

type ShowAuthorsContext struct {
	SupportedShowStatementContext
}

func NewShowAuthorsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAuthorsContext {
	var p = new(ShowAuthorsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowAuthorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAuthorsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowAuthorsContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTHORS, 0)
}

func (s *ShowAuthorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowAuthors(s)
	}
}

func (s *ShowAuthorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowAuthors(s)
	}
}

type ShowStorageEnginesContext struct {
	SupportedShowStatementContext
}

func NewShowStorageEnginesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStorageEnginesContext {
	var p = new(ShowStorageEnginesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowStorageEnginesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStorageEnginesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowStorageEnginesContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(DorisParserENGINES, 0)
}

func (s *ShowStorageEnginesContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *ShowStorageEnginesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowStorageEngines(s)
	}
}

func (s *ShowStorageEnginesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowStorageEngines(s)
	}
}

type ShowWarningErrorsContext struct {
	SupportedShowStatementContext
}

func NewShowWarningErrorsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowWarningErrorsContext {
	var p = new(ShowWarningErrorsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowWarningErrorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWarningErrorsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowWarningErrorsContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(DorisParserWARNINGS, 0)
}

func (s *ShowWarningErrorsContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(DorisParserERRORS, 0)
}

func (s *ShowWarningErrorsContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowWarningErrorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowWarningErrors(s)
	}
}

func (s *ShowWarningErrorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowWarningErrors(s)
	}
}

type ShowCatalogsContext struct {
	SupportedShowStatementContext
}

func NewShowCatalogsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCatalogsContext {
	var p = new(ShowCatalogsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCatalogsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCatalogsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCatalogsContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOGS, 0)
}

func (s *ShowCatalogsContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowCatalogsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCatalogs(s)
	}
}

func (s *ShowCatalogsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCatalogs(s)
	}
}

type ShowRolesContext struct {
	SupportedShowStatementContext
}

func NewShowRolesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRolesContext {
	var p = new(ShowRolesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowRolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRolesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowRolesContext) ROLES() antlr.TerminalNode {
	return s.GetToken(DorisParserROLES, 0)
}

func (s *ShowRolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowRoles(s)
	}
}

func (s *ShowRolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowRoles(s)
	}
}

type ShowRowPolicyContext struct {
	SupportedShowStatementContext
	role IIdentifierContext
}

func NewShowRowPolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRowPolicyContext {
	var p = new(ShowRowPolicyContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowRowPolicyContext) GetRole() IIdentifierContext { return s.role }

func (s *ShowRowPolicyContext) SetRole(v IIdentifierContext) { s.role = v }

func (s *ShowRowPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRowPolicyContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowRowPolicyContext) ROW() antlr.TerminalNode {
	return s.GetToken(DorisParserROW, 0)
}

func (s *ShowRowPolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *ShowRowPolicyContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *ShowRowPolicyContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *ShowRowPolicyContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *ShowRowPolicyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowRowPolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowRowPolicy(s)
	}
}

func (s *ShowRowPolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowRowPolicy(s)
	}
}

type ShowTabletsBelongContext struct {
	SupportedShowStatementContext
	_INTEGER_VALUE antlr.Token
	tabletIds      []antlr.Token
}

func NewShowTabletsBelongContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTabletsBelongContext {
	var p = new(ShowTabletsBelongContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTabletsBelongContext) Get_INTEGER_VALUE() antlr.Token { return s._INTEGER_VALUE }

func (s *ShowTabletsBelongContext) Set_INTEGER_VALUE(v antlr.Token) { s._INTEGER_VALUE = v }

func (s *ShowTabletsBelongContext) GetTabletIds() []antlr.Token { return s.tabletIds }

func (s *ShowTabletsBelongContext) SetTabletIds(v []antlr.Token) { s.tabletIds = v }

func (s *ShowTabletsBelongContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTabletsBelongContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTabletsBelongContext) TABLETS() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLETS, 0)
}

func (s *ShowTabletsBelongContext) BELONG() antlr.TerminalNode {
	return s.GetToken(DorisParserBELONG, 0)
}

func (s *ShowTabletsBelongContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserINTEGER_VALUE)
}

func (s *ShowTabletsBelongContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, i)
}

func (s *ShowTabletsBelongContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ShowTabletsBelongContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ShowTabletsBelongContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTabletsBelong(s)
	}
}

func (s *ShowTabletsBelongContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTabletsBelong(s)
	}
}

type ShowTriggersContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowTriggersContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTriggersContext {
	var p = new(ShowTriggersContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTriggersContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowTriggersContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowTriggersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTriggersContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTriggersContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(DorisParserTRIGGERS, 0)
}

func (s *ShowTriggersContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserFULL, 0)
}

func (s *ShowTriggersContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowTriggersContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowTriggersContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowTriggersContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowTriggersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTriggers(s)
	}
}

func (s *ShowTriggersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTriggers(s)
	}
}

type ShowCreateTableContext struct {
	SupportedShowStatementContext
	name IMultipartIdentifierContext
}

func NewShowCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateTableContext {
	var p = new(ShowCreateTableContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCreateTableContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *ShowCreateTableContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *ShowCreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateTableContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowCreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *ShowCreateTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateTableContext) BRIEF() antlr.TerminalNode {
	return s.GetToken(DorisParserBRIEF, 0)
}

func (s *ShowCreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCreateTable(s)
	}
}

func (s *ShowCreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCreateTable(s)
	}
}

type ShowCatalogContext struct {
	SupportedShowStatementContext
	name IIdentifierContext
}

func NewShowCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCatalogContext {
	var p = new(ShowCatalogContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCatalogContext) GetName() IIdentifierContext { return s.name }

func (s *ShowCatalogContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ShowCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCatalogContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCatalogContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *ShowCatalogContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCatalogContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCatalog(s)
	}
}

func (s *ShowCatalogContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCatalog(s)
	}
}

type ShowColumnsContext struct {
	SupportedShowStatementContext
	tableName IMultipartIdentifierContext
	database  IMultipartIdentifierContext
}

func NewShowColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnsContext {
	var p = new(ShowColumnsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowColumnsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowColumnsContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowColumnsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowColumnsContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMNS, 0)
}

func (s *ShowColumnsContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(DorisParserFIELDS, 0)
}

func (s *ShowColumnsContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(DorisParserFROM)
}

func (s *ShowColumnsContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, i)
}

func (s *ShowColumnsContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserIN)
}

func (s *ShowColumnsContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserIN, i)
}

func (s *ShowColumnsContext) AllMultipartIdentifier() []IMultipartIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultipartIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipartIdentifierContext); ok {
			tst[i] = t.(IMultipartIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ShowColumnsContext) MultipartIdentifier(i int) IMultipartIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowColumnsContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserFULL, 0)
}

func (s *ShowColumnsContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowColumns(s)
	}
}

func (s *ShowColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowColumns(s)
	}
}

type ShowBuildIndexContext struct {
	SupportedShowStatementContext
	database IIdentifierContext
}

func NewShowBuildIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowBuildIndexContext {
	var p = new(ShowBuildIndexContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowBuildIndexContext) GetDatabase() IIdentifierContext { return s.database }

func (s *ShowBuildIndexContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *ShowBuildIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBuildIndexContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowBuildIndexContext) BUILD() antlr.TerminalNode {
	return s.GetToken(DorisParserBUILD, 0)
}

func (s *ShowBuildIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *ShowBuildIndexContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowBuildIndexContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowBuildIndexContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowBuildIndexContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowBuildIndexContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowBuildIndexContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowBuildIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowBuildIndex(s)
	}
}

func (s *ShowBuildIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowBuildIndex(s)
	}
}

type ShowVariablesContext struct {
	SupportedShowStatementContext
}

func NewShowVariablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowVariablesContext {
	var p = new(ShowVariablesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowVariablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowVariablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowVariablesContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserVARIABLES, 0)
}

func (s *ShowVariablesContext) StatementScope() IStatementScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementScopeContext)
}

func (s *ShowVariablesContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowVariablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowVariables(s)
	}
}

func (s *ShowVariablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowVariables(s)
	}
}

type ShowEventsContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowEventsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowEventsContext {
	var p = new(ShowEventsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowEventsContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowEventsContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowEventsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowEventsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowEventsContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEVENTS, 0)
}

func (s *ShowEventsContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowEventsContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowEventsContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowEventsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowEventsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowEvents(s)
	}
}

func (s *ShowEventsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowEvents(s)
	}
}

type ShowPluginsContext struct {
	SupportedShowStatementContext
}

func NewShowPluginsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowPluginsContext {
	var p = new(ShowPluginsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowPluginsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPluginsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowPluginsContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(DorisParserPLUGINS, 0)
}

func (s *ShowPluginsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowPlugins(s)
	}
}

func (s *ShowPluginsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowPlugins(s)
	}
}

type ShowAllPropertiesContext struct {
	SupportedShowStatementContext
}

func NewShowAllPropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAllPropertiesContext {
	var p = new(ShowAllPropertiesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowAllPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAllPropertiesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowAllPropertiesContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *ShowAllPropertiesContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *ShowAllPropertiesContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *ShowAllPropertiesContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowAllPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowAllProperties(s)
	}
}

func (s *ShowAllPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowAllProperties(s)
	}
}

type ShowDataSkewContext struct {
	SupportedShowStatementContext
}

func NewShowDataSkewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDataSkewContext {
	var p = new(ShowDataSkewContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowDataSkewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDataSkewContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowDataSkewContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserDATA, 0)
}

func (s *ShowDataSkewContext) SKEW() antlr.TerminalNode {
	return s.GetToken(DorisParserSKEW, 0)
}

func (s *ShowDataSkewContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowDataSkewContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *ShowDataSkewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowDataSkew(s)
	}
}

func (s *ShowDataSkewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowDataSkew(s)
	}
}

type ShowConvertLscContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowConvertLscContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowConvertLscContext {
	var p = new(ShowConvertLscContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowConvertLscContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowConvertLscContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowConvertLscContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowConvertLscContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowConvertLscContext) CONVERT_LSC() antlr.TerminalNode {
	return s.GetToken(DorisParserCONVERT_LSC, 0)
}

func (s *ShowConvertLscContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowConvertLscContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowConvertLscContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowConvertLscContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowConvertLsc(s)
	}
}

func (s *ShowConvertLscContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowConvertLsc(s)
	}
}

type ShowSqlBlockRuleContext struct {
	SupportedShowStatementContext
	ruleName IIdentifierContext
}

func NewShowSqlBlockRuleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSqlBlockRuleContext {
	var p = new(ShowSqlBlockRuleContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowSqlBlockRuleContext) GetRuleName() IIdentifierContext { return s.ruleName }

func (s *ShowSqlBlockRuleContext) SetRuleName(v IIdentifierContext) { s.ruleName = v }

func (s *ShowSqlBlockRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSqlBlockRuleContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowSqlBlockRuleContext) SQL_BLOCK_RULE() antlr.TerminalNode {
	return s.GetToken(DorisParserSQL_BLOCK_RULE, 0)
}

func (s *ShowSqlBlockRuleContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *ShowSqlBlockRuleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowSqlBlockRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowSqlBlockRule(s)
	}
}

func (s *ShowSqlBlockRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowSqlBlockRule(s)
	}
}

type ShowTableCreationContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowTableCreationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTableCreationContext {
	var p = new(ShowTableCreationContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTableCreationContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowTableCreationContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowTableCreationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTableCreationContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTableCreationContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *ShowTableCreationContext) CREATION() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATION, 0)
}

func (s *ShowTableCreationContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *ShowTableCreationContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowTableCreationContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowTableCreationContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowTableCreationContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowTableCreationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTableCreation(s)
	}
}

func (s *ShowTableCreationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTableCreation(s)
	}
}

type ShowWarningErrorCountContext struct {
	SupportedShowStatementContext
}

func NewShowWarningErrorCountContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowWarningErrorCountContext {
	var p = new(ShowWarningErrorCountContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowWarningErrorCountContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWarningErrorCountContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowWarningErrorCountContext) COUNT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOUNT, 0)
}

func (s *ShowWarningErrorCountContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ShowWarningErrorCountContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserASTERISK, 0)
}

func (s *ShowWarningErrorCountContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ShowWarningErrorCountContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(DorisParserWARNINGS, 0)
}

func (s *ShowWarningErrorCountContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(DorisParserERRORS, 0)
}

func (s *ShowWarningErrorCountContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowWarningErrorCount(s)
	}
}

func (s *ShowWarningErrorCountContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowWarningErrorCount(s)
	}
}

type ShowReplicaStatusContext struct {
	SupportedShowStatementContext
}

func NewShowReplicaStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowReplicaStatusContext {
	var p = new(ShowReplicaStatusContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowReplicaStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowReplicaStatusContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowReplicaStatusContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLICA, 0)
}

func (s *ShowReplicaStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATUS, 0)
}

func (s *ShowReplicaStatusContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowReplicaStatusContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *ShowReplicaStatusContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *ShowReplicaStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowReplicaStatus(s)
	}
}

func (s *ShowReplicaStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowReplicaStatus(s)
	}
}

type ShowDeleteContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowDeleteContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDeleteContext {
	var p = new(ShowDeleteContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowDeleteContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowDeleteContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowDeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDeleteContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowDeleteContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisParserDELETE, 0)
}

func (s *ShowDeleteContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowDeleteContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowDeleteContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowDeleteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowDelete(s)
	}
}

func (s *ShowDeleteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowDelete(s)
	}
}

type ShowTabletsFromTableContext struct {
	SupportedShowStatementContext
	tableName IMultipartIdentifierContext
}

func NewShowTabletsFromTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTabletsFromTableContext {
	var p = new(ShowTabletsFromTableContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTabletsFromTableContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowTabletsFromTableContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowTabletsFromTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTabletsFromTableContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTabletsFromTableContext) TABLETS() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLETS, 0)
}

func (s *ShowTabletsFromTableContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowTabletsFromTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowTabletsFromTableContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *ShowTabletsFromTableContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowTabletsFromTableContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowTabletsFromTableContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowTabletsFromTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTabletsFromTable(s)
	}
}

func (s *ShowTabletsFromTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTabletsFromTable(s)
	}
}

type ShowStagesContext struct {
	SupportedShowStatementContext
}

func NewShowStagesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStagesContext {
	var p = new(ShowStagesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowStagesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStagesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowStagesContext) STAGES() antlr.TerminalNode {
	return s.GetToken(DorisParserSTAGES, 0)
}

func (s *ShowStagesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowStages(s)
	}
}

func (s *ShowStagesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowStages(s)
	}
}

type ShowTransactionContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTransactionContext {
	var p = new(ShowTransactionContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTransactionContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowTransactionContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTransactionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisParserTRANSACTION, 0)
}

func (s *ShowTransactionContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowTransactionContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowTransactionContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowTransactionContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTransaction(s)
	}
}

func (s *ShowTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTransaction(s)
	}
}

type ShowBrokerContext struct {
	SupportedShowStatementContext
}

func NewShowBrokerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowBrokerContext {
	var p = new(ShowBrokerContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowBrokerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBrokerContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowBrokerContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserBROKER, 0)
}

func (s *ShowBrokerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowBroker(s)
	}
}

func (s *ShowBrokerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowBroker(s)
	}
}

type ShowGrantsContext struct {
	SupportedShowStatementContext
}

func NewShowGrantsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowGrantsContext {
	var p = new(ShowGrantsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowGrantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGrantsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowGrantsContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(DorisParserGRANTS, 0)
}

func (s *ShowGrantsContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *ShowGrantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowGrants(s)
	}
}

func (s *ShowGrantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowGrants(s)
	}
}

type ShowResourcesContext struct {
	SupportedShowStatementContext
}

func NewShowResourcesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowResourcesContext {
	var p = new(ShowResourcesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowResourcesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowResourcesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowResourcesContext) RESOURCES() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCES, 0)
}

func (s *ShowResourcesContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowResourcesContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowResourcesContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowResourcesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowResources(s)
	}
}

func (s *ShowResourcesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowResources(s)
	}
}

type ShowWorkloadGroupsContext struct {
	SupportedShowStatementContext
}

func NewShowWorkloadGroupsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowWorkloadGroupsContext {
	var p = new(ShowWorkloadGroupsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowWorkloadGroupsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWorkloadGroupsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowWorkloadGroupsContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserWORKLOAD, 0)
}

func (s *ShowWorkloadGroupsContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUPS, 0)
}

func (s *ShowWorkloadGroupsContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *ShowWorkloadGroupsContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowWorkloadGroupsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowWorkloadGroups(s)
	}
}

func (s *ShowWorkloadGroupsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowWorkloadGroups(s)
	}
}

type ShowReplicaDistributionContext struct {
	SupportedShowStatementContext
}

func NewShowReplicaDistributionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowReplicaDistributionContext {
	var p = new(ShowReplicaDistributionContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowReplicaDistributionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowReplicaDistributionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowReplicaDistributionContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLICA, 0)
}

func (s *ShowReplicaDistributionContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTRIBUTION, 0)
}

func (s *ShowReplicaDistributionContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowReplicaDistributionContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *ShowReplicaDistributionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowReplicaDistribution(s)
	}
}

func (s *ShowReplicaDistributionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowReplicaDistribution(s)
	}
}

type ShowTabletStorageFormatContext struct {
	SupportedShowStatementContext
}

func NewShowTabletStorageFormatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTabletStorageFormatContext {
	var p = new(ShowTabletStorageFormatContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTabletStorageFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTabletStorageFormatContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTabletStorageFormatContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLET, 0)
}

func (s *ShowTabletStorageFormatContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *ShowTabletStorageFormatContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DorisParserFORMAT, 0)
}

func (s *ShowTabletStorageFormatContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserVERBOSE, 0)
}

func (s *ShowTabletStorageFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTabletStorageFormat(s)
	}
}

func (s *ShowTabletStorageFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTabletStorageFormat(s)
	}
}

type ShowCharsetContext struct {
	SupportedShowStatementContext
}

func NewShowCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCharsetContext {
	var p = new(ShowCharsetContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCharsetContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCharsetContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(DorisParserCHARSET, 0)
}

func (s *ShowCharsetContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserCHAR, 0)
}

func (s *ShowCharsetContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *ShowCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCharset(s)
	}
}

func (s *ShowCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCharset(s)
	}
}

type ShowProcContext struct {
	SupportedShowStatementContext
	path antlr.Token
}

func NewShowProcContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowProcContext {
	var p = new(ShowProcContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowProcContext) GetPath() antlr.Token { return s.path }

func (s *ShowProcContext) SetPath(v antlr.Token) { s.path = v }

func (s *ShowProcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProcContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowProcContext) PROC() antlr.TerminalNode {
	return s.GetToken(DorisParserPROC, 0)
}

func (s *ShowProcContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowProcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowProc(s)
	}
}

func (s *ShowProcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowProc(s)
	}
}

type ShowCreateViewContext struct {
	SupportedShowStatementContext
	name IMultipartIdentifierContext
}

func NewShowCreateViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateViewContext {
	var p = new(ShowCreateViewContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCreateViewContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *ShowCreateViewContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *ShowCreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateViewContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCreateViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowCreateViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *ShowCreateViewContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCreateView(s)
	}
}

func (s *ShowCreateViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCreateView(s)
	}
}

type ShowOpenTablesContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowOpenTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowOpenTablesContext {
	var p = new(ShowOpenTablesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowOpenTablesContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowOpenTablesContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowOpenTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowOpenTablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowOpenTablesContext) OPEN() antlr.TerminalNode {
	return s.GetToken(DorisParserOPEN, 0)
}

func (s *ShowOpenTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLES, 0)
}

func (s *ShowOpenTablesContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowOpenTablesContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowOpenTablesContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowOpenTablesContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowOpenTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowOpenTables(s)
	}
}

func (s *ShowOpenTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowOpenTables(s)
	}
}

type ShowQueryStatsContext struct {
	SupportedShowStatementContext
	database  IIdentifierContext
	tableName IMultipartIdentifierContext
}

func NewShowQueryStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowQueryStatsContext {
	var p = new(ShowQueryStatsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowQueryStatsContext) GetDatabase() IIdentifierContext { return s.database }

func (s *ShowQueryStatsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowQueryStatsContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *ShowQueryStatsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowQueryStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowQueryStatsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowQueryStatsContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DorisParserQUERY, 0)
}

func (s *ShowQueryStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *ShowQueryStatsContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *ShowQueryStatsContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowQueryStatsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowQueryStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowQueryStatsContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *ShowQueryStatsContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserVERBOSE, 0)
}

func (s *ShowQueryStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowQueryStats(s)
	}
}

func (s *ShowQueryStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowQueryStats(s)
	}
}

type ShowCreateDatabaseContext struct {
	SupportedShowStatementContext
	name IMultipartIdentifierContext
}

func NewShowCreateDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateDatabaseContext {
	var p = new(ShowCreateDatabaseContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCreateDatabaseContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *ShowCreateDatabaseContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *ShowCreateDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateDatabaseContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCreateDatabaseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowCreateDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *ShowCreateDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEMA, 0)
}

func (s *ShowCreateDatabaseContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCreateDatabase(s)
	}
}

func (s *ShowCreateDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCreateDatabase(s)
	}
}

type ShowQueryProfileContext struct {
	SupportedShowStatementContext
	queryIdPath antlr.Token
}

func NewShowQueryProfileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowQueryProfileContext {
	var p = new(ShowQueryProfileContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowQueryProfileContext) GetQueryIdPath() antlr.Token { return s.queryIdPath }

func (s *ShowQueryProfileContext) SetQueryIdPath(v antlr.Token) { s.queryIdPath = v }

func (s *ShowQueryProfileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowQueryProfileContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowQueryProfileContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DorisParserQUERY, 0)
}

func (s *ShowQueryProfileContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserPROFILE, 0)
}

func (s *ShowQueryProfileContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowQueryProfileContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowQueryProfileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowQueryProfile(s)
	}
}

func (s *ShowQueryProfileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowQueryProfile(s)
	}
}

type ShowDictionariesContext struct {
	SupportedShowStatementContext
}

func NewShowDictionariesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDictionariesContext {
	var p = new(ShowDictionariesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowDictionariesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDictionariesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowDictionariesContext) DICTIONARIES() antlr.TerminalNode {
	return s.GetToken(DorisParserDICTIONARIES, 0)
}

func (s *ShowDictionariesContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowDictionariesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowDictionaries(s)
	}
}

func (s *ShowDictionariesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowDictionaries(s)
	}
}

type ShowStoragePolicyContext struct {
	SupportedShowStatementContext
	policy IIdentifierOrTextContext
}

func NewShowStoragePolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStoragePolicyContext {
	var p = new(ShowStoragePolicyContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowStoragePolicyContext) GetPolicy() IIdentifierOrTextContext { return s.policy }

func (s *ShowStoragePolicyContext) SetPolicy(v IIdentifierOrTextContext) { s.policy = v }

func (s *ShowStoragePolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStoragePolicyContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowStoragePolicyContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *ShowStoragePolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *ShowStoragePolicyContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserUSING, 0)
}

func (s *ShowStoragePolicyContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *ShowStoragePolicyContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *ShowStoragePolicyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowStoragePolicy(s)
	}
}

func (s *ShowStoragePolicyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowStoragePolicy(s)
	}
}

type ShowEncryptKeysContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowEncryptKeysContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowEncryptKeysContext {
	var p = new(ShowEncryptKeysContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowEncryptKeysContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowEncryptKeysContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowEncryptKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowEncryptKeysContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowEncryptKeysContext) ENCRYPTKEYS() antlr.TerminalNode {
	return s.GetToken(DorisParserENCRYPTKEYS, 0)
}

func (s *ShowEncryptKeysContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *ShowEncryptKeysContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowEncryptKeysContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowEncryptKeysContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowEncryptKeysContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowEncryptKeysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowEncryptKeys(s)
	}
}

func (s *ShowEncryptKeysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowEncryptKeys(s)
	}
}

type ShowLoadContext struct {
	SupportedShowStatementContext
	database IIdentifierContext
}

func NewShowLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowLoadContext {
	var p = new(ShowLoadContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowLoadContext) GetDatabase() IIdentifierContext { return s.database }

func (s *ShowLoadContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *ShowLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowLoadContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *ShowLoadContext) STREAM() antlr.TerminalNode {
	return s.GetToken(DorisParserSTREAM, 0)
}

func (s *ShowLoadContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowLoadContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowLoadContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowLoadContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowLoadContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowLoadContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowLoad(s)
	}
}

func (s *ShowLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowLoad(s)
	}
}

type ShowClustersContext struct {
	SupportedShowStatementContext
}

func NewShowClustersContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowClustersContext {
	var p = new(ShowClustersContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowClustersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowClustersContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowClustersContext) CLUSTERS() antlr.TerminalNode {
	return s.GetToken(DorisParserCLUSTERS, 0)
}

func (s *ShowClustersContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPUTE, 0)
}

func (s *ShowClustersContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUPS, 0)
}

func (s *ShowClustersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowClusters(s)
	}
}

func (s *ShowClustersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowClusters(s)
	}
}

type ShowTrashContext struct {
	SupportedShowStatementContext
	backend antlr.Token
}

func NewShowTrashContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTrashContext {
	var p = new(ShowTrashContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTrashContext) GetBackend() antlr.Token { return s.backend }

func (s *ShowTrashContext) SetBackend(v antlr.Token) { s.backend = v }

func (s *ShowTrashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTrashContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTrashContext) TRASH() antlr.TerminalNode {
	return s.GetToken(DorisParserTRASH, 0)
}

func (s *ShowTrashContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *ShowTrashContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowTrashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTrash(s)
	}
}

func (s *ShowTrashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTrash(s)
	}
}

type ShowPartitionsContext struct {
	SupportedShowStatementContext
	tableName IMultipartIdentifierContext
}

func NewShowPartitionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowPartitionsContext {
	var p = new(ShowPartitionsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowPartitionsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowPartitionsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowPartitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPartitionsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowPartitionsContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITIONS, 0)
}

func (s *ShowPartitionsContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowPartitionsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowPartitionsContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *ShowPartitionsContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowPartitionsContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowPartitionsContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowPartitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowPartitions(s)
	}
}

func (s *ShowPartitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowPartitions(s)
	}
}

type ShowGlobalFunctionsContext struct {
	SupportedShowStatementContext
}

func NewShowGlobalFunctionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowGlobalFunctionsContext {
	var p = new(ShowGlobalFunctionsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowGlobalFunctionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGlobalFunctionsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowGlobalFunctionsContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *ShowGlobalFunctionsContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserFUNCTIONS, 0)
}

func (s *ShowGlobalFunctionsContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserFULL, 0)
}

func (s *ShowGlobalFunctionsContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *ShowGlobalFunctionsContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowGlobalFunctionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowGlobalFunctions(s)
	}
}

func (s *ShowGlobalFunctionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowGlobalFunctions(s)
	}
}

type ShowFrontendsContext struct {
	SupportedShowStatementContext
	name IIdentifierContext
}

func NewShowFrontendsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowFrontendsContext {
	var p = new(ShowFrontendsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowFrontendsContext) GetName() IIdentifierContext { return s.name }

func (s *ShowFrontendsContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ShowFrontendsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFrontendsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowFrontendsContext) FRONTENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserFRONTENDS, 0)
}

func (s *ShowFrontendsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowFrontendsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowFrontends(s)
	}
}

func (s *ShowFrontendsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowFrontends(s)
	}
}

type ShowLoadProfileContext struct {
	SupportedShowStatementContext
	loadIdPath antlr.Token
}

func NewShowLoadProfileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowLoadProfileContext {
	var p = new(ShowLoadProfileContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowLoadProfileContext) GetLoadIdPath() antlr.Token { return s.loadIdPath }

func (s *ShowLoadProfileContext) SetLoadIdPath(v antlr.Token) { s.loadIdPath = v }

func (s *ShowLoadProfileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowLoadProfileContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowLoadProfileContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *ShowLoadProfileContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserPROFILE, 0)
}

func (s *ShowLoadProfileContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowLoadProfileContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowLoadProfileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowLoadProfile(s)
	}
}

func (s *ShowLoadProfileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowLoadProfile(s)
	}
}

type ShowPartitionIdContext struct {
	SupportedShowStatementContext
	partitionId antlr.Token
}

func NewShowPartitionIdContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowPartitionIdContext {
	var p = new(ShowPartitionIdContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowPartitionIdContext) GetPartitionId() antlr.Token { return s.partitionId }

func (s *ShowPartitionIdContext) SetPartitionId(v antlr.Token) { s.partitionId = v }

func (s *ShowPartitionIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPartitionIdContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowPartitionIdContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *ShowPartitionIdContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ShowPartitionIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowPartitionId(s)
	}
}

func (s *ShowPartitionIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowPartitionId(s)
	}
}

type ShowSnapshotContext struct {
	SupportedShowStatementContext
	repo IIdentifierContext
}

func NewShowSnapshotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSnapshotContext {
	var p = new(ShowSnapshotContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowSnapshotContext) GetRepo() IIdentifierContext { return s.repo }

func (s *ShowSnapshotContext) SetRepo(v IIdentifierContext) { s.repo = v }

func (s *ShowSnapshotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSnapshotContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowSnapshotContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisParserSNAPSHOT, 0)
}

func (s *ShowSnapshotContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *ShowSnapshotContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowSnapshotContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowSnapshotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowSnapshot(s)
	}
}

func (s *ShowSnapshotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowSnapshot(s)
	}
}

type ShowCatalogRecycleBinContext struct {
	SupportedShowStatementContext
}

func NewShowCatalogRecycleBinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCatalogRecycleBinContext {
	var p = new(ShowCatalogRecycleBinContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCatalogRecycleBinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCatalogRecycleBinContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCatalogRecycleBinContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *ShowCatalogRecycleBinContext) RECYCLE() antlr.TerminalNode {
	return s.GetToken(DorisParserRECYCLE, 0)
}

func (s *ShowCatalogRecycleBinContext) BIN() antlr.TerminalNode {
	return s.GetToken(DorisParserBIN, 0)
}

func (s *ShowCatalogRecycleBinContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserWHERE, 0)
}

func (s *ShowCatalogRecycleBinContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowCatalogRecycleBinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCatalogRecycleBin(s)
	}
}

func (s *ShowCatalogRecycleBinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCatalogRecycleBin(s)
	}
}

type ShowCopyContext struct {
	SupportedShowStatementContext
	database IIdentifierContext
}

func NewShowCopyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCopyContext {
	var p = new(ShowCopyContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCopyContext) GetDatabase() IIdentifierContext { return s.database }

func (s *ShowCopyContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *ShowCopyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCopyContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCopyContext) COPY() antlr.TerminalNode {
	return s.GetToken(DorisParserCOPY, 0)
}

func (s *ShowCopyContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *ShowCopyContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowCopyContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowCopyContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowCopyContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowCopyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCopyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCopy(s)
	}
}

func (s *ShowCopyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCopy(s)
	}
}

type ShowCollationContext struct {
	SupportedShowStatementContext
}

func NewShowCollationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCollationContext {
	var p = new(ShowCollationContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCollationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCollationContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCollationContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLLATION, 0)
}

func (s *ShowCollationContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowCollationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCollation(s)
	}
}

func (s *ShowCollationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCollation(s)
	}
}

type ShowBackendsContext struct {
	SupportedShowStatementContext
}

func NewShowBackendsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowBackendsContext {
	var p = new(ShowBackendsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowBackendsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBackendsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowBackendsContext) BACKENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKENDS, 0)
}

func (s *ShowBackendsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowBackends(s)
	}
}

func (s *ShowBackendsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowBackends(s)
	}
}

type ShowTypeCastContext struct {
	SupportedShowStatementContext
	database IIdentifierContext
}

func NewShowTypeCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTypeCastContext {
	var p = new(ShowTypeCastContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTypeCastContext) GetDatabase() IIdentifierContext { return s.database }

func (s *ShowTypeCastContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *ShowTypeCastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTypeCastContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTypeCastContext) TYPECAST() antlr.TerminalNode {
	return s.GetToken(DorisParserTYPECAST, 0)
}

func (s *ShowTypeCastContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowTypeCastContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowTypeCastContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowTypeCastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTypeCast(s)
	}
}

func (s *ShowTypeCastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTypeCast(s)
	}
}

type ShowPrivilegesContext struct {
	SupportedShowStatementContext
}

func NewShowPrivilegesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowPrivilegesContext {
	var p = new(ShowPrivilegesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowPrivilegesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPrivilegesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowPrivilegesContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(DorisParserPRIVILEGES, 0)
}

func (s *ShowPrivilegesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowPrivileges(s)
	}
}

func (s *ShowPrivilegesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowPrivileges(s)
	}
}

type ShowRestoreContext struct {
	SupportedShowStatementContext
	database IIdentifierContext
}

func NewShowRestoreContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRestoreContext {
	var p = new(ShowRestoreContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowRestoreContext) GetDatabase() IIdentifierContext { return s.database }

func (s *ShowRestoreContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *ShowRestoreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRestoreContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowRestoreContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESTORE, 0)
}

func (s *ShowRestoreContext) BRIEF() antlr.TerminalNode {
	return s.GetToken(DorisParserBRIEF, 0)
}

func (s *ShowRestoreContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowRestoreContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowRestoreContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowRestoreContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowRestoreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowRestore(s)
	}
}

func (s *ShowRestoreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowRestore(s)
	}
}

type ShowLoadWaringsContext struct {
	SupportedShowStatementContext
	database IIdentifierContext
	url      antlr.Token
}

func NewShowLoadWaringsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowLoadWaringsContext {
	var p = new(ShowLoadWaringsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowLoadWaringsContext) GetUrl() antlr.Token { return s.url }

func (s *ShowLoadWaringsContext) SetUrl(v antlr.Token) { s.url = v }

func (s *ShowLoadWaringsContext) GetDatabase() IIdentifierContext { return s.database }

func (s *ShowLoadWaringsContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *ShowLoadWaringsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowLoadWaringsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowLoadWaringsContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *ShowLoadWaringsContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(DorisParserWARNINGS, 0)
}

func (s *ShowLoadWaringsContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *ShowLoadWaringsContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowLoadWaringsContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowLoadWaringsContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowLoadWaringsContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowLoadWaringsContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowLoadWaringsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowLoadWaringsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowLoadWarings(s)
	}
}

func (s *ShowLoadWaringsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowLoadWarings(s)
	}
}

type ShowAlterTableContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowAlterTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAlterTableContext {
	var p = new(ShowAlterTableContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowAlterTableContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowAlterTableContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowAlterTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAlterTableContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowAlterTableContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *ShowAlterTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *ShowAlterTableContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *ShowAlterTableContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *ShowAlterTableContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowAlterTableContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowAlterTableContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowAlterTableContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *ShowAlterTableContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *ShowAlterTableContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowAlterTableContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowAlterTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowAlterTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowAlterTable(s)
	}
}

func (s *ShowAlterTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowAlterTable(s)
	}
}

type ShowTableIdContext struct {
	SupportedShowStatementContext
	tableId antlr.Token
}

func NewShowTableIdContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTableIdContext {
	var p = new(ShowTableIdContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTableIdContext) GetTableId() antlr.Token { return s.tableId }

func (s *ShowTableIdContext) SetTableId(v antlr.Token) { s.tableId = v }

func (s *ShowTableIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTableIdContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTableIdContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *ShowTableIdContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ShowTableIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTableId(s)
	}
}

func (s *ShowTableIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTableId(s)
	}
}

type ShowSmallFilesContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowSmallFilesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSmallFilesContext {
	var p = new(ShowSmallFilesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowSmallFilesContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowSmallFilesContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowSmallFilesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSmallFilesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowSmallFilesContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisParserFILE, 0)
}

func (s *ShowSmallFilesContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowSmallFilesContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowSmallFilesContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowSmallFilesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowSmallFiles(s)
	}
}

func (s *ShowSmallFilesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowSmallFiles(s)
	}
}

type ShowDatabasesContext struct {
	SupportedShowStatementContext
	catalog IIdentifierContext
}

func NewShowDatabasesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDatabasesContext {
	var p = new(ShowDatabasesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowDatabasesContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *ShowDatabasesContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *ShowDatabasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDatabasesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowDatabasesContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASES, 0)
}

func (s *ShowDatabasesContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEMAS, 0)
}

func (s *ShowDatabasesContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowDatabasesContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowDatabasesContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowDatabasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowDatabases(s)
	}
}

func (s *ShowDatabasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowDatabases(s)
	}
}

type ShowTabletIdContext struct {
	SupportedShowStatementContext
	tabletId antlr.Token
}

func NewShowTabletIdContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTabletIdContext {
	var p = new(ShowTabletIdContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTabletIdContext) GetTabletId() antlr.Token { return s.tabletId }

func (s *ShowTabletIdContext) SetTabletId(v antlr.Token) { s.tabletId = v }

func (s *ShowTabletIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTabletIdContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTabletIdContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLET, 0)
}

func (s *ShowTabletIdContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ShowTabletIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTabletId(s)
	}
}

func (s *ShowTabletIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTabletId(s)
	}
}

type ShowStorageVaultContext struct {
	SupportedShowStatementContext
}

func NewShowStorageVaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStorageVaultContext {
	var p = new(ShowStorageVaultContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowStorageVaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStorageVaultContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowStorageVaultContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *ShowStorageVaultContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULT, 0)
}

func (s *ShowStorageVaultContext) VAULTS() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULTS, 0)
}

func (s *ShowStorageVaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowStorageVault(s)
	}
}

func (s *ShowStorageVaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowStorageVault(s)
	}
}

type ShowStatusContext struct {
	SupportedShowStatementContext
}

func NewShowStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStatusContext {
	var p = new(ShowStatusContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatusContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATUS, 0)
}

func (s *ShowStatusContext) StatementScope() IStatementScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementScopeContext)
}

func (s *ShowStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowStatus(s)
	}
}

func (s *ShowStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowStatus(s)
	}
}

type ShowUserPropertiesContext struct {
	SupportedShowStatementContext
	user IIdentifierOrTextContext
}

func NewShowUserPropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowUserPropertiesContext {
	var p = new(ShowUserPropertiesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowUserPropertiesContext) GetUser() IIdentifierOrTextContext { return s.user }

func (s *ShowUserPropertiesContext) SetUser(v IIdentifierOrTextContext) { s.user = v }

func (s *ShowUserPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowUserPropertiesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowUserPropertiesContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTY, 0)
}

func (s *ShowUserPropertiesContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *ShowUserPropertiesContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *ShowUserPropertiesContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowUserPropertiesContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *ShowUserPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowUserProperties(s)
	}
}

func (s *ShowUserPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowUserProperties(s)
	}
}

type ShowWarmUpJobContext struct {
	SupportedShowStatementContext
}

func NewShowWarmUpJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowWarmUpJobContext {
	var p = new(ShowWarmUpJobContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowWarmUpJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWarmUpJobContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowWarmUpJobContext) WARM() antlr.TerminalNode {
	return s.GetToken(DorisParserWARM, 0)
}

func (s *ShowWarmUpJobContext) UP() antlr.TerminalNode {
	return s.GetToken(DorisParserUP, 0)
}

func (s *ShowWarmUpJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *ShowWarmUpJobContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowWarmUpJobContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowWarmUpJob(s)
	}
}

func (s *ShowWarmUpJobContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowWarmUpJob(s)
	}
}

type ShowLastInsertContext struct {
	SupportedShowStatementContext
}

func NewShowLastInsertContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowLastInsertContext {
	var p = new(ShowLastInsertContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowLastInsertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowLastInsertContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowLastInsertContext) LAST() antlr.TerminalNode {
	return s.GetToken(DorisParserLAST, 0)
}

func (s *ShowLastInsertContext) INSERT() antlr.TerminalNode {
	return s.GetToken(DorisParserINSERT, 0)
}

func (s *ShowLastInsertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowLastInsert(s)
	}
}

func (s *ShowLastInsertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowLastInsert(s)
	}
}

type ShowCreateCatalogContext struct {
	SupportedShowStatementContext
	name IIdentifierContext
}

func NewShowCreateCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateCatalogContext {
	var p = new(ShowCreateCatalogContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCreateCatalogContext) GetName() IIdentifierContext { return s.name }

func (s *ShowCreateCatalogContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ShowCreateCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateCatalogContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCreateCatalogContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowCreateCatalogContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *ShowCreateCatalogContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateCatalogContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCreateCatalog(s)
	}
}

func (s *ShowCreateCatalogContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCreateCatalog(s)
	}
}

type ShowCreateMaterializedViewContext struct {
	SupportedShowStatementContext
	mvName    IIdentifierContext
	tableName IMultipartIdentifierContext
}

func NewShowCreateMaterializedViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateMaterializedViewContext {
	var p = new(ShowCreateMaterializedViewContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCreateMaterializedViewContext) GetMvName() IIdentifierContext { return s.mvName }

func (s *ShowCreateMaterializedViewContext) GetTableName() IMultipartIdentifierContext {
	return s.tableName
}

func (s *ShowCreateMaterializedViewContext) SetMvName(v IIdentifierContext) { s.mvName = v }

func (s *ShowCreateMaterializedViewContext) SetTableName(v IMultipartIdentifierContext) {
	s.tableName = v
}

func (s *ShowCreateMaterializedViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateMaterializedViewContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCreateMaterializedViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowCreateMaterializedViewContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *ShowCreateMaterializedViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *ShowCreateMaterializedViewContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *ShowCreateMaterializedViewContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateMaterializedViewContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateMaterializedViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCreateMaterializedView(s)
	}
}

func (s *ShowCreateMaterializedViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCreateMaterializedView(s)
	}
}

type ShowProcessListContext struct {
	SupportedShowStatementContext
}

func NewShowProcessListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowProcessListContext {
	var p = new(ShowProcessListContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowProcessListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProcessListContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowProcessListContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(DorisParserPROCESSLIST, 0)
}

func (s *ShowProcessListContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserFULL, 0)
}

func (s *ShowProcessListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowProcessList(s)
	}
}

func (s *ShowProcessListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowProcessList(s)
	}
}

type ShowDataTypesContext struct {
	SupportedShowStatementContext
}

func NewShowDataTypesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDataTypesContext {
	var p = new(ShowDataTypesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowDataTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDataTypesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowDataTypesContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserDATA, 0)
}

func (s *ShowDataTypesContext) TYPES() antlr.TerminalNode {
	return s.GetToken(DorisParserTYPES, 0)
}

func (s *ShowDataTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowDataTypes(s)
	}
}

func (s *ShowDataTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowDataTypes(s)
	}
}

type ShowDiagnoseTabletContext struct {
	SupportedShowStatementContext
	tabletId antlr.Token
}

func NewShowDiagnoseTabletContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDiagnoseTabletContext {
	var p = new(ShowDiagnoseTabletContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowDiagnoseTabletContext) GetTabletId() antlr.Token { return s.tabletId }

func (s *ShowDiagnoseTabletContext) SetTabletId(v antlr.Token) { s.tabletId = v }

func (s *ShowDiagnoseTabletContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDiagnoseTabletContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowDiagnoseTabletContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLET, 0)
}

func (s *ShowDiagnoseTabletContext) DIAGNOSIS() antlr.TerminalNode {
	return s.GetToken(DorisParserDIAGNOSIS, 0)
}

func (s *ShowDiagnoseTabletContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ShowDiagnoseTabletContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowDiagnoseTablet(s)
	}
}

func (s *ShowDiagnoseTabletContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowDiagnoseTablet(s)
	}
}

type ShowWhitelistContext struct {
	SupportedShowStatementContext
}

func NewShowWhitelistContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowWhitelistContext {
	var p = new(ShowWhitelistContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowWhitelistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWhitelistContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowWhitelistContext) WHITELIST() antlr.TerminalNode {
	return s.GetToken(DorisParserWHITELIST, 0)
}

func (s *ShowWhitelistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowWhitelist(s)
	}
}

func (s *ShowWhitelistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowWhitelist(s)
	}
}

type ShowViewsContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowViewsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowViewsContext {
	var p = new(ShowViewsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowViewsContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowViewsContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowViewsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowViewsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowViewsContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEWS, 0)
}

func (s *ShowViewsContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserFULL, 0)
}

func (s *ShowViewsContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowViewsContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowViewsContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowViewsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowViewsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowViews(s)
	}
}

func (s *ShowViewsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowViews(s)
	}
}

type ShowFunctionsContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowFunctionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowFunctionsContext {
	var p = new(ShowFunctionsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowFunctionsContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowFunctionsContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowFunctionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFunctionsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowFunctionsContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserFUNCTIONS, 0)
}

func (s *ShowFunctionsContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserFULL, 0)
}

func (s *ShowFunctionsContext) BUILTIN() antlr.TerminalNode {
	return s.GetToken(DorisParserBUILTIN, 0)
}

func (s *ShowFunctionsContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *ShowFunctionsContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowFunctionsContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowFunctionsContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowFunctionsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowFunctionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowFunctions(s)
	}
}

func (s *ShowFunctionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowFunctions(s)
	}
}

type ShowDatabaseIdContext struct {
	SupportedShowStatementContext
	databaseId antlr.Token
}

func NewShowDatabaseIdContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDatabaseIdContext {
	var p = new(ShowDatabaseIdContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowDatabaseIdContext) GetDatabaseId() antlr.Token { return s.databaseId }

func (s *ShowDatabaseIdContext) SetDatabaseId(v antlr.Token) { s.databaseId = v }

func (s *ShowDatabaseIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDatabaseIdContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowDatabaseIdContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *ShowDatabaseIdContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ShowDatabaseIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowDatabaseId(s)
	}
}

func (s *ShowDatabaseIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowDatabaseId(s)
	}
}

type ShowCreateRepositoryContext struct {
	SupportedShowStatementContext
}

func NewShowCreateRepositoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateRepositoryContext {
	var p = new(ShowCreateRepositoryContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCreateRepositoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateRepositoryContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCreateRepositoryContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowCreateRepositoryContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisParserREPOSITORY, 0)
}

func (s *ShowCreateRepositoryContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *ShowCreateRepositoryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateRepositoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCreateRepository(s)
	}
}

func (s *ShowCreateRepositoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCreateRepository(s)
	}
}

func (p *DorisParser) SupportedShowStatement() (localctx ISupportedShowStatementContext) {
	localctx = NewSupportedShowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, DorisParserRULE_supportedShowStatement)
	var _la int

	p.SetState(2606)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 345, p.GetParserRuleContext()) {
	case 1:
		localctx = NewShowVariablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1912)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1914)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION {
			{
				p.SetState(1913)
				p.StatementScope()
			}

		}
		{
			p.SetState(1916)
			p.Match(DorisParserVARIABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1918)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(1917)
				p.WildWhere()
			}

		}

	case 2:
		localctx = NewShowAuthorsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1920)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1921)
			p.Match(DorisParserAUTHORS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewShowAlterTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1922)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1923)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1924)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1929)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserROLLUP:
			{
				p.SetState(1925)
				p.Match(DorisParserROLLUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserMATERIALIZED:
			{
				p.SetState(1926)
				p.Match(DorisParserMATERIALIZED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1927)
				p.Match(DorisParserVIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCOLUMN:
			{
				p.SetState(1928)
				p.Match(DorisParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(1933)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1931)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1932)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowAlterTableContext).database = _x
			}

		}
		p.SetState(1936)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(1935)
				p.WildWhere()
			}

		}
		p.SetState(1939)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserORDER {
			{
				p.SetState(1938)
				p.SortClause()
			}

		}
		p.SetState(1942)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIMIT {
			{
				p.SetState(1941)
				p.LimitClause()
			}

		}

	case 4:
		localctx = NewShowCreateDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1944)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1945)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1946)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserDATABASE || _la == DorisParserSCHEMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1947)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateDatabaseContext).name = _x
		}

	case 5:
		localctx = NewShowBackupContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1948)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1949)
			p.Match(DorisParserBACKUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1952)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1950)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1951)

				var _x = p.Identifier()

				localctx.(*ShowBackupContext).database = _x
			}

		}
		p.SetState(1955)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(1954)
				p.WildWhere()
			}

		}

	case 6:
		localctx = NewShowBrokerContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1957)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1958)
			p.Match(DorisParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewShowBuildIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1959)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1960)
			p.Match(DorisParserBUILD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1961)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1964)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1962)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1963)

				var _x = p.Identifier()

				localctx.(*ShowBuildIndexContext).database = _x
			}

		}
		p.SetState(1967)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(1966)
				p.WildWhere()
			}

		}
		p.SetState(1970)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserORDER {
			{
				p.SetState(1969)
				p.SortClause()
			}

		}
		p.SetState(1973)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIMIT {
			{
				p.SetState(1972)
				p.LimitClause()
			}

		}

	case 8:
		localctx = NewShowDynamicPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1975)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1976)
			p.Match(DorisParserDYNAMIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1977)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1978)
			p.Match(DorisParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1981)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1979)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1980)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowDynamicPartitionContext).database = _x
			}

		}

	case 9:
		localctx = NewShowEventsContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1983)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1984)
			p.Match(DorisParserEVENTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1987)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1985)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1986)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowEventsContext).database = _x
			}

		}
		p.SetState(1990)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(1989)
				p.WildWhere()
			}

		}

	case 10:
		localctx = NewShowExportContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1992)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1993)
			p.Match(DorisParserEXPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1996)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(1994)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1995)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowExportContext).database = _x
			}

		}
		p.SetState(1999)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(1998)
				p.WildWhere()
			}

		}
		p.SetState(2002)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserORDER {
			{
				p.SetState(2001)
				p.SortClause()
			}

		}
		p.SetState(2005)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIMIT {
			{
				p.SetState(2004)
				p.LimitClause()
			}

		}

	case 11:
		localctx = NewShowLastInsertContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2007)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2008)
			p.Match(DorisParserLAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2009)
			p.Match(DorisParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewShowCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2010)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2014)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserCHAR:
			{
				p.SetState(2011)
				p.Match(DorisParserCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2012)
				p.Match(DorisParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCHARSET:
			{
				p.SetState(2013)
				p.Match(DorisParserCHARSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 13:
		localctx = NewShowDeleteContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2016)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2017)
			p.Match(DorisParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2020)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2018)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2019)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowDeleteContext).database = _x
			}

		}

	case 14:
		localctx = NewShowCreateFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2022)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2023)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2025)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION {
			{
				p.SetState(2024)
				p.StatementScope()
			}

		}
		{
			p.SetState(2027)
			p.Match(DorisParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2028)
			p.FunctionIdentifier()
		}
		{
			p.SetState(2029)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2031)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&9152335059222592) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&32633505112391681) != 0) || _la == DorisParserDOUBLE || _la == DorisParserFLOAT || ((int64((_la-213)) & ^0x3f) == 0 && ((int64(1)<<(_la-213))&9208814108673) != 0) || _la == DorisParserMAP || _la == DorisParserQUANTILE_STATE || ((int64((_la-426)) & ^0x3f) == 0 && ((int64(1)<<(_la-426))&704375029761) != 0) || _la == DorisParserVARCHAR || _la == DorisParserVARIANT {
			{
				p.SetState(2030)
				p.FunctionArguments()
			}

		}
		{
			p.SetState(2033)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2036)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2034)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2035)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowCreateFunctionContext).database = _x
			}

		}

	case 15:
		localctx = NewShowFunctionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(2038)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2040)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFULL {
			{
				p.SetState(2039)
				p.Match(DorisParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2043)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserBUILTIN {
			{
				p.SetState(2042)
				p.Match(DorisParserBUILTIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2045)
			p.Match(DorisParserFUNCTIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2048)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2046)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2047)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowFunctionsContext).database = _x
			}

		}
		p.SetState(2052)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE {
			{
				p.SetState(2050)
				p.Match(DorisParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2051)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 16:
		localctx = NewShowGlobalFunctionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(2054)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2055)
			p.Match(DorisParserGLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2057)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFULL {
			{
				p.SetState(2056)
				p.Match(DorisParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2059)
			p.Match(DorisParserFUNCTIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2062)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE {
			{
				p.SetState(2060)
				p.Match(DorisParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2061)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 17:
		localctx = NewShowGrantsContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(2064)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2066)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserALL {
			{
				p.SetState(2065)
				p.Match(DorisParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2068)
			p.Match(DorisParserGRANTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		localctx = NewShowGrantsForUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(2069)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2070)
			p.Match(DorisParserGRANTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2071)
			p.Match(DorisParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2072)
			p.UserIdentify()
		}

	case 19:
		localctx = NewShowSnapshotContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(2073)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2074)
			p.Match(DorisParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2075)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2076)

			var _x = p.Identifier()

			localctx.(*ShowSnapshotContext).repo = _x
		}
		p.SetState(2078)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2077)
				p.WildWhere()
			}

		}

	case 20:
		localctx = NewShowLoadProfileContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(2080)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2081)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2082)
			p.Match(DorisParserPROFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2084)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserSTRING_LITERAL {
			{
				p.SetState(2083)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*ShowLoadProfileContext).loadIdPath = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2087)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIMIT {
			{
				p.SetState(2086)
				p.LimitClause()
			}

		}

	case 21:
		localctx = NewShowCreateRepositoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(2089)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2090)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2091)
			p.Match(DorisParserREPOSITORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2092)
			p.Match(DorisParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2093)
			p.Identifier()
		}

	case 22:
		localctx = NewShowViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(2094)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2095)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2096)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserFROM || _la == DorisParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2097)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowViewContext).tableName = _x
		}
		p.SetState(2100)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2098)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2099)

				var _x = p.Identifier()

				localctx.(*ShowViewContext).database = _x
			}

		}

	case 23:
		localctx = NewShowPluginsContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(2102)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2103)
			p.Match(DorisParserPLUGINS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		localctx = NewShowStorageVaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(2104)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2105)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2106)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserVAULT || _la == DorisParserVAULTS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 25:
		localctx = NewShowRepositoriesContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(2107)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2108)
			p.Match(DorisParserREPOSITORIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 26:
		localctx = NewShowEncryptKeysContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(2109)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2110)
			p.Match(DorisParserENCRYPTKEYS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2113)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2111)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2112)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowEncryptKeysContext).database = _x
			}

		}
		p.SetState(2117)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE {
			{
				p.SetState(2115)
				p.Match(DorisParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2116)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 27:
		localctx = NewShowCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(2119)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2121)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserBRIEF {
			{
				p.SetState(2120)
				p.Match(DorisParserBRIEF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2123)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2124)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2125)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateTableContext).name = _x
		}

	case 28:
		localctx = NewShowProcessListContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(2126)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2128)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFULL {
			{
				p.SetState(2127)
				p.Match(DorisParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2130)
			p.Match(DorisParserPROCESSLIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 29:
		localctx = NewShowPartitionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(2131)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2133)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(2132)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2135)
			p.Match(DorisParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2136)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2137)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowPartitionsContext).tableName = _x
		}
		p.SetState(2139)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2138)
				p.WildWhere()
			}

		}
		p.SetState(2142)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserORDER {
			{
				p.SetState(2141)
				p.SortClause()
			}

		}
		p.SetState(2145)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIMIT {
			{
				p.SetState(2144)
				p.LimitClause()
			}

		}

	case 30:
		localctx = NewShowRestoreContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(2147)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2149)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserBRIEF {
			{
				p.SetState(2148)
				p.Match(DorisParserBRIEF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2151)
			p.Match(DorisParserRESTORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2154)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2152)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2153)

				var _x = p.Identifier()

				localctx.(*ShowRestoreContext).database = _x
			}

		}
		p.SetState(2157)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2156)
				p.WildWhere()
			}

		}

	case 31:
		localctx = NewShowRolesContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(2159)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2160)
			p.Match(DorisParserROLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 32:
		localctx = NewShowPartitionIdContext(p, localctx)
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(2161)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2162)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2163)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*ShowPartitionIdContext).partitionId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 33:
		localctx = NewShowPrivilegesContext(p, localctx)
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(2164)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2165)
			p.Match(DorisParserPRIVILEGES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 34:
		localctx = NewShowProcContext(p, localctx)
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(2166)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2167)
			p.Match(DorisParserPROC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2168)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ShowProcContext).path = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 35:
		localctx = NewShowSmallFilesContext(p, localctx)
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(2169)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2170)
			p.Match(DorisParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2173)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2171)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2172)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowSmallFilesContext).database = _x
			}

		}

	case 36:
		localctx = NewShowStorageEnginesContext(p, localctx)
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(2175)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2177)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserSTORAGE {
			{
				p.SetState(2176)
				p.Match(DorisParserSTORAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2179)
			p.Match(DorisParserENGINES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 37:
		localctx = NewShowCreateCatalogContext(p, localctx)
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(2180)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2181)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2182)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2183)

			var _x = p.Identifier()

			localctx.(*ShowCreateCatalogContext).name = _x
		}

	case 38:
		localctx = NewShowCatalogContext(p, localctx)
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(2184)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2185)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2186)

			var _x = p.Identifier()

			localctx.(*ShowCatalogContext).name = _x
		}

	case 39:
		localctx = NewShowCatalogsContext(p, localctx)
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(2187)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2188)
			p.Match(DorisParserCATALOGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2190)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2189)
				p.WildWhere()
			}

		}

	case 40:
		localctx = NewShowUserPropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(2192)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2193)
			p.Match(DorisParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2196)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFOR {
			{
				p.SetState(2194)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2195)

				var _x = p.IdentifierOrText()

				localctx.(*ShowUserPropertiesContext).user = _x
			}

		}
		p.SetState(2200)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE {
			{
				p.SetState(2198)
				p.Match(DorisParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2199)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 41:
		localctx = NewShowAllPropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(2202)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2203)
			p.Match(DorisParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2204)
			p.Match(DorisParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2207)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE {
			{
				p.SetState(2205)
				p.Match(DorisParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2206)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 42:
		localctx = NewShowCollationContext(p, localctx)
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(2209)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2210)
			p.Match(DorisParserCOLLATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2212)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2211)
				p.WildWhere()
			}

		}

	case 43:
		localctx = NewShowRowPolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(2214)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2215)
			p.Match(DorisParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2216)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2223)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFOR {
			{
				p.SetState(2217)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2221)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
				{
					p.SetState(2218)
					p.UserIdentify()
				}

			case DorisParserROLE:
				{
					p.SetState(2219)
					p.Match(DorisParserROLE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2220)

					var _x = p.Identifier()

					localctx.(*ShowRowPolicyContext).role = _x
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}

	case 44:
		localctx = NewShowStoragePolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(2225)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2226)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2227)
			p.Match(DorisParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2233)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserUSING {
			{
				p.SetState(2228)
				p.Match(DorisParserUSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2231)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserFOR {
				{
					p.SetState(2229)
					p.Match(DorisParserFOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2230)

					var _x = p.IdentifierOrText()

					localctx.(*ShowStoragePolicyContext).policy = _x
				}

			}

		}

	case 45:
		localctx = NewShowSqlBlockRuleContext(p, localctx)
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(2235)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2236)
			p.Match(DorisParserSQL_BLOCK_RULE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2239)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFOR {
			{
				p.SetState(2237)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2238)

				var _x = p.Identifier()

				localctx.(*ShowSqlBlockRuleContext).ruleName = _x
			}

		}

	case 46:
		localctx = NewShowCreateViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(2241)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2242)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2243)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2244)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateViewContext).name = _x
		}

	case 47:
		localctx = NewShowDataTypesContext(p, localctx)
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(2245)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2246)
			p.Match(DorisParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2247)
			p.Match(DorisParserTYPES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 48:
		localctx = NewShowDataContext(p, localctx)
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(2248)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2249)
			p.Match(DorisParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2251)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserALL {
			{
				p.SetState(2250)
				p.Match(DorisParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2255)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(2253)
				p.Match(DorisParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2254)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowDataContext).tableName = _x
			}

		}
		p.SetState(2258)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserORDER {
			{
				p.SetState(2257)
				p.SortClause()
			}

		}
		p.SetState(2261)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2260)
				p.PropertyClause()
			}

		}

	case 49:
		localctx = NewShowCreateMaterializedViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(2263)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2264)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2265)
			p.Match(DorisParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2266)
			p.Match(DorisParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2267)

			var _x = p.Identifier()

			localctx.(*ShowCreateMaterializedViewContext).mvName = _x
		}
		{
			p.SetState(2268)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2269)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateMaterializedViewContext).tableName = _x
		}

	case 50:
		localctx = NewShowWarningErrorsContext(p, localctx)
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(2271)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2272)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserERRORS || _la == DorisParserWARNINGS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2274)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIMIT {
			{
				p.SetState(2273)
				p.LimitClause()
			}

		}

	case 51:
		localctx = NewShowWarningErrorCountContext(p, localctx)
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(2276)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2277)
			p.Match(DorisParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2278)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2279)
			p.Match(DorisParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2280)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2281)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserERRORS || _la == DorisParserWARNINGS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 52:
		localctx = NewShowBackendsContext(p, localctx)
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(2282)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2283)
			p.Match(DorisParserBACKENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 53:
		localctx = NewShowStagesContext(p, localctx)
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(2284)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2285)
			p.Match(DorisParserSTAGES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 54:
		localctx = NewShowReplicaDistributionContext(p, localctx)
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(2286)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2287)
			p.Match(DorisParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2288)
			p.Match(DorisParserDISTRIBUTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2289)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2290)
			p.BaseTableRef()
		}

	case 55:
		localctx = NewShowResourcesContext(p, localctx)
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(2291)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2292)
			p.Match(DorisParserRESOURCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2294)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2293)
				p.WildWhere()
			}

		}
		p.SetState(2297)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserORDER {
			{
				p.SetState(2296)
				p.SortClause()
			}

		}
		p.SetState(2300)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIMIT {
			{
				p.SetState(2299)
				p.LimitClause()
			}

		}

	case 56:
		localctx = NewShowLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(2302)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2304)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserSTREAM {
			{
				p.SetState(2303)
				p.Match(DorisParserSTREAM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2306)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2309)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2307)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2308)

				var _x = p.Identifier()

				localctx.(*ShowLoadContext).database = _x
			}

		}
		p.SetState(2312)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2311)
				p.WildWhere()
			}

		}
		p.SetState(2315)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserORDER {
			{
				p.SetState(2314)
				p.SortClause()
			}

		}
		p.SetState(2318)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIMIT {
			{
				p.SetState(2317)
				p.LimitClause()
			}

		}

	case 57:
		localctx = NewShowLoadWaringsContext(p, localctx)
		p.EnterOuterAlt(localctx, 57)
		{
			p.SetState(2320)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2321)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2322)
			p.Match(DorisParserWARNINGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2335)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserEOF, DorisParserSEMICOLON, DorisParserFROM, DorisParserIN, DorisParserLIKE, DorisParserLIMIT, DorisParserWHERE:
			p.SetState(2325)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserFROM || _la == DorisParserIN {
				{
					p.SetState(2323)
					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisParserFROM || _la == DorisParserIN) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(2324)

					var _x = p.Identifier()

					localctx.(*ShowLoadWaringsContext).database = _x
				}

			}
			p.SetState(2328)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserLIKE || _la == DorisParserWHERE {
				{
					p.SetState(2327)
					p.WildWhere()
				}

			}
			p.SetState(2331)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserLIMIT {
				{
					p.SetState(2330)
					p.LimitClause()
				}

			}

		case DorisParserON:
			{
				p.SetState(2333)
				p.Match(DorisParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2334)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*ShowLoadWaringsContext).url = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 58:
		localctx = NewShowTriggersContext(p, localctx)
		p.EnterOuterAlt(localctx, 58)
		{
			p.SetState(2337)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2339)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFULL {
			{
				p.SetState(2338)
				p.Match(DorisParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2341)
			p.Match(DorisParserTRIGGERS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2344)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2342)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2343)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowTriggersContext).database = _x
			}

		}
		p.SetState(2347)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2346)
				p.WildWhere()
			}

		}

	case 59:
		localctx = NewShowDiagnoseTabletContext(p, localctx)
		p.EnterOuterAlt(localctx, 59)
		{
			p.SetState(2349)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2350)
			p.Match(DorisParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2351)
			p.Match(DorisParserDIAGNOSIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2352)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*ShowDiagnoseTabletContext).tabletId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 60:
		localctx = NewShowOpenTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 60)
		{
			p.SetState(2353)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2354)
			p.Match(DorisParserOPEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2355)
			p.Match(DorisParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2358)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2356)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2357)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowOpenTablesContext).database = _x
			}

		}
		p.SetState(2361)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2360)
				p.WildWhere()
			}

		}

	case 61:
		localctx = NewShowFrontendsContext(p, localctx)
		p.EnterOuterAlt(localctx, 61)
		{
			p.SetState(2363)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2364)
			p.Match(DorisParserFRONTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2366)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305902462020672000) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4609989332399152113) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4540397275156637211) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&2557745532860070517) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&8545544968972265069) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-305714810442809349) != 0) || ((int64((_la-391)) & ^0x3f) == 0 && ((int64(1)<<(_la-391))&1188948054525294943) != 0) || ((int64((_la-455)) & ^0x3f) == 0 && ((int64(1)<<(_la-455))&2458964612221191023) != 0) || ((int64((_la-538)) & ^0x3f) == 0 && ((int64(1)<<(_la-538))&49159) != 0) {
			{
				p.SetState(2365)

				var _x = p.Identifier()

				localctx.(*ShowFrontendsContext).name = _x
			}

		}

	case 62:
		localctx = NewShowDatabaseIdContext(p, localctx)
		p.EnterOuterAlt(localctx, 62)
		{
			p.SetState(2368)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2369)
			p.Match(DorisParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2370)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*ShowDatabaseIdContext).databaseId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 63:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 63)
		{
			p.SetState(2371)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2373)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFULL {
			{
				p.SetState(2372)
				p.Match(DorisParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2375)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserCOLUMNS || _la == DorisParserFIELDS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2376)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserFROM || _la == DorisParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2377)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowColumnsContext).tableName = _x
		}
		p.SetState(2380)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2378)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2379)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowColumnsContext).database = _x
			}

		}
		p.SetState(2383)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2382)
				p.WildWhere()
			}

		}

	case 64:
		localctx = NewShowTableIdContext(p, localctx)
		p.EnterOuterAlt(localctx, 64)
		{
			p.SetState(2385)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2386)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2387)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*ShowTableIdContext).tableId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 65:
		localctx = NewShowTrashContext(p, localctx)
		p.EnterOuterAlt(localctx, 65)
		{
			p.SetState(2388)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2389)
			p.Match(DorisParserTRASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2392)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserON {
			{
				p.SetState(2390)
				p.Match(DorisParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2391)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*ShowTrashContext).backend = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 66:
		localctx = NewShowTypeCastContext(p, localctx)
		p.EnterOuterAlt(localctx, 66)
		{
			p.SetState(2394)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2395)
			p.Match(DorisParserTYPECAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2398)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2396)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2397)

				var _x = p.Identifier()

				localctx.(*ShowTypeCastContext).database = _x
			}

		}

	case 67:
		localctx = NewShowClustersContext(p, localctx)
		p.EnterOuterAlt(localctx, 67)
		{
			p.SetState(2400)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2404)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserCLUSTERS:
			{
				p.SetState(2401)
				p.Match(DorisParserCLUSTERS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCOMPUTE:
			{
				p.SetState(2402)
				p.Match(DorisParserCOMPUTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2403)
				p.Match(DorisParserGROUPS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 68:
		localctx = NewShowStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 68)
		{
			p.SetState(2406)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2408)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION {
			{
				p.SetState(2407)
				p.StatementScope()
			}

		}
		{
			p.SetState(2410)
			p.Match(DorisParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 69:
		localctx = NewShowWhitelistContext(p, localctx)
		p.EnterOuterAlt(localctx, 69)
		{
			p.SetState(2411)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2412)
			p.Match(DorisParserWHITELIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 70:
		localctx = NewShowTabletsBelongContext(p, localctx)
		p.EnterOuterAlt(localctx, 70)
		{
			p.SetState(2413)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2414)
			p.Match(DorisParserTABLETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2415)
			p.Match(DorisParserBELONG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2416)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*ShowTabletsBelongContext)._INTEGER_VALUE = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ShowTabletsBelongContext).tabletIds = append(localctx.(*ShowTabletsBelongContext).tabletIds, localctx.(*ShowTabletsBelongContext)._INTEGER_VALUE)
		p.SetState(2421)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(2417)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2418)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*ShowTabletsBelongContext)._INTEGER_VALUE = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*ShowTabletsBelongContext).tabletIds = append(localctx.(*ShowTabletsBelongContext).tabletIds, localctx.(*ShowTabletsBelongContext)._INTEGER_VALUE)

			p.SetState(2423)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 71:
		localctx = NewShowDataSkewContext(p, localctx)
		p.EnterOuterAlt(localctx, 71)
		{
			p.SetState(2424)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2425)
			p.Match(DorisParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2426)
			p.Match(DorisParserSKEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2427)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2428)
			p.BaseTableRef()
		}

	case 72:
		localctx = NewShowTableCreationContext(p, localctx)
		p.EnterOuterAlt(localctx, 72)
		{
			p.SetState(2429)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2430)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2431)
			p.Match(DorisParserCREATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2434)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2432)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2433)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowTableCreationContext).database = _x
			}

		}
		p.SetState(2438)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE {
			{
				p.SetState(2436)
				p.Match(DorisParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2437)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 73:
		localctx = NewShowTabletStorageFormatContext(p, localctx)
		p.EnterOuterAlt(localctx, 73)
		{
			p.SetState(2440)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2441)
			p.Match(DorisParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2442)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2443)
			p.Match(DorisParserFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2445)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserVERBOSE {
			{
				p.SetState(2444)
				p.Match(DorisParserVERBOSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 74:
		localctx = NewShowQueryProfileContext(p, localctx)
		p.EnterOuterAlt(localctx, 74)
		{
			p.SetState(2447)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2448)
			p.Match(DorisParserQUERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2449)
			p.Match(DorisParserPROFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2451)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserSTRING_LITERAL {
			{
				p.SetState(2450)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*ShowQueryProfileContext).queryIdPath = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2454)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIMIT {
			{
				p.SetState(2453)
				p.LimitClause()
			}

		}

	case 75:
		localctx = NewShowConvertLscContext(p, localctx)
		p.EnterOuterAlt(localctx, 75)
		{
			p.SetState(2456)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2457)
			p.Match(DorisParserCONVERT_LSC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2460)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2458)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2459)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowConvertLscContext).database = _x
			}

		}

	case 76:
		localctx = NewShowTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 76)
		{
			p.SetState(2462)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2464)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFULL {
			{
				p.SetState(2463)
				p.Match(DorisParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2466)
			p.Match(DorisParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2469)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2467)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2468)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowTablesContext).database = _x
			}

		}
		p.SetState(2472)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2471)
				p.WildWhere()
			}

		}

	case 77:
		localctx = NewShowViewsContext(p, localctx)
		p.EnterOuterAlt(localctx, 77)
		{
			p.SetState(2474)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2476)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFULL {
			{
				p.SetState(2475)
				p.Match(DorisParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2478)
			p.Match(DorisParserVIEWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2481)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2479)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2480)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowViewsContext).database = _x
			}

		}
		p.SetState(2484)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2483)
				p.WildWhere()
			}

		}

	case 78:
		localctx = NewShowTableStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 78)
		{
			p.SetState(2486)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2487)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2488)
			p.Match(DorisParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2491)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2489)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2490)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowTableStatusContext).database = _x
			}

		}
		p.SetState(2494)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2493)
				p.WildWhere()
			}

		}

	case 79:
		localctx = NewShowDatabasesContext(p, localctx)
		p.EnterOuterAlt(localctx, 79)
		{
			p.SetState(2496)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2497)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserDATABASES || _la == DorisParserSCHEMAS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2500)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(2498)
				p.Match(DorisParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2499)

				var _x = p.Identifier()

				localctx.(*ShowDatabasesContext).catalog = _x
			}

		}
		p.SetState(2503)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2502)
				p.WildWhere()
			}

		}

	case 80:
		localctx = NewShowTabletsFromTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 80)
		{
			p.SetState(2505)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2506)
			p.Match(DorisParserTABLETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2507)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2508)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowTabletsFromTableContext).tableName = _x
		}
		p.SetState(2510)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(2509)
				p.PartitionSpec()
			}

		}
		p.SetState(2513)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2512)
				p.WildWhere()
			}

		}
		p.SetState(2516)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserORDER {
			{
				p.SetState(2515)
				p.SortClause()
			}

		}
		p.SetState(2519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIMIT {
			{
				p.SetState(2518)
				p.LimitClause()
			}

		}

	case 81:
		localctx = NewShowCatalogRecycleBinContext(p, localctx)
		p.EnterOuterAlt(localctx, 81)
		{
			p.SetState(2521)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2522)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2523)
			p.Match(DorisParserRECYCLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2524)
			p.Match(DorisParserBIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2527)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWHERE {
			{
				p.SetState(2525)
				p.Match(DorisParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2526)
				p.Expression()
			}

		}

	case 82:
		localctx = NewShowTabletIdContext(p, localctx)
		p.EnterOuterAlt(localctx, 82)
		{
			p.SetState(2529)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2530)
			p.Match(DorisParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2531)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*ShowTabletIdContext).tabletId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 83:
		localctx = NewShowDictionariesContext(p, localctx)
		p.EnterOuterAlt(localctx, 83)
		{
			p.SetState(2532)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2533)
			p.Match(DorisParserDICTIONARIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2535)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2534)
				p.WildWhere()
			}

		}

	case 84:
		localctx = NewShowTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 84)
		{
			p.SetState(2537)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2538)
			p.Match(DorisParserTRANSACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2541)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2539)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2540)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowTransactionContext).database = _x
			}

		}
		p.SetState(2544)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2543)
				p.WildWhere()
			}

		}

	case 85:
		localctx = NewShowReplicaStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 85)
		{
			p.SetState(2546)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2547)
			p.Match(DorisParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2548)
			p.Match(DorisParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2549)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2550)
			p.BaseTableRef()
		}
		p.SetState(2552)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWHERE {
			{
				p.SetState(2551)
				p.WhereClause()
			}

		}

	case 86:
		localctx = NewShowWorkloadGroupsContext(p, localctx)
		p.EnterOuterAlt(localctx, 86)
		{
			p.SetState(2554)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2555)
			p.Match(DorisParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2556)
			p.Match(DorisParserGROUPS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2559)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE {
			{
				p.SetState(2557)
				p.Match(DorisParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2558)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 87:
		localctx = NewShowCopyContext(p, localctx)
		p.EnterOuterAlt(localctx, 87)
		{
			p.SetState(2561)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2562)
			p.Match(DorisParserCOPY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2565)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2563)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2564)

				var _x = p.Identifier()

				localctx.(*ShowCopyContext).database = _x
			}

		}
		p.SetState(2568)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWHERE {
			{
				p.SetState(2567)
				p.WhereClause()
			}

		}
		p.SetState(2571)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserORDER {
			{
				p.SetState(2570)
				p.SortClause()
			}

		}
		p.SetState(2574)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIMIT {
			{
				p.SetState(2573)
				p.LimitClause()
			}

		}

	case 88:
		localctx = NewShowQueryStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 88)
		{
			p.SetState(2576)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2577)
			p.Match(DorisParserQUERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2578)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2589)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case DorisParserFOR:
			{
				p.SetState(2579)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2580)

				var _x = p.Identifier()

				localctx.(*ShowQueryStatsContext).database = _x
			}

		case DorisParserFROM:
			{
				p.SetState(2581)
				p.Match(DorisParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2582)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowQueryStatsContext).tableName = _x
			}
			p.SetState(2587)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserALL {
				{
					p.SetState(2583)
					p.Match(DorisParserALL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(2585)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisParserVERBOSE {
					{
						p.SetState(2584)
						p.Match(DorisParserVERBOSE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}

			}

		case DorisParserEOF, DorisParserSEMICOLON:

		default:
		}

	case 89:
		localctx = NewShowIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 89)
		{
			p.SetState(2591)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2592)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-226)) & ^0x3f) == 0 && ((int64(1)<<(_la-226))&201326595) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2593)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserFROM || _la == DorisParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2594)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowIndexContext).tableName = _x
		}
		p.SetState(2597)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2595)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2596)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowIndexContext).database = _x
			}

		}

	case 90:
		localctx = NewShowWarmUpJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 90)
		{
			p.SetState(2599)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2600)
			p.Match(DorisParserWARM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2601)
			p.Match(DorisParserUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2602)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2604)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2603)
				p.WildWhere()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedLoadStatementContext is an interface to support dynamic dispatch.
type ISupportedLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedLoadStatementContext differentiates from other interfaces.
	IsSupportedLoadStatementContext()
}

type SupportedLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedLoadStatementContext() *SupportedLoadStatementContext {
	var p = new(SupportedLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedLoadStatement
	return p
}

func InitEmptySupportedLoadStatementContext(p *SupportedLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedLoadStatement
}

func (*SupportedLoadStatementContext) IsSupportedLoadStatementContext() {}

func NewSupportedLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedLoadStatementContext {
	var p = new(SupportedLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedLoadStatement

	return p
}

func (s *SupportedLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedLoadStatementContext) CopyAll(ctx *SupportedLoadStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowRoutineLoadContext struct {
	SupportedLoadStatementContext
	label IMultipartIdentifierContext
}

func NewShowRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRoutineLoadContext {
	var p = new(ShowRoutineLoadContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *ShowRoutineLoadContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *ShowRoutineLoadContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *ShowRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRoutineLoadContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserROUTINE, 0)
}

func (s *ShowRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *ShowRoutineLoadContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *ShowRoutineLoadContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *ShowRoutineLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowRoutineLoadContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *ShowRoutineLoadContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowRoutineLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowRoutineLoad(s)
	}
}

func (s *ShowRoutineLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowRoutineLoad(s)
	}
}

type ResumeRoutineLoadContext struct {
	SupportedLoadStatementContext
	label IMultipartIdentifierContext
}

func NewResumeRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ResumeRoutineLoadContext {
	var p = new(ResumeRoutineLoadContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *ResumeRoutineLoadContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *ResumeRoutineLoadContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *ResumeRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumeRoutineLoadContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisParserRESUME, 0)
}

func (s *ResumeRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserROUTINE, 0)
}

func (s *ResumeRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *ResumeRoutineLoadContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *ResumeRoutineLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ResumeRoutineLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterResumeRoutineLoad(s)
	}
}

func (s *ResumeRoutineLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitResumeRoutineLoad(s)
	}
}

type CreateRoutineLoadAliasContext struct {
	SupportedLoadStatementContext
}

func NewCreateRoutineLoadAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateRoutineLoadAliasContext {
	var p = new(CreateRoutineLoadAliasContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *CreateRoutineLoadAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoutineLoadAliasContext) CreateRoutineLoad() ICreateRoutineLoadContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRoutineLoadContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRoutineLoadContext)
}

func (s *CreateRoutineLoadAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateRoutineLoadAlias(s)
	}
}

func (s *CreateRoutineLoadAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateRoutineLoadAlias(s)
	}
}

type ShowIndexTokenizerContext struct {
	SupportedLoadStatementContext
}

func NewShowIndexTokenizerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowIndexTokenizerContext {
	var p = new(ShowIndexTokenizerContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *ShowIndexTokenizerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowIndexTokenizerContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowIndexTokenizerContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserINVERTED, 0)
}

func (s *ShowIndexTokenizerContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *ShowIndexTokenizerContext) TOKENIZER() antlr.TerminalNode {
	return s.GetToken(DorisParserTOKENIZER, 0)
}

func (s *ShowIndexTokenizerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowIndexTokenizer(s)
	}
}

func (s *ShowIndexTokenizerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowIndexTokenizer(s)
	}
}

type PauseAllRoutineLoadContext struct {
	SupportedLoadStatementContext
}

func NewPauseAllRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PauseAllRoutineLoadContext {
	var p = new(PauseAllRoutineLoadContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *PauseAllRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PauseAllRoutineLoadContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserPAUSE, 0)
}

func (s *PauseAllRoutineLoadContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *PauseAllRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserROUTINE, 0)
}

func (s *PauseAllRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *PauseAllRoutineLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPauseAllRoutineLoad(s)
	}
}

func (s *PauseAllRoutineLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPauseAllRoutineLoad(s)
	}
}

type SyncContext struct {
	SupportedLoadStatementContext
}

func NewSyncContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SyncContext {
	var p = new(SyncContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *SyncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyncContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DorisParserSYNC, 0)
}

func (s *SyncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSync(s)
	}
}

func (s *SyncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSync(s)
	}
}

type ShowCreateRoutineLoadContext struct {
	SupportedLoadStatementContext
	label IMultipartIdentifierContext
}

func NewShowCreateRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateRoutineLoadContext {
	var p = new(ShowCreateRoutineLoadContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *ShowCreateRoutineLoadContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *ShowCreateRoutineLoadContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *ShowCreateRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateRoutineLoadContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCreateRoutineLoadContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowCreateRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserROUTINE, 0)
}

func (s *ShowCreateRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *ShowCreateRoutineLoadContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *ShowCreateRoutineLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateRoutineLoadContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *ShowCreateRoutineLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCreateRoutineLoad(s)
	}
}

func (s *ShowCreateRoutineLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCreateRoutineLoad(s)
	}
}

type PauseRoutineLoadContext struct {
	SupportedLoadStatementContext
	label IMultipartIdentifierContext
}

func NewPauseRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PauseRoutineLoadContext {
	var p = new(PauseRoutineLoadContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *PauseRoutineLoadContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *PauseRoutineLoadContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *PauseRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PauseRoutineLoadContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserPAUSE, 0)
}

func (s *PauseRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserROUTINE, 0)
}

func (s *PauseRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *PauseRoutineLoadContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *PauseRoutineLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *PauseRoutineLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPauseRoutineLoad(s)
	}
}

func (s *PauseRoutineLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPauseRoutineLoad(s)
	}
}

type ShowIndexTokenFilterContext struct {
	SupportedLoadStatementContext
}

func NewShowIndexTokenFilterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowIndexTokenFilterContext {
	var p = new(ShowIndexTokenFilterContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *ShowIndexTokenFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowIndexTokenFilterContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowIndexTokenFilterContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserINVERTED, 0)
}

func (s *ShowIndexTokenFilterContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *ShowIndexTokenFilterContext) TOKEN_FILTER() antlr.TerminalNode {
	return s.GetToken(DorisParserTOKEN_FILTER, 0)
}

func (s *ShowIndexTokenFilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowIndexTokenFilter(s)
	}
}

func (s *ShowIndexTokenFilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowIndexTokenFilter(s)
	}
}

type ShowIndexAnalyzerContext struct {
	SupportedLoadStatementContext
}

func NewShowIndexAnalyzerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowIndexAnalyzerContext {
	var p = new(ShowIndexAnalyzerContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *ShowIndexAnalyzerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowIndexAnalyzerContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowIndexAnalyzerContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserINVERTED, 0)
}

func (s *ShowIndexAnalyzerContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *ShowIndexAnalyzerContext) ANALYZER() antlr.TerminalNode {
	return s.GetToken(DorisParserANALYZER, 0)
}

func (s *ShowIndexAnalyzerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowIndexAnalyzer(s)
	}
}

func (s *ShowIndexAnalyzerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowIndexAnalyzer(s)
	}
}

type ShowRoutineLoadTaskContext struct {
	SupportedLoadStatementContext
	database IIdentifierContext
}

func NewShowRoutineLoadTaskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRoutineLoadTaskContext {
	var p = new(ShowRoutineLoadTaskContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *ShowRoutineLoadTaskContext) GetDatabase() IIdentifierContext { return s.database }

func (s *ShowRoutineLoadTaskContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *ShowRoutineLoadTaskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRoutineLoadTaskContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowRoutineLoadTaskContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserROUTINE, 0)
}

func (s *ShowRoutineLoadTaskContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *ShowRoutineLoadTaskContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisParserTASK, 0)
}

func (s *ShowRoutineLoadTaskContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowRoutineLoadTaskContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ShowRoutineLoadTaskContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ShowRoutineLoadTaskContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowRoutineLoadTaskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowRoutineLoadTask(s)
	}
}

func (s *ShowRoutineLoadTaskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowRoutineLoadTask(s)
	}
}

type ResumeAllRoutineLoadContext struct {
	SupportedLoadStatementContext
}

func NewResumeAllRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ResumeAllRoutineLoadContext {
	var p = new(ResumeAllRoutineLoadContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *ResumeAllRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumeAllRoutineLoadContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisParserRESUME, 0)
}

func (s *ResumeAllRoutineLoadContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *ResumeAllRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserROUTINE, 0)
}

func (s *ResumeAllRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *ResumeAllRoutineLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterResumeAllRoutineLoad(s)
	}
}

func (s *ResumeAllRoutineLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitResumeAllRoutineLoad(s)
	}
}

type StopRoutineLoadContext struct {
	SupportedLoadStatementContext
	label IMultipartIdentifierContext
}

func NewStopRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StopRoutineLoadContext {
	var p = new(StopRoutineLoadContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *StopRoutineLoadContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *StopRoutineLoadContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *StopRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StopRoutineLoadContext) STOP() antlr.TerminalNode {
	return s.GetToken(DorisParserSTOP, 0)
}

func (s *StopRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserROUTINE, 0)
}

func (s *StopRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *StopRoutineLoadContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *StopRoutineLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *StopRoutineLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStopRoutineLoad(s)
	}
}

func (s *StopRoutineLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStopRoutineLoad(s)
	}
}

func (p *DorisParser) SupportedLoadStatement() (localctx ISupportedLoadStatementContext) {
	localctx = NewSupportedLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, DorisParserRULE_supportedLoadStatement)
	var _la int

	p.SetState(2679)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 352, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSyncContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2608)
			p.Match(DorisParserSYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewCreateRoutineLoadAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2609)
			p.CreateRoutineLoad()
		}

	case 3:
		localctx = NewShowCreateRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2610)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2612)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserALL {
			{
				p.SetState(2611)
				p.Match(DorisParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2614)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2615)
			p.Match(DorisParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2616)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2617)
			p.Match(DorisParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2618)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateRoutineLoadContext).label = _x
		}

	case 4:
		localctx = NewPauseRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2619)
			p.Match(DorisParserPAUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2620)
			p.Match(DorisParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2621)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2622)
			p.Match(DorisParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2623)

			var _x = p.MultipartIdentifier()

			localctx.(*PauseRoutineLoadContext).label = _x
		}

	case 5:
		localctx = NewPauseAllRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2624)
			p.Match(DorisParserPAUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2625)
			p.Match(DorisParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2626)
			p.Match(DorisParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2627)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewResumeRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2628)
			p.Match(DorisParserRESUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2629)
			p.Match(DorisParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2630)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2631)
			p.Match(DorisParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2632)

			var _x = p.MultipartIdentifier()

			localctx.(*ResumeRoutineLoadContext).label = _x
		}

	case 7:
		localctx = NewResumeAllRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2633)
			p.Match(DorisParserRESUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2634)
			p.Match(DorisParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2635)
			p.Match(DorisParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2636)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewStopRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2637)
			p.Match(DorisParserSTOP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2638)
			p.Match(DorisParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2639)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2640)
			p.Match(DorisParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2641)

			var _x = p.MultipartIdentifier()

			localctx.(*StopRoutineLoadContext).label = _x
		}

	case 9:
		localctx = NewShowRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2642)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2644)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserALL {
			{
				p.SetState(2643)
				p.Match(DorisParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2646)
			p.Match(DorisParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2647)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2654)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserFOR:
			{
				p.SetState(2648)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2649)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowRoutineLoadContext).label = _x
			}

		case DorisParserEOF, DorisParserSEMICOLON, DorisParserLIKE:
			p.SetState(2652)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserLIKE {
				{
					p.SetState(2650)
					p.Match(DorisParserLIKE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2651)
					p.Match(DorisParserSTRING_LITERAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 10:
		localctx = NewShowRoutineLoadTaskContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2656)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2657)
			p.Match(DorisParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2658)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2659)
			p.Match(DorisParserTASK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2662)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2660)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2661)

				var _x = p.Identifier()

				localctx.(*ShowRoutineLoadTaskContext).database = _x
			}

		}
		p.SetState(2665)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2664)
				p.WildWhere()
			}

		}

	case 11:
		localctx = NewShowIndexAnalyzerContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2667)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2668)
			p.Match(DorisParserINVERTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2669)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2670)
			p.Match(DorisParserANALYZER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewShowIndexTokenizerContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2671)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2672)
			p.Match(DorisParserINVERTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2673)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2674)
			p.Match(DorisParserTOKENIZER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		localctx = NewShowIndexTokenFilterContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2675)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2676)
			p.Match(DorisParserINVERTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2677)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2678)
			p.Match(DorisParserTOKEN_FILTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedKillStatementContext is an interface to support dynamic dispatch.
type ISupportedKillStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedKillStatementContext differentiates from other interfaces.
	IsSupportedKillStatementContext()
}

type SupportedKillStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedKillStatementContext() *SupportedKillStatementContext {
	var p = new(SupportedKillStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedKillStatement
	return p
}

func InitEmptySupportedKillStatementContext(p *SupportedKillStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedKillStatement
}

func (*SupportedKillStatementContext) IsSupportedKillStatementContext() {}

func NewSupportedKillStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedKillStatementContext {
	var p = new(SupportedKillStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedKillStatement

	return p
}

func (s *SupportedKillStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedKillStatementContext) CopyAll(ctx *SupportedKillStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedKillStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedKillStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type KillQueryContext struct {
	SupportedKillStatementContext
}

func NewKillQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KillQueryContext {
	var p = new(KillQueryContext)

	InitEmptySupportedKillStatementContext(&p.SupportedKillStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedKillStatementContext))

	return p
}

func (s *KillQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillQueryContext) KILL() antlr.TerminalNode {
	return s.GetToken(DorisParserKILL, 0)
}

func (s *KillQueryContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DorisParserQUERY, 0)
}

func (s *KillQueryContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *KillQueryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *KillQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterKillQuery(s)
	}
}

func (s *KillQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitKillQuery(s)
	}
}

type KillConnectionContext struct {
	SupportedKillStatementContext
}

func NewKillConnectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KillConnectionContext {
	var p = new(KillConnectionContext)

	InitEmptySupportedKillStatementContext(&p.SupportedKillStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedKillStatementContext))

	return p
}

func (s *KillConnectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillConnectionContext) KILL() antlr.TerminalNode {
	return s.GetToken(DorisParserKILL, 0)
}

func (s *KillConnectionContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *KillConnectionContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(DorisParserCONNECTION, 0)
}

func (s *KillConnectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterKillConnection(s)
	}
}

func (s *KillConnectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitKillConnection(s)
	}
}

func (p *DorisParser) SupportedKillStatement() (localctx ISupportedKillStatementContext) {
	localctx = NewSupportedKillStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, DorisParserRULE_supportedKillStatement)
	var _la int

	p.SetState(2689)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 354, p.GetParserRuleContext()) {
	case 1:
		localctx = NewKillConnectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2681)
			p.Match(DorisParserKILL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2683)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCONNECTION {
			{
				p.SetState(2682)
				p.Match(DorisParserCONNECTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2685)
			p.Match(DorisParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewKillQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2686)
			p.Match(DorisParserKILL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2687)
			p.Match(DorisParserQUERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2688)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserSTRING_LITERAL || _la == DorisParserINTEGER_VALUE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedOtherStatementContext is an interface to support dynamic dispatch.
type ISupportedOtherStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedOtherStatementContext differentiates from other interfaces.
	IsSupportedOtherStatementContext()
}

type SupportedOtherStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedOtherStatementContext() *SupportedOtherStatementContext {
	var p = new(SupportedOtherStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedOtherStatement
	return p
}

func InitEmptySupportedOtherStatementContext(p *SupportedOtherStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedOtherStatement
}

func (*SupportedOtherStatementContext) IsSupportedOtherStatementContext() {}

func NewSupportedOtherStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedOtherStatementContext {
	var p = new(SupportedOtherStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedOtherStatement

	return p
}

func (s *SupportedOtherStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedOtherStatementContext) CopyAll(ctx *SupportedOtherStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedOtherStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedOtherStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type HelpContext struct {
	SupportedOtherStatementContext
	mark IIdentifierOrTextContext
}

func NewHelpContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HelpContext {
	var p = new(HelpContext)

	InitEmptySupportedOtherStatementContext(&p.SupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedOtherStatementContext))

	return p
}

func (s *HelpContext) GetMark() IIdentifierOrTextContext { return s.mark }

func (s *HelpContext) SetMark(v IIdentifierOrTextContext) { s.mark = v }

func (s *HelpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelpContext) HELP() antlr.TerminalNode {
	return s.GetToken(DorisParserHELP, 0)
}

func (s *HelpContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *HelpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterHelp(s)
	}
}

func (s *HelpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitHelp(s)
	}
}

type UnlockTablesContext struct {
	SupportedOtherStatementContext
}

func NewUnlockTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnlockTablesContext {
	var p = new(UnlockTablesContext)

	InitEmptySupportedOtherStatementContext(&p.SupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedOtherStatementContext))

	return p
}

func (s *UnlockTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnlockTablesContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(DorisParserUNLOCK, 0)
}

func (s *UnlockTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLES, 0)
}

func (s *UnlockTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUnlockTables(s)
	}
}

func (s *UnlockTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUnlockTables(s)
	}
}

type UninstallPluginContext struct {
	SupportedOtherStatementContext
	name IIdentifierOrTextContext
}

func NewUninstallPluginContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UninstallPluginContext {
	var p = new(UninstallPluginContext)

	InitEmptySupportedOtherStatementContext(&p.SupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedOtherStatementContext))

	return p
}

func (s *UninstallPluginContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *UninstallPluginContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *UninstallPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UninstallPluginContext) UNINSTALL() antlr.TerminalNode {
	return s.GetToken(DorisParserUNINSTALL, 0)
}

func (s *UninstallPluginContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(DorisParserPLUGIN, 0)
}

func (s *UninstallPluginContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *UninstallPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUninstallPlugin(s)
	}
}

func (s *UninstallPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUninstallPlugin(s)
	}
}

type BackupContext struct {
	SupportedOtherStatementContext
	label      IMultipartIdentifierContext
	repo       IIdentifierContext
	properties IPropertyClauseContext
}

func NewBackupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BackupContext {
	var p = new(BackupContext)

	InitEmptySupportedOtherStatementContext(&p.SupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedOtherStatementContext))

	return p
}

func (s *BackupContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *BackupContext) GetRepo() IIdentifierContext { return s.repo }

func (s *BackupContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *BackupContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *BackupContext) SetRepo(v IIdentifierContext) { s.repo = v }

func (s *BackupContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *BackupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackupContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKUP, 0)
}

func (s *BackupContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisParserSNAPSHOT, 0)
}

func (s *BackupContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *BackupContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *BackupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BackupContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *BackupContext) AllBaseTableRef() []IBaseTableRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			len++
		}
	}

	tst := make([]IBaseTableRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBaseTableRefContext); ok {
			tst[i] = t.(IBaseTableRefContext)
			i++
		}
	}

	return tst
}

func (s *BackupContext) BaseTableRef(i int) IBaseTableRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *BackupContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *BackupContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *BackupContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(DorisParserEXCLUDE, 0)
}

func (s *BackupContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *BackupContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *BackupContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *BackupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBackup(s)
	}
}

func (s *BackupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBackup(s)
	}
}

type LockTablesContext struct {
	SupportedOtherStatementContext
}

func NewLockTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LockTablesContext {
	var p = new(LockTablesContext)

	InitEmptySupportedOtherStatementContext(&p.SupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedOtherStatementContext))

	return p
}

func (s *LockTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockTablesContext) LOCK() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCK, 0)
}

func (s *LockTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLES, 0)
}

func (s *LockTablesContext) AllLockTable() []ILockTableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILockTableContext); ok {
			len++
		}
	}

	tst := make([]ILockTableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILockTableContext); ok {
			tst[i] = t.(ILockTableContext)
			i++
		}
	}

	return tst
}

func (s *LockTablesContext) LockTable(i int) ILockTableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockTableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockTableContext)
}

func (s *LockTablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *LockTablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *LockTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLockTables(s)
	}
}

func (s *LockTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLockTables(s)
	}
}

type InstallPluginContext struct {
	SupportedOtherStatementContext
	source     IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewInstallPluginContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InstallPluginContext {
	var p = new(InstallPluginContext)

	InitEmptySupportedOtherStatementContext(&p.SupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedOtherStatementContext))

	return p
}

func (s *InstallPluginContext) GetSource() IIdentifierOrTextContext { return s.source }

func (s *InstallPluginContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *InstallPluginContext) SetSource(v IIdentifierOrTextContext) { s.source = v }

func (s *InstallPluginContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *InstallPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstallPluginContext) INSTALL() antlr.TerminalNode {
	return s.GetToken(DorisParserINSTALL, 0)
}

func (s *InstallPluginContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(DorisParserPLUGIN, 0)
}

func (s *InstallPluginContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *InstallPluginContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *InstallPluginContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *InstallPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterInstallPlugin(s)
	}
}

func (s *InstallPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitInstallPlugin(s)
	}
}

type WarmUpClusterContext struct {
	SupportedOtherStatementContext
	destination IIdentifierContext
	source      IIdentifierContext
}

func NewWarmUpClusterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WarmUpClusterContext {
	var p = new(WarmUpClusterContext)

	InitEmptySupportedOtherStatementContext(&p.SupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedOtherStatementContext))

	return p
}

func (s *WarmUpClusterContext) GetDestination() IIdentifierContext { return s.destination }

func (s *WarmUpClusterContext) GetSource() IIdentifierContext { return s.source }

func (s *WarmUpClusterContext) SetDestination(v IIdentifierContext) { s.destination = v }

func (s *WarmUpClusterContext) SetSource(v IIdentifierContext) { s.source = v }

func (s *WarmUpClusterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WarmUpClusterContext) WARM() antlr.TerminalNode {
	return s.GetToken(DorisParserWARM, 0)
}

func (s *WarmUpClusterContext) UP() antlr.TerminalNode {
	return s.GetToken(DorisParserUP, 0)
}

func (s *WarmUpClusterContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *WarmUpClusterContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *WarmUpClusterContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WarmUpClusterContext) AllCLUSTER() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCLUSTER)
}

func (s *WarmUpClusterContext) CLUSTER(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCLUSTER, i)
}

func (s *WarmUpClusterContext) AllCOMPUTE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMPUTE)
}

func (s *WarmUpClusterContext) COMPUTE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPUTE, i)
}

func (s *WarmUpClusterContext) AllGROUP() []antlr.TerminalNode {
	return s.GetTokens(DorisParserGROUP)
}

func (s *WarmUpClusterContext) GROUP(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserGROUP, i)
}

func (s *WarmUpClusterContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserFORCE, 0)
}

func (s *WarmUpClusterContext) AllWarmUpItem() []IWarmUpItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWarmUpItemContext); ok {
			len++
		}
	}

	tst := make([]IWarmUpItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWarmUpItemContext); ok {
			tst[i] = t.(IWarmUpItemContext)
			i++
		}
	}

	return tst
}

func (s *WarmUpClusterContext) WarmUpItem(i int) IWarmUpItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWarmUpItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWarmUpItemContext)
}

func (s *WarmUpClusterContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(DorisParserAND)
}

func (s *WarmUpClusterContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserAND, i)
}

func (s *WarmUpClusterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWarmUpCluster(s)
	}
}

func (s *WarmUpClusterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWarmUpCluster(s)
	}
}

func (p *DorisParser) SupportedOtherStatement() (localctx ISupportedOtherStatementContext) {
	localctx = NewSupportedOtherStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, DorisParserRULE_supportedOtherStatement)
	var _la int

	p.SetState(2767)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserHELP:
		localctx = NewHelpContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2691)
			p.Match(DorisParserHELP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2692)

			var _x = p.IdentifierOrText()

			localctx.(*HelpContext).mark = _x
		}

	case DorisParserUNLOCK:
		localctx = NewUnlockTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2693)
			p.Match(DorisParserUNLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2694)
			p.Match(DorisParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserINSTALL:
		localctx = NewInstallPluginContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2695)
			p.Match(DorisParserINSTALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2696)
			p.Match(DorisParserPLUGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2697)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2698)

			var _x = p.IdentifierOrText()

			localctx.(*InstallPluginContext).source = _x
		}
		p.SetState(2700)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2699)

				var _x = p.PropertyClause()

				localctx.(*InstallPluginContext).properties = _x
			}

		}

	case DorisParserUNINSTALL:
		localctx = NewUninstallPluginContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2702)
			p.Match(DorisParserUNINSTALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2703)
			p.Match(DorisParserPLUGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2704)

			var _x = p.IdentifierOrText()

			localctx.(*UninstallPluginContext).name = _x
		}

	case DorisParserLOCK:
		localctx = NewLockTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2705)
			p.Match(DorisParserLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2706)
			p.Match(DorisParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2715)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305902462020672000) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4609989332399152113) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4540397275156637211) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&2557745532860070517) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&8545544968972265069) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-305714810442809349) != 0) || ((int64((_la-391)) & ^0x3f) == 0 && ((int64(1)<<(_la-391))&1188948054525294943) != 0) || ((int64((_la-455)) & ^0x3f) == 0 && ((int64(1)<<(_la-455))&2458964612221191023) != 0) || ((int64((_la-538)) & ^0x3f) == 0 && ((int64(1)<<(_la-538))&49159) != 0) {
			{
				p.SetState(2707)
				p.LockTable()
			}
			p.SetState(2712)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(2708)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2709)
					p.LockTable()
				}

				p.SetState(2714)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}

	case DorisParserWARM:
		localctx = NewWarmUpClusterContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2717)
			p.Match(DorisParserWARM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2718)
			p.Match(DorisParserUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2722)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserCLUSTER:
			{
				p.SetState(2719)
				p.Match(DorisParserCLUSTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCOMPUTE:
			{
				p.SetState(2720)
				p.Match(DorisParserCOMPUTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2721)
				p.Match(DorisParserGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(2724)

			var _x = p.Identifier()

			localctx.(*WarmUpClusterContext).destination = _x
		}
		{
			p.SetState(2725)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2740)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserCLUSTER, DorisParserCOMPUTE:
			p.SetState(2729)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserCLUSTER:
				{
					p.SetState(2726)
					p.Match(DorisParserCLUSTER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case DorisParserCOMPUTE:
				{
					p.SetState(2727)
					p.Match(DorisParserCOMPUTE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2728)
					p.Match(DorisParserGROUP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			{
				p.SetState(2731)

				var _x = p.Identifier()

				localctx.(*WarmUpClusterContext).source = _x
			}

		case DorisParserTABLE:
			{
				p.SetState(2732)
				p.WarmUpItem()
			}
			p.SetState(2737)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserAND {
				{
					p.SetState(2733)
					p.Match(DorisParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2734)
					p.WarmUpItem()
				}

				p.SetState(2739)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(2743)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFORCE {
			{
				p.SetState(2742)
				p.Match(DorisParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DorisParserBACKUP:
		localctx = NewBackupContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2745)
			p.Match(DorisParserBACKUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2746)
			p.Match(DorisParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2747)

			var _x = p.MultipartIdentifier()

			localctx.(*BackupContext).label = _x
		}
		{
			p.SetState(2748)
			p.Match(DorisParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2749)

			var _x = p.Identifier()

			localctx.(*BackupContext).repo = _x
		}
		p.SetState(2762)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserEXCLUDE || _la == DorisParserON {
			{
				p.SetState(2750)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserEXCLUDE || _la == DorisParserON) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2751)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2752)
				p.BaseTableRef()
			}
			p.SetState(2757)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(2753)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2754)
					p.BaseTableRef()
				}

				p.SetState(2759)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2760)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2765)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2764)

				var _x = p.PropertyClause()

				localctx.(*BackupContext).properties = _x
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedOtherStatementContext is an interface to support dynamic dispatch.
type IUnsupportedOtherStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedOtherStatementContext differentiates from other interfaces.
	IsUnsupportedOtherStatementContext()
}

type UnsupportedOtherStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedOtherStatementContext() *UnsupportedOtherStatementContext {
	var p = new(UnsupportedOtherStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedOtherStatement
	return p
}

func InitEmptyUnsupportedOtherStatementContext(p *UnsupportedOtherStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedOtherStatement
}

func (*UnsupportedOtherStatementContext) IsUnsupportedOtherStatementContext() {}

func NewUnsupportedOtherStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedOtherStatementContext {
	var p = new(UnsupportedOtherStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedOtherStatement

	return p
}

func (s *UnsupportedOtherStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedOtherStatementContext) CopyAll(ctx *UnsupportedOtherStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedOtherStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedOtherStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RestoreContext struct {
	UnsupportedOtherStatementContext
	label      IMultipartIdentifierContext
	repo       IIdentifierContext
	properties IPropertyClauseContext
}

func NewRestoreContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RestoreContext {
	var p = new(RestoreContext)

	InitEmptyUnsupportedOtherStatementContext(&p.UnsupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedOtherStatementContext))

	return p
}

func (s *RestoreContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *RestoreContext) GetRepo() IIdentifierContext { return s.repo }

func (s *RestoreContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *RestoreContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *RestoreContext) SetRepo(v IIdentifierContext) { s.repo = v }

func (s *RestoreContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *RestoreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RestoreContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESTORE, 0)
}

func (s *RestoreContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisParserSNAPSHOT, 0)
}

func (s *RestoreContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *RestoreContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *RestoreContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RestoreContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *RestoreContext) AllBaseTableRef() []IBaseTableRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			len++
		}
	}

	tst := make([]IBaseTableRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBaseTableRefContext); ok {
			tst[i] = t.(IBaseTableRefContext)
			i++
		}
	}

	return tst
}

func (s *RestoreContext) BaseTableRef(i int) IBaseTableRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *RestoreContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *RestoreContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *RestoreContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(DorisParserEXCLUDE, 0)
}

func (s *RestoreContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *RestoreContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *RestoreContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *RestoreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRestore(s)
	}
}

func (s *RestoreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRestore(s)
	}
}

type UnsupportedStartTransactionContext struct {
	UnsupportedOtherStatementContext
}

func NewUnsupportedStartTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnsupportedStartTransactionContext {
	var p = new(UnsupportedStartTransactionContext)

	InitEmptyUnsupportedOtherStatementContext(&p.UnsupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedOtherStatementContext))

	return p
}

func (s *UnsupportedStartTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedStartTransactionContext) START() antlr.TerminalNode {
	return s.GetToken(DorisParserSTART, 0)
}

func (s *UnsupportedStartTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisParserTRANSACTION, 0)
}

func (s *UnsupportedStartTransactionContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *UnsupportedStartTransactionContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCONSISTENT, 0)
}

func (s *UnsupportedStartTransactionContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisParserSNAPSHOT, 0)
}

func (s *UnsupportedStartTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUnsupportedStartTransaction(s)
	}
}

func (s *UnsupportedStartTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUnsupportedStartTransaction(s)
	}
}

func (p *DorisParser) UnsupportedOtherStatement() (localctx IUnsupportedOtherStatementContext) {
	localctx = NewUnsupportedOtherStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, DorisParserRULE_unsupportedOtherStatement)
	var _la int

	p.SetState(2798)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserRESTORE:
		localctx = NewRestoreContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2769)
			p.Match(DorisParserRESTORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2770)
			p.Match(DorisParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2771)

			var _x = p.MultipartIdentifier()

			localctx.(*RestoreContext).label = _x
		}
		{
			p.SetState(2772)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2773)

			var _x = p.Identifier()

			localctx.(*RestoreContext).repo = _x
		}
		p.SetState(2786)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserEXCLUDE || _la == DorisParserON {
			{
				p.SetState(2774)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserEXCLUDE || _la == DorisParserON) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2775)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2776)
				p.BaseTableRef()
			}
			p.SetState(2781)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(2777)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2778)
					p.BaseTableRef()
				}

				p.SetState(2783)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2784)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2789)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2788)

				var _x = p.PropertyClause()

				localctx.(*RestoreContext).properties = _x
			}

		}

	case DorisParserSTART:
		localctx = NewUnsupportedStartTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2791)
			p.Match(DorisParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2792)
			p.Match(DorisParserTRANSACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2796)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(2793)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2794)
				p.Match(DorisParserCONSISTENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2795)
				p.Match(DorisParserSNAPSHOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWarmUpItemContext is an interface to support dynamic dispatch.
type IWarmUpItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTableName returns the tableName rule contexts.
	GetTableName() IMultipartIdentifierContext

	// GetPartitionName returns the partitionName rule contexts.
	GetPartitionName() IIdentifierContext

	// SetTableName sets the tableName rule contexts.
	SetTableName(IMultipartIdentifierContext)

	// SetPartitionName sets the partitionName rule contexts.
	SetPartitionName(IIdentifierContext)

	// Getter signatures
	TABLE() antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsWarmUpItemContext differentiates from other interfaces.
	IsWarmUpItemContext()
}

type WarmUpItemContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	tableName     IMultipartIdentifierContext
	partitionName IIdentifierContext
}

func NewEmptyWarmUpItemContext() *WarmUpItemContext {
	var p = new(WarmUpItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_warmUpItem
	return p
}

func InitEmptyWarmUpItemContext(p *WarmUpItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_warmUpItem
}

func (*WarmUpItemContext) IsWarmUpItemContext() {}

func NewWarmUpItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WarmUpItemContext {
	var p = new(WarmUpItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_warmUpItem

	return p
}

func (s *WarmUpItemContext) GetParser() antlr.Parser { return s.parser }

func (s *WarmUpItemContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *WarmUpItemContext) GetPartitionName() IIdentifierContext { return s.partitionName }

func (s *WarmUpItemContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *WarmUpItemContext) SetPartitionName(v IIdentifierContext) { s.partitionName = v }

func (s *WarmUpItemContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *WarmUpItemContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *WarmUpItemContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *WarmUpItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WarmUpItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WarmUpItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WarmUpItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWarmUpItem(s)
	}
}

func (s *WarmUpItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWarmUpItem(s)
	}
}

func (p *DorisParser) WarmUpItem() (localctx IWarmUpItemContext) {
	localctx = NewWarmUpItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, DorisParserRULE_warmUpItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2800)
		p.Match(DorisParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2801)

		var _x = p.MultipartIdentifier()

		localctx.(*WarmUpItemContext).tableName = _x
	}
	p.SetState(2804)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPARTITION {
		{
			p.SetState(2802)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2803)

			var _x = p.Identifier()

			localctx.(*WarmUpItemContext).partitionName = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockTableContext is an interface to support dynamic dispatch.
type ILockTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IMultipartIdentifierContext

	// GetAlias returns the alias rule contexts.
	GetAlias() IIdentifierOrTextContext

	// SetName sets the name rule contexts.
	SetName(IMultipartIdentifierContext)

	// SetAlias sets the alias rule contexts.
	SetAlias(IIdentifierOrTextContext)

	// Getter signatures
	MultipartIdentifier() IMultipartIdentifierContext
	READ() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	AS() antlr.TerminalNode
	IdentifierOrText() IIdentifierOrTextContext
	LOCAL() antlr.TerminalNode
	LOW_PRIORITY() antlr.TerminalNode

	// IsLockTableContext differentiates from other interfaces.
	IsLockTableContext()
}

type LockTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IMultipartIdentifierContext
	alias  IIdentifierOrTextContext
}

func NewEmptyLockTableContext() *LockTableContext {
	var p = new(LockTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_lockTable
	return p
}

func InitEmptyLockTableContext(p *LockTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_lockTable
}

func (*LockTableContext) IsLockTableContext() {}

func NewLockTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockTableContext {
	var p = new(LockTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_lockTable

	return p
}

func (s *LockTableContext) GetParser() antlr.Parser { return s.parser }

func (s *LockTableContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *LockTableContext) GetAlias() IIdentifierOrTextContext { return s.alias }

func (s *LockTableContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *LockTableContext) SetAlias(v IIdentifierOrTextContext) { s.alias = v }

func (s *LockTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *LockTableContext) READ() antlr.TerminalNode {
	return s.GetToken(DorisParserREAD, 0)
}

func (s *LockTableContext) WRITE() antlr.TerminalNode {
	return s.GetToken(DorisParserWRITE, 0)
}

func (s *LockTableContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *LockTableContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *LockTableContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *LockTableContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(DorisParserLOW_PRIORITY, 0)
}

func (s *LockTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLockTable(s)
	}
}

func (s *LockTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLockTable(s)
	}
}

func (p *DorisParser) LockTable() (localctx ILockTableContext) {
	localctx = NewLockTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, DorisParserRULE_lockTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2806)

		var _x = p.MultipartIdentifier()

		localctx.(*LockTableContext).name = _x
	}
	p.SetState(2809)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserAS {
		{
			p.SetState(2807)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2808)

			var _x = p.IdentifierOrText()

			localctx.(*LockTableContext).alias = _x
		}

	}
	p.SetState(2819)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserREAD:
		{
			p.SetState(2811)
			p.Match(DorisParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2813)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLOCAL {
			{
				p.SetState(2812)
				p.Match(DorisParserLOCAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DorisParserLOW_PRIORITY, DorisParserWRITE:
		p.SetState(2816)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLOW_PRIORITY {
			{
				p.SetState(2815)
				p.Match(DorisParserLOW_PRIORITY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2818)
			p.Match(DorisParserWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateRoutineLoadContext is an interface to support dynamic dispatch.
type ICreateRoutineLoadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLabel returns the label rule contexts.
	GetLabel() IMultipartIdentifierContext

	// GetTable returns the table rule contexts.
	GetTable() IIdentifierContext

	// GetType_ returns the type_ rule contexts.
	GetType_() IIdentifierContext

	// GetCustomProperties returns the customProperties rule contexts.
	GetCustomProperties() IPropertyItemListContext

	// SetLabel sets the label rule contexts.
	SetLabel(IMultipartIdentifierContext)

	// SetTable sets the table rule contexts.
	SetTable(IIdentifierContext)

	// SetType_ sets the type_ rule contexts.
	SetType_(IIdentifierContext)

	// SetCustomProperties sets the customProperties rule contexts.
	SetCustomProperties(IPropertyItemListContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FROM() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	PropertyItemList() IPropertyItemListContext
	ON() antlr.TerminalNode
	WITH() antlr.TerminalNode
	AllLoadProperty() []ILoadPropertyContext
	LoadProperty(i int) ILoadPropertyContext
	PropertyClause() IPropertyClauseContext
	CommentSpec() ICommentSpecContext
	APPEND() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreateRoutineLoadContext differentiates from other interfaces.
	IsCreateRoutineLoadContext()
}

type CreateRoutineLoadContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	label            IMultipartIdentifierContext
	table            IIdentifierContext
	type_            IIdentifierContext
	customProperties IPropertyItemListContext
}

func NewEmptyCreateRoutineLoadContext() *CreateRoutineLoadContext {
	var p = new(CreateRoutineLoadContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_createRoutineLoad
	return p
}

func InitEmptyCreateRoutineLoadContext(p *CreateRoutineLoadContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_createRoutineLoad
}

func (*CreateRoutineLoadContext) IsCreateRoutineLoadContext() {}

func NewCreateRoutineLoadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRoutineLoadContext {
	var p = new(CreateRoutineLoadContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_createRoutineLoad

	return p
}

func (s *CreateRoutineLoadContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRoutineLoadContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *CreateRoutineLoadContext) GetTable() IIdentifierContext { return s.table }

func (s *CreateRoutineLoadContext) GetType_() IIdentifierContext { return s.type_ }

func (s *CreateRoutineLoadContext) GetCustomProperties() IPropertyItemListContext {
	return s.customProperties
}

func (s *CreateRoutineLoadContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *CreateRoutineLoadContext) SetTable(v IIdentifierContext) { s.table = v }

func (s *CreateRoutineLoadContext) SetType_(v IIdentifierContext) { s.type_ = v }

func (s *CreateRoutineLoadContext) SetCustomProperties(v IPropertyItemListContext) {
	s.customProperties = v
}

func (s *CreateRoutineLoadContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserROUTINE, 0)
}

func (s *CreateRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *CreateRoutineLoadContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *CreateRoutineLoadContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CreateRoutineLoadContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CreateRoutineLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateRoutineLoadContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateRoutineLoadContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRoutineLoadContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *CreateRoutineLoadContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *CreateRoutineLoadContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *CreateRoutineLoadContext) AllLoadProperty() []ILoadPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILoadPropertyContext); ok {
			len++
		}
	}

	tst := make([]ILoadPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILoadPropertyContext); ok {
			tst[i] = t.(ILoadPropertyContext)
			i++
		}
	}

	return tst
}

func (s *CreateRoutineLoadContext) LoadProperty(i int) ILoadPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadPropertyContext)
}

func (s *CreateRoutineLoadContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateRoutineLoadContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *CreateRoutineLoadContext) APPEND() antlr.TerminalNode {
	return s.GetToken(DorisParserAPPEND, 0)
}

func (s *CreateRoutineLoadContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisParserDELETE, 0)
}

func (s *CreateRoutineLoadContext) MERGE() antlr.TerminalNode {
	return s.GetToken(DorisParserMERGE, 0)
}

func (s *CreateRoutineLoadContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *CreateRoutineLoadContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *CreateRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoutineLoadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRoutineLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateRoutineLoad(s)
	}
}

func (s *CreateRoutineLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateRoutineLoad(s)
	}
}

func (p *DorisParser) CreateRoutineLoad() (localctx ICreateRoutineLoadContext) {
	localctx = NewCreateRoutineLoadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, DorisParserRULE_createRoutineLoad)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2821)
		p.Match(DorisParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2822)
		p.Match(DorisParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2823)
		p.Match(DorisParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2824)

		var _x = p.MultipartIdentifier()

		localctx.(*CreateRoutineLoadContext).label = _x
	}
	p.SetState(2827)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserON {
		{
			p.SetState(2825)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2826)

			var _x = p.Identifier()

			localctx.(*CreateRoutineLoadContext).table = _x
		}

	}
	p.SetState(2831)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserWITH {
		{
			p.SetState(2829)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2830)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserAPPEND || _la == DorisParserDELETE || _la == DorisParserMERGE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(2841)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserCOLUMNS || _la == DorisParserDELETE || ((int64((_la-322)) & ^0x3f) == 0 && ((int64(1)<<(_la-322))&536871297) != 0) || _la == DorisParserTEMPORARY || _la == DorisParserWHERE {
		{
			p.SetState(2833)
			p.LoadProperty()
		}
		p.SetState(2838)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(2834)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2835)
				p.LoadProperty()
			}

			p.SetState(2840)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(2844)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPROPERTIES {
		{
			p.SetState(2843)
			p.PropertyClause()
		}

	}
	{
		p.SetState(2846)
		p.Match(DorisParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2847)

		var _x = p.Identifier()

		localctx.(*CreateRoutineLoadContext).type_ = _x
	}
	{
		p.SetState(2848)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2849)

		var _x = p.PropertyItemList()

		localctx.(*CreateRoutineLoadContext).customProperties = _x
	}
	{
		p.SetState(2850)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2852)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserCOMMENT {
		{
			p.SetState(2851)
			p.CommentSpec()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedLoadStatementContext is an interface to support dynamic dispatch.
type IUnsupportedLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedLoadStatementContext differentiates from other interfaces.
	IsUnsupportedLoadStatementContext()
}

type UnsupportedLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedLoadStatementContext() *UnsupportedLoadStatementContext {
	var p = new(UnsupportedLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedLoadStatement
	return p
}

func InitEmptyUnsupportedLoadStatementContext(p *UnsupportedLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedLoadStatement
}

func (*UnsupportedLoadStatementContext) IsUnsupportedLoadStatementContext() {}

func NewUnsupportedLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedLoadStatementContext {
	var p = new(UnsupportedLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedLoadStatement

	return p
}

func (s *UnsupportedLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedLoadStatementContext) CopyAll(ctx *UnsupportedLoadStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowCreateLoadContext struct {
	UnsupportedLoadStatementContext
	label IMultipartIdentifierContext
}

func NewShowCreateLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateLoadContext {
	var p = new(ShowCreateLoadContext)

	InitEmptyUnsupportedLoadStatementContext(&p.UnsupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedLoadStatementContext))

	return p
}

func (s *ShowCreateLoadContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *ShowCreateLoadContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *ShowCreateLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateLoadContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowCreateLoadContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *ShowCreateLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *ShowCreateLoadContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *ShowCreateLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowCreateLoad(s)
	}
}

func (s *ShowCreateLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowCreateLoad(s)
	}
}

type MysqlLoadContext struct {
	UnsupportedLoadStatementContext
	properties IPropertyItemListContext
}

func NewMysqlLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MysqlLoadContext {
	var p = new(MysqlLoadContext)

	InitEmptyUnsupportedLoadStatementContext(&p.UnsupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedLoadStatementContext))

	return p
}

func (s *MysqlLoadContext) GetProperties() IPropertyItemListContext { return s.properties }

func (s *MysqlLoadContext) SetProperties(v IPropertyItemListContext) { s.properties = v }

func (s *MysqlLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MysqlLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *MysqlLoadContext) MysqlDataDesc() IMysqlDataDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMysqlDataDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMysqlDataDescContext)
}

func (s *MysqlLoadContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *MysqlLoadContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *MysqlLoadContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *MysqlLoadContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *MysqlLoadContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *MysqlLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMysqlLoad(s)
	}
}

func (s *MysqlLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMysqlLoad(s)
	}
}

func (p *DorisParser) UnsupportedLoadStatement() (localctx IUnsupportedLoadStatementContext) {
	localctx = NewUnsupportedLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, DorisParserRULE_unsupportedLoadStatement)
	var _la int

	p.SetState(2871)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLOAD:
		localctx = NewMysqlLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2854)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2855)
			p.MysqlDataDesc()
		}
		p.SetState(2861)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2856)
				p.Match(DorisParserPROPERTIES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2857)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2858)

				var _x = p.PropertyItemList()

				localctx.(*MysqlLoadContext).properties = _x
			}
			{
				p.SetState(2859)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2864)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMMENT {
			{
				p.SetState(2863)
				p.CommentSpec()
			}

		}

	case DorisParserSHOW:
		localctx = NewShowCreateLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2866)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2867)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2868)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2869)
			p.Match(DorisParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2870)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateLoadContext).label = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoadPropertyContext is an interface to support dynamic dispatch.
type ILoadPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLoadPropertyContext differentiates from other interfaces.
	IsLoadPropertyContext()
}

type LoadPropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoadPropertyContext() *LoadPropertyContext {
	var p = new(LoadPropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_loadProperty
	return p
}

func InitEmptyLoadPropertyContext(p *LoadPropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_loadProperty
}

func (*LoadPropertyContext) IsLoadPropertyContext() {}

func NewLoadPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadPropertyContext {
	var p = new(LoadPropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_loadProperty

	return p
}

func (s *LoadPropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadPropertyContext) CopyAll(ctx *LoadPropertyContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LoadPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadPropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ImportPrecedingFilterContext struct {
	LoadPropertyContext
}

func NewImportPrecedingFilterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImportPrecedingFilterContext {
	var p = new(ImportPrecedingFilterContext)

	InitEmptyLoadPropertyContext(&p.LoadPropertyContext)
	p.parser = parser
	p.CopyAll(ctx.(*LoadPropertyContext))

	return p
}

func (s *ImportPrecedingFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportPrecedingFilterContext) ImportPrecedingFilterStatement() IImportPrecedingFilterStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportPrecedingFilterStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportPrecedingFilterStatementContext)
}

func (s *ImportPrecedingFilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterImportPrecedingFilter(s)
	}
}

func (s *ImportPrecedingFilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitImportPrecedingFilter(s)
	}
}

type ImportSequenceContext struct {
	LoadPropertyContext
}

func NewImportSequenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImportSequenceContext {
	var p = new(ImportSequenceContext)

	InitEmptyLoadPropertyContext(&p.LoadPropertyContext)
	p.parser = parser
	p.CopyAll(ctx.(*LoadPropertyContext))

	return p
}

func (s *ImportSequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportSequenceContext) ImportSequenceStatement() IImportSequenceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportSequenceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportSequenceStatementContext)
}

func (s *ImportSequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterImportSequence(s)
	}
}

func (s *ImportSequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitImportSequence(s)
	}
}

type ImportColumnsContext struct {
	LoadPropertyContext
}

func NewImportColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImportColumnsContext {
	var p = new(ImportColumnsContext)

	InitEmptyLoadPropertyContext(&p.LoadPropertyContext)
	p.parser = parser
	p.CopyAll(ctx.(*LoadPropertyContext))

	return p
}

func (s *ImportColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportColumnsContext) ImportColumnsStatement() IImportColumnsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportColumnsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportColumnsStatementContext)
}

func (s *ImportColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterImportColumns(s)
	}
}

func (s *ImportColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitImportColumns(s)
	}
}

type ImportWhereContext struct {
	LoadPropertyContext
}

func NewImportWhereContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImportWhereContext {
	var p = new(ImportWhereContext)

	InitEmptyLoadPropertyContext(&p.LoadPropertyContext)
	p.parser = parser
	p.CopyAll(ctx.(*LoadPropertyContext))

	return p
}

func (s *ImportWhereContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportWhereContext) ImportWhereStatement() IImportWhereStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportWhereStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportWhereStatementContext)
}

func (s *ImportWhereContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterImportWhere(s)
	}
}

func (s *ImportWhereContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitImportWhere(s)
	}
}

type SeparatorContext struct {
	LoadPropertyContext
}

func NewSeparatorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SeparatorContext {
	var p = new(SeparatorContext)

	InitEmptyLoadPropertyContext(&p.LoadPropertyContext)
	p.parser = parser
	p.CopyAll(ctx.(*LoadPropertyContext))

	return p
}

func (s *SeparatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SeparatorContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMNS, 0)
}

func (s *SeparatorContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(DorisParserTERMINATED, 0)
}

func (s *SeparatorContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *SeparatorContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *SeparatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSeparator(s)
	}
}

func (s *SeparatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSeparator(s)
	}
}

type ImportPartitionsContext struct {
	LoadPropertyContext
}

func NewImportPartitionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImportPartitionsContext {
	var p = new(ImportPartitionsContext)

	InitEmptyLoadPropertyContext(&p.LoadPropertyContext)
	p.parser = parser
	p.CopyAll(ctx.(*LoadPropertyContext))

	return p
}

func (s *ImportPartitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportPartitionsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *ImportPartitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterImportPartitions(s)
	}
}

func (s *ImportPartitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitImportPartitions(s)
	}
}

type ImportDeleteOnContext struct {
	LoadPropertyContext
}

func NewImportDeleteOnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImportDeleteOnContext {
	var p = new(ImportDeleteOnContext)

	InitEmptyLoadPropertyContext(&p.LoadPropertyContext)
	p.parser = parser
	p.CopyAll(ctx.(*LoadPropertyContext))

	return p
}

func (s *ImportDeleteOnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeleteOnContext) ImportDeleteOnStatement() IImportDeleteOnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDeleteOnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDeleteOnStatementContext)
}

func (s *ImportDeleteOnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterImportDeleteOn(s)
	}
}

func (s *ImportDeleteOnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitImportDeleteOn(s)
	}
}

func (p *DorisParser) LoadProperty() (localctx ILoadPropertyContext) {
	localctx = NewLoadPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, DorisParserRULE_loadProperty)
	p.SetState(2883)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 386, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSeparatorContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2873)
			p.Match(DorisParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2874)
			p.Match(DorisParserTERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2875)
			p.Match(DorisParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2876)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewImportColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2877)
			p.ImportColumnsStatement()
		}

	case 3:
		localctx = NewImportPrecedingFilterContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2878)
			p.ImportPrecedingFilterStatement()
		}

	case 4:
		localctx = NewImportWhereContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2879)
			p.ImportWhereStatement()
		}

	case 5:
		localctx = NewImportDeleteOnContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2880)
			p.ImportDeleteOnStatement()
		}

	case 6:
		localctx = NewImportSequenceContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2881)
			p.ImportSequenceStatement()
		}

	case 7:
		localctx = NewImportPartitionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2882)
			p.PartitionSpec()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportSequenceStatementContext is an interface to support dynamic dispatch.
type IImportSequenceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsImportSequenceStatementContext differentiates from other interfaces.
	IsImportSequenceStatementContext()
}

type ImportSequenceStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportSequenceStatementContext() *ImportSequenceStatementContext {
	var p = new(ImportSequenceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_importSequenceStatement
	return p
}

func InitEmptyImportSequenceStatementContext(p *ImportSequenceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_importSequenceStatement
}

func (*ImportSequenceStatementContext) IsImportSequenceStatementContext() {}

func NewImportSequenceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportSequenceStatementContext {
	var p = new(ImportSequenceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_importSequenceStatement

	return p
}

func (s *ImportSequenceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportSequenceStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisParserORDER, 0)
}

func (s *ImportSequenceStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *ImportSequenceStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ImportSequenceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportSequenceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportSequenceStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterImportSequenceStatement(s)
	}
}

func (s *ImportSequenceStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitImportSequenceStatement(s)
	}
}

func (p *DorisParser) ImportSequenceStatement() (localctx IImportSequenceStatementContext) {
	localctx = NewImportSequenceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, DorisParserRULE_importSequenceStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2885)
		p.Match(DorisParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2886)
		p.Match(DorisParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2887)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportDeleteOnStatementContext is an interface to support dynamic dispatch.
type IImportDeleteOnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	ON() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsImportDeleteOnStatementContext differentiates from other interfaces.
	IsImportDeleteOnStatementContext()
}

type ImportDeleteOnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDeleteOnStatementContext() *ImportDeleteOnStatementContext {
	var p = new(ImportDeleteOnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_importDeleteOnStatement
	return p
}

func InitEmptyImportDeleteOnStatementContext(p *ImportDeleteOnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_importDeleteOnStatement
}

func (*ImportDeleteOnStatementContext) IsImportDeleteOnStatementContext() {}

func NewImportDeleteOnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDeleteOnStatementContext {
	var p = new(ImportDeleteOnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_importDeleteOnStatement

	return p
}

func (s *ImportDeleteOnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDeleteOnStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisParserDELETE, 0)
}

func (s *ImportDeleteOnStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *ImportDeleteOnStatementContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ImportDeleteOnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeleteOnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDeleteOnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterImportDeleteOnStatement(s)
	}
}

func (s *ImportDeleteOnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitImportDeleteOnStatement(s)
	}
}

func (p *DorisParser) ImportDeleteOnStatement() (localctx IImportDeleteOnStatementContext) {
	localctx = NewImportDeleteOnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, DorisParserRULE_importDeleteOnStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2889)
		p.Match(DorisParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2890)
		p.Match(DorisParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2891)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportWhereStatementContext is an interface to support dynamic dispatch.
type IImportWhereStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsImportWhereStatementContext differentiates from other interfaces.
	IsImportWhereStatementContext()
}

type ImportWhereStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportWhereStatementContext() *ImportWhereStatementContext {
	var p = new(ImportWhereStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_importWhereStatement
	return p
}

func InitEmptyImportWhereStatementContext(p *ImportWhereStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_importWhereStatement
}

func (*ImportWhereStatementContext) IsImportWhereStatementContext() {}

func NewImportWhereStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportWhereStatementContext {
	var p = new(ImportWhereStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_importWhereStatement

	return p
}

func (s *ImportWhereStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportWhereStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserWHERE, 0)
}

func (s *ImportWhereStatementContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ImportWhereStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportWhereStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportWhereStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterImportWhereStatement(s)
	}
}

func (s *ImportWhereStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitImportWhereStatement(s)
	}
}

func (p *DorisParser) ImportWhereStatement() (localctx IImportWhereStatementContext) {
	localctx = NewImportWhereStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, DorisParserRULE_importWhereStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2893)
		p.Match(DorisParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2894)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportPrecedingFilterStatementContext is an interface to support dynamic dispatch.
type IImportPrecedingFilterStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRECEDING() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsImportPrecedingFilterStatementContext differentiates from other interfaces.
	IsImportPrecedingFilterStatementContext()
}

type ImportPrecedingFilterStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportPrecedingFilterStatementContext() *ImportPrecedingFilterStatementContext {
	var p = new(ImportPrecedingFilterStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_importPrecedingFilterStatement
	return p
}

func InitEmptyImportPrecedingFilterStatementContext(p *ImportPrecedingFilterStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_importPrecedingFilterStatement
}

func (*ImportPrecedingFilterStatementContext) IsImportPrecedingFilterStatementContext() {}

func NewImportPrecedingFilterStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportPrecedingFilterStatementContext {
	var p = new(ImportPrecedingFilterStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_importPrecedingFilterStatement

	return p
}

func (s *ImportPrecedingFilterStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportPrecedingFilterStatementContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(DorisParserPRECEDING, 0)
}

func (s *ImportPrecedingFilterStatementContext) FILTER() antlr.TerminalNode {
	return s.GetToken(DorisParserFILTER, 0)
}

func (s *ImportPrecedingFilterStatementContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ImportPrecedingFilterStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportPrecedingFilterStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportPrecedingFilterStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterImportPrecedingFilterStatement(s)
	}
}

func (s *ImportPrecedingFilterStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitImportPrecedingFilterStatement(s)
	}
}

func (p *DorisParser) ImportPrecedingFilterStatement() (localctx IImportPrecedingFilterStatementContext) {
	localctx = NewImportPrecedingFilterStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, DorisParserRULE_importPrecedingFilterStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2896)
		p.Match(DorisParserPRECEDING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2897)
		p.Match(DorisParserFILTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2898)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportColumnsStatementContext is an interface to support dynamic dispatch.
type IImportColumnsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLUMNS() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	AllImportColumnDesc() []IImportColumnDescContext
	ImportColumnDesc(i int) IImportColumnDescContext
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsImportColumnsStatementContext differentiates from other interfaces.
	IsImportColumnsStatementContext()
}

type ImportColumnsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportColumnsStatementContext() *ImportColumnsStatementContext {
	var p = new(ImportColumnsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_importColumnsStatement
	return p
}

func InitEmptyImportColumnsStatementContext(p *ImportColumnsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_importColumnsStatement
}

func (*ImportColumnsStatementContext) IsImportColumnsStatementContext() {}

func NewImportColumnsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportColumnsStatementContext {
	var p = new(ImportColumnsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_importColumnsStatement

	return p
}

func (s *ImportColumnsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportColumnsStatementContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMNS, 0)
}

func (s *ImportColumnsStatementContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ImportColumnsStatementContext) AllImportColumnDesc() []IImportColumnDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportColumnDescContext); ok {
			len++
		}
	}

	tst := make([]IImportColumnDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportColumnDescContext); ok {
			tst[i] = t.(IImportColumnDescContext)
			i++
		}
	}

	return tst
}

func (s *ImportColumnsStatementContext) ImportColumnDesc(i int) IImportColumnDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportColumnDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportColumnDescContext)
}

func (s *ImportColumnsStatementContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ImportColumnsStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ImportColumnsStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ImportColumnsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportColumnsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportColumnsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterImportColumnsStatement(s)
	}
}

func (s *ImportColumnsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitImportColumnsStatement(s)
	}
}

func (p *DorisParser) ImportColumnsStatement() (localctx IImportColumnsStatementContext) {
	localctx = NewImportColumnsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, DorisParserRULE_importColumnsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2900)
		p.Match(DorisParserCOLUMNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2901)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2902)
		p.ImportColumnDesc()
	}
	p.SetState(2907)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(2903)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2904)
			p.ImportColumnDesc()
		}

		p.SetState(2909)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2910)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportColumnDescContext is an interface to support dynamic dispatch.
type IImportColumnDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	Identifier() IIdentifierContext
	EQ() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode

	// IsImportColumnDescContext differentiates from other interfaces.
	IsImportColumnDescContext()
}

type ImportColumnDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyImportColumnDescContext() *ImportColumnDescContext {
	var p = new(ImportColumnDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_importColumnDesc
	return p
}

func InitEmptyImportColumnDescContext(p *ImportColumnDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_importColumnDesc
}

func (*ImportColumnDescContext) IsImportColumnDescContext() {}

func NewImportColumnDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportColumnDescContext {
	var p = new(ImportColumnDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_importColumnDesc

	return p
}

func (s *ImportColumnDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportColumnDescContext) GetName() IIdentifierContext { return s.name }

func (s *ImportColumnDescContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ImportColumnDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ImportColumnDescContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *ImportColumnDescContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ImportColumnDescContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ImportColumnDescContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ImportColumnDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportColumnDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportColumnDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterImportColumnDesc(s)
	}
}

func (s *ImportColumnDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitImportColumnDesc(s)
	}
}

func (p *DorisParser) ImportColumnDesc() (localctx IImportColumnDescContext) {
	localctx = NewImportColumnDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, DorisParserRULE_importColumnDesc)
	var _la int

	p.SetState(2925)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2912)

			var _x = p.Identifier()

			localctx.(*ImportColumnDescContext).name = _x
		}
		p.SetState(2915)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserEQ {
			{
				p.SetState(2913)
				p.Match(DorisParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2914)
				p.booleanExpression(0)
			}

		}

	case DorisParserLEFT_PAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2917)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2918)

			var _x = p.Identifier()

			localctx.(*ImportColumnDescContext).name = _x
		}
		p.SetState(2921)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserEQ {
			{
				p.SetState(2919)
				p.Match(DorisParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2920)
				p.booleanExpression(0)
			}

		}
		{
			p.SetState(2923)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedRefreshStatementContext is an interface to support dynamic dispatch.
type ISupportedRefreshStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedRefreshStatementContext differentiates from other interfaces.
	IsSupportedRefreshStatementContext()
}

type SupportedRefreshStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedRefreshStatementContext() *SupportedRefreshStatementContext {
	var p = new(SupportedRefreshStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedRefreshStatement
	return p
}

func InitEmptySupportedRefreshStatementContext(p *SupportedRefreshStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedRefreshStatement
}

func (*SupportedRefreshStatementContext) IsSupportedRefreshStatementContext() {}

func NewSupportedRefreshStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedRefreshStatementContext {
	var p = new(SupportedRefreshStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedRefreshStatement

	return p
}

func (s *SupportedRefreshStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedRefreshStatementContext) CopyAll(ctx *SupportedRefreshStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedRefreshStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedRefreshStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RefreshCatalogContext struct {
	SupportedRefreshStatementContext
	name IIdentifierContext
}

func NewRefreshCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RefreshCatalogContext {
	var p = new(RefreshCatalogContext)

	InitEmptySupportedRefreshStatementContext(&p.SupportedRefreshStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedRefreshStatementContext))

	return p
}

func (s *RefreshCatalogContext) GetName() IIdentifierContext { return s.name }

func (s *RefreshCatalogContext) SetName(v IIdentifierContext) { s.name = v }

func (s *RefreshCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshCatalogContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserREFRESH, 0)
}

func (s *RefreshCatalogContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *RefreshCatalogContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RefreshCatalogContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *RefreshCatalogContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRefreshCatalog(s)
	}
}

func (s *RefreshCatalogContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRefreshCatalog(s)
	}
}

type RefreshDictionaryContext struct {
	SupportedRefreshStatementContext
	name IMultipartIdentifierContext
}

func NewRefreshDictionaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RefreshDictionaryContext {
	var p = new(RefreshDictionaryContext)

	InitEmptySupportedRefreshStatementContext(&p.SupportedRefreshStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedRefreshStatementContext))

	return p
}

func (s *RefreshDictionaryContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *RefreshDictionaryContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *RefreshDictionaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshDictionaryContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserREFRESH, 0)
}

func (s *RefreshDictionaryContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(DorisParserDICTIONARY, 0)
}

func (s *RefreshDictionaryContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *RefreshDictionaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRefreshDictionary(s)
	}
}

func (s *RefreshDictionaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRefreshDictionary(s)
	}
}

type RefreshDatabaseContext struct {
	SupportedRefreshStatementContext
	name IMultipartIdentifierContext
}

func NewRefreshDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RefreshDatabaseContext {
	var p = new(RefreshDatabaseContext)

	InitEmptySupportedRefreshStatementContext(&p.SupportedRefreshStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedRefreshStatementContext))

	return p
}

func (s *RefreshDatabaseContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *RefreshDatabaseContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *RefreshDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshDatabaseContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserREFRESH, 0)
}

func (s *RefreshDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *RefreshDatabaseContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *RefreshDatabaseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *RefreshDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRefreshDatabase(s)
	}
}

func (s *RefreshDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRefreshDatabase(s)
	}
}

type RefreshTableContext struct {
	SupportedRefreshStatementContext
	name IMultipartIdentifierContext
}

func NewRefreshTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RefreshTableContext {
	var p = new(RefreshTableContext)

	InitEmptySupportedRefreshStatementContext(&p.SupportedRefreshStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedRefreshStatementContext))

	return p
}

func (s *RefreshTableContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *RefreshTableContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *RefreshTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshTableContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserREFRESH, 0)
}

func (s *RefreshTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *RefreshTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *RefreshTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRefreshTable(s)
	}
}

func (s *RefreshTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRefreshTable(s)
	}
}

type RefreshLdapContext struct {
	SupportedRefreshStatementContext
	user IIdentifierOrTextContext
}

func NewRefreshLdapContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RefreshLdapContext {
	var p = new(RefreshLdapContext)

	InitEmptySupportedRefreshStatementContext(&p.SupportedRefreshStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedRefreshStatementContext))

	return p
}

func (s *RefreshLdapContext) GetUser() IIdentifierOrTextContext { return s.user }

func (s *RefreshLdapContext) SetUser(v IIdentifierOrTextContext) { s.user = v }

func (s *RefreshLdapContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshLdapContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserREFRESH, 0)
}

func (s *RefreshLdapContext) LDAP() antlr.TerminalNode {
	return s.GetToken(DorisParserLDAP, 0)
}

func (s *RefreshLdapContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *RefreshLdapContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *RefreshLdapContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *RefreshLdapContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRefreshLdap(s)
	}
}

func (s *RefreshLdapContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRefreshLdap(s)
	}
}

func (p *DorisParser) SupportedRefreshStatement() (localctx ISupportedRefreshStatementContext) {
	localctx = NewSupportedRefreshStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, DorisParserRULE_supportedRefreshStatement)
	var _la int

	p.SetState(2952)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 394, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRefreshCatalogContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2927)
			p.Match(DorisParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2928)
			p.Match(DorisParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2929)

			var _x = p.Identifier()

			localctx.(*RefreshCatalogContext).name = _x
		}
		p.SetState(2931)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2930)
				p.PropertyClause()
			}

		}

	case 2:
		localctx = NewRefreshDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2933)
			p.Match(DorisParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2934)
			p.Match(DorisParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2935)

			var _x = p.MultipartIdentifier()

			localctx.(*RefreshDatabaseContext).name = _x
		}
		p.SetState(2937)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(2936)
				p.PropertyClause()
			}

		}

	case 3:
		localctx = NewRefreshTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2939)
			p.Match(DorisParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2940)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2941)

			var _x = p.MultipartIdentifier()

			localctx.(*RefreshTableContext).name = _x
		}

	case 4:
		localctx = NewRefreshDictionaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2942)
			p.Match(DorisParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2943)
			p.Match(DorisParserDICTIONARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2944)

			var _x = p.MultipartIdentifier()

			localctx.(*RefreshDictionaryContext).name = _x
		}

	case 5:
		localctx = NewRefreshLdapContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2945)
			p.Match(DorisParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2946)
			p.Match(DorisParserLDAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2950)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserALL:
			{
				p.SetState(2947)
				p.Match(DorisParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserFOR:
			{
				p.SetState(2948)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2949)

				var _x = p.IdentifierOrText()

				localctx.(*RefreshLdapContext).user = _x
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedCleanStatementContext is an interface to support dynamic dispatch.
type ISupportedCleanStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedCleanStatementContext differentiates from other interfaces.
	IsSupportedCleanStatementContext()
}

type SupportedCleanStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedCleanStatementContext() *SupportedCleanStatementContext {
	var p = new(SupportedCleanStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedCleanStatement
	return p
}

func InitEmptySupportedCleanStatementContext(p *SupportedCleanStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedCleanStatement
}

func (*SupportedCleanStatementContext) IsSupportedCleanStatementContext() {}

func NewSupportedCleanStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedCleanStatementContext {
	var p = new(SupportedCleanStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedCleanStatement

	return p
}

func (s *SupportedCleanStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedCleanStatementContext) CopyAll(ctx *SupportedCleanStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedCleanStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedCleanStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CleanLabelContext struct {
	SupportedCleanStatementContext
	label    IIdentifierContext
	database IIdentifierContext
}

func NewCleanLabelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CleanLabelContext {
	var p = new(CleanLabelContext)

	InitEmptySupportedCleanStatementContext(&p.SupportedCleanStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCleanStatementContext))

	return p
}

func (s *CleanLabelContext) GetLabel() IIdentifierContext { return s.label }

func (s *CleanLabelContext) GetDatabase() IIdentifierContext { return s.database }

func (s *CleanLabelContext) SetLabel(v IIdentifierContext) { s.label = v }

func (s *CleanLabelContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *CleanLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CleanLabelContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(DorisParserCLEAN, 0)
}

func (s *CleanLabelContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisParserLABEL, 0)
}

func (s *CleanLabelContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *CleanLabelContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *CleanLabelContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CleanLabelContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CleanLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCleanLabel(s)
	}
}

func (s *CleanLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCleanLabel(s)
	}
}

type CleanQueryStatsContext struct {
	SupportedCleanStatementContext
	database IIdentifierContext
	table    IMultipartIdentifierContext
}

func NewCleanQueryStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CleanQueryStatsContext {
	var p = new(CleanQueryStatsContext)

	InitEmptySupportedCleanStatementContext(&p.SupportedCleanStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCleanStatementContext))

	return p
}

func (s *CleanQueryStatsContext) GetDatabase() IIdentifierContext { return s.database }

func (s *CleanQueryStatsContext) GetTable() IMultipartIdentifierContext { return s.table }

func (s *CleanQueryStatsContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *CleanQueryStatsContext) SetTable(v IMultipartIdentifierContext) { s.table = v }

func (s *CleanQueryStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CleanQueryStatsContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(DorisParserCLEAN, 0)
}

func (s *CleanQueryStatsContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DorisParserQUERY, 0)
}

func (s *CleanQueryStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *CleanQueryStatsContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *CleanQueryStatsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CleanQueryStatsContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *CleanQueryStatsContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *CleanQueryStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CleanQueryStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCleanQueryStats(s)
	}
}

func (s *CleanQueryStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCleanQueryStats(s)
	}
}

type CleanAllProfileContext struct {
	SupportedCleanStatementContext
}

func NewCleanAllProfileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CleanAllProfileContext {
	var p = new(CleanAllProfileContext)

	InitEmptySupportedCleanStatementContext(&p.SupportedCleanStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCleanStatementContext))

	return p
}

func (s *CleanAllProfileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CleanAllProfileContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(DorisParserCLEAN, 0)
}

func (s *CleanAllProfileContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *CleanAllProfileContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserPROFILE, 0)
}

func (s *CleanAllProfileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCleanAllProfile(s)
	}
}

func (s *CleanAllProfileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCleanAllProfile(s)
	}
}

type CleanAllQueryStatsContext struct {
	SupportedCleanStatementContext
}

func NewCleanAllQueryStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CleanAllQueryStatsContext {
	var p = new(CleanAllQueryStatsContext)

	InitEmptySupportedCleanStatementContext(&p.SupportedCleanStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCleanStatementContext))

	return p
}

func (s *CleanAllQueryStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CleanAllQueryStatsContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(DorisParserCLEAN, 0)
}

func (s *CleanAllQueryStatsContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *CleanAllQueryStatsContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DorisParserQUERY, 0)
}

func (s *CleanAllQueryStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *CleanAllQueryStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCleanAllQueryStats(s)
	}
}

func (s *CleanAllQueryStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCleanAllQueryStats(s)
	}
}

func (p *DorisParser) SupportedCleanStatement() (localctx ISupportedCleanStatementContext) {
	localctx = NewSupportedCleanStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, DorisParserRULE_supportedCleanStatement)
	var _la int

	p.SetState(2977)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 397, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCleanAllProfileContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2954)
			p.Match(DorisParserCLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2955)
			p.Match(DorisParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2956)
			p.Match(DorisParserPROFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewCleanLabelContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2957)
			p.Match(DorisParserCLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2958)
			p.Match(DorisParserLABEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2960)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305902462020672000) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4609989332399152113) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4540397275156637211) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&2557745532860070517) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&8545544968972265069) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-305714810442809349) != 0) || ((int64((_la-391)) & ^0x3f) == 0 && ((int64(1)<<(_la-391))&1188948054525294943) != 0) || ((int64((_la-455)) & ^0x3f) == 0 && ((int64(1)<<(_la-455))&2458964612221191023) != 0) || ((int64((_la-538)) & ^0x3f) == 0 && ((int64(1)<<(_la-538))&49159) != 0) {
			{
				p.SetState(2959)

				var _x = p.Identifier()

				localctx.(*CleanLabelContext).label = _x
			}

		}
		{
			p.SetState(2962)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserFROM || _la == DorisParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2963)

			var _x = p.Identifier()

			localctx.(*CleanLabelContext).database = _x
		}

	case 3:
		localctx = NewCleanQueryStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2964)
			p.Match(DorisParserCLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2965)
			p.Match(DorisParserQUERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2966)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2971)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserFOR:
			{
				p.SetState(2967)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2968)

				var _x = p.Identifier()

				localctx.(*CleanQueryStatsContext).database = _x
			}

		case DorisParserFROM, DorisParserIN:
			{
				p.SetState(2969)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2970)

				var _x = p.MultipartIdentifier()

				localctx.(*CleanQueryStatsContext).table = _x
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 4:
		localctx = NewCleanAllQueryStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2973)
			p.Match(DorisParserCLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2974)
			p.Match(DorisParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2975)
			p.Match(DorisParserQUERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2976)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedCancelStatementContext is an interface to support dynamic dispatch.
type ISupportedCancelStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedCancelStatementContext differentiates from other interfaces.
	IsSupportedCancelStatementContext()
}

type SupportedCancelStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedCancelStatementContext() *SupportedCancelStatementContext {
	var p = new(SupportedCancelStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedCancelStatement
	return p
}

func InitEmptySupportedCancelStatementContext(p *SupportedCancelStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedCancelStatement
}

func (*SupportedCancelStatementContext) IsSupportedCancelStatementContext() {}

func NewSupportedCancelStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedCancelStatementContext {
	var p = new(SupportedCancelStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedCancelStatement

	return p
}

func (s *SupportedCancelStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedCancelStatementContext) CopyAll(ctx *SupportedCancelStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedCancelStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedCancelStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CancelBackupContext struct {
	SupportedCancelStatementContext
	database IIdentifierContext
}

func NewCancelBackupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelBackupContext {
	var p = new(CancelBackupContext)

	InitEmptySupportedCancelStatementContext(&p.SupportedCancelStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCancelStatementContext))

	return p
}

func (s *CancelBackupContext) GetDatabase() IIdentifierContext { return s.database }

func (s *CancelBackupContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *CancelBackupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelBackupContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *CancelBackupContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKUP, 0)
}

func (s *CancelBackupContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *CancelBackupContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *CancelBackupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelBackupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCancelBackup(s)
	}
}

func (s *CancelBackupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCancelBackup(s)
	}
}

type CancelWarmUpJobContext struct {
	SupportedCancelStatementContext
}

func NewCancelWarmUpJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelWarmUpJobContext {
	var p = new(CancelWarmUpJobContext)

	InitEmptySupportedCancelStatementContext(&p.SupportedCancelStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCancelStatementContext))

	return p
}

func (s *CancelWarmUpJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelWarmUpJobContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *CancelWarmUpJobContext) WARM() antlr.TerminalNode {
	return s.GetToken(DorisParserWARM, 0)
}

func (s *CancelWarmUpJobContext) UP() antlr.TerminalNode {
	return s.GetToken(DorisParserUP, 0)
}

func (s *CancelWarmUpJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *CancelWarmUpJobContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *CancelWarmUpJobContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCancelWarmUpJob(s)
	}
}

func (s *CancelWarmUpJobContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCancelWarmUpJob(s)
	}
}

type CancelExportContext struct {
	SupportedCancelStatementContext
	database IIdentifierContext
}

func NewCancelExportContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelExportContext {
	var p = new(CancelExportContext)

	InitEmptySupportedCancelStatementContext(&p.SupportedCancelStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCancelStatementContext))

	return p
}

func (s *CancelExportContext) GetDatabase() IIdentifierContext { return s.database }

func (s *CancelExportContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *CancelExportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelExportContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *CancelExportContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(DorisParserEXPORT, 0)
}

func (s *CancelExportContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *CancelExportContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *CancelExportContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *CancelExportContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelExportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCancelExport(s)
	}
}

func (s *CancelExportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCancelExport(s)
	}
}

type CancelBuildIndexContext struct {
	SupportedCancelStatementContext
	tableName      IMultipartIdentifierContext
	_INTEGER_VALUE antlr.Token
	jobIds         []antlr.Token
}

func NewCancelBuildIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelBuildIndexContext {
	var p = new(CancelBuildIndexContext)

	InitEmptySupportedCancelStatementContext(&p.SupportedCancelStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCancelStatementContext))

	return p
}

func (s *CancelBuildIndexContext) Get_INTEGER_VALUE() antlr.Token { return s._INTEGER_VALUE }

func (s *CancelBuildIndexContext) Set_INTEGER_VALUE(v antlr.Token) { s._INTEGER_VALUE = v }

func (s *CancelBuildIndexContext) GetJobIds() []antlr.Token { return s.jobIds }

func (s *CancelBuildIndexContext) SetJobIds(v []antlr.Token) { s.jobIds = v }

func (s *CancelBuildIndexContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *CancelBuildIndexContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *CancelBuildIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelBuildIndexContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *CancelBuildIndexContext) BUILD() antlr.TerminalNode {
	return s.GetToken(DorisParserBUILD, 0)
}

func (s *CancelBuildIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *CancelBuildIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *CancelBuildIndexContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CancelBuildIndexContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CancelBuildIndexContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CancelBuildIndexContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserINTEGER_VALUE)
}

func (s *CancelBuildIndexContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, i)
}

func (s *CancelBuildIndexContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *CancelBuildIndexContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *CancelBuildIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCancelBuildIndex(s)
	}
}

func (s *CancelBuildIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCancelBuildIndex(s)
	}
}

type CancelRestoreContext struct {
	SupportedCancelStatementContext
	database IIdentifierContext
}

func NewCancelRestoreContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelRestoreContext {
	var p = new(CancelRestoreContext)

	InitEmptySupportedCancelStatementContext(&p.SupportedCancelStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCancelStatementContext))

	return p
}

func (s *CancelRestoreContext) GetDatabase() IIdentifierContext { return s.database }

func (s *CancelRestoreContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *CancelRestoreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelRestoreContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *CancelRestoreContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESTORE, 0)
}

func (s *CancelRestoreContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *CancelRestoreContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *CancelRestoreContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelRestoreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCancelRestore(s)
	}
}

func (s *CancelRestoreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCancelRestore(s)
	}
}

type CancelLoadContext struct {
	SupportedCancelStatementContext
	database IIdentifierContext
}

func NewCancelLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelLoadContext {
	var p = new(CancelLoadContext)

	InitEmptySupportedCancelStatementContext(&p.SupportedCancelStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCancelStatementContext))

	return p
}

func (s *CancelLoadContext) GetDatabase() IIdentifierContext { return s.database }

func (s *CancelLoadContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *CancelLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelLoadContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *CancelLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *CancelLoadContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *CancelLoadContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *CancelLoadContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *CancelLoadContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCancelLoad(s)
	}
}

func (s *CancelLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCancelLoad(s)
	}
}

type CancelDecommisionBackendContext struct {
	SupportedCancelStatementContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
}

func NewCancelDecommisionBackendContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelDecommisionBackendContext {
	var p = new(CancelDecommisionBackendContext)

	InitEmptySupportedCancelStatementContext(&p.SupportedCancelStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCancelStatementContext))

	return p
}

func (s *CancelDecommisionBackendContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *CancelDecommisionBackendContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *CancelDecommisionBackendContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *CancelDecommisionBackendContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *CancelDecommisionBackendContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelDecommisionBackendContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *CancelDecommisionBackendContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(DorisParserDECOMMISSION, 0)
}

func (s *CancelDecommisionBackendContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKEND, 0)
}

func (s *CancelDecommisionBackendContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *CancelDecommisionBackendContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *CancelDecommisionBackendContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *CancelDecommisionBackendContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *CancelDecommisionBackendContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCancelDecommisionBackend(s)
	}
}

func (s *CancelDecommisionBackendContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCancelDecommisionBackend(s)
	}
}

type CancelAlterTableContext struct {
	SupportedCancelStatementContext
	tableName      IMultipartIdentifierContext
	_INTEGER_VALUE antlr.Token
	jobIds         []antlr.Token
}

func NewCancelAlterTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelAlterTableContext {
	var p = new(CancelAlterTableContext)

	InitEmptySupportedCancelStatementContext(&p.SupportedCancelStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCancelStatementContext))

	return p
}

func (s *CancelAlterTableContext) Get_INTEGER_VALUE() antlr.Token { return s._INTEGER_VALUE }

func (s *CancelAlterTableContext) Set_INTEGER_VALUE(v antlr.Token) { s._INTEGER_VALUE = v }

func (s *CancelAlterTableContext) GetJobIds() []antlr.Token { return s.jobIds }

func (s *CancelAlterTableContext) SetJobIds(v []antlr.Token) { s.jobIds = v }

func (s *CancelAlterTableContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *CancelAlterTableContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *CancelAlterTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelAlterTableContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *CancelAlterTableContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *CancelAlterTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *CancelAlterTableContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *CancelAlterTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CancelAlterTableContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *CancelAlterTableContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *CancelAlterTableContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CancelAlterTableContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CancelAlterTableContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *CancelAlterTableContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *CancelAlterTableContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserINTEGER_VALUE)
}

func (s *CancelAlterTableContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, i)
}

func (s *CancelAlterTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *CancelAlterTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *CancelAlterTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCancelAlterTable(s)
	}
}

func (s *CancelAlterTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCancelAlterTable(s)
	}
}

func (p *DorisParser) SupportedCancelStatement() (localctx ISupportedCancelStatementContext) {
	localctx = NewSupportedCancelStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, DorisParserRULE_supportedCancelStatement)
	var _la int

	p.SetState(3067)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 411, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCancelLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2979)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2980)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2983)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2981)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2982)

				var _x = p.Identifier()

				localctx.(*CancelLoadContext).database = _x
			}

		}
		p.SetState(2986)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2985)
				p.WildWhere()
			}

		}

	case 2:
		localctx = NewCancelExportContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2988)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2989)
			p.Match(DorisParserEXPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2992)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(2990)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2991)

				var _x = p.Identifier()

				localctx.(*CancelExportContext).database = _x
			}

		}
		p.SetState(2995)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(2994)
				p.WildWhere()
			}

		}

	case 3:
		localctx = NewCancelWarmUpJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2997)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2998)
			p.Match(DorisParserWARM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2999)
			p.Match(DorisParserUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3000)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3002)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLIKE || _la == DorisParserWHERE {
			{
				p.SetState(3001)
				p.WildWhere()
			}

		}

	case 4:
		localctx = NewCancelDecommisionBackendContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3004)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3005)
			p.Match(DorisParserDECOMMISSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3006)
			p.Match(DorisParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3007)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*CancelDecommisionBackendContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*CancelDecommisionBackendContext).hostPorts = append(localctx.(*CancelDecommisionBackendContext).hostPorts, localctx.(*CancelDecommisionBackendContext)._STRING_LITERAL)
		p.SetState(3012)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(3008)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3009)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*CancelDecommisionBackendContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*CancelDecommisionBackendContext).hostPorts = append(localctx.(*CancelDecommisionBackendContext).hostPorts, localctx.(*CancelDecommisionBackendContext)._STRING_LITERAL)

			p.SetState(3014)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 5:
		localctx = NewCancelBackupContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3015)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3016)
			p.Match(DorisParserBACKUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3019)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(3017)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(3018)

				var _x = p.Identifier()

				localctx.(*CancelBackupContext).database = _x
			}

		}

	case 6:
		localctx = NewCancelRestoreContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3021)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3022)
			p.Match(DorisParserRESTORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3025)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM || _la == DorisParserIN {
			{
				p.SetState(3023)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserFROM || _la == DorisParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(3024)

				var _x = p.Identifier()

				localctx.(*CancelRestoreContext).database = _x
			}

		}

	case 7:
		localctx = NewCancelBuildIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3027)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3028)
			p.Match(DorisParserBUILD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3029)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3030)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3031)

			var _x = p.MultipartIdentifier()

			localctx.(*CancelBuildIndexContext).tableName = _x
		}
		p.SetState(3042)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(3032)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3033)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*CancelBuildIndexContext)._INTEGER_VALUE = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*CancelBuildIndexContext).jobIds = append(localctx.(*CancelBuildIndexContext).jobIds, localctx.(*CancelBuildIndexContext)._INTEGER_VALUE)
			p.SetState(3038)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(3034)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3035)

					var _m = p.Match(DorisParserINTEGER_VALUE)

					localctx.(*CancelBuildIndexContext)._INTEGER_VALUE = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*CancelBuildIndexContext).jobIds = append(localctx.(*CancelBuildIndexContext).jobIds, localctx.(*CancelBuildIndexContext)._INTEGER_VALUE)

				p.SetState(3040)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3041)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 8:
		localctx = NewCancelAlterTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3044)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3045)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3046)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3051)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserROLLUP:
			{
				p.SetState(3047)
				p.Match(DorisParserROLLUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserMATERIALIZED:
			{
				p.SetState(3048)
				p.Match(DorisParserMATERIALIZED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3049)
				p.Match(DorisParserVIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCOLUMN:
			{
				p.SetState(3050)
				p.Match(DorisParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(3053)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3054)

			var _x = p.MultipartIdentifier()

			localctx.(*CancelAlterTableContext).tableName = _x
		}
		p.SetState(3065)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(3055)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3056)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*CancelAlterTableContext)._INTEGER_VALUE = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*CancelAlterTableContext).jobIds = append(localctx.(*CancelAlterTableContext).jobIds, localctx.(*CancelAlterTableContext)._INTEGER_VALUE)
			p.SetState(3061)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(3057)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3058)

					var _m = p.Match(DorisParserINTEGER_VALUE)

					localctx.(*CancelAlterTableContext)._INTEGER_VALUE = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*CancelAlterTableContext).jobIds = append(localctx.(*CancelAlterTableContext).jobIds, localctx.(*CancelAlterTableContext)._INTEGER_VALUE)

				p.SetState(3063)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3064)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedAdminStatementContext is an interface to support dynamic dispatch.
type ISupportedAdminStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedAdminStatementContext differentiates from other interfaces.
	IsSupportedAdminStatementContext()
}

type SupportedAdminStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedAdminStatementContext() *SupportedAdminStatementContext {
	var p = new(SupportedAdminStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedAdminStatement
	return p
}

func InitEmptySupportedAdminStatementContext(p *SupportedAdminStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedAdminStatement
}

func (*SupportedAdminStatementContext) IsSupportedAdminStatementContext() {}

func NewSupportedAdminStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedAdminStatementContext {
	var p = new(SupportedAdminStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedAdminStatement

	return p
}

func (s *SupportedAdminStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedAdminStatementContext) CopyAll(ctx *SupportedAdminStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedAdminStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedAdminStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AdminShowReplicaDistributionContext struct {
	SupportedAdminStatementContext
}

func NewAdminShowReplicaDistributionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminShowReplicaDistributionContext {
	var p = new(AdminShowReplicaDistributionContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminShowReplicaDistributionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminShowReplicaDistributionContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminShowReplicaDistributionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *AdminShowReplicaDistributionContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLICA, 0)
}

func (s *AdminShowReplicaDistributionContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTRIBUTION, 0)
}

func (s *AdminShowReplicaDistributionContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *AdminShowReplicaDistributionContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *AdminShowReplicaDistributionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminShowReplicaDistribution(s)
	}
}

func (s *AdminShowReplicaDistributionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminShowReplicaDistribution(s)
	}
}

type AdminShowTabletStorageFormatContext struct {
	SupportedAdminStatementContext
}

func NewAdminShowTabletStorageFormatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminShowTabletStorageFormatContext {
	var p = new(AdminShowTabletStorageFormatContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminShowTabletStorageFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminShowTabletStorageFormatContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminShowTabletStorageFormatContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *AdminShowTabletStorageFormatContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLET, 0)
}

func (s *AdminShowTabletStorageFormatContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *AdminShowTabletStorageFormatContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DorisParserFORMAT, 0)
}

func (s *AdminShowTabletStorageFormatContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserVERBOSE, 0)
}

func (s *AdminShowTabletStorageFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminShowTabletStorageFormat(s)
	}
}

func (s *AdminShowTabletStorageFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminShowTabletStorageFormat(s)
	}
}

type AdminRebalanceDiskContext struct {
	SupportedAdminStatementContext
	_STRING_LITERAL antlr.Token
	backends        []antlr.Token
}

func NewAdminRebalanceDiskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminRebalanceDiskContext {
	var p = new(AdminRebalanceDiskContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminRebalanceDiskContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *AdminRebalanceDiskContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *AdminRebalanceDiskContext) GetBackends() []antlr.Token { return s.backends }

func (s *AdminRebalanceDiskContext) SetBackends(v []antlr.Token) { s.backends = v }

func (s *AdminRebalanceDiskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminRebalanceDiskContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminRebalanceDiskContext) REBALANCE() antlr.TerminalNode {
	return s.GetToken(DorisParserREBALANCE, 0)
}

func (s *AdminRebalanceDiskContext) DISK() antlr.TerminalNode {
	return s.GetToken(DorisParserDISK, 0)
}

func (s *AdminRebalanceDiskContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *AdminRebalanceDiskContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AdminRebalanceDiskContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AdminRebalanceDiskContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *AdminRebalanceDiskContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *AdminRebalanceDiskContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AdminRebalanceDiskContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AdminRebalanceDiskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminRebalanceDisk(s)
	}
}

func (s *AdminRebalanceDiskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminRebalanceDisk(s)
	}
}

type AdminSetReplicaStatusContext struct {
	SupportedAdminStatementContext
}

func NewAdminSetReplicaStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminSetReplicaStatusContext {
	var p = new(AdminSetReplicaStatusContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminSetReplicaStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetReplicaStatusContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminSetReplicaStatusContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AdminSetReplicaStatusContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLICA, 0)
}

func (s *AdminSetReplicaStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATUS, 0)
}

func (s *AdminSetReplicaStatusContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *AdminSetReplicaStatusContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AdminSetReplicaStatusContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AdminSetReplicaStatusContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AdminSetReplicaStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminSetReplicaStatus(s)
	}
}

func (s *AdminSetReplicaStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminSetReplicaStatus(s)
	}
}

type AdminSetReplicaVersionContext struct {
	SupportedAdminStatementContext
}

func NewAdminSetReplicaVersionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminSetReplicaVersionContext {
	var p = new(AdminSetReplicaVersionContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminSetReplicaVersionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetReplicaVersionContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminSetReplicaVersionContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AdminSetReplicaVersionContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLICA, 0)
}

func (s *AdminSetReplicaVersionContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisParserVERSION, 0)
}

func (s *AdminSetReplicaVersionContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *AdminSetReplicaVersionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AdminSetReplicaVersionContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AdminSetReplicaVersionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AdminSetReplicaVersionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminSetReplicaVersion(s)
	}
}

func (s *AdminSetReplicaVersionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminSetReplicaVersion(s)
	}
}

type AdminSetTableStatusContext struct {
	SupportedAdminStatementContext
	name       IMultipartIdentifierContext
	properties IPropertyClauseContext
}

func NewAdminSetTableStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminSetTableStatusContext {
	var p = new(AdminSetTableStatusContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminSetTableStatusContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AdminSetTableStatusContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AdminSetTableStatusContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AdminSetTableStatusContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AdminSetTableStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetTableStatusContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminSetTableStatusContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AdminSetTableStatusContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AdminSetTableStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATUS, 0)
}

func (s *AdminSetTableStatusContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AdminSetTableStatusContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AdminSetTableStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminSetTableStatus(s)
	}
}

func (s *AdminSetTableStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminSetTableStatus(s)
	}
}

type AdminCancelRepairTableContext struct {
	SupportedAdminStatementContext
}

func NewAdminCancelRepairTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminCancelRepairTableContext {
	var p = new(AdminCancelRepairTableContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminCancelRepairTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCancelRepairTableContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminCancelRepairTableContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *AdminCancelRepairTableContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(DorisParserREPAIR, 0)
}

func (s *AdminCancelRepairTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AdminCancelRepairTableContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *AdminCancelRepairTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminCancelRepairTable(s)
	}
}

func (s *AdminCancelRepairTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminCancelRepairTable(s)
	}
}

type AdminCopyTabletContext struct {
	SupportedAdminStatementContext
	tabletId   antlr.Token
	properties IPropertyClauseContext
}

func NewAdminCopyTabletContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminCopyTabletContext {
	var p = new(AdminCopyTabletContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminCopyTabletContext) GetTabletId() antlr.Token { return s.tabletId }

func (s *AdminCopyTabletContext) SetTabletId(v antlr.Token) { s.tabletId = v }

func (s *AdminCopyTabletContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AdminCopyTabletContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AdminCopyTabletContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCopyTabletContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminCopyTabletContext) COPY() antlr.TerminalNode {
	return s.GetToken(DorisParserCOPY, 0)
}

func (s *AdminCopyTabletContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLET, 0)
}

func (s *AdminCopyTabletContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *AdminCopyTabletContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AdminCopyTabletContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminCopyTablet(s)
	}
}

func (s *AdminCopyTabletContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminCopyTablet(s)
	}
}

type AdminRepairTableContext struct {
	SupportedAdminStatementContext
}

func NewAdminRepairTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminRepairTableContext {
	var p = new(AdminRepairTableContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminRepairTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminRepairTableContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminRepairTableContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(DorisParserREPAIR, 0)
}

func (s *AdminRepairTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AdminRepairTableContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *AdminRepairTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminRepairTable(s)
	}
}

func (s *AdminRepairTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminRepairTable(s)
	}
}

type AdminSetFrontendConfigContext struct {
	SupportedAdminStatementContext
}

func NewAdminSetFrontendConfigContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminSetFrontendConfigContext {
	var p = new(AdminSetFrontendConfigContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminSetFrontendConfigContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetFrontendConfigContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminSetFrontendConfigContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AdminSetFrontendConfigContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(DorisParserCONFIG, 0)
}

func (s *AdminSetFrontendConfigContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(DorisParserFRONTEND, 0)
}

func (s *AdminSetFrontendConfigContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AdminSetFrontendConfigContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AdminSetFrontendConfigContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AdminSetFrontendConfigContext) AllALL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserALL)
}

func (s *AdminSetFrontendConfigContext) ALL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserALL, i)
}

func (s *AdminSetFrontendConfigContext) FRONTENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserFRONTENDS, 0)
}

func (s *AdminSetFrontendConfigContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminSetFrontendConfig(s)
	}
}

func (s *AdminSetFrontendConfigContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminSetFrontendConfig(s)
	}
}

type AdminCheckTabletsContext struct {
	SupportedAdminStatementContext
	properties IPropertyClauseContext
}

func NewAdminCheckTabletsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminCheckTabletsContext {
	var p = new(AdminCheckTabletsContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminCheckTabletsContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AdminCheckTabletsContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AdminCheckTabletsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCheckTabletsContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminCheckTabletsContext) CHECK() antlr.TerminalNode {
	return s.GetToken(DorisParserCHECK, 0)
}

func (s *AdminCheckTabletsContext) TabletList() ITabletListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabletListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabletListContext)
}

func (s *AdminCheckTabletsContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AdminCheckTabletsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminCheckTablets(s)
	}
}

func (s *AdminCheckTabletsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminCheckTablets(s)
	}
}

type AdminCleanTrashContext struct {
	SupportedAdminStatementContext
	_STRING_LITERAL antlr.Token
	backends        []antlr.Token
}

func NewAdminCleanTrashContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminCleanTrashContext {
	var p = new(AdminCleanTrashContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminCleanTrashContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *AdminCleanTrashContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *AdminCleanTrashContext) GetBackends() []antlr.Token { return s.backends }

func (s *AdminCleanTrashContext) SetBackends(v []antlr.Token) { s.backends = v }

func (s *AdminCleanTrashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCleanTrashContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminCleanTrashContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(DorisParserCLEAN, 0)
}

func (s *AdminCleanTrashContext) TRASH() antlr.TerminalNode {
	return s.GetToken(DorisParserTRASH, 0)
}

func (s *AdminCleanTrashContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *AdminCleanTrashContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AdminCleanTrashContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AdminCleanTrashContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *AdminCleanTrashContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *AdminCleanTrashContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AdminCleanTrashContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AdminCleanTrashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminCleanTrash(s)
	}
}

func (s *AdminCleanTrashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminCleanTrash(s)
	}
}

type AdminCompactTableContext struct {
	SupportedAdminStatementContext
}

func NewAdminCompactTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminCompactTableContext {
	var p = new(AdminCompactTableContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminCompactTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCompactTableContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminCompactTableContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPACT, 0)
}

func (s *AdminCompactTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AdminCompactTableContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *AdminCompactTableContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserWHERE, 0)
}

func (s *AdminCompactTableContext) TYPE() antlr.TerminalNode {
	return s.GetToken(DorisParserTYPE, 0)
}

func (s *AdminCompactTableContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *AdminCompactTableContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *AdminCompactTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminCompactTable(s)
	}
}

func (s *AdminCompactTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminCompactTable(s)
	}
}

type AdminDiagnoseTabletContext struct {
	SupportedAdminStatementContext
	tabletId antlr.Token
}

func NewAdminDiagnoseTabletContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminDiagnoseTabletContext {
	var p = new(AdminDiagnoseTabletContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminDiagnoseTabletContext) GetTabletId() antlr.Token { return s.tabletId }

func (s *AdminDiagnoseTabletContext) SetTabletId(v antlr.Token) { s.tabletId = v }

func (s *AdminDiagnoseTabletContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminDiagnoseTabletContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminDiagnoseTabletContext) DIAGNOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserDIAGNOSE, 0)
}

func (s *AdminDiagnoseTabletContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLET, 0)
}

func (s *AdminDiagnoseTabletContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *AdminDiagnoseTabletContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminDiagnoseTablet(s)
	}
}

func (s *AdminDiagnoseTabletContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminDiagnoseTablet(s)
	}
}

type AdminCancelRebalanceDiskContext struct {
	SupportedAdminStatementContext
	_STRING_LITERAL antlr.Token
	backends        []antlr.Token
}

func NewAdminCancelRebalanceDiskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminCancelRebalanceDiskContext {
	var p = new(AdminCancelRebalanceDiskContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminCancelRebalanceDiskContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *AdminCancelRebalanceDiskContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *AdminCancelRebalanceDiskContext) GetBackends() []antlr.Token { return s.backends }

func (s *AdminCancelRebalanceDiskContext) SetBackends(v []antlr.Token) { s.backends = v }

func (s *AdminCancelRebalanceDiskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCancelRebalanceDiskContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminCancelRebalanceDiskContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserCANCEL, 0)
}

func (s *AdminCancelRebalanceDiskContext) REBALANCE() antlr.TerminalNode {
	return s.GetToken(DorisParserREBALANCE, 0)
}

func (s *AdminCancelRebalanceDiskContext) DISK() antlr.TerminalNode {
	return s.GetToken(DorisParserDISK, 0)
}

func (s *AdminCancelRebalanceDiskContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *AdminCancelRebalanceDiskContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AdminCancelRebalanceDiskContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AdminCancelRebalanceDiskContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *AdminCancelRebalanceDiskContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *AdminCancelRebalanceDiskContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AdminCancelRebalanceDiskContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AdminCancelRebalanceDiskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminCancelRebalanceDisk(s)
	}
}

func (s *AdminCancelRebalanceDiskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminCancelRebalanceDisk(s)
	}
}

type AdminShowReplicaStatusContext struct {
	SupportedAdminStatementContext
}

func NewAdminShowReplicaStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminShowReplicaStatusContext {
	var p = new(AdminShowReplicaStatusContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminShowReplicaStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminShowReplicaStatusContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminShowReplicaStatusContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *AdminShowReplicaStatusContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLICA, 0)
}

func (s *AdminShowReplicaStatusContext) AllSTATUS() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTATUS)
}

func (s *AdminShowReplicaStatusContext) STATUS(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTATUS, i)
}

func (s *AdminShowReplicaStatusContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *AdminShowReplicaStatusContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *AdminShowReplicaStatusContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserWHERE, 0)
}

func (s *AdminShowReplicaStatusContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *AdminShowReplicaStatusContext) NEQ() antlr.TerminalNode {
	return s.GetToken(DorisParserNEQ, 0)
}

func (s *AdminShowReplicaStatusContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *AdminShowReplicaStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminShowReplicaStatus(s)
	}
}

func (s *AdminShowReplicaStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminShowReplicaStatus(s)
	}
}

func (p *DorisParser) SupportedAdminStatement() (localctx ISupportedAdminStatementContext) {
	localctx = NewSupportedAdminStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, DorisParserRULE_supportedAdminStatement)
	var _la int

	p.SetState(3224)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 427, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAdminShowReplicaDistributionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3069)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3070)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3071)
			p.Match(DorisParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3072)
			p.Match(DorisParserDISTRIBUTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3073)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3074)
			p.BaseTableRef()
		}

	case 2:
		localctx = NewAdminRebalanceDiskContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3075)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3076)
			p.Match(DorisParserREBALANCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3077)
			p.Match(DorisParserDISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3089)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserON {
			{
				p.SetState(3078)
				p.Match(DorisParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3079)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3080)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*AdminRebalanceDiskContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*AdminRebalanceDiskContext).backends = append(localctx.(*AdminRebalanceDiskContext).backends, localctx.(*AdminRebalanceDiskContext)._STRING_LITERAL)
			p.SetState(3085)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(3081)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3082)

					var _m = p.Match(DorisParserSTRING_LITERAL)

					localctx.(*AdminRebalanceDiskContext)._STRING_LITERAL = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*AdminRebalanceDiskContext).backends = append(localctx.(*AdminRebalanceDiskContext).backends, localctx.(*AdminRebalanceDiskContext)._STRING_LITERAL)

				p.SetState(3087)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3088)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		localctx = NewAdminCancelRebalanceDiskContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3091)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3092)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3093)
			p.Match(DorisParserREBALANCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3094)
			p.Match(DorisParserDISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3106)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserON {
			{
				p.SetState(3095)
				p.Match(DorisParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3096)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3097)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*AdminCancelRebalanceDiskContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*AdminCancelRebalanceDiskContext).backends = append(localctx.(*AdminCancelRebalanceDiskContext).backends, localctx.(*AdminCancelRebalanceDiskContext)._STRING_LITERAL)
			p.SetState(3102)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(3098)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3099)

					var _m = p.Match(DorisParserSTRING_LITERAL)

					localctx.(*AdminCancelRebalanceDiskContext)._STRING_LITERAL = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*AdminCancelRebalanceDiskContext).backends = append(localctx.(*AdminCancelRebalanceDiskContext).backends, localctx.(*AdminCancelRebalanceDiskContext)._STRING_LITERAL)

				p.SetState(3104)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3105)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		localctx = NewAdminDiagnoseTabletContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3108)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3109)
			p.Match(DorisParserDIAGNOSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3110)
			p.Match(DorisParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3111)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*AdminDiagnoseTabletContext).tabletId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewAdminShowReplicaStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3112)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3113)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3114)
			p.Match(DorisParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3115)
			p.Match(DorisParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3116)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3117)
			p.BaseTableRef()
		}
		p.SetState(3123)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case DorisParserWHERE:
			{
				p.SetState(3118)
				p.Match(DorisParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3119)
				p.Match(DorisParserSTATUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3120)
				p.Match(DorisParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserNEQ:
			{
				p.SetState(3121)
				p.Match(DorisParserNEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3122)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserEOF, DorisParserSEMICOLON:

		default:
		}

	case 6:
		localctx = NewAdminCompactTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3125)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3126)
			p.Match(DorisParserCOMPACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3127)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3128)
			p.BaseTableRef()
		}
		p.SetState(3133)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWHERE {
			{
				p.SetState(3129)
				p.Match(DorisParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3130)
				p.Match(DorisParserTYPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3131)
				p.Match(DorisParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3132)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 7:
		localctx = NewAdminCheckTabletsContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3135)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3136)
			p.Match(DorisParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3137)
			p.TabletList()
		}
		p.SetState(3139)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3138)

				var _x = p.PropertyClause()

				localctx.(*AdminCheckTabletsContext).properties = _x
			}

		}

	case 8:
		localctx = NewAdminShowTabletStorageFormatContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3141)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3142)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3143)
			p.Match(DorisParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3144)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3145)
			p.Match(DorisParserFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3147)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserVERBOSE {
			{
				p.SetState(3146)
				p.Match(DorisParserVERBOSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 9:
		localctx = NewAdminSetFrontendConfigContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3149)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3150)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3154)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserFRONTEND:
			{
				p.SetState(3151)
				p.Match(DorisParserFRONTEND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserALL:
			{
				p.SetState(3152)
				p.Match(DorisParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3153)
				p.Match(DorisParserFRONTENDS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(3156)
			p.Match(DorisParserCONFIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3161)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(3157)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3158)
				p.PropertyItemList()
			}
			{
				p.SetState(3159)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3164)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserALL {
			{
				p.SetState(3163)
				p.Match(DorisParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 10:
		localctx = NewAdminCleanTrashContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3166)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3167)
			p.Match(DorisParserCLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3168)
			p.Match(DorisParserTRASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3180)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserON {
			{
				p.SetState(3169)
				p.Match(DorisParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3170)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3171)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*AdminCleanTrashContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*AdminCleanTrashContext).backends = append(localctx.(*AdminCleanTrashContext).backends, localctx.(*AdminCleanTrashContext)._STRING_LITERAL)
			p.SetState(3176)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(3172)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3173)

					var _m = p.Match(DorisParserSTRING_LITERAL)

					localctx.(*AdminCleanTrashContext)._STRING_LITERAL = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*AdminCleanTrashContext).backends = append(localctx.(*AdminCleanTrashContext).backends, localctx.(*AdminCleanTrashContext)._STRING_LITERAL)

				p.SetState(3178)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3179)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 11:
		localctx = NewAdminSetReplicaVersionContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3182)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3183)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3184)
			p.Match(DorisParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3185)
			p.Match(DorisParserVERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3186)
			p.Match(DorisParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3187)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3188)
			p.PropertyItemList()
		}
		{
			p.SetState(3189)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewAdminSetTableStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3191)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3192)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3193)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3194)

			var _x = p.MultipartIdentifier()

			localctx.(*AdminSetTableStatusContext).name = _x
		}
		{
			p.SetState(3195)
			p.Match(DorisParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3197)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3196)

				var _x = p.PropertyClause()

				localctx.(*AdminSetTableStatusContext).properties = _x
			}

		}

	case 13:
		localctx = NewAdminSetReplicaStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3199)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3200)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3201)
			p.Match(DorisParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3202)
			p.Match(DorisParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3203)
			p.Match(DorisParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3204)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3205)
			p.PropertyItemList()
		}
		{
			p.SetState(3206)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		localctx = NewAdminRepairTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3208)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3209)
			p.Match(DorisParserREPAIR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3210)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3211)
			p.BaseTableRef()
		}

	case 15:
		localctx = NewAdminCancelRepairTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3212)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3213)
			p.Match(DorisParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3214)
			p.Match(DorisParserREPAIR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3215)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3216)
			p.BaseTableRef()
		}

	case 16:
		localctx = NewAdminCopyTabletContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3217)
			p.Match(DorisParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3218)
			p.Match(DorisParserCOPY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3219)
			p.Match(DorisParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3220)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*AdminCopyTabletContext).tabletId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3222)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3221)

				var _x = p.PropertyClause()

				localctx.(*AdminCopyTabletContext).properties = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedRecoverStatementContext is an interface to support dynamic dispatch.
type ISupportedRecoverStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedRecoverStatementContext differentiates from other interfaces.
	IsSupportedRecoverStatementContext()
}

type SupportedRecoverStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedRecoverStatementContext() *SupportedRecoverStatementContext {
	var p = new(SupportedRecoverStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedRecoverStatement
	return p
}

func InitEmptySupportedRecoverStatementContext(p *SupportedRecoverStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedRecoverStatement
}

func (*SupportedRecoverStatementContext) IsSupportedRecoverStatementContext() {}

func NewSupportedRecoverStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedRecoverStatementContext {
	var p = new(SupportedRecoverStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedRecoverStatement

	return p
}

func (s *SupportedRecoverStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedRecoverStatementContext) CopyAll(ctx *SupportedRecoverStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedRecoverStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedRecoverStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RecoverPartitionContext struct {
	SupportedRecoverStatementContext
	name      IIdentifierContext
	id        antlr.Token
	alias     IIdentifierContext
	tableName IMultipartIdentifierContext
}

func NewRecoverPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RecoverPartitionContext {
	var p = new(RecoverPartitionContext)

	InitEmptySupportedRecoverStatementContext(&p.SupportedRecoverStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedRecoverStatementContext))

	return p
}

func (s *RecoverPartitionContext) GetId() antlr.Token { return s.id }

func (s *RecoverPartitionContext) SetId(v antlr.Token) { s.id = v }

func (s *RecoverPartitionContext) GetName() IIdentifierContext { return s.name }

func (s *RecoverPartitionContext) GetAlias() IIdentifierContext { return s.alias }

func (s *RecoverPartitionContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *RecoverPartitionContext) SetName(v IIdentifierContext) { s.name = v }

func (s *RecoverPartitionContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *RecoverPartitionContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *RecoverPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecoverPartitionContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(DorisParserRECOVER, 0)
}

func (s *RecoverPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *RecoverPartitionContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *RecoverPartitionContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RecoverPartitionContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RecoverPartitionContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *RecoverPartitionContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *RecoverPartitionContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *RecoverPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRecoverPartition(s)
	}
}

func (s *RecoverPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRecoverPartition(s)
	}
}

type RecoverTableContext struct {
	SupportedRecoverStatementContext
	name  IMultipartIdentifierContext
	id    antlr.Token
	alias IIdentifierContext
}

func NewRecoverTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RecoverTableContext {
	var p = new(RecoverTableContext)

	InitEmptySupportedRecoverStatementContext(&p.SupportedRecoverStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedRecoverStatementContext))

	return p
}

func (s *RecoverTableContext) GetId() antlr.Token { return s.id }

func (s *RecoverTableContext) SetId(v antlr.Token) { s.id = v }

func (s *RecoverTableContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *RecoverTableContext) GetAlias() IIdentifierContext { return s.alias }

func (s *RecoverTableContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *RecoverTableContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *RecoverTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecoverTableContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(DorisParserRECOVER, 0)
}

func (s *RecoverTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *RecoverTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *RecoverTableContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *RecoverTableContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *RecoverTableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RecoverTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRecoverTable(s)
	}
}

func (s *RecoverTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRecoverTable(s)
	}
}

type RecoverDatabaseContext struct {
	SupportedRecoverStatementContext
	name  IIdentifierContext
	id    antlr.Token
	alias IIdentifierContext
}

func NewRecoverDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RecoverDatabaseContext {
	var p = new(RecoverDatabaseContext)

	InitEmptySupportedRecoverStatementContext(&p.SupportedRecoverStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedRecoverStatementContext))

	return p
}

func (s *RecoverDatabaseContext) GetId() antlr.Token { return s.id }

func (s *RecoverDatabaseContext) SetId(v antlr.Token) { s.id = v }

func (s *RecoverDatabaseContext) GetName() IIdentifierContext { return s.name }

func (s *RecoverDatabaseContext) GetAlias() IIdentifierContext { return s.alias }

func (s *RecoverDatabaseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *RecoverDatabaseContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *RecoverDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecoverDatabaseContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(DorisParserRECOVER, 0)
}

func (s *RecoverDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *RecoverDatabaseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RecoverDatabaseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RecoverDatabaseContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *RecoverDatabaseContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *RecoverDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRecoverDatabase(s)
	}
}

func (s *RecoverDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRecoverDatabase(s)
	}
}

func (p *DorisParser) SupportedRecoverStatement() (localctx ISupportedRecoverStatementContext) {
	localctx = NewSupportedRecoverStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, DorisParserRULE_supportedRecoverStatement)
	var _la int

	p.SetState(3259)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 434, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRecoverDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3226)
			p.Match(DorisParserRECOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3227)
			p.Match(DorisParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3228)

			var _x = p.Identifier()

			localctx.(*RecoverDatabaseContext).name = _x
		}
		p.SetState(3230)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserINTEGER_VALUE {
			{
				p.SetState(3229)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*RecoverDatabaseContext).id = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3234)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAS {
			{
				p.SetState(3232)
				p.Match(DorisParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3233)

				var _x = p.Identifier()

				localctx.(*RecoverDatabaseContext).alias = _x
			}

		}

	case 2:
		localctx = NewRecoverTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3236)
			p.Match(DorisParserRECOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3237)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3238)

			var _x = p.MultipartIdentifier()

			localctx.(*RecoverTableContext).name = _x
		}
		p.SetState(3240)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserINTEGER_VALUE {
			{
				p.SetState(3239)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*RecoverTableContext).id = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3244)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAS {
			{
				p.SetState(3242)
				p.Match(DorisParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3243)

				var _x = p.Identifier()

				localctx.(*RecoverTableContext).alias = _x
			}

		}

	case 3:
		localctx = NewRecoverPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3246)
			p.Match(DorisParserRECOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3247)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3248)

			var _x = p.Identifier()

			localctx.(*RecoverPartitionContext).name = _x
		}
		p.SetState(3250)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserINTEGER_VALUE {
			{
				p.SetState(3249)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*RecoverPartitionContext).id = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3254)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAS {
			{
				p.SetState(3252)
				p.Match(DorisParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3253)

				var _x = p.Identifier()

				localctx.(*RecoverPartitionContext).alias = _x
			}

		}
		{
			p.SetState(3256)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3257)

			var _x = p.MultipartIdentifier()

			localctx.(*RecoverPartitionContext).tableName = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedAdminStatementContext is an interface to support dynamic dispatch.
type IUnsupportedAdminStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedAdminStatementContext differentiates from other interfaces.
	IsUnsupportedAdminStatementContext()
}

type UnsupportedAdminStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedAdminStatementContext() *UnsupportedAdminStatementContext {
	var p = new(UnsupportedAdminStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedAdminStatement
	return p
}

func InitEmptyUnsupportedAdminStatementContext(p *UnsupportedAdminStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedAdminStatement
}

func (*UnsupportedAdminStatementContext) IsUnsupportedAdminStatementContext() {}

func NewUnsupportedAdminStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedAdminStatementContext {
	var p = new(UnsupportedAdminStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedAdminStatement

	return p
}

func (s *UnsupportedAdminStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedAdminStatementContext) CopyAll(ctx *UnsupportedAdminStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedAdminStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedAdminStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AdminSetPartitionVersionContext struct {
	UnsupportedAdminStatementContext
	name       IMultipartIdentifierContext
	properties IPropertyClauseContext
}

func NewAdminSetPartitionVersionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminSetPartitionVersionContext {
	var p = new(AdminSetPartitionVersionContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminSetPartitionVersionContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AdminSetPartitionVersionContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AdminSetPartitionVersionContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AdminSetPartitionVersionContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AdminSetPartitionVersionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetPartitionVersionContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserADMIN, 0)
}

func (s *AdminSetPartitionVersionContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AdminSetPartitionVersionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AdminSetPartitionVersionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *AdminSetPartitionVersionContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisParserVERSION, 0)
}

func (s *AdminSetPartitionVersionContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AdminSetPartitionVersionContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AdminSetPartitionVersionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAdminSetPartitionVersion(s)
	}
}

func (s *AdminSetPartitionVersionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAdminSetPartitionVersion(s)
	}
}

func (p *DorisParser) UnsupportedAdminStatement() (localctx IUnsupportedAdminStatementContext) {
	localctx = NewUnsupportedAdminStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, DorisParserRULE_unsupportedAdminStatement)
	var _la int

	localctx = NewAdminSetPartitionVersionContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3261)
		p.Match(DorisParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3262)
		p.Match(DorisParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3263)
		p.Match(DorisParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3264)

		var _x = p.MultipartIdentifier()

		localctx.(*AdminSetPartitionVersionContext).name = _x
	}
	{
		p.SetState(3265)
		p.Match(DorisParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3266)
		p.Match(DorisParserVERSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3268)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPROPERTIES {
		{
			p.SetState(3267)

			var _x = p.PropertyClause()

			localctx.(*AdminSetPartitionVersionContext).properties = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBaseTableRefContext is an interface to support dynamic dispatch.
type IBaseTableRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MultipartIdentifier() IMultipartIdentifierContext
	TableAlias() ITableAliasContext
	OptScanParams() IOptScanParamsContext
	TableSnapshot() ITableSnapshotContext
	SpecifiedPartition() ISpecifiedPartitionContext
	TabletList() ITabletListContext
	Sample() ISampleContext
	RelationHint() IRelationHintContext

	// IsBaseTableRefContext differentiates from other interfaces.
	IsBaseTableRefContext()
}

type BaseTableRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseTableRefContext() *BaseTableRefContext {
	var p = new(BaseTableRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_baseTableRef
	return p
}

func InitEmptyBaseTableRefContext(p *BaseTableRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_baseTableRef
}

func (*BaseTableRefContext) IsBaseTableRefContext() {}

func NewBaseTableRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseTableRefContext {
	var p = new(BaseTableRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_baseTableRef

	return p
}

func (s *BaseTableRefContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseTableRefContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *BaseTableRefContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *BaseTableRefContext) OptScanParams() IOptScanParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptScanParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptScanParamsContext)
}

func (s *BaseTableRefContext) TableSnapshot() ITableSnapshotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSnapshotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSnapshotContext)
}

func (s *BaseTableRefContext) SpecifiedPartition() ISpecifiedPartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecifiedPartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecifiedPartitionContext)
}

func (s *BaseTableRefContext) TabletList() ITabletListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabletListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabletListContext)
}

func (s *BaseTableRefContext) Sample() ISampleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleContext)
}

func (s *BaseTableRefContext) RelationHint() IRelationHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationHintContext)
}

func (s *BaseTableRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseTableRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseTableRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBaseTableRef(s)
	}
}

func (s *BaseTableRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBaseTableRef(s)
	}
}

func (p *DorisParser) BaseTableRef() (localctx IBaseTableRefContext) {
	localctx = NewBaseTableRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, DorisParserRULE_baseTableRef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3270)
		p.MultipartIdentifier()
	}
	p.SetState(3272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserATSIGN {
		{
			p.SetState(3271)
			p.OptScanParams()
		}

	}
	p.SetState(3275)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserFOR {
		{
			p.SetState(3274)
			p.TableSnapshot()
		}

	}
	p.SetState(3278)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 438, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3277)
			p.SpecifiedPartition()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3281)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserTABLET {
		{
			p.SetState(3280)
			p.TabletList()
		}

	}
	{
		p.SetState(3283)
		p.TableAlias()
	}
	p.SetState(3285)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserTABLESAMPLE {
		{
			p.SetState(3284)
			p.Sample()
		}

	}
	p.SetState(3288)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLEFT_BRACKET || _la == DorisParserHINT_START {
		{
			p.SetState(3287)
			p.RelationHint()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWildWhereContext is an interface to support dynamic dispatch.
type IWildWhereContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIKE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsWildWhereContext differentiates from other interfaces.
	IsWildWhereContext()
}

type WildWhereContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWildWhereContext() *WildWhereContext {
	var p = new(WildWhereContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_wildWhere
	return p
}

func InitEmptyWildWhereContext(p *WildWhereContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_wildWhere
}

func (*WildWhereContext) IsWildWhereContext() {}

func NewWildWhereContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WildWhereContext {
	var p = new(WildWhereContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_wildWhere

	return p
}

func (s *WildWhereContext) GetParser() antlr.Parser { return s.parser }

func (s *WildWhereContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *WildWhereContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *WildWhereContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserWHERE, 0)
}

func (s *WildWhereContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WildWhereContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildWhereContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WildWhereContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWildWhere(s)
	}
}

func (s *WildWhereContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWildWhere(s)
	}
}

func (p *DorisParser) WildWhere() (localctx IWildWhereContext) {
	localctx = NewWildWhereContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, DorisParserRULE_wildWhere)
	p.SetState(3294)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLIKE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3290)
			p.Match(DorisParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3291)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserWHERE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3292)
			p.Match(DorisParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3293)
			p.Expression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedTransactionStatementContext is an interface to support dynamic dispatch.
type ISupportedTransactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedTransactionStatementContext differentiates from other interfaces.
	IsSupportedTransactionStatementContext()
}

type SupportedTransactionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedTransactionStatementContext() *SupportedTransactionStatementContext {
	var p = new(SupportedTransactionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedTransactionStatement
	return p
}

func InitEmptySupportedTransactionStatementContext(p *SupportedTransactionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedTransactionStatement
}

func (*SupportedTransactionStatementContext) IsSupportedTransactionStatementContext() {}

func NewSupportedTransactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedTransactionStatementContext {
	var p = new(SupportedTransactionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedTransactionStatement

	return p
}

func (s *SupportedTransactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedTransactionStatementContext) CopyAll(ctx *SupportedTransactionStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedTransactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedTransactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TranscationCommitContext struct {
	SupportedTransactionStatementContext
}

func NewTranscationCommitContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TranscationCommitContext {
	var p = new(TranscationCommitContext)

	InitEmptySupportedTransactionStatementContext(&p.SupportedTransactionStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedTransactionStatementContext))

	return p
}

func (s *TranscationCommitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TranscationCommitContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMIT, 0)
}

func (s *TranscationCommitContext) WORK() antlr.TerminalNode {
	return s.GetToken(DorisParserWORK, 0)
}

func (s *TranscationCommitContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisParserAND, 0)
}

func (s *TranscationCommitContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(DorisParserCHAIN, 0)
}

func (s *TranscationCommitContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(DorisParserRELEASE, 0)
}

func (s *TranscationCommitContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(DorisParserNO)
}

func (s *TranscationCommitContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserNO, i)
}

func (s *TranscationCommitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTranscationCommit(s)
	}
}

func (s *TranscationCommitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTranscationCommit(s)
	}
}

type TransactionRollbackContext struct {
	SupportedTransactionStatementContext
}

func NewTransactionRollbackContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TransactionRollbackContext {
	var p = new(TransactionRollbackContext)

	InitEmptySupportedTransactionStatementContext(&p.SupportedTransactionStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedTransactionStatementContext))

	return p
}

func (s *TransactionRollbackContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionRollbackContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLBACK, 0)
}

func (s *TransactionRollbackContext) WORK() antlr.TerminalNode {
	return s.GetToken(DorisParserWORK, 0)
}

func (s *TransactionRollbackContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisParserAND, 0)
}

func (s *TransactionRollbackContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(DorisParserCHAIN, 0)
}

func (s *TransactionRollbackContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(DorisParserRELEASE, 0)
}

func (s *TransactionRollbackContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(DorisParserNO)
}

func (s *TransactionRollbackContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserNO, i)
}

func (s *TransactionRollbackContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTransactionRollback(s)
	}
}

func (s *TransactionRollbackContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTransactionRollback(s)
	}
}

type TransactionBeginContext struct {
	SupportedTransactionStatementContext
}

func NewTransactionBeginContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TransactionBeginContext {
	var p = new(TransactionBeginContext)

	InitEmptySupportedTransactionStatementContext(&p.SupportedTransactionStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedTransactionStatementContext))

	return p
}

func (s *TransactionBeginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionBeginContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(DorisParserBEGIN, 0)
}

func (s *TransactionBeginContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *TransactionBeginContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisParserLABEL, 0)
}

func (s *TransactionBeginContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TransactionBeginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTransactionBegin(s)
	}
}

func (s *TransactionBeginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTransactionBegin(s)
	}
}

func (p *DorisParser) SupportedTransactionStatement() (localctx ISupportedTransactionStatementContext) {
	localctx = NewSupportedTransactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, DorisParserRULE_supportedTransactionStatement)
	var _la int

	p.SetState(3338)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserBEGIN:
		localctx = NewTransactionBeginContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3296)
			p.Match(DorisParserBEGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3302)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(3297)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3298)
				p.Match(DorisParserLABEL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3300)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305902462020672000) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4609989332399152113) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4540397275156637211) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&2557745532860070517) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&8545544968972265069) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-305714810442809349) != 0) || ((int64((_la-391)) & ^0x3f) == 0 && ((int64(1)<<(_la-391))&1188948054525294943) != 0) || ((int64((_la-455)) & ^0x3f) == 0 && ((int64(1)<<(_la-455))&2458964612221191023) != 0) || ((int64((_la-538)) & ^0x3f) == 0 && ((int64(1)<<(_la-538))&49159) != 0) {
				{
					p.SetState(3299)
					p.Identifier()
				}

			}

		}

	case DorisParserCOMMIT:
		localctx = NewTranscationCommitContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3304)
			p.Match(DorisParserCOMMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3306)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWORK {
			{
				p.SetState(3305)
				p.Match(DorisParserWORK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3313)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAND {
			{
				p.SetState(3308)
				p.Match(DorisParserAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3310)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserNO {
				{
					p.SetState(3309)
					p.Match(DorisParserNO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(3312)
				p.Match(DorisParserCHAIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3319)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNO || _la == DorisParserRELEASE {
			p.SetState(3316)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserNO {
				{
					p.SetState(3315)
					p.Match(DorisParserNO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(3318)
				p.Match(DorisParserRELEASE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DorisParserROLLBACK:
		localctx = NewTransactionRollbackContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3321)
			p.Match(DorisParserROLLBACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3323)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWORK {
			{
				p.SetState(3322)
				p.Match(DorisParserWORK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3330)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAND {
			{
				p.SetState(3325)
				p.Match(DorisParserAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3327)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserNO {
				{
					p.SetState(3326)
					p.Match(DorisParserNO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(3329)
				p.Match(DorisParserCHAIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3336)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNO || _la == DorisParserRELEASE {
			p.SetState(3333)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserNO {
				{
					p.SetState(3332)
					p.Match(DorisParserNO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(3335)
				p.Match(DorisParserRELEASE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedGrantRevokeStatementContext is an interface to support dynamic dispatch.
type ISupportedGrantRevokeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedGrantRevokeStatementContext differentiates from other interfaces.
	IsSupportedGrantRevokeStatementContext()
}

type SupportedGrantRevokeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedGrantRevokeStatementContext() *SupportedGrantRevokeStatementContext {
	var p = new(SupportedGrantRevokeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedGrantRevokeStatement
	return p
}

func InitEmptySupportedGrantRevokeStatementContext(p *SupportedGrantRevokeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedGrantRevokeStatement
}

func (*SupportedGrantRevokeStatementContext) IsSupportedGrantRevokeStatementContext() {}

func NewSupportedGrantRevokeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedGrantRevokeStatementContext {
	var p = new(SupportedGrantRevokeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedGrantRevokeStatement

	return p
}

func (s *SupportedGrantRevokeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedGrantRevokeStatementContext) CopyAll(ctx *SupportedGrantRevokeStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedGrantRevokeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedGrantRevokeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type GrantResourcePrivilegeContext struct {
	SupportedGrantRevokeStatementContext
}

func NewGrantResourcePrivilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantResourcePrivilegeContext {
	var p = new(GrantResourcePrivilegeContext)

	InitEmptySupportedGrantRevokeStatementContext(&p.SupportedGrantRevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedGrantRevokeStatementContext))

	return p
}

func (s *GrantResourcePrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantResourcePrivilegeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(DorisParserGRANT, 0)
}

func (s *GrantResourcePrivilegeContext) PrivilegeList() IPrivilegeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeListContext)
}

func (s *GrantResourcePrivilegeContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *GrantResourcePrivilegeContext) IdentifierOrTextOrAsterisk() IIdentifierOrTextOrAsteriskContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextOrAsteriskContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextOrAsteriskContext)
}

func (s *GrantResourcePrivilegeContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *GrantResourcePrivilegeContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCE, 0)
}

func (s *GrantResourcePrivilegeContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(DorisParserCLUSTER, 0)
}

func (s *GrantResourcePrivilegeContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPUTE, 0)
}

func (s *GrantResourcePrivilegeContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUP, 0)
}

func (s *GrantResourcePrivilegeContext) STAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTAGE, 0)
}

func (s *GrantResourcePrivilegeContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *GrantResourcePrivilegeContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULT, 0)
}

func (s *GrantResourcePrivilegeContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserWORKLOAD, 0)
}

func (s *GrantResourcePrivilegeContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *GrantResourcePrivilegeContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *GrantResourcePrivilegeContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *GrantResourcePrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterGrantResourcePrivilege(s)
	}
}

func (s *GrantResourcePrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitGrantResourcePrivilege(s)
	}
}

type RevokeRoleContext struct {
	SupportedGrantRevokeStatementContext
	_identifierOrText IIdentifierOrTextContext
	roles             []IIdentifierOrTextContext
}

func NewRevokeRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeRoleContext {
	var p = new(RevokeRoleContext)

	InitEmptySupportedGrantRevokeStatementContext(&p.SupportedGrantRevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedGrantRevokeStatementContext))

	return p
}

func (s *RevokeRoleContext) Get_identifierOrText() IIdentifierOrTextContext {
	return s._identifierOrText
}

func (s *RevokeRoleContext) Set_identifierOrText(v IIdentifierOrTextContext) { s._identifierOrText = v }

func (s *RevokeRoleContext) GetRoles() []IIdentifierOrTextContext { return s.roles }

func (s *RevokeRoleContext) SetRoles(v []IIdentifierOrTextContext) { s.roles = v }

func (s *RevokeRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeRoleContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisParserREVOKE, 0)
}

func (s *RevokeRoleContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *RevokeRoleContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *RevokeRoleContext) AllIdentifierOrText() []IIdentifierOrTextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrTextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrTextContext); ok {
			tst[i] = t.(IIdentifierOrTextContext)
			i++
		}
	}

	return tst
}

func (s *RevokeRoleContext) IdentifierOrText(i int) IIdentifierOrTextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *RevokeRoleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *RevokeRoleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *RevokeRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRevokeRole(s)
	}
}

func (s *RevokeRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRevokeRole(s)
	}
}

type GrantTablePrivilegeContext struct {
	SupportedGrantRevokeStatementContext
}

func NewGrantTablePrivilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantTablePrivilegeContext {
	var p = new(GrantTablePrivilegeContext)

	InitEmptySupportedGrantRevokeStatementContext(&p.SupportedGrantRevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedGrantRevokeStatementContext))

	return p
}

func (s *GrantTablePrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantTablePrivilegeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(DorisParserGRANT, 0)
}

func (s *GrantTablePrivilegeContext) PrivilegeList() IPrivilegeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeListContext)
}

func (s *GrantTablePrivilegeContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *GrantTablePrivilegeContext) MultipartIdentifierOrAsterisk() IMultipartIdentifierOrAsteriskContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierOrAsteriskContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierOrAsteriskContext)
}

func (s *GrantTablePrivilegeContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *GrantTablePrivilegeContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *GrantTablePrivilegeContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *GrantTablePrivilegeContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *GrantTablePrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterGrantTablePrivilege(s)
	}
}

func (s *GrantTablePrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitGrantTablePrivilege(s)
	}
}

type GrantRoleContext struct {
	SupportedGrantRevokeStatementContext
	_identifierOrText IIdentifierOrTextContext
	roles             []IIdentifierOrTextContext
}

func NewGrantRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantRoleContext {
	var p = new(GrantRoleContext)

	InitEmptySupportedGrantRevokeStatementContext(&p.SupportedGrantRevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedGrantRevokeStatementContext))

	return p
}

func (s *GrantRoleContext) Get_identifierOrText() IIdentifierOrTextContext {
	return s._identifierOrText
}

func (s *GrantRoleContext) Set_identifierOrText(v IIdentifierOrTextContext) { s._identifierOrText = v }

func (s *GrantRoleContext) GetRoles() []IIdentifierOrTextContext { return s.roles }

func (s *GrantRoleContext) SetRoles(v []IIdentifierOrTextContext) { s.roles = v }

func (s *GrantRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRoleContext) GRANT() antlr.TerminalNode {
	return s.GetToken(DorisParserGRANT, 0)
}

func (s *GrantRoleContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *GrantRoleContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *GrantRoleContext) AllIdentifierOrText() []IIdentifierOrTextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrTextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrTextContext); ok {
			tst[i] = t.(IIdentifierOrTextContext)
			i++
		}
	}

	return tst
}

func (s *GrantRoleContext) IdentifierOrText(i int) IIdentifierOrTextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *GrantRoleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *GrantRoleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *GrantRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterGrantRole(s)
	}
}

func (s *GrantRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitGrantRole(s)
	}
}

type RevokeResourcePrivilegeContext struct {
	SupportedGrantRevokeStatementContext
}

func NewRevokeResourcePrivilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeResourcePrivilegeContext {
	var p = new(RevokeResourcePrivilegeContext)

	InitEmptySupportedGrantRevokeStatementContext(&p.SupportedGrantRevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedGrantRevokeStatementContext))

	return p
}

func (s *RevokeResourcePrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeResourcePrivilegeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisParserREVOKE, 0)
}

func (s *RevokeResourcePrivilegeContext) PrivilegeList() IPrivilegeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeListContext)
}

func (s *RevokeResourcePrivilegeContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *RevokeResourcePrivilegeContext) IdentifierOrTextOrAsterisk() IIdentifierOrTextOrAsteriskContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextOrAsteriskContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextOrAsteriskContext)
}

func (s *RevokeResourcePrivilegeContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *RevokeResourcePrivilegeContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCE, 0)
}

func (s *RevokeResourcePrivilegeContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(DorisParserCLUSTER, 0)
}

func (s *RevokeResourcePrivilegeContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPUTE, 0)
}

func (s *RevokeResourcePrivilegeContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUP, 0)
}

func (s *RevokeResourcePrivilegeContext) STAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTAGE, 0)
}

func (s *RevokeResourcePrivilegeContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *RevokeResourcePrivilegeContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULT, 0)
}

func (s *RevokeResourcePrivilegeContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserWORKLOAD, 0)
}

func (s *RevokeResourcePrivilegeContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *RevokeResourcePrivilegeContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *RevokeResourcePrivilegeContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *RevokeResourcePrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRevokeResourcePrivilege(s)
	}
}

func (s *RevokeResourcePrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRevokeResourcePrivilege(s)
	}
}

type RevokeTablePrivilegeContext struct {
	SupportedGrantRevokeStatementContext
}

func NewRevokeTablePrivilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeTablePrivilegeContext {
	var p = new(RevokeTablePrivilegeContext)

	InitEmptySupportedGrantRevokeStatementContext(&p.SupportedGrantRevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedGrantRevokeStatementContext))

	return p
}

func (s *RevokeTablePrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeTablePrivilegeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisParserREVOKE, 0)
}

func (s *RevokeTablePrivilegeContext) PrivilegeList() IPrivilegeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeListContext)
}

func (s *RevokeTablePrivilegeContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *RevokeTablePrivilegeContext) MultipartIdentifierOrAsterisk() IMultipartIdentifierOrAsteriskContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierOrAsteriskContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierOrAsteriskContext)
}

func (s *RevokeTablePrivilegeContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *RevokeTablePrivilegeContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *RevokeTablePrivilegeContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserROLE, 0)
}

func (s *RevokeTablePrivilegeContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *RevokeTablePrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRevokeTablePrivilege(s)
	}
}

func (s *RevokeTablePrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRevokeTablePrivilege(s)
	}
}

func (p *DorisParser) SupportedGrantRevokeStatement() (localctx ISupportedGrantRevokeStatementContext) {
	localctx = NewSupportedGrantRevokeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, DorisParserRULE_supportedGrantRevokeStatement)
	var _la int

	p.SetState(3426)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 464, p.GetParserRuleContext()) {
	case 1:
		localctx = NewGrantTablePrivilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3340)
			p.Match(DorisParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3341)
			p.PrivilegeList()
		}
		{
			p.SetState(3342)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3343)
			p.MultipartIdentifierOrAsterisk()
		}
		{
			p.SetState(3344)
			p.Match(DorisParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3348)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(3345)
				p.UserIdentify()
			}

		case DorisParserROLE:
			{
				p.SetState(3346)
				p.Match(DorisParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3347)
				p.IdentifierOrText()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		localctx = NewGrantResourcePrivilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3350)
			p.Match(DorisParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3351)
			p.PrivilegeList()
		}
		{
			p.SetState(3352)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3362)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserRESOURCE:
			{
				p.SetState(3353)
				p.Match(DorisParserRESOURCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCLUSTER:
			{
				p.SetState(3354)
				p.Match(DorisParserCLUSTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCOMPUTE:
			{
				p.SetState(3355)
				p.Match(DorisParserCOMPUTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3356)
				p.Match(DorisParserGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserSTAGE:
			{
				p.SetState(3357)
				p.Match(DorisParserSTAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserSTORAGE:
			{
				p.SetState(3358)
				p.Match(DorisParserSTORAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3359)
				p.Match(DorisParserVAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserWORKLOAD:
			{
				p.SetState(3360)
				p.Match(DorisParserWORKLOAD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3361)
				p.Match(DorisParserGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(3364)
			p.IdentifierOrTextOrAsterisk()
		}
		{
			p.SetState(3365)
			p.Match(DorisParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3369)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(3366)
				p.UserIdentify()
			}

		case DorisParserROLE:
			{
				p.SetState(3367)
				p.Match(DorisParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3368)
				p.IdentifierOrText()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		localctx = NewGrantRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3371)
			p.Match(DorisParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3372)

			var _x = p.IdentifierOrText()

			localctx.(*GrantRoleContext)._identifierOrText = _x
		}
		localctx.(*GrantRoleContext).roles = append(localctx.(*GrantRoleContext).roles, localctx.(*GrantRoleContext)._identifierOrText)
		p.SetState(3377)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(3373)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3374)

				var _x = p.IdentifierOrText()

				localctx.(*GrantRoleContext)._identifierOrText = _x
			}
			localctx.(*GrantRoleContext).roles = append(localctx.(*GrantRoleContext).roles, localctx.(*GrantRoleContext)._identifierOrText)

			p.SetState(3379)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3380)
			p.Match(DorisParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3381)
			p.UserIdentify()
		}

	case 4:
		localctx = NewRevokeRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3383)
			p.Match(DorisParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3384)

			var _x = p.IdentifierOrText()

			localctx.(*RevokeRoleContext)._identifierOrText = _x
		}
		localctx.(*RevokeRoleContext).roles = append(localctx.(*RevokeRoleContext).roles, localctx.(*RevokeRoleContext)._identifierOrText)
		p.SetState(3389)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(3385)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3386)

				var _x = p.IdentifierOrText()

				localctx.(*RevokeRoleContext)._identifierOrText = _x
			}
			localctx.(*RevokeRoleContext).roles = append(localctx.(*RevokeRoleContext).roles, localctx.(*RevokeRoleContext)._identifierOrText)

			p.SetState(3391)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3392)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3393)
			p.UserIdentify()
		}

	case 5:
		localctx = NewRevokeResourcePrivilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3395)
			p.Match(DorisParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3396)
			p.PrivilegeList()
		}
		{
			p.SetState(3397)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3407)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserRESOURCE:
			{
				p.SetState(3398)
				p.Match(DorisParserRESOURCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCLUSTER:
			{
				p.SetState(3399)
				p.Match(DorisParserCLUSTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCOMPUTE:
			{
				p.SetState(3400)
				p.Match(DorisParserCOMPUTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3401)
				p.Match(DorisParserGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserSTAGE:
			{
				p.SetState(3402)
				p.Match(DorisParserSTAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserSTORAGE:
			{
				p.SetState(3403)
				p.Match(DorisParserSTORAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3404)
				p.Match(DorisParserVAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserWORKLOAD:
			{
				p.SetState(3405)
				p.Match(DorisParserWORKLOAD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3406)
				p.Match(DorisParserGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(3409)
			p.IdentifierOrTextOrAsterisk()
		}
		{
			p.SetState(3410)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3414)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(3411)
				p.UserIdentify()
			}

		case DorisParserROLE:
			{
				p.SetState(3412)
				p.Match(DorisParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3413)
				p.IdentifierOrText()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 6:
		localctx = NewRevokeTablePrivilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3416)
			p.Match(DorisParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3417)
			p.PrivilegeList()
		}
		{
			p.SetState(3418)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3419)
			p.MultipartIdentifierOrAsterisk()
		}
		{
			p.SetState(3420)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3424)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(3421)
				p.UserIdentify()
			}

		case DorisParserROLE:
			{
				p.SetState(3422)
				p.Match(DorisParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3423)
				p.IdentifierOrText()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeContext is an interface to support dynamic dispatch.
type IPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IIdentifierListContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IIdentifierListContext)

	// Getter signatures
	Identifier() IIdentifierContext
	IdentifierList() IIdentifierListContext
	ALL() antlr.TerminalNode

	// IsPrivilegeContext differentiates from other interfaces.
	IsPrivilegeContext()
}

type PrivilegeContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	name    IIdentifierContext
	columns IIdentifierListContext
}

func NewEmptyPrivilegeContext() *PrivilegeContext {
	var p = new(PrivilegeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_privilege
	return p
}

func InitEmptyPrivilegeContext(p *PrivilegeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_privilege
}

func (*PrivilegeContext) IsPrivilegeContext() {}

func NewPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeContext {
	var p = new(PrivilegeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_privilege

	return p
}

func (s *PrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeContext) GetName() IIdentifierContext { return s.name }

func (s *PrivilegeContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *PrivilegeContext) SetName(v IIdentifierContext) { s.name = v }

func (s *PrivilegeContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *PrivilegeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrivilegeContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PrivilegeContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *PrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPrivilege(s)
	}
}

func (s *PrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPrivilege(s)
	}
}

func (p *DorisParser) Privilege() (localctx IPrivilegeContext) {
	localctx = NewPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, DorisParserRULE_privilege)
	var _la int

	p.SetState(3433)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3428)

			var _x = p.Identifier()

			localctx.(*PrivilegeContext).name = _x
		}
		p.SetState(3430)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(3429)

				var _x = p.IdentifierList()

				localctx.(*PrivilegeContext).columns = _x
			}

		}

	case DorisParserALL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3432)
			p.Match(DorisParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeListContext is an interface to support dynamic dispatch.
type IPrivilegeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrivilege() []IPrivilegeContext
	Privilege(i int) IPrivilegeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPrivilegeListContext differentiates from other interfaces.
	IsPrivilegeListContext()
}

type PrivilegeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeListContext() *PrivilegeListContext {
	var p = new(PrivilegeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_privilegeList
	return p
}

func InitEmptyPrivilegeListContext(p *PrivilegeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_privilegeList
}

func (*PrivilegeListContext) IsPrivilegeListContext() {}

func NewPrivilegeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeListContext {
	var p = new(PrivilegeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_privilegeList

	return p
}

func (s *PrivilegeListContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeListContext) AllPrivilege() []IPrivilegeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivilegeContext); ok {
			len++
		}
	}

	tst := make([]IPrivilegeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivilegeContext); ok {
			tst[i] = t.(IPrivilegeContext)
			i++
		}
	}

	return tst
}

func (s *PrivilegeListContext) Privilege(i int) IPrivilegeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeContext)
}

func (s *PrivilegeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *PrivilegeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *PrivilegeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPrivilegeList(s)
	}
}

func (s *PrivilegeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPrivilegeList(s)
	}
}

func (p *DorisParser) PrivilegeList() (localctx IPrivilegeListContext) {
	localctx = NewPrivilegeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, DorisParserRULE_privilegeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3435)
		p.Privilege()
	}
	p.SetState(3440)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(3436)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3437)
			p.Privilege()
		}

		p.SetState(3442)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterSystemClauseContext is an interface to support dynamic dispatch.
type IAlterSystemClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlterSystemClauseContext differentiates from other interfaces.
	IsAlterSystemClauseContext()
}

type AlterSystemClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterSystemClauseContext() *AlterSystemClauseContext {
	var p = new(AlterSystemClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_alterSystemClause
	return p
}

func InitEmptyAlterSystemClauseContext(p *AlterSystemClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_alterSystemClause
}

func (*AlterSystemClauseContext) IsAlterSystemClauseContext() {}

func NewAlterSystemClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterSystemClauseContext {
	var p = new(AlterSystemClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_alterSystemClause

	return p
}

func (s *AlterSystemClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterSystemClauseContext) CopyAll(ctx *AlterSystemClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AlterSystemClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSystemClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DropBrokerClauseContext struct {
	AlterSystemClauseContext
	name            IIdentifierOrTextContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
}

func NewDropBrokerClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropBrokerClauseContext {
	var p = new(DropBrokerClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *DropBrokerClauseContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *DropBrokerClauseContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *DropBrokerClauseContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *DropBrokerClauseContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *DropBrokerClauseContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *DropBrokerClauseContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *DropBrokerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropBrokerClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropBrokerClauseContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserBROKER, 0)
}

func (s *DropBrokerClauseContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DropBrokerClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *DropBrokerClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *DropBrokerClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *DropBrokerClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *DropBrokerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropBrokerClause(s)
	}
}

func (s *DropBrokerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropBrokerClause(s)
	}
}

type ModifyFrontendOrBackendHostNameClauseContext struct {
	AlterSystemClauseContext
	hostPort antlr.Token
	hostName antlr.Token
}

func NewModifyFrontendOrBackendHostNameClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyFrontendOrBackendHostNameClauseContext {
	var p = new(ModifyFrontendOrBackendHostNameClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) GetHostPort() antlr.Token { return s.hostPort }

func (s *ModifyFrontendOrBackendHostNameClauseContext) GetHostName() antlr.Token { return s.hostName }

func (s *ModifyFrontendOrBackendHostNameClauseContext) SetHostPort(v antlr.Token) { s.hostPort = v }

func (s *ModifyFrontendOrBackendHostNameClauseContext) SetHostName(v antlr.Token) { s.hostName = v }

func (s *ModifyFrontendOrBackendHostNameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) HOSTNAME() antlr.TerminalNode {
	return s.GetToken(DorisParserHOSTNAME, 0)
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(DorisParserFRONTEND, 0)
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKEND, 0)
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterModifyFrontendOrBackendHostNameClause(s)
	}
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitModifyFrontendOrBackendHostNameClause(s)
	}
}

type DropObserverClauseContext struct {
	AlterSystemClauseContext
	hostPort antlr.Token
}

func NewDropObserverClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropObserverClauseContext {
	var p = new(DropObserverClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *DropObserverClauseContext) GetHostPort() antlr.Token { return s.hostPort }

func (s *DropObserverClauseContext) SetHostPort(v antlr.Token) { s.hostPort = v }

func (s *DropObserverClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropObserverClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropObserverClauseContext) OBSERVER() antlr.TerminalNode {
	return s.GetToken(DorisParserOBSERVER, 0)
}

func (s *DropObserverClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *DropObserverClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropObserverClause(s)
	}
}

func (s *DropObserverClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropObserverClause(s)
	}
}

type AddFollowerClauseContext struct {
	AlterSystemClauseContext
	hostPort antlr.Token
}

func NewAddFollowerClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddFollowerClauseContext {
	var p = new(AddFollowerClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *AddFollowerClauseContext) GetHostPort() antlr.Token { return s.hostPort }

func (s *AddFollowerClauseContext) SetHostPort(v antlr.Token) { s.hostPort = v }

func (s *AddFollowerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddFollowerClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddFollowerClauseContext) FOLLOWER() antlr.TerminalNode {
	return s.GetToken(DorisParserFOLLOWER, 0)
}

func (s *AddFollowerClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *AddFollowerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddFollowerClause(s)
	}
}

func (s *AddFollowerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddFollowerClause(s)
	}
}

type DropFollowerClauseContext struct {
	AlterSystemClauseContext
	hostPort antlr.Token
}

func NewDropFollowerClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropFollowerClauseContext {
	var p = new(DropFollowerClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *DropFollowerClauseContext) GetHostPort() antlr.Token { return s.hostPort }

func (s *DropFollowerClauseContext) SetHostPort(v antlr.Token) { s.hostPort = v }

func (s *DropFollowerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFollowerClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropFollowerClauseContext) FOLLOWER() antlr.TerminalNode {
	return s.GetToken(DorisParserFOLLOWER, 0)
}

func (s *DropFollowerClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *DropFollowerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropFollowerClause(s)
	}
}

func (s *DropFollowerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropFollowerClause(s)
	}
}

type DropAllBrokerClauseContext struct {
	AlterSystemClauseContext
	name IIdentifierOrTextContext
}

func NewDropAllBrokerClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropAllBrokerClauseContext {
	var p = new(DropAllBrokerClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *DropAllBrokerClauseContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *DropAllBrokerClauseContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *DropAllBrokerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropAllBrokerClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropAllBrokerClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *DropAllBrokerClauseContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserBROKER, 0)
}

func (s *DropAllBrokerClauseContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DropAllBrokerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropAllBrokerClause(s)
	}
}

func (s *DropAllBrokerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropAllBrokerClause(s)
	}
}

type DropBackendClauseContext struct {
	AlterSystemClauseContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
}

func NewDropBackendClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropBackendClauseContext {
	var p = new(DropBackendClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *DropBackendClauseContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *DropBackendClauseContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *DropBackendClauseContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *DropBackendClauseContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *DropBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKEND, 0)
}

func (s *DropBackendClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropBackendClauseContext) DROPP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROPP, 0)
}

func (s *DropBackendClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *DropBackendClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *DropBackendClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *DropBackendClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *DropBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropBackendClause(s)
	}
}

func (s *DropBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropBackendClause(s)
	}
}

type AlterLoadErrorUrlClauseContext struct {
	AlterSystemClauseContext
	properties IPropertyClauseContext
}

func NewAlterLoadErrorUrlClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterLoadErrorUrlClauseContext {
	var p = new(AlterLoadErrorUrlClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *AlterLoadErrorUrlClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterLoadErrorUrlClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterLoadErrorUrlClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterLoadErrorUrlClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterLoadErrorUrlClauseContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserLOAD, 0)
}

func (s *AlterLoadErrorUrlClauseContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(DorisParserERRORS, 0)
}

func (s *AlterLoadErrorUrlClauseContext) HUB() antlr.TerminalNode {
	return s.GetToken(DorisParserHUB, 0)
}

func (s *AlterLoadErrorUrlClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterLoadErrorUrlClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterLoadErrorUrlClause(s)
	}
}

func (s *AlterLoadErrorUrlClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterLoadErrorUrlClause(s)
	}
}

type ModifyBackendClauseContext struct {
	AlterSystemClauseContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
}

func NewModifyBackendClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyBackendClauseContext {
	var p = new(ModifyBackendClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *ModifyBackendClauseContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *ModifyBackendClauseContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *ModifyBackendClauseContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *ModifyBackendClauseContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *ModifyBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyBackendClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *ModifyBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKEND, 0)
}

func (s *ModifyBackendClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *ModifyBackendClauseContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ModifyBackendClauseContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *ModifyBackendClauseContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ModifyBackendClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *ModifyBackendClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *ModifyBackendClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ModifyBackendClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ModifyBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterModifyBackendClause(s)
	}
}

func (s *ModifyBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitModifyBackendClause(s)
	}
}

type AddBrokerClauseContext struct {
	AlterSystemClauseContext
	name            IIdentifierOrTextContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
}

func NewAddBrokerClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddBrokerClauseContext {
	var p = new(AddBrokerClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *AddBrokerClauseContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *AddBrokerClauseContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *AddBrokerClauseContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *AddBrokerClauseContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *AddBrokerClauseContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *AddBrokerClauseContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *AddBrokerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddBrokerClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddBrokerClauseContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserBROKER, 0)
}

func (s *AddBrokerClauseContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *AddBrokerClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *AddBrokerClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *AddBrokerClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AddBrokerClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AddBrokerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddBrokerClause(s)
	}
}

func (s *AddBrokerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddBrokerClause(s)
	}
}

type AddObserverClauseContext struct {
	AlterSystemClauseContext
	hostPort antlr.Token
}

func NewAddObserverClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddObserverClauseContext {
	var p = new(AddObserverClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *AddObserverClauseContext) GetHostPort() antlr.Token { return s.hostPort }

func (s *AddObserverClauseContext) SetHostPort(v antlr.Token) { s.hostPort = v }

func (s *AddObserverClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddObserverClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddObserverClauseContext) OBSERVER() antlr.TerminalNode {
	return s.GetToken(DorisParserOBSERVER, 0)
}

func (s *AddObserverClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *AddObserverClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddObserverClause(s)
	}
}

func (s *AddObserverClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddObserverClause(s)
	}
}

type DecommissionBackendClauseContext struct {
	AlterSystemClauseContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
}

func NewDecommissionBackendClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecommissionBackendClauseContext {
	var p = new(DecommissionBackendClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *DecommissionBackendClauseContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *DecommissionBackendClauseContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *DecommissionBackendClauseContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *DecommissionBackendClauseContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *DecommissionBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecommissionBackendClauseContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(DorisParserDECOMMISSION, 0)
}

func (s *DecommissionBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKEND, 0)
}

func (s *DecommissionBackendClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *DecommissionBackendClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *DecommissionBackendClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *DecommissionBackendClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *DecommissionBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDecommissionBackendClause(s)
	}
}

func (s *DecommissionBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDecommissionBackendClause(s)
	}
}

type AddBackendClauseContext struct {
	AlterSystemClauseContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
	properties      IPropertyClauseContext
}

func NewAddBackendClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddBackendClauseContext {
	var p = new(AddBackendClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *AddBackendClauseContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *AddBackendClauseContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *AddBackendClauseContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *AddBackendClauseContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *AddBackendClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AddBackendClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AddBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddBackendClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKEND, 0)
}

func (s *AddBackendClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *AddBackendClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *AddBackendClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AddBackendClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AddBackendClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AddBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddBackendClause(s)
	}
}

func (s *AddBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddBackendClause(s)
	}
}

func (p *DorisParser) AlterSystemClause() (localctx IAlterSystemClauseContext) {
	localctx = NewAlterSystemClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, DorisParserRULE_alterSystemClause)
	var _la int

	p.SetState(3541)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 476, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAddBackendClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3443)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3444)
			p.Match(DorisParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3445)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*AddBackendClauseContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*AddBackendClauseContext).hostPorts = append(localctx.(*AddBackendClauseContext).hostPorts, localctx.(*AddBackendClauseContext)._STRING_LITERAL)
		p.SetState(3450)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(3446)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3447)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*AddBackendClauseContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*AddBackendClauseContext).hostPorts = append(localctx.(*AddBackendClauseContext).hostPorts, localctx.(*AddBackendClauseContext)._STRING_LITERAL)

			p.SetState(3452)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(3454)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3453)

				var _x = p.PropertyClause()

				localctx.(*AddBackendClauseContext).properties = _x
			}

		}

	case 2:
		localctx = NewDropBackendClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3456)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserDROP || _la == DorisParserDROPP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3457)
			p.Match(DorisParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3458)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*DropBackendClauseContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*DropBackendClauseContext).hostPorts = append(localctx.(*DropBackendClauseContext).hostPorts, localctx.(*DropBackendClauseContext)._STRING_LITERAL)
		p.SetState(3463)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(3459)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3460)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*DropBackendClauseContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*DropBackendClauseContext).hostPorts = append(localctx.(*DropBackendClauseContext).hostPorts, localctx.(*DropBackendClauseContext)._STRING_LITERAL)

			p.SetState(3465)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		localctx = NewDecommissionBackendClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3466)
			p.Match(DorisParserDECOMMISSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3467)
			p.Match(DorisParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3468)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*DecommissionBackendClauseContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*DecommissionBackendClauseContext).hostPorts = append(localctx.(*DecommissionBackendClauseContext).hostPorts, localctx.(*DecommissionBackendClauseContext)._STRING_LITERAL)
		p.SetState(3473)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(3469)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3470)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*DecommissionBackendClauseContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*DecommissionBackendClauseContext).hostPorts = append(localctx.(*DecommissionBackendClauseContext).hostPorts, localctx.(*DecommissionBackendClauseContext)._STRING_LITERAL)

			p.SetState(3475)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 4:
		localctx = NewAddObserverClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3476)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3477)
			p.Match(DorisParserOBSERVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3478)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*AddObserverClauseContext).hostPort = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewDropObserverClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3479)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3480)
			p.Match(DorisParserOBSERVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3481)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*DropObserverClauseContext).hostPort = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewAddFollowerClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3482)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3483)
			p.Match(DorisParserFOLLOWER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3484)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*AddFollowerClauseContext).hostPort = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewDropFollowerClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3485)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3486)
			p.Match(DorisParserFOLLOWER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3487)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*DropFollowerClauseContext).hostPort = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewAddBrokerClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3488)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3489)
			p.Match(DorisParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3490)

			var _x = p.IdentifierOrText()

			localctx.(*AddBrokerClauseContext).name = _x
		}
		{
			p.SetState(3491)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*AddBrokerClauseContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*AddBrokerClauseContext).hostPorts = append(localctx.(*AddBrokerClauseContext).hostPorts, localctx.(*AddBrokerClauseContext)._STRING_LITERAL)
		p.SetState(3496)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(3492)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3493)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*AddBrokerClauseContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*AddBrokerClauseContext).hostPorts = append(localctx.(*AddBrokerClauseContext).hostPorts, localctx.(*AddBrokerClauseContext)._STRING_LITERAL)

			p.SetState(3498)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 9:
		localctx = NewDropBrokerClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3499)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3500)
			p.Match(DorisParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3501)

			var _x = p.IdentifierOrText()

			localctx.(*DropBrokerClauseContext).name = _x
		}
		{
			p.SetState(3502)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*DropBrokerClauseContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*DropBrokerClauseContext).hostPorts = append(localctx.(*DropBrokerClauseContext).hostPorts, localctx.(*DropBrokerClauseContext)._STRING_LITERAL)
		p.SetState(3507)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(3503)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3504)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*DropBrokerClauseContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*DropBrokerClauseContext).hostPorts = append(localctx.(*DropBrokerClauseContext).hostPorts, localctx.(*DropBrokerClauseContext)._STRING_LITERAL)

			p.SetState(3509)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 10:
		localctx = NewDropAllBrokerClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3510)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3511)
			p.Match(DorisParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3512)
			p.Match(DorisParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3513)

			var _x = p.IdentifierOrText()

			localctx.(*DropAllBrokerClauseContext).name = _x
		}

	case 11:
		localctx = NewAlterLoadErrorUrlClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3514)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3515)
			p.Match(DorisParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3516)
			p.Match(DorisParserERRORS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3517)
			p.Match(DorisParserHUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3518)

				var _x = p.PropertyClause()

				localctx.(*AlterLoadErrorUrlClauseContext).properties = _x
			}

		}

	case 12:
		localctx = NewModifyBackendClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3521)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3522)
			p.Match(DorisParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3523)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ModifyBackendClauseContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ModifyBackendClauseContext).hostPorts = append(localctx.(*ModifyBackendClauseContext).hostPorts, localctx.(*ModifyBackendClauseContext)._STRING_LITERAL)
		p.SetState(3528)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(3524)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3525)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*ModifyBackendClauseContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*ModifyBackendClauseContext).hostPorts = append(localctx.(*ModifyBackendClauseContext).hostPorts, localctx.(*ModifyBackendClauseContext)._STRING_LITERAL)

			p.SetState(3530)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3531)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3532)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3533)
			p.PropertyItemList()
		}
		{
			p.SetState(3534)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		localctx = NewModifyFrontendOrBackendHostNameClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3536)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3537)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserBACKEND || _la == DorisParserFRONTEND) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3538)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ModifyFrontendOrBackendHostNameClauseContext).hostPort = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3539)
			p.Match(DorisParserHOSTNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3540)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ModifyFrontendOrBackendHostNameClauseContext).hostName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropRollupClauseContext is an interface to support dynamic dispatch.
type IDropRollupClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// GetProperties returns the properties rule contexts.
	GetProperties() IPropertyClauseContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// SetProperties sets the properties rule contexts.
	SetProperties(IPropertyClauseContext)

	// Getter signatures
	Identifier() IIdentifierContext
	PropertyClause() IPropertyClauseContext

	// IsDropRollupClauseContext differentiates from other interfaces.
	IsDropRollupClauseContext()
}

type DropRollupClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
	properties IPropertyClauseContext
}

func NewEmptyDropRollupClauseContext() *DropRollupClauseContext {
	var p = new(DropRollupClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dropRollupClause
	return p
}

func InitEmptyDropRollupClauseContext(p *DropRollupClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dropRollupClause
}

func (*DropRollupClauseContext) IsDropRollupClauseContext() {}

func NewDropRollupClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropRollupClauseContext {
	var p = new(DropRollupClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_dropRollupClause

	return p
}

func (s *DropRollupClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropRollupClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *DropRollupClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *DropRollupClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *DropRollupClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *DropRollupClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropRollupClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *DropRollupClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRollupClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropRollupClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropRollupClause(s)
	}
}

func (s *DropRollupClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropRollupClause(s)
	}
}

func (p *DorisParser) DropRollupClause() (localctx IDropRollupClauseContext) {
	localctx = NewDropRollupClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, DorisParserRULE_dropRollupClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3543)

		var _x = p.Identifier()

		localctx.(*DropRollupClauseContext).rollupName = _x
	}
	p.SetState(3545)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPROPERTIES {
		{
			p.SetState(3544)

			var _x = p.PropertyClause()

			localctx.(*DropRollupClauseContext).properties = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddRollupClauseContext is an interface to support dynamic dispatch.
type IAddRollupClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IIdentifierListContext

	// GetDupKeys returns the dupKeys rule contexts.
	GetDupKeys() IIdentifierListContext

	// GetProperties returns the properties rule contexts.
	GetProperties() IPropertyClauseContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IIdentifierListContext)

	// SetDupKeys sets the dupKeys rule contexts.
	SetDupKeys(IIdentifierListContext)

	// SetProperties sets the properties rule contexts.
	SetProperties(IPropertyClauseContext)

	// Getter signatures
	Identifier() IIdentifierContext
	AllIdentifierList() []IIdentifierListContext
	IdentifierList(i int) IIdentifierListContext
	DUPLICATE() antlr.TerminalNode
	KEY() antlr.TerminalNode
	FromRollup() IFromRollupContext
	PropertyClause() IPropertyClauseContext

	// IsAddRollupClauseContext differentiates from other interfaces.
	IsAddRollupClauseContext()
}

type AddRollupClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
	columns    IIdentifierListContext
	dupKeys    IIdentifierListContext
	properties IPropertyClauseContext
}

func NewEmptyAddRollupClauseContext() *AddRollupClauseContext {
	var p = new(AddRollupClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_addRollupClause
	return p
}

func InitEmptyAddRollupClauseContext(p *AddRollupClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_addRollupClause
}

func (*AddRollupClauseContext) IsAddRollupClauseContext() {}

func NewAddRollupClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddRollupClauseContext {
	var p = new(AddRollupClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_addRollupClause

	return p
}

func (s *AddRollupClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddRollupClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *AddRollupClauseContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *AddRollupClauseContext) GetDupKeys() IIdentifierListContext { return s.dupKeys }

func (s *AddRollupClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AddRollupClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *AddRollupClauseContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *AddRollupClauseContext) SetDupKeys(v IIdentifierListContext) { s.dupKeys = v }

func (s *AddRollupClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AddRollupClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddRollupClauseContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *AddRollupClauseContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *AddRollupClauseContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(DorisParserDUPLICATE, 0)
}

func (s *AddRollupClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserKEY, 0)
}

func (s *AddRollupClauseContext) FromRollup() IFromRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromRollupContext)
}

func (s *AddRollupClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AddRollupClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddRollupClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddRollupClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddRollupClause(s)
	}
}

func (s *AddRollupClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddRollupClause(s)
	}
}

func (p *DorisParser) AddRollupClause() (localctx IAddRollupClauseContext) {
	localctx = NewAddRollupClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, DorisParserRULE_addRollupClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3547)

		var _x = p.Identifier()

		localctx.(*AddRollupClauseContext).rollupName = _x
	}
	{
		p.SetState(3548)

		var _x = p.IdentifierList()

		localctx.(*AddRollupClauseContext).columns = _x
	}
	p.SetState(3552)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserDUPLICATE {
		{
			p.SetState(3549)
			p.Match(DorisParserDUPLICATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3550)
			p.Match(DorisParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3551)

			var _x = p.IdentifierList()

			localctx.(*AddRollupClauseContext).dupKeys = _x
		}

	}
	p.SetState(3555)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserFROM {
		{
			p.SetState(3554)
			p.FromRollup()
		}

	}
	p.SetState(3558)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPROPERTIES {
		{
			p.SetState(3557)

			var _x = p.PropertyClause()

			localctx.(*AddRollupClauseContext).properties = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableClauseContext is an interface to support dynamic dispatch.
type IAlterTableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlterTableClauseContext differentiates from other interfaces.
	IsAlterTableClauseContext()
}

type AlterTableClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableClauseContext() *AlterTableClauseContext {
	var p = new(AlterTableClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_alterTableClause
	return p
}

func InitEmptyAlterTableClauseContext(p *AlterTableClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_alterTableClause
}

func (*AlterTableClauseContext) IsAlterTableClauseContext() {}

func NewAlterTableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableClauseContext {
	var p = new(AlterTableClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_alterTableClause

	return p
}

func (s *AlterTableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableClauseContext) CopyAll(ctx *AlterTableClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AlterTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AddPartitionClauseContext struct {
	AlterTableClauseContext
	hashKeys   IIdentifierListContext
	autoBucket antlr.Token
	properties IPropertyClauseContext
}

func NewAddPartitionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddPartitionClauseContext {
	var p = new(AddPartitionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AddPartitionClauseContext) GetAutoBucket() antlr.Token { return s.autoBucket }

func (s *AddPartitionClauseContext) SetAutoBucket(v antlr.Token) { s.autoBucket = v }

func (s *AddPartitionClauseContext) GetHashKeys() IIdentifierListContext { return s.hashKeys }

func (s *AddPartitionClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AddPartitionClauseContext) SetHashKeys(v IIdentifierListContext) { s.hashKeys = v }

func (s *AddPartitionClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AddPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddPartitionClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddPartitionClauseContext) PartitionDef() IPartitionDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefContext)
}

func (s *AddPartitionClauseContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *AddPartitionClauseContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTRIBUTED, 0)
}

func (s *AddPartitionClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *AddPartitionClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AddPartitionClauseContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisParserHASH, 0)
}

func (s *AddPartitionClauseContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(DorisParserRANDOM, 0)
}

func (s *AddPartitionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *AddPartitionClauseContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisParserBUCKETS, 0)
}

func (s *AddPartitionClauseContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *AddPartitionClauseContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO, 0)
}

func (s *AddPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddPartitionClause(s)
	}
}

func (s *AddPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddPartitionClause(s)
	}
}

type ModifyDistributionClauseContext struct {
	AlterTableClauseContext
	hashKeys   IIdentifierListContext
	autoBucket antlr.Token
}

func NewModifyDistributionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyDistributionClauseContext {
	var p = new(ModifyDistributionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ModifyDistributionClauseContext) GetAutoBucket() antlr.Token { return s.autoBucket }

func (s *ModifyDistributionClauseContext) SetAutoBucket(v antlr.Token) { s.autoBucket = v }

func (s *ModifyDistributionClauseContext) GetHashKeys() IIdentifierListContext { return s.hashKeys }

func (s *ModifyDistributionClauseContext) SetHashKeys(v IIdentifierListContext) { s.hashKeys = v }

func (s *ModifyDistributionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyDistributionClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *ModifyDistributionClauseContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTRIBUTION, 0)
}

func (s *ModifyDistributionClauseContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTRIBUTED, 0)
}

func (s *ModifyDistributionClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *ModifyDistributionClauseContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisParserHASH, 0)
}

func (s *ModifyDistributionClauseContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(DorisParserRANDOM, 0)
}

func (s *ModifyDistributionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ModifyDistributionClauseContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisParserBUCKETS, 0)
}

func (s *ModifyDistributionClauseContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ModifyDistributionClauseContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO, 0)
}

func (s *ModifyDistributionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterModifyDistributionClause(s)
	}
}

func (s *ModifyDistributionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitModifyDistributionClause(s)
	}
}

type AddColumnClauseContext struct {
	AlterTableClauseContext
	properties IPropertyClauseContext
}

func NewAddColumnClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddColumnClauseContext {
	var p = new(AddColumnClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AddColumnClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AddColumnClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AddColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddColumnClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *AddColumnClauseContext) ColumnDef() IColumnDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefContext)
}

func (s *AddColumnClauseContext) ColumnPosition() IColumnPositionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnPositionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnPositionContext)
}

func (s *AddColumnClauseContext) ToRollup() IToRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IToRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IToRollupContext)
}

func (s *AddColumnClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AddColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddColumnClause(s)
	}
}

func (s *AddColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddColumnClause(s)
	}
}

type ModifyColumnClauseContext struct {
	AlterTableClauseContext
	properties IPropertyClauseContext
}

func NewModifyColumnClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyColumnClauseContext {
	var p = new(ModifyColumnClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ModifyColumnClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *ModifyColumnClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *ModifyColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyColumnClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *ModifyColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *ModifyColumnClauseContext) ColumnDef() IColumnDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefContext)
}

func (s *ModifyColumnClauseContext) ColumnPosition() IColumnPositionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnPositionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnPositionContext)
}

func (s *ModifyColumnClauseContext) FromRollup() IFromRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromRollupContext)
}

func (s *ModifyColumnClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ModifyColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterModifyColumnClause(s)
	}
}

func (s *ModifyColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitModifyColumnClause(s)
	}
}

type RenameRollupClauseContext struct {
	AlterTableClauseContext
	name    IIdentifierContext
	newName IIdentifierContext
}

func NewRenameRollupClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameRollupClauseContext {
	var p = new(RenameRollupClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *RenameRollupClauseContext) GetName() IIdentifierContext { return s.name }

func (s *RenameRollupClauseContext) GetNewName() IIdentifierContext { return s.newName }

func (s *RenameRollupClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *RenameRollupClauseContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *RenameRollupClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameRollupClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserRENAME, 0)
}

func (s *RenameRollupClauseContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *RenameRollupClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RenameRollupClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenameRollupClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRenameRollupClause(s)
	}
}

func (s *RenameRollupClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRenameRollupClause(s)
	}
}

type AddColumnsClauseContext struct {
	AlterTableClauseContext
	properties IPropertyClauseContext
}

func NewAddColumnsClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddColumnsClauseContext {
	var p = new(AddColumnsClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AddColumnsClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AddColumnsClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AddColumnsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddColumnsClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddColumnsClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *AddColumnsClauseContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AddColumnsClauseContext) ColumnDefs() IColumnDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefsContext)
}

func (s *AddColumnsClauseContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AddColumnsClauseContext) ToRollup() IToRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IToRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IToRollupContext)
}

func (s *AddColumnsClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AddColumnsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddColumnsClause(s)
	}
}

func (s *AddColumnsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddColumnsClause(s)
	}
}

type ReplaceTableClauseContext struct {
	AlterTableClauseContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewReplaceTableClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReplaceTableClauseContext {
	var p = new(ReplaceTableClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ReplaceTableClauseContext) GetName() IIdentifierContext { return s.name }

func (s *ReplaceTableClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *ReplaceTableClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ReplaceTableClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *ReplaceTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplaceTableClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *ReplaceTableClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *ReplaceTableClauseContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *ReplaceTableClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReplaceTableClauseContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserFORCE, 0)
}

func (s *ReplaceTableClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ReplaceTableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterReplaceTableClause(s)
	}
}

func (s *ReplaceTableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitReplaceTableClause(s)
	}
}

type RenamePartitionClauseContext struct {
	AlterTableClauseContext
	name    IIdentifierContext
	newName IIdentifierContext
}

func NewRenamePartitionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenamePartitionClauseContext {
	var p = new(RenamePartitionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *RenamePartitionClauseContext) GetName() IIdentifierContext { return s.name }

func (s *RenamePartitionClauseContext) GetNewName() IIdentifierContext { return s.newName }

func (s *RenamePartitionClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *RenamePartitionClauseContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *RenamePartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenamePartitionClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserRENAME, 0)
}

func (s *RenamePartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *RenamePartitionClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RenamePartitionClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenamePartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRenamePartitionClause(s)
	}
}

func (s *RenamePartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRenamePartitionClause(s)
	}
}

type DropIndexClauseContext struct {
	AlterTableClauseContext
	name IIdentifierContext
}

func NewDropIndexClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropIndexClauseContext {
	var p = new(DropIndexClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *DropIndexClauseContext) GetName() IIdentifierContext { return s.name }

func (s *DropIndexClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropIndexClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropIndexClauseContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *DropIndexClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropIndexClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropIndexClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropIndexClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropIndexClause(s)
	}
}

func (s *DropIndexClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropIndexClause(s)
	}
}

type DropColumnClauseContext struct {
	AlterTableClauseContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewDropColumnClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropColumnClauseContext {
	var p = new(DropColumnClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *DropColumnClauseContext) GetName() IIdentifierContext { return s.name }

func (s *DropColumnClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *DropColumnClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropColumnClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *DropColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropColumnClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *DropColumnClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropColumnClauseContext) FromRollup() IFromRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromRollupContext)
}

func (s *DropColumnClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *DropColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropColumnClause(s)
	}
}

func (s *DropColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropColumnClause(s)
	}
}

type DropPartitionClauseContext struct {
	AlterTableClauseContext
	partitionName IIdentifierContext
	indexName     IIdentifierContext
}

func NewDropPartitionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropPartitionClauseContext {
	var p = new(DropPartitionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *DropPartitionClauseContext) GetPartitionName() IIdentifierContext { return s.partitionName }

func (s *DropPartitionClauseContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *DropPartitionClauseContext) SetPartitionName(v IIdentifierContext) { s.partitionName = v }

func (s *DropPartitionClauseContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *DropPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropPartitionClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropPartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *DropPartitionClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DropPartitionClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropPartitionClauseContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *DropPartitionClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *DropPartitionClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *DropPartitionClauseContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserFORCE, 0)
}

func (s *DropPartitionClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *DropPartitionClauseContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *DropPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropPartitionClause(s)
	}
}

func (s *DropPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropPartitionClause(s)
	}
}

type ReplacePartitionClauseContext struct {
	AlterTableClauseContext
	partitions     IPartitionSpecContext
	tempPartitions IPartitionSpecContext
	properties     IPropertyClauseContext
}

func NewReplacePartitionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReplacePartitionClauseContext {
	var p = new(ReplacePartitionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ReplacePartitionClauseContext) GetPartitions() IPartitionSpecContext { return s.partitions }

func (s *ReplacePartitionClauseContext) GetTempPartitions() IPartitionSpecContext {
	return s.tempPartitions
}

func (s *ReplacePartitionClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *ReplacePartitionClauseContext) SetPartitions(v IPartitionSpecContext) { s.partitions = v }

func (s *ReplacePartitionClauseContext) SetTempPartitions(v IPartitionSpecContext) {
	s.tempPartitions = v
}

func (s *ReplacePartitionClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *ReplacePartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplacePartitionClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *ReplacePartitionClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *ReplacePartitionClauseContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserFORCE, 0)
}

func (s *ReplacePartitionClauseContext) AllPartitionSpec() []IPartitionSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			len++
		}
	}

	tst := make([]IPartitionSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionSpecContext); ok {
			tst[i] = t.(IPartitionSpecContext)
			i++
		}
	}

	return tst
}

func (s *ReplacePartitionClauseContext) PartitionSpec(i int) IPartitionSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *ReplacePartitionClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ReplacePartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterReplacePartitionClause(s)
	}
}

func (s *ReplacePartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitReplacePartitionClause(s)
	}
}

type RenameClauseContext struct {
	AlterTableClauseContext
	newName IIdentifierContext
}

func NewRenameClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameClauseContext {
	var p = new(RenameClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *RenameClauseContext) GetNewName() IIdentifierContext { return s.newName }

func (s *RenameClauseContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *RenameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserRENAME, 0)
}

func (s *RenameClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRenameClause(s)
	}
}

func (s *RenameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRenameClause(s)
	}
}

type ModifyTableCommentClauseContext struct {
	AlterTableClauseContext
	comment antlr.Token
}

func NewModifyTableCommentClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyTableCommentClauseContext {
	var p = new(ModifyTableCommentClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ModifyTableCommentClauseContext) GetComment() antlr.Token { return s.comment }

func (s *ModifyTableCommentClauseContext) SetComment(v antlr.Token) { s.comment = v }

func (s *ModifyTableCommentClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyTableCommentClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *ModifyTableCommentClauseContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *ModifyTableCommentClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ModifyTableCommentClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterModifyTableCommentClause(s)
	}
}

func (s *ModifyTableCommentClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitModifyTableCommentClause(s)
	}
}

type ModifyPartitionClauseContext struct {
	AlterTableClauseContext
	partitionName       IIdentifierContext
	partitionNames      IIdentifierListContext
	partitionProperties IPropertyItemListContext
}

func NewModifyPartitionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyPartitionClauseContext {
	var p = new(ModifyPartitionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ModifyPartitionClauseContext) GetPartitionName() IIdentifierContext { return s.partitionName }

func (s *ModifyPartitionClauseContext) GetPartitionNames() IIdentifierListContext {
	return s.partitionNames
}

func (s *ModifyPartitionClauseContext) GetPartitionProperties() IPropertyItemListContext {
	return s.partitionProperties
}

func (s *ModifyPartitionClauseContext) SetPartitionName(v IIdentifierContext) { s.partitionName = v }

func (s *ModifyPartitionClauseContext) SetPartitionNames(v IIdentifierListContext) {
	s.partitionNames = v
}

func (s *ModifyPartitionClauseContext) SetPartitionProperties(v IPropertyItemListContext) {
	s.partitionProperties = v
}

func (s *ModifyPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyPartitionClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *ModifyPartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *ModifyPartitionClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *ModifyPartitionClauseContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserLEFT_PAREN)
}

func (s *ModifyPartitionClauseContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, i)
}

func (s *ModifyPartitionClauseContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserRIGHT_PAREN)
}

func (s *ModifyPartitionClauseContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, i)
}

func (s *ModifyPartitionClauseContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *ModifyPartitionClauseContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserASTERISK, 0)
}

func (s *ModifyPartitionClauseContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *ModifyPartitionClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifyPartitionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ModifyPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterModifyPartitionClause(s)
	}
}

func (s *ModifyPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitModifyPartitionClause(s)
	}
}

type ModifyEngineClauseContext struct {
	AlterTableClauseContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewModifyEngineClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyEngineClauseContext {
	var p = new(ModifyEngineClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ModifyEngineClauseContext) GetName() IIdentifierContext { return s.name }

func (s *ModifyEngineClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *ModifyEngineClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ModifyEngineClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *ModifyEngineClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyEngineClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *ModifyEngineClauseContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(DorisParserENGINE, 0)
}

func (s *ModifyEngineClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *ModifyEngineClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifyEngineClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ModifyEngineClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterModifyEngineClause(s)
	}
}

func (s *ModifyEngineClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitModifyEngineClause(s)
	}
}

type ReorderColumnsClauseContext struct {
	AlterTableClauseContext
	properties IPropertyClauseContext
}

func NewReorderColumnsClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReorderColumnsClauseContext {
	var p = new(ReorderColumnsClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ReorderColumnsClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *ReorderColumnsClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *ReorderColumnsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReorderColumnsClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisParserORDER, 0)
}

func (s *ReorderColumnsClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *ReorderColumnsClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ReorderColumnsClauseContext) FromRollup() IFromRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromRollupContext)
}

func (s *ReorderColumnsClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ReorderColumnsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterReorderColumnsClause(s)
	}
}

func (s *ReorderColumnsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitReorderColumnsClause(s)
	}
}

type AddIndexClauseContext struct {
	AlterTableClauseContext
}

func NewAddIndexClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddIndexClauseContext {
	var p = new(AddIndexClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AddIndexClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddIndexClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AddIndexClauseContext) IndexDef() IIndexDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexDefContext)
}

func (s *AddIndexClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAddIndexClause(s)
	}
}

func (s *AddIndexClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAddIndexClause(s)
	}
}

type ModifyColumnCommentClauseContext struct {
	AlterTableClauseContext
	name    IIdentifierContext
	comment antlr.Token
}

func NewModifyColumnCommentClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyColumnCommentClauseContext {
	var p = new(ModifyColumnCommentClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ModifyColumnCommentClauseContext) GetComment() antlr.Token { return s.comment }

func (s *ModifyColumnCommentClauseContext) SetComment(v antlr.Token) { s.comment = v }

func (s *ModifyColumnCommentClauseContext) GetName() IIdentifierContext { return s.name }

func (s *ModifyColumnCommentClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ModifyColumnCommentClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyColumnCommentClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *ModifyColumnCommentClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *ModifyColumnCommentClauseContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *ModifyColumnCommentClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifyColumnCommentClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ModifyColumnCommentClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterModifyColumnCommentClause(s)
	}
}

func (s *ModifyColumnCommentClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitModifyColumnCommentClause(s)
	}
}

type AlterMultiPartitionClauseContext struct {
	AlterTableClauseContext
	from       IPartitionValueListContext
	to         IPartitionValueListContext
	unit       IIdentifierContext
	properties IPropertyClauseContext
}

func NewAlterMultiPartitionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterMultiPartitionClauseContext {
	var p = new(AlterMultiPartitionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterMultiPartitionClauseContext) GetFrom() IPartitionValueListContext { return s.from }

func (s *AlterMultiPartitionClauseContext) GetTo() IPartitionValueListContext { return s.to }

func (s *AlterMultiPartitionClauseContext) GetUnit() IIdentifierContext { return s.unit }

func (s *AlterMultiPartitionClauseContext) GetProperties() IPropertyClauseContext {
	return s.properties
}

func (s *AlterMultiPartitionClauseContext) SetFrom(v IPartitionValueListContext) { s.from = v }

func (s *AlterMultiPartitionClauseContext) SetTo(v IPartitionValueListContext) { s.to = v }

func (s *AlterMultiPartitionClauseContext) SetUnit(v IIdentifierContext) { s.unit = v }

func (s *AlterMultiPartitionClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterMultiPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterMultiPartitionClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *AlterMultiPartitionClauseContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITIONS, 0)
}

func (s *AlterMultiPartitionClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *AlterMultiPartitionClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *AlterMultiPartitionClauseContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DorisParserINTERVAL, 0)
}

func (s *AlterMultiPartitionClauseContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *AlterMultiPartitionClauseContext) AllPartitionValueList() []IPartitionValueListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueListContext); ok {
			tst[i] = t.(IPartitionValueListContext)
			i++
		}
	}

	return tst
}

func (s *AlterMultiPartitionClauseContext) PartitionValueList(i int) IPartitionValueListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueListContext)
}

func (s *AlterMultiPartitionClauseContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *AlterMultiPartitionClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterMultiPartitionClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterMultiPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterMultiPartitionClause(s)
	}
}

func (s *AlterMultiPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterMultiPartitionClause(s)
	}
}

type RenameColumnClauseContext struct {
	AlterTableClauseContext
	name    IIdentifierContext
	newName IIdentifierContext
}

func NewRenameColumnClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameColumnClauseContext {
	var p = new(RenameColumnClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *RenameColumnClauseContext) GetName() IIdentifierContext { return s.name }

func (s *RenameColumnClauseContext) GetNewName() IIdentifierContext { return s.newName }

func (s *RenameColumnClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *RenameColumnClauseContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *RenameColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameColumnClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserRENAME, 0)
}

func (s *RenameColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *RenameColumnClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RenameColumnClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenameColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRenameColumnClause(s)
	}
}

func (s *RenameColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRenameColumnClause(s)
	}
}

type CreateOrReplaceTagClausesContext struct {
	AlterTableClauseContext
}

func NewCreateOrReplaceTagClausesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateOrReplaceTagClausesContext {
	var p = new(CreateOrReplaceTagClausesContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *CreateOrReplaceTagClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateOrReplaceTagClausesContext) CreateOrReplaceTagClause() ICreateOrReplaceTagClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateOrReplaceTagClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateOrReplaceTagClauseContext)
}

func (s *CreateOrReplaceTagClausesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateOrReplaceTagClauses(s)
	}
}

func (s *CreateOrReplaceTagClausesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateOrReplaceTagClauses(s)
	}
}

type EnableFeatureClauseContext struct {
	AlterTableClauseContext
	name       antlr.Token
	properties IPropertyClauseContext
}

func NewEnableFeatureClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EnableFeatureClauseContext {
	var p = new(EnableFeatureClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *EnableFeatureClauseContext) GetName() antlr.Token { return s.name }

func (s *EnableFeatureClauseContext) SetName(v antlr.Token) { s.name = v }

func (s *EnableFeatureClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *EnableFeatureClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *EnableFeatureClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnableFeatureClauseContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserENABLE, 0)
}

func (s *EnableFeatureClauseContext) FEATURE() antlr.TerminalNode {
	return s.GetToken(DorisParserFEATURE, 0)
}

func (s *EnableFeatureClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *EnableFeatureClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *EnableFeatureClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *EnableFeatureClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterEnableFeatureClause(s)
	}
}

func (s *EnableFeatureClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitEnableFeatureClause(s)
	}
}

type CreateOrReplaceBranchClausesContext struct {
	AlterTableClauseContext
}

func NewCreateOrReplaceBranchClausesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateOrReplaceBranchClausesContext {
	var p = new(CreateOrReplaceBranchClausesContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *CreateOrReplaceBranchClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateOrReplaceBranchClausesContext) CreateOrReplaceBranchClause() ICreateOrReplaceBranchClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateOrReplaceBranchClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateOrReplaceBranchClauseContext)
}

func (s *CreateOrReplaceBranchClausesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateOrReplaceBranchClauses(s)
	}
}

func (s *CreateOrReplaceBranchClausesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateOrReplaceBranchClauses(s)
	}
}

func (p *DorisParser) AlterTableClause() (localctx IAlterTableClauseContext) {
	localctx = NewAlterTableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, DorisParserRULE_alterTableClause)
	var _la int

	p.SetState(3782)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 521, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAddColumnClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3560)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3561)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3562)
			p.ColumnDef()
		}
		p.SetState(3564)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAFTER || _la == DorisParserFIRST {
			{
				p.SetState(3563)
				p.ColumnPosition()
			}

		}
		p.SetState(3567)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIN || _la == DorisParserTO {
			{
				p.SetState(3566)
				p.ToRollup()
			}

		}
		p.SetState(3570)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3569)

				var _x = p.PropertyClause()

				localctx.(*AddColumnClauseContext).properties = _x
			}

		}

	case 2:
		localctx = NewAddColumnsClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3572)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3573)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3574)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3575)
			p.ColumnDefs()
		}
		{
			p.SetState(3576)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3578)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIN || _la == DorisParserTO {
			{
				p.SetState(3577)
				p.ToRollup()
			}

		}
		p.SetState(3581)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3580)

				var _x = p.PropertyClause()

				localctx.(*AddColumnsClauseContext).properties = _x
			}

		}

	case 3:
		localctx = NewDropColumnClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3583)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3584)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3585)

			var _x = p.Identifier()

			localctx.(*DropColumnClauseContext).name = _x
		}
		p.SetState(3587)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(3586)
				p.FromRollup()
			}

		}
		p.SetState(3590)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3589)

				var _x = p.PropertyClause()

				localctx.(*DropColumnClauseContext).properties = _x
			}

		}

	case 4:
		localctx = NewModifyColumnClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3592)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3593)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3594)
			p.ColumnDef()
		}
		p.SetState(3596)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAFTER || _la == DorisParserFIRST {
			{
				p.SetState(3595)
				p.ColumnPosition()
			}

		}
		p.SetState(3599)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(3598)
				p.FromRollup()
			}

		}
		p.SetState(3602)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3601)

				var _x = p.PropertyClause()

				localctx.(*ModifyColumnClauseContext).properties = _x
			}

		}

	case 5:
		localctx = NewReorderColumnsClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3604)
			p.Match(DorisParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3605)
			p.Match(DorisParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3606)
			p.IdentifierList()
		}
		p.SetState(3608)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(3607)
				p.FromRollup()
			}

		}
		p.SetState(3611)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3610)

				var _x = p.PropertyClause()

				localctx.(*ReorderColumnsClauseContext).properties = _x
			}

		}

	case 6:
		localctx = NewAddPartitionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3613)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3615)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(3614)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3617)
			p.PartitionDef()
		}
		p.SetState(3632)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserDISTRIBUTED {
			{
				p.SetState(3618)
				p.Match(DorisParserDISTRIBUTED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3619)
				p.Match(DorisParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3623)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserHASH:
				{
					p.SetState(3620)
					p.Match(DorisParserHASH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3621)

					var _x = p.IdentifierList()

					localctx.(*AddPartitionClauseContext).hashKeys = _x
				}

			case DorisParserRANDOM:
				{
					p.SetState(3622)
					p.Match(DorisParserRANDOM)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			p.SetState(3630)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserBUCKETS {
				{
					p.SetState(3625)
					p.Match(DorisParserBUCKETS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(3628)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DorisParserINTEGER_VALUE:
					{
						p.SetState(3626)
						p.Match(DorisParserINTEGER_VALUE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case DorisParserAUTO:
					{
						p.SetState(3627)

						var _m = p.Match(DorisParserAUTO)

						localctx.(*AddPartitionClauseContext).autoBucket = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			}

		}
		p.SetState(3635)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3634)

				var _x = p.PropertyClause()

				localctx.(*AddPartitionClauseContext).properties = _x
			}

		}

	case 7:
		localctx = NewDropPartitionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3637)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3639)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(3638)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3641)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3644)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(3642)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3643)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3646)

			var _x = p.Identifier()

			localctx.(*DropPartitionClauseContext).partitionName = _x
		}
		p.SetState(3648)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFORCE {
			{
				p.SetState(3647)
				p.Match(DorisParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3653)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFROM {
			{
				p.SetState(3650)
				p.Match(DorisParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3651)
				p.Match(DorisParserINDEX)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3652)

				var _x = p.Identifier()

				localctx.(*DropPartitionClauseContext).indexName = _x
			}

		}

	case 8:
		localctx = NewModifyPartitionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3655)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3657)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(3656)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3659)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3665)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 504, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3660)

				var _x = p.Identifier()

				localctx.(*ModifyPartitionClauseContext).partitionName = _x
			}

		case 2:
			{
				p.SetState(3661)

				var _x = p.IdentifierList()

				localctx.(*ModifyPartitionClauseContext).partitionNames = _x
			}

		case 3:
			{
				p.SetState(3662)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3663)
				p.Match(DorisParserASTERISK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3664)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(3667)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3668)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3669)

			var _x = p.PropertyItemList()

			localctx.(*ModifyPartitionClauseContext).partitionProperties = _x
		}
		{
			p.SetState(3670)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewReplacePartitionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3672)
			p.Match(DorisParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3674)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(3673)

				var _x = p.PartitionSpec()

				localctx.(*ReplacePartitionClauseContext).partitions = _x
			}

		}
		{
			p.SetState(3676)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3678)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(3677)

				var _x = p.PartitionSpec()

				localctx.(*ReplacePartitionClauseContext).tempPartitions = _x
			}

		}
		p.SetState(3681)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFORCE {
			{
				p.SetState(3680)
				p.Match(DorisParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3684)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3683)

				var _x = p.PropertyClause()

				localctx.(*ReplacePartitionClauseContext).properties = _x
			}

		}

	case 10:
		localctx = NewReplaceTableClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3686)
			p.Match(DorisParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3687)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3688)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3689)

			var _x = p.Identifier()

			localctx.(*ReplaceTableClauseContext).name = _x
		}
		p.SetState(3691)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3690)

				var _x = p.PropertyClause()

				localctx.(*ReplaceTableClauseContext).properties = _x
			}

		}
		p.SetState(3694)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFORCE {
			{
				p.SetState(3693)
				p.Match(DorisParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 11:
		localctx = NewRenameClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3696)
			p.Match(DorisParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3697)

			var _x = p.Identifier()

			localctx.(*RenameClauseContext).newName = _x
		}

	case 12:
		localctx = NewRenameRollupClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3698)
			p.Match(DorisParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3699)
			p.Match(DorisParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3700)

			var _x = p.Identifier()

			localctx.(*RenameRollupClauseContext).name = _x
		}
		{
			p.SetState(3701)

			var _x = p.Identifier()

			localctx.(*RenameRollupClauseContext).newName = _x
		}

	case 13:
		localctx = NewRenamePartitionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3703)
			p.Match(DorisParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3704)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3705)

			var _x = p.Identifier()

			localctx.(*RenamePartitionClauseContext).name = _x
		}
		{
			p.SetState(3706)

			var _x = p.Identifier()

			localctx.(*RenamePartitionClauseContext).newName = _x
		}

	case 14:
		localctx = NewRenameColumnClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3708)
			p.Match(DorisParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3709)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3710)

			var _x = p.Identifier()

			localctx.(*RenameColumnClauseContext).name = _x
		}
		{
			p.SetState(3711)

			var _x = p.Identifier()

			localctx.(*RenameColumnClauseContext).newName = _x
		}

	case 15:
		localctx = NewAddIndexClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3713)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3714)
			p.IndexDef()
		}

	case 16:
		localctx = NewDropIndexClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3715)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3716)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3719)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(3717)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3718)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3721)

			var _x = p.Identifier()

			localctx.(*DropIndexClauseContext).name = _x
		}

	case 17:
		localctx = NewEnableFeatureClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(3722)
			p.Match(DorisParserENABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3723)
			p.Match(DorisParserFEATURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3724)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*EnableFeatureClauseContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3727)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWITH {
			{
				p.SetState(3725)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3726)

				var _x = p.PropertyClause()

				localctx.(*EnableFeatureClauseContext).properties = _x
			}

		}

	case 18:
		localctx = NewModifyDistributionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(3729)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3730)
			p.Match(DorisParserDISTRIBUTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3745)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserDISTRIBUTED {
			{
				p.SetState(3731)
				p.Match(DorisParserDISTRIBUTED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3732)
				p.Match(DorisParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3736)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserHASH:
				{
					p.SetState(3733)
					p.Match(DorisParserHASH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3734)

					var _x = p.IdentifierList()

					localctx.(*ModifyDistributionClauseContext).hashKeys = _x
				}

			case DorisParserRANDOM:
				{
					p.SetState(3735)
					p.Match(DorisParserRANDOM)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			p.SetState(3743)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserBUCKETS {
				{
					p.SetState(3738)
					p.Match(DorisParserBUCKETS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(3741)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DorisParserINTEGER_VALUE:
					{
						p.SetState(3739)
						p.Match(DorisParserINTEGER_VALUE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case DorisParserAUTO:
					{
						p.SetState(3740)

						var _m = p.Match(DorisParserAUTO)

						localctx.(*ModifyDistributionClauseContext).autoBucket = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			}

		}

	case 19:
		localctx = NewModifyTableCommentClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(3747)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3748)
			p.Match(DorisParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3749)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ModifyTableCommentClauseContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		localctx = NewModifyColumnCommentClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(3750)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3751)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3752)

			var _x = p.Identifier()

			localctx.(*ModifyColumnCommentClauseContext).name = _x
		}
		{
			p.SetState(3753)
			p.Match(DorisParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3754)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ModifyColumnCommentClauseContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		localctx = NewModifyEngineClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(3756)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3757)
			p.Match(DorisParserENGINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3758)
			p.Match(DorisParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3759)

			var _x = p.Identifier()

			localctx.(*ModifyEngineClauseContext).name = _x
		}
		p.SetState(3761)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3760)

				var _x = p.PropertyClause()

				localctx.(*ModifyEngineClauseContext).properties = _x
			}

		}

	case 22:
		localctx = NewAlterMultiPartitionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(3763)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3765)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(3764)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3767)
			p.Match(DorisParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3768)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3769)

			var _x = p.PartitionValueList()

			localctx.(*AlterMultiPartitionClauseContext).from = _x
		}
		{
			p.SetState(3770)
			p.Match(DorisParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3771)

			var _x = p.PartitionValueList()

			localctx.(*AlterMultiPartitionClauseContext).to = _x
		}
		{
			p.SetState(3772)
			p.Match(DorisParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3773)
			p.Match(DorisParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3775)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 519, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3774)

				var _x = p.Identifier()

				localctx.(*AlterMultiPartitionClauseContext).unit = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3778)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3777)

				var _x = p.PropertyClause()

				localctx.(*AlterMultiPartitionClauseContext).properties = _x
			}

		}

	case 23:
		localctx = NewCreateOrReplaceTagClausesContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(3780)
			p.CreateOrReplaceTagClause()
		}

	case 24:
		localctx = NewCreateOrReplaceBranchClausesContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(3781)
			p.CreateOrReplaceBranchClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateOrReplaceTagClauseContext is an interface to support dynamic dispatch.
type ICreateOrReplaceTagClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// GetOps returns the ops rule contexts.
	GetOps() ITagOptionsContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// SetOps sets the ops rule contexts.
	SetOps(ITagOptionsContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	TAG() antlr.TerminalNode
	Identifier() IIdentifierContext
	TagOptions() ITagOptionsContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	OR() antlr.TerminalNode

	// IsCreateOrReplaceTagClauseContext differentiates from other interfaces.
	IsCreateOrReplaceTagClauseContext()
}

type CreateOrReplaceTagClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
	ops    ITagOptionsContext
}

func NewEmptyCreateOrReplaceTagClauseContext() *CreateOrReplaceTagClauseContext {
	var p = new(CreateOrReplaceTagClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_createOrReplaceTagClause
	return p
}

func InitEmptyCreateOrReplaceTagClauseContext(p *CreateOrReplaceTagClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_createOrReplaceTagClause
}

func (*CreateOrReplaceTagClauseContext) IsCreateOrReplaceTagClauseContext() {}

func NewCreateOrReplaceTagClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateOrReplaceTagClauseContext {
	var p = new(CreateOrReplaceTagClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_createOrReplaceTagClause

	return p
}

func (s *CreateOrReplaceTagClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateOrReplaceTagClauseContext) GetName() IIdentifierContext { return s.name }

func (s *CreateOrReplaceTagClauseContext) GetOps() ITagOptionsContext { return s.ops }

func (s *CreateOrReplaceTagClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateOrReplaceTagClauseContext) SetOps(v ITagOptionsContext) { s.ops = v }

func (s *CreateOrReplaceTagClauseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateOrReplaceTagClauseContext) TAG() antlr.TerminalNode {
	return s.GetToken(DorisParserTAG, 0)
}

func (s *CreateOrReplaceTagClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateOrReplaceTagClauseContext) TagOptions() ITagOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITagOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITagOptionsContext)
}

func (s *CreateOrReplaceTagClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateOrReplaceTagClauseContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateOrReplaceTagClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateOrReplaceTagClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *CreateOrReplaceTagClauseContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisParserOR, 0)
}

func (s *CreateOrReplaceTagClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateOrReplaceTagClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateOrReplaceTagClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateOrReplaceTagClause(s)
	}
}

func (s *CreateOrReplaceTagClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateOrReplaceTagClause(s)
	}
}

func (p *DorisParser) CreateOrReplaceTagClause() (localctx ICreateOrReplaceTagClauseContext) {
	localctx = NewCreateOrReplaceTagClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, DorisParserRULE_createOrReplaceTagClause)
	var _la int

	p.SetState(3803)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 524, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3784)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3785)
			p.Match(DorisParserTAG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3789)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(3786)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3787)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3788)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3791)

			var _x = p.Identifier()

			localctx.(*CreateOrReplaceTagClauseContext).name = _x
		}
		{
			p.SetState(3792)

			var _x = p.TagOptions()

			localctx.(*CreateOrReplaceTagClauseContext).ops = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3796)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCREATE {
			{
				p.SetState(3794)
				p.Match(DorisParserCREATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3795)
				p.Match(DorisParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3798)
			p.Match(DorisParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3799)
			p.Match(DorisParserTAG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3800)

			var _x = p.Identifier()

			localctx.(*CreateOrReplaceTagClauseContext).name = _x
		}
		{
			p.SetState(3801)

			var _x = p.TagOptions()

			localctx.(*CreateOrReplaceTagClauseContext).ops = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateOrReplaceBranchClauseContext is an interface to support dynamic dispatch.
type ICreateOrReplaceBranchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// GetOps returns the ops rule contexts.
	GetOps() IBranchOptionsContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// SetOps sets the ops rule contexts.
	SetOps(IBranchOptionsContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	BRANCH() antlr.TerminalNode
	Identifier() IIdentifierContext
	BranchOptions() IBranchOptionsContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	OR() antlr.TerminalNode

	// IsCreateOrReplaceBranchClauseContext differentiates from other interfaces.
	IsCreateOrReplaceBranchClauseContext()
}

type CreateOrReplaceBranchClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
	ops    IBranchOptionsContext
}

func NewEmptyCreateOrReplaceBranchClauseContext() *CreateOrReplaceBranchClauseContext {
	var p = new(CreateOrReplaceBranchClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_createOrReplaceBranchClause
	return p
}

func InitEmptyCreateOrReplaceBranchClauseContext(p *CreateOrReplaceBranchClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_createOrReplaceBranchClause
}

func (*CreateOrReplaceBranchClauseContext) IsCreateOrReplaceBranchClauseContext() {}

func NewCreateOrReplaceBranchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateOrReplaceBranchClauseContext {
	var p = new(CreateOrReplaceBranchClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_createOrReplaceBranchClause

	return p
}

func (s *CreateOrReplaceBranchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateOrReplaceBranchClauseContext) GetName() IIdentifierContext { return s.name }

func (s *CreateOrReplaceBranchClauseContext) GetOps() IBranchOptionsContext { return s.ops }

func (s *CreateOrReplaceBranchClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateOrReplaceBranchClauseContext) SetOps(v IBranchOptionsContext) { s.ops = v }

func (s *CreateOrReplaceBranchClauseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATE, 0)
}

func (s *CreateOrReplaceBranchClauseContext) BRANCH() antlr.TerminalNode {
	return s.GetToken(DorisParserBRANCH, 0)
}

func (s *CreateOrReplaceBranchClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateOrReplaceBranchClauseContext) BranchOptions() IBranchOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBranchOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBranchOptionsContext)
}

func (s *CreateOrReplaceBranchClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *CreateOrReplaceBranchClauseContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *CreateOrReplaceBranchClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *CreateOrReplaceBranchClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *CreateOrReplaceBranchClauseContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisParserOR, 0)
}

func (s *CreateOrReplaceBranchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateOrReplaceBranchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateOrReplaceBranchClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCreateOrReplaceBranchClause(s)
	}
}

func (s *CreateOrReplaceBranchClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCreateOrReplaceBranchClause(s)
	}
}

func (p *DorisParser) CreateOrReplaceBranchClause() (localctx ICreateOrReplaceBranchClauseContext) {
	localctx = NewCreateOrReplaceBranchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, DorisParserRULE_createOrReplaceBranchClause)
	var _la int

	p.SetState(3824)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 527, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3805)
			p.Match(DorisParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3806)
			p.Match(DorisParserBRANCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3810)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserIF {
			{
				p.SetState(3807)
				p.Match(DorisParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3808)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3809)
				p.Match(DorisParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3812)

			var _x = p.Identifier()

			localctx.(*CreateOrReplaceBranchClauseContext).name = _x
		}
		{
			p.SetState(3813)

			var _x = p.BranchOptions()

			localctx.(*CreateOrReplaceBranchClauseContext).ops = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3817)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCREATE {
			{
				p.SetState(3815)
				p.Match(DorisParserCREATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3816)
				p.Match(DorisParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3819)
			p.Match(DorisParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3820)
			p.Match(DorisParserBRANCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3821)

			var _x = p.Identifier()

			localctx.(*CreateOrReplaceBranchClauseContext).name = _x
		}
		{
			p.SetState(3822)

			var _x = p.BranchOptions()

			localctx.(*CreateOrReplaceBranchClauseContext).ops = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITagOptionsContext is an interface to support dynamic dispatch.
type ITagOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetVersion returns the version token.
	GetVersion() antlr.Token

	// SetVersion sets the version token.
	SetVersion(antlr.Token)

	// Getter signatures
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	RetainTime() IRetainTimeContext
	INTEGER_VALUE() antlr.TerminalNode

	// IsTagOptionsContext differentiates from other interfaces.
	IsTagOptionsContext()
}

type TagOptionsContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	version antlr.Token
}

func NewEmptyTagOptionsContext() *TagOptionsContext {
	var p = new(TagOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tagOptions
	return p
}

func InitEmptyTagOptionsContext(p *TagOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tagOptions
}

func (*TagOptionsContext) IsTagOptionsContext() {}

func NewTagOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TagOptionsContext {
	var p = new(TagOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_tagOptions

	return p
}

func (s *TagOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *TagOptionsContext) GetVersion() antlr.Token { return s.version }

func (s *TagOptionsContext) SetVersion(v antlr.Token) { s.version = v }

func (s *TagOptionsContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *TagOptionsContext) OF() antlr.TerminalNode {
	return s.GetToken(DorisParserOF, 0)
}

func (s *TagOptionsContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisParserVERSION, 0)
}

func (s *TagOptionsContext) RetainTime() IRetainTimeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRetainTimeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRetainTimeContext)
}

func (s *TagOptionsContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *TagOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TagOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TagOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTagOptions(s)
	}
}

func (s *TagOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTagOptions(s)
	}
}

func (p *DorisParser) TagOptions() (localctx ITagOptionsContext) {
	localctx = NewTagOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, DorisParserRULE_tagOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3830)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserAS {
		{
			p.SetState(3826)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3827)
			p.Match(DorisParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3828)
			p.Match(DorisParserVERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3829)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*TagOptionsContext).version = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3833)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserRETAIN {
		{
			p.SetState(3832)
			p.RetainTime()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBranchOptionsContext is an interface to support dynamic dispatch.
type IBranchOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetVersion returns the version token.
	GetVersion() antlr.Token

	// SetVersion sets the version token.
	SetVersion(antlr.Token)

	// Getter signatures
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	RetainTime() IRetainTimeContext
	RetentionSnapshot() IRetentionSnapshotContext
	INTEGER_VALUE() antlr.TerminalNode

	// IsBranchOptionsContext differentiates from other interfaces.
	IsBranchOptionsContext()
}

type BranchOptionsContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	version antlr.Token
}

func NewEmptyBranchOptionsContext() *BranchOptionsContext {
	var p = new(BranchOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_branchOptions
	return p
}

func InitEmptyBranchOptionsContext(p *BranchOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_branchOptions
}

func (*BranchOptionsContext) IsBranchOptionsContext() {}

func NewBranchOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BranchOptionsContext {
	var p = new(BranchOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_branchOptions

	return p
}

func (s *BranchOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *BranchOptionsContext) GetVersion() antlr.Token { return s.version }

func (s *BranchOptionsContext) SetVersion(v antlr.Token) { s.version = v }

func (s *BranchOptionsContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *BranchOptionsContext) OF() antlr.TerminalNode {
	return s.GetToken(DorisParserOF, 0)
}

func (s *BranchOptionsContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisParserVERSION, 0)
}

func (s *BranchOptionsContext) RetainTime() IRetainTimeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRetainTimeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRetainTimeContext)
}

func (s *BranchOptionsContext) RetentionSnapshot() IRetentionSnapshotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRetentionSnapshotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRetentionSnapshotContext)
}

func (s *BranchOptionsContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *BranchOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BranchOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BranchOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBranchOptions(s)
	}
}

func (s *BranchOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBranchOptions(s)
	}
}

func (p *DorisParser) BranchOptions() (localctx IBranchOptionsContext) {
	localctx = NewBranchOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, DorisParserRULE_branchOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserAS {
		{
			p.SetState(3835)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3836)
			p.Match(DorisParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3837)
			p.Match(DorisParserVERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3838)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*BranchOptionsContext).version = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3842)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserRETAIN {
		{
			p.SetState(3841)
			p.RetainTime()
		}

	}
	p.SetState(3845)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserWITH {
		{
			p.SetState(3844)
			p.RetentionSnapshot()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRetainTimeContext is an interface to support dynamic dispatch.
type IRetainTimeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETAIN() antlr.TerminalNode
	TimeValueWithUnit() ITimeValueWithUnitContext

	// IsRetainTimeContext differentiates from other interfaces.
	IsRetainTimeContext()
}

type RetainTimeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRetainTimeContext() *RetainTimeContext {
	var p = new(RetainTimeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_retainTime
	return p
}

func InitEmptyRetainTimeContext(p *RetainTimeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_retainTime
}

func (*RetainTimeContext) IsRetainTimeContext() {}

func NewRetainTimeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RetainTimeContext {
	var p = new(RetainTimeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_retainTime

	return p
}

func (s *RetainTimeContext) GetParser() antlr.Parser { return s.parser }

func (s *RetainTimeContext) RETAIN() antlr.TerminalNode {
	return s.GetToken(DorisParserRETAIN, 0)
}

func (s *RetainTimeContext) TimeValueWithUnit() ITimeValueWithUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeValueWithUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeValueWithUnitContext)
}

func (s *RetainTimeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RetainTimeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RetainTimeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRetainTime(s)
	}
}

func (s *RetainTimeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRetainTime(s)
	}
}

func (p *DorisParser) RetainTime() (localctx IRetainTimeContext) {
	localctx = NewRetainTimeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, DorisParserRULE_retainTime)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3847)
		p.Match(DorisParserRETAIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3848)
		p.TimeValueWithUnit()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRetentionSnapshotContext is an interface to support dynamic dispatch.
type IRetentionSnapshotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	RETENTION() antlr.TerminalNode
	MinSnapshotsToKeep() IMinSnapshotsToKeepContext
	TimeValueWithUnit() ITimeValueWithUnitContext

	// IsRetentionSnapshotContext differentiates from other interfaces.
	IsRetentionSnapshotContext()
}

type RetentionSnapshotContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRetentionSnapshotContext() *RetentionSnapshotContext {
	var p = new(RetentionSnapshotContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_retentionSnapshot
	return p
}

func InitEmptyRetentionSnapshotContext(p *RetentionSnapshotContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_retentionSnapshot
}

func (*RetentionSnapshotContext) IsRetentionSnapshotContext() {}

func NewRetentionSnapshotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RetentionSnapshotContext {
	var p = new(RetentionSnapshotContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_retentionSnapshot

	return p
}

func (s *RetentionSnapshotContext) GetParser() antlr.Parser { return s.parser }

func (s *RetentionSnapshotContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *RetentionSnapshotContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisParserSNAPSHOT, 0)
}

func (s *RetentionSnapshotContext) RETENTION() antlr.TerminalNode {
	return s.GetToken(DorisParserRETENTION, 0)
}

func (s *RetentionSnapshotContext) MinSnapshotsToKeep() IMinSnapshotsToKeepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMinSnapshotsToKeepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMinSnapshotsToKeepContext)
}

func (s *RetentionSnapshotContext) TimeValueWithUnit() ITimeValueWithUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeValueWithUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeValueWithUnitContext)
}

func (s *RetentionSnapshotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RetentionSnapshotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RetentionSnapshotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRetentionSnapshot(s)
	}
}

func (s *RetentionSnapshotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRetentionSnapshot(s)
	}
}

func (p *DorisParser) RetentionSnapshot() (localctx IRetentionSnapshotContext) {
	localctx = NewRetentionSnapshotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, DorisParserRULE_retentionSnapshot)
	p.SetState(3864)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 533, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3850)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3851)
			p.Match(DorisParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3852)
			p.Match(DorisParserRETENTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3853)
			p.MinSnapshotsToKeep()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3854)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3855)
			p.Match(DorisParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3856)
			p.Match(DorisParserRETENTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3857)
			p.TimeValueWithUnit()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3858)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3859)
			p.Match(DorisParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3860)
			p.Match(DorisParserRETENTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3861)
			p.MinSnapshotsToKeep()
		}
		{
			p.SetState(3862)
			p.TimeValueWithUnit()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMinSnapshotsToKeepContext is an interface to support dynamic dispatch.
type IMinSnapshotsToKeepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value token.
	GetValue() antlr.Token

	// SetValue sets the value token.
	SetValue(antlr.Token)

	// Getter signatures
	SNAPSHOTS() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsMinSnapshotsToKeepContext differentiates from other interfaces.
	IsMinSnapshotsToKeepContext()
}

type MinSnapshotsToKeepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  antlr.Token
}

func NewEmptyMinSnapshotsToKeepContext() *MinSnapshotsToKeepContext {
	var p = new(MinSnapshotsToKeepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_minSnapshotsToKeep
	return p
}

func InitEmptyMinSnapshotsToKeepContext(p *MinSnapshotsToKeepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_minSnapshotsToKeep
}

func (*MinSnapshotsToKeepContext) IsMinSnapshotsToKeepContext() {}

func NewMinSnapshotsToKeepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MinSnapshotsToKeepContext {
	var p = new(MinSnapshotsToKeepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_minSnapshotsToKeep

	return p
}

func (s *MinSnapshotsToKeepContext) GetParser() antlr.Parser { return s.parser }

func (s *MinSnapshotsToKeepContext) GetValue() antlr.Token { return s.value }

func (s *MinSnapshotsToKeepContext) SetValue(v antlr.Token) { s.value = v }

func (s *MinSnapshotsToKeepContext) SNAPSHOTS() antlr.TerminalNode {
	return s.GetToken(DorisParserSNAPSHOTS, 0)
}

func (s *MinSnapshotsToKeepContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *MinSnapshotsToKeepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MinSnapshotsToKeepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MinSnapshotsToKeepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMinSnapshotsToKeep(s)
	}
}

func (s *MinSnapshotsToKeepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMinSnapshotsToKeep(s)
	}
}

func (p *DorisParser) MinSnapshotsToKeep() (localctx IMinSnapshotsToKeepContext) {
	localctx = NewMinSnapshotsToKeepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, DorisParserRULE_minSnapshotsToKeep)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3866)

		var _m = p.Match(DorisParserINTEGER_VALUE)

		localctx.(*MinSnapshotsToKeepContext).value = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3867)
		p.Match(DorisParserSNAPSHOTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimeValueWithUnitContext is an interface to support dynamic dispatch.
type ITimeValueWithUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTimeValue returns the timeValue token.
	GetTimeValue() antlr.Token

	// GetTimeUnit returns the timeUnit token.
	GetTimeUnit() antlr.Token

	// SetTimeValue sets the timeValue token.
	SetTimeValue(antlr.Token)

	// SetTimeUnit sets the timeUnit token.
	SetTimeUnit(antlr.Token)

	// Getter signatures
	INTEGER_VALUE() antlr.TerminalNode
	DAYS() antlr.TerminalNode
	HOURS() antlr.TerminalNode
	MINUTES() antlr.TerminalNode

	// IsTimeValueWithUnitContext differentiates from other interfaces.
	IsTimeValueWithUnitContext()
}

type TimeValueWithUnitContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	timeValue antlr.Token
	timeUnit  antlr.Token
}

func NewEmptyTimeValueWithUnitContext() *TimeValueWithUnitContext {
	var p = new(TimeValueWithUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_timeValueWithUnit
	return p
}

func InitEmptyTimeValueWithUnitContext(p *TimeValueWithUnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_timeValueWithUnit
}

func (*TimeValueWithUnitContext) IsTimeValueWithUnitContext() {}

func NewTimeValueWithUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeValueWithUnitContext {
	var p = new(TimeValueWithUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_timeValueWithUnit

	return p
}

func (s *TimeValueWithUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeValueWithUnitContext) GetTimeValue() antlr.Token { return s.timeValue }

func (s *TimeValueWithUnitContext) GetTimeUnit() antlr.Token { return s.timeUnit }

func (s *TimeValueWithUnitContext) SetTimeValue(v antlr.Token) { s.timeValue = v }

func (s *TimeValueWithUnitContext) SetTimeUnit(v antlr.Token) { s.timeUnit = v }

func (s *TimeValueWithUnitContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *TimeValueWithUnitContext) DAYS() antlr.TerminalNode {
	return s.GetToken(DorisParserDAYS, 0)
}

func (s *TimeValueWithUnitContext) HOURS() antlr.TerminalNode {
	return s.GetToken(DorisParserHOURS, 0)
}

func (s *TimeValueWithUnitContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(DorisParserMINUTES, 0)
}

func (s *TimeValueWithUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeValueWithUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimeValueWithUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTimeValueWithUnit(s)
	}
}

func (s *TimeValueWithUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTimeValueWithUnit(s)
	}
}

func (p *DorisParser) TimeValueWithUnit() (localctx ITimeValueWithUnitContext) {
	localctx = NewTimeValueWithUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, DorisParserRULE_timeValueWithUnit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3869)

		var _m = p.Match(DorisParserINTEGER_VALUE)

		localctx.(*TimeValueWithUnitContext).timeValue = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3870)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*TimeValueWithUnitContext).timeUnit = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserDAYS || _la == DorisParserHOURS || _la == DorisParserMINUTES) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*TimeValueWithUnitContext).timeUnit = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnPositionContext is an interface to support dynamic dispatch.
type IColumnPositionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPosition returns the position rule contexts.
	GetPosition() IIdentifierContext

	// SetPosition sets the position rule contexts.
	SetPosition(IIdentifierContext)

	// Getter signatures
	FIRST() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsColumnPositionContext differentiates from other interfaces.
	IsColumnPositionContext()
}

type ColumnPositionContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	position IIdentifierContext
}

func NewEmptyColumnPositionContext() *ColumnPositionContext {
	var p = new(ColumnPositionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_columnPosition
	return p
}

func InitEmptyColumnPositionContext(p *ColumnPositionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_columnPosition
}

func (*ColumnPositionContext) IsColumnPositionContext() {}

func NewColumnPositionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnPositionContext {
	var p = new(ColumnPositionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_columnPosition

	return p
}

func (s *ColumnPositionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnPositionContext) GetPosition() IIdentifierContext { return s.position }

func (s *ColumnPositionContext) SetPosition(v IIdentifierContext) { s.position = v }

func (s *ColumnPositionContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DorisParserFIRST, 0)
}

func (s *ColumnPositionContext) AFTER() antlr.TerminalNode {
	return s.GetToken(DorisParserAFTER, 0)
}

func (s *ColumnPositionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnPositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnPositionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnPositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterColumnPosition(s)
	}
}

func (s *ColumnPositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitColumnPosition(s)
	}
}

func (p *DorisParser) ColumnPosition() (localctx IColumnPositionContext) {
	localctx = NewColumnPositionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, DorisParserRULE_columnPosition)
	p.SetState(3875)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserFIRST:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3872)
			p.Match(DorisParserFIRST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserAFTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3873)
			p.Match(DorisParserAFTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3874)

			var _x = p.Identifier()

			localctx.(*ColumnPositionContext).position = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IToRollupContext is an interface to support dynamic dispatch.
type IToRollupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollup returns the rollup rule contexts.
	GetRollup() IIdentifierContext

	// SetRollup sets the rollup rule contexts.
	SetRollup(IIdentifierContext)

	// Getter signatures
	TO() antlr.TerminalNode
	IN() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsToRollupContext differentiates from other interfaces.
	IsToRollupContext()
}

type ToRollupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	rollup IIdentifierContext
}

func NewEmptyToRollupContext() *ToRollupContext {
	var p = new(ToRollupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_toRollup
	return p
}

func InitEmptyToRollupContext(p *ToRollupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_toRollup
}

func (*ToRollupContext) IsToRollupContext() {}

func NewToRollupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ToRollupContext {
	var p = new(ToRollupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_toRollup

	return p
}

func (s *ToRollupContext) GetParser() antlr.Parser { return s.parser }

func (s *ToRollupContext) GetRollup() IIdentifierContext { return s.rollup }

func (s *ToRollupContext) SetRollup(v IIdentifierContext) { s.rollup = v }

func (s *ToRollupContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *ToRollupContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *ToRollupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ToRollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ToRollupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ToRollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterToRollup(s)
	}
}

func (s *ToRollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitToRollup(s)
	}
}

func (p *DorisParser) ToRollup() (localctx IToRollupContext) {
	localctx = NewToRollupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, DorisParserRULE_toRollup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3877)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserIN || _la == DorisParserTO) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3878)

		var _x = p.Identifier()

		localctx.(*ToRollupContext).rollup = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromRollupContext is an interface to support dynamic dispatch.
type IFromRollupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollup returns the rollup rule contexts.
	GetRollup() IIdentifierContext

	// SetRollup sets the rollup rule contexts.
	SetRollup(IIdentifierContext)

	// Getter signatures
	FROM() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsFromRollupContext differentiates from other interfaces.
	IsFromRollupContext()
}

type FromRollupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	rollup IIdentifierContext
}

func NewEmptyFromRollupContext() *FromRollupContext {
	var p = new(FromRollupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_fromRollup
	return p
}

func InitEmptyFromRollupContext(p *FromRollupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_fromRollup
}

func (*FromRollupContext) IsFromRollupContext() {}

func NewFromRollupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromRollupContext {
	var p = new(FromRollupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_fromRollup

	return p
}

func (s *FromRollupContext) GetParser() antlr.Parser { return s.parser }

func (s *FromRollupContext) GetRollup() IIdentifierContext { return s.rollup }

func (s *FromRollupContext) SetRollup(v IIdentifierContext) { s.rollup = v }

func (s *FromRollupContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *FromRollupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FromRollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromRollupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromRollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFromRollup(s)
	}
}

func (s *FromRollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFromRollup(s)
	}
}

func (p *DorisParser) FromRollup() (localctx IFromRollupContext) {
	localctx = NewFromRollupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, DorisParserRULE_fromRollup)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3880)
		p.Match(DorisParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3881)

		var _x = p.Identifier()

		localctx.(*FromRollupContext).rollup = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedStatsStatementContext is an interface to support dynamic dispatch.
type ISupportedStatsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedStatsStatementContext differentiates from other interfaces.
	IsSupportedStatsStatementContext()
}

type SupportedStatsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedStatsStatementContext() *SupportedStatsStatementContext {
	var p = new(SupportedStatsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedStatsStatement
	return p
}

func InitEmptySupportedStatsStatementContext(p *SupportedStatsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedStatsStatement
}

func (*SupportedStatsStatementContext) IsSupportedStatsStatementContext() {}

func NewSupportedStatsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedStatsStatementContext {
	var p = new(SupportedStatsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedStatsStatement

	return p
}

func (s *SupportedStatsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedStatsStatementContext) CopyAll(ctx *SupportedStatsStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedStatsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedStatsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowTableStatsContext struct {
	SupportedStatsStatementContext
	tableName  IMultipartIdentifierContext
	columnList IIdentifierListContext
	tableId    antlr.Token
}

func NewShowTableStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTableStatsContext {
	var p = new(ShowTableStatsContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *ShowTableStatsContext) GetTableId() antlr.Token { return s.tableId }

func (s *ShowTableStatsContext) SetTableId(v antlr.Token) { s.tableId = v }

func (s *ShowTableStatsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowTableStatsContext) GetColumnList() IIdentifierListContext { return s.columnList }

func (s *ShowTableStatsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowTableStatsContext) SetColumnList(v IIdentifierListContext) { s.columnList = v }

func (s *ShowTableStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTableStatsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowTableStatsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *ShowTableStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *ShowTableStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowTableStatsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *ShowTableStatsContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ShowTableStatsContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ShowTableStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowTableStats(s)
	}
}

func (s *ShowTableStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowTableStats(s)
	}
}

type AnalyzeDatabaseContext struct {
	SupportedStatsStatementContext
	name IMultipartIdentifierContext
}

func NewAnalyzeDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AnalyzeDatabaseContext {
	var p = new(AnalyzeDatabaseContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *AnalyzeDatabaseContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AnalyzeDatabaseContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AnalyzeDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeDatabaseContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisParserANALYZE, 0)
}

func (s *AnalyzeDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *AnalyzeDatabaseContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AnalyzeDatabaseContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(DorisParserWITH)
}

func (s *AnalyzeDatabaseContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, i)
}

func (s *AnalyzeDatabaseContext) AllAnalyzeProperties() []IAnalyzePropertiesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnalyzePropertiesContext); ok {
			len++
		}
	}

	tst := make([]IAnalyzePropertiesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnalyzePropertiesContext); ok {
			tst[i] = t.(IAnalyzePropertiesContext)
			i++
		}
	}

	return tst
}

func (s *AnalyzeDatabaseContext) AnalyzeProperties(i int) IAnalyzePropertiesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzePropertiesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzePropertiesContext)
}

func (s *AnalyzeDatabaseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AnalyzeDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAnalyzeDatabase(s)
	}
}

func (s *AnalyzeDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAnalyzeDatabase(s)
	}
}

type ShowQueuedAnalyzeJobsContext struct {
	SupportedStatsStatementContext
	tableName  IMultipartIdentifierContext
	stateKey   IIdentifierContext
	stateValue antlr.Token
}

func NewShowQueuedAnalyzeJobsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowQueuedAnalyzeJobsContext {
	var p = new(ShowQueuedAnalyzeJobsContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *ShowQueuedAnalyzeJobsContext) GetStateValue() antlr.Token { return s.stateValue }

func (s *ShowQueuedAnalyzeJobsContext) SetStateValue(v antlr.Token) { s.stateValue = v }

func (s *ShowQueuedAnalyzeJobsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowQueuedAnalyzeJobsContext) GetStateKey() IIdentifierContext { return s.stateKey }

func (s *ShowQueuedAnalyzeJobsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowQueuedAnalyzeJobsContext) SetStateKey(v IIdentifierContext) { s.stateKey = v }

func (s *ShowQueuedAnalyzeJobsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowQueuedAnalyzeJobsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowQueuedAnalyzeJobsContext) QUEUED() antlr.TerminalNode {
	return s.GetToken(DorisParserQUEUED, 0)
}

func (s *ShowQueuedAnalyzeJobsContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisParserANALYZE, 0)
}

func (s *ShowQueuedAnalyzeJobsContext) JOBS() antlr.TerminalNode {
	return s.GetToken(DorisParserJOBS, 0)
}

func (s *ShowQueuedAnalyzeJobsContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserWHERE, 0)
}

func (s *ShowQueuedAnalyzeJobsContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *ShowQueuedAnalyzeJobsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowQueuedAnalyzeJobsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowQueuedAnalyzeJobsContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowQueuedAnalyzeJobsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowQueuedAnalyzeJobs(s)
	}
}

func (s *ShowQueuedAnalyzeJobsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowQueuedAnalyzeJobs(s)
	}
}

type ShowIndexStatsContext struct {
	SupportedStatsStatementContext
	tableName IMultipartIdentifierContext
	indexId   IIdentifierContext
}

func NewShowIndexStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowIndexStatsContext {
	var p = new(ShowIndexStatsContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *ShowIndexStatsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowIndexStatsContext) GetIndexId() IIdentifierContext { return s.indexId }

func (s *ShowIndexStatsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowIndexStatsContext) SetIndexId(v IIdentifierContext) { s.indexId = v }

func (s *ShowIndexStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowIndexStatsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowIndexStatsContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *ShowIndexStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *ShowIndexStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowIndexStatsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowIndexStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowIndexStats(s)
	}
}

func (s *ShowIndexStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowIndexStats(s)
	}
}

type DropStatsContext struct {
	SupportedStatsStatementContext
	tableName IMultipartIdentifierContext
	columns   IIdentifierListContext
}

func NewDropStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropStatsContext {
	var p = new(DropStatsContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *DropStatsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DropStatsContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *DropStatsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DropStatsContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *DropStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStatsContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *DropStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropStatsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *DropStatsContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DropStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropStats(s)
	}
}

func (s *DropStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropStats(s)
	}
}

type DropCachedStatsContext struct {
	SupportedStatsStatementContext
	tableName IMultipartIdentifierContext
}

func NewDropCachedStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropCachedStatsContext {
	var p = new(DropCachedStatsContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *DropCachedStatsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DropCachedStatsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DropCachedStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropCachedStatsContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropCachedStatsContext) CACHED() antlr.TerminalNode {
	return s.GetToken(DorisParserCACHED, 0)
}

func (s *DropCachedStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *DropCachedStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropCachedStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropCachedStats(s)
	}
}

func (s *DropCachedStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropCachedStats(s)
	}
}

type KillAnalyzeJobContext struct {
	SupportedStatsStatementContext
	jobId antlr.Token
}

func NewKillAnalyzeJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KillAnalyzeJobContext {
	var p = new(KillAnalyzeJobContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *KillAnalyzeJobContext) GetJobId() antlr.Token { return s.jobId }

func (s *KillAnalyzeJobContext) SetJobId(v antlr.Token) { s.jobId = v }

func (s *KillAnalyzeJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillAnalyzeJobContext) KILL() antlr.TerminalNode {
	return s.GetToken(DorisParserKILL, 0)
}

func (s *KillAnalyzeJobContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisParserANALYZE, 0)
}

func (s *KillAnalyzeJobContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *KillAnalyzeJobContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterKillAnalyzeJob(s)
	}
}

func (s *KillAnalyzeJobContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitKillAnalyzeJob(s)
	}
}

type ShowAnalyzeContext struct {
	SupportedStatsStatementContext
	jobId      antlr.Token
	tableName  IMultipartIdentifierContext
	stateKey   IIdentifierContext
	stateValue antlr.Token
}

func NewShowAnalyzeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAnalyzeContext {
	var p = new(ShowAnalyzeContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *ShowAnalyzeContext) GetJobId() antlr.Token { return s.jobId }

func (s *ShowAnalyzeContext) GetStateValue() antlr.Token { return s.stateValue }

func (s *ShowAnalyzeContext) SetJobId(v antlr.Token) { s.jobId = v }

func (s *ShowAnalyzeContext) SetStateValue(v antlr.Token) { s.stateValue = v }

func (s *ShowAnalyzeContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowAnalyzeContext) GetStateKey() IIdentifierContext { return s.stateKey }

func (s *ShowAnalyzeContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowAnalyzeContext) SetStateKey(v IIdentifierContext) { s.stateKey = v }

func (s *ShowAnalyzeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAnalyzeContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowAnalyzeContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisParserANALYZE, 0)
}

func (s *ShowAnalyzeContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO, 0)
}

func (s *ShowAnalyzeContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserWHERE, 0)
}

func (s *ShowAnalyzeContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *ShowAnalyzeContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ShowAnalyzeContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowAnalyzeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowAnalyzeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ShowAnalyzeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowAnalyze(s)
	}
}

func (s *ShowAnalyzeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowAnalyze(s)
	}
}

type DropAnalyzeJobContext struct {
	SupportedStatsStatementContext
}

func NewDropAnalyzeJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropAnalyzeJobContext {
	var p = new(DropAnalyzeJobContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *DropAnalyzeJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropAnalyzeJobContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropAnalyzeJobContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisParserANALYZE, 0)
}

func (s *DropAnalyzeJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *DropAnalyzeJobContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *DropAnalyzeJobContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropAnalyzeJob(s)
	}
}

func (s *DropAnalyzeJobContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropAnalyzeJob(s)
	}
}

type AlterColumnStatsContext struct {
	SupportedStatsStatementContext
	name       IMultipartIdentifierContext
	indexName  IIdentifierContext
	columnName IIdentifierContext
}

func NewAlterColumnStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterColumnStatsContext {
	var p = new(AlterColumnStatsContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *AlterColumnStatsContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterColumnStatsContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *AlterColumnStatsContext) GetColumnName() IIdentifierContext { return s.columnName }

func (s *AlterColumnStatsContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterColumnStatsContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *AlterColumnStatsContext) SetColumnName(v IIdentifierContext) { s.columnName = v }

func (s *AlterColumnStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterColumnStatsContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterColumnStatsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AlterColumnStatsContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *AlterColumnStatsContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *AlterColumnStatsContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterColumnStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *AlterColumnStatsContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterColumnStatsContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterColumnStatsContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterColumnStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterColumnStatsContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterColumnStatsContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterColumnStatsContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *AlterColumnStatsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *AlterColumnStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterColumnStats(s)
	}
}

func (s *AlterColumnStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterColumnStats(s)
	}
}

type DropExpiredStatsContext struct {
	SupportedStatsStatementContext
}

func NewDropExpiredStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropExpiredStatsContext {
	var p = new(DropExpiredStatsContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *DropExpiredStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropExpiredStatsContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserDROP, 0)
}

func (s *DropExpiredStatsContext) EXPIRED() antlr.TerminalNode {
	return s.GetToken(DorisParserEXPIRED, 0)
}

func (s *DropExpiredStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *DropExpiredStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDropExpiredStats(s)
	}
}

func (s *DropExpiredStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDropExpiredStats(s)
	}
}

type AnalyzeTableContext struct {
	SupportedStatsStatementContext
	name    IMultipartIdentifierContext
	columns IIdentifierListContext
}

func NewAnalyzeTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AnalyzeTableContext {
	var p = new(AnalyzeTableContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *AnalyzeTableContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AnalyzeTableContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *AnalyzeTableContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AnalyzeTableContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *AnalyzeTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeTableContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisParserANALYZE, 0)
}

func (s *AnalyzeTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AnalyzeTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AnalyzeTableContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *AnalyzeTableContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(DorisParserWITH)
}

func (s *AnalyzeTableContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, i)
}

func (s *AnalyzeTableContext) AllAnalyzeProperties() []IAnalyzePropertiesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnalyzePropertiesContext); ok {
			len++
		}
	}

	tst := make([]IAnalyzePropertiesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnalyzePropertiesContext); ok {
			tst[i] = t.(IAnalyzePropertiesContext)
			i++
		}
	}

	return tst
}

func (s *AnalyzeTableContext) AnalyzeProperties(i int) IAnalyzePropertiesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzePropertiesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzePropertiesContext)
}

func (s *AnalyzeTableContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AnalyzeTableContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *AnalyzeTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAnalyzeTable(s)
	}
}

func (s *AnalyzeTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAnalyzeTable(s)
	}
}

type AlterTableStatsContext struct {
	SupportedStatsStatementContext
	name IMultipartIdentifierContext
}

func NewAlterTableStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableStatsContext {
	var p = new(AlterTableStatsContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *AlterTableStatsContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterTableStatsContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterTableStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableStatsContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserALTER, 0)
}

func (s *AlterTableStatsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *AlterTableStatsContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *AlterTableStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *AlterTableStatsContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AlterTableStatsContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterTableStatsContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AlterTableStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterTableStatsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *AlterTableStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAlterTableStats(s)
	}
}

func (s *AlterTableStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAlterTableStats(s)
	}
}

type ShowColumnHistogramStatsContext struct {
	SupportedStatsStatementContext
	tableName  IMultipartIdentifierContext
	columnList IIdentifierListContext
}

func NewShowColumnHistogramStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnHistogramStatsContext {
	var p = new(ShowColumnHistogramStatsContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *ShowColumnHistogramStatsContext) GetTableName() IMultipartIdentifierContext {
	return s.tableName
}

func (s *ShowColumnHistogramStatsContext) GetColumnList() IIdentifierListContext { return s.columnList }

func (s *ShowColumnHistogramStatsContext) SetTableName(v IMultipartIdentifierContext) {
	s.tableName = v
}

func (s *ShowColumnHistogramStatsContext) SetColumnList(v IIdentifierListContext) { s.columnList = v }

func (s *ShowColumnHistogramStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnHistogramStatsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowColumnHistogramStatsContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *ShowColumnHistogramStatsContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(DorisParserHISTOGRAM, 0)
}

func (s *ShowColumnHistogramStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowColumnHistogramStatsContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ShowColumnHistogramStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowColumnHistogramStats(s)
	}
}

func (s *ShowColumnHistogramStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowColumnHistogramStats(s)
	}
}

func (p *DorisParser) SupportedStatsStatement() (localctx ISupportedStatsStatementContext) {
	localctx = NewSupportedStatsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, DorisParserRULE_supportedStatsStatement)
	var _la int

	p.SetState(4023)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 553, p.GetParserRuleContext()) {
	case 1:
		localctx = NewShowAnalyzeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3883)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3885)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAUTO {
			{
				p.SetState(3884)
				p.Match(DorisParserAUTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3887)
			p.Match(DorisParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3890)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case DorisParserINTEGER_VALUE:
			{
				p.SetState(3888)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*ShowAnalyzeContext).jobId = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(3889)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowAnalyzeContext).tableName = _x
			}

		case DorisParserEOF, DorisParserSEMICOLON, DorisParserWHERE:

		default:
		}
		p.SetState(3897)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWHERE {
			{
				p.SetState(3892)
				p.Match(DorisParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			{
				p.SetState(3893)

				var _x = p.Identifier()

				localctx.(*ShowAnalyzeContext).stateKey = _x
			}

			{
				p.SetState(3894)
				p.Match(DorisParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			{
				p.SetState(3895)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*ShowAnalyzeContext).stateValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		localctx = NewShowQueuedAnalyzeJobsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3899)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3900)
			p.Match(DorisParserQUEUED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3901)
			p.Match(DorisParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3902)
			p.Match(DorisParserJOBS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3904)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305902462020672000) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4609989332399152113) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4540397275156637211) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&2557745532860070517) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&8545544968972265069) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-305714810442809349) != 0) || ((int64((_la-391)) & ^0x3f) == 0 && ((int64(1)<<(_la-391))&1188948054525294943) != 0) || ((int64((_la-455)) & ^0x3f) == 0 && ((int64(1)<<(_la-455))&2458964612221191023) != 0) || ((int64((_la-538)) & ^0x3f) == 0 && ((int64(1)<<(_la-538))&49159) != 0) {
			{
				p.SetState(3903)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowQueuedAnalyzeJobsContext).tableName = _x
			}

		}
		p.SetState(3911)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWHERE {
			{
				p.SetState(3906)
				p.Match(DorisParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			{
				p.SetState(3907)

				var _x = p.Identifier()

				localctx.(*ShowQueuedAnalyzeJobsContext).stateKey = _x
			}

			{
				p.SetState(3908)
				p.Match(DorisParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			{
				p.SetState(3909)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*ShowQueuedAnalyzeJobsContext).stateValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		localctx = NewShowColumnHistogramStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3913)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3914)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3915)
			p.Match(DorisParserHISTOGRAM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3916)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowColumnHistogramStatsContext).tableName = _x
		}
		{
			p.SetState(3917)

			var _x = p.IdentifierList()

			localctx.(*ShowColumnHistogramStatsContext).columnList = _x
		}

	case 4:
		localctx = NewAnalyzeDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3919)
			p.Match(DorisParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3920)
			p.Match(DorisParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3921)

			var _x = p.MultipartIdentifier()

			localctx.(*AnalyzeDatabaseContext).name = _x
		}
		p.SetState(3926)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserWITH {
			{
				p.SetState(3922)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3923)
				p.AnalyzeProperties()
			}

			p.SetState(3928)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(3930)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3929)
				p.PropertyClause()
			}

		}

	case 5:
		localctx = NewAnalyzeTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3932)
			p.Match(DorisParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3933)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3934)

			var _x = p.MultipartIdentifier()

			localctx.(*AnalyzeTableContext).name = _x
		}
		p.SetState(3936)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(3935)
				p.PartitionSpec()
			}

		}
		p.SetState(3939)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(3938)

				var _x = p.IdentifierList()

				localctx.(*AnalyzeTableContext).columns = _x
			}

		}
		p.SetState(3945)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserWITH {
			{
				p.SetState(3941)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3942)
				p.AnalyzeProperties()
			}

			p.SetState(3947)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(3949)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(3948)
				p.PropertyClause()
			}

		}

	case 6:
		localctx = NewAlterTableStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3951)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3952)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3953)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterTableStatsContext).name = _x
		}
		{
			p.SetState(3954)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3955)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3956)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3957)
			p.PropertyItemList()
		}
		{
			p.SetState(3958)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3960)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(3959)
				p.PartitionSpec()
			}

		}

	case 7:
		localctx = NewAlterColumnStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3962)
			p.Match(DorisParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3963)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3964)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterColumnStatsContext).name = _x
		}
		p.SetState(3967)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserINDEX {
			{
				p.SetState(3965)
				p.Match(DorisParserINDEX)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3966)

				var _x = p.Identifier()

				localctx.(*AlterColumnStatsContext).indexName = _x
			}

		}
		{
			p.SetState(3969)
			p.Match(DorisParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3970)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3971)

			var _x = p.Identifier()

			localctx.(*AlterColumnStatsContext).columnName = _x
		}
		{
			p.SetState(3972)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3973)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3974)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3975)
			p.PropertyItemList()
		}
		{
			p.SetState(3976)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3978)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(3977)
				p.PartitionSpec()
			}

		}

	case 8:
		localctx = NewShowIndexStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3980)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3981)
			p.Match(DorisParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3982)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3983)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowIndexStatsContext).tableName = _x
		}
		{
			p.SetState(3984)

			var _x = p.Identifier()

			localctx.(*ShowIndexStatsContext).indexId = _x
		}

	case 9:
		localctx = NewDropStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3986)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3987)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3988)

			var _x = p.MultipartIdentifier()

			localctx.(*DropStatsContext).tableName = _x
		}
		p.SetState(3990)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(3989)

				var _x = p.IdentifierList()

				localctx.(*DropStatsContext).columns = _x
			}

		}
		p.SetState(3993)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(3992)
				p.PartitionSpec()
			}

		}

	case 10:
		localctx = NewDropCachedStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3995)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3996)
			p.Match(DorisParserCACHED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3997)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3998)

			var _x = p.MultipartIdentifier()

			localctx.(*DropCachedStatsContext).tableName = _x
		}

	case 11:
		localctx = NewDropExpiredStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3999)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4000)
			p.Match(DorisParserEXPIRED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4001)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewKillAnalyzeJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(4002)
			p.Match(DorisParserKILL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4003)
			p.Match(DorisParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4004)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*KillAnalyzeJobContext).jobId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		localctx = NewDropAnalyzeJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(4005)
			p.Match(DorisParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4006)
			p.Match(DorisParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4007)
			p.Match(DorisParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4008)
			p.Match(DorisParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		localctx = NewShowTableStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(4009)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4010)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4011)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4012)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowTableStatsContext).tableName = _x
		}
		p.SetState(4014)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(4013)
				p.PartitionSpec()
			}

		}
		p.SetState(4017)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(4016)

				var _x = p.IdentifierList()

				localctx.(*ShowTableStatsContext).columnList = _x
			}

		}

	case 15:
		localctx = NewShowTableStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(4019)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4020)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4021)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4022)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*ShowTableStatsContext).tableId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedStatsStatementContext is an interface to support dynamic dispatch.
type IUnsupportedStatsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedStatsStatementContext differentiates from other interfaces.
	IsUnsupportedStatsStatementContext()
}

type UnsupportedStatsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedStatsStatementContext() *UnsupportedStatsStatementContext {
	var p = new(UnsupportedStatsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedStatsStatement
	return p
}

func InitEmptyUnsupportedStatsStatementContext(p *UnsupportedStatsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unsupportedStatsStatement
}

func (*UnsupportedStatsStatementContext) IsUnsupportedStatsStatementContext() {}

func NewUnsupportedStatsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedStatsStatementContext {
	var p = new(UnsupportedStatsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unsupportedStatsStatement

	return p
}

func (s *UnsupportedStatsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedStatsStatementContext) CopyAll(ctx *UnsupportedStatsStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedStatsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedStatsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowColumnStatsContext struct {
	UnsupportedStatsStatementContext
	tableName  IMultipartIdentifierContext
	columnList IIdentifierListContext
}

func NewShowColumnStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnStatsContext {
	var p = new(ShowColumnStatsContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *ShowColumnStatsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowColumnStatsContext) GetColumnList() IIdentifierListContext { return s.columnList }

func (s *ShowColumnStatsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowColumnStatsContext) SetColumnList(v IIdentifierListContext) { s.columnList = v }

func (s *ShowColumnStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnStatsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowColumnStatsContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMN, 0)
}

func (s *ShowColumnStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *ShowColumnStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowColumnStatsContext) CACHED() antlr.TerminalNode {
	return s.GetToken(DorisParserCACHED, 0)
}

func (s *ShowColumnStatsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *ShowColumnStatsContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ShowColumnStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowColumnStats(s)
	}
}

func (s *ShowColumnStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowColumnStats(s)
	}
}

type ShowAnalyzeTaskContext struct {
	UnsupportedStatsStatementContext
	jobId antlr.Token
}

func NewShowAnalyzeTaskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAnalyzeTaskContext {
	var p = new(ShowAnalyzeTaskContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *ShowAnalyzeTaskContext) GetJobId() antlr.Token { return s.jobId }

func (s *ShowAnalyzeTaskContext) SetJobId(v antlr.Token) { s.jobId = v }

func (s *ShowAnalyzeTaskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAnalyzeTaskContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserSHOW, 0)
}

func (s *ShowAnalyzeTaskContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisParserANALYZE, 0)
}

func (s *ShowAnalyzeTaskContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisParserTASK, 0)
}

func (s *ShowAnalyzeTaskContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATUS, 0)
}

func (s *ShowAnalyzeTaskContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ShowAnalyzeTaskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterShowAnalyzeTask(s)
	}
}

func (s *ShowAnalyzeTaskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitShowAnalyzeTask(s)
	}
}

func (p *DorisParser) UnsupportedStatsStatement() (localctx IUnsupportedStatsStatementContext) {
	localctx = NewUnsupportedStatsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, DorisParserRULE_unsupportedStatsStatement)
	var _la int

	p.SetState(4043)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 557, p.GetParserRuleContext()) {
	case 1:
		localctx = NewShowColumnStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4025)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4026)
			p.Match(DorisParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4028)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCACHED {
			{
				p.SetState(4027)
				p.Match(DorisParserCACHED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4030)
			p.Match(DorisParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4031)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowColumnStatsContext).tableName = _x
		}
		p.SetState(4033)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(4032)

				var _x = p.IdentifierList()

				localctx.(*ShowColumnStatsContext).columnList = _x
			}

		}
		p.SetState(4036)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(4035)
				p.PartitionSpec()
			}

		}

	case 2:
		localctx = NewShowAnalyzeTaskContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4038)
			p.Match(DorisParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4039)
			p.Match(DorisParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4040)
			p.Match(DorisParserTASK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4041)
			p.Match(DorisParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4042)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*ShowAnalyzeTaskContext).jobId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyzePropertiesContext is an interface to support dynamic dispatch.
type IAnalyzePropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRows returns the rows token.
	GetRows() antlr.Token

	// GetPercent returns the percent token.
	GetPercent() antlr.Token

	// GetBucket returns the bucket token.
	GetBucket() antlr.Token

	// GetPeriodInSecond returns the periodInSecond token.
	GetPeriodInSecond() antlr.Token

	// GetCrontabExpr returns the crontabExpr token.
	GetCrontabExpr() antlr.Token

	// SetRows sets the rows token.
	SetRows(antlr.Token)

	// SetPercent sets the percent token.
	SetPercent(antlr.Token)

	// SetBucket sets the bucket token.
	SetBucket(antlr.Token)

	// SetPeriodInSecond sets the periodInSecond token.
	SetPeriodInSecond(antlr.Token)

	// SetCrontabExpr sets the crontabExpr token.
	SetCrontabExpr(antlr.Token)

	// Getter signatures
	SYNC() antlr.TerminalNode
	INCREMENTAL() antlr.TerminalNode
	FULL() antlr.TerminalNode
	SQL() antlr.TerminalNode
	HISTOGRAM() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	PERCENT() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	PERIOD() antlr.TerminalNode
	CRON() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsAnalyzePropertiesContext differentiates from other interfaces.
	IsAnalyzePropertiesContext()
}

type AnalyzePropertiesContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	rows           antlr.Token
	percent        antlr.Token
	bucket         antlr.Token
	periodInSecond antlr.Token
	crontabExpr    antlr.Token
}

func NewEmptyAnalyzePropertiesContext() *AnalyzePropertiesContext {
	var p = new(AnalyzePropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_analyzeProperties
	return p
}

func InitEmptyAnalyzePropertiesContext(p *AnalyzePropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_analyzeProperties
}

func (*AnalyzePropertiesContext) IsAnalyzePropertiesContext() {}

func NewAnalyzePropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzePropertiesContext {
	var p = new(AnalyzePropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_analyzeProperties

	return p
}

func (s *AnalyzePropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzePropertiesContext) GetRows() antlr.Token { return s.rows }

func (s *AnalyzePropertiesContext) GetPercent() antlr.Token { return s.percent }

func (s *AnalyzePropertiesContext) GetBucket() antlr.Token { return s.bucket }

func (s *AnalyzePropertiesContext) GetPeriodInSecond() antlr.Token { return s.periodInSecond }

func (s *AnalyzePropertiesContext) GetCrontabExpr() antlr.Token { return s.crontabExpr }

func (s *AnalyzePropertiesContext) SetRows(v antlr.Token) { s.rows = v }

func (s *AnalyzePropertiesContext) SetPercent(v antlr.Token) { s.percent = v }

func (s *AnalyzePropertiesContext) SetBucket(v antlr.Token) { s.bucket = v }

func (s *AnalyzePropertiesContext) SetPeriodInSecond(v antlr.Token) { s.periodInSecond = v }

func (s *AnalyzePropertiesContext) SetCrontabExpr(v antlr.Token) { s.crontabExpr = v }

func (s *AnalyzePropertiesContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DorisParserSYNC, 0)
}

func (s *AnalyzePropertiesContext) INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(DorisParserINCREMENTAL, 0)
}

func (s *AnalyzePropertiesContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserFULL, 0)
}

func (s *AnalyzePropertiesContext) SQL() antlr.TerminalNode {
	return s.GetToken(DorisParserSQL, 0)
}

func (s *AnalyzePropertiesContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(DorisParserHISTOGRAM, 0)
}

func (s *AnalyzePropertiesContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(DorisParserSAMPLE, 0)
}

func (s *AnalyzePropertiesContext) ROWS() antlr.TerminalNode {
	return s.GetToken(DorisParserROWS, 0)
}

func (s *AnalyzePropertiesContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(DorisParserPERCENT, 0)
}

func (s *AnalyzePropertiesContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *AnalyzePropertiesContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisParserBUCKETS, 0)
}

func (s *AnalyzePropertiesContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(DorisParserPERIOD, 0)
}

func (s *AnalyzePropertiesContext) CRON() antlr.TerminalNode {
	return s.GetToken(DorisParserCRON, 0)
}

func (s *AnalyzePropertiesContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *AnalyzePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzePropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnalyzePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAnalyzeProperties(s)
	}
}

func (s *AnalyzePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAnalyzeProperties(s)
	}
}

func (p *DorisParser) AnalyzeProperties() (localctx IAnalyzePropertiesContext) {
	localctx = NewAnalyzePropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, DorisParserRULE_analyzeProperties)
	p.SetState(4063)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserSYNC:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4045)
			p.Match(DorisParserSYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserINCREMENTAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4046)
			p.Match(DorisParserINCREMENTAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserFULL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4047)
			p.Match(DorisParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserSQL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4048)
			p.Match(DorisParserSQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserHISTOGRAM:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4049)
			p.Match(DorisParserHISTOGRAM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserSAMPLE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4050)
			p.Match(DorisParserSAMPLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4055)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserROWS:
			{
				p.SetState(4051)
				p.Match(DorisParserROWS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4052)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*AnalyzePropertiesContext).rows = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserPERCENT:
			{
				p.SetState(4053)
				p.Match(DorisParserPERCENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4054)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*AnalyzePropertiesContext).percent = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case DorisParserBUCKETS:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4057)
			p.Match(DorisParserBUCKETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4058)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*AnalyzePropertiesContext).bucket = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserPERIOD:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4059)
			p.Match(DorisParserPERIOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4060)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*AnalyzePropertiesContext).periodInSecond = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserCRON:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4061)
			p.Match(DorisParserCRON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4062)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*AnalyzePropertiesContext).crontabExpr = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWorkloadPolicyActionsContext is an interface to support dynamic dispatch.
type IWorkloadPolicyActionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWorkloadPolicyAction() []IWorkloadPolicyActionContext
	WorkloadPolicyAction(i int) IWorkloadPolicyActionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWorkloadPolicyActionsContext differentiates from other interfaces.
	IsWorkloadPolicyActionsContext()
}

type WorkloadPolicyActionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWorkloadPolicyActionsContext() *WorkloadPolicyActionsContext {
	var p = new(WorkloadPolicyActionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_workloadPolicyActions
	return p
}

func InitEmptyWorkloadPolicyActionsContext(p *WorkloadPolicyActionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_workloadPolicyActions
}

func (*WorkloadPolicyActionsContext) IsWorkloadPolicyActionsContext() {}

func NewWorkloadPolicyActionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WorkloadPolicyActionsContext {
	var p = new(WorkloadPolicyActionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_workloadPolicyActions

	return p
}

func (s *WorkloadPolicyActionsContext) GetParser() antlr.Parser { return s.parser }

func (s *WorkloadPolicyActionsContext) AllWorkloadPolicyAction() []IWorkloadPolicyActionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWorkloadPolicyActionContext); ok {
			len++
		}
	}

	tst := make([]IWorkloadPolicyActionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWorkloadPolicyActionContext); ok {
			tst[i] = t.(IWorkloadPolicyActionContext)
			i++
		}
	}

	return tst
}

func (s *WorkloadPolicyActionsContext) WorkloadPolicyAction(i int) IWorkloadPolicyActionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWorkloadPolicyActionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWorkloadPolicyActionContext)
}

func (s *WorkloadPolicyActionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *WorkloadPolicyActionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *WorkloadPolicyActionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WorkloadPolicyActionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WorkloadPolicyActionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWorkloadPolicyActions(s)
	}
}

func (s *WorkloadPolicyActionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWorkloadPolicyActions(s)
	}
}

func (p *DorisParser) WorkloadPolicyActions() (localctx IWorkloadPolicyActionsContext) {
	localctx = NewWorkloadPolicyActionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, DorisParserRULE_workloadPolicyActions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4065)
		p.WorkloadPolicyAction()
	}
	p.SetState(4070)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(4066)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4067)
			p.WorkloadPolicyAction()
		}

		p.SetState(4072)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWorkloadPolicyActionContext is an interface to support dynamic dispatch.
type IWorkloadPolicyActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET_SESSION_VARIABLE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsWorkloadPolicyActionContext differentiates from other interfaces.
	IsWorkloadPolicyActionContext()
}

type WorkloadPolicyActionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWorkloadPolicyActionContext() *WorkloadPolicyActionContext {
	var p = new(WorkloadPolicyActionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_workloadPolicyAction
	return p
}

func InitEmptyWorkloadPolicyActionContext(p *WorkloadPolicyActionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_workloadPolicyAction
}

func (*WorkloadPolicyActionContext) IsWorkloadPolicyActionContext() {}

func NewWorkloadPolicyActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WorkloadPolicyActionContext {
	var p = new(WorkloadPolicyActionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_workloadPolicyAction

	return p
}

func (s *WorkloadPolicyActionContext) GetParser() antlr.Parser { return s.parser }

func (s *WorkloadPolicyActionContext) SET_SESSION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserSET_SESSION_VARIABLE, 0)
}

func (s *WorkloadPolicyActionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *WorkloadPolicyActionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WorkloadPolicyActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WorkloadPolicyActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WorkloadPolicyActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWorkloadPolicyAction(s)
	}
}

func (s *WorkloadPolicyActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWorkloadPolicyAction(s)
	}
}

func (p *DorisParser) WorkloadPolicyAction() (localctx IWorkloadPolicyActionContext) {
	localctx = NewWorkloadPolicyActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, DorisParserRULE_workloadPolicyAction)
	var _la int

	p.SetState(4079)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 562, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4073)
			p.Match(DorisParserSET_SESSION_VARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4074)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4075)
			p.Identifier()
		}
		p.SetState(4077)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserSTRING_LITERAL {
			{
				p.SetState(4076)
				p.Match(DorisParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWorkloadPolicyConditionsContext is an interface to support dynamic dispatch.
type IWorkloadPolicyConditionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWorkloadPolicyCondition() []IWorkloadPolicyConditionContext
	WorkloadPolicyCondition(i int) IWorkloadPolicyConditionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWorkloadPolicyConditionsContext differentiates from other interfaces.
	IsWorkloadPolicyConditionsContext()
}

type WorkloadPolicyConditionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWorkloadPolicyConditionsContext() *WorkloadPolicyConditionsContext {
	var p = new(WorkloadPolicyConditionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_workloadPolicyConditions
	return p
}

func InitEmptyWorkloadPolicyConditionsContext(p *WorkloadPolicyConditionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_workloadPolicyConditions
}

func (*WorkloadPolicyConditionsContext) IsWorkloadPolicyConditionsContext() {}

func NewWorkloadPolicyConditionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WorkloadPolicyConditionsContext {
	var p = new(WorkloadPolicyConditionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_workloadPolicyConditions

	return p
}

func (s *WorkloadPolicyConditionsContext) GetParser() antlr.Parser { return s.parser }

func (s *WorkloadPolicyConditionsContext) AllWorkloadPolicyCondition() []IWorkloadPolicyConditionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWorkloadPolicyConditionContext); ok {
			len++
		}
	}

	tst := make([]IWorkloadPolicyConditionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWorkloadPolicyConditionContext); ok {
			tst[i] = t.(IWorkloadPolicyConditionContext)
			i++
		}
	}

	return tst
}

func (s *WorkloadPolicyConditionsContext) WorkloadPolicyCondition(i int) IWorkloadPolicyConditionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWorkloadPolicyConditionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWorkloadPolicyConditionContext)
}

func (s *WorkloadPolicyConditionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *WorkloadPolicyConditionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *WorkloadPolicyConditionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WorkloadPolicyConditionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WorkloadPolicyConditionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWorkloadPolicyConditions(s)
	}
}

func (s *WorkloadPolicyConditionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWorkloadPolicyConditions(s)
	}
}

func (p *DorisParser) WorkloadPolicyConditions() (localctx IWorkloadPolicyConditionsContext) {
	localctx = NewWorkloadPolicyConditionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, DorisParserRULE_workloadPolicyConditions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4081)
		p.WorkloadPolicyCondition()
	}
	p.SetState(4086)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(4082)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4083)
			p.WorkloadPolicyCondition()
		}

		p.SetState(4088)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWorkloadPolicyConditionContext is an interface to support dynamic dispatch.
type IWorkloadPolicyConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMetricName returns the metricName rule contexts.
	GetMetricName() IIdentifierContext

	// SetMetricName sets the metricName rule contexts.
	SetMetricName(IIdentifierContext)

	// Getter signatures
	ComparisonOperator() IComparisonOperatorContext
	Identifier() IIdentifierContext
	Number() INumberContext
	STRING_LITERAL() antlr.TerminalNode

	// IsWorkloadPolicyConditionContext differentiates from other interfaces.
	IsWorkloadPolicyConditionContext()
}

type WorkloadPolicyConditionContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	metricName IIdentifierContext
}

func NewEmptyWorkloadPolicyConditionContext() *WorkloadPolicyConditionContext {
	var p = new(WorkloadPolicyConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_workloadPolicyCondition
	return p
}

func InitEmptyWorkloadPolicyConditionContext(p *WorkloadPolicyConditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_workloadPolicyCondition
}

func (*WorkloadPolicyConditionContext) IsWorkloadPolicyConditionContext() {}

func NewWorkloadPolicyConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WorkloadPolicyConditionContext {
	var p = new(WorkloadPolicyConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_workloadPolicyCondition

	return p
}

func (s *WorkloadPolicyConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *WorkloadPolicyConditionContext) GetMetricName() IIdentifierContext { return s.metricName }

func (s *WorkloadPolicyConditionContext) SetMetricName(v IIdentifierContext) { s.metricName = v }

func (s *WorkloadPolicyConditionContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *WorkloadPolicyConditionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WorkloadPolicyConditionContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *WorkloadPolicyConditionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *WorkloadPolicyConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WorkloadPolicyConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WorkloadPolicyConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWorkloadPolicyCondition(s)
	}
}

func (s *WorkloadPolicyConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWorkloadPolicyCondition(s)
	}
}

func (p *DorisParser) WorkloadPolicyCondition() (localctx IWorkloadPolicyConditionContext) {
	localctx = NewWorkloadPolicyConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, DorisParserRULE_workloadPolicyCondition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4089)

		var _x = p.Identifier()

		localctx.(*WorkloadPolicyConditionContext).metricName = _x
	}
	{
		p.SetState(4090)
		p.ComparisonOperator()
	}
	p.SetState(4093)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserSUBTRACT, DorisParserINTEGER_VALUE, DorisParserEXPONENT_VALUE, DorisParserDECIMAL_VALUE:
		{
			p.SetState(4091)
			p.Number()
		}

	case DorisParserSTRING_LITERAL:
		{
			p.SetState(4092)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStorageBackendContext is an interface to support dynamic dispatch.
type IStorageBackendContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBrokerName returns the brokerName rule contexts.
	GetBrokerName() IIdentifierContext

	// GetProperties returns the properties rule contexts.
	GetProperties() IPropertyClauseContext

	// SetBrokerName sets the brokerName rule contexts.
	SetBrokerName(IIdentifierContext)

	// SetProperties sets the properties rule contexts.
	SetProperties(IPropertyClauseContext)

	// Getter signatures
	ON() antlr.TerminalNode
	LOCATION() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	S3() antlr.TerminalNode
	HDFS() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	Identifier() IIdentifierContext
	PropertyClause() IPropertyClauseContext

	// IsStorageBackendContext differentiates from other interfaces.
	IsStorageBackendContext()
}

type StorageBackendContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	brokerName IIdentifierContext
	properties IPropertyClauseContext
}

func NewEmptyStorageBackendContext() *StorageBackendContext {
	var p = new(StorageBackendContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_storageBackend
	return p
}

func InitEmptyStorageBackendContext(p *StorageBackendContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_storageBackend
}

func (*StorageBackendContext) IsStorageBackendContext() {}

func NewStorageBackendContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StorageBackendContext {
	var p = new(StorageBackendContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_storageBackend

	return p
}

func (s *StorageBackendContext) GetParser() antlr.Parser { return s.parser }

func (s *StorageBackendContext) GetBrokerName() IIdentifierContext { return s.brokerName }

func (s *StorageBackendContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *StorageBackendContext) SetBrokerName(v IIdentifierContext) { s.brokerName = v }

func (s *StorageBackendContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *StorageBackendContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *StorageBackendContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCATION, 0)
}

func (s *StorageBackendContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *StorageBackendContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserBROKER, 0)
}

func (s *StorageBackendContext) S3() antlr.TerminalNode {
	return s.GetToken(DorisParserS3, 0)
}

func (s *StorageBackendContext) HDFS() antlr.TerminalNode {
	return s.GetToken(DorisParserHDFS, 0)
}

func (s *StorageBackendContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *StorageBackendContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StorageBackendContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *StorageBackendContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StorageBackendContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StorageBackendContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStorageBackend(s)
	}
}

func (s *StorageBackendContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStorageBackend(s)
	}
}

func (p *DorisParser) StorageBackend() (localctx IStorageBackendContext) {
	localctx = NewStorageBackendContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, DorisParserRULE_storageBackend)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4095)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserBROKER || _la == DorisParserHDFS || _la == DorisParserLOCAL || _la == DorisParserS3) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(4097)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305902462020672000) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4609989332399152113) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4540397275156637211) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&2557745532860070517) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&8545544968972265069) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-305714810442809349) != 0) || ((int64((_la-391)) & ^0x3f) == 0 && ((int64(1)<<(_la-391))&1188948054525294943) != 0) || ((int64((_la-455)) & ^0x3f) == 0 && ((int64(1)<<(_la-455))&2458964612221191023) != 0) || ((int64((_la-538)) & ^0x3f) == 0 && ((int64(1)<<(_la-538))&49159) != 0) {
		{
			p.SetState(4096)

			var _x = p.Identifier()

			localctx.(*StorageBackendContext).brokerName = _x
		}

	}
	{
		p.SetState(4099)
		p.Match(DorisParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4100)
		p.Match(DorisParserLOCATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4101)
		p.Match(DorisParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4103)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPROPERTIES {
		{
			p.SetState(4102)

			var _x = p.PropertyClause()

			localctx.(*StorageBackendContext).properties = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPasswordOptionContext is an interface to support dynamic dispatch.
type IPasswordOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetHistoryDefault returns the historyDefault token.
	GetHistoryDefault() antlr.Token

	// GetHistoryValue returns the historyValue token.
	GetHistoryValue() antlr.Token

	// GetExpireDefault returns the expireDefault token.
	GetExpireDefault() antlr.Token

	// GetExpireNever returns the expireNever token.
	GetExpireNever() antlr.Token

	// GetExpireValue returns the expireValue token.
	GetExpireValue() antlr.Token

	// GetExpireTimeUnit returns the expireTimeUnit token.
	GetExpireTimeUnit() antlr.Token

	// GetReuseDefault returns the reuseDefault token.
	GetReuseDefault() antlr.Token

	// GetReuseValue returns the reuseValue token.
	GetReuseValue() antlr.Token

	// GetAttemptsValue returns the attemptsValue token.
	GetAttemptsValue() antlr.Token

	// GetLockUnbounded returns the lockUnbounded token.
	GetLockUnbounded() antlr.Token

	// GetLockValue returns the lockValue token.
	GetLockValue() antlr.Token

	// GetLockTimeUint returns the lockTimeUint token.
	GetLockTimeUint() antlr.Token

	// SetHistoryDefault sets the historyDefault token.
	SetHistoryDefault(antlr.Token)

	// SetHistoryValue sets the historyValue token.
	SetHistoryValue(antlr.Token)

	// SetExpireDefault sets the expireDefault token.
	SetExpireDefault(antlr.Token)

	// SetExpireNever sets the expireNever token.
	SetExpireNever(antlr.Token)

	// SetExpireValue sets the expireValue token.
	SetExpireValue(antlr.Token)

	// SetExpireTimeUnit sets the expireTimeUnit token.
	SetExpireTimeUnit(antlr.Token)

	// SetReuseDefault sets the reuseDefault token.
	SetReuseDefault(antlr.Token)

	// SetReuseValue sets the reuseValue token.
	SetReuseValue(antlr.Token)

	// SetAttemptsValue sets the attemptsValue token.
	SetAttemptsValue(antlr.Token)

	// SetLockUnbounded sets the lockUnbounded token.
	SetLockUnbounded(antlr.Token)

	// SetLockValue sets the lockValue token.
	SetLockValue(antlr.Token)

	// SetLockTimeUint sets the lockTimeUint token.
	SetLockTimeUint(antlr.Token)

	// Getter signatures
	PASSWORD_HISTORY() antlr.TerminalNode
	PASSWORD_EXPIRE() antlr.TerminalNode
	PASSWORD_REUSE() antlr.TerminalNode
	AllINTERVAL() []antlr.TerminalNode
	INTERVAL(i int) antlr.TerminalNode
	FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode
	PASSWORD_LOCK_TIME() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	ACCOUNT_LOCK() antlr.TerminalNode
	ACCOUNT_UNLOCK() antlr.TerminalNode
	AllDAY() []antlr.TerminalNode
	DAY(i int) antlr.TerminalNode
	AllDEFAULT() []antlr.TerminalNode
	DEFAULT(i int) antlr.TerminalNode
	NEVER() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	AllHOUR() []antlr.TerminalNode
	HOUR(i int) antlr.TerminalNode
	AllSECOND() []antlr.TerminalNode
	SECOND(i int) antlr.TerminalNode

	// IsPasswordOptionContext differentiates from other interfaces.
	IsPasswordOptionContext()
}

type PasswordOptionContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	historyDefault antlr.Token
	historyValue   antlr.Token
	expireDefault  antlr.Token
	expireNever    antlr.Token
	expireValue    antlr.Token
	expireTimeUnit antlr.Token
	reuseDefault   antlr.Token
	reuseValue     antlr.Token
	attemptsValue  antlr.Token
	lockUnbounded  antlr.Token
	lockValue      antlr.Token
	lockTimeUint   antlr.Token
}

func NewEmptyPasswordOptionContext() *PasswordOptionContext {
	var p = new(PasswordOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_passwordOption
	return p
}

func InitEmptyPasswordOptionContext(p *PasswordOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_passwordOption
}

func (*PasswordOptionContext) IsPasswordOptionContext() {}

func NewPasswordOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PasswordOptionContext {
	var p = new(PasswordOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_passwordOption

	return p
}

func (s *PasswordOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *PasswordOptionContext) GetHistoryDefault() antlr.Token { return s.historyDefault }

func (s *PasswordOptionContext) GetHistoryValue() antlr.Token { return s.historyValue }

func (s *PasswordOptionContext) GetExpireDefault() antlr.Token { return s.expireDefault }

func (s *PasswordOptionContext) GetExpireNever() antlr.Token { return s.expireNever }

func (s *PasswordOptionContext) GetExpireValue() antlr.Token { return s.expireValue }

func (s *PasswordOptionContext) GetExpireTimeUnit() antlr.Token { return s.expireTimeUnit }

func (s *PasswordOptionContext) GetReuseDefault() antlr.Token { return s.reuseDefault }

func (s *PasswordOptionContext) GetReuseValue() antlr.Token { return s.reuseValue }

func (s *PasswordOptionContext) GetAttemptsValue() antlr.Token { return s.attemptsValue }

func (s *PasswordOptionContext) GetLockUnbounded() antlr.Token { return s.lockUnbounded }

func (s *PasswordOptionContext) GetLockValue() antlr.Token { return s.lockValue }

func (s *PasswordOptionContext) GetLockTimeUint() antlr.Token { return s.lockTimeUint }

func (s *PasswordOptionContext) SetHistoryDefault(v antlr.Token) { s.historyDefault = v }

func (s *PasswordOptionContext) SetHistoryValue(v antlr.Token) { s.historyValue = v }

func (s *PasswordOptionContext) SetExpireDefault(v antlr.Token) { s.expireDefault = v }

func (s *PasswordOptionContext) SetExpireNever(v antlr.Token) { s.expireNever = v }

func (s *PasswordOptionContext) SetExpireValue(v antlr.Token) { s.expireValue = v }

func (s *PasswordOptionContext) SetExpireTimeUnit(v antlr.Token) { s.expireTimeUnit = v }

func (s *PasswordOptionContext) SetReuseDefault(v antlr.Token) { s.reuseDefault = v }

func (s *PasswordOptionContext) SetReuseValue(v antlr.Token) { s.reuseValue = v }

func (s *PasswordOptionContext) SetAttemptsValue(v antlr.Token) { s.attemptsValue = v }

func (s *PasswordOptionContext) SetLockUnbounded(v antlr.Token) { s.lockUnbounded = v }

func (s *PasswordOptionContext) SetLockValue(v antlr.Token) { s.lockValue = v }

func (s *PasswordOptionContext) SetLockTimeUint(v antlr.Token) { s.lockTimeUint = v }

func (s *PasswordOptionContext) PASSWORD_HISTORY() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD_HISTORY, 0)
}

func (s *PasswordOptionContext) PASSWORD_EXPIRE() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD_EXPIRE, 0)
}

func (s *PasswordOptionContext) PASSWORD_REUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD_REUSE, 0)
}

func (s *PasswordOptionContext) AllINTERVAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserINTERVAL)
}

func (s *PasswordOptionContext) INTERVAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserINTERVAL, i)
}

func (s *PasswordOptionContext) FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode {
	return s.GetToken(DorisParserFAILED_LOGIN_ATTEMPTS, 0)
}

func (s *PasswordOptionContext) PASSWORD_LOCK_TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD_LOCK_TIME, 0)
}

func (s *PasswordOptionContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserINTEGER_VALUE)
}

func (s *PasswordOptionContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, i)
}

func (s *PasswordOptionContext) ACCOUNT_LOCK() antlr.TerminalNode {
	return s.GetToken(DorisParserACCOUNT_LOCK, 0)
}

func (s *PasswordOptionContext) ACCOUNT_UNLOCK() antlr.TerminalNode {
	return s.GetToken(DorisParserACCOUNT_UNLOCK, 0)
}

func (s *PasswordOptionContext) AllDAY() []antlr.TerminalNode {
	return s.GetTokens(DorisParserDAY)
}

func (s *PasswordOptionContext) DAY(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserDAY, i)
}

func (s *PasswordOptionContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(DorisParserDEFAULT)
}

func (s *PasswordOptionContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, i)
}

func (s *PasswordOptionContext) NEVER() antlr.TerminalNode {
	return s.GetToken(DorisParserNEVER, 0)
}

func (s *PasswordOptionContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(DorisParserUNBOUNDED, 0)
}

func (s *PasswordOptionContext) AllHOUR() []antlr.TerminalNode {
	return s.GetTokens(DorisParserHOUR)
}

func (s *PasswordOptionContext) HOUR(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserHOUR, i)
}

func (s *PasswordOptionContext) AllSECOND() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSECOND)
}

func (s *PasswordOptionContext) SECOND(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSECOND, i)
}

func (s *PasswordOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PasswordOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPasswordOption(s)
	}
}

func (s *PasswordOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPasswordOption(s)
	}
}

func (p *DorisParser) PasswordOption() (localctx IPasswordOptionContext) {
	localctx = NewPasswordOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, DorisParserRULE_passwordOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4110)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPASSWORD_HISTORY {
		{
			p.SetState(4105)
			p.Match(DorisParserPASSWORD_HISTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4108)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserDEFAULT:
			{
				p.SetState(4106)

				var _m = p.Match(DorisParserDEFAULT)

				localctx.(*PasswordOptionContext).historyDefault = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserINTEGER_VALUE:
			{
				p.SetState(4107)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*PasswordOptionContext).historyValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(4120)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPASSWORD_EXPIRE {
		{
			p.SetState(4112)
			p.Match(DorisParserPASSWORD_EXPIRE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4118)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserDEFAULT:
			{
				p.SetState(4113)

				var _m = p.Match(DorisParserDEFAULT)

				localctx.(*PasswordOptionContext).expireDefault = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserNEVER:
			{
				p.SetState(4114)

				var _m = p.Match(DorisParserNEVER)

				localctx.(*PasswordOptionContext).expireNever = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserINTERVAL:
			{
				p.SetState(4115)
				p.Match(DorisParserINTERVAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4116)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*PasswordOptionContext).expireValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4117)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*PasswordOptionContext).expireTimeUnit = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserDAY || _la == DorisParserHOUR || _la == DorisParserSECOND) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*PasswordOptionContext).expireTimeUnit = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(4129)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPASSWORD_REUSE {
		{
			p.SetState(4122)
			p.Match(DorisParserPASSWORD_REUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4123)
			p.Match(DorisParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4127)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserDEFAULT:
			{
				p.SetState(4124)

				var _m = p.Match(DorisParserDEFAULT)

				localctx.(*PasswordOptionContext).reuseDefault = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserINTEGER_VALUE:
			{
				p.SetState(4125)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*PasswordOptionContext).reuseValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4126)
				p.Match(DorisParserDAY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(4133)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserFAILED_LOGIN_ATTEMPTS {
		{
			p.SetState(4131)
			p.Match(DorisParserFAILED_LOGIN_ATTEMPTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4132)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*PasswordOptionContext).attemptsValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4141)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPASSWORD_LOCK_TIME {
		{
			p.SetState(4135)
			p.Match(DorisParserPASSWORD_LOCK_TIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4139)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserUNBOUNDED:
			{
				p.SetState(4136)

				var _m = p.Match(DorisParserUNBOUNDED)

				localctx.(*PasswordOptionContext).lockUnbounded = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserINTEGER_VALUE:
			{
				p.SetState(4137)

				var _m = p.Match(DorisParserINTEGER_VALUE)

				localctx.(*PasswordOptionContext).lockValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4138)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*PasswordOptionContext).lockTimeUint = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserDAY || _la == DorisParserHOUR || _la == DorisParserSECOND) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*PasswordOptionContext).lockTimeUint = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(4144)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserACCOUNT_LOCK || _la == DorisParserACCOUNT_UNLOCK {
		{
			p.SetState(4143)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserACCOUNT_LOCK || _la == DorisParserACCOUNT_UNLOCK) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionArgumentsContext is an interface to support dynamic dispatch.
type IFunctionArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOTDOTDOT() antlr.TerminalNode
	DataTypeList() IDataTypeListContext
	COMMA() antlr.TerminalNode

	// IsFunctionArgumentsContext differentiates from other interfaces.
	IsFunctionArgumentsContext()
}

type FunctionArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionArgumentsContext() *FunctionArgumentsContext {
	var p = new(FunctionArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionArguments
	return p
}

func InitEmptyFunctionArgumentsContext(p *FunctionArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionArguments
}

func (*FunctionArgumentsContext) IsFunctionArgumentsContext() {}

func NewFunctionArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgumentsContext {
	var p = new(FunctionArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_functionArguments

	return p
}

func (s *FunctionArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgumentsContext) DOTDOTDOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOTDOTDOT, 0)
}

func (s *FunctionArgumentsContext) DataTypeList() IDataTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeListContext)
}

func (s *FunctionArgumentsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, 0)
}

func (s *FunctionArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFunctionArguments(s)
	}
}

func (s *FunctionArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFunctionArguments(s)
	}
}

func (p *DorisParser) FunctionArguments() (localctx IFunctionArgumentsContext) {
	localctx = NewFunctionArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, DorisParserRULE_functionArguments)
	p.SetState(4152)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 577, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4146)
			p.Match(DorisParserDOTDOTDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4147)
			p.DataTypeList()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4148)
			p.DataTypeList()
		}
		{
			p.SetState(4149)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4150)
			p.Match(DorisParserDOTDOTDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeListContext is an interface to support dynamic dispatch.
type IDataTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDataType() []IDataTypeContext
	DataType(i int) IDataTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDataTypeListContext differentiates from other interfaces.
	IsDataTypeListContext()
}

type DataTypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeListContext() *DataTypeListContext {
	var p = new(DataTypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dataTypeList
	return p
}

func InitEmptyDataTypeListContext(p *DataTypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dataTypeList
}

func (*DataTypeListContext) IsDataTypeListContext() {}

func NewDataTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeListContext {
	var p = new(DataTypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_dataTypeList

	return p
}

func (s *DataTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeListContext) AllDataType() []IDataTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeContext); ok {
			tst[i] = t.(IDataTypeContext)
			i++
		}
	}

	return tst
}

func (s *DataTypeListContext) DataType(i int) IDataTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *DataTypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *DataTypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *DataTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDataTypeList(s)
	}
}

func (s *DataTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDataTypeList(s)
	}
}

func (p *DorisParser) DataTypeList() (localctx IDataTypeListContext) {
	localctx = NewDataTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, DorisParserRULE_dataTypeList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4154)
		p.DataType()
	}
	p.SetState(4159)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 578, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4155)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4156)
				p.DataType()
			}

		}
		p.SetState(4161)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 578, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedSetStatementContext is an interface to support dynamic dispatch.
type ISupportedSetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedSetStatementContext differentiates from other interfaces.
	IsSupportedSetStatementContext()
}

type SupportedSetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedSetStatementContext() *SupportedSetStatementContext {
	var p = new(SupportedSetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedSetStatement
	return p
}

func InitEmptySupportedSetStatementContext(p *SupportedSetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedSetStatement
}

func (*SupportedSetStatementContext) IsSupportedSetStatementContext() {}

func NewSupportedSetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedSetStatementContext {
	var p = new(SupportedSetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedSetStatement

	return p
}

func (s *SupportedSetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedSetStatementContext) CopyAll(ctx *SupportedSetStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedSetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedSetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SetTransactionContext struct {
	SupportedSetStatementContext
}

func NewSetTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetTransactionContext {
	var p = new(SetTransactionContext)

	InitEmptySupportedSetStatementContext(&p.SupportedSetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedSetStatementContext))

	return p
}

func (s *SetTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTransactionContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *SetTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisParserTRANSACTION, 0)
}

func (s *SetTransactionContext) TransactionAccessMode() ITransactionAccessModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionAccessModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionAccessModeContext)
}

func (s *SetTransactionContext) IsolationLevel() IIsolationLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsolationLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsolationLevelContext)
}

func (s *SetTransactionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, 0)
}

func (s *SetTransactionContext) StatementScope() IStatementScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementScopeContext)
}

func (s *SetTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetTransaction(s)
	}
}

func (s *SetTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetTransaction(s)
	}
}

type SetUserPropertiesContext struct {
	SupportedSetStatementContext
	user IIdentifierOrTextContext
}

func NewSetUserPropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetUserPropertiesContext {
	var p = new(SetUserPropertiesContext)

	InitEmptySupportedSetStatementContext(&p.SupportedSetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedSetStatementContext))

	return p
}

func (s *SetUserPropertiesContext) GetUser() IIdentifierOrTextContext { return s.user }

func (s *SetUserPropertiesContext) SetUser(v IIdentifierOrTextContext) { s.user = v }

func (s *SetUserPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetUserPropertiesContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *SetUserPropertiesContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTY, 0)
}

func (s *SetUserPropertiesContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *SetUserPropertiesContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *SetUserPropertiesContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *SetUserPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetUserProperties(s)
	}
}

func (s *SetUserPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetUserProperties(s)
	}
}

type SetDefaultStorageVaultContext struct {
	SupportedSetStatementContext
}

func NewSetDefaultStorageVaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetDefaultStorageVaultContext {
	var p = new(SetDefaultStorageVaultContext)

	InitEmptySupportedSetStatementContext(&p.SupportedSetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedSetStatementContext))

	return p
}

func (s *SetDefaultStorageVaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetDefaultStorageVaultContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *SetDefaultStorageVaultContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetDefaultStorageVaultContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *SetDefaultStorageVaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *SetDefaultStorageVaultContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *SetDefaultStorageVaultContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULT, 0)
}

func (s *SetDefaultStorageVaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetDefaultStorageVault(s)
	}
}

func (s *SetDefaultStorageVaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetDefaultStorageVault(s)
	}
}

type SetOptionsContext struct {
	SupportedSetStatementContext
}

func NewSetOptionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetOptionsContext {
	var p = new(SetOptionsContext)

	InitEmptySupportedSetStatementContext(&p.SupportedSetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedSetStatementContext))

	return p
}

func (s *SetOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOptionsContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *SetOptionsContext) AllOptionWithType() []IOptionWithTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOptionWithTypeContext); ok {
			len++
		}
	}

	tst := make([]IOptionWithTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOptionWithTypeContext); ok {
			tst[i] = t.(IOptionWithTypeContext)
			i++
		}
	}

	return tst
}

func (s *SetOptionsContext) OptionWithType(i int) IOptionWithTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionWithTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionWithTypeContext)
}

func (s *SetOptionsContext) AllOptionWithoutType() []IOptionWithoutTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOptionWithoutTypeContext); ok {
			len++
		}
	}

	tst := make([]IOptionWithoutTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOptionWithoutTypeContext); ok {
			tst[i] = t.(IOptionWithoutTypeContext)
			i++
		}
	}

	return tst
}

func (s *SetOptionsContext) OptionWithoutType(i int) IOptionWithoutTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionWithoutTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionWithoutTypeContext)
}

func (s *SetOptionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *SetOptionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *SetOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetOptions(s)
	}
}

func (s *SetOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetOptions(s)
	}
}

func (p *DorisParser) SupportedSetStatement() (localctx ISupportedSetStatementContext) {
	localctx = NewSupportedSetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, DorisParserRULE_supportedSetStatement)
	var _la int

	p.SetState(4208)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 585, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSetOptionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4162)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4165)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 579, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4163)
				p.OptionWithType()
			}

		case 2:
			{
				p.SetState(4164)
				p.OptionWithoutType()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(4174)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(4167)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(4170)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 580, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(4168)
					p.OptionWithType()
				}

			case 2:
				{
					p.SetState(4169)
					p.OptionWithoutType()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

			p.SetState(4176)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewSetDefaultStorageVaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4177)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4178)
			p.Identifier()
		}
		{
			p.SetState(4179)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4180)
			p.Match(DorisParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4181)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4182)
			p.Match(DorisParserVAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewSetUserPropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4184)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4185)
			p.Match(DorisParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4188)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFOR {
			{
				p.SetState(4186)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4187)

				var _x = p.IdentifierOrText()

				localctx.(*SetUserPropertiesContext).user = _x
			}

		}
		{
			p.SetState(4190)
			p.PropertyItemList()
		}

	case 4:
		localctx = NewSetTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4191)
			p.Match(DorisParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4193)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION {
			{
				p.SetState(4192)
				p.StatementScope()
			}

		}
		{
			p.SetState(4195)
			p.Match(DorisParserTRANSACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4206)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 584, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4196)
				p.TransactionAccessMode()
			}

		case 2:
			{
				p.SetState(4197)
				p.IsolationLevel()
			}

		case 3:
			{
				p.SetState(4198)
				p.TransactionAccessMode()
			}
			{
				p.SetState(4199)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4200)
				p.IsolationLevel()
			}

		case 4:
			{
				p.SetState(4202)
				p.IsolationLevel()
			}
			{
				p.SetState(4203)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4204)
				p.TransactionAccessMode()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionWithTypeContext is an interface to support dynamic dispatch.
type IOptionWithTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsOptionWithTypeContext differentiates from other interfaces.
	IsOptionWithTypeContext()
}

type OptionWithTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionWithTypeContext() *OptionWithTypeContext {
	var p = new(OptionWithTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_optionWithType
	return p
}

func InitEmptyOptionWithTypeContext(p *OptionWithTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_optionWithType
}

func (*OptionWithTypeContext) IsOptionWithTypeContext() {}

func NewOptionWithTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionWithTypeContext {
	var p = new(OptionWithTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_optionWithType

	return p
}

func (s *OptionWithTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionWithTypeContext) CopyAll(ctx *OptionWithTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *OptionWithTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionWithTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SetVariableWithTypeContext struct {
	OptionWithTypeContext
}

func NewSetVariableWithTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetVariableWithTypeContext {
	var p = new(SetVariableWithTypeContext)

	InitEmptyOptionWithTypeContext(&p.OptionWithTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithTypeContext))

	return p
}

func (s *SetVariableWithTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetVariableWithTypeContext) StatementScope() IStatementScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementScopeContext)
}

func (s *SetVariableWithTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetVariableWithTypeContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *SetVariableWithTypeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetVariableWithTypeContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *SetVariableWithTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetVariableWithType(s)
	}
}

func (s *SetVariableWithTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetVariableWithType(s)
	}
}

func (p *DorisParser) OptionWithType() (localctx IOptionWithTypeContext) {
	localctx = NewOptionWithTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, DorisParserRULE_optionWithType)
	localctx = NewSetVariableWithTypeContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4210)
		p.StatementScope()
	}
	{
		p.SetState(4211)
		p.Identifier()
	}
	{
		p.SetState(4212)
		p.Match(DorisParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4215)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_PAREN, DorisParserLEFT_BRACKET, DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADD, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBINARY, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCASE, DorisParserCAST, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATABASE, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXISTS, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserEXTRACT, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFALSE, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIF, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINTERVAL, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserKEY, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLEFT, DorisParserLESS, DorisParserLEVEL, DorisParserLIKE, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNOT, DorisParserNULL, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLACEHOLDER, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREGEXP, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRIGHT, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRIM, DorisParserTRUE, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserPLUS, DorisParserSUBTRACT, DorisParserASTERISK, DorisParserTILDE, DorisParserLOGICALNOT, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserATSIGN, DorisParserDOUBLEATSIGN, DorisParserSTRING_LITERAL, DorisParserINTEGER_VALUE, DorisParserEXPONENT_VALUE, DorisParserDECIMAL_VALUE, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		{
			p.SetState(4213)
			p.Expression()
		}

	case DorisParserDEFAULT:
		{
			p.SetState(4214)
			p.Match(DorisParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionWithoutTypeContext is an interface to support dynamic dispatch.
type IOptionWithoutTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsOptionWithoutTypeContext differentiates from other interfaces.
	IsOptionWithoutTypeContext()
}

type OptionWithoutTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionWithoutTypeContext() *OptionWithoutTypeContext {
	var p = new(OptionWithoutTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_optionWithoutType
	return p
}

func InitEmptyOptionWithoutTypeContext(p *OptionWithoutTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_optionWithoutType
}

func (*OptionWithoutTypeContext) IsOptionWithoutTypeContext() {}

func NewOptionWithoutTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionWithoutTypeContext {
	var p = new(OptionWithoutTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_optionWithoutType

	return p
}

func (s *OptionWithoutTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionWithoutTypeContext) CopyAll(ctx *OptionWithoutTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *OptionWithoutTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionWithoutTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SetNamesContext struct {
	OptionWithoutTypeContext
}

func NewSetNamesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetNamesContext {
	var p = new(SetNamesContext)

	InitEmptyOptionWithoutTypeContext(&p.OptionWithoutTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithoutTypeContext))

	return p
}

func (s *SetNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetNamesContext) NAMES() antlr.TerminalNode {
	return s.GetToken(DorisParserNAMES, 0)
}

func (s *SetNamesContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *SetNamesContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetNames(s)
	}
}

func (s *SetNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetNames(s)
	}
}

type SetCharsetContext struct {
	OptionWithoutTypeContext
	charsetName IIdentifierOrTextContext
}

func NewSetCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetCharsetContext {
	var p = new(SetCharsetContext)

	InitEmptyOptionWithoutTypeContext(&p.OptionWithoutTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithoutTypeContext))

	return p
}

func (s *SetCharsetContext) GetCharsetName() IIdentifierOrTextContext { return s.charsetName }

func (s *SetCharsetContext) SetCharsetName(v IIdentifierOrTextContext) { s.charsetName = v }

func (s *SetCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetCharsetContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserCHAR, 0)
}

func (s *SetCharsetContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *SetCharsetContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(DorisParserCHARSET, 0)
}

func (s *SetCharsetContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *SetCharsetContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *SetCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetCharset(s)
	}
}

func (s *SetCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetCharset(s)
	}
}

type SetCollateContext struct {
	OptionWithoutTypeContext
	charsetName IIdentifierOrTextContext
	collateName IIdentifierOrTextContext
}

func NewSetCollateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetCollateContext {
	var p = new(SetCollateContext)

	InitEmptyOptionWithoutTypeContext(&p.OptionWithoutTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithoutTypeContext))

	return p
}

func (s *SetCollateContext) GetCharsetName() IIdentifierOrTextContext { return s.charsetName }

func (s *SetCollateContext) GetCollateName() IIdentifierOrTextContext { return s.collateName }

func (s *SetCollateContext) SetCharsetName(v IIdentifierOrTextContext) { s.charsetName = v }

func (s *SetCollateContext) SetCollateName(v IIdentifierOrTextContext) { s.collateName = v }

func (s *SetCollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetCollateContext) NAMES() antlr.TerminalNode {
	return s.GetToken(DorisParserNAMES, 0)
}

func (s *SetCollateContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(DorisParserDEFAULT)
}

func (s *SetCollateContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, i)
}

func (s *SetCollateContext) AllIdentifierOrText() []IIdentifierOrTextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrTextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrTextContext); ok {
			tst[i] = t.(IIdentifierOrTextContext)
			i++
		}
	}

	return tst
}

func (s *SetCollateContext) IdentifierOrText(i int) IIdentifierOrTextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *SetCollateContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLLATE, 0)
}

func (s *SetCollateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetCollate(s)
	}
}

func (s *SetCollateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetCollate(s)
	}
}

type SetPasswordContext struct {
	OptionWithoutTypeContext
	pwd     antlr.Token
	isPlain antlr.Token
}

func NewSetPasswordContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetPasswordContext {
	var p = new(SetPasswordContext)

	InitEmptyOptionWithoutTypeContext(&p.OptionWithoutTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithoutTypeContext))

	return p
}

func (s *SetPasswordContext) GetPwd() antlr.Token { return s.pwd }

func (s *SetPasswordContext) GetIsPlain() antlr.Token { return s.isPlain }

func (s *SetPasswordContext) SetPwd(v antlr.Token) { s.pwd = v }

func (s *SetPasswordContext) SetIsPlain(v antlr.Token) { s.isPlain = v }

func (s *SetPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetPasswordContext) AllPASSWORD() []antlr.TerminalNode {
	return s.GetTokens(DorisParserPASSWORD)
}

func (s *SetPasswordContext) PASSWORD(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD, i)
}

func (s *SetPasswordContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *SetPasswordContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *SetPasswordContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *SetPasswordContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *SetPasswordContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *SetPasswordContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *SetPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetPassword(s)
	}
}

func (s *SetPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetPassword(s)
	}
}

type SetVariableWithoutTypeContext struct {
	OptionWithoutTypeContext
}

func NewSetVariableWithoutTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetVariableWithoutTypeContext {
	var p = new(SetVariableWithoutTypeContext)

	InitEmptyOptionWithoutTypeContext(&p.OptionWithoutTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithoutTypeContext))

	return p
}

func (s *SetVariableWithoutTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetVariableWithoutTypeContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *SetVariableWithoutTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetVariableWithoutType(s)
	}
}

func (s *SetVariableWithoutTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetVariableWithoutType(s)
	}
}

type SetLdapAdminPasswordContext struct {
	OptionWithoutTypeContext
	pwd antlr.Token
}

func NewSetLdapAdminPasswordContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetLdapAdminPasswordContext {
	var p = new(SetLdapAdminPasswordContext)

	InitEmptyOptionWithoutTypeContext(&p.OptionWithoutTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithoutTypeContext))

	return p
}

func (s *SetLdapAdminPasswordContext) GetPwd() antlr.Token { return s.pwd }

func (s *SetLdapAdminPasswordContext) SetPwd(v antlr.Token) { s.pwd = v }

func (s *SetLdapAdminPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetLdapAdminPasswordContext) LDAP_ADMIN_PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisParserLDAP_ADMIN_PASSWORD, 0)
}

func (s *SetLdapAdminPasswordContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *SetLdapAdminPasswordContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *SetLdapAdminPasswordContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD, 0)
}

func (s *SetLdapAdminPasswordContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *SetLdapAdminPasswordContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *SetLdapAdminPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetLdapAdminPassword(s)
	}
}

func (s *SetLdapAdminPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetLdapAdminPassword(s)
	}
}

func (p *DorisParser) OptionWithoutType() (localctx IOptionWithoutTypeContext) {
	localctx = NewOptionWithoutTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, DorisParserRULE_optionWithoutType)
	var _la int

	p.SetState(4262)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 594, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSetNamesContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4217)
			p.Match(DorisParserNAMES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4218)
			p.Match(DorisParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4219)
			p.Expression()
		}

	case 2:
		localctx = NewSetCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4223)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserCHAR:
			{
				p.SetState(4220)
				p.Match(DorisParserCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4221)
				p.Match(DorisParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserCHARSET:
			{
				p.SetState(4222)
				p.Match(DorisParserCHARSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(4227)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(4225)

				var _x = p.IdentifierOrText()

				localctx.(*SetCharsetContext).charsetName = _x
			}

		case DorisParserDEFAULT:
			{
				p.SetState(4226)
				p.Match(DorisParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		localctx = NewSetCollateContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4229)
			p.Match(DorisParserNAMES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4232)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(4230)

				var _x = p.IdentifierOrText()

				localctx.(*SetCollateContext).charsetName = _x
			}

		case DorisParserDEFAULT:
			{
				p.SetState(4231)
				p.Match(DorisParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(4237)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case DorisParserCOLLATE:
			{
				p.SetState(4234)
				p.Match(DorisParserCOLLATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4235)

				var _x = p.IdentifierOrText()

				localctx.(*SetCollateContext).collateName = _x
			}

		case DorisParserDEFAULT:
			{
				p.SetState(4236)
				p.Match(DorisParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserEOF, DorisParserSEMICOLON, DorisParserCOMMA:

		default:
		}

	case 4:
		localctx = NewSetPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4239)
			p.Match(DorisParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4242)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFOR {
			{
				p.SetState(4240)
				p.Match(DorisParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4241)
				p.UserIdentify()
			}

		}
		{
			p.SetState(4244)
			p.Match(DorisParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4250)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserSTRING_LITERAL:
			{
				p.SetState(4245)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*SetPasswordContext).pwd = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserPASSWORD:
			{
				p.SetState(4246)

				var _m = p.Match(DorisParserPASSWORD)

				localctx.(*SetPasswordContext).isPlain = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4247)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4248)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*SetPasswordContext).pwd = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4249)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 5:
		localctx = NewSetLdapAdminPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4252)
			p.Match(DorisParserLDAP_ADMIN_PASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4253)
			p.Match(DorisParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4259)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserSTRING_LITERAL:
			{
				p.SetState(4254)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*SetLdapAdminPasswordContext).pwd = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserPASSWORD:
			{
				p.SetState(4255)
				p.Match(DorisParserPASSWORD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4256)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4257)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*SetLdapAdminPasswordContext).pwd = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4258)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 6:
		localctx = NewSetVariableWithoutTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4261)
			p.Variable()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableContext is an interface to support dynamic dispatch.
type IVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsVariableContext differentiates from other interfaces.
	IsVariableContext()
}

type VariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableContext() *VariableContext {
	var p = new(VariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_variable
	return p
}

func InitEmptyVariableContext(p *VariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_variable
}

func (*VariableContext) IsVariableContext() {}

func NewVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableContext {
	var p = new(VariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_variable

	return p
}

func (s *VariableContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableContext) CopyAll(ctx *VariableContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *VariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SetUserVariableContext struct {
	VariableContext
}

func NewSetUserVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetUserVariableContext {
	var p = new(SetUserVariableContext)

	InitEmptyVariableContext(&p.VariableContext)
	p.parser = parser
	p.CopyAll(ctx.(*VariableContext))

	return p
}

func (s *SetUserVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetUserVariableContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserATSIGN, 0)
}

func (s *SetUserVariableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetUserVariableContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *SetUserVariableContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetUserVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetUserVariable(s)
	}
}

func (s *SetUserVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetUserVariable(s)
	}
}

type SetSystemVariableContext struct {
	VariableContext
}

func NewSetSystemVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetSystemVariableContext {
	var p = new(SetSystemVariableContext)

	InitEmptyVariableContext(&p.VariableContext)
	p.parser = parser
	p.CopyAll(ctx.(*VariableContext))

	return p
}

func (s *SetSystemVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetSystemVariableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetSystemVariableContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *SetSystemVariableContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetSystemVariableContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *SetSystemVariableContext) DOUBLEATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserDOUBLEATSIGN, 0)
}

func (s *SetSystemVariableContext) StatementScope() IStatementScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementScopeContext)
}

func (s *SetSystemVariableContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *SetSystemVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetSystemVariable(s)
	}
}

func (s *SetSystemVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetSystemVariable(s)
	}
}

func (p *DorisParser) Variable() (localctx IVariableContext) {
	localctx = NewVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, DorisParserRULE_variable)
	var _la int

	p.SetState(4283)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserDOUBLEATSIGN, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		localctx = NewSetSystemVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4270)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserDOUBLEATSIGN {
			{
				p.SetState(4264)
				p.Match(DorisParserDOUBLEATSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(4268)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 595, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(4265)
					p.StatementScope()
				}
				{
					p.SetState(4266)
					p.Match(DorisParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}
		{
			p.SetState(4272)
			p.Identifier()
		}
		{
			p.SetState(4273)
			p.Match(DorisParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4276)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_PAREN, DorisParserLEFT_BRACKET, DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADD, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBINARY, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCASE, DorisParserCAST, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATABASE, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXISTS, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserEXTRACT, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFALSE, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIF, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINTERVAL, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserKEY, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLEFT, DorisParserLESS, DorisParserLEVEL, DorisParserLIKE, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNOT, DorisParserNULL, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLACEHOLDER, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREGEXP, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRIGHT, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRIM, DorisParserTRUE, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserPLUS, DorisParserSUBTRACT, DorisParserASTERISK, DorisParserTILDE, DorisParserLOGICALNOT, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserATSIGN, DorisParserDOUBLEATSIGN, DorisParserSTRING_LITERAL, DorisParserINTEGER_VALUE, DorisParserEXPONENT_VALUE, DorisParserDECIMAL_VALUE, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(4274)
				p.Expression()
			}

		case DorisParserDEFAULT:
			{
				p.SetState(4275)
				p.Match(DorisParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case DorisParserATSIGN:
		localctx = NewSetUserVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4278)
			p.Match(DorisParserATSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4279)
			p.Identifier()
		}
		{
			p.SetState(4280)
			p.Match(DorisParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4281)
			p.Expression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionAccessModeContext is an interface to support dynamic dispatch.
type ITransactionAccessModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	WRITE() antlr.TerminalNode

	// IsTransactionAccessModeContext differentiates from other interfaces.
	IsTransactionAccessModeContext()
}

type TransactionAccessModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionAccessModeContext() *TransactionAccessModeContext {
	var p = new(TransactionAccessModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_transactionAccessMode
	return p
}

func InitEmptyTransactionAccessModeContext(p *TransactionAccessModeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_transactionAccessMode
}

func (*TransactionAccessModeContext) IsTransactionAccessModeContext() {}

func NewTransactionAccessModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionAccessModeContext {
	var p = new(TransactionAccessModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_transactionAccessMode

	return p
}

func (s *TransactionAccessModeContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionAccessModeContext) READ() antlr.TerminalNode {
	return s.GetToken(DorisParserREAD, 0)
}

func (s *TransactionAccessModeContext) ONLY() antlr.TerminalNode {
	return s.GetToken(DorisParserONLY, 0)
}

func (s *TransactionAccessModeContext) WRITE() antlr.TerminalNode {
	return s.GetToken(DorisParserWRITE, 0)
}

func (s *TransactionAccessModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionAccessModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionAccessModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTransactionAccessMode(s)
	}
}

func (s *TransactionAccessModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTransactionAccessMode(s)
	}
}

func (p *DorisParser) TransactionAccessMode() (localctx ITransactionAccessModeContext) {
	localctx = NewTransactionAccessModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, DorisParserRULE_transactionAccessMode)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4285)
		p.Match(DorisParserREAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4286)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserONLY || _la == DorisParserWRITE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIsolationLevelContext is an interface to support dynamic dispatch.
type IIsolationLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ISOLATION() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	READ() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	REPEATABLE() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode

	// IsIsolationLevelContext differentiates from other interfaces.
	IsIsolationLevelContext()
}

type IsolationLevelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsolationLevelContext() *IsolationLevelContext {
	var p = new(IsolationLevelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_isolationLevel
	return p
}

func InitEmptyIsolationLevelContext(p *IsolationLevelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_isolationLevel
}

func (*IsolationLevelContext) IsIsolationLevelContext() {}

func NewIsolationLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IsolationLevelContext {
	var p = new(IsolationLevelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_isolationLevel

	return p
}

func (s *IsolationLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *IsolationLevelContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(DorisParserISOLATION, 0)
}

func (s *IsolationLevelContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(DorisParserLEVEL, 0)
}

func (s *IsolationLevelContext) READ() antlr.TerminalNode {
	return s.GetToken(DorisParserREAD, 0)
}

func (s *IsolationLevelContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(DorisParserUNCOMMITTED, 0)
}

func (s *IsolationLevelContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMITTED, 0)
}

func (s *IsolationLevelContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPEATABLE, 0)
}

func (s *IsolationLevelContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserSERIALIZABLE, 0)
}

func (s *IsolationLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsolationLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IsolationLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIsolationLevel(s)
	}
}

func (s *IsolationLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIsolationLevel(s)
	}
}

func (p *DorisParser) IsolationLevel() (localctx IIsolationLevelContext) {
	localctx = NewIsolationLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, DorisParserRULE_isolationLevel)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4288)
		p.Match(DorisParserISOLATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4289)
		p.Match(DorisParserLEVEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4297)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 599, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4290)
			p.Match(DorisParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4291)
			p.Match(DorisParserUNCOMMITTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(4292)
			p.Match(DorisParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4293)
			p.Match(DorisParserCOMMITTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(4294)
			p.Match(DorisParserREPEATABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4295)
			p.Match(DorisParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(4296)
			p.Match(DorisParserSERIALIZABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedUnsetStatementContext is an interface to support dynamic dispatch.
type ISupportedUnsetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNSET() antlr.TerminalNode
	VARIABLE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	Identifier() IIdentifierContext
	StatementScope() IStatementScopeContext
	DEFAULT() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VAULT() antlr.TerminalNode

	// IsSupportedUnsetStatementContext differentiates from other interfaces.
	IsSupportedUnsetStatementContext()
}

type SupportedUnsetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedUnsetStatementContext() *SupportedUnsetStatementContext {
	var p = new(SupportedUnsetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedUnsetStatement
	return p
}

func InitEmptySupportedUnsetStatementContext(p *SupportedUnsetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedUnsetStatement
}

func (*SupportedUnsetStatementContext) IsSupportedUnsetStatementContext() {}

func NewSupportedUnsetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedUnsetStatementContext {
	var p = new(SupportedUnsetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedUnsetStatement

	return p
}

func (s *SupportedUnsetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedUnsetStatementContext) UNSET() antlr.TerminalNode {
	return s.GetToken(DorisParserUNSET, 0)
}

func (s *SupportedUnsetStatementContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserVARIABLE, 0)
}

func (s *SupportedUnsetStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *SupportedUnsetStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SupportedUnsetStatementContext) StatementScope() IStatementScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementScopeContext)
}

func (s *SupportedUnsetStatementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *SupportedUnsetStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *SupportedUnsetStatementContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULT, 0)
}

func (s *SupportedUnsetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedUnsetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SupportedUnsetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSupportedUnsetStatement(s)
	}
}

func (s *SupportedUnsetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSupportedUnsetStatement(s)
	}
}

func (p *DorisParser) SupportedUnsetStatement() (localctx ISupportedUnsetStatementContext) {
	localctx = NewSupportedUnsetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, DorisParserRULE_supportedUnsetStatement)
	var _la int

	p.SetState(4312)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 602, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4299)
			p.Match(DorisParserUNSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4301)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION {
			{
				p.SetState(4300)
				p.StatementScope()
			}

		}
		{
			p.SetState(4303)
			p.Match(DorisParserVARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4306)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserALL:
			{
				p.SetState(4304)
				p.Match(DorisParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(4305)
				p.Identifier()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4308)
			p.Match(DorisParserUNSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4309)
			p.Match(DorisParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4310)
			p.Match(DorisParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4311)
			p.Match(DorisParserVAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedUseStatementContext is an interface to support dynamic dispatch.
type ISupportedUseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedUseStatementContext differentiates from other interfaces.
	IsSupportedUseStatementContext()
}

type SupportedUseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedUseStatementContext() *SupportedUseStatementContext {
	var p = new(SupportedUseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedUseStatement
	return p
}

func InitEmptySupportedUseStatementContext(p *SupportedUseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedUseStatement
}

func (*SupportedUseStatementContext) IsSupportedUseStatementContext() {}

func NewSupportedUseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedUseStatementContext {
	var p = new(SupportedUseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedUseStatement

	return p
}

func (s *SupportedUseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedUseStatementContext) CopyAll(ctx *SupportedUseStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedUseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedUseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UseCloudClusterContext struct {
	SupportedUseStatementContext
	catalog  IIdentifierContext
	database IIdentifierContext
	cluster  IIdentifierContext
}

func NewUseCloudClusterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UseCloudClusterContext {
	var p = new(UseCloudClusterContext)

	InitEmptySupportedUseStatementContext(&p.SupportedUseStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedUseStatementContext))

	return p
}

func (s *UseCloudClusterContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *UseCloudClusterContext) GetDatabase() IIdentifierContext { return s.database }

func (s *UseCloudClusterContext) GetCluster() IIdentifierContext { return s.cluster }

func (s *UseCloudClusterContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *UseCloudClusterContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *UseCloudClusterContext) SetCluster(v IIdentifierContext) { s.cluster = v }

func (s *UseCloudClusterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseCloudClusterContext) USE() antlr.TerminalNode {
	return s.GetToken(DorisParserUSE, 0)
}

func (s *UseCloudClusterContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserATSIGN, 0)
}

func (s *UseCloudClusterContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *UseCloudClusterContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UseCloudClusterContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *UseCloudClusterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUseCloudCluster(s)
	}
}

func (s *UseCloudClusterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUseCloudCluster(s)
	}
}

type UseDatabaseContext struct {
	SupportedUseStatementContext
	catalog  IIdentifierContext
	database IIdentifierContext
}

func NewUseDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UseDatabaseContext {
	var p = new(UseDatabaseContext)

	InitEmptySupportedUseStatementContext(&p.SupportedUseStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedUseStatementContext))

	return p
}

func (s *UseDatabaseContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *UseDatabaseContext) GetDatabase() IIdentifierContext { return s.database }

func (s *UseDatabaseContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *UseDatabaseContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *UseDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseDatabaseContext) USE() antlr.TerminalNode {
	return s.GetToken(DorisParserUSE, 0)
}

func (s *UseDatabaseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *UseDatabaseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UseDatabaseContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *UseDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUseDatabase(s)
	}
}

func (s *UseDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUseDatabase(s)
	}
}

type SwitchCatalogContext struct {
	SupportedUseStatementContext
	catalog IIdentifierContext
}

func NewSwitchCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SwitchCatalogContext {
	var p = new(SwitchCatalogContext)

	InitEmptySupportedUseStatementContext(&p.SupportedUseStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedUseStatementContext))

	return p
}

func (s *SwitchCatalogContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *SwitchCatalogContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *SwitchCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchCatalogContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(DorisParserSWITCH, 0)
}

func (s *SwitchCatalogContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SwitchCatalogContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSwitchCatalog(s)
	}
}

func (s *SwitchCatalogContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSwitchCatalog(s)
	}
}

func (p *DorisParser) SupportedUseStatement() (localctx ISupportedUseStatementContext) {
	localctx = NewSupportedUseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, DorisParserRULE_supportedUseStatement)
	var _la int

	p.SetState(4334)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 606, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSwitchCatalogContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4314)
			p.Match(DorisParserSWITCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4315)

			var _x = p.Identifier()

			localctx.(*SwitchCatalogContext).catalog = _x
		}

	case 2:
		localctx = NewUseDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4316)
			p.Match(DorisParserUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4320)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 603, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4317)

				var _x = p.Identifier()

				localctx.(*UseDatabaseContext).catalog = _x
			}
			{
				p.SetState(4318)
				p.Match(DorisParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4322)

			var _x = p.Identifier()

			localctx.(*UseDatabaseContext).database = _x
		}

	case 3:
		localctx = NewUseCloudClusterContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4323)
			p.Match(DorisParserUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4330)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305902462020672000) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4609989332399152113) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4540397275156637211) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&2557745532860070517) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&8545544968972265069) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-305714810442809349) != 0) || ((int64((_la-391)) & ^0x3f) == 0 && ((int64(1)<<(_la-391))&1188948054525294943) != 0) || ((int64((_la-455)) & ^0x3f) == 0 && ((int64(1)<<(_la-455))&2458964612221191023) != 0) || ((int64((_la-538)) & ^0x3f) == 0 && ((int64(1)<<(_la-538))&49159) != 0) {
			p.SetState(4327)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 604, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(4324)

					var _x = p.Identifier()

					localctx.(*UseCloudClusterContext).catalog = _x
				}
				{
					p.SetState(4325)
					p.Match(DorisParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(4329)

				var _x = p.Identifier()

				localctx.(*UseCloudClusterContext).database = _x
			}

		}
		{
			p.SetState(4332)
			p.Match(DorisParserATSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4333)

			var _x = p.Identifier()

			localctx.(*UseCloudClusterContext).cluster = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStageAndPatternContext is an interface to support dynamic dispatch.
type IStageAndPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern token.
	GetPattern() antlr.Token

	// SetPattern sets the pattern token.
	SetPattern(antlr.Token)

	// GetStage returns the stage rule contexts.
	GetStage() IIdentifierContext

	// SetStage sets the stage rule contexts.
	SetStage(IIdentifierContext)

	// Getter signatures
	ATSIGN() antlr.TerminalNode
	TILDE() antlr.TerminalNode
	Identifier() IIdentifierContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsStageAndPatternContext differentiates from other interfaces.
	IsStageAndPatternContext()
}

type StageAndPatternContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	stage   IIdentifierContext
	pattern antlr.Token
}

func NewEmptyStageAndPatternContext() *StageAndPatternContext {
	var p = new(StageAndPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_stageAndPattern
	return p
}

func InitEmptyStageAndPatternContext(p *StageAndPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_stageAndPattern
}

func (*StageAndPatternContext) IsStageAndPatternContext() {}

func NewStageAndPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StageAndPatternContext {
	var p = new(StageAndPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_stageAndPattern

	return p
}

func (s *StageAndPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *StageAndPatternContext) GetPattern() antlr.Token { return s.pattern }

func (s *StageAndPatternContext) SetPattern(v antlr.Token) { s.pattern = v }

func (s *StageAndPatternContext) GetStage() IIdentifierContext { return s.stage }

func (s *StageAndPatternContext) SetStage(v IIdentifierContext) { s.stage = v }

func (s *StageAndPatternContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserATSIGN, 0)
}

func (s *StageAndPatternContext) TILDE() antlr.TerminalNode {
	return s.GetToken(DorisParserTILDE, 0)
}

func (s *StageAndPatternContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StageAndPatternContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *StageAndPatternContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *StageAndPatternContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *StageAndPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StageAndPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StageAndPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStageAndPattern(s)
	}
}

func (s *StageAndPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStageAndPattern(s)
	}
}

func (p *DorisParser) StageAndPattern() (localctx IStageAndPatternContext) {
	localctx = NewStageAndPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, DorisParserRULE_stageAndPattern)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4336)
		p.Match(DorisParserATSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4339)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		{
			p.SetState(4337)

			var _x = p.Identifier()

			localctx.(*StageAndPatternContext).stage = _x
		}

	case DorisParserTILDE:
		{
			p.SetState(4338)
			p.Match(DorisParserTILDE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(4344)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLEFT_PAREN {
		{
			p.SetState(4341)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4342)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*StageAndPatternContext).pattern = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4343)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedDescribeStatementContext is an interface to support dynamic dispatch.
type ISupportedDescribeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedDescribeStatementContext differentiates from other interfaces.
	IsSupportedDescribeStatementContext()
}

type SupportedDescribeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedDescribeStatementContext() *SupportedDescribeStatementContext {
	var p = new(SupportedDescribeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedDescribeStatement
	return p
}

func InitEmptySupportedDescribeStatementContext(p *SupportedDescribeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_supportedDescribeStatement
}

func (*SupportedDescribeStatementContext) IsSupportedDescribeStatementContext() {}

func NewSupportedDescribeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedDescribeStatementContext {
	var p = new(SupportedDescribeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_supportedDescribeStatement

	return p
}

func (s *SupportedDescribeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedDescribeStatementContext) CopyAll(ctx *SupportedDescribeStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedDescribeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedDescribeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DescribeTableValuedFunctionContext struct {
	SupportedDescribeStatementContext
	tvfName    IIdentifierContext
	properties IPropertyItemListContext
}

func NewDescribeTableValuedFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeTableValuedFunctionContext {
	var p = new(DescribeTableValuedFunctionContext)

	InitEmptySupportedDescribeStatementContext(&p.SupportedDescribeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDescribeStatementContext))

	return p
}

func (s *DescribeTableValuedFunctionContext) GetTvfName() IIdentifierContext { return s.tvfName }

func (s *DescribeTableValuedFunctionContext) GetProperties() IPropertyItemListContext {
	return s.properties
}

func (s *DescribeTableValuedFunctionContext) SetTvfName(v IIdentifierContext) { s.tvfName = v }

func (s *DescribeTableValuedFunctionContext) SetProperties(v IPropertyItemListContext) {
	s.properties = v
}

func (s *DescribeTableValuedFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeTableValuedFunctionContext) ExplainCommand() IExplainCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainCommandContext)
}

func (s *DescribeTableValuedFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserFUNCTION, 0)
}

func (s *DescribeTableValuedFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *DescribeTableValuedFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *DescribeTableValuedFunctionContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *DescribeTableValuedFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DescribeTableValuedFunctionContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *DescribeTableValuedFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDescribeTableValuedFunction(s)
	}
}

func (s *DescribeTableValuedFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDescribeTableValuedFunction(s)
	}
}

type DescribeTableContext struct {
	SupportedDescribeStatementContext
}

func NewDescribeTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeTableContext {
	var p = new(DescribeTableContext)

	InitEmptySupportedDescribeStatementContext(&p.SupportedDescribeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDescribeStatementContext))

	return p
}

func (s *DescribeTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeTableContext) ExplainCommand() IExplainCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainCommandContext)
}

func (s *DescribeTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DescribeTableContext) SpecifiedPartition() ISpecifiedPartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecifiedPartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecifiedPartitionContext)
}

func (s *DescribeTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDescribeTable(s)
	}
}

func (s *DescribeTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDescribeTable(s)
	}
}

type DescribeTableAllContext struct {
	SupportedDescribeStatementContext
}

func NewDescribeTableAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeTableAllContext {
	var p = new(DescribeTableAllContext)

	InitEmptySupportedDescribeStatementContext(&p.SupportedDescribeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDescribeStatementContext))

	return p
}

func (s *DescribeTableAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeTableAllContext) ExplainCommand() IExplainCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainCommandContext)
}

func (s *DescribeTableAllContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DescribeTableAllContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *DescribeTableAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDescribeTableAll(s)
	}
}

func (s *DescribeTableAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDescribeTableAll(s)
	}
}

type DescribeDictionaryContext struct {
	SupportedDescribeStatementContext
}

func NewDescribeDictionaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeDictionaryContext {
	var p = new(DescribeDictionaryContext)

	InitEmptySupportedDescribeStatementContext(&p.SupportedDescribeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDescribeStatementContext))

	return p
}

func (s *DescribeDictionaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeDictionaryContext) ExplainCommand() IExplainCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainCommandContext)
}

func (s *DescribeDictionaryContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(DorisParserDICTIONARY, 0)
}

func (s *DescribeDictionaryContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DescribeDictionaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDescribeDictionary(s)
	}
}

func (s *DescribeDictionaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDescribeDictionary(s)
	}
}

func (p *DorisParser) SupportedDescribeStatement() (localctx ISupportedDescribeStatementContext) {
	localctx = NewSupportedDescribeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, DorisParserRULE_supportedDescribeStatement)
	var _la int

	p.SetState(4369)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 611, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDescribeTableValuedFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4346)
			p.ExplainCommand()
		}
		{
			p.SetState(4347)
			p.Match(DorisParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4348)

			var _x = p.Identifier()

			localctx.(*DescribeTableValuedFunctionContext).tvfName = _x
		}
		{
			p.SetState(4349)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4351)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305884869834627456) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4609989332399152113) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4539834325203215899) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&2557745532860070517) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&8563559367481747053) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-305714810442743813) != 0) || ((int64((_la-391)) & ^0x3f) == 0 && ((int64(1)<<(_la-391))&1188948054525294943) != 0) || ((int64((_la-455)) & ^0x3f) == 0 && ((int64(1)<<(_la-455))&2458964612221715311) != 0) || ((int64((_la-525)) & ^0x3f) == 0 && ((int64(1)<<(_la-525))&461692929) != 0) {
			{
				p.SetState(4350)

				var _x = p.PropertyItemList()

				localctx.(*DescribeTableValuedFunctionContext).properties = _x
			}

		}
		{
			p.SetState(4353)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4354)
			p.TableAlias()
		}

	case 2:
		localctx = NewDescribeTableAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4356)
			p.ExplainCommand()
		}
		{
			p.SetState(4357)
			p.MultipartIdentifier()
		}
		{
			p.SetState(4358)
			p.Match(DorisParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewDescribeTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4360)
			p.ExplainCommand()
		}
		{
			p.SetState(4361)
			p.MultipartIdentifier()
		}
		p.SetState(4363)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(4362)
				p.SpecifiedPartition()
			}

		}

	case 4:
		localctx = NewDescribeDictionaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4365)
			p.ExplainCommand()
		}
		{
			p.SetState(4366)
			p.Match(DorisParserDICTIONARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4367)
			p.MultipartIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstraintContext is an interface to support dynamic dispatch.
type IConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSlots returns the slots rule contexts.
	GetSlots() IIdentifierListContext

	// GetReferenceTable returns the referenceTable rule contexts.
	GetReferenceTable() IMultipartIdentifierContext

	// GetReferencedSlots returns the referencedSlots rule contexts.
	GetReferencedSlots() IIdentifierListContext

	// SetSlots sets the slots rule contexts.
	SetSlots(IIdentifierListContext)

	// SetReferenceTable sets the referenceTable rule contexts.
	SetReferenceTable(IMultipartIdentifierContext)

	// SetReferencedSlots sets the referencedSlots rule contexts.
	SetReferencedSlots(IIdentifierListContext)

	// Getter signatures
	PRIMARY() antlr.TerminalNode
	KEY() antlr.TerminalNode
	AllIdentifierList() []IIdentifierListContext
	IdentifierList(i int) IIdentifierListContext
	UNIQUE() antlr.TerminalNode
	FOREIGN() antlr.TerminalNode
	REFERENCES() antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext

	// IsConstraintContext differentiates from other interfaces.
	IsConstraintContext()
}

type ConstraintContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	slots           IIdentifierListContext
	referenceTable  IMultipartIdentifierContext
	referencedSlots IIdentifierListContext
}

func NewEmptyConstraintContext() *ConstraintContext {
	var p = new(ConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_constraint
	return p
}

func InitEmptyConstraintContext(p *ConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_constraint
}

func (*ConstraintContext) IsConstraintContext() {}

func NewConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintContext {
	var p = new(ConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_constraint

	return p
}

func (s *ConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintContext) GetSlots() IIdentifierListContext { return s.slots }

func (s *ConstraintContext) GetReferenceTable() IMultipartIdentifierContext { return s.referenceTable }

func (s *ConstraintContext) GetReferencedSlots() IIdentifierListContext { return s.referencedSlots }

func (s *ConstraintContext) SetSlots(v IIdentifierListContext) { s.slots = v }

func (s *ConstraintContext) SetReferenceTable(v IMultipartIdentifierContext) { s.referenceTable = v }

func (s *ConstraintContext) SetReferencedSlots(v IIdentifierListContext) { s.referencedSlots = v }

func (s *ConstraintContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(DorisParserPRIMARY, 0)
}

func (s *ConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserKEY, 0)
}

func (s *ConstraintContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *ConstraintContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ConstraintContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(DorisParserUNIQUE, 0)
}

func (s *ConstraintContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserFOREIGN, 0)
}

func (s *ConstraintContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(DorisParserREFERENCES, 0)
}

func (s *ConstraintContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterConstraint(s)
	}
}

func (s *ConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitConstraint(s)
	}
}

func (p *DorisParser) Constraint() (localctx IConstraintContext) {
	localctx = NewConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, DorisParserRULE_constraint)
	p.SetState(4383)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserPRIMARY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4371)
			p.Match(DorisParserPRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4372)
			p.Match(DorisParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4373)

			var _x = p.IdentifierList()

			localctx.(*ConstraintContext).slots = _x
		}

	case DorisParserUNIQUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4374)
			p.Match(DorisParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4375)

			var _x = p.IdentifierList()

			localctx.(*ConstraintContext).slots = _x
		}

	case DorisParserFOREIGN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4376)
			p.Match(DorisParserFOREIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4377)
			p.Match(DorisParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4378)

			var _x = p.IdentifierList()

			localctx.(*ConstraintContext).slots = _x
		}
		{
			p.SetState(4379)
			p.Match(DorisParserREFERENCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4380)

			var _x = p.MultipartIdentifier()

			localctx.(*ConstraintContext).referenceTable = _x
		}
		{
			p.SetState(4381)

			var _x = p.IdentifierList()

			localctx.(*ConstraintContext).referencedSlots = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionSpecContext is an interface to support dynamic dispatch.
type IPartitionSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitions returns the partitions rule contexts.
	GetPartitions() IIdentifierListContext

	// GetPartition returns the partition rule contexts.
	GetPartition() IErrorCapturingIdentifierContext

	// SetPartitions sets the partitions rule contexts.
	SetPartitions(IIdentifierListContext)

	// SetPartition sets the partition rule contexts.
	SetPartition(IErrorCapturingIdentifierContext)

	// Getter signatures
	PARTITION() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	TEMPORARY() antlr.TerminalNode
	ErrorCapturingIdentifier() IErrorCapturingIdentifierContext
	LEFT_PAREN() antlr.TerminalNode
	ASTERISK() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode

	// IsPartitionSpecContext differentiates from other interfaces.
	IsPartitionSpecContext()
}

type PartitionSpecContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	partitions IIdentifierListContext
	partition  IErrorCapturingIdentifierContext
}

func NewEmptyPartitionSpecContext() *PartitionSpecContext {
	var p = new(PartitionSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionSpec
	return p
}

func InitEmptyPartitionSpecContext(p *PartitionSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionSpec
}

func (*PartitionSpecContext) IsPartitionSpecContext() {}

func NewPartitionSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionSpecContext {
	var p = new(PartitionSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_partitionSpec

	return p
}

func (s *PartitionSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionSpecContext) GetPartitions() IIdentifierListContext { return s.partitions }

func (s *PartitionSpecContext) GetPartition() IErrorCapturingIdentifierContext { return s.partition }

func (s *PartitionSpecContext) SetPartitions(v IIdentifierListContext) { s.partitions = v }

func (s *PartitionSpecContext) SetPartition(v IErrorCapturingIdentifierContext) { s.partition = v }

func (s *PartitionSpecContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *PartitionSpecContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITIONS, 0)
}

func (s *PartitionSpecContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PartitionSpecContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *PartitionSpecContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *PartitionSpecContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *PartitionSpecContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserASTERISK, 0)
}

func (s *PartitionSpecContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *PartitionSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPartitionSpec(s)
	}
}

func (s *PartitionSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPartitionSpec(s)
	}
}

func (p *DorisParser) PartitionSpec() (localctx IPartitionSpecContext) {
	localctx = NewPartitionSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, DorisParserRULE_partitionSpec)
	var _la int

	p.SetState(4399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 615, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4386)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(4385)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4388)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserPARTITION || _la == DorisParserPARTITIONS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4389)

			var _x = p.IdentifierList()

			localctx.(*PartitionSpecContext).partitions = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4391)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(4390)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4393)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4394)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*PartitionSpecContext).partition = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4395)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserPARTITION || _la == DorisParserPARTITIONS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4396)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4397)
			p.Match(DorisParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4398)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionTableContext is an interface to support dynamic dispatch.
type IPartitionTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAutoPartition returns the autoPartition token.
	GetAutoPartition() antlr.Token

	// SetAutoPartition sets the autoPartition token.
	SetAutoPartition(antlr.Token)

	// GetPartitionList returns the partitionList rule contexts.
	GetPartitionList() IIdentityOrFunctionListContext

	// GetPartitions returns the partitions rule contexts.
	GetPartitions() IPartitionsDefContext

	// SetPartitionList sets the partitionList rule contexts.
	SetPartitionList(IIdentityOrFunctionListContext)

	// SetPartitions sets the partitions rule contexts.
	SetPartitions(IPartitionsDefContext)

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	IdentityOrFunctionList() IIdentityOrFunctionListContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AUTO() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	LIST() antlr.TerminalNode
	PartitionsDef() IPartitionsDefContext

	// IsPartitionTableContext differentiates from other interfaces.
	IsPartitionTableContext()
}

type PartitionTableContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	autoPartition antlr.Token
	partitionList IIdentityOrFunctionListContext
	partitions    IPartitionsDefContext
}

func NewEmptyPartitionTableContext() *PartitionTableContext {
	var p = new(PartitionTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionTable
	return p
}

func InitEmptyPartitionTableContext(p *PartitionTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionTable
}

func (*PartitionTableContext) IsPartitionTableContext() {}

func NewPartitionTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionTableContext {
	var p = new(PartitionTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_partitionTable

	return p
}

func (s *PartitionTableContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionTableContext) GetAutoPartition() antlr.Token { return s.autoPartition }

func (s *PartitionTableContext) SetAutoPartition(v antlr.Token) { s.autoPartition = v }

func (s *PartitionTableContext) GetPartitionList() IIdentityOrFunctionListContext {
	return s.partitionList
}

func (s *PartitionTableContext) GetPartitions() IPartitionsDefContext { return s.partitions }

func (s *PartitionTableContext) SetPartitionList(v IIdentityOrFunctionListContext) {
	s.partitionList = v
}

func (s *PartitionTableContext) SetPartitions(v IPartitionsDefContext) { s.partitions = v }

func (s *PartitionTableContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *PartitionTableContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *PartitionTableContext) IdentityOrFunctionList() IIdentityOrFunctionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentityOrFunctionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentityOrFunctionListContext)
}

func (s *PartitionTableContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *PartitionTableContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *PartitionTableContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO, 0)
}

func (s *PartitionTableContext) RANGE() antlr.TerminalNode {
	return s.GetToken(DorisParserRANGE, 0)
}

func (s *PartitionTableContext) LIST() antlr.TerminalNode {
	return s.GetToken(DorisParserLIST, 0)
}

func (s *PartitionTableContext) PartitionsDef() IPartitionsDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionsDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionsDefContext)
}

func (s *PartitionTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPartitionTable(s)
	}
}

func (s *PartitionTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPartitionTable(s)
	}
}

func (p *DorisParser) PartitionTable() (localctx IPartitionTableContext) {
	localctx = NewPartitionTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, DorisParserRULE_partitionTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4402)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserAUTO {
		{
			p.SetState(4401)

			var _m = p.Match(DorisParserAUTO)

			localctx.(*PartitionTableContext).autoPartition = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4404)
		p.Match(DorisParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4405)
		p.Match(DorisParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4407)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLIST || _la == DorisParserRANGE {
		{
			p.SetState(4406)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserLIST || _la == DorisParserRANGE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(4409)

		var _x = p.IdentityOrFunctionList()

		localctx.(*PartitionTableContext).partitionList = _x
	}

	{
		p.SetState(4410)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4412)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserFROM || _la == DorisParserPARTITION {
		{
			p.SetState(4411)

			var _x = p.PartitionsDef()

			localctx.(*PartitionTableContext).partitions = _x
		}

	}
	{
		p.SetState(4414)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentityOrFunctionListContext is an interface to support dynamic dispatch.
type IIdentityOrFunctionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_identityOrFunction returns the _identityOrFunction rule contexts.
	Get_identityOrFunction() IIdentityOrFunctionContext

	// Set_identityOrFunction sets the _identityOrFunction rule contexts.
	Set_identityOrFunction(IIdentityOrFunctionContext)

	// GetPartitions returns the partitions rule context list.
	GetPartitions() []IIdentityOrFunctionContext

	// SetPartitions sets the partitions rule context list.
	SetPartitions([]IIdentityOrFunctionContext)

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	AllIdentityOrFunction() []IIdentityOrFunctionContext
	IdentityOrFunction(i int) IIdentityOrFunctionContext
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentityOrFunctionListContext differentiates from other interfaces.
	IsIdentityOrFunctionListContext()
}

type IdentityOrFunctionListContext struct {
	antlr.BaseParserRuleContext
	parser              antlr.Parser
	_identityOrFunction IIdentityOrFunctionContext
	partitions          []IIdentityOrFunctionContext
}

func NewEmptyIdentityOrFunctionListContext() *IdentityOrFunctionListContext {
	var p = new(IdentityOrFunctionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identityOrFunctionList
	return p
}

func InitEmptyIdentityOrFunctionListContext(p *IdentityOrFunctionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identityOrFunctionList
}

func (*IdentityOrFunctionListContext) IsIdentityOrFunctionListContext() {}

func NewIdentityOrFunctionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentityOrFunctionListContext {
	var p = new(IdentityOrFunctionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_identityOrFunctionList

	return p
}

func (s *IdentityOrFunctionListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentityOrFunctionListContext) Get_identityOrFunction() IIdentityOrFunctionContext {
	return s._identityOrFunction
}

func (s *IdentityOrFunctionListContext) Set_identityOrFunction(v IIdentityOrFunctionContext) {
	s._identityOrFunction = v
}

func (s *IdentityOrFunctionListContext) GetPartitions() []IIdentityOrFunctionContext {
	return s.partitions
}

func (s *IdentityOrFunctionListContext) SetPartitions(v []IIdentityOrFunctionContext) {
	s.partitions = v
}

func (s *IdentityOrFunctionListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *IdentityOrFunctionListContext) AllIdentityOrFunction() []IIdentityOrFunctionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentityOrFunctionContext); ok {
			len++
		}
	}

	tst := make([]IIdentityOrFunctionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentityOrFunctionContext); ok {
			tst[i] = t.(IIdentityOrFunctionContext)
			i++
		}
	}

	return tst
}

func (s *IdentityOrFunctionListContext) IdentityOrFunction(i int) IIdentityOrFunctionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentityOrFunctionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentityOrFunctionContext)
}

func (s *IdentityOrFunctionListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *IdentityOrFunctionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *IdentityOrFunctionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *IdentityOrFunctionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentityOrFunctionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentityOrFunctionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIdentityOrFunctionList(s)
	}
}

func (s *IdentityOrFunctionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIdentityOrFunctionList(s)
	}
}

func (p *DorisParser) IdentityOrFunctionList() (localctx IIdentityOrFunctionListContext) {
	localctx = NewIdentityOrFunctionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, DorisParserRULE_identityOrFunctionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4416)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4417)
		p.IdentityOrFunction()
	}
	p.SetState(4422)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(4418)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4419)

			var _x = p.IdentityOrFunction()

			localctx.(*IdentityOrFunctionListContext)._identityOrFunction = _x
		}
		localctx.(*IdentityOrFunctionListContext).partitions = append(localctx.(*IdentityOrFunctionListContext).partitions, localctx.(*IdentityOrFunctionListContext)._identityOrFunction)

		p.SetState(4424)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4425)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentityOrFunctionContext is an interface to support dynamic dispatch.
type IIdentityOrFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	FunctionCallExpression() IFunctionCallExpressionContext

	// IsIdentityOrFunctionContext differentiates from other interfaces.
	IsIdentityOrFunctionContext()
}

type IdentityOrFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentityOrFunctionContext() *IdentityOrFunctionContext {
	var p = new(IdentityOrFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identityOrFunction
	return p
}

func InitEmptyIdentityOrFunctionContext(p *IdentityOrFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identityOrFunction
}

func (*IdentityOrFunctionContext) IsIdentityOrFunctionContext() {}

func NewIdentityOrFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentityOrFunctionContext {
	var p = new(IdentityOrFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_identityOrFunction

	return p
}

func (s *IdentityOrFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentityOrFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentityOrFunctionContext) FunctionCallExpression() IFunctionCallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallExpressionContext)
}

func (s *IdentityOrFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentityOrFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentityOrFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIdentityOrFunction(s)
	}
}

func (s *IdentityOrFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIdentityOrFunction(s)
	}
}

func (p *DorisParser) IdentityOrFunction() (localctx IIdentityOrFunctionContext) {
	localctx = NewIdentityOrFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, DorisParserRULE_identityOrFunction)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4429)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 620, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4427)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4428)
			p.FunctionCallExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataDescContext is an interface to support dynamic dispatch.
type IDataDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_STRING_LITERAL returns the _STRING_LITERAL token.
	Get_STRING_LITERAL() antlr.Token

	// GetComma returns the comma token.
	GetComma() antlr.Token

	// GetSeparator returns the separator token.
	GetSeparator() antlr.Token

	// Set_STRING_LITERAL sets the _STRING_LITERAL token.
	Set_STRING_LITERAL(antlr.Token)

	// SetComma sets the comma token.
	SetComma(antlr.Token)

	// SetSeparator sets the separator token.
	SetSeparator(antlr.Token)

	// GetFilePaths returns the filePaths token list.
	GetFilePaths() []antlr.Token

	// GetFilePath returns the filePath token list.
	GetFilePath() []antlr.Token

	// SetFilePaths sets the filePaths token list.
	SetFilePaths([]antlr.Token)

	// SetFilePath sets the filePath token list.
	SetFilePath([]antlr.Token)

	// GetTargetTableName returns the targetTableName rule contexts.
	GetTargetTableName() IIdentifierContext

	// GetFormat returns the format rule contexts.
	GetFormat() IIdentifierOrTextContext

	// GetCompressType returns the compressType rule contexts.
	GetCompressType() IIdentifierOrTextContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IIdentifierListContext

	// GetColumnsFromPath returns the columnsFromPath rule contexts.
	GetColumnsFromPath() IColFromPathContext

	// GetColumnMapping returns the columnMapping rule contexts.
	GetColumnMapping() IColMappingListContext

	// GetPreFilter returns the preFilter rule contexts.
	GetPreFilter() IPreFilterClauseContext

	// GetWhere returns the where rule contexts.
	GetWhere() IWhereClauseContext

	// GetDeleteOn returns the deleteOn rule contexts.
	GetDeleteOn() IDeleteOnClauseContext

	// GetSequenceColumn returns the sequenceColumn rule contexts.
	GetSequenceColumn() ISequenceColClauseContext

	// GetSourceTableName returns the sourceTableName rule contexts.
	GetSourceTableName() IIdentifierContext

	// GetPartition returns the partition rule contexts.
	GetPartition() IIdentifierListContext

	// SetTargetTableName sets the targetTableName rule contexts.
	SetTargetTableName(IIdentifierContext)

	// SetFormat sets the format rule contexts.
	SetFormat(IIdentifierOrTextContext)

	// SetCompressType sets the compressType rule contexts.
	SetCompressType(IIdentifierOrTextContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IIdentifierListContext)

	// SetColumnsFromPath sets the columnsFromPath rule contexts.
	SetColumnsFromPath(IColFromPathContext)

	// SetColumnMapping sets the columnMapping rule contexts.
	SetColumnMapping(IColMappingListContext)

	// SetPreFilter sets the preFilter rule contexts.
	SetPreFilter(IPreFilterClauseContext)

	// SetWhere sets the where rule contexts.
	SetWhere(IWhereClauseContext)

	// SetDeleteOn sets the deleteOn rule contexts.
	SetDeleteOn(IDeleteOnClauseContext)

	// SetSequenceColumn sets the sequenceColumn rule contexts.
	SetSequenceColumn(ISequenceColClauseContext)

	// SetSourceTableName sets the sourceTableName rule contexts.
	SetSourceTableName(IIdentifierContext)

	// SetPartition sets the partition rule contexts.
	SetPartition(IIdentifierListContext)

	// Getter signatures
	DATA() antlr.TerminalNode
	INFILE() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	INTO() antlr.TerminalNode
	AllTABLE() []antlr.TerminalNode
	TABLE(i int) antlr.TerminalNode
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	MergeType() IMergeTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	PartitionSpec() IPartitionSpecContext
	COLUMNS() antlr.TerminalNode
	AllTERMINATED() []antlr.TerminalNode
	TERMINATED(i int) antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	LINES() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	AllAS() []antlr.TerminalNode
	AS(i int) antlr.TerminalNode
	COMPRESS_TYPE() antlr.TerminalNode
	PropertyClause() IPropertyClauseContext
	AllIdentifierOrText() []IIdentifierOrTextContext
	IdentifierOrText(i int) IIdentifierOrTextContext
	IdentifierList() IIdentifierListContext
	ColFromPath() IColFromPathContext
	ColMappingList() IColMappingListContext
	PreFilterClause() IPreFilterClauseContext
	WhereClause() IWhereClauseContext
	DeleteOnClause() IDeleteOnClauseContext
	SequenceColClause() ISequenceColClauseContext
	WITH() antlr.TerminalNode
	FROM() antlr.TerminalNode
	PARTITION() antlr.TerminalNode

	// IsDataDescContext differentiates from other interfaces.
	IsDataDescContext()
}

type DataDescContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	_STRING_LITERAL antlr.Token
	filePaths       []antlr.Token
	filePath        []antlr.Token
	targetTableName IIdentifierContext
	comma           antlr.Token
	separator       antlr.Token
	format          IIdentifierOrTextContext
	compressType    IIdentifierOrTextContext
	columns         IIdentifierListContext
	columnsFromPath IColFromPathContext
	columnMapping   IColMappingListContext
	preFilter       IPreFilterClauseContext
	where           IWhereClauseContext
	deleteOn        IDeleteOnClauseContext
	sequenceColumn  ISequenceColClauseContext
	sourceTableName IIdentifierContext
	partition       IIdentifierListContext
}

func NewEmptyDataDescContext() *DataDescContext {
	var p = new(DataDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dataDesc
	return p
}

func InitEmptyDataDescContext(p *DataDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dataDesc
}

func (*DataDescContext) IsDataDescContext() {}

func NewDataDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescContext {
	var p = new(DataDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_dataDesc

	return p
}

func (s *DataDescContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDescContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *DataDescContext) GetComma() antlr.Token { return s.comma }

func (s *DataDescContext) GetSeparator() antlr.Token { return s.separator }

func (s *DataDescContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *DataDescContext) SetComma(v antlr.Token) { s.comma = v }

func (s *DataDescContext) SetSeparator(v antlr.Token) { s.separator = v }

func (s *DataDescContext) GetFilePaths() []antlr.Token { return s.filePaths }

func (s *DataDescContext) GetFilePath() []antlr.Token { return s.filePath }

func (s *DataDescContext) SetFilePaths(v []antlr.Token) { s.filePaths = v }

func (s *DataDescContext) SetFilePath(v []antlr.Token) { s.filePath = v }

func (s *DataDescContext) GetTargetTableName() IIdentifierContext { return s.targetTableName }

func (s *DataDescContext) GetFormat() IIdentifierOrTextContext { return s.format }

func (s *DataDescContext) GetCompressType() IIdentifierOrTextContext { return s.compressType }

func (s *DataDescContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *DataDescContext) GetColumnsFromPath() IColFromPathContext { return s.columnsFromPath }

func (s *DataDescContext) GetColumnMapping() IColMappingListContext { return s.columnMapping }

func (s *DataDescContext) GetPreFilter() IPreFilterClauseContext { return s.preFilter }

func (s *DataDescContext) GetWhere() IWhereClauseContext { return s.where }

func (s *DataDescContext) GetDeleteOn() IDeleteOnClauseContext { return s.deleteOn }

func (s *DataDescContext) GetSequenceColumn() ISequenceColClauseContext { return s.sequenceColumn }

func (s *DataDescContext) GetSourceTableName() IIdentifierContext { return s.sourceTableName }

func (s *DataDescContext) GetPartition() IIdentifierListContext { return s.partition }

func (s *DataDescContext) SetTargetTableName(v IIdentifierContext) { s.targetTableName = v }

func (s *DataDescContext) SetFormat(v IIdentifierOrTextContext) { s.format = v }

func (s *DataDescContext) SetCompressType(v IIdentifierOrTextContext) { s.compressType = v }

func (s *DataDescContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *DataDescContext) SetColumnsFromPath(v IColFromPathContext) { s.columnsFromPath = v }

func (s *DataDescContext) SetColumnMapping(v IColMappingListContext) { s.columnMapping = v }

func (s *DataDescContext) SetPreFilter(v IPreFilterClauseContext) { s.preFilter = v }

func (s *DataDescContext) SetWhere(v IWhereClauseContext) { s.where = v }

func (s *DataDescContext) SetDeleteOn(v IDeleteOnClauseContext) { s.deleteOn = v }

func (s *DataDescContext) SetSequenceColumn(v ISequenceColClauseContext) { s.sequenceColumn = v }

func (s *DataDescContext) SetSourceTableName(v IIdentifierContext) { s.sourceTableName = v }

func (s *DataDescContext) SetPartition(v IIdentifierListContext) { s.partition = v }

func (s *DataDescContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserDATA, 0)
}

func (s *DataDescContext) INFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserINFILE, 0)
}

func (s *DataDescContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *DataDescContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *DataDescContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserINTO, 0)
}

func (s *DataDescContext) AllTABLE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserTABLE)
}

func (s *DataDescContext) TABLE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, i)
}

func (s *DataDescContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *DataDescContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *DataDescContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DataDescContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DataDescContext) MergeType() IMergeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeTypeContext)
}

func (s *DataDescContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *DataDescContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *DataDescContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *DataDescContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMNS, 0)
}

func (s *DataDescContext) AllTERMINATED() []antlr.TerminalNode {
	return s.GetTokens(DorisParserTERMINATED)
}

func (s *DataDescContext) TERMINATED(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserTERMINATED, i)
}

func (s *DataDescContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(DorisParserBY)
}

func (s *DataDescContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserBY, i)
}

func (s *DataDescContext) LINES() antlr.TerminalNode {
	return s.GetToken(DorisParserLINES, 0)
}

func (s *DataDescContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DorisParserFORMAT, 0)
}

func (s *DataDescContext) AllAS() []antlr.TerminalNode {
	return s.GetTokens(DorisParserAS)
}

func (s *DataDescContext) AS(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserAS, i)
}

func (s *DataDescContext) COMPRESS_TYPE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPRESS_TYPE, 0)
}

func (s *DataDescContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *DataDescContext) AllIdentifierOrText() []IIdentifierOrTextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrTextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrTextContext); ok {
			tst[i] = t.(IIdentifierOrTextContext)
			i++
		}
	}

	return tst
}

func (s *DataDescContext) IdentifierOrText(i int) IIdentifierOrTextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DataDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DataDescContext) ColFromPath() IColFromPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColFromPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColFromPathContext)
}

func (s *DataDescContext) ColMappingList() IColMappingListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColMappingListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColMappingListContext)
}

func (s *DataDescContext) PreFilterClause() IPreFilterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreFilterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreFilterClauseContext)
}

func (s *DataDescContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *DataDescContext) DeleteOnClause() IDeleteOnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteOnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteOnClauseContext)
}

func (s *DataDescContext) SequenceColClause() ISequenceColClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceColClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceColClauseContext)
}

func (s *DataDescContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *DataDescContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *DataDescContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *DataDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDataDesc(s)
	}
}

func (s *DataDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDataDesc(s)
	}
}

func (p *DorisParser) DataDesc() (localctx IDataDescContext) {
	localctx = NewDataDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, DorisParserRULE_dataDesc)
	var _la int

	p.SetState(4530)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 644, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4435)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAPPEND || _la == DorisParserDELETE || _la == DorisParserMERGE || _la == DorisParserWITH {
			p.SetState(4432)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserWITH {
				{
					p.SetState(4431)
					p.Match(DorisParserWITH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(4434)
				p.MergeType()
			}

		}
		{
			p.SetState(4437)
			p.Match(DorisParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4438)
			p.Match(DorisParserINFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4439)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4440)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*DataDescContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*DataDescContext).filePaths = append(localctx.(*DataDescContext).filePaths, localctx.(*DataDescContext)._STRING_LITERAL)
		p.SetState(4445)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(4441)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4442)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*DataDescContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*DataDescContext).filePath = append(localctx.(*DataDescContext).filePath, localctx.(*DataDescContext)._STRING_LITERAL)

			p.SetState(4447)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4448)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4449)
			p.Match(DorisParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4450)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4451)

			var _x = p.Identifier()

			localctx.(*DataDescContext).targetTableName = _x
		}
		p.SetState(4453)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION || _la == DorisParserPARTITIONS || _la == DorisParserTEMPORARY {
			{
				p.SetState(4452)
				p.PartitionSpec()
			}

		}
		p.SetState(4459)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 625, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4455)
				p.Match(DorisParserCOLUMNS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4456)
				p.Match(DorisParserTERMINATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4457)
				p.Match(DorisParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4458)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*DataDescContext).comma = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4465)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLINES {
			{
				p.SetState(4461)
				p.Match(DorisParserLINES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4462)
				p.Match(DorisParserTERMINATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4463)
				p.Match(DorisParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4464)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*DataDescContext).separator = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(4470)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserFORMAT {
			{
				p.SetState(4467)
				p.Match(DorisParserFORMAT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4468)
				p.Match(DorisParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4469)

				var _x = p.IdentifierOrText()

				localctx.(*DataDescContext).format = _x
			}

		}
		p.SetState(4475)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOMPRESS_TYPE {
			{
				p.SetState(4472)
				p.Match(DorisParserCOMPRESS_TYPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4473)
				p.Match(DorisParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4474)

				var _x = p.IdentifierOrText()

				localctx.(*DataDescContext).compressType = _x
			}

		}
		p.SetState(4478)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(4477)

				var _x = p.IdentifierList()

				localctx.(*DataDescContext).columns = _x
			}

		}
		p.SetState(4481)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserCOLUMNS {
			{
				p.SetState(4480)

				var _x = p.ColFromPath()

				localctx.(*DataDescContext).columnsFromPath = _x
			}

		}
		p.SetState(4484)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserSET {
			{
				p.SetState(4483)

				var _x = p.ColMappingList()

				localctx.(*DataDescContext).columnMapping = _x
			}

		}
		p.SetState(4487)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPRECEDING {
			{
				p.SetState(4486)

				var _x = p.PreFilterClause()

				localctx.(*DataDescContext).preFilter = _x
			}

		}
		p.SetState(4490)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWHERE {
			{
				p.SetState(4489)

				var _x = p.WhereClause()

				localctx.(*DataDescContext).where = _x
			}

		}
		p.SetState(4493)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserDELETE {
			{
				p.SetState(4492)

				var _x = p.DeleteOnClause()

				localctx.(*DataDescContext).deleteOn = _x
			}

		}
		p.SetState(4496)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserORDER {
			{
				p.SetState(4495)

				var _x = p.SequenceColClause()

				localctx.(*DataDescContext).sequenceColumn = _x
			}

		}
		p.SetState(4499)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(4498)
				p.PropertyClause()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4505)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAPPEND || _la == DorisParserDELETE || _la == DorisParserMERGE || _la == DorisParserWITH {
			p.SetState(4502)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserWITH {
				{
					p.SetState(4501)
					p.Match(DorisParserWITH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(4504)
				p.MergeType()
			}

		}
		{
			p.SetState(4507)
			p.Match(DorisParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4508)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4509)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4510)

			var _x = p.Identifier()

			localctx.(*DataDescContext).sourceTableName = _x
		}
		{
			p.SetState(4511)
			p.Match(DorisParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4512)
			p.Match(DorisParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4513)

			var _x = p.Identifier()

			localctx.(*DataDescContext).targetTableName = _x
		}
		p.SetState(4516)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPARTITION {
			{
				p.SetState(4514)
				p.Match(DorisParserPARTITION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4515)

				var _x = p.IdentifierList()

				localctx.(*DataDescContext).partition = _x
			}

		}
		p.SetState(4519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserSET {
			{
				p.SetState(4518)

				var _x = p.ColMappingList()

				localctx.(*DataDescContext).columnMapping = _x
			}

		}
		p.SetState(4522)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserWHERE {
			{
				p.SetState(4521)

				var _x = p.WhereClause()

				localctx.(*DataDescContext).where = _x
			}

		}
		p.SetState(4525)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserDELETE {
			{
				p.SetState(4524)

				var _x = p.DeleteOnClause()

				localctx.(*DataDescContext).deleteOn = _x
			}

		}
		p.SetState(4528)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPROPERTIES {
			{
				p.SetState(4527)
				p.PropertyClause()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementScopeContext is an interface to support dynamic dispatch.
type IStatementScopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GLOBAL() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	LOCAL() antlr.TerminalNode

	// IsStatementScopeContext differentiates from other interfaces.
	IsStatementScopeContext()
}

type StatementScopeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementScopeContext() *StatementScopeContext {
	var p = new(StatementScopeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_statementScope
	return p
}

func InitEmptyStatementScopeContext(p *StatementScopeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_statementScope
}

func (*StatementScopeContext) IsStatementScopeContext() {}

func NewStatementScopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementScopeContext {
	var p = new(StatementScopeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_statementScope

	return p
}

func (s *StatementScopeContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementScopeContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *StatementScopeContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION, 0)
}

func (s *StatementScopeContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *StatementScopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementScopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementScopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStatementScope(s)
	}
}

func (s *StatementScopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStatementScope(s)
	}
}

func (p *DorisParser) StatementScope() (localctx IStatementScopeContext) {
	localctx = NewStatementScopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, DorisParserRULE_statementScope)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4532)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserGLOBAL || _la == DorisParserLOCAL || _la == DorisParserSESSION) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBuildModeContext is an interface to support dynamic dispatch.
type IBuildModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BUILD() antlr.TerminalNode
	IMMEDIATE() antlr.TerminalNode
	DEFERRED() antlr.TerminalNode

	// IsBuildModeContext differentiates from other interfaces.
	IsBuildModeContext()
}

type BuildModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBuildModeContext() *BuildModeContext {
	var p = new(BuildModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_buildMode
	return p
}

func InitEmptyBuildModeContext(p *BuildModeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_buildMode
}

func (*BuildModeContext) IsBuildModeContext() {}

func NewBuildModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BuildModeContext {
	var p = new(BuildModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_buildMode

	return p
}

func (s *BuildModeContext) GetParser() antlr.Parser { return s.parser }

func (s *BuildModeContext) BUILD() antlr.TerminalNode {
	return s.GetToken(DorisParserBUILD, 0)
}

func (s *BuildModeContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(DorisParserIMMEDIATE, 0)
}

func (s *BuildModeContext) DEFERRED() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFERRED, 0)
}

func (s *BuildModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BuildModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BuildModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBuildMode(s)
	}
}

func (s *BuildModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBuildMode(s)
	}
}

func (p *DorisParser) BuildMode() (localctx IBuildModeContext) {
	localctx = NewBuildModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, DorisParserRULE_buildMode)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4534)
		p.Match(DorisParserBUILD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4535)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserDEFERRED || _la == DorisParserIMMEDIATE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshTriggerContext is an interface to support dynamic dispatch.
type IRefreshTriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	MANUAL() antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	RefreshSchedule() IRefreshScheduleContext
	COMMIT() antlr.TerminalNode

	// IsRefreshTriggerContext differentiates from other interfaces.
	IsRefreshTriggerContext()
}

type RefreshTriggerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefreshTriggerContext() *RefreshTriggerContext {
	var p = new(RefreshTriggerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_refreshTrigger
	return p
}

func InitEmptyRefreshTriggerContext(p *RefreshTriggerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_refreshTrigger
}

func (*RefreshTriggerContext) IsRefreshTriggerContext() {}

func NewRefreshTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshTriggerContext {
	var p = new(RefreshTriggerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_refreshTrigger

	return p
}

func (s *RefreshTriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshTriggerContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *RefreshTriggerContext) MANUAL() antlr.TerminalNode {
	return s.GetToken(DorisParserMANUAL, 0)
}

func (s *RefreshTriggerContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEDULE, 0)
}

func (s *RefreshTriggerContext) RefreshSchedule() IRefreshScheduleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshScheduleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshScheduleContext)
}

func (s *RefreshTriggerContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMIT, 0)
}

func (s *RefreshTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshTriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRefreshTrigger(s)
	}
}

func (s *RefreshTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRefreshTrigger(s)
	}
}

func (p *DorisParser) RefreshTrigger() (localctx IRefreshTriggerContext) {
	localctx = NewRefreshTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, DorisParserRULE_refreshTrigger)
	p.SetState(4544)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 645, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4537)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4538)
			p.Match(DorisParserMANUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4539)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4540)
			p.Match(DorisParserSCHEDULE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4541)
			p.RefreshSchedule()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4542)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4543)
			p.Match(DorisParserCOMMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshScheduleContext is an interface to support dynamic dispatch.
type IRefreshScheduleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRefreshUnit returns the refreshUnit rule contexts.
	GetRefreshUnit() IIdentifierContext

	// SetRefreshUnit sets the refreshUnit rule contexts.
	SetRefreshUnit(IIdentifierContext)

	// Getter signatures
	EVERY() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	Identifier() IIdentifierContext
	STARTS() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsRefreshScheduleContext differentiates from other interfaces.
	IsRefreshScheduleContext()
}

type RefreshScheduleContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	refreshUnit IIdentifierContext
}

func NewEmptyRefreshScheduleContext() *RefreshScheduleContext {
	var p = new(RefreshScheduleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_refreshSchedule
	return p
}

func InitEmptyRefreshScheduleContext(p *RefreshScheduleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_refreshSchedule
}

func (*RefreshScheduleContext) IsRefreshScheduleContext() {}

func NewRefreshScheduleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshScheduleContext {
	var p = new(RefreshScheduleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_refreshSchedule

	return p
}

func (s *RefreshScheduleContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshScheduleContext) GetRefreshUnit() IIdentifierContext { return s.refreshUnit }

func (s *RefreshScheduleContext) SetRefreshUnit(v IIdentifierContext) { s.refreshUnit = v }

func (s *RefreshScheduleContext) EVERY() antlr.TerminalNode {
	return s.GetToken(DorisParserEVERY, 0)
}

func (s *RefreshScheduleContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *RefreshScheduleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RefreshScheduleContext) STARTS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTARTS, 0)
}

func (s *RefreshScheduleContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *RefreshScheduleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshScheduleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshScheduleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRefreshSchedule(s)
	}
}

func (s *RefreshScheduleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRefreshSchedule(s)
	}
}

func (p *DorisParser) RefreshSchedule() (localctx IRefreshScheduleContext) {
	localctx = NewRefreshScheduleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, DorisParserRULE_refreshSchedule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4546)
		p.Match(DorisParserEVERY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4547)
		p.Match(DorisParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4548)

		var _x = p.Identifier()

		localctx.(*RefreshScheduleContext).refreshUnit = _x
	}
	p.SetState(4551)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserSTARTS {
		{
			p.SetState(4549)
			p.Match(DorisParserSTARTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4550)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshMethodContext is an interface to support dynamic dispatch.
type IRefreshMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMPLETE() antlr.TerminalNode
	AUTO() antlr.TerminalNode

	// IsRefreshMethodContext differentiates from other interfaces.
	IsRefreshMethodContext()
}

type RefreshMethodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefreshMethodContext() *RefreshMethodContext {
	var p = new(RefreshMethodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_refreshMethod
	return p
}

func InitEmptyRefreshMethodContext(p *RefreshMethodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_refreshMethod
}

func (*RefreshMethodContext) IsRefreshMethodContext() {}

func NewRefreshMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshMethodContext {
	var p = new(RefreshMethodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_refreshMethod

	return p
}

func (s *RefreshMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshMethodContext) COMPLETE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPLETE, 0)
}

func (s *RefreshMethodContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO, 0)
}

func (s *RefreshMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshMethodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRefreshMethod(s)
	}
}

func (s *RefreshMethodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRefreshMethod(s)
	}
}

func (p *DorisParser) RefreshMethod() (localctx IRefreshMethodContext) {
	localctx = NewRefreshMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, DorisParserRULE_refreshMethod)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4553)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserAUTO || _la == DorisParserCOMPLETE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMvPartitionContext is an interface to support dynamic dispatch.
type IMvPartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionKey returns the partitionKey rule contexts.
	GetPartitionKey() IIdentifierContext

	// GetPartitionExpr returns the partitionExpr rule contexts.
	GetPartitionExpr() IFunctionCallExpressionContext

	// SetPartitionKey sets the partitionKey rule contexts.
	SetPartitionKey(IIdentifierContext)

	// SetPartitionExpr sets the partitionExpr rule contexts.
	SetPartitionExpr(IFunctionCallExpressionContext)

	// Getter signatures
	Identifier() IIdentifierContext
	FunctionCallExpression() IFunctionCallExpressionContext

	// IsMvPartitionContext differentiates from other interfaces.
	IsMvPartitionContext()
}

type MvPartitionContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	partitionKey  IIdentifierContext
	partitionExpr IFunctionCallExpressionContext
}

func NewEmptyMvPartitionContext() *MvPartitionContext {
	var p = new(MvPartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_mvPartition
	return p
}

func InitEmptyMvPartitionContext(p *MvPartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_mvPartition
}

func (*MvPartitionContext) IsMvPartitionContext() {}

func NewMvPartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MvPartitionContext {
	var p = new(MvPartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_mvPartition

	return p
}

func (s *MvPartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *MvPartitionContext) GetPartitionKey() IIdentifierContext { return s.partitionKey }

func (s *MvPartitionContext) GetPartitionExpr() IFunctionCallExpressionContext {
	return s.partitionExpr
}

func (s *MvPartitionContext) SetPartitionKey(v IIdentifierContext) { s.partitionKey = v }

func (s *MvPartitionContext) SetPartitionExpr(v IFunctionCallExpressionContext) { s.partitionExpr = v }

func (s *MvPartitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MvPartitionContext) FunctionCallExpression() IFunctionCallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallExpressionContext)
}

func (s *MvPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MvPartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MvPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMvPartition(s)
	}
}

func (s *MvPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMvPartition(s)
	}
}

func (p *DorisParser) MvPartition() (localctx IMvPartitionContext) {
	localctx = NewMvPartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, DorisParserRULE_mvPartition)
	p.SetState(4557)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 647, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4555)

			var _x = p.Identifier()

			localctx.(*MvPartitionContext).partitionKey = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4556)

			var _x = p.FunctionCallExpression()

			localctx.(*MvPartitionContext).partitionExpr = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrTextContext is an interface to support dynamic dispatch.
type IIdentifierOrTextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	STRING_LITERAL() antlr.TerminalNode

	// IsIdentifierOrTextContext differentiates from other interfaces.
	IsIdentifierOrTextContext()
}

type IdentifierOrTextContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrTextContext() *IdentifierOrTextContext {
	var p = new(IdentifierOrTextContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierOrText
	return p
}

func InitEmptyIdentifierOrTextContext(p *IdentifierOrTextContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierOrText
}

func (*IdentifierOrTextContext) IsIdentifierOrTextContext() {}

func NewIdentifierOrTextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrTextContext {
	var p = new(IdentifierOrTextContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_identifierOrText

	return p
}

func (s *IdentifierOrTextContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrTextContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierOrTextContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *IdentifierOrTextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrTextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrTextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIdentifierOrText(s)
	}
}

func (s *IdentifierOrTextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIdentifierOrText(s)
	}
}

func (p *DorisParser) IdentifierOrText() (localctx IIdentifierOrTextContext) {
	localctx = NewIdentifierOrTextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, DorisParserRULE_identifierOrText)
	p.SetState(4561)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4559)
			p.Identifier()
		}

	case DorisParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4560)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrTextOrAsteriskContext is an interface to support dynamic dispatch.
type IIdentifierOrTextOrAsteriskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	STRING_LITERAL() antlr.TerminalNode
	ASTERISK() antlr.TerminalNode

	// IsIdentifierOrTextOrAsteriskContext differentiates from other interfaces.
	IsIdentifierOrTextOrAsteriskContext()
}

type IdentifierOrTextOrAsteriskContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrTextOrAsteriskContext() *IdentifierOrTextOrAsteriskContext {
	var p = new(IdentifierOrTextOrAsteriskContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierOrTextOrAsterisk
	return p
}

func InitEmptyIdentifierOrTextOrAsteriskContext(p *IdentifierOrTextOrAsteriskContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierOrTextOrAsterisk
}

func (*IdentifierOrTextOrAsteriskContext) IsIdentifierOrTextOrAsteriskContext() {}

func NewIdentifierOrTextOrAsteriskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrTextOrAsteriskContext {
	var p = new(IdentifierOrTextOrAsteriskContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_identifierOrTextOrAsterisk

	return p
}

func (s *IdentifierOrTextOrAsteriskContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrTextOrAsteriskContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierOrTextOrAsteriskContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *IdentifierOrTextOrAsteriskContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserASTERISK, 0)
}

func (s *IdentifierOrTextOrAsteriskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrTextOrAsteriskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrTextOrAsteriskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIdentifierOrTextOrAsterisk(s)
	}
}

func (s *IdentifierOrTextOrAsteriskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIdentifierOrTextOrAsterisk(s)
	}
}

func (p *DorisParser) IdentifierOrTextOrAsterisk() (localctx IIdentifierOrTextOrAsteriskContext) {
	localctx = NewIdentifierOrTextOrAsteriskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, DorisParserRULE_identifierOrTextOrAsterisk)
	p.SetState(4566)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4563)
			p.Identifier()
		}

	case DorisParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4564)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserASTERISK:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4565)
			p.Match(DorisParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultipartIdentifierOrAsteriskContext is an interface to support dynamic dispatch.
type IMultipartIdentifierOrAsteriskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_identifierOrAsterisk returns the _identifierOrAsterisk rule contexts.
	Get_identifierOrAsterisk() IIdentifierOrAsteriskContext

	// Set_identifierOrAsterisk sets the _identifierOrAsterisk rule contexts.
	Set_identifierOrAsterisk(IIdentifierOrAsteriskContext)

	// GetParts returns the parts rule context list.
	GetParts() []IIdentifierOrAsteriskContext

	// SetParts sets the parts rule context list.
	SetParts([]IIdentifierOrAsteriskContext)

	// Getter signatures
	AllIdentifierOrAsterisk() []IIdentifierOrAsteriskContext
	IdentifierOrAsterisk(i int) IIdentifierOrAsteriskContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsMultipartIdentifierOrAsteriskContext differentiates from other interfaces.
	IsMultipartIdentifierOrAsteriskContext()
}

type MultipartIdentifierOrAsteriskContext struct {
	antlr.BaseParserRuleContext
	parser                antlr.Parser
	_identifierOrAsterisk IIdentifierOrAsteriskContext
	parts                 []IIdentifierOrAsteriskContext
}

func NewEmptyMultipartIdentifierOrAsteriskContext() *MultipartIdentifierOrAsteriskContext {
	var p = new(MultipartIdentifierOrAsteriskContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_multipartIdentifierOrAsterisk
	return p
}

func InitEmptyMultipartIdentifierOrAsteriskContext(p *MultipartIdentifierOrAsteriskContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_multipartIdentifierOrAsterisk
}

func (*MultipartIdentifierOrAsteriskContext) IsMultipartIdentifierOrAsteriskContext() {}

func NewMultipartIdentifierOrAsteriskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipartIdentifierOrAsteriskContext {
	var p = new(MultipartIdentifierOrAsteriskContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_multipartIdentifierOrAsterisk

	return p
}

func (s *MultipartIdentifierOrAsteriskContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipartIdentifierOrAsteriskContext) Get_identifierOrAsterisk() IIdentifierOrAsteriskContext {
	return s._identifierOrAsterisk
}

func (s *MultipartIdentifierOrAsteriskContext) Set_identifierOrAsterisk(v IIdentifierOrAsteriskContext) {
	s._identifierOrAsterisk = v
}

func (s *MultipartIdentifierOrAsteriskContext) GetParts() []IIdentifierOrAsteriskContext {
	return s.parts
}

func (s *MultipartIdentifierOrAsteriskContext) SetParts(v []IIdentifierOrAsteriskContext) {
	s.parts = v
}

func (s *MultipartIdentifierOrAsteriskContext) AllIdentifierOrAsterisk() []IIdentifierOrAsteriskContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrAsteriskContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrAsteriskContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrAsteriskContext); ok {
			tst[i] = t.(IIdentifierOrAsteriskContext)
			i++
		}
	}

	return tst
}

func (s *MultipartIdentifierOrAsteriskContext) IdentifierOrAsterisk(i int) IIdentifierOrAsteriskContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrAsteriskContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrAsteriskContext)
}

func (s *MultipartIdentifierOrAsteriskContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(DorisParserDOT)
}

func (s *MultipartIdentifierOrAsteriskContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, i)
}

func (s *MultipartIdentifierOrAsteriskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipartIdentifierOrAsteriskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipartIdentifierOrAsteriskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMultipartIdentifierOrAsterisk(s)
	}
}

func (s *MultipartIdentifierOrAsteriskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMultipartIdentifierOrAsterisk(s)
	}
}

func (p *DorisParser) MultipartIdentifierOrAsterisk() (localctx IMultipartIdentifierOrAsteriskContext) {
	localctx = NewMultipartIdentifierOrAsteriskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, DorisParserRULE_multipartIdentifierOrAsterisk)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4568)

		var _x = p.IdentifierOrAsterisk()

		localctx.(*MultipartIdentifierOrAsteriskContext)._identifierOrAsterisk = _x
	}
	localctx.(*MultipartIdentifierOrAsteriskContext).parts = append(localctx.(*MultipartIdentifierOrAsteriskContext).parts, localctx.(*MultipartIdentifierOrAsteriskContext)._identifierOrAsterisk)
	p.SetState(4573)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserDOT {
		{
			p.SetState(4569)
			p.Match(DorisParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4570)

			var _x = p.IdentifierOrAsterisk()

			localctx.(*MultipartIdentifierOrAsteriskContext)._identifierOrAsterisk = _x
		}
		localctx.(*MultipartIdentifierOrAsteriskContext).parts = append(localctx.(*MultipartIdentifierOrAsteriskContext).parts, localctx.(*MultipartIdentifierOrAsteriskContext)._identifierOrAsterisk)

		p.SetState(4575)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrAsteriskContext is an interface to support dynamic dispatch.
type IIdentifierOrAsteriskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierOrText() IIdentifierOrTextContext
	ASTERISK() antlr.TerminalNode

	// IsIdentifierOrAsteriskContext differentiates from other interfaces.
	IsIdentifierOrAsteriskContext()
}

type IdentifierOrAsteriskContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrAsteriskContext() *IdentifierOrAsteriskContext {
	var p = new(IdentifierOrAsteriskContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierOrAsterisk
	return p
}

func InitEmptyIdentifierOrAsteriskContext(p *IdentifierOrAsteriskContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierOrAsterisk
}

func (*IdentifierOrAsteriskContext) IsIdentifierOrAsteriskContext() {}

func NewIdentifierOrAsteriskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrAsteriskContext {
	var p = new(IdentifierOrAsteriskContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_identifierOrAsterisk

	return p
}

func (s *IdentifierOrAsteriskContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrAsteriskContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *IdentifierOrAsteriskContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserASTERISK, 0)
}

func (s *IdentifierOrAsteriskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrAsteriskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrAsteriskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIdentifierOrAsterisk(s)
	}
}

func (s *IdentifierOrAsteriskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIdentifierOrAsterisk(s)
	}
}

func (p *DorisParser) IdentifierOrAsterisk() (localctx IIdentifierOrAsteriskContext) {
	localctx = NewIdentifierOrAsteriskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, DorisParserRULE_identifierOrAsterisk)
	p.SetState(4578)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4576)
			p.IdentifierOrText()
		}

	case DorisParserASTERISK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4577)
			p.Match(DorisParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserIdentifyContext is an interface to support dynamic dispatch.
type IUserIdentifyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUser returns the user rule contexts.
	GetUser() IIdentifierOrTextContext

	// GetHost returns the host rule contexts.
	GetHost() IIdentifierOrTextContext

	// SetUser sets the user rule contexts.
	SetUser(IIdentifierOrTextContext)

	// SetHost sets the host rule contexts.
	SetHost(IIdentifierOrTextContext)

	// Getter signatures
	AllIdentifierOrText() []IIdentifierOrTextContext
	IdentifierOrText(i int) IIdentifierOrTextContext
	ATSIGN() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode

	// IsUserIdentifyContext differentiates from other interfaces.
	IsUserIdentifyContext()
}

type UserIdentifyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	user   IIdentifierOrTextContext
	host   IIdentifierOrTextContext
}

func NewEmptyUserIdentifyContext() *UserIdentifyContext {
	var p = new(UserIdentifyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_userIdentify
	return p
}

func InitEmptyUserIdentifyContext(p *UserIdentifyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_userIdentify
}

func (*UserIdentifyContext) IsUserIdentifyContext() {}

func NewUserIdentifyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserIdentifyContext {
	var p = new(UserIdentifyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_userIdentify

	return p
}

func (s *UserIdentifyContext) GetParser() antlr.Parser { return s.parser }

func (s *UserIdentifyContext) GetUser() IIdentifierOrTextContext { return s.user }

func (s *UserIdentifyContext) GetHost() IIdentifierOrTextContext { return s.host }

func (s *UserIdentifyContext) SetUser(v IIdentifierOrTextContext) { s.user = v }

func (s *UserIdentifyContext) SetHost(v IIdentifierOrTextContext) { s.host = v }

func (s *UserIdentifyContext) AllIdentifierOrText() []IIdentifierOrTextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrTextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrTextContext); ok {
			tst[i] = t.(IIdentifierOrTextContext)
			i++
		}
	}

	return tst
}

func (s *UserIdentifyContext) IdentifierOrText(i int) IIdentifierOrTextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *UserIdentifyContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserATSIGN, 0)
}

func (s *UserIdentifyContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *UserIdentifyContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *UserIdentifyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserIdentifyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserIdentifyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUserIdentify(s)
	}
}

func (s *UserIdentifyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUserIdentify(s)
	}
}

func (p *DorisParser) UserIdentify() (localctx IUserIdentifyContext) {
	localctx = NewUserIdentifyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, DorisParserRULE_userIdentify)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4580)

		var _x = p.IdentifierOrText()

		localctx.(*UserIdentifyContext).user = _x
	}
	p.SetState(4589)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserATSIGN {
		{
			p.SetState(4581)
			p.Match(DorisParserATSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4587)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserSTRING_LITERAL, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(4582)

				var _x = p.IdentifierOrText()

				localctx.(*UserIdentifyContext).host = _x
			}

		case DorisParserLEFT_PAREN:
			{
				p.SetState(4583)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4584)

				var _x = p.IdentifierOrText()

				localctx.(*UserIdentifyContext).host = _x
			}
			{
				p.SetState(4585)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantUserIdentifyContext is an interface to support dynamic dispatch.
type IGrantUserIdentifyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserIdentify() IUserIdentifyContext
	IDENTIFIED() antlr.TerminalNode
	BY() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode

	// IsGrantUserIdentifyContext differentiates from other interfaces.
	IsGrantUserIdentifyContext()
}

type GrantUserIdentifyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantUserIdentifyContext() *GrantUserIdentifyContext {
	var p = new(GrantUserIdentifyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_grantUserIdentify
	return p
}

func InitEmptyGrantUserIdentifyContext(p *GrantUserIdentifyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_grantUserIdentify
}

func (*GrantUserIdentifyContext) IsGrantUserIdentifyContext() {}

func NewGrantUserIdentifyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantUserIdentifyContext {
	var p = new(GrantUserIdentifyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_grantUserIdentify

	return p
}

func (s *GrantUserIdentifyContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantUserIdentifyContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *GrantUserIdentifyContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(DorisParserIDENTIFIED, 0)
}

func (s *GrantUserIdentifyContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *GrantUserIdentifyContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *GrantUserIdentifyContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD, 0)
}

func (s *GrantUserIdentifyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantUserIdentifyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantUserIdentifyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterGrantUserIdentify(s)
	}
}

func (s *GrantUserIdentifyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitGrantUserIdentify(s)
	}
}

func (p *DorisParser) GrantUserIdentify() (localctx IGrantUserIdentifyContext) {
	localctx = NewGrantUserIdentifyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, DorisParserRULE_grantUserIdentify)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4591)
		p.UserIdentify()
	}
	p.SetState(4598)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserIDENTIFIED {
		{
			p.SetState(4592)
			p.Match(DorisParserIDENTIFIED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4593)
			p.Match(DorisParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4595)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserPASSWORD {
			{
				p.SetState(4594)
				p.Match(DorisParserPASSWORD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4597)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplainContext is an interface to support dynamic dispatch.
type IExplainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLevel returns the level token.
	GetLevel() antlr.Token

	// SetLevel sets the level token.
	SetLevel(antlr.Token)

	// Getter signatures
	ExplainCommand() IExplainCommandContext
	PlanType() IPlanTypeContext
	PROCESS() antlr.TerminalNode
	VERBOSE() antlr.TerminalNode
	TREE() antlr.TerminalNode
	GRAPH() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	DUMP() antlr.TerminalNode

	// IsExplainContext differentiates from other interfaces.
	IsExplainContext()
}

type ExplainContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	level  antlr.Token
}

func NewEmptyExplainContext() *ExplainContext {
	var p = new(ExplainContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_explain
	return p
}

func InitEmptyExplainContext(p *ExplainContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_explain
}

func (*ExplainContext) IsExplainContext() {}

func NewExplainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainContext {
	var p = new(ExplainContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_explain

	return p
}

func (s *ExplainContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainContext) GetLevel() antlr.Token { return s.level }

func (s *ExplainContext) SetLevel(v antlr.Token) { s.level = v }

func (s *ExplainContext) ExplainCommand() IExplainCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainCommandContext)
}

func (s *ExplainContext) PlanType() IPlanTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPlanTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPlanTypeContext)
}

func (s *ExplainContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(DorisParserPROCESS, 0)
}

func (s *ExplainContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserVERBOSE, 0)
}

func (s *ExplainContext) TREE() antlr.TerminalNode {
	return s.GetToken(DorisParserTREE, 0)
}

func (s *ExplainContext) GRAPH() antlr.TerminalNode {
	return s.GetToken(DorisParserGRAPH, 0)
}

func (s *ExplainContext) PLAN() antlr.TerminalNode {
	return s.GetToken(DorisParserPLAN, 0)
}

func (s *ExplainContext) DUMP() antlr.TerminalNode {
	return s.GetToken(DorisParserDUMP, 0)
}

func (s *ExplainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterExplain(s)
	}
}

func (s *ExplainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitExplain(s)
	}
}

func (p *DorisParser) Explain() (localctx IExplainContext) {
	localctx = NewExplainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, DorisParserRULE_explain)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4600)
		p.ExplainCommand()
	}
	p.SetState(4602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserALL || _la == DorisParserANALYZED || _la == DorisParserDISTRIBUTED || ((int64((_la-276)) & ^0x3f) == 0 && ((int64(1)<<(_la-276))&4521191813431297) != 0) || _la == DorisParserPHYSICAL || _la == DorisParserREWRITTEN || _la == DorisParserSHAPE {
		{
			p.SetState(4601)
			p.PlanType()
		}

	}
	p.SetState(4605)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserDUMP || _la == DorisParserGRAPH || _la == DorisParserPLAN || _la == DorisParserTREE || _la == DorisParserVERBOSE {
		{
			p.SetState(4604)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ExplainContext).level = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserDUMP || _la == DorisParserGRAPH || _la == DorisParserPLAN || _la == DorisParserTREE || _la == DorisParserVERBOSE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ExplainContext).level = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(4608)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPROCESS {
		{
			p.SetState(4607)
			p.Match(DorisParserPROCESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplainCommandContext is an interface to support dynamic dispatch.
type IExplainCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXPLAIN() antlr.TerminalNode
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode

	// IsExplainCommandContext differentiates from other interfaces.
	IsExplainCommandContext()
}

type ExplainCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainCommandContext() *ExplainCommandContext {
	var p = new(ExplainCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_explainCommand
	return p
}

func InitEmptyExplainCommandContext(p *ExplainCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_explainCommand
}

func (*ExplainCommandContext) IsExplainCommandContext() {}

func NewExplainCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainCommandContext {
	var p = new(ExplainCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_explainCommand

	return p
}

func (s *ExplainCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainCommandContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(DorisParserEXPLAIN, 0)
}

func (s *ExplainCommandContext) DESC() antlr.TerminalNode {
	return s.GetToken(DorisParserDESC, 0)
}

func (s *ExplainCommandContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(DorisParserDESCRIBE, 0)
}

func (s *ExplainCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplainCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterExplainCommand(s)
	}
}

func (s *ExplainCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitExplainCommand(s)
	}
}

func (p *DorisParser) ExplainCommand() (localctx IExplainCommandContext) {
	localctx = NewExplainCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, DorisParserRULE_explainCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4610)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&1099511627779) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPlanTypeContext is an interface to support dynamic dispatch.
type IPlanTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARSED() antlr.TerminalNode
	ANALYZED() antlr.TerminalNode
	REWRITTEN() antlr.TerminalNode
	LOGICAL() antlr.TerminalNode
	OPTIMIZED() antlr.TerminalNode
	PHYSICAL() antlr.TerminalNode
	SHAPE() antlr.TerminalNode
	MEMO() antlr.TerminalNode
	DISTRIBUTED() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsPlanTypeContext differentiates from other interfaces.
	IsPlanTypeContext()
}

type PlanTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPlanTypeContext() *PlanTypeContext {
	var p = new(PlanTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_planType
	return p
}

func InitEmptyPlanTypeContext(p *PlanTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_planType
}

func (*PlanTypeContext) IsPlanTypeContext() {}

func NewPlanTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PlanTypeContext {
	var p = new(PlanTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_planType

	return p
}

func (s *PlanTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PlanTypeContext) PARSED() antlr.TerminalNode {
	return s.GetToken(DorisParserPARSED, 0)
}

func (s *PlanTypeContext) ANALYZED() antlr.TerminalNode {
	return s.GetToken(DorisParserANALYZED, 0)
}

func (s *PlanTypeContext) REWRITTEN() antlr.TerminalNode {
	return s.GetToken(DorisParserREWRITTEN, 0)
}

func (s *PlanTypeContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOGICAL, 0)
}

func (s *PlanTypeContext) OPTIMIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserOPTIMIZED, 0)
}

func (s *PlanTypeContext) PHYSICAL() antlr.TerminalNode {
	return s.GetToken(DorisParserPHYSICAL, 0)
}

func (s *PlanTypeContext) SHAPE() antlr.TerminalNode {
	return s.GetToken(DorisParserSHAPE, 0)
}

func (s *PlanTypeContext) MEMO() antlr.TerminalNode {
	return s.GetToken(DorisParserMEMO, 0)
}

func (s *PlanTypeContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTRIBUTED, 0)
}

func (s *PlanTypeContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *PlanTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PlanTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PlanTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPlanType(s)
	}
}

func (s *PlanTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPlanType(s)
	}
}

func (p *DorisParser) PlanType() (localctx IPlanTypeContext) {
	localctx = NewPlanTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, DorisParserRULE_planType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4612)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserALL || _la == DorisParserANALYZED || _la == DorisParserDISTRIBUTED || ((int64((_la-276)) & ^0x3f) == 0 && ((int64(1)<<(_la-276))&4521191813431297) != 0) || _la == DorisParserPHYSICAL || _la == DorisParserREWRITTEN || _la == DorisParserSHAPE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplayCommandContext is an interface to support dynamic dispatch.
type IReplayCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLAN() antlr.TerminalNode
	REPLAYER() antlr.TerminalNode
	ReplayType() IReplayTypeContext

	// IsReplayCommandContext differentiates from other interfaces.
	IsReplayCommandContext()
}

type ReplayCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplayCommandContext() *ReplayCommandContext {
	var p = new(ReplayCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_replayCommand
	return p
}

func InitEmptyReplayCommandContext(p *ReplayCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_replayCommand
}

func (*ReplayCommandContext) IsReplayCommandContext() {}

func NewReplayCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplayCommandContext {
	var p = new(ReplayCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_replayCommand

	return p
}

func (s *ReplayCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplayCommandContext) PLAN() antlr.TerminalNode {
	return s.GetToken(DorisParserPLAN, 0)
}

func (s *ReplayCommandContext) REPLAYER() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLAYER, 0)
}

func (s *ReplayCommandContext) ReplayType() IReplayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplayTypeContext)
}

func (s *ReplayCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplayCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplayCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterReplayCommand(s)
	}
}

func (s *ReplayCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitReplayCommand(s)
	}
}

func (p *DorisParser) ReplayCommand() (localctx IReplayCommandContext) {
	localctx = NewReplayCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, DorisParserRULE_replayCommand)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4614)
		p.Match(DorisParserPLAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4615)
		p.Match(DorisParserREPLAYER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4616)
		p.ReplayType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplayTypeContext is an interface to support dynamic dispatch.
type IReplayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFilePath returns the filePath token.
	GetFilePath() antlr.Token

	// SetFilePath sets the filePath token.
	SetFilePath(antlr.Token)

	// Getter signatures
	DUMP() antlr.TerminalNode
	Query() IQueryContext
	PLAY() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsReplayTypeContext differentiates from other interfaces.
	IsReplayTypeContext()
}

type ReplayTypeContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	filePath antlr.Token
}

func NewEmptyReplayTypeContext() *ReplayTypeContext {
	var p = new(ReplayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_replayType
	return p
}

func InitEmptyReplayTypeContext(p *ReplayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_replayType
}

func (*ReplayTypeContext) IsReplayTypeContext() {}

func NewReplayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplayTypeContext {
	var p = new(ReplayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_replayType

	return p
}

func (s *ReplayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplayTypeContext) GetFilePath() antlr.Token { return s.filePath }

func (s *ReplayTypeContext) SetFilePath(v antlr.Token) { s.filePath = v }

func (s *ReplayTypeContext) DUMP() antlr.TerminalNode {
	return s.GetToken(DorisParserDUMP, 0)
}

func (s *ReplayTypeContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *ReplayTypeContext) PLAY() antlr.TerminalNode {
	return s.GetToken(DorisParserPLAY, 0)
}

func (s *ReplayTypeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *ReplayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterReplayType(s)
	}
}

func (s *ReplayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitReplayType(s)
	}
}

func (p *DorisParser) ReplayType() (localctx IReplayTypeContext) {
	localctx = NewReplayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, DorisParserRULE_replayType)
	p.SetState(4622)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserDUMP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4618)
			p.Match(DorisParserDUMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4619)
			p.Query()
		}

	case DorisParserPLAY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4620)
			p.Match(DorisParserPLAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4621)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ReplayTypeContext).filePath = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMergeTypeContext is an interface to support dynamic dispatch.
type IMergeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	APPEND() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	MERGE() antlr.TerminalNode

	// IsMergeTypeContext differentiates from other interfaces.
	IsMergeTypeContext()
}

type MergeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeTypeContext() *MergeTypeContext {
	var p = new(MergeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_mergeType
	return p
}

func InitEmptyMergeTypeContext(p *MergeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_mergeType
}

func (*MergeTypeContext) IsMergeTypeContext() {}

func NewMergeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeTypeContext {
	var p = new(MergeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_mergeType

	return p
}

func (s *MergeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeTypeContext) APPEND() antlr.TerminalNode {
	return s.GetToken(DorisParserAPPEND, 0)
}

func (s *MergeTypeContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisParserDELETE, 0)
}

func (s *MergeTypeContext) MERGE() antlr.TerminalNode {
	return s.GetToken(DorisParserMERGE, 0)
}

func (s *MergeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMergeType(s)
	}
}

func (s *MergeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMergeType(s)
	}
}

func (p *DorisParser) MergeType() (localctx IMergeTypeContext) {
	localctx = NewMergeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, DorisParserRULE_mergeType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4624)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserAPPEND || _la == DorisParserDELETE || _la == DorisParserMERGE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPreFilterClauseContext is an interface to support dynamic dispatch.
type IPreFilterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRECEDING() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	Expression() IExpressionContext

	// IsPreFilterClauseContext differentiates from other interfaces.
	IsPreFilterClauseContext()
}

type PreFilterClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreFilterClauseContext() *PreFilterClauseContext {
	var p = new(PreFilterClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_preFilterClause
	return p
}

func InitEmptyPreFilterClauseContext(p *PreFilterClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_preFilterClause
}

func (*PreFilterClauseContext) IsPreFilterClauseContext() {}

func NewPreFilterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PreFilterClauseContext {
	var p = new(PreFilterClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_preFilterClause

	return p
}

func (s *PreFilterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PreFilterClauseContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(DorisParserPRECEDING, 0)
}

func (s *PreFilterClauseContext) FILTER() antlr.TerminalNode {
	return s.GetToken(DorisParserFILTER, 0)
}

func (s *PreFilterClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PreFilterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreFilterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PreFilterClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPreFilterClause(s)
	}
}

func (s *PreFilterClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPreFilterClause(s)
	}
}

func (p *DorisParser) PreFilterClause() (localctx IPreFilterClauseContext) {
	localctx = NewPreFilterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, DorisParserRULE_preFilterClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4626)
		p.Match(DorisParserPRECEDING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4627)
		p.Match(DorisParserFILTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4628)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteOnClauseContext is an interface to support dynamic dispatch.
type IDeleteOnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	ON() antlr.TerminalNode
	Expression() IExpressionContext

	// IsDeleteOnClauseContext differentiates from other interfaces.
	IsDeleteOnClauseContext()
}

type DeleteOnClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteOnClauseContext() *DeleteOnClauseContext {
	var p = new(DeleteOnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_deleteOnClause
	return p
}

func InitEmptyDeleteOnClauseContext(p *DeleteOnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_deleteOnClause
}

func (*DeleteOnClauseContext) IsDeleteOnClauseContext() {}

func NewDeleteOnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteOnClauseContext {
	var p = new(DeleteOnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_deleteOnClause

	return p
}

func (s *DeleteOnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteOnClauseContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisParserDELETE, 0)
}

func (s *DeleteOnClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *DeleteOnClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DeleteOnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteOnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteOnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDeleteOnClause(s)
	}
}

func (s *DeleteOnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDeleteOnClause(s)
	}
}

func (p *DorisParser) DeleteOnClause() (localctx IDeleteOnClauseContext) {
	localctx = NewDeleteOnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, DorisParserRULE_deleteOnClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4630)
		p.Match(DorisParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4631)
		p.Match(DorisParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4632)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISequenceColClauseContext is an interface to support dynamic dispatch.
type ISequenceColClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsSequenceColClauseContext differentiates from other interfaces.
	IsSequenceColClauseContext()
}

type SequenceColClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequenceColClauseContext() *SequenceColClauseContext {
	var p = new(SequenceColClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sequenceColClause
	return p
}

func InitEmptySequenceColClauseContext(p *SequenceColClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sequenceColClause
}

func (*SequenceColClauseContext) IsSequenceColClauseContext() {}

func NewSequenceColClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SequenceColClauseContext {
	var p = new(SequenceColClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_sequenceColClause

	return p
}

func (s *SequenceColClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SequenceColClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisParserORDER, 0)
}

func (s *SequenceColClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *SequenceColClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SequenceColClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SequenceColClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SequenceColClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSequenceColClause(s)
	}
}

func (s *SequenceColClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSequenceColClause(s)
	}
}

func (p *DorisParser) SequenceColClause() (localctx ISequenceColClauseContext) {
	localctx = NewSequenceColClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, DorisParserRULE_sequenceColClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4634)
		p.Match(DorisParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4635)
		p.Match(DorisParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4636)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColFromPathContext is an interface to support dynamic dispatch.
type IColFromPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLUMNS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	PATH() antlr.TerminalNode
	AS() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsColFromPathContext differentiates from other interfaces.
	IsColFromPathContext()
}

type ColFromPathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColFromPathContext() *ColFromPathContext {
	var p = new(ColFromPathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_colFromPath
	return p
}

func InitEmptyColFromPathContext(p *ColFromPathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_colFromPath
}

func (*ColFromPathContext) IsColFromPathContext() {}

func NewColFromPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColFromPathContext {
	var p = new(ColFromPathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_colFromPath

	return p
}

func (s *ColFromPathContext) GetParser() antlr.Parser { return s.parser }

func (s *ColFromPathContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMNS, 0)
}

func (s *ColFromPathContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ColFromPathContext) PATH() antlr.TerminalNode {
	return s.GetToken(DorisParserPATH, 0)
}

func (s *ColFromPathContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *ColFromPathContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ColFromPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColFromPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColFromPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterColFromPath(s)
	}
}

func (s *ColFromPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitColFromPath(s)
	}
}

func (p *DorisParser) ColFromPath() (localctx IColFromPathContext) {
	localctx = NewColFromPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, DorisParserRULE_colFromPath)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4638)
		p.Match(DorisParserCOLUMNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4639)
		p.Match(DorisParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4640)
		p.Match(DorisParserPATH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4641)
		p.Match(DorisParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4642)
		p.IdentifierList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColMappingListContext is an interface to support dynamic dispatch.
type IColMappingListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_mappingExpr returns the _mappingExpr rule contexts.
	Get_mappingExpr() IMappingExprContext

	// Set_mappingExpr sets the _mappingExpr rule contexts.
	Set_mappingExpr(IMappingExprContext)

	// GetMappingSet returns the mappingSet rule context list.
	GetMappingSet() []IMappingExprContext

	// SetMappingSet sets the mappingSet rule context list.
	SetMappingSet([]IMappingExprContext)

	// Getter signatures
	SET() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllMappingExpr() []IMappingExprContext
	MappingExpr(i int) IMappingExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColMappingListContext differentiates from other interfaces.
	IsColMappingListContext()
}

type ColMappingListContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	_mappingExpr IMappingExprContext
	mappingSet   []IMappingExprContext
}

func NewEmptyColMappingListContext() *ColMappingListContext {
	var p = new(ColMappingListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_colMappingList
	return p
}

func InitEmptyColMappingListContext(p *ColMappingListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_colMappingList
}

func (*ColMappingListContext) IsColMappingListContext() {}

func NewColMappingListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColMappingListContext {
	var p = new(ColMappingListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_colMappingList

	return p
}

func (s *ColMappingListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColMappingListContext) Get_mappingExpr() IMappingExprContext { return s._mappingExpr }

func (s *ColMappingListContext) Set_mappingExpr(v IMappingExprContext) { s._mappingExpr = v }

func (s *ColMappingListContext) GetMappingSet() []IMappingExprContext { return s.mappingSet }

func (s *ColMappingListContext) SetMappingSet(v []IMappingExprContext) { s.mappingSet = v }

func (s *ColMappingListContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserSET, 0)
}

func (s *ColMappingListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ColMappingListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ColMappingListContext) AllMappingExpr() []IMappingExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMappingExprContext); ok {
			len++
		}
	}

	tst := make([]IMappingExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMappingExprContext); ok {
			tst[i] = t.(IMappingExprContext)
			i++
		}
	}

	return tst
}

func (s *ColMappingListContext) MappingExpr(i int) IMappingExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMappingExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMappingExprContext)
}

func (s *ColMappingListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ColMappingListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ColMappingListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColMappingListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColMappingListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterColMappingList(s)
	}
}

func (s *ColMappingListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitColMappingList(s)
	}
}

func (p *DorisParser) ColMappingList() (localctx IColMappingListContext) {
	localctx = NewColMappingListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, DorisParserRULE_colMappingList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4644)
		p.Match(DorisParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4645)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4646)

		var _x = p.MappingExpr()

		localctx.(*ColMappingListContext)._mappingExpr = _x
	}
	localctx.(*ColMappingListContext).mappingSet = append(localctx.(*ColMappingListContext).mappingSet, localctx.(*ColMappingListContext)._mappingExpr)
	p.SetState(4651)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(4647)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4648)

			var _x = p.MappingExpr()

			localctx.(*ColMappingListContext)._mappingExpr = _x
		}
		localctx.(*ColMappingListContext).mappingSet = append(localctx.(*ColMappingListContext).mappingSet, localctx.(*ColMappingListContext)._mappingExpr)

		p.SetState(4653)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4654)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMappingExprContext is an interface to support dynamic dispatch.
type IMappingExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMappingCol returns the mappingCol rule contexts.
	GetMappingCol() IIdentifierContext

	// SetMappingCol sets the mappingCol rule contexts.
	SetMappingCol(IIdentifierContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	Expression() IExpressionContext
	Identifier() IIdentifierContext

	// IsMappingExprContext differentiates from other interfaces.
	IsMappingExprContext()
}

type MappingExprContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	mappingCol IIdentifierContext
}

func NewEmptyMappingExprContext() *MappingExprContext {
	var p = new(MappingExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_mappingExpr
	return p
}

func InitEmptyMappingExprContext(p *MappingExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_mappingExpr
}

func (*MappingExprContext) IsMappingExprContext() {}

func NewMappingExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MappingExprContext {
	var p = new(MappingExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_mappingExpr

	return p
}

func (s *MappingExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MappingExprContext) GetMappingCol() IIdentifierContext { return s.mappingCol }

func (s *MappingExprContext) SetMappingCol(v IIdentifierContext) { s.mappingCol = v }

func (s *MappingExprContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *MappingExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MappingExprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MappingExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MappingExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MappingExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMappingExpr(s)
	}
}

func (s *MappingExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMappingExpr(s)
	}
}

func (p *DorisParser) MappingExpr() (localctx IMappingExprContext) {
	localctx = NewMappingExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, DorisParserRULE_mappingExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4656)

		var _x = p.Identifier()

		localctx.(*MappingExprContext).mappingCol = _x
	}
	{
		p.SetState(4657)
		p.Match(DorisParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4658)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithRemoteStorageSystemContext is an interface to support dynamic dispatch.
type IWithRemoteStorageSystemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBrokerProperties returns the brokerProperties rule contexts.
	GetBrokerProperties() IPropertyItemListContext

	// GetBrokerName returns the brokerName rule contexts.
	GetBrokerName() IIdentifierOrTextContext

	// SetBrokerProperties sets the brokerProperties rule contexts.
	SetBrokerProperties(IPropertyItemListContext)

	// SetBrokerName sets the brokerName rule contexts.
	SetBrokerName(IIdentifierOrTextContext)

	// Getter signatures
	ResourceDesc() IResourceDescContext
	WITH() antlr.TerminalNode
	S3() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	PropertyItemList() IPropertyItemListContext
	HDFS() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	IdentifierOrText() IIdentifierOrTextContext

	// IsWithRemoteStorageSystemContext differentiates from other interfaces.
	IsWithRemoteStorageSystemContext()
}

type WithRemoteStorageSystemContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	brokerProperties IPropertyItemListContext
	brokerName       IIdentifierOrTextContext
}

func NewEmptyWithRemoteStorageSystemContext() *WithRemoteStorageSystemContext {
	var p = new(WithRemoteStorageSystemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_withRemoteStorageSystem
	return p
}

func InitEmptyWithRemoteStorageSystemContext(p *WithRemoteStorageSystemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_withRemoteStorageSystem
}

func (*WithRemoteStorageSystemContext) IsWithRemoteStorageSystemContext() {}

func NewWithRemoteStorageSystemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithRemoteStorageSystemContext {
	var p = new(WithRemoteStorageSystemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_withRemoteStorageSystem

	return p
}

func (s *WithRemoteStorageSystemContext) GetParser() antlr.Parser { return s.parser }

func (s *WithRemoteStorageSystemContext) GetBrokerProperties() IPropertyItemListContext {
	return s.brokerProperties
}

func (s *WithRemoteStorageSystemContext) GetBrokerName() IIdentifierOrTextContext {
	return s.brokerName
}

func (s *WithRemoteStorageSystemContext) SetBrokerProperties(v IPropertyItemListContext) {
	s.brokerProperties = v
}

func (s *WithRemoteStorageSystemContext) SetBrokerName(v IIdentifierOrTextContext) { s.brokerName = v }

func (s *WithRemoteStorageSystemContext) ResourceDesc() IResourceDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceDescContext)
}

func (s *WithRemoteStorageSystemContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *WithRemoteStorageSystemContext) S3() antlr.TerminalNode {
	return s.GetToken(DorisParserS3, 0)
}

func (s *WithRemoteStorageSystemContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *WithRemoteStorageSystemContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *WithRemoteStorageSystemContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *WithRemoteStorageSystemContext) HDFS() antlr.TerminalNode {
	return s.GetToken(DorisParserHDFS, 0)
}

func (s *WithRemoteStorageSystemContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *WithRemoteStorageSystemContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserBROKER, 0)
}

func (s *WithRemoteStorageSystemContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *WithRemoteStorageSystemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithRemoteStorageSystemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithRemoteStorageSystemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWithRemoteStorageSystem(s)
	}
}

func (s *WithRemoteStorageSystemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWithRemoteStorageSystem(s)
	}
}

func (p *DorisParser) WithRemoteStorageSystem() (localctx IWithRemoteStorageSystemContext) {
	localctx = NewWithRemoteStorageSystemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, DorisParserRULE_withRemoteStorageSystem)
	var _la int

	p.SetState(4688)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 662, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4660)
			p.ResourceDesc()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4661)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4662)
			p.Match(DorisParserS3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4663)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4664)

			var _x = p.PropertyItemList()

			localctx.(*WithRemoteStorageSystemContext).brokerProperties = _x
		}
		{
			p.SetState(4665)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4667)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4668)
			p.Match(DorisParserHDFS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4669)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4670)

			var _x = p.PropertyItemList()

			localctx.(*WithRemoteStorageSystemContext).brokerProperties = _x
		}
		{
			p.SetState(4671)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4673)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4674)
			p.Match(DorisParserLOCAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4675)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4676)

			var _x = p.PropertyItemList()

			localctx.(*WithRemoteStorageSystemContext).brokerProperties = _x
		}
		{
			p.SetState(4677)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4679)
			p.Match(DorisParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4680)
			p.Match(DorisParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4681)

			var _x = p.IdentifierOrText()

			localctx.(*WithRemoteStorageSystemContext).brokerName = _x
		}
		p.SetState(4686)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(4682)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4683)

				var _x = p.PropertyItemList()

				localctx.(*WithRemoteStorageSystemContext).brokerProperties = _x
			}
			{
				p.SetState(4684)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceDescContext is an interface to support dynamic dispatch.
type IResourceDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResourceName returns the resourceName rule contexts.
	GetResourceName() IIdentifierOrTextContext

	// SetResourceName sets the resourceName rule contexts.
	SetResourceName(IIdentifierOrTextContext)

	// Getter signatures
	WITH() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	IdentifierOrText() IIdentifierOrTextContext
	LEFT_PAREN() antlr.TerminalNode
	PropertyItemList() IPropertyItemListContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsResourceDescContext differentiates from other interfaces.
	IsResourceDescContext()
}

type ResourceDescContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	resourceName IIdentifierOrTextContext
}

func NewEmptyResourceDescContext() *ResourceDescContext {
	var p = new(ResourceDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_resourceDesc
	return p
}

func InitEmptyResourceDescContext(p *ResourceDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_resourceDesc
}

func (*ResourceDescContext) IsResourceDescContext() {}

func NewResourceDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceDescContext {
	var p = new(ResourceDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_resourceDesc

	return p
}

func (s *ResourceDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceDescContext) GetResourceName() IIdentifierOrTextContext { return s.resourceName }

func (s *ResourceDescContext) SetResourceName(v IIdentifierOrTextContext) { s.resourceName = v }

func (s *ResourceDescContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *ResourceDescContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCE, 0)
}

func (s *ResourceDescContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *ResourceDescContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ResourceDescContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *ResourceDescContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ResourceDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterResourceDesc(s)
	}
}

func (s *ResourceDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitResourceDesc(s)
	}
}

func (p *DorisParser) ResourceDesc() (localctx IResourceDescContext) {
	localctx = NewResourceDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, DorisParserRULE_resourceDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4690)
		p.Match(DorisParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4691)
		p.Match(DorisParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4692)

		var _x = p.IdentifierOrText()

		localctx.(*ResourceDescContext).resourceName = _x
	}
	p.SetState(4697)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLEFT_PAREN {
		{
			p.SetState(4693)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4694)
			p.PropertyItemList()
		}
		{
			p.SetState(4695)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMysqlDataDescContext is an interface to support dynamic dispatch.
type IMysqlDataDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFilePath returns the filePath token.
	GetFilePath() antlr.Token

	// GetComma returns the comma token.
	GetComma() antlr.Token

	// GetSeparator returns the separator token.
	GetSeparator() antlr.Token

	// SetFilePath sets the filePath token.
	SetFilePath(antlr.Token)

	// SetComma sets the comma token.
	SetComma(antlr.Token)

	// SetSeparator sets the separator token.
	SetSeparator(antlr.Token)

	// GetTableName returns the tableName rule contexts.
	GetTableName() IMultipartIdentifierContext

	// GetPartition returns the partition rule contexts.
	GetPartition() IIdentifierListContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IIdentifierListContext

	// SetTableName sets the tableName rule contexts.
	SetTableName(IMultipartIdentifierContext)

	// SetPartition sets the partition rule contexts.
	SetPartition(IIdentifierListContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IIdentifierListContext)

	// Getter signatures
	DATA() antlr.TerminalNode
	INFILE() antlr.TerminalNode
	INTO() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext
	LOCAL() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	AllTERMINATED() []antlr.TerminalNode
	TERMINATED(i int) antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	LINES() antlr.TerminalNode
	SkipLines() ISkipLinesContext
	ColMappingList() IColMappingListContext
	PropertyClause() IPropertyClauseContext
	AllIdentifierList() []IIdentifierListContext
	IdentifierList(i int) IIdentifierListContext

	// IsMysqlDataDescContext differentiates from other interfaces.
	IsMysqlDataDescContext()
}

type MysqlDataDescContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	filePath  antlr.Token
	tableName IMultipartIdentifierContext
	partition IIdentifierListContext
	comma     antlr.Token
	separator antlr.Token
	columns   IIdentifierListContext
}

func NewEmptyMysqlDataDescContext() *MysqlDataDescContext {
	var p = new(MysqlDataDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_mysqlDataDesc
	return p
}

func InitEmptyMysqlDataDescContext(p *MysqlDataDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_mysqlDataDesc
}

func (*MysqlDataDescContext) IsMysqlDataDescContext() {}

func NewMysqlDataDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MysqlDataDescContext {
	var p = new(MysqlDataDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_mysqlDataDesc

	return p
}

func (s *MysqlDataDescContext) GetParser() antlr.Parser { return s.parser }

func (s *MysqlDataDescContext) GetFilePath() antlr.Token { return s.filePath }

func (s *MysqlDataDescContext) GetComma() antlr.Token { return s.comma }

func (s *MysqlDataDescContext) GetSeparator() antlr.Token { return s.separator }

func (s *MysqlDataDescContext) SetFilePath(v antlr.Token) { s.filePath = v }

func (s *MysqlDataDescContext) SetComma(v antlr.Token) { s.comma = v }

func (s *MysqlDataDescContext) SetSeparator(v antlr.Token) { s.separator = v }

func (s *MysqlDataDescContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *MysqlDataDescContext) GetPartition() IIdentifierListContext { return s.partition }

func (s *MysqlDataDescContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *MysqlDataDescContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *MysqlDataDescContext) SetPartition(v IIdentifierListContext) { s.partition = v }

func (s *MysqlDataDescContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *MysqlDataDescContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserDATA, 0)
}

func (s *MysqlDataDescContext) INFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserINFILE, 0)
}

func (s *MysqlDataDescContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserINTO, 0)
}

func (s *MysqlDataDescContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLE, 0)
}

func (s *MysqlDataDescContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *MysqlDataDescContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *MysqlDataDescContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *MysqlDataDescContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *MysqlDataDescContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *MysqlDataDescContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMNS, 0)
}

func (s *MysqlDataDescContext) AllTERMINATED() []antlr.TerminalNode {
	return s.GetTokens(DorisParserTERMINATED)
}

func (s *MysqlDataDescContext) TERMINATED(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserTERMINATED, i)
}

func (s *MysqlDataDescContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(DorisParserBY)
}

func (s *MysqlDataDescContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserBY, i)
}

func (s *MysqlDataDescContext) LINES() antlr.TerminalNode {
	return s.GetToken(DorisParserLINES, 0)
}

func (s *MysqlDataDescContext) SkipLines() ISkipLinesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkipLinesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkipLinesContext)
}

func (s *MysqlDataDescContext) ColMappingList() IColMappingListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColMappingListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColMappingListContext)
}

func (s *MysqlDataDescContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *MysqlDataDescContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *MysqlDataDescContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *MysqlDataDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MysqlDataDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MysqlDataDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMysqlDataDesc(s)
	}
}

func (s *MysqlDataDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMysqlDataDesc(s)
	}
}

func (p *DorisParser) MysqlDataDesc() (localctx IMysqlDataDescContext) {
	localctx = NewMysqlDataDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, DorisParserRULE_mysqlDataDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4699)
		p.Match(DorisParserDATA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4701)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLOCAL {
		{
			p.SetState(4700)
			p.Match(DorisParserLOCAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4703)
		p.Match(DorisParserINFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4704)

		var _m = p.Match(DorisParserSTRING_LITERAL)

		localctx.(*MysqlDataDescContext).filePath = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4705)
		p.Match(DorisParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4706)
		p.Match(DorisParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4707)

		var _x = p.MultipartIdentifier()

		localctx.(*MysqlDataDescContext).tableName = _x
	}
	p.SetState(4710)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPARTITION {
		{
			p.SetState(4708)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4709)

			var _x = p.IdentifierList()

			localctx.(*MysqlDataDescContext).partition = _x
		}

	}
	p.SetState(4716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserCOLUMNS {
		{
			p.SetState(4712)
			p.Match(DorisParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4713)
			p.Match(DorisParserTERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4714)
			p.Match(DorisParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4715)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*MysqlDataDescContext).comma = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4722)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLINES {
		{
			p.SetState(4718)
			p.Match(DorisParserLINES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4719)
			p.Match(DorisParserTERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4720)
			p.Match(DorisParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4721)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*MysqlDataDescContext).separator = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4725)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserIGNORE {
		{
			p.SetState(4724)
			p.SkipLines()
		}

	}
	p.SetState(4728)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLEFT_PAREN {
		{
			p.SetState(4727)

			var _x = p.IdentifierList()

			localctx.(*MysqlDataDescContext).columns = _x
		}

	}
	p.SetState(4731)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserSET {
		{
			p.SetState(4730)
			p.ColMappingList()
		}

	}
	p.SetState(4734)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 671, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4733)
			p.PropertyClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISkipLinesContext is an interface to support dynamic dispatch.
type ISkipLinesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLines returns the lines token.
	GetLines() antlr.Token

	// SetLines sets the lines token.
	SetLines(antlr.Token)

	// Getter signatures
	IGNORE() antlr.TerminalNode
	LINES() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	ROWS() antlr.TerminalNode

	// IsSkipLinesContext differentiates from other interfaces.
	IsSkipLinesContext()
}

type SkipLinesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	lines  antlr.Token
}

func NewEmptySkipLinesContext() *SkipLinesContext {
	var p = new(SkipLinesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_skipLines
	return p
}

func InitEmptySkipLinesContext(p *SkipLinesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_skipLines
}

func (*SkipLinesContext) IsSkipLinesContext() {}

func NewSkipLinesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SkipLinesContext {
	var p = new(SkipLinesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_skipLines

	return p
}

func (s *SkipLinesContext) GetParser() antlr.Parser { return s.parser }

func (s *SkipLinesContext) GetLines() antlr.Token { return s.lines }

func (s *SkipLinesContext) SetLines(v antlr.Token) { s.lines = v }

func (s *SkipLinesContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(DorisParserIGNORE, 0)
}

func (s *SkipLinesContext) LINES() antlr.TerminalNode {
	return s.GetToken(DorisParserLINES, 0)
}

func (s *SkipLinesContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *SkipLinesContext) ROWS() antlr.TerminalNode {
	return s.GetToken(DorisParserROWS, 0)
}

func (s *SkipLinesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SkipLinesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SkipLinesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSkipLines(s)
	}
}

func (s *SkipLinesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSkipLines(s)
	}
}

func (p *DorisParser) SkipLines() (localctx ISkipLinesContext) {
	localctx = NewSkipLinesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, DorisParserRULE_skipLines)
	p.SetState(4742)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 672, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4736)
			p.Match(DorisParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4737)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*SkipLinesContext).lines = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4738)
			p.Match(DorisParserLINES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4739)
			p.Match(DorisParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4740)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*SkipLinesContext).lines = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4741)
			p.Match(DorisParserROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOutFileClauseContext is an interface to support dynamic dispatch.
type IOutFileClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFilePath returns the filePath rule contexts.
	GetFilePath() IConstantContext

	// GetFormat returns the format rule contexts.
	GetFormat() IIdentifierContext

	// SetFilePath sets the filePath rule contexts.
	SetFilePath(IConstantContext)

	// SetFormat sets the format rule contexts.
	SetFormat(IIdentifierContext)

	// Getter signatures
	INTO() antlr.TerminalNode
	OUTFILE() antlr.TerminalNode
	Constant() IConstantContext
	FORMAT() antlr.TerminalNode
	AS() antlr.TerminalNode
	PropertyClause() IPropertyClauseContext
	Identifier() IIdentifierContext

	// IsOutFileClauseContext differentiates from other interfaces.
	IsOutFileClauseContext()
}

type OutFileClauseContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	filePath IConstantContext
	format   IIdentifierContext
}

func NewEmptyOutFileClauseContext() *OutFileClauseContext {
	var p = new(OutFileClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_outFileClause
	return p
}

func InitEmptyOutFileClauseContext(p *OutFileClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_outFileClause
}

func (*OutFileClauseContext) IsOutFileClauseContext() {}

func NewOutFileClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OutFileClauseContext {
	var p = new(OutFileClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_outFileClause

	return p
}

func (s *OutFileClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OutFileClauseContext) GetFilePath() IConstantContext { return s.filePath }

func (s *OutFileClauseContext) GetFormat() IIdentifierContext { return s.format }

func (s *OutFileClauseContext) SetFilePath(v IConstantContext) { s.filePath = v }

func (s *OutFileClauseContext) SetFormat(v IIdentifierContext) { s.format = v }

func (s *OutFileClauseContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserINTO, 0)
}

func (s *OutFileClauseContext) OUTFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserOUTFILE, 0)
}

func (s *OutFileClauseContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *OutFileClauseContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DorisParserFORMAT, 0)
}

func (s *OutFileClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *OutFileClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *OutFileClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *OutFileClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OutFileClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OutFileClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterOutFileClause(s)
	}
}

func (s *OutFileClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitOutFileClause(s)
	}
}

func (p *DorisParser) OutFileClause() (localctx IOutFileClauseContext) {
	localctx = NewOutFileClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, DorisParserRULE_outFileClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4744)
		p.Match(DorisParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4745)
		p.Match(DorisParserOUTFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4746)

		var _x = p.Constant()

		localctx.(*OutFileClauseContext).filePath = _x
	}
	p.SetState(4750)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserFORMAT {
		{
			p.SetState(4747)
			p.Match(DorisParserFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4748)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4749)

			var _x = p.Identifier()

			localctx.(*OutFileClauseContext).format = _x
		}

	}
	p.SetState(4753)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPROPERTIES {
		{
			p.SetState(4752)
			p.PropertyClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryTerm() IQueryTermContext
	QueryOrganization() IQueryOrganizationContext
	Cte() ICteContext

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_query
	return p
}

func InitEmptyQueryContext(p *QueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_query
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) QueryTerm() IQueryTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *QueryContext) QueryOrganization() IQueryOrganizationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryOrganizationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryOrganizationContext)
}

func (s *QueryContext) Cte() ICteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (p *DorisParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, DorisParserRULE_query)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4756)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserWITH {
		{
			p.SetState(4755)
			p.Cte()
		}

	}
	{
		p.SetState(4758)
		p.queryTerm(0)
	}
	{
		p.SetState(4759)
		p.QueryOrganization()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryTermContext is an interface to support dynamic dispatch.
type IQueryTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQueryTermContext differentiates from other interfaces.
	IsQueryTermContext()
}

type QueryTermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryTermContext() *QueryTermContext {
	var p = new(QueryTermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_queryTerm
	return p
}

func InitEmptyQueryTermContext(p *QueryTermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_queryTerm
}

func (*QueryTermContext) IsQueryTermContext() {}

func NewQueryTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryTermContext {
	var p = new(QueryTermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_queryTerm

	return p
}

func (s *QueryTermContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryTermContext) CopyAll(ctx *QueryTermContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QueryTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QueryTermDefaultContext struct {
	QueryTermContext
}

func NewQueryTermDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryTermDefaultContext {
	var p = new(QueryTermDefaultContext)

	InitEmptyQueryTermContext(&p.QueryTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryTermContext))

	return p
}

func (s *QueryTermDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermDefaultContext) QueryPrimary() IQueryPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryPrimaryContext)
}

func (s *QueryTermDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterQueryTermDefault(s)
	}
}

func (s *QueryTermDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitQueryTermDefault(s)
	}
}

type SetOperationContext struct {
	QueryTermContext
	left     IQueryTermContext
	operator antlr.Token
	right    IQueryTermContext
}

func NewSetOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetOperationContext {
	var p = new(SetOperationContext)

	InitEmptyQueryTermContext(&p.QueryTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryTermContext))

	return p
}

func (s *SetOperationContext) GetOperator() antlr.Token { return s.operator }

func (s *SetOperationContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *SetOperationContext) GetLeft() IQueryTermContext { return s.left }

func (s *SetOperationContext) GetRight() IQueryTermContext { return s.right }

func (s *SetOperationContext) SetLeft(v IQueryTermContext) { s.left = v }

func (s *SetOperationContext) SetRight(v IQueryTermContext) { s.right = v }

func (s *SetOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOperationContext) AllQueryTerm() []IQueryTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQueryTermContext); ok {
			len++
		}
	}

	tst := make([]IQueryTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQueryTermContext); ok {
			tst[i] = t.(IQueryTermContext)
			i++
		}
	}

	return tst
}

func (s *SetOperationContext) QueryTerm(i int) IQueryTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *SetOperationContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(DorisParserINTERSECT, 0)
}

func (s *SetOperationContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *SetOperationContext) UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserUNION, 0)
}

func (s *SetOperationContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(DorisParserEXCEPT, 0)
}

func (s *SetOperationContext) MINUS() antlr.TerminalNode {
	return s.GetToken(DorisParserMINUS, 0)
}

func (s *SetOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetOperation(s)
	}
}

func (s *SetOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetOperation(s)
	}
}

func (p *DorisParser) QueryTerm() (localctx IQueryTermContext) {
	return p.queryTerm(0)
}

func (p *DorisParser) queryTerm(_p int) (localctx IQueryTermContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewQueryTermContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IQueryTermContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 228
	p.EnterRecursionRule(localctx, 228, DorisParserRULE_queryTerm, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewQueryTermDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(4762)
		p.QueryPrimary()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(4778)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 679, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(4776)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 678, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSetOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_queryTerm)
				p.SetState(4764)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(4765)

					var _m = p.Match(DorisParserINTERSECT)

					localctx.(*SetOperationContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(4767)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisParserALL || _la == DorisParserDISTINCT {
					{
						p.SetState(4766)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(4769)

					var _x = p.queryTerm(3)

					localctx.(*SetOperationContext).right = _x
				}

			case 2:
				localctx = NewSetOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_queryTerm)
				p.SetState(4770)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(4771)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*SetOperationContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisParserEXCEPT || _la == DorisParserMINUS || _la == DorisParserUNION) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*SetOperationContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(4773)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisParserALL || _la == DorisParserDISTINCT {
					{
						p.SetState(4772)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(4775)

					var _x = p.queryTerm(2)

					localctx.(*SetOperationContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(4780)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 679, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetQuantifierContext is an interface to support dynamic dispatch.
type ISetQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTINCT() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsSetQuantifierContext differentiates from other interfaces.
	IsSetQuantifierContext()
}

type SetQuantifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetQuantifierContext() *SetQuantifierContext {
	var p = new(SetQuantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_setQuantifier
	return p
}

func InitEmptySetQuantifierContext(p *SetQuantifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_setQuantifier
}

func (*SetQuantifierContext) IsSetQuantifierContext() {}

func NewSetQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetQuantifierContext {
	var p = new(SetQuantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_setQuantifier

	return p
}

func (s *SetQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SetQuantifierContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTINCT, 0)
}

func (s *SetQuantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *SetQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSetQuantifier(s)
	}
}

func (p *DorisParser) SetQuantifier() (localctx ISetQuantifierContext) {
	localctx = NewSetQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, DorisParserRULE_setQuantifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4781)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserALL || _la == DorisParserDISTINCT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryPrimaryContext is an interface to support dynamic dispatch.
type IQueryPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQueryPrimaryContext differentiates from other interfaces.
	IsQueryPrimaryContext()
}

type QueryPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryPrimaryContext() *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_queryPrimary
	return p
}

func InitEmptyQueryPrimaryContext(p *QueryPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_queryPrimary
}

func (*QueryPrimaryContext) IsQueryPrimaryContext() {}

func NewQueryPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_queryPrimary

	return p
}

func (s *QueryPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryPrimaryContext) CopyAll(ctx *QueryPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QueryPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryContext struct {
	QueryPrimaryContext
}

func NewSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryContext {
	var p = new(SubqueryContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *SubqueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *SubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSubquery(s)
	}
}

func (s *SubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSubquery(s)
	}
}

type ValuesTableContext struct {
	QueryPrimaryContext
}

func NewValuesTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValuesTableContext {
	var p = new(ValuesTableContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *ValuesTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesTableContext) InlineTable() IInlineTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineTableContext)
}

func (s *ValuesTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterValuesTable(s)
	}
}

func (s *ValuesTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitValuesTable(s)
	}
}

type QueryPrimaryDefaultContext struct {
	QueryPrimaryContext
}

func NewQueryPrimaryDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryPrimaryDefaultContext {
	var p = new(QueryPrimaryDefaultContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *QueryPrimaryDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryDefaultContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *QueryPrimaryDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterQueryPrimaryDefault(s)
	}
}

func (s *QueryPrimaryDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitQueryPrimaryDefault(s)
	}
}

func (p *DorisParser) QueryPrimary() (localctx IQueryPrimaryContext) {
	localctx = NewQueryPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, DorisParserRULE_queryPrimary)
	p.SetState(4789)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserSELECT:
		localctx = NewQueryPrimaryDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4783)
			p.QuerySpecification()
		}

	case DorisParserLEFT_PAREN:
		localctx = NewSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4784)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4785)
			p.Query()
		}
		{
			p.SetState(4786)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserVALUES:
		localctx = NewValuesTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4788)
			p.InlineTable()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_querySpecification
	return p
}

func InitEmptyQuerySpecificationContext(p *QuerySpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_querySpecification
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) CopyAll(ctx *QuerySpecificationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RegularQuerySpecificationContext struct {
	QuerySpecificationContext
}

func NewRegularQuerySpecificationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegularQuerySpecificationContext {
	var p = new(RegularQuerySpecificationContext)

	InitEmptyQuerySpecificationContext(&p.QuerySpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*QuerySpecificationContext))

	return p
}

func (s *RegularQuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegularQuerySpecificationContext) SelectClause() ISelectClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectClauseContext)
}

func (s *RegularQuerySpecificationContext) QueryOrganization() IQueryOrganizationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryOrganizationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryOrganizationContext)
}

func (s *RegularQuerySpecificationContext) IntoClause() IIntoClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntoClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntoClauseContext)
}

func (s *RegularQuerySpecificationContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *RegularQuerySpecificationContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *RegularQuerySpecificationContext) AggClause() IAggClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggClauseContext)
}

func (s *RegularQuerySpecificationContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *RegularQuerySpecificationContext) QualifyClause() IQualifyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifyClauseContext)
}

func (s *RegularQuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRegularQuerySpecification(s)
	}
}

func (s *RegularQuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRegularQuerySpecification(s)
	}
}

func (p *DorisParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, DorisParserRULE_querySpecification)
	localctx = NewRegularQuerySpecificationContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4791)
		p.SelectClause()
	}
	p.SetState(4793)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 681, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4792)
			p.IntoClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4796)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 682, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4795)
			p.FromClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4799)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 683, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4798)
			p.WhereClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4802)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 684, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4801)
			p.AggClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4805)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 685, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4804)
			p.HavingClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4808)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 686, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4807)
			p.QualifyClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4813)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 687, p.GetParserRuleContext()) {
	case 1:
		p.SetState(4810)

		if !(!ansiSQLSyntax) {
			p.SetError(antlr.NewFailedPredicateException(p, "!ansiSQLSyntax", ""))
			goto errorExit
		}
		{
			p.SetState(4811)
			p.QueryOrganization()
		}

	case 2:
		p.SetState(4812)

		if !(ansiSQLSyntax) {
			p.SetError(antlr.NewFailedPredicateException(p, "ansiSQLSyntax", ""))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICteContext is an interface to support dynamic dispatch.
type ICteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	AllAliasQuery() []IAliasQueryContext
	AliasQuery(i int) IAliasQueryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCteContext differentiates from other interfaces.
	IsCteContext()
}

type CteContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCteContext() *CteContext {
	var p = new(CteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_cte
	return p
}

func InitEmptyCteContext(p *CteContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_cte
}

func (*CteContext) IsCteContext() {}

func NewCteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CteContext {
	var p = new(CteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_cte

	return p
}

func (s *CteContext) GetParser() antlr.Parser { return s.parser }

func (s *CteContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *CteContext) AllAliasQuery() []IAliasQueryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAliasQueryContext); ok {
			len++
		}
	}

	tst := make([]IAliasQueryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAliasQueryContext); ok {
			tst[i] = t.(IAliasQueryContext)
			i++
		}
	}

	return tst
}

func (s *CteContext) AliasQuery(i int) IAliasQueryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasQueryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasQueryContext)
}

func (s *CteContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *CteContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *CteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCte(s)
	}
}

func (s *CteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCte(s)
	}
}

func (p *DorisParser) Cte() (localctx ICteContext) {
	localctx = NewCteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, DorisParserRULE_cte)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4815)
		p.Match(DorisParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4816)
		p.AliasQuery()
	}
	p.SetState(4821)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(4817)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4818)
			p.AliasQuery()
		}

		p.SetState(4823)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAliasQueryContext is an interface to support dynamic dispatch.
type IAliasQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AS() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	Query() IQueryContext
	RIGHT_PAREN() antlr.TerminalNode
	ColumnAliases() IColumnAliasesContext

	// IsAliasQueryContext differentiates from other interfaces.
	IsAliasQueryContext()
}

type AliasQueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasQueryContext() *AliasQueryContext {
	var p = new(AliasQueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_aliasQuery
	return p
}

func InitEmptyAliasQueryContext(p *AliasQueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_aliasQuery
}

func (*AliasQueryContext) IsAliasQueryContext() {}

func NewAliasQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasQueryContext {
	var p = new(AliasQueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_aliasQuery

	return p
}

func (s *AliasQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasQueryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AliasQueryContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *AliasQueryContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AliasQueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *AliasQueryContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AliasQueryContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *AliasQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAliasQuery(s)
	}
}

func (s *AliasQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAliasQuery(s)
	}
}

func (p *DorisParser) AliasQuery() (localctx IAliasQueryContext) {
	localctx = NewAliasQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, DorisParserRULE_aliasQuery)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4824)
		p.Identifier()
	}
	p.SetState(4826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLEFT_PAREN {
		{
			p.SetState(4825)
			p.ColumnAliases()
		}

	}
	{
		p.SetState(4828)
		p.Match(DorisParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4829)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4830)
		p.Query()
	}
	{
		p.SetState(4831)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnAliasesContext is an interface to support dynamic dispatch.
type IColumnAliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnAliasesContext differentiates from other interfaces.
	IsColumnAliasesContext()
}

type ColumnAliasesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnAliasesContext() *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_columnAliases
	return p
}

func InitEmptyColumnAliasesContext(p *ColumnAliasesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_columnAliases
}

func (*ColumnAliasesContext) IsColumnAliasesContext() {}

func NewColumnAliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_columnAliases

	return p
}

func (s *ColumnAliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnAliasesContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ColumnAliasesContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnAliasesContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnAliasesContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ColumnAliasesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ColumnAliasesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ColumnAliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnAliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnAliasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterColumnAliases(s)
	}
}

func (s *ColumnAliasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitColumnAliases(s)
	}
}

func (p *DorisParser) ColumnAliases() (localctx IColumnAliasesContext) {
	localctx = NewColumnAliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, DorisParserRULE_columnAliases)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4833)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4834)
		p.Identifier()
	}
	p.SetState(4839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(4835)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4836)
			p.Identifier()
		}

		p.SetState(4841)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4842)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectClauseContext is an interface to support dynamic dispatch.
type ISelectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	SelectColumnClause() ISelectColumnClauseContext
	DISTINCT() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsSelectClauseContext differentiates from other interfaces.
	IsSelectClauseContext()
}

type SelectClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectClauseContext() *SelectClauseContext {
	var p = new(SelectClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_selectClause
	return p
}

func InitEmptySelectClauseContext(p *SelectClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_selectClause
}

func (*SelectClauseContext) IsSelectClauseContext() {}

func NewSelectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectClauseContext {
	var p = new(SelectClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_selectClause

	return p
}

func (s *SelectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectClauseContext) SELECT() antlr.TerminalNode {
	return s.GetToken(DorisParserSELECT, 0)
}

func (s *SelectClauseContext) SelectColumnClause() ISelectColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectColumnClauseContext)
}

func (s *SelectClauseContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTINCT, 0)
}

func (s *SelectClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *SelectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSelectClause(s)
	}
}

func (s *SelectClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSelectClause(s)
	}
}

func (p *DorisParser) SelectClause() (localctx ISelectClauseContext) {
	localctx = NewSelectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, DorisParserRULE_selectClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4844)
		p.Match(DorisParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserALL || _la == DorisParserDISTINCT {
		{
			p.SetState(4845)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserALL || _la == DorisParserDISTINCT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(4848)
		p.SelectColumnClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectColumnClauseContext is an interface to support dynamic dispatch.
type ISelectColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NamedExpressionSeq() INamedExpressionSeqContext

	// IsSelectColumnClauseContext differentiates from other interfaces.
	IsSelectColumnClauseContext()
}

type SelectColumnClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectColumnClauseContext() *SelectColumnClauseContext {
	var p = new(SelectColumnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_selectColumnClause
	return p
}

func InitEmptySelectColumnClauseContext(p *SelectColumnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_selectColumnClause
}

func (*SelectColumnClauseContext) IsSelectColumnClauseContext() {}

func NewSelectColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectColumnClauseContext {
	var p = new(SelectColumnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_selectColumnClause

	return p
}

func (s *SelectColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectColumnClauseContext) NamedExpressionSeq() INamedExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionSeqContext)
}

func (s *SelectColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSelectColumnClause(s)
	}
}

func (s *SelectColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSelectColumnClause(s)
	}
}

func (p *DorisParser) SelectColumnClause() (localctx ISelectColumnClauseContext) {
	localctx = NewSelectColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, DorisParserRULE_selectColumnClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4850)
		p.NamedExpressionSeq()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_whereClause
	return p
}

func InitEmptyWhereClauseContext(p *WhereClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_whereClause
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserWHERE, 0)
}

func (s *WhereClauseContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWhereClause(s)
	}
}

func (s *WhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWhereClause(s)
	}
}

func (p *DorisParser) WhereClause() (localctx IWhereClauseContext) {
	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, DorisParserRULE_whereClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4852)
		p.Match(DorisParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4853)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM() antlr.TerminalNode
	Relations() IRelationsContext

	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_fromClause
	return p
}

func InitEmptyFromClauseContext(p *FromClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_fromClause
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *FromClauseContext) Relations() IRelationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationsContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFromClause(s)
	}
}

func (s *FromClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFromClause(s)
	}
}

func (p *DorisParser) FromClause() (localctx IFromClauseContext) {
	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, DorisParserRULE_fromClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4855)
		p.Match(DorisParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4856)
		p.Relations()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntoClauseContext is an interface to support dynamic dispatch.
type IIntoClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTO() antlr.TerminalNode
	AllTableRow() []ITableRowContext
	TableRow(i int) ITableRowContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	BulkCollectClause() IBulkCollectClauseContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIntoClauseContext differentiates from other interfaces.
	IsIntoClauseContext()
}

type IntoClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntoClauseContext() *IntoClauseContext {
	var p = new(IntoClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_intoClause
	return p
}

func InitEmptyIntoClauseContext(p *IntoClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_intoClause
}

func (*IntoClauseContext) IsIntoClauseContext() {}

func NewIntoClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntoClauseContext {
	var p = new(IntoClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_intoClause

	return p
}

func (s *IntoClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *IntoClauseContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserINTO, 0)
}

func (s *IntoClauseContext) AllTableRow() []ITableRowContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableRowContext); ok {
			len++
		}
	}

	tst := make([]ITableRowContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableRowContext); ok {
			tst[i] = t.(ITableRowContext)
			i++
		}
	}

	return tst
}

func (s *IntoClauseContext) TableRow(i int) ITableRowContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRowContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRowContext)
}

func (s *IntoClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IntoClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IntoClauseContext) BulkCollectClause() IBulkCollectClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBulkCollectClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBulkCollectClauseContext)
}

func (s *IntoClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *IntoClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *IntoClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntoClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntoClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIntoClause(s)
	}
}

func (s *IntoClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIntoClause(s)
	}
}

func (p *DorisParser) IntoClause() (localctx IIntoClauseContext) {
	localctx = NewIntoClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, DorisParserRULE_intoClause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4859)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserBULK {
		{
			p.SetState(4858)
			p.BulkCollectClause()
		}

	}
	{
		p.SetState(4861)
		p.Match(DorisParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4864)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 693, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4862)
			p.TableRow()
		}

	case 2:
		{
			p.SetState(4863)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(4873)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 695, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4866)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(4869)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 694, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(4867)
					p.TableRow()
				}

			case 2:
				{
					p.SetState(4868)
					p.Identifier()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(4875)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 695, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBulkCollectClauseContext is an interface to support dynamic dispatch.
type IBulkCollectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BULK() antlr.TerminalNode
	COLLECT() antlr.TerminalNode

	// IsBulkCollectClauseContext differentiates from other interfaces.
	IsBulkCollectClauseContext()
}

type BulkCollectClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBulkCollectClauseContext() *BulkCollectClauseContext {
	var p = new(BulkCollectClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_bulkCollectClause
	return p
}

func InitEmptyBulkCollectClauseContext(p *BulkCollectClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_bulkCollectClause
}

func (*BulkCollectClauseContext) IsBulkCollectClauseContext() {}

func NewBulkCollectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BulkCollectClauseContext {
	var p = new(BulkCollectClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_bulkCollectClause

	return p
}

func (s *BulkCollectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *BulkCollectClauseContext) BULK() antlr.TerminalNode {
	return s.GetToken(DorisParserBULK, 0)
}

func (s *BulkCollectClauseContext) COLLECT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLLECT, 0)
}

func (s *BulkCollectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BulkCollectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BulkCollectClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBulkCollectClause(s)
	}
}

func (s *BulkCollectClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBulkCollectClause(s)
	}
}

func (p *DorisParser) BulkCollectClause() (localctx IBulkCollectClauseContext) {
	localctx = NewBulkCollectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, DorisParserRULE_bulkCollectClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4876)
		p.Match(DorisParserBULK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4877)
		p.Match(DorisParserCOLLECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableRowContext is an interface to support dynamic dispatch.
type ITableRowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LEFT_PAREN() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode

	// IsTableRowContext differentiates from other interfaces.
	IsTableRowContext()
}

type TableRowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableRowContext() *TableRowContext {
	var p = new(TableRowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tableRow
	return p
}

func InitEmptyTableRowContext(p *TableRowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tableRow
}

func (*TableRowContext) IsTableRowContext() {}

func NewTableRowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableRowContext {
	var p = new(TableRowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_tableRow

	return p
}

func (s *TableRowContext) GetParser() antlr.Parser { return s.parser }

func (s *TableRowContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableRowContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *TableRowContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *TableRowContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *TableRowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableRowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableRowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTableRow(s)
	}
}

func (s *TableRowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTableRow(s)
	}
}

func (p *DorisParser) TableRow() (localctx ITableRowContext) {
	localctx = NewTableRowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, DorisParserRULE_tableRow)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4879)
		p.Identifier()
	}
	{
		p.SetState(4880)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4881)
		p.Match(DorisParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4882)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationsContext is an interface to support dynamic dispatch.
type IRelationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRelation() []IRelationContext
	Relation(i int) IRelationContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRelationsContext differentiates from other interfaces.
	IsRelationsContext()
}

type RelationsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationsContext() *RelationsContext {
	var p = new(RelationsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_relations
	return p
}

func InitEmptyRelationsContext(p *RelationsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_relations
}

func (*RelationsContext) IsRelationsContext() {}

func NewRelationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationsContext {
	var p = new(RelationsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_relations

	return p
}

func (s *RelationsContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationsContext) AllRelation() []IRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelationContext); ok {
			len++
		}
	}

	tst := make([]IRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelationContext); ok {
			tst[i] = t.(IRelationContext)
			i++
		}
	}

	return tst
}

func (s *RelationsContext) Relation(i int) IRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *RelationsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *RelationsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *RelationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRelations(s)
	}
}

func (s *RelationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRelations(s)
	}
}

func (p *DorisParser) Relations() (localctx IRelationsContext) {
	localctx = NewRelationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, DorisParserRULE_relations)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4884)
		p.Relation()
	}
	p.SetState(4889)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 696, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4885)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4886)
				p.Relation()
			}

		}
		p.SetState(4891)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 696, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RelationPrimary() IRelationPrimaryContext
	AllJoinRelation() []IJoinRelationContext
	JoinRelation(i int) IJoinRelationContext

	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_relation
	return p
}

func InitEmptyRelationContext(p *RelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_relation
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) RelationPrimary() IRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *RelationContext) AllJoinRelation() []IJoinRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinRelationContext); ok {
			len++
		}
	}

	tst := make([]IJoinRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinRelationContext); ok {
			tst[i] = t.(IJoinRelationContext)
			i++
		}
	}

	return tst
}

func (s *RelationContext) JoinRelation(i int) IJoinRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinRelationContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRelation(s)
	}
}

func (s *RelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRelation(s)
	}
}

func (p *DorisParser) Relation() (localctx IRelationContext) {
	localctx = NewRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, DorisParserRULE_relation)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4892)
		p.RelationPrimary()
	}
	p.SetState(4896)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 697, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4893)
				p.JoinRelation()
			}

		}
		p.SetState(4898)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 697, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinRelationContext is an interface to support dynamic dispatch.
type IJoinRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRight returns the right rule contexts.
	GetRight() IRelationPrimaryContext

	// SetRight sets the right rule contexts.
	SetRight(IRelationPrimaryContext)

	// Getter signatures
	JOIN() antlr.TerminalNode
	RelationPrimary() IRelationPrimaryContext
	JoinType() IJoinTypeContext
	DistributeType() IDistributeTypeContext
	JoinCriteria() IJoinCriteriaContext

	// IsJoinRelationContext differentiates from other interfaces.
	IsJoinRelationContext()
}

type JoinRelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	right  IRelationPrimaryContext
}

func NewEmptyJoinRelationContext() *JoinRelationContext {
	var p = new(JoinRelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_joinRelation
	return p
}

func InitEmptyJoinRelationContext(p *JoinRelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_joinRelation
}

func (*JoinRelationContext) IsJoinRelationContext() {}

func NewJoinRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinRelationContext {
	var p = new(JoinRelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_joinRelation

	return p
}

func (s *JoinRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinRelationContext) GetRight() IRelationPrimaryContext { return s.right }

func (s *JoinRelationContext) SetRight(v IRelationPrimaryContext) { s.right = v }

func (s *JoinRelationContext) JOIN() antlr.TerminalNode {
	return s.GetToken(DorisParserJOIN, 0)
}

func (s *JoinRelationContext) RelationPrimary() IRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *JoinRelationContext) JoinType() IJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinTypeContext)
}

func (s *JoinRelationContext) DistributeType() IDistributeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributeTypeContext)
}

func (s *JoinRelationContext) JoinCriteria() IJoinCriteriaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinCriteriaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinCriteriaContext)
}

func (s *JoinRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterJoinRelation(s)
	}
}

func (s *JoinRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitJoinRelation(s)
	}
}

func (p *DorisParser) JoinRelation() (localctx IJoinRelationContext) {
	localctx = NewJoinRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, DorisParserRULE_joinRelation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4899)
		p.JoinType()
	}

	{
		p.SetState(4900)
		p.Match(DorisParserJOIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4902)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 698, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4901)
			p.DistributeType()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4904)

		var _x = p.RelationPrimary()

		localctx.(*JoinRelationContext).right = _x
	}
	p.SetState(4906)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 699, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4905)
			p.JoinCriteria()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDistributeTypeContext is an interface to support dynamic dispatch.
type IDistributeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDistributeTypeContext differentiates from other interfaces.
	IsDistributeTypeContext()
}

type DistributeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistributeTypeContext() *DistributeTypeContext {
	var p = new(DistributeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_distributeType
	return p
}

func InitEmptyDistributeTypeContext(p *DistributeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_distributeType
}

func (*DistributeTypeContext) IsDistributeTypeContext() {}

func NewDistributeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistributeTypeContext {
	var p = new(DistributeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_distributeType

	return p
}

func (s *DistributeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DistributeTypeContext) CopyAll(ctx *DistributeTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DistributeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistributeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CommentDistributeTypeContext struct {
	DistributeTypeContext
}

func NewCommentDistributeTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommentDistributeTypeContext {
	var p = new(CommentDistributeTypeContext)

	InitEmptyDistributeTypeContext(&p.DistributeTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DistributeTypeContext))

	return p
}

func (s *CommentDistributeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentDistributeTypeContext) HINT_START() antlr.TerminalNode {
	return s.GetToken(DorisParserHINT_START, 0)
}

func (s *CommentDistributeTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CommentDistributeTypeContext) HINT_END() antlr.TerminalNode {
	return s.GetToken(DorisParserHINT_END, 0)
}

func (s *CommentDistributeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCommentDistributeType(s)
	}
}

func (s *CommentDistributeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCommentDistributeType(s)
	}
}

type BracketDistributeTypeContext struct {
	DistributeTypeContext
}

func NewBracketDistributeTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BracketDistributeTypeContext {
	var p = new(BracketDistributeTypeContext)

	InitEmptyDistributeTypeContext(&p.DistributeTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DistributeTypeContext))

	return p
}

func (s *BracketDistributeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BracketDistributeTypeContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACKET, 0)
}

func (s *BracketDistributeTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BracketDistributeTypeContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACKET, 0)
}

func (s *BracketDistributeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBracketDistributeType(s)
	}
}

func (s *BracketDistributeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBracketDistributeType(s)
	}
}

func (p *DorisParser) DistributeType() (localctx IDistributeTypeContext) {
	localctx = NewDistributeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, DorisParserRULE_distributeType)
	p.SetState(4916)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACKET:
		localctx = NewBracketDistributeTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4908)
			p.Match(DorisParserLEFT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4909)
			p.Identifier()
		}
		{
			p.SetState(4910)
			p.Match(DorisParserRIGHT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserHINT_START:
		localctx = NewCommentDistributeTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4912)
			p.Match(DorisParserHINT_START)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4913)
			p.Identifier()
		}
		{
			p.SetState(4914)
			p.Match(DorisParserHINT_END)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationHintContext is an interface to support dynamic dispatch.
type IRelationHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationHintContext differentiates from other interfaces.
	IsRelationHintContext()
}

type RelationHintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationHintContext() *RelationHintContext {
	var p = new(RelationHintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_relationHint
	return p
}

func InitEmptyRelationHintContext(p *RelationHintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_relationHint
}

func (*RelationHintContext) IsRelationHintContext() {}

func NewRelationHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationHintContext {
	var p = new(RelationHintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_relationHint

	return p
}

func (s *RelationHintContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationHintContext) CopyAll(ctx *RelationHintContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RelationHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BracketRelationHintContext struct {
	RelationHintContext
}

func NewBracketRelationHintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BracketRelationHintContext {
	var p = new(BracketRelationHintContext)

	InitEmptyRelationHintContext(&p.RelationHintContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationHintContext))

	return p
}

func (s *BracketRelationHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BracketRelationHintContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACKET, 0)
}

func (s *BracketRelationHintContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *BracketRelationHintContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BracketRelationHintContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACKET, 0)
}

func (s *BracketRelationHintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *BracketRelationHintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *BracketRelationHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBracketRelationHint(s)
	}
}

func (s *BracketRelationHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBracketRelationHint(s)
	}
}

type CommentRelationHintContext struct {
	RelationHintContext
}

func NewCommentRelationHintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommentRelationHintContext {
	var p = new(CommentRelationHintContext)

	InitEmptyRelationHintContext(&p.RelationHintContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationHintContext))

	return p
}

func (s *CommentRelationHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentRelationHintContext) HINT_START() antlr.TerminalNode {
	return s.GetToken(DorisParserHINT_START, 0)
}

func (s *CommentRelationHintContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CommentRelationHintContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CommentRelationHintContext) HINT_END() antlr.TerminalNode {
	return s.GetToken(DorisParserHINT_END, 0)
}

func (s *CommentRelationHintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *CommentRelationHintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *CommentRelationHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCommentRelationHint(s)
	}
}

func (s *CommentRelationHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCommentRelationHint(s)
	}
}

func (p *DorisParser) RelationHint() (localctx IRelationHintContext) {
	localctx = NewRelationHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, DorisParserRULE_relationHint)
	var _la int

	p.SetState(4940)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACKET:
		localctx = NewBracketRelationHintContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4918)
			p.Match(DorisParserLEFT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4919)
			p.Identifier()
		}
		p.SetState(4924)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(4920)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4921)
				p.Identifier()
			}

			p.SetState(4926)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4927)
			p.Match(DorisParserRIGHT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserHINT_START:
		localctx = NewCommentRelationHintContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4929)
			p.Match(DorisParserHINT_START)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4930)
			p.Identifier()
		}
		p.SetState(4935)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(4931)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4932)
				p.Identifier()
			}

			p.SetState(4937)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4938)
			p.Match(DorisParserHINT_END)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggClauseContext is an interface to support dynamic dispatch.
type IAggClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	GroupingElement() IGroupingElementContext

	// IsAggClauseContext differentiates from other interfaces.
	IsAggClauseContext()
}

type AggClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggClauseContext() *AggClauseContext {
	var p = new(AggClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_aggClause
	return p
}

func InitEmptyAggClauseContext(p *AggClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_aggClause
}

func (*AggClauseContext) IsAggClauseContext() {}

func NewAggClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggClauseContext {
	var p = new(AggClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_aggClause

	return p
}

func (s *AggClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AggClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUP, 0)
}

func (s *AggClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *AggClauseContext) GroupingElement() IGroupingElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingElementContext)
}

func (s *AggClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAggClause(s)
	}
}

func (s *AggClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAggClause(s)
	}
}

func (p *DorisParser) AggClause() (localctx IAggClauseContext) {
	localctx = NewAggClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, DorisParserRULE_aggClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4942)
		p.Match(DorisParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4943)
		p.Match(DorisParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4944)
		p.GroupingElement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingElementContext is an interface to support dynamic dispatch.
type IGroupingElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLLUP() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	CUBE() antlr.TerminalNode
	GROUPING() antlr.TerminalNode
	SETS() antlr.TerminalNode
	AllGroupingSet() []IGroupingSetContext
	GroupingSet(i int) IGroupingSetContext
	WITH() antlr.TerminalNode

	// IsGroupingElementContext differentiates from other interfaces.
	IsGroupingElementContext()
}

type GroupingElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingElementContext() *GroupingElementContext {
	var p = new(GroupingElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_groupingElement
	return p
}

func InitEmptyGroupingElementContext(p *GroupingElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_groupingElement
}

func (*GroupingElementContext) IsGroupingElementContext() {}

func NewGroupingElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingElementContext {
	var p = new(GroupingElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_groupingElement

	return p
}

func (s *GroupingElementContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingElementContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *GroupingElementContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *GroupingElementContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *GroupingElementContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupingElementContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingElementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *GroupingElementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *GroupingElementContext) CUBE() antlr.TerminalNode {
	return s.GetToken(DorisParserCUBE, 0)
}

func (s *GroupingElementContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUPING, 0)
}

func (s *GroupingElementContext) SETS() antlr.TerminalNode {
	return s.GetToken(DorisParserSETS, 0)
}

func (s *GroupingElementContext) AllGroupingSet() []IGroupingSetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupingSetContext); ok {
			len++
		}
	}

	tst := make([]IGroupingSetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupingSetContext); ok {
			tst[i] = t.(IGroupingSetContext)
			i++
		}
	}

	return tst
}

func (s *GroupingElementContext) GroupingSet(i int) IGroupingSetContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingSetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *GroupingElementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserWITH, 0)
}

func (s *GroupingElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterGroupingElement(s)
	}
}

func (s *GroupingElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitGroupingElement(s)
	}
}

func (p *DorisParser) GroupingElement() (localctx IGroupingElementContext) {
	localctx = NewGroupingElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, DorisParserRULE_groupingElement)
	var _la int

	var _alt int

	p.SetState(4997)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 711, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4946)
			p.Match(DorisParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4947)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4956)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305884869834611068) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4610552282352573437) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4539691388691605019) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&2845980307192511093) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&8572566566736488189) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-304588910535901189) != 0) || ((int64((_la-391)) & ^0x3f) == 0 && ((int64(1)<<(_la-391))&1188948054525295071) != 0) || ((int64((_la-455)) & ^0x3f) == 0 && ((int64(1)<<(_la-455))&2458964612221977455) != 0) || ((int64((_la-524)) & ^0x3f) == 0 && ((int64(1)<<(_la-524))&923779367) != 0) {
			{
				p.SetState(4948)
				p.Expression()
			}
			p.SetState(4953)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(4949)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4950)
					p.Expression()
				}

				p.SetState(4955)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(4958)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4959)
			p.Match(DorisParserCUBE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4960)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4969)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305884869834611068) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4610552282352573437) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4539691388691605019) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&2845980307192511093) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&8572566566736488189) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-304588910535901189) != 0) || ((int64((_la-391)) & ^0x3f) == 0 && ((int64(1)<<(_la-391))&1188948054525295071) != 0) || ((int64((_la-455)) & ^0x3f) == 0 && ((int64(1)<<(_la-455))&2458964612221977455) != 0) || ((int64((_la-524)) & ^0x3f) == 0 && ((int64(1)<<(_la-524))&923779367) != 0) {
			{
				p.SetState(4961)
				p.Expression()
			}
			p.SetState(4966)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(4962)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4963)
					p.Expression()
				}

				p.SetState(4968)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(4971)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4972)
			p.Match(DorisParserGROUPING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4973)
			p.Match(DorisParserSETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4974)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4975)
			p.GroupingSet()
		}
		p.SetState(4980)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(4976)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4977)
				p.GroupingSet()
			}

			p.SetState(4982)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4983)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4985)
			p.Expression()
		}
		p.SetState(4990)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 709, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(4986)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4987)
					p.Expression()
				}

			}
			p.SetState(4992)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 709, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(4995)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 710, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4993)
				p.Match(DorisParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4994)
				p.Match(DorisParserROLLUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingSetContext is an interface to support dynamic dispatch.
type IGroupingSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGroupingSetContext differentiates from other interfaces.
	IsGroupingSetContext()
}

type GroupingSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingSetContext() *GroupingSetContext {
	var p = new(GroupingSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_groupingSet
	return p
}

func InitEmptyGroupingSetContext(p *GroupingSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_groupingSet
}

func (*GroupingSetContext) IsGroupingSetContext() {}

func NewGroupingSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingSetContext {
	var p = new(GroupingSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_groupingSet

	return p
}

func (s *GroupingSetContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingSetContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *GroupingSetContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *GroupingSetContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupingSetContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingSetContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *GroupingSetContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *GroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterGroupingSet(s)
	}
}

func (s *GroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitGroupingSet(s)
	}
}

func (p *DorisParser) GroupingSet() (localctx IGroupingSetContext) {
	localctx = NewGroupingSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, DorisParserRULE_groupingSet)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4999)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5008)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305884869834611068) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4610552282352573437) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4539691388691605019) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&2845980307192511093) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&8572566566736488189) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-304588910535901189) != 0) || ((int64((_la-391)) & ^0x3f) == 0 && ((int64(1)<<(_la-391))&1188948054525295071) != 0) || ((int64((_la-455)) & ^0x3f) == 0 && ((int64(1)<<(_la-455))&2458964612221977455) != 0) || ((int64((_la-524)) & ^0x3f) == 0 && ((int64(1)<<(_la-524))&923779367) != 0) {
		{
			p.SetState(5000)
			p.Expression()
		}
		p.SetState(5005)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(5001)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5002)
				p.Expression()
			}

			p.SetState(5007)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(5010)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHavingClauseContext is an interface to support dynamic dispatch.
type IHavingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HAVING() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsHavingClauseContext differentiates from other interfaces.
	IsHavingClauseContext()
}

type HavingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHavingClauseContext() *HavingClauseContext {
	var p = new(HavingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_havingClause
	return p
}

func InitEmptyHavingClauseContext(p *HavingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_havingClause
}

func (*HavingClauseContext) IsHavingClauseContext() {}

func NewHavingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HavingClauseContext {
	var p = new(HavingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_havingClause

	return p
}

func (s *HavingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *HavingClauseContext) HAVING() antlr.TerminalNode {
	return s.GetToken(DorisParserHAVING, 0)
}

func (s *HavingClauseContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *HavingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HavingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HavingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterHavingClause(s)
	}
}

func (s *HavingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitHavingClause(s)
	}
}

func (p *DorisParser) HavingClause() (localctx IHavingClauseContext) {
	localctx = NewHavingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, DorisParserRULE_havingClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5012)
		p.Match(DorisParserHAVING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5013)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifyClauseContext is an interface to support dynamic dispatch.
type IQualifyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUALIFY() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsQualifyClauseContext differentiates from other interfaces.
	IsQualifyClauseContext()
}

type QualifyClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifyClauseContext() *QualifyClauseContext {
	var p = new(QualifyClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_qualifyClause
	return p
}

func InitEmptyQualifyClauseContext(p *QualifyClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_qualifyClause
}

func (*QualifyClauseContext) IsQualifyClauseContext() {}

func NewQualifyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifyClauseContext {
	var p = new(QualifyClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_qualifyClause

	return p
}

func (s *QualifyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifyClauseContext) QUALIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserQUALIFY, 0)
}

func (s *QualifyClauseContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *QualifyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterQualifyClause(s)
	}
}

func (s *QualifyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitQualifyClause(s)
	}
}

func (p *DorisParser) QualifyClause() (localctx IQualifyClauseContext) {
	localctx = NewQualifyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, DorisParserRULE_qualifyClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5015)
		p.Match(DorisParserQUALIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5016)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectHintContext is an interface to support dynamic dispatch.
type ISelectHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_hintStatement returns the _hintStatement rule contexts.
	Get_hintStatement() IHintStatementContext

	// Set_hintStatement sets the _hintStatement rule contexts.
	Set_hintStatement(IHintStatementContext)

	// GetHintStatements returns the hintStatements rule context list.
	GetHintStatements() []IHintStatementContext

	// SetHintStatements sets the hintStatements rule context list.
	SetHintStatements([]IHintStatementContext)

	// Getter signatures
	HINT_END() antlr.TerminalNode
	AllHintStatement() []IHintStatementContext
	HintStatement(i int) IHintStatementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSelectHintContext differentiates from other interfaces.
	IsSelectHintContext()
}

type SelectHintContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	_hintStatement IHintStatementContext
	hintStatements []IHintStatementContext
}

func NewEmptySelectHintContext() *SelectHintContext {
	var p = new(SelectHintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_selectHint
	return p
}

func InitEmptySelectHintContext(p *SelectHintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_selectHint
}

func (*SelectHintContext) IsSelectHintContext() {}

func NewSelectHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectHintContext {
	var p = new(SelectHintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_selectHint

	return p
}

func (s *SelectHintContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectHintContext) Get_hintStatement() IHintStatementContext { return s._hintStatement }

func (s *SelectHintContext) Set_hintStatement(v IHintStatementContext) { s._hintStatement = v }

func (s *SelectHintContext) GetHintStatements() []IHintStatementContext { return s.hintStatements }

func (s *SelectHintContext) SetHintStatements(v []IHintStatementContext) { s.hintStatements = v }

func (s *SelectHintContext) HINT_END() antlr.TerminalNode {
	return s.GetToken(DorisParserHINT_END, 0)
}

func (s *SelectHintContext) AllHintStatement() []IHintStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHintStatementContext); ok {
			len++
		}
	}

	tst := make([]IHintStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHintStatementContext); ok {
			tst[i] = t.(IHintStatementContext)
			i++
		}
	}

	return tst
}

func (s *SelectHintContext) HintStatement(i int) IHintStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintStatementContext)
}

func (s *SelectHintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *SelectHintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *SelectHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSelectHint(s)
	}
}

func (s *SelectHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSelectHint(s)
	}
}

func (p *DorisParser) SelectHint() (localctx ISelectHintContext) {
	localctx = NewSelectHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, DorisParserRULE_selectHint)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5018)

		var _x = p.HintStatement()

		localctx.(*SelectHintContext)._hintStatement = _x
	}
	localctx.(*SelectHintContext).hintStatements = append(localctx.(*SelectHintContext).hintStatements, localctx.(*SelectHintContext)._hintStatement)
	p.SetState(5025)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 715, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(5020)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserCOMMA {
				{
					p.SetState(5019)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(5022)

				var _x = p.HintStatement()

				localctx.(*SelectHintContext)._hintStatement = _x
			}
			localctx.(*SelectHintContext).hintStatements = append(localctx.(*SelectHintContext).hintStatements, localctx.(*SelectHintContext)._hintStatement)

		}
		p.SetState(5027)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 715, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(5028)
		p.Match(DorisParserHINT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHintStatementContext is an interface to support dynamic dispatch.
type IHintStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetHintName returns the hintName rule contexts.
	GetHintName() IIdentifierContext

	// Get_hintAssignment returns the _hintAssignment rule contexts.
	Get_hintAssignment() IHintAssignmentContext

	// Get_multipartIdentifier returns the _multipartIdentifier rule contexts.
	Get_multipartIdentifier() IMultipartIdentifierContext

	// SetHintName sets the hintName rule contexts.
	SetHintName(IIdentifierContext)

	// Set_hintAssignment sets the _hintAssignment rule contexts.
	Set_hintAssignment(IHintAssignmentContext)

	// Set_multipartIdentifier sets the _multipartIdentifier rule contexts.
	Set_multipartIdentifier(IMultipartIdentifierContext)

	// GetParameters returns the parameters rule context list.
	GetParameters() []IHintAssignmentContext

	// GetTableList returns the tableList rule context list.
	GetTableList() []IMultipartIdentifierContext

	// SetParameters sets the parameters rule context list.
	SetParameters([]IHintAssignmentContext)

	// SetTableList sets the tableList rule context list.
	SetTableList([]IMultipartIdentifierContext)

	// Getter signatures
	Identifier() IIdentifierContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllHintAssignment() []IHintAssignmentContext
	HintAssignment(i int) IHintAssignmentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	USE_MV() antlr.TerminalNode
	NO_USE_MV() antlr.TerminalNode
	AllMultipartIdentifier() []IMultipartIdentifierContext
	MultipartIdentifier(i int) IMultipartIdentifierContext

	// IsHintStatementContext differentiates from other interfaces.
	IsHintStatementContext()
}

type HintStatementContext struct {
	antlr.BaseParserRuleContext
	parser               antlr.Parser
	hintName             IIdentifierContext
	_hintAssignment      IHintAssignmentContext
	parameters           []IHintAssignmentContext
	_multipartIdentifier IMultipartIdentifierContext
	tableList            []IMultipartIdentifierContext
}

func NewEmptyHintStatementContext() *HintStatementContext {
	var p = new(HintStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_hintStatement
	return p
}

func InitEmptyHintStatementContext(p *HintStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_hintStatement
}

func (*HintStatementContext) IsHintStatementContext() {}

func NewHintStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintStatementContext {
	var p = new(HintStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_hintStatement

	return p
}

func (s *HintStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HintStatementContext) GetHintName() IIdentifierContext { return s.hintName }

func (s *HintStatementContext) Get_hintAssignment() IHintAssignmentContext { return s._hintAssignment }

func (s *HintStatementContext) Get_multipartIdentifier() IMultipartIdentifierContext {
	return s._multipartIdentifier
}

func (s *HintStatementContext) SetHintName(v IIdentifierContext) { s.hintName = v }

func (s *HintStatementContext) Set_hintAssignment(v IHintAssignmentContext) { s._hintAssignment = v }

func (s *HintStatementContext) Set_multipartIdentifier(v IMultipartIdentifierContext) {
	s._multipartIdentifier = v
}

func (s *HintStatementContext) GetParameters() []IHintAssignmentContext { return s.parameters }

func (s *HintStatementContext) GetTableList() []IMultipartIdentifierContext { return s.tableList }

func (s *HintStatementContext) SetParameters(v []IHintAssignmentContext) { s.parameters = v }

func (s *HintStatementContext) SetTableList(v []IMultipartIdentifierContext) { s.tableList = v }

func (s *HintStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *HintStatementContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *HintStatementContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *HintStatementContext) AllHintAssignment() []IHintAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHintAssignmentContext); ok {
			len++
		}
	}

	tst := make([]IHintAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHintAssignmentContext); ok {
			tst[i] = t.(IHintAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *HintStatementContext) HintAssignment(i int) IHintAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintAssignmentContext)
}

func (s *HintStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *HintStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *HintStatementContext) USE_MV() antlr.TerminalNode {
	return s.GetToken(DorisParserUSE_MV, 0)
}

func (s *HintStatementContext) NO_USE_MV() antlr.TerminalNode {
	return s.GetToken(DorisParserNO_USE_MV, 0)
}

func (s *HintStatementContext) AllMultipartIdentifier() []IMultipartIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultipartIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipartIdentifierContext); ok {
			tst[i] = t.(IMultipartIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *HintStatementContext) MultipartIdentifier(i int) IMultipartIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *HintStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HintStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterHintStatement(s)
	}
}

func (s *HintStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitHintStatement(s)
	}
}

func (p *DorisParser) HintStatement() (localctx IHintStatementContext) {
	localctx = NewHintStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, DorisParserRULE_hintStatement)
	var _la int

	p.SetState(5060)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5030)

			var _x = p.Identifier()

			localctx.(*HintStatementContext).hintName = _x
		}
		p.SetState(5044)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(5031)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5032)

				var _x = p.HintAssignment()

				localctx.(*HintStatementContext)._hintAssignment = _x
			}
			localctx.(*HintStatementContext).parameters = append(localctx.(*HintStatementContext).parameters, localctx.(*HintStatementContext)._hintAssignment)
			p.SetState(5039)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305884869834627440) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4609989332399152113) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4539834325203215899) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&2557745532860070517) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&8563559367481747053) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-305714810442743813) != 0) || ((int64((_la-391)) & ^0x3f) == 0 && ((int64(1)<<(_la-391))&1188948054525294943) != 0) || ((int64((_la-455)) & ^0x3f) == 0 && ((int64(1)<<(_la-455))&2458964612221715311) != 0) || ((int64((_la-525)) & ^0x3f) == 0 && ((int64(1)<<(_la-525))&461692929) != 0) {
				p.SetState(5034)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisParserCOMMA {
					{
						p.SetState(5033)
						p.Match(DorisParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(5036)

					var _x = p.HintAssignment()

					localctx.(*HintStatementContext)._hintAssignment = _x
				}
				localctx.(*HintStatementContext).parameters = append(localctx.(*HintStatementContext).parameters, localctx.(*HintStatementContext)._hintAssignment)

				p.SetState(5041)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(5042)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DorisParserNO_USE_MV, DorisParserUSE_MV:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5046)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserNO_USE_MV || _la == DorisParserUSE_MV) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(5058)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(5047)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5048)

				var _x = p.MultipartIdentifier()

				localctx.(*HintStatementContext)._multipartIdentifier = _x
			}
			localctx.(*HintStatementContext).tableList = append(localctx.(*HintStatementContext).tableList, localctx.(*HintStatementContext)._multipartIdentifier)
			p.SetState(5053)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(5049)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5050)

					var _x = p.MultipartIdentifier()

					localctx.(*HintStatementContext)._multipartIdentifier = _x
				}
				localctx.(*HintStatementContext).tableList = append(localctx.(*HintStatementContext).tableList, localctx.(*HintStatementContext)._multipartIdentifier)

				p.SetState(5055)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(5056)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHintAssignmentContext is an interface to support dynamic dispatch.
type IHintAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IIdentifierOrTextContext

	// GetConstantValue returns the constantValue rule contexts.
	GetConstantValue() IConstantContext

	// GetIdentifierValue returns the identifierValue rule contexts.
	GetIdentifierValue() IIdentifierContext

	// SetKey sets the key rule contexts.
	SetKey(IIdentifierOrTextContext)

	// SetConstantValue sets the constantValue rule contexts.
	SetConstantValue(IConstantContext)

	// SetIdentifierValue sets the identifierValue rule contexts.
	SetIdentifierValue(IIdentifierContext)

	// Getter signatures
	IdentifierOrText() IIdentifierOrTextContext
	EQ() antlr.TerminalNode
	Constant() IConstantContext
	Identifier() IIdentifierContext

	// IsHintAssignmentContext differentiates from other interfaces.
	IsHintAssignmentContext()
}

type HintAssignmentContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	key             IIdentifierOrTextContext
	constantValue   IConstantContext
	identifierValue IIdentifierContext
}

func NewEmptyHintAssignmentContext() *HintAssignmentContext {
	var p = new(HintAssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_hintAssignment
	return p
}

func InitEmptyHintAssignmentContext(p *HintAssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_hintAssignment
}

func (*HintAssignmentContext) IsHintAssignmentContext() {}

func NewHintAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintAssignmentContext {
	var p = new(HintAssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_hintAssignment

	return p
}

func (s *HintAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *HintAssignmentContext) GetKey() IIdentifierOrTextContext { return s.key }

func (s *HintAssignmentContext) GetConstantValue() IConstantContext { return s.constantValue }

func (s *HintAssignmentContext) GetIdentifierValue() IIdentifierContext { return s.identifierValue }

func (s *HintAssignmentContext) SetKey(v IIdentifierOrTextContext) { s.key = v }

func (s *HintAssignmentContext) SetConstantValue(v IConstantContext) { s.constantValue = v }

func (s *HintAssignmentContext) SetIdentifierValue(v IIdentifierContext) { s.identifierValue = v }

func (s *HintAssignmentContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *HintAssignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *HintAssignmentContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *HintAssignmentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *HintAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HintAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterHintAssignment(s)
	}
}

func (s *HintAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitHintAssignment(s)
	}
}

func (p *DorisParser) HintAssignment() (localctx IHintAssignmentContext) {
	localctx = NewHintAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, DorisParserRULE_hintAssignment)
	var _la int

	p.SetState(5071)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 724, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5062)

			var _x = p.IdentifierOrText()

			localctx.(*HintAssignmentContext).key = _x
		}
		p.SetState(5068)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserEQ {
			{
				p.SetState(5063)
				p.Match(DorisParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5066)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 722, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(5064)

					var _x = p.Constant()

					localctx.(*HintAssignmentContext).constantValue = _x
				}

			case 2:
				{
					p.SetState(5065)

					var _x = p.Identifier()

					localctx.(*HintAssignmentContext).identifierValue = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5070)
			p.Constant()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateAssignmentContext is an interface to support dynamic dispatch.
type IUpdateAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCol returns the col rule contexts.
	GetCol() IMultipartIdentifierContext

	// SetCol sets the col rule contexts.
	SetCol(IMultipartIdentifierContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext
	Expression() IExpressionContext
	DEFAULT() antlr.TerminalNode

	// IsUpdateAssignmentContext differentiates from other interfaces.
	IsUpdateAssignmentContext()
}

type UpdateAssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	col    IMultipartIdentifierContext
}

func NewEmptyUpdateAssignmentContext() *UpdateAssignmentContext {
	var p = new(UpdateAssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_updateAssignment
	return p
}

func InitEmptyUpdateAssignmentContext(p *UpdateAssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_updateAssignment
}

func (*UpdateAssignmentContext) IsUpdateAssignmentContext() {}

func NewUpdateAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateAssignmentContext {
	var p = new(UpdateAssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_updateAssignment

	return p
}

func (s *UpdateAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateAssignmentContext) GetCol() IMultipartIdentifierContext { return s.col }

func (s *UpdateAssignmentContext) SetCol(v IMultipartIdentifierContext) { s.col = v }

func (s *UpdateAssignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *UpdateAssignmentContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *UpdateAssignmentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UpdateAssignmentContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *UpdateAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUpdateAssignment(s)
	}
}

func (s *UpdateAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUpdateAssignment(s)
	}
}

func (p *DorisParser) UpdateAssignment() (localctx IUpdateAssignmentContext) {
	localctx = NewUpdateAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, DorisParserRULE_updateAssignment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5073)

		var _x = p.MultipartIdentifier()

		localctx.(*UpdateAssignmentContext).col = _x
	}
	{
		p.SetState(5074)
		p.Match(DorisParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5077)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_PAREN, DorisParserLEFT_BRACKET, DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADD, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBINARY, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCASE, DorisParserCAST, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATABASE, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXISTS, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserEXTRACT, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFALSE, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIF, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINTERVAL, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserKEY, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLEFT, DorisParserLESS, DorisParserLEVEL, DorisParserLIKE, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNOT, DorisParserNULL, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLACEHOLDER, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREGEXP, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRIGHT, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRIM, DorisParserTRUE, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserPLUS, DorisParserSUBTRACT, DorisParserASTERISK, DorisParserTILDE, DorisParserLOGICALNOT, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserATSIGN, DorisParserDOUBLEATSIGN, DorisParserSTRING_LITERAL, DorisParserINTEGER_VALUE, DorisParserEXPONENT_VALUE, DorisParserDECIMAL_VALUE, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		{
			p.SetState(5075)
			p.Expression()
		}

	case DorisParserDEFAULT:
		{
			p.SetState(5076)
			p.Match(DorisParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateAssignmentSeqContext is an interface to support dynamic dispatch.
type IUpdateAssignmentSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_updateAssignment returns the _updateAssignment rule contexts.
	Get_updateAssignment() IUpdateAssignmentContext

	// Set_updateAssignment sets the _updateAssignment rule contexts.
	Set_updateAssignment(IUpdateAssignmentContext)

	// GetAssignments returns the assignments rule context list.
	GetAssignments() []IUpdateAssignmentContext

	// SetAssignments sets the assignments rule context list.
	SetAssignments([]IUpdateAssignmentContext)

	// Getter signatures
	AllUpdateAssignment() []IUpdateAssignmentContext
	UpdateAssignment(i int) IUpdateAssignmentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsUpdateAssignmentSeqContext differentiates from other interfaces.
	IsUpdateAssignmentSeqContext()
}

type UpdateAssignmentSeqContext struct {
	antlr.BaseParserRuleContext
	parser            antlr.Parser
	_updateAssignment IUpdateAssignmentContext
	assignments       []IUpdateAssignmentContext
}

func NewEmptyUpdateAssignmentSeqContext() *UpdateAssignmentSeqContext {
	var p = new(UpdateAssignmentSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_updateAssignmentSeq
	return p
}

func InitEmptyUpdateAssignmentSeqContext(p *UpdateAssignmentSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_updateAssignmentSeq
}

func (*UpdateAssignmentSeqContext) IsUpdateAssignmentSeqContext() {}

func NewUpdateAssignmentSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateAssignmentSeqContext {
	var p = new(UpdateAssignmentSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_updateAssignmentSeq

	return p
}

func (s *UpdateAssignmentSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateAssignmentSeqContext) Get_updateAssignment() IUpdateAssignmentContext {
	return s._updateAssignment
}

func (s *UpdateAssignmentSeqContext) Set_updateAssignment(v IUpdateAssignmentContext) {
	s._updateAssignment = v
}

func (s *UpdateAssignmentSeqContext) GetAssignments() []IUpdateAssignmentContext {
	return s.assignments
}

func (s *UpdateAssignmentSeqContext) SetAssignments(v []IUpdateAssignmentContext) { s.assignments = v }

func (s *UpdateAssignmentSeqContext) AllUpdateAssignment() []IUpdateAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdateAssignmentContext); ok {
			len++
		}
	}

	tst := make([]IUpdateAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdateAssignmentContext); ok {
			tst[i] = t.(IUpdateAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *UpdateAssignmentSeqContext) UpdateAssignment(i int) IUpdateAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateAssignmentContext)
}

func (s *UpdateAssignmentSeqContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *UpdateAssignmentSeqContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *UpdateAssignmentSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateAssignmentSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateAssignmentSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUpdateAssignmentSeq(s)
	}
}

func (s *UpdateAssignmentSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUpdateAssignmentSeq(s)
	}
}

func (p *DorisParser) UpdateAssignmentSeq() (localctx IUpdateAssignmentSeqContext) {
	localctx = NewUpdateAssignmentSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, DorisParserRULE_updateAssignmentSeq)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5079)

		var _x = p.UpdateAssignment()

		localctx.(*UpdateAssignmentSeqContext)._updateAssignment = _x
	}
	localctx.(*UpdateAssignmentSeqContext).assignments = append(localctx.(*UpdateAssignmentSeqContext).assignments, localctx.(*UpdateAssignmentSeqContext)._updateAssignment)
	p.SetState(5084)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(5080)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5081)

			var _x = p.UpdateAssignment()

			localctx.(*UpdateAssignmentSeqContext)._updateAssignment = _x
		}
		localctx.(*UpdateAssignmentSeqContext).assignments = append(localctx.(*UpdateAssignmentSeqContext).assignments, localctx.(*UpdateAssignmentSeqContext)._updateAssignment)

		p.SetState(5086)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILateralViewContext is an interface to support dynamic dispatch.
type ILateralViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFunctionName returns the functionName rule contexts.
	GetFunctionName() IIdentifierContext

	// GetTableName returns the tableName rule contexts.
	GetTableName() IIdentifierContext

	// Get_identifier returns the _identifier rule contexts.
	Get_identifier() IIdentifierContext

	// SetFunctionName sets the functionName rule contexts.
	SetFunctionName(IIdentifierContext)

	// SetTableName sets the tableName rule contexts.
	SetTableName(IIdentifierContext)

	// Set_identifier sets the _identifier rule contexts.
	Set_identifier(IIdentifierContext)

	// GetColumnNames returns the columnNames rule context list.
	GetColumnNames() []IIdentifierContext

	// SetColumnNames sets the columnNames rule context list.
	SetColumnNames([]IIdentifierContext)

	// Getter signatures
	LATERAL() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AS() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLateralViewContext differentiates from other interfaces.
	IsLateralViewContext()
}

type LateralViewContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	functionName IIdentifierContext
	tableName    IIdentifierContext
	_identifier  IIdentifierContext
	columnNames  []IIdentifierContext
}

func NewEmptyLateralViewContext() *LateralViewContext {
	var p = new(LateralViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_lateralView
	return p
}

func InitEmptyLateralViewContext(p *LateralViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_lateralView
}

func (*LateralViewContext) IsLateralViewContext() {}

func NewLateralViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LateralViewContext {
	var p = new(LateralViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_lateralView

	return p
}

func (s *LateralViewContext) GetParser() antlr.Parser { return s.parser }

func (s *LateralViewContext) GetFunctionName() IIdentifierContext { return s.functionName }

func (s *LateralViewContext) GetTableName() IIdentifierContext { return s.tableName }

func (s *LateralViewContext) Get_identifier() IIdentifierContext { return s._identifier }

func (s *LateralViewContext) SetFunctionName(v IIdentifierContext) { s.functionName = v }

func (s *LateralViewContext) SetTableName(v IIdentifierContext) { s.tableName = v }

func (s *LateralViewContext) Set_identifier(v IIdentifierContext) { s._identifier = v }

func (s *LateralViewContext) GetColumnNames() []IIdentifierContext { return s.columnNames }

func (s *LateralViewContext) SetColumnNames(v []IIdentifierContext) { s.columnNames = v }

func (s *LateralViewContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLATERAL, 0)
}

func (s *LateralViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *LateralViewContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *LateralViewContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *LateralViewContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *LateralViewContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *LateralViewContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LateralViewContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LateralViewContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LateralViewContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *LateralViewContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *LateralViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LateralViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LateralViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLateralView(s)
	}
}

func (s *LateralViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLateralView(s)
	}
}

func (p *DorisParser) LateralView() (localctx ILateralViewContext) {
	localctx = NewLateralViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, DorisParserRULE_lateralView)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5087)
		p.Match(DorisParserLATERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5088)
		p.Match(DorisParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5089)

		var _x = p.Identifier()

		localctx.(*LateralViewContext).functionName = _x
	}
	{
		p.SetState(5090)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5099)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305884869834611068) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4610552282352573437) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4539691388691605019) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&2845980307192511093) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&8572566566736488189) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-304588910535901189) != 0) || ((int64((_la-391)) & ^0x3f) == 0 && ((int64(1)<<(_la-391))&1188948054525295071) != 0) || ((int64((_la-455)) & ^0x3f) == 0 && ((int64(1)<<(_la-455))&2458964612221977455) != 0) || ((int64((_la-524)) & ^0x3f) == 0 && ((int64(1)<<(_la-524))&923779367) != 0) {
		{
			p.SetState(5091)
			p.Expression()
		}
		p.SetState(5096)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(5092)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5093)
				p.Expression()
			}

			p.SetState(5098)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(5101)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5102)

		var _x = p.Identifier()

		localctx.(*LateralViewContext).tableName = _x
	}
	{
		p.SetState(5103)
		p.Match(DorisParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5104)

		var _x = p.Identifier()

		localctx.(*LateralViewContext)._identifier = _x
	}
	localctx.(*LateralViewContext).columnNames = append(localctx.(*LateralViewContext).columnNames, localctx.(*LateralViewContext)._identifier)
	p.SetState(5109)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 729, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5105)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5106)

				var _x = p.Identifier()

				localctx.(*LateralViewContext)._identifier = _x
			}
			localctx.(*LateralViewContext).columnNames = append(localctx.(*LateralViewContext).columnNames, localctx.(*LateralViewContext)._identifier)

		}
		p.SetState(5111)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 729, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryOrganizationContext is an interface to support dynamic dispatch.
type IQueryOrganizationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SortClause() ISortClauseContext
	LimitClause() ILimitClauseContext

	// IsQueryOrganizationContext differentiates from other interfaces.
	IsQueryOrganizationContext()
}

type QueryOrganizationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryOrganizationContext() *QueryOrganizationContext {
	var p = new(QueryOrganizationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_queryOrganization
	return p
}

func InitEmptyQueryOrganizationContext(p *QueryOrganizationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_queryOrganization
}

func (*QueryOrganizationContext) IsQueryOrganizationContext() {}

func NewQueryOrganizationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryOrganizationContext {
	var p = new(QueryOrganizationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_queryOrganization

	return p
}

func (s *QueryOrganizationContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryOrganizationContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *QueryOrganizationContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QueryOrganizationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryOrganizationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryOrganizationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterQueryOrganization(s)
	}
}

func (s *QueryOrganizationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitQueryOrganization(s)
	}
}

func (p *DorisParser) QueryOrganization() (localctx IQueryOrganizationContext) {
	localctx = NewQueryOrganizationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, DorisParserRULE_queryOrganization)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(5113)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 730, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5112)
			p.SortClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(5116)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 731, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5115)
			p.LimitClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortClauseContext is an interface to support dynamic dispatch.
type ISortClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSortClauseContext differentiates from other interfaces.
	IsSortClauseContext()
}

type SortClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortClauseContext() *SortClauseContext {
	var p = new(SortClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sortClause
	return p
}

func InitEmptySortClauseContext(p *SortClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sortClause
}

func (*SortClauseContext) IsSortClauseContext() {}

func NewSortClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortClauseContext {
	var p = new(SortClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_sortClause

	return p
}

func (s *SortClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisParserORDER, 0)
}

func (s *SortClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *SortClauseContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *SortClauseContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *SortClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *SortClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *SortClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSortClause(s)
	}
}

func (s *SortClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSortClause(s)
	}
}

func (p *DorisParser) SortClause() (localctx ISortClauseContext) {
	localctx = NewSortClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, DorisParserRULE_sortClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5118)
		p.Match(DorisParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5119)
		p.Match(DorisParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5120)
		p.SortItem()
	}
	p.SetState(5125)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 732, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5121)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5122)
				p.SortItem()
			}

		}
		p.SetState(5127)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 732, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortItemContext is an interface to support dynamic dispatch.
type ISortItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrdering returns the ordering token.
	GetOrdering() antlr.Token

	// SetOrdering sets the ordering token.
	SetOrdering(antlr.Token)

	// Getter signatures
	Expression() IExpressionContext
	NULLS() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsSortItemContext differentiates from other interfaces.
	IsSortItemContext()
}

type SortItemContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	ordering antlr.Token
}

func NewEmptySortItemContext() *SortItemContext {
	var p = new(SortItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sortItem
	return p
}

func InitEmptySortItemContext(p *SortItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sortItem
}

func (*SortItemContext) IsSortItemContext() {}

func NewSortItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortItemContext {
	var p = new(SortItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_sortItem

	return p
}

func (s *SortItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SortItemContext) GetOrdering() antlr.Token { return s.ordering }

func (s *SortItemContext) SetOrdering(v antlr.Token) { s.ordering = v }

func (s *SortItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SortItemContext) NULLS() antlr.TerminalNode {
	return s.GetToken(DorisParserNULLS, 0)
}

func (s *SortItemContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DorisParserFIRST, 0)
}

func (s *SortItemContext) LAST() antlr.TerminalNode {
	return s.GetToken(DorisParserLAST, 0)
}

func (s *SortItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(DorisParserASC, 0)
}

func (s *SortItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(DorisParserDESC, 0)
}

func (s *SortItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSortItem(s)
	}
}

func (s *SortItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSortItem(s)
	}
}

func (p *DorisParser) SortItem() (localctx ISortItemContext) {
	localctx = NewSortItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, DorisParserRULE_sortItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5128)
		p.Expression()
	}
	p.SetState(5130)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 733, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5129)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).ordering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserASC || _la == DorisParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).ordering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(5134)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 734, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5132)
			p.Match(DorisParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5133)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserFIRST || _la == DorisParserLAST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// GetOffset returns the offset token.
	GetOffset() antlr.Token

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// SetOffset sets the offset token.
	SetOffset(antlr.Token)

	// Getter signatures
	LIMIT() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	limit  antlr.Token
	offset antlr.Token
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_limitClause
	return p
}

func InitEmptyLimitClauseContext(p *LimitClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_limitClause
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) GetLimit() antlr.Token { return s.limit }

func (s *LimitClauseContext) GetOffset() antlr.Token { return s.offset }

func (s *LimitClauseContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *LimitClauseContext) SetOffset(v antlr.Token) { s.offset = v }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(DorisParserLIMIT, 0)
}

func (s *LimitClauseContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserINTEGER_VALUE)
}

func (s *LimitClauseContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, i)
}

func (s *LimitClauseContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(DorisParserOFFSET, 0)
}

func (s *LimitClauseContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, 0)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLimitClause(s)
	}
}

func (p *DorisParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, DorisParserRULE_limitClause)
	p.SetState(5146)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 735, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5136)
			p.Match(DorisParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5137)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*LimitClauseContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5138)
			p.Match(DorisParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5139)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*LimitClauseContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5140)
			p.Match(DorisParserOFFSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5141)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*LimitClauseContext).offset = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5142)
			p.Match(DorisParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5143)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*LimitClauseContext).offset = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5144)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5145)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*LimitClauseContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionClauseContext is an interface to support dynamic dispatch.
type IPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionClauseContext differentiates from other interfaces.
	IsPartitionClauseContext()
}

type PartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionClauseContext() *PartitionClauseContext {
	var p = new(PartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionClause
	return p
}

func InitEmptyPartitionClauseContext(p *PartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionClause
}

func (*PartitionClauseContext) IsPartitionClauseContext() {}

func NewPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionClauseContext {
	var p = new(PartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_partitionClause

	return p
}

func (s *PartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *PartitionClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *PartitionClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *PartitionClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *PartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPartitionClause(s)
	}
}

func (s *PartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPartitionClause(s)
	}
}

func (p *DorisParser) PartitionClause() (localctx IPartitionClauseContext) {
	localctx = NewPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, DorisParserRULE_partitionClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5148)
		p.Match(DorisParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5149)
		p.Match(DorisParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5150)
		p.Expression()
	}
	p.SetState(5155)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(5151)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5152)
			p.Expression()
		}

		p.SetState(5157)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinTypeContext is an interface to support dynamic dispatch.
type IJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INNER() antlr.TerminalNode
	CROSS() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	FULL() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	ANTI() antlr.TerminalNode

	// IsJoinTypeContext differentiates from other interfaces.
	IsJoinTypeContext()
}

type JoinTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinTypeContext() *JoinTypeContext {
	var p = new(JoinTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_joinType
	return p
}

func InitEmptyJoinTypeContext(p *JoinTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_joinType
}

func (*JoinTypeContext) IsJoinTypeContext() {}

func NewJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinTypeContext {
	var p = new(JoinTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_joinType

	return p
}

func (s *JoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinTypeContext) INNER() antlr.TerminalNode {
	return s.GetToken(DorisParserINNER, 0)
}

func (s *JoinTypeContext) CROSS() antlr.TerminalNode {
	return s.GetToken(DorisParserCROSS, 0)
}

func (s *JoinTypeContext) LEFT() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT, 0)
}

func (s *JoinTypeContext) OUTER() antlr.TerminalNode {
	return s.GetToken(DorisParserOUTER, 0)
}

func (s *JoinTypeContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT, 0)
}

func (s *JoinTypeContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserFULL, 0)
}

func (s *JoinTypeContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DorisParserSEMI, 0)
}

func (s *JoinTypeContext) ANTI() antlr.TerminalNode {
	return s.GetToken(DorisParserANTI, 0)
}

func (s *JoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterJoinType(s)
	}
}

func (s *JoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitJoinType(s)
	}
}

func (p *DorisParser) JoinType() (localctx IJoinTypeContext) {
	localctx = NewJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, DorisParserRULE_joinType)
	var _la int

	p.SetState(5182)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 741, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5159)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserINNER {
			{
				p.SetState(5158)
				p.Match(DorisParserINNER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5161)
			p.Match(DorisParserCROSS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5162)
			p.Match(DorisParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5164)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserOUTER {
			{
				p.SetState(5163)
				p.Match(DorisParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5166)
			p.Match(DorisParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5168)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserOUTER {
			{
				p.SetState(5167)
				p.Match(DorisParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5170)
			p.Match(DorisParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5172)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserOUTER {
			{
				p.SetState(5171)
				p.Match(DorisParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5174)
			p.Match(DorisParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5175)
			p.Match(DorisParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5176)
			p.Match(DorisParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5177)
			p.Match(DorisParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5178)
			p.Match(DorisParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5179)
			p.Match(DorisParserANTI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5180)
			p.Match(DorisParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5181)
			p.Match(DorisParserANTI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinCriteriaContext is an interface to support dynamic dispatch.
type IJoinCriteriaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext
	USING() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsJoinCriteriaContext differentiates from other interfaces.
	IsJoinCriteriaContext()
}

type JoinCriteriaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinCriteriaContext() *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_joinCriteria
	return p
}

func InitEmptyJoinCriteriaContext(p *JoinCriteriaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_joinCriteria
}

func (*JoinCriteriaContext) IsJoinCriteriaContext() {}

func NewJoinCriteriaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_joinCriteria

	return p
}

func (s *JoinCriteriaContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinCriteriaContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *JoinCriteriaContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *JoinCriteriaContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserUSING, 0)
}

func (s *JoinCriteriaContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *JoinCriteriaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinCriteriaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinCriteriaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitJoinCriteria(s)
	}
}

func (p *DorisParser) JoinCriteria() (localctx IJoinCriteriaContext) {
	localctx = NewJoinCriteriaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, DorisParserRULE_joinCriteria)
	p.SetState(5188)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5184)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5185)
			p.booleanExpression(0)
		}

	case DorisParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5186)
			p.Match(DorisParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5187)
			p.IdentifierList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	IdentifierSeq() IIdentifierSeqContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierList
	return p
}

func InitEmptyIdentifierListContext(p *IdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierList
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *IdentifierListContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *IdentifierListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (p *DorisParser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, DorisParserRULE_identifierList)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5190)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5191)
		p.IdentifierSeq()
	}
	{
		p.SetState(5192)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierSeqContext is an interface to support dynamic dispatch.
type IIdentifierSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_errorCapturingIdentifier returns the _errorCapturingIdentifier rule contexts.
	Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext

	// Set_errorCapturingIdentifier sets the _errorCapturingIdentifier rule contexts.
	Set_errorCapturingIdentifier(IErrorCapturingIdentifierContext)

	// GetIdent returns the ident rule context list.
	GetIdent() []IErrorCapturingIdentifierContext

	// SetIdent sets the ident rule context list.
	SetIdent([]IErrorCapturingIdentifierContext)

	// Getter signatures
	AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext
	ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentifierSeqContext differentiates from other interfaces.
	IsIdentifierSeqContext()
}

type IdentifierSeqContext struct {
	antlr.BaseParserRuleContext
	parser                    antlr.Parser
	_errorCapturingIdentifier IErrorCapturingIdentifierContext
	ident                     []IErrorCapturingIdentifierContext
}

func NewEmptyIdentifierSeqContext() *IdentifierSeqContext {
	var p = new(IdentifierSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierSeq
	return p
}

func InitEmptyIdentifierSeqContext(p *IdentifierSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifierSeq
}

func (*IdentifierSeqContext) IsIdentifierSeqContext() {}

func NewIdentifierSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierSeqContext {
	var p = new(IdentifierSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_identifierSeq

	return p
}

func (s *IdentifierSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierSeqContext) Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext {
	return s._errorCapturingIdentifier
}

func (s *IdentifierSeqContext) Set_errorCapturingIdentifier(v IErrorCapturingIdentifierContext) {
	s._errorCapturingIdentifier = v
}

func (s *IdentifierSeqContext) GetIdent() []IErrorCapturingIdentifierContext { return s.ident }

func (s *IdentifierSeqContext) SetIdent(v []IErrorCapturingIdentifierContext) { s.ident = v }

func (s *IdentifierSeqContext) AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IErrorCapturingIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			tst[i] = t.(IErrorCapturingIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierSeqContext) ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *IdentifierSeqContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *IdentifierSeqContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *IdentifierSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIdentifierSeq(s)
	}
}

func (s *IdentifierSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIdentifierSeq(s)
	}
}

func (p *DorisParser) IdentifierSeq() (localctx IIdentifierSeqContext) {
	localctx = NewIdentifierSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, DorisParserRULE_identifierSeq)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5194)

		var _x = p.ErrorCapturingIdentifier()

		localctx.(*IdentifierSeqContext)._errorCapturingIdentifier = _x
	}
	localctx.(*IdentifierSeqContext).ident = append(localctx.(*IdentifierSeqContext).ident, localctx.(*IdentifierSeqContext)._errorCapturingIdentifier)
	p.SetState(5199)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(5195)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5196)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*IdentifierSeqContext)._errorCapturingIdentifier = _x
		}
		localctx.(*IdentifierSeqContext).ident = append(localctx.(*IdentifierSeqContext).ident, localctx.(*IdentifierSeqContext)._errorCapturingIdentifier)

		p.SetState(5201)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptScanParamsContext is an interface to support dynamic dispatch.
type IOptScanParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFuncName returns the funcName rule contexts.
	GetFuncName() IIdentifierContext

	// GetMapParams returns the mapParams rule contexts.
	GetMapParams() IPropertyItemListContext

	// GetListParams returns the listParams rule contexts.
	GetListParams() IIdentifierSeqContext

	// SetFuncName sets the funcName rule contexts.
	SetFuncName(IIdentifierContext)

	// SetMapParams sets the mapParams rule contexts.
	SetMapParams(IPropertyItemListContext)

	// SetListParams sets the listParams rule contexts.
	SetListParams(IIdentifierSeqContext)

	// Getter signatures
	ATSIGN() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	PropertyItemList() IPropertyItemListContext
	IdentifierSeq() IIdentifierSeqContext

	// IsOptScanParamsContext differentiates from other interfaces.
	IsOptScanParamsContext()
}

type OptScanParamsContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	funcName   IIdentifierContext
	mapParams  IPropertyItemListContext
	listParams IIdentifierSeqContext
}

func NewEmptyOptScanParamsContext() *OptScanParamsContext {
	var p = new(OptScanParamsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_optScanParams
	return p
}

func InitEmptyOptScanParamsContext(p *OptScanParamsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_optScanParams
}

func (*OptScanParamsContext) IsOptScanParamsContext() {}

func NewOptScanParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptScanParamsContext {
	var p = new(OptScanParamsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_optScanParams

	return p
}

func (s *OptScanParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *OptScanParamsContext) GetFuncName() IIdentifierContext { return s.funcName }

func (s *OptScanParamsContext) GetMapParams() IPropertyItemListContext { return s.mapParams }

func (s *OptScanParamsContext) GetListParams() IIdentifierSeqContext { return s.listParams }

func (s *OptScanParamsContext) SetFuncName(v IIdentifierContext) { s.funcName = v }

func (s *OptScanParamsContext) SetMapParams(v IPropertyItemListContext) { s.mapParams = v }

func (s *OptScanParamsContext) SetListParams(v IIdentifierSeqContext) { s.listParams = v }

func (s *OptScanParamsContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserATSIGN, 0)
}

func (s *OptScanParamsContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *OptScanParamsContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *OptScanParamsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *OptScanParamsContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *OptScanParamsContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *OptScanParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptScanParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptScanParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterOptScanParams(s)
	}
}

func (s *OptScanParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitOptScanParams(s)
	}
}

func (p *DorisParser) OptScanParams() (localctx IOptScanParamsContext) {
	localctx = NewOptScanParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, DorisParserRULE_optScanParams)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5202)
		p.Match(DorisParserATSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5203)

		var _x = p.Identifier()

		localctx.(*OptScanParamsContext).funcName = _x
	}
	{
		p.SetState(5204)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5207)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 744, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5205)

			var _x = p.PropertyItemList()

			localctx.(*OptScanParamsContext).mapParams = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 744, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(5206)

			var _x = p.IdentifierSeq()

			localctx.(*OptScanParamsContext).listParams = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(5209)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationPrimaryContext is an interface to support dynamic dispatch.
type IRelationPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationPrimaryContext differentiates from other interfaces.
	IsRelationPrimaryContext()
}

type RelationPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationPrimaryContext() *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_relationPrimary
	return p
}

func InitEmptyRelationPrimaryContext(p *RelationPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_relationPrimary
}

func (*RelationPrimaryContext) IsRelationPrimaryContext() {}

func NewRelationPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_relationPrimary

	return p
}

func (s *RelationPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationPrimaryContext) CopyAll(ctx *RelationPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RelationPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableValuedFunctionContext struct {
	RelationPrimaryContext
	tvfName    IIdentifierContext
	properties IPropertyItemListContext
}

func NewTableValuedFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableValuedFunctionContext {
	var p = new(TableValuedFunctionContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableValuedFunctionContext) GetTvfName() IIdentifierContext { return s.tvfName }

func (s *TableValuedFunctionContext) GetProperties() IPropertyItemListContext { return s.properties }

func (s *TableValuedFunctionContext) SetTvfName(v IIdentifierContext) { s.tvfName = v }

func (s *TableValuedFunctionContext) SetProperties(v IPropertyItemListContext) { s.properties = v }

func (s *TableValuedFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableValuedFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *TableValuedFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *TableValuedFunctionContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *TableValuedFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableValuedFunctionContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *TableValuedFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTableValuedFunction(s)
	}
}

func (s *TableValuedFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTableValuedFunction(s)
	}
}

type RelationListContext struct {
	RelationPrimaryContext
}

func NewRelationListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationListContext {
	var p = new(RelationListContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *RelationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *RelationListContext) Relations() IRelationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationsContext)
}

func (s *RelationListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *RelationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRelationList(s)
	}
}

func (s *RelationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRelationList(s)
	}
}

type AliasedQueryContext struct {
	RelationPrimaryContext
}

func NewAliasedQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AliasedQueryContext {
	var p = new(AliasedQueryContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *AliasedQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasedQueryContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AliasedQueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *AliasedQueryContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AliasedQueryContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *AliasedQueryContext) AllLateralView() []ILateralViewContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILateralViewContext); ok {
			len++
		}
	}

	tst := make([]ILateralViewContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILateralViewContext); ok {
			tst[i] = t.(ILateralViewContext)
			i++
		}
	}

	return tst
}

func (s *AliasedQueryContext) LateralView(i int) ILateralViewContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILateralViewContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILateralViewContext)
}

func (s *AliasedQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAliasedQuery(s)
	}
}

func (s *AliasedQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAliasedQuery(s)
	}
}

type TableNameContext struct {
	RelationPrimaryContext
}

func NewTableNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableNameContext {
	var p = new(TableNameContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *TableNameContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *TableNameContext) OptScanParams() IOptScanParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptScanParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptScanParamsContext)
}

func (s *TableNameContext) MaterializedViewName() IMaterializedViewNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaterializedViewNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaterializedViewNameContext)
}

func (s *TableNameContext) TableSnapshot() ITableSnapshotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSnapshotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSnapshotContext)
}

func (s *TableNameContext) SpecifiedPartition() ISpecifiedPartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecifiedPartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecifiedPartitionContext)
}

func (s *TableNameContext) TabletList() ITabletListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabletListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabletListContext)
}

func (s *TableNameContext) Sample() ISampleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleContext)
}

func (s *TableNameContext) RelationHint() IRelationHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationHintContext)
}

func (s *TableNameContext) AllLateralView() []ILateralViewContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILateralViewContext); ok {
			len++
		}
	}

	tst := make([]ILateralViewContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILateralViewContext); ok {
			tst[i] = t.(ILateralViewContext)
			i++
		}
	}

	return tst
}

func (s *TableNameContext) LateralView(i int) ILateralViewContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILateralViewContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILateralViewContext)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (p *DorisParser) RelationPrimary() (localctx IRelationPrimaryContext) {
	localctx = NewRelationPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, DorisParserRULE_relationPrimary)
	var _la int

	var _alt int

	p.SetState(5262)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 755, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableNameContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5211)
			p.MultipartIdentifier()
		}
		p.SetState(5213)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 745, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5212)
				p.OptScanParams()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5216)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 746, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5215)
				p.MaterializedViewName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5219)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 747, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5218)
				p.TableSnapshot()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5222)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 748, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5221)
				p.SpecifiedPartition()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5225)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 749, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5224)
				p.TabletList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5227)
			p.TableAlias()
		}
		p.SetState(5229)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 750, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5228)
				p.Sample()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5232)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 751, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5231)
				p.RelationHint()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5237)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 752, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(5234)
					p.LateralView()
				}

			}
			p.SetState(5239)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 752, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		localctx = NewAliasedQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5240)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5241)
			p.Query()
		}
		{
			p.SetState(5242)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5243)
			p.TableAlias()
		}
		p.SetState(5247)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 753, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(5244)
					p.LateralView()
				}

			}
			p.SetState(5249)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 753, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 3:
		localctx = NewTableValuedFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5250)

			var _x = p.Identifier()

			localctx.(*TableValuedFunctionContext).tvfName = _x
		}
		{
			p.SetState(5251)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5253)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305884869834627456) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4609989332399152113) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4539834325203215899) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&2557745532860070517) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&8563559367481747053) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-305714810442743813) != 0) || ((int64((_la-391)) & ^0x3f) == 0 && ((int64(1)<<(_la-391))&1188948054525294943) != 0) || ((int64((_la-455)) & ^0x3f) == 0 && ((int64(1)<<(_la-455))&2458964612221715311) != 0) || ((int64((_la-525)) & ^0x3f) == 0 && ((int64(1)<<(_la-525))&461692929) != 0) {
			{
				p.SetState(5252)

				var _x = p.PropertyItemList()

				localctx.(*TableValuedFunctionContext).properties = _x
			}

		}
		{
			p.SetState(5255)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5256)
			p.TableAlias()
		}

	case 4:
		localctx = NewRelationListContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5258)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5259)
			p.Relations()
		}
		{
			p.SetState(5260)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaterializedViewNameContext is an interface to support dynamic dispatch.
type IMaterializedViewNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// Getter signatures
	INDEX() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsMaterializedViewNameContext differentiates from other interfaces.
	IsMaterializedViewNameContext()
}

type MaterializedViewNameContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	indexName IIdentifierContext
}

func NewEmptyMaterializedViewNameContext() *MaterializedViewNameContext {
	var p = new(MaterializedViewNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_materializedViewName
	return p
}

func InitEmptyMaterializedViewNameContext(p *MaterializedViewNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_materializedViewName
}

func (*MaterializedViewNameContext) IsMaterializedViewNameContext() {}

func NewMaterializedViewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaterializedViewNameContext {
	var p = new(MaterializedViewNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_materializedViewName

	return p
}

func (s *MaterializedViewNameContext) GetParser() antlr.Parser { return s.parser }

func (s *MaterializedViewNameContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *MaterializedViewNameContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *MaterializedViewNameContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *MaterializedViewNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MaterializedViewNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaterializedViewNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaterializedViewNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMaterializedViewName(s)
	}
}

func (s *MaterializedViewNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMaterializedViewName(s)
	}
}

func (p *DorisParser) MaterializedViewName() (localctx IMaterializedViewNameContext) {
	localctx = NewMaterializedViewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, DorisParserRULE_materializedViewName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5264)
		p.Match(DorisParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5265)

		var _x = p.Identifier()

		localctx.(*MaterializedViewNameContext).indexName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyClauseContext is an interface to support dynamic dispatch.
type IPropertyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFileProperties returns the fileProperties rule contexts.
	GetFileProperties() IPropertyItemListContext

	// SetFileProperties sets the fileProperties rule contexts.
	SetFileProperties(IPropertyItemListContext)

	// Getter signatures
	PROPERTIES() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	PropertyItemList() IPropertyItemListContext

	// IsPropertyClauseContext differentiates from other interfaces.
	IsPropertyClauseContext()
}

type PropertyClauseContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	fileProperties IPropertyItemListContext
}

func NewEmptyPropertyClauseContext() *PropertyClauseContext {
	var p = new(PropertyClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyClause
	return p
}

func InitEmptyPropertyClauseContext(p *PropertyClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyClause
}

func (*PropertyClauseContext) IsPropertyClauseContext() {}

func NewPropertyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyClauseContext {
	var p = new(PropertyClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_propertyClause

	return p
}

func (s *PropertyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyClauseContext) GetFileProperties() IPropertyItemListContext { return s.fileProperties }

func (s *PropertyClauseContext) SetFileProperties(v IPropertyItemListContext) { s.fileProperties = v }

func (s *PropertyClauseContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *PropertyClauseContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *PropertyClauseContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *PropertyClauseContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *PropertyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPropertyClause(s)
	}
}

func (s *PropertyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPropertyClause(s)
	}
}

func (p *DorisParser) PropertyClause() (localctx IPropertyClauseContext) {
	localctx = NewPropertyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, DorisParserRULE_propertyClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5267)
		p.Match(DorisParserPROPERTIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5268)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5269)

		var _x = p.PropertyItemList()

		localctx.(*PropertyClauseContext).fileProperties = _x
	}
	{
		p.SetState(5270)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyItemListContext is an interface to support dynamic dispatch.
type IPropertyItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_propertyItem returns the _propertyItem rule contexts.
	Get_propertyItem() IPropertyItemContext

	// Set_propertyItem sets the _propertyItem rule contexts.
	Set_propertyItem(IPropertyItemContext)

	// GetProperties returns the properties rule context list.
	GetProperties() []IPropertyItemContext

	// SetProperties sets the properties rule context list.
	SetProperties([]IPropertyItemContext)

	// Getter signatures
	AllPropertyItem() []IPropertyItemContext
	PropertyItem(i int) IPropertyItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPropertyItemListContext differentiates from other interfaces.
	IsPropertyItemListContext()
}

type PropertyItemListContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	_propertyItem IPropertyItemContext
	properties    []IPropertyItemContext
}

func NewEmptyPropertyItemListContext() *PropertyItemListContext {
	var p = new(PropertyItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyItemList
	return p
}

func InitEmptyPropertyItemListContext(p *PropertyItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyItemList
}

func (*PropertyItemListContext) IsPropertyItemListContext() {}

func NewPropertyItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyItemListContext {
	var p = new(PropertyItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_propertyItemList

	return p
}

func (s *PropertyItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyItemListContext) Get_propertyItem() IPropertyItemContext { return s._propertyItem }

func (s *PropertyItemListContext) Set_propertyItem(v IPropertyItemContext) { s._propertyItem = v }

func (s *PropertyItemListContext) GetProperties() []IPropertyItemContext { return s.properties }

func (s *PropertyItemListContext) SetProperties(v []IPropertyItemContext) { s.properties = v }

func (s *PropertyItemListContext) AllPropertyItem() []IPropertyItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyItemContext); ok {
			len++
		}
	}

	tst := make([]IPropertyItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyItemContext); ok {
			tst[i] = t.(IPropertyItemContext)
			i++
		}
	}

	return tst
}

func (s *PropertyItemListContext) PropertyItem(i int) IPropertyItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemContext)
}

func (s *PropertyItemListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *PropertyItemListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *PropertyItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPropertyItemList(s)
	}
}

func (s *PropertyItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPropertyItemList(s)
	}
}

func (p *DorisParser) PropertyItemList() (localctx IPropertyItemListContext) {
	localctx = NewPropertyItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, DorisParserRULE_propertyItemList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5272)

		var _x = p.PropertyItem()

		localctx.(*PropertyItemListContext)._propertyItem = _x
	}
	localctx.(*PropertyItemListContext).properties = append(localctx.(*PropertyItemListContext).properties, localctx.(*PropertyItemListContext)._propertyItem)
	p.SetState(5277)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(5273)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5274)

			var _x = p.PropertyItem()

			localctx.(*PropertyItemListContext)._propertyItem = _x
		}
		localctx.(*PropertyItemListContext).properties = append(localctx.(*PropertyItemListContext).properties, localctx.(*PropertyItemListContext)._propertyItem)

		p.SetState(5279)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyItemContext is an interface to support dynamic dispatch.
type IPropertyItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IPropertyKeyContext

	// GetValue returns the value rule contexts.
	GetValue() IPropertyValueContext

	// SetKey sets the key rule contexts.
	SetKey(IPropertyKeyContext)

	// SetValue sets the value rule contexts.
	SetValue(IPropertyValueContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	PropertyKey() IPropertyKeyContext
	PropertyValue() IPropertyValueContext

	// IsPropertyItemContext differentiates from other interfaces.
	IsPropertyItemContext()
}

type PropertyItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IPropertyKeyContext
	value  IPropertyValueContext
}

func NewEmptyPropertyItemContext() *PropertyItemContext {
	var p = new(PropertyItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyItem
	return p
}

func InitEmptyPropertyItemContext(p *PropertyItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyItem
}

func (*PropertyItemContext) IsPropertyItemContext() {}

func NewPropertyItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyItemContext {
	var p = new(PropertyItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_propertyItem

	return p
}

func (s *PropertyItemContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyItemContext) GetKey() IPropertyKeyContext { return s.key }

func (s *PropertyItemContext) GetValue() IPropertyValueContext { return s.value }

func (s *PropertyItemContext) SetKey(v IPropertyKeyContext) { s.key = v }

func (s *PropertyItemContext) SetValue(v IPropertyValueContext) { s.value = v }

func (s *PropertyItemContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *PropertyItemContext) PropertyKey() IPropertyKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyKeyContext)
}

func (s *PropertyItemContext) PropertyValue() IPropertyValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyValueContext)
}

func (s *PropertyItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPropertyItem(s)
	}
}

func (s *PropertyItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPropertyItem(s)
	}
}

func (p *DorisParser) PropertyItem() (localctx IPropertyItemContext) {
	localctx = NewPropertyItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, DorisParserRULE_propertyItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5280)

		var _x = p.PropertyKey()

		localctx.(*PropertyItemContext).key = _x
	}
	{
		p.SetState(5281)
		p.Match(DorisParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5282)

		var _x = p.PropertyValue()

		localctx.(*PropertyItemContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyKeyContext is an interface to support dynamic dispatch.
type IPropertyKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Constant() IConstantContext

	// IsPropertyKeyContext differentiates from other interfaces.
	IsPropertyKeyContext()
}

type PropertyKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyKeyContext() *PropertyKeyContext {
	var p = new(PropertyKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyKey
	return p
}

func InitEmptyPropertyKeyContext(p *PropertyKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyKey
}

func (*PropertyKeyContext) IsPropertyKeyContext() {}

func NewPropertyKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyKeyContext {
	var p = new(PropertyKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_propertyKey

	return p
}

func (s *PropertyKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyKeyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyKeyContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *PropertyKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPropertyKey(s)
	}
}

func (s *PropertyKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPropertyKey(s)
	}
}

func (p *DorisParser) PropertyKey() (localctx IPropertyKeyContext) {
	localctx = NewPropertyKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, DorisParserRULE_propertyKey)
	p.SetState(5286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 757, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5284)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5285)
			p.Constant()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyValueContext is an interface to support dynamic dispatch.
type IPropertyValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Constant() IConstantContext

	// IsPropertyValueContext differentiates from other interfaces.
	IsPropertyValueContext()
}

type PropertyValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyValueContext() *PropertyValueContext {
	var p = new(PropertyValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyValue
	return p
}

func InitEmptyPropertyValueContext(p *PropertyValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_propertyValue
}

func (*PropertyValueContext) IsPropertyValueContext() {}

func NewPropertyValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyValueContext {
	var p = new(PropertyValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_propertyValue

	return p
}

func (s *PropertyValueContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyValueContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyValueContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *PropertyValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPropertyValue(s)
	}
}

func (s *PropertyValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPropertyValue(s)
	}
}

func (p *DorisParser) PropertyValue() (localctx IPropertyValueContext) {
	localctx = NewPropertyValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, DorisParserRULE_propertyValue)
	p.SetState(5290)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 758, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5288)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5289)
			p.Constant()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableAliasContext is an interface to support dynamic dispatch.
type ITableAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StrictIdentifier() IStrictIdentifierContext
	AS() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsTableAliasContext differentiates from other interfaces.
	IsTableAliasContext()
}

type TableAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableAliasContext() *TableAliasContext {
	var p = new(TableAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tableAlias
	return p
}

func InitEmptyTableAliasContext(p *TableAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tableAlias
}

func (*TableAliasContext) IsTableAliasContext() {}

func NewTableAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableAliasContext {
	var p = new(TableAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_tableAlias

	return p
}

func (s *TableAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *TableAliasContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *TableAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *TableAliasContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *TableAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTableAlias(s)
	}
}

func (s *TableAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTableAlias(s)
	}
}

func (p *DorisParser) TableAlias() (localctx ITableAliasContext) {
	localctx = NewTableAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, DorisParserRULE_tableAlias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5299)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 761, p.GetParserRuleContext()) == 1 {
		p.SetState(5293)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAS {
			{
				p.SetState(5292)
				p.Match(DorisParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5295)
			p.StrictIdentifier()
		}
		p.SetState(5297)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 760, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5296)
				p.IdentifierList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultipartIdentifierContext is an interface to support dynamic dispatch.
type IMultipartIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_errorCapturingIdentifier returns the _errorCapturingIdentifier rule contexts.
	Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext

	// Set_errorCapturingIdentifier sets the _errorCapturingIdentifier rule contexts.
	Set_errorCapturingIdentifier(IErrorCapturingIdentifierContext)

	// GetParts returns the parts rule context list.
	GetParts() []IErrorCapturingIdentifierContext

	// SetParts sets the parts rule context list.
	SetParts([]IErrorCapturingIdentifierContext)

	// Getter signatures
	AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext
	ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsMultipartIdentifierContext differentiates from other interfaces.
	IsMultipartIdentifierContext()
}

type MultipartIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser                    antlr.Parser
	_errorCapturingIdentifier IErrorCapturingIdentifierContext
	parts                     []IErrorCapturingIdentifierContext
}

func NewEmptyMultipartIdentifierContext() *MultipartIdentifierContext {
	var p = new(MultipartIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_multipartIdentifier
	return p
}

func InitEmptyMultipartIdentifierContext(p *MultipartIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_multipartIdentifier
}

func (*MultipartIdentifierContext) IsMultipartIdentifierContext() {}

func NewMultipartIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipartIdentifierContext {
	var p = new(MultipartIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_multipartIdentifier

	return p
}

func (s *MultipartIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipartIdentifierContext) Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext {
	return s._errorCapturingIdentifier
}

func (s *MultipartIdentifierContext) Set_errorCapturingIdentifier(v IErrorCapturingIdentifierContext) {
	s._errorCapturingIdentifier = v
}

func (s *MultipartIdentifierContext) GetParts() []IErrorCapturingIdentifierContext { return s.parts }

func (s *MultipartIdentifierContext) SetParts(v []IErrorCapturingIdentifierContext) { s.parts = v }

func (s *MultipartIdentifierContext) AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IErrorCapturingIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			tst[i] = t.(IErrorCapturingIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *MultipartIdentifierContext) ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *MultipartIdentifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(DorisParserDOT)
}

func (s *MultipartIdentifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, i)
}

func (s *MultipartIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipartIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipartIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMultipartIdentifier(s)
	}
}

func (s *MultipartIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMultipartIdentifier(s)
	}
}

func (p *DorisParser) MultipartIdentifier() (localctx IMultipartIdentifierContext) {
	localctx = NewMultipartIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, DorisParserRULE_multipartIdentifier)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5301)

		var _x = p.ErrorCapturingIdentifier()

		localctx.(*MultipartIdentifierContext)._errorCapturingIdentifier = _x
	}
	localctx.(*MultipartIdentifierContext).parts = append(localctx.(*MultipartIdentifierContext).parts, localctx.(*MultipartIdentifierContext)._errorCapturingIdentifier)
	p.SetState(5306)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 762, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5302)
				p.Match(DorisParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5303)

				var _x = p.ErrorCapturingIdentifier()

				localctx.(*MultipartIdentifierContext)._errorCapturingIdentifier = _x
			}
			localctx.(*MultipartIdentifierContext).parts = append(localctx.(*MultipartIdentifierContext).parts, localctx.(*MultipartIdentifierContext)._errorCapturingIdentifier)

		}
		p.SetState(5308)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 762, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleColumnDefsContext is an interface to support dynamic dispatch.
type ISimpleColumnDefsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_simpleColumnDef returns the _simpleColumnDef rule contexts.
	Get_simpleColumnDef() ISimpleColumnDefContext

	// Set_simpleColumnDef sets the _simpleColumnDef rule contexts.
	Set_simpleColumnDef(ISimpleColumnDefContext)

	// GetCols returns the cols rule context list.
	GetCols() []ISimpleColumnDefContext

	// SetCols sets the cols rule context list.
	SetCols([]ISimpleColumnDefContext)

	// Getter signatures
	AllSimpleColumnDef() []ISimpleColumnDefContext
	SimpleColumnDef(i int) ISimpleColumnDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSimpleColumnDefsContext differentiates from other interfaces.
	IsSimpleColumnDefsContext()
}

type SimpleColumnDefsContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	_simpleColumnDef ISimpleColumnDefContext
	cols             []ISimpleColumnDefContext
}

func NewEmptySimpleColumnDefsContext() *SimpleColumnDefsContext {
	var p = new(SimpleColumnDefsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_simpleColumnDefs
	return p
}

func InitEmptySimpleColumnDefsContext(p *SimpleColumnDefsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_simpleColumnDefs
}

func (*SimpleColumnDefsContext) IsSimpleColumnDefsContext() {}

func NewSimpleColumnDefsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleColumnDefsContext {
	var p = new(SimpleColumnDefsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_simpleColumnDefs

	return p
}

func (s *SimpleColumnDefsContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleColumnDefsContext) Get_simpleColumnDef() ISimpleColumnDefContext {
	return s._simpleColumnDef
}

func (s *SimpleColumnDefsContext) Set_simpleColumnDef(v ISimpleColumnDefContext) {
	s._simpleColumnDef = v
}

func (s *SimpleColumnDefsContext) GetCols() []ISimpleColumnDefContext { return s.cols }

func (s *SimpleColumnDefsContext) SetCols(v []ISimpleColumnDefContext) { s.cols = v }

func (s *SimpleColumnDefsContext) AllSimpleColumnDef() []ISimpleColumnDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleColumnDefContext); ok {
			len++
		}
	}

	tst := make([]ISimpleColumnDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleColumnDefContext); ok {
			tst[i] = t.(ISimpleColumnDefContext)
			i++
		}
	}

	return tst
}

func (s *SimpleColumnDefsContext) SimpleColumnDef(i int) ISimpleColumnDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleColumnDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleColumnDefContext)
}

func (s *SimpleColumnDefsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *SimpleColumnDefsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *SimpleColumnDefsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleColumnDefsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleColumnDefsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSimpleColumnDefs(s)
	}
}

func (s *SimpleColumnDefsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSimpleColumnDefs(s)
	}
}

func (p *DorisParser) SimpleColumnDefs() (localctx ISimpleColumnDefsContext) {
	localctx = NewSimpleColumnDefsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, DorisParserRULE_simpleColumnDefs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5309)

		var _x = p.SimpleColumnDef()

		localctx.(*SimpleColumnDefsContext)._simpleColumnDef = _x
	}
	localctx.(*SimpleColumnDefsContext).cols = append(localctx.(*SimpleColumnDefsContext).cols, localctx.(*SimpleColumnDefsContext)._simpleColumnDef)
	p.SetState(5314)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(5310)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5311)

			var _x = p.SimpleColumnDef()

			localctx.(*SimpleColumnDefsContext)._simpleColumnDef = _x
		}
		localctx.(*SimpleColumnDefsContext).cols = append(localctx.(*SimpleColumnDefsContext).cols, localctx.(*SimpleColumnDefsContext)._simpleColumnDef)

		p.SetState(5316)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleColumnDefContext is an interface to support dynamic dispatch.
type ISimpleColumnDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetComment returns the comment token.
	GetComment() antlr.Token

	// SetComment sets the comment token.
	SetComment(antlr.Token)

	// GetColName returns the colName rule contexts.
	GetColName() IIdentifierContext

	// SetColName sets the colName rule contexts.
	SetColName(IIdentifierContext)

	// Getter signatures
	Identifier() IIdentifierContext
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsSimpleColumnDefContext differentiates from other interfaces.
	IsSimpleColumnDefContext()
}

type SimpleColumnDefContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	colName IIdentifierContext
	comment antlr.Token
}

func NewEmptySimpleColumnDefContext() *SimpleColumnDefContext {
	var p = new(SimpleColumnDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_simpleColumnDef
	return p
}

func InitEmptySimpleColumnDefContext(p *SimpleColumnDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_simpleColumnDef
}

func (*SimpleColumnDefContext) IsSimpleColumnDefContext() {}

func NewSimpleColumnDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleColumnDefContext {
	var p = new(SimpleColumnDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_simpleColumnDef

	return p
}

func (s *SimpleColumnDefContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleColumnDefContext) GetComment() antlr.Token { return s.comment }

func (s *SimpleColumnDefContext) SetComment(v antlr.Token) { s.comment = v }

func (s *SimpleColumnDefContext) GetColName() IIdentifierContext { return s.colName }

func (s *SimpleColumnDefContext) SetColName(v IIdentifierContext) { s.colName = v }

func (s *SimpleColumnDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SimpleColumnDefContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *SimpleColumnDefContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *SimpleColumnDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleColumnDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleColumnDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSimpleColumnDef(s)
	}
}

func (s *SimpleColumnDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSimpleColumnDef(s)
	}
}

func (p *DorisParser) SimpleColumnDef() (localctx ISimpleColumnDefContext) {
	localctx = NewSimpleColumnDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, DorisParserRULE_simpleColumnDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5317)

		var _x = p.Identifier()

		localctx.(*SimpleColumnDefContext).colName = _x
	}
	p.SetState(5320)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserCOMMENT {
		{
			p.SetState(5318)
			p.Match(DorisParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5319)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*SimpleColumnDefContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDefsContext is an interface to support dynamic dispatch.
type IColumnDefsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_columnDef returns the _columnDef rule contexts.
	Get_columnDef() IColumnDefContext

	// Set_columnDef sets the _columnDef rule contexts.
	Set_columnDef(IColumnDefContext)

	// GetCols returns the cols rule context list.
	GetCols() []IColumnDefContext

	// SetCols sets the cols rule context list.
	SetCols([]IColumnDefContext)

	// Getter signatures
	AllColumnDef() []IColumnDefContext
	ColumnDef(i int) IColumnDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnDefsContext differentiates from other interfaces.
	IsColumnDefsContext()
}

type ColumnDefsContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	_columnDef IColumnDefContext
	cols       []IColumnDefContext
}

func NewEmptyColumnDefsContext() *ColumnDefsContext {
	var p = new(ColumnDefsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_columnDefs
	return p
}

func InitEmptyColumnDefsContext(p *ColumnDefsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_columnDefs
}

func (*ColumnDefsContext) IsColumnDefsContext() {}

func NewColumnDefsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefsContext {
	var p = new(ColumnDefsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_columnDefs

	return p
}

func (s *ColumnDefsContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefsContext) Get_columnDef() IColumnDefContext { return s._columnDef }

func (s *ColumnDefsContext) Set_columnDef(v IColumnDefContext) { s._columnDef = v }

func (s *ColumnDefsContext) GetCols() []IColumnDefContext { return s.cols }

func (s *ColumnDefsContext) SetCols(v []IColumnDefContext) { s.cols = v }

func (s *ColumnDefsContext) AllColumnDef() []IColumnDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnDefContext); ok {
			len++
		}
	}

	tst := make([]IColumnDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnDefContext); ok {
			tst[i] = t.(IColumnDefContext)
			i++
		}
	}

	return tst
}

func (s *ColumnDefsContext) ColumnDef(i int) IColumnDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefContext)
}

func (s *ColumnDefsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ColumnDefsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ColumnDefsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterColumnDefs(s)
	}
}

func (s *ColumnDefsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitColumnDefs(s)
	}
}

func (p *DorisParser) ColumnDefs() (localctx IColumnDefsContext) {
	localctx = NewColumnDefsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, DorisParserRULE_columnDefs)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5322)

		var _x = p.ColumnDef()

		localctx.(*ColumnDefsContext)._columnDef = _x
	}
	localctx.(*ColumnDefsContext).cols = append(localctx.(*ColumnDefsContext).cols, localctx.(*ColumnDefsContext)._columnDef)
	p.SetState(5327)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 765, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5323)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5324)

				var _x = p.ColumnDef()

				localctx.(*ColumnDefsContext)._columnDef = _x
			}
			localctx.(*ColumnDefsContext).cols = append(localctx.(*ColumnDefsContext).cols, localctx.(*ColumnDefsContext)._columnDef)

		}
		p.SetState(5329)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 765, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDefContext is an interface to support dynamic dispatch.
type IColumnDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNullable returns the nullable token.
	GetNullable() antlr.Token

	// GetNullValue returns the nullValue token.
	GetNullValue() antlr.Token

	// GetStringValue returns the stringValue token.
	GetStringValue() antlr.Token

	// GetDefaultTimestamp returns the defaultTimestamp token.
	GetDefaultTimestamp() antlr.Token

	// GetComment returns the comment token.
	GetComment() antlr.Token

	// SetNullable sets the nullable token.
	SetNullable(antlr.Token)

	// SetNullValue sets the nullValue token.
	SetNullValue(antlr.Token)

	// SetStringValue sets the stringValue token.
	SetStringValue(antlr.Token)

	// SetDefaultTimestamp sets the defaultTimestamp token.
	SetDefaultTimestamp(antlr.Token)

	// SetComment sets the comment token.
	SetComment(antlr.Token)

	// GetColName returns the colName rule contexts.
	GetColName() IIdentifierContext

	// GetType_ returns the type_ rule contexts.
	GetType_() IDataTypeContext

	// GetAggType returns the aggType rule contexts.
	GetAggType() IAggTypeDefContext

	// GetGeneratedExpr returns the generatedExpr rule contexts.
	GetGeneratedExpr() IExpressionContext

	// GetAutoIncInitValue returns the autoIncInitValue rule contexts.
	GetAutoIncInitValue() INumberContext

	// GetDefaultValuePrecision returns the defaultValuePrecision rule contexts.
	GetDefaultValuePrecision() INumberContext

	// GetOnUpdateValuePrecision returns the onUpdateValuePrecision rule contexts.
	GetOnUpdateValuePrecision() INumberContext

	// SetColName sets the colName rule contexts.
	SetColName(IIdentifierContext)

	// SetType_ sets the type_ rule contexts.
	SetType_(IDataTypeContext)

	// SetAggType sets the aggType rule contexts.
	SetAggType(IAggTypeDefContext)

	// SetGeneratedExpr sets the generatedExpr rule contexts.
	SetGeneratedExpr(IExpressionContext)

	// SetAutoIncInitValue sets the autoIncInitValue rule contexts.
	SetAutoIncInitValue(INumberContext)

	// SetDefaultValuePrecision sets the defaultValuePrecision rule contexts.
	SetDefaultValuePrecision(INumberContext)

	// SetOnUpdateValuePrecision sets the onUpdateValuePrecision rule contexts.
	SetOnUpdateValuePrecision(INumberContext)

	// Getter signatures
	Identifier() IIdentifierContext
	DataType() IDataTypeContext
	KEY() antlr.TerminalNode
	AS() antlr.TerminalNode
	AllLEFT_PAREN() []antlr.TerminalNode
	LEFT_PAREN(i int) antlr.TerminalNode
	AllRIGHT_PAREN() []antlr.TerminalNode
	RIGHT_PAREN(i int) antlr.TerminalNode
	AUTO_INCREMENT() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	ON() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	AllCURRENT_TIMESTAMP() []antlr.TerminalNode
	CURRENT_TIMESTAMP(i int) antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	AggTypeDef() IAggTypeDefContext
	Expression() IExpressionContext
	AllNULL() []antlr.TerminalNode
	NULL(i int) antlr.TerminalNode
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	DECIMAL_VALUE() antlr.TerminalNode
	PI() antlr.TerminalNode
	E() antlr.TerminalNode
	BITMAP_EMPTY() antlr.TerminalNode
	CURRENT_DATE() antlr.TerminalNode
	GENERATED() antlr.TerminalNode
	ALWAYS() antlr.TerminalNode
	NOT() antlr.TerminalNode
	AllNumber() []INumberContext
	Number(i int) INumberContext
	SUBTRACT() antlr.TerminalNode

	// IsColumnDefContext differentiates from other interfaces.
	IsColumnDefContext()
}

type ColumnDefContext struct {
	antlr.BaseParserRuleContext
	parser                 antlr.Parser
	colName                IIdentifierContext
	type_                  IDataTypeContext
	aggType                IAggTypeDefContext
	generatedExpr          IExpressionContext
	nullable               antlr.Token
	autoIncInitValue       INumberContext
	nullValue              antlr.Token
	stringValue            antlr.Token
	defaultTimestamp       antlr.Token
	defaultValuePrecision  INumberContext
	onUpdateValuePrecision INumberContext
	comment                antlr.Token
}

func NewEmptyColumnDefContext() *ColumnDefContext {
	var p = new(ColumnDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_columnDef
	return p
}

func InitEmptyColumnDefContext(p *ColumnDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_columnDef
}

func (*ColumnDefContext) IsColumnDefContext() {}

func NewColumnDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefContext {
	var p = new(ColumnDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_columnDef

	return p
}

func (s *ColumnDefContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefContext) GetNullable() antlr.Token { return s.nullable }

func (s *ColumnDefContext) GetNullValue() antlr.Token { return s.nullValue }

func (s *ColumnDefContext) GetStringValue() antlr.Token { return s.stringValue }

func (s *ColumnDefContext) GetDefaultTimestamp() antlr.Token { return s.defaultTimestamp }

func (s *ColumnDefContext) GetComment() antlr.Token { return s.comment }

func (s *ColumnDefContext) SetNullable(v antlr.Token) { s.nullable = v }

func (s *ColumnDefContext) SetNullValue(v antlr.Token) { s.nullValue = v }

func (s *ColumnDefContext) SetStringValue(v antlr.Token) { s.stringValue = v }

func (s *ColumnDefContext) SetDefaultTimestamp(v antlr.Token) { s.defaultTimestamp = v }

func (s *ColumnDefContext) SetComment(v antlr.Token) { s.comment = v }

func (s *ColumnDefContext) GetColName() IIdentifierContext { return s.colName }

func (s *ColumnDefContext) GetType_() IDataTypeContext { return s.type_ }

func (s *ColumnDefContext) GetAggType() IAggTypeDefContext { return s.aggType }

func (s *ColumnDefContext) GetGeneratedExpr() IExpressionContext { return s.generatedExpr }

func (s *ColumnDefContext) GetAutoIncInitValue() INumberContext { return s.autoIncInitValue }

func (s *ColumnDefContext) GetDefaultValuePrecision() INumberContext { return s.defaultValuePrecision }

func (s *ColumnDefContext) GetOnUpdateValuePrecision() INumberContext {
	return s.onUpdateValuePrecision
}

func (s *ColumnDefContext) SetColName(v IIdentifierContext) { s.colName = v }

func (s *ColumnDefContext) SetType_(v IDataTypeContext) { s.type_ = v }

func (s *ColumnDefContext) SetAggType(v IAggTypeDefContext) { s.aggType = v }

func (s *ColumnDefContext) SetGeneratedExpr(v IExpressionContext) { s.generatedExpr = v }

func (s *ColumnDefContext) SetAutoIncInitValue(v INumberContext) { s.autoIncInitValue = v }

func (s *ColumnDefContext) SetDefaultValuePrecision(v INumberContext) { s.defaultValuePrecision = v }

func (s *ColumnDefContext) SetOnUpdateValuePrecision(v INumberContext) { s.onUpdateValuePrecision = v }

func (s *ColumnDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnDefContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ColumnDefContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserKEY, 0)
}

func (s *ColumnDefContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *ColumnDefContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserLEFT_PAREN)
}

func (s *ColumnDefContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, i)
}

func (s *ColumnDefContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserRIGHT_PAREN)
}

func (s *ColumnDefContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, i)
}

func (s *ColumnDefContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO_INCREMENT, 0)
}

func (s *ColumnDefContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *ColumnDefContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserON, 0)
}

func (s *ColumnDefContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(DorisParserUPDATE, 0)
}

func (s *ColumnDefContext) AllCURRENT_TIMESTAMP() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCURRENT_TIMESTAMP)
}

func (s *ColumnDefContext) CURRENT_TIMESTAMP(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_TIMESTAMP, i)
}

func (s *ColumnDefContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *ColumnDefContext) AggTypeDef() IAggTypeDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggTypeDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggTypeDefContext)
}

func (s *ColumnDefContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ColumnDefContext) AllNULL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserNULL)
}

func (s *ColumnDefContext) NULL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserNULL, i)
}

func (s *ColumnDefContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSTRING_LITERAL)
}

func (s *ColumnDefContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, i)
}

func (s *ColumnDefContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *ColumnDefContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserDECIMAL_VALUE, 0)
}

func (s *ColumnDefContext) PI() antlr.TerminalNode {
	return s.GetToken(DorisParserPI, 0)
}

func (s *ColumnDefContext) E() antlr.TerminalNode {
	return s.GetToken(DorisParserE, 0)
}

func (s *ColumnDefContext) BITMAP_EMPTY() antlr.TerminalNode {
	return s.GetToken(DorisParserBITMAP_EMPTY, 0)
}

func (s *ColumnDefContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_DATE, 0)
}

func (s *ColumnDefContext) GENERATED() antlr.TerminalNode {
	return s.GetToken(DorisParserGENERATED, 0)
}

func (s *ColumnDefContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(DorisParserALWAYS, 0)
}

func (s *ColumnDefContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *ColumnDefContext) AllNumber() []INumberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INumberContext); ok {
			len++
		}
	}

	tst := make([]INumberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INumberContext); ok {
			tst[i] = t.(INumberContext)
			i++
		}
	}

	return tst
}

func (s *ColumnDefContext) Number(i int) INumberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *ColumnDefContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(DorisParserSUBTRACT, 0)
}

func (s *ColumnDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterColumnDef(s)
	}
}

func (s *ColumnDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitColumnDef(s)
	}
}

func (p *DorisParser) ColumnDef() (localctx IColumnDefContext) {
	localctx = NewColumnDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, DorisParserRULE_columnDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5330)

		var _x = p.Identifier()

		localctx.(*ColumnDefContext).colName = _x
	}
	{
		p.SetState(5331)

		var _x = p.DataType()

		localctx.(*ColumnDefContext).type_ = _x
	}
	p.SetState(5333)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserKEY {
		{
			p.SetState(5332)
			p.Match(DorisParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5336)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserBITMAP_UNION || _la == DorisParserGENERIC || _la == DorisParserHLL_UNION || _la == DorisParserMAX || _la == DorisParserMIN || ((int64((_la-361)) & ^0x3f) == 0 && ((int64(1)<<(_la-361))&6291457) != 0) || _la == DorisParserSUM {
		{
			p.SetState(5335)

			var _x = p.AggTypeDef()

			localctx.(*ColumnDefContext).aggType = _x
		}

	}
	p.SetState(5347)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserAS || _la == DorisParserGENERATED {
		p.SetState(5340)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserGENERATED {
			{
				p.SetState(5338)
				p.Match(DorisParserGENERATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5339)
				p.Match(DorisParserALWAYS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5342)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5343)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5344)

			var _x = p.Expression()

			localctx.(*ColumnDefContext).generatedExpr = _x
		}
		{
			p.SetState(5345)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5353)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserNOT || _la == DorisParserNULL {
		p.SetState(5350)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(5349)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5352)

			var _m = p.Match(DorisParserNULL)

			localctx.(*ColumnDefContext).nullable = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5362)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserAUTO_INCREMENT {
		{
			p.SetState(5355)
			p.Match(DorisParserAUTO_INCREMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5360)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(5356)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5357)

				var _x = p.Number()

				localctx.(*ColumnDefContext).autoIncInitValue = _x
			}
			{
				p.SetState(5358)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	p.SetState(5388)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserDEFAULT {
		{
			p.SetState(5364)
			p.Match(DorisParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5386)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 777, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5365)

				var _m = p.Match(DorisParserNULL)

				localctx.(*ColumnDefContext).nullValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			p.SetState(5367)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserSUBTRACT {
				{
					p.SetState(5366)
					p.Match(DorisParserSUBTRACT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(5369)
				p.Match(DorisParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			p.SetState(5371)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserSUBTRACT {
				{
					p.SetState(5370)
					p.Match(DorisParserSUBTRACT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(5373)
				p.Match(DorisParserDECIMAL_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 4:
			{
				p.SetState(5374)
				p.Match(DorisParserPI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 5:
			{
				p.SetState(5375)
				p.Match(DorisParserE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 6:
			{
				p.SetState(5376)
				p.Match(DorisParserBITMAP_EMPTY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 7:
			{
				p.SetState(5377)

				var _m = p.Match(DorisParserSTRING_LITERAL)

				localctx.(*ColumnDefContext).stringValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 8:
			{
				p.SetState(5378)
				p.Match(DorisParserCURRENT_DATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 9:
			{
				p.SetState(5379)

				var _m = p.Match(DorisParserCURRENT_TIMESTAMP)

				localctx.(*ColumnDefContext).defaultTimestamp = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5384)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserLEFT_PAREN {
				{
					p.SetState(5380)
					p.Match(DorisParserLEFT_PAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5381)

					var _x = p.Number()

					localctx.(*ColumnDefContext).defaultValuePrecision = _x
				}
				{
					p.SetState(5382)
					p.Match(DorisParserRIGHT_PAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	}
	p.SetState(5399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserON {
		{
			p.SetState(5390)
			p.Match(DorisParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5391)
			p.Match(DorisParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5392)
			p.Match(DorisParserCURRENT_TIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5397)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(5393)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5394)

				var _x = p.Number()

				localctx.(*ColumnDefContext).onUpdateValuePrecision = _x
			}
			{
				p.SetState(5395)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	p.SetState(5403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserCOMMENT {
		{
			p.SetState(5401)
			p.Match(DorisParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5402)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*ColumnDefContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexDefsContext is an interface to support dynamic dispatch.
type IIndexDefsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_indexDef returns the _indexDef rule contexts.
	Get_indexDef() IIndexDefContext

	// Set_indexDef sets the _indexDef rule contexts.
	Set_indexDef(IIndexDefContext)

	// GetIndexes returns the indexes rule context list.
	GetIndexes() []IIndexDefContext

	// SetIndexes sets the indexes rule context list.
	SetIndexes([]IIndexDefContext)

	// Getter signatures
	AllIndexDef() []IIndexDefContext
	IndexDef(i int) IIndexDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIndexDefsContext differentiates from other interfaces.
	IsIndexDefsContext()
}

type IndexDefsContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	_indexDef IIndexDefContext
	indexes   []IIndexDefContext
}

func NewEmptyIndexDefsContext() *IndexDefsContext {
	var p = new(IndexDefsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_indexDefs
	return p
}

func InitEmptyIndexDefsContext(p *IndexDefsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_indexDefs
}

func (*IndexDefsContext) IsIndexDefsContext() {}

func NewIndexDefsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexDefsContext {
	var p = new(IndexDefsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_indexDefs

	return p
}

func (s *IndexDefsContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexDefsContext) Get_indexDef() IIndexDefContext { return s._indexDef }

func (s *IndexDefsContext) Set_indexDef(v IIndexDefContext) { s._indexDef = v }

func (s *IndexDefsContext) GetIndexes() []IIndexDefContext { return s.indexes }

func (s *IndexDefsContext) SetIndexes(v []IIndexDefContext) { s.indexes = v }

func (s *IndexDefsContext) AllIndexDef() []IIndexDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexDefContext); ok {
			len++
		}
	}

	tst := make([]IIndexDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexDefContext); ok {
			tst[i] = t.(IIndexDefContext)
			i++
		}
	}

	return tst
}

func (s *IndexDefsContext) IndexDef(i int) IIndexDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexDefContext)
}

func (s *IndexDefsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *IndexDefsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *IndexDefsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexDefsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexDefsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIndexDefs(s)
	}
}

func (s *IndexDefsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIndexDefs(s)
	}
}

func (p *DorisParser) IndexDefs() (localctx IIndexDefsContext) {
	localctx = NewIndexDefsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, DorisParserRULE_indexDefs)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5405)

		var _x = p.IndexDef()

		localctx.(*IndexDefsContext)._indexDef = _x
	}
	localctx.(*IndexDefsContext).indexes = append(localctx.(*IndexDefsContext).indexes, localctx.(*IndexDefsContext)._indexDef)
	p.SetState(5410)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 782, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5406)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5407)

				var _x = p.IndexDef()

				localctx.(*IndexDefsContext)._indexDef = _x
			}
			localctx.(*IndexDefsContext).indexes = append(localctx.(*IndexDefsContext).indexes, localctx.(*IndexDefsContext)._indexDef)

		}
		p.SetState(5412)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 782, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexDefContext is an interface to support dynamic dispatch.
type IIndexDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIfNotExists returns the ifNotExists token.
	GetIfNotExists() antlr.Token

	// GetIndexType returns the indexType token.
	GetIndexType() antlr.Token

	// GetComment returns the comment token.
	GetComment() antlr.Token

	// SetIfNotExists sets the ifNotExists token.
	SetIfNotExists(antlr.Token)

	// SetIndexType sets the indexType token.
	SetIndexType(antlr.Token)

	// SetComment sets the comment token.
	SetComment(antlr.Token)

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// GetCols returns the cols rule contexts.
	GetCols() IIdentifierListContext

	// GetProperties returns the properties rule contexts.
	GetProperties() IPropertyItemListContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// SetCols sets the cols rule contexts.
	SetCols(IIdentifierListContext)

	// SetProperties sets the properties rule contexts.
	SetProperties(IPropertyItemListContext)

	// Getter signatures
	INDEX() antlr.TerminalNode
	Identifier() IIdentifierContext
	IdentifierList() IIdentifierListContext
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	USING() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	IF() antlr.TerminalNode
	PropertyItemList() IPropertyItemListContext
	STRING_LITERAL() antlr.TerminalNode
	BITMAP() antlr.TerminalNode
	INVERTED() antlr.TerminalNode
	NGRAM_BF() antlr.TerminalNode

	// IsIndexDefContext differentiates from other interfaces.
	IsIndexDefContext()
}

type IndexDefContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	ifNotExists antlr.Token
	indexName   IIdentifierContext
	cols        IIdentifierListContext
	indexType   antlr.Token
	properties  IPropertyItemListContext
	comment     antlr.Token
}

func NewEmptyIndexDefContext() *IndexDefContext {
	var p = new(IndexDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_indexDef
	return p
}

func InitEmptyIndexDefContext(p *IndexDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_indexDef
}

func (*IndexDefContext) IsIndexDefContext() {}

func NewIndexDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexDefContext {
	var p = new(IndexDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_indexDef

	return p
}

func (s *IndexDefContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexDefContext) GetIfNotExists() antlr.Token { return s.ifNotExists }

func (s *IndexDefContext) GetIndexType() antlr.Token { return s.indexType }

func (s *IndexDefContext) GetComment() antlr.Token { return s.comment }

func (s *IndexDefContext) SetIfNotExists(v antlr.Token) { s.ifNotExists = v }

func (s *IndexDefContext) SetIndexType(v antlr.Token) { s.indexType = v }

func (s *IndexDefContext) SetComment(v antlr.Token) { s.comment = v }

func (s *IndexDefContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *IndexDefContext) GetCols() IIdentifierListContext { return s.cols }

func (s *IndexDefContext) GetProperties() IPropertyItemListContext { return s.properties }

func (s *IndexDefContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *IndexDefContext) SetCols(v IIdentifierListContext) { s.cols = v }

func (s *IndexDefContext) SetProperties(v IPropertyItemListContext) { s.properties = v }

func (s *IndexDefContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEX, 0)
}

func (s *IndexDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IndexDefContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *IndexDefContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *IndexDefContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *IndexDefContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserUSING, 0)
}

func (s *IndexDefContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *IndexDefContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *IndexDefContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *IndexDefContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *IndexDefContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *IndexDefContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *IndexDefContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *IndexDefContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(DorisParserBITMAP, 0)
}

func (s *IndexDefContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserINVERTED, 0)
}

func (s *IndexDefContext) NGRAM_BF() antlr.TerminalNode {
	return s.GetToken(DorisParserNGRAM_BF, 0)
}

func (s *IndexDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIndexDef(s)
	}
}

func (s *IndexDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIndexDef(s)
	}
}

func (p *DorisParser) IndexDef() (localctx IIndexDefContext) {
	localctx = NewIndexDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, DorisParserRULE_indexDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5413)
		p.Match(DorisParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5417)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserIF {
		{
			p.SetState(5414)

			var _m = p.Match(DorisParserIF)

			localctx.(*IndexDefContext).ifNotExists = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5415)
			p.Match(DorisParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5416)
			p.Match(DorisParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5419)

		var _x = p.Identifier()

		localctx.(*IndexDefContext).indexName = _x
	}
	{
		p.SetState(5420)

		var _x = p.IdentifierList()

		localctx.(*IndexDefContext).cols = _x
	}
	p.SetState(5423)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserUSING {
		{
			p.SetState(5421)
			p.Match(DorisParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5422)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IndexDefContext).indexType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserBITMAP || _la == DorisParserINVERTED || _la == DorisParserNGRAM_BF) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IndexDefContext).indexType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(5430)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPROPERTIES {
		{
			p.SetState(5425)
			p.Match(DorisParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5426)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5427)

			var _x = p.PropertyItemList()

			localctx.(*IndexDefContext).properties = _x
		}
		{
			p.SetState(5428)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5434)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserCOMMENT {
		{
			p.SetState(5432)
			p.Match(DorisParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5433)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*IndexDefContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionsDefContext is an interface to support dynamic dispatch.
type IPartitionsDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_partitionDef returns the _partitionDef rule contexts.
	Get_partitionDef() IPartitionDefContext

	// Set_partitionDef sets the _partitionDef rule contexts.
	Set_partitionDef(IPartitionDefContext)

	// GetPartitions returns the partitions rule context list.
	GetPartitions() []IPartitionDefContext

	// SetPartitions sets the partitions rule context list.
	SetPartitions([]IPartitionDefContext)

	// Getter signatures
	AllPartitionDef() []IPartitionDefContext
	PartitionDef(i int) IPartitionDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionsDefContext differentiates from other interfaces.
	IsPartitionsDefContext()
}

type PartitionsDefContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	_partitionDef IPartitionDefContext
	partitions    []IPartitionDefContext
}

func NewEmptyPartitionsDefContext() *PartitionsDefContext {
	var p = new(PartitionsDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionsDef
	return p
}

func InitEmptyPartitionsDefContext(p *PartitionsDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionsDef
}

func (*PartitionsDefContext) IsPartitionsDefContext() {}

func NewPartitionsDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionsDefContext {
	var p = new(PartitionsDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_partitionsDef

	return p
}

func (s *PartitionsDefContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionsDefContext) Get_partitionDef() IPartitionDefContext { return s._partitionDef }

func (s *PartitionsDefContext) Set_partitionDef(v IPartitionDefContext) { s._partitionDef = v }

func (s *PartitionsDefContext) GetPartitions() []IPartitionDefContext { return s.partitions }

func (s *PartitionsDefContext) SetPartitions(v []IPartitionDefContext) { s.partitions = v }

func (s *PartitionsDefContext) AllPartitionDef() []IPartitionDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefContext); ok {
			tst[i] = t.(IPartitionDefContext)
			i++
		}
	}

	return tst
}

func (s *PartitionsDefContext) PartitionDef(i int) IPartitionDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefContext)
}

func (s *PartitionsDefContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *PartitionsDefContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *PartitionsDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionsDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionsDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPartitionsDef(s)
	}
}

func (s *PartitionsDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPartitionsDef(s)
	}
}

func (p *DorisParser) PartitionsDef() (localctx IPartitionsDefContext) {
	localctx = NewPartitionsDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, DorisParserRULE_partitionsDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5436)

		var _x = p.PartitionDef()

		localctx.(*PartitionsDefContext)._partitionDef = _x
	}
	localctx.(*PartitionsDefContext).partitions = append(localctx.(*PartitionsDefContext).partitions, localctx.(*PartitionsDefContext)._partitionDef)
	p.SetState(5441)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(5437)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5438)

			var _x = p.PartitionDef()

			localctx.(*PartitionsDefContext)._partitionDef = _x
		}
		localctx.(*PartitionsDefContext).partitions = append(localctx.(*PartitionsDefContext).partitions, localctx.(*PartitionsDefContext)._partitionDef)

		p.SetState(5443)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDefContext is an interface to support dynamic dispatch.
type IPartitionDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionProperties returns the partitionProperties rule contexts.
	GetPartitionProperties() IPropertyItemListContext

	// SetPartitionProperties sets the partitionProperties rule contexts.
	SetPartitionProperties(IPropertyItemListContext)

	// Getter signatures
	LessThanPartitionDef() ILessThanPartitionDefContext
	FixedPartitionDef() IFixedPartitionDefContext
	StepPartitionDef() IStepPartitionDefContext
	InPartitionDef() IInPartitionDefContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	PropertyItemList() IPropertyItemListContext

	// IsPartitionDefContext differentiates from other interfaces.
	IsPartitionDefContext()
}

type PartitionDefContext struct {
	antlr.BaseParserRuleContext
	parser              antlr.Parser
	partitionProperties IPropertyItemListContext
}

func NewEmptyPartitionDefContext() *PartitionDefContext {
	var p = new(PartitionDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionDef
	return p
}

func InitEmptyPartitionDefContext(p *PartitionDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionDef
}

func (*PartitionDefContext) IsPartitionDefContext() {}

func NewPartitionDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefContext {
	var p = new(PartitionDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_partitionDef

	return p
}

func (s *PartitionDefContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefContext) GetPartitionProperties() IPropertyItemListContext {
	return s.partitionProperties
}

func (s *PartitionDefContext) SetPartitionProperties(v IPropertyItemListContext) {
	s.partitionProperties = v
}

func (s *PartitionDefContext) LessThanPartitionDef() ILessThanPartitionDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILessThanPartitionDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILessThanPartitionDefContext)
}

func (s *PartitionDefContext) FixedPartitionDef() IFixedPartitionDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFixedPartitionDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFixedPartitionDefContext)
}

func (s *PartitionDefContext) StepPartitionDef() IStepPartitionDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStepPartitionDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStepPartitionDefContext)
}

func (s *PartitionDefContext) InPartitionDef() IInPartitionDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInPartitionDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInPartitionDefContext)
}

func (s *PartitionDefContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *PartitionDefContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *PartitionDefContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *PartitionDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPartitionDef(s)
	}
}

func (s *PartitionDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPartitionDef(s)
	}
}

func (p *DorisParser) PartitionDef() (localctx IPartitionDefContext) {
	localctx = NewPartitionDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, DorisParserRULE_partitionDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5448)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 788, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5444)
			p.LessThanPartitionDef()
		}

	case 2:
		{
			p.SetState(5445)
			p.FixedPartitionDef()
		}

	case 3:
		{
			p.SetState(5446)
			p.StepPartitionDef()
		}

	case 4:
		{
			p.SetState(5447)
			p.InPartitionDef()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(5454)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserLEFT_PAREN {
		{
			p.SetState(5450)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5451)

			var _x = p.PropertyItemList()

			localctx.(*PartitionDefContext).partitionProperties = _x
		}
		{
			p.SetState(5452)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILessThanPartitionDefContext is an interface to support dynamic dispatch.
type ILessThanPartitionDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionName returns the partitionName rule contexts.
	GetPartitionName() IIdentifierContext

	// SetPartitionName sets the partitionName rule contexts.
	SetPartitionName(IIdentifierContext)

	// Getter signatures
	PARTITION() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	LESS() antlr.TerminalNode
	THAN() antlr.TerminalNode
	Identifier() IIdentifierContext
	MAXVALUE() antlr.TerminalNode
	PartitionValueList() IPartitionValueListContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsLessThanPartitionDefContext differentiates from other interfaces.
	IsLessThanPartitionDefContext()
}

type LessThanPartitionDefContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	partitionName IIdentifierContext
}

func NewEmptyLessThanPartitionDefContext() *LessThanPartitionDefContext {
	var p = new(LessThanPartitionDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_lessThanPartitionDef
	return p
}

func InitEmptyLessThanPartitionDefContext(p *LessThanPartitionDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_lessThanPartitionDef
}

func (*LessThanPartitionDefContext) IsLessThanPartitionDefContext() {}

func NewLessThanPartitionDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LessThanPartitionDefContext {
	var p = new(LessThanPartitionDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_lessThanPartitionDef

	return p
}

func (s *LessThanPartitionDefContext) GetParser() antlr.Parser { return s.parser }

func (s *LessThanPartitionDefContext) GetPartitionName() IIdentifierContext { return s.partitionName }

func (s *LessThanPartitionDefContext) SetPartitionName(v IIdentifierContext) { s.partitionName = v }

func (s *LessThanPartitionDefContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *LessThanPartitionDefContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisParserVALUES, 0)
}

func (s *LessThanPartitionDefContext) LESS() antlr.TerminalNode {
	return s.GetToken(DorisParserLESS, 0)
}

func (s *LessThanPartitionDefContext) THAN() antlr.TerminalNode {
	return s.GetToken(DorisParserTHAN, 0)
}

func (s *LessThanPartitionDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LessThanPartitionDefContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserMAXVALUE, 0)
}

func (s *LessThanPartitionDefContext) PartitionValueList() IPartitionValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueListContext)
}

func (s *LessThanPartitionDefContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *LessThanPartitionDefContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *LessThanPartitionDefContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *LessThanPartitionDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LessThanPartitionDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LessThanPartitionDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLessThanPartitionDef(s)
	}
}

func (s *LessThanPartitionDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLessThanPartitionDef(s)
	}
}

func (p *DorisParser) LessThanPartitionDef() (localctx ILessThanPartitionDefContext) {
	localctx = NewLessThanPartitionDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, DorisParserRULE_lessThanPartitionDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5456)
		p.Match(DorisParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5460)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserIF {
		{
			p.SetState(5457)
			p.Match(DorisParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5458)
			p.Match(DorisParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5459)
			p.Match(DorisParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5462)

		var _x = p.Identifier()

		localctx.(*LessThanPartitionDefContext).partitionName = _x
	}
	{
		p.SetState(5463)
		p.Match(DorisParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5464)
		p.Match(DorisParserLESS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5465)
		p.Match(DorisParserTHAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5468)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserMAXVALUE:
		{
			p.SetState(5466)
			p.Match(DorisParserMAXVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserLEFT_PAREN:
		{
			p.SetState(5467)
			p.PartitionValueList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFixedPartitionDefContext is an interface to support dynamic dispatch.
type IFixedPartitionDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionName returns the partitionName rule contexts.
	GetPartitionName() IIdentifierContext

	// GetLower returns the lower rule contexts.
	GetLower() IPartitionValueListContext

	// GetUpper returns the upper rule contexts.
	GetUpper() IPartitionValueListContext

	// SetPartitionName sets the partitionName rule contexts.
	SetPartitionName(IIdentifierContext)

	// SetLower sets the lower rule contexts.
	SetLower(IPartitionValueListContext)

	// SetUpper sets the upper rule contexts.
	SetUpper(IPartitionValueListContext)

	// Getter signatures
	PARTITION() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	LEFT_BRACKET() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	AllPartitionValueList() []IPartitionValueListContext
	PartitionValueList(i int) IPartitionValueListContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsFixedPartitionDefContext differentiates from other interfaces.
	IsFixedPartitionDefContext()
}

type FixedPartitionDefContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	partitionName IIdentifierContext
	lower         IPartitionValueListContext
	upper         IPartitionValueListContext
}

func NewEmptyFixedPartitionDefContext() *FixedPartitionDefContext {
	var p = new(FixedPartitionDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_fixedPartitionDef
	return p
}

func InitEmptyFixedPartitionDefContext(p *FixedPartitionDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_fixedPartitionDef
}

func (*FixedPartitionDefContext) IsFixedPartitionDefContext() {}

func NewFixedPartitionDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FixedPartitionDefContext {
	var p = new(FixedPartitionDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_fixedPartitionDef

	return p
}

func (s *FixedPartitionDefContext) GetParser() antlr.Parser { return s.parser }

func (s *FixedPartitionDefContext) GetPartitionName() IIdentifierContext { return s.partitionName }

func (s *FixedPartitionDefContext) GetLower() IPartitionValueListContext { return s.lower }

func (s *FixedPartitionDefContext) GetUpper() IPartitionValueListContext { return s.upper }

func (s *FixedPartitionDefContext) SetPartitionName(v IIdentifierContext) { s.partitionName = v }

func (s *FixedPartitionDefContext) SetLower(v IPartitionValueListContext) { s.lower = v }

func (s *FixedPartitionDefContext) SetUpper(v IPartitionValueListContext) { s.upper = v }

func (s *FixedPartitionDefContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *FixedPartitionDefContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisParserVALUES, 0)
}

func (s *FixedPartitionDefContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACKET, 0)
}

func (s *FixedPartitionDefContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, 0)
}

func (s *FixedPartitionDefContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *FixedPartitionDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FixedPartitionDefContext) AllPartitionValueList() []IPartitionValueListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueListContext); ok {
			tst[i] = t.(IPartitionValueListContext)
			i++
		}
	}

	return tst
}

func (s *FixedPartitionDefContext) PartitionValueList(i int) IPartitionValueListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueListContext)
}

func (s *FixedPartitionDefContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *FixedPartitionDefContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *FixedPartitionDefContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *FixedPartitionDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FixedPartitionDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FixedPartitionDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFixedPartitionDef(s)
	}
}

func (s *FixedPartitionDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFixedPartitionDef(s)
	}
}

func (p *DorisParser) FixedPartitionDef() (localctx IFixedPartitionDefContext) {
	localctx = NewFixedPartitionDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, DorisParserRULE_fixedPartitionDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5470)
		p.Match(DorisParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5474)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserIF {
		{
			p.SetState(5471)
			p.Match(DorisParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5472)
			p.Match(DorisParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5473)
			p.Match(DorisParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5476)

		var _x = p.Identifier()

		localctx.(*FixedPartitionDefContext).partitionName = _x
	}
	{
		p.SetState(5477)
		p.Match(DorisParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5478)
		p.Match(DorisParserLEFT_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5479)

		var _x = p.PartitionValueList()

		localctx.(*FixedPartitionDefContext).lower = _x
	}
	{
		p.SetState(5480)
		p.Match(DorisParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5481)

		var _x = p.PartitionValueList()

		localctx.(*FixedPartitionDefContext).upper = _x
	}
	{
		p.SetState(5482)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStepPartitionDefContext is an interface to support dynamic dispatch.
type IStepPartitionDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnitsAmount returns the unitsAmount token.
	GetUnitsAmount() antlr.Token

	// SetUnitsAmount sets the unitsAmount token.
	SetUnitsAmount(antlr.Token)

	// GetFrom returns the from rule contexts.
	GetFrom() IPartitionValueListContext

	// GetTo returns the to rule contexts.
	GetTo() IPartitionValueListContext

	// GetUnit returns the unit rule contexts.
	GetUnit() IUnitIdentifierContext

	// SetFrom sets the from rule contexts.
	SetFrom(IPartitionValueListContext)

	// SetTo sets the to rule contexts.
	SetTo(IPartitionValueListContext)

	// SetUnit sets the unit rule contexts.
	SetUnit(IUnitIdentifierContext)

	// Getter signatures
	FROM() antlr.TerminalNode
	TO() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	AllPartitionValueList() []IPartitionValueListContext
	PartitionValueList(i int) IPartitionValueListContext
	INTEGER_VALUE() antlr.TerminalNode
	UnitIdentifier() IUnitIdentifierContext

	// IsStepPartitionDefContext differentiates from other interfaces.
	IsStepPartitionDefContext()
}

type StepPartitionDefContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	from        IPartitionValueListContext
	to          IPartitionValueListContext
	unitsAmount antlr.Token
	unit        IUnitIdentifierContext
}

func NewEmptyStepPartitionDefContext() *StepPartitionDefContext {
	var p = new(StepPartitionDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_stepPartitionDef
	return p
}

func InitEmptyStepPartitionDefContext(p *StepPartitionDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_stepPartitionDef
}

func (*StepPartitionDefContext) IsStepPartitionDefContext() {}

func NewStepPartitionDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StepPartitionDefContext {
	var p = new(StepPartitionDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_stepPartitionDef

	return p
}

func (s *StepPartitionDefContext) GetParser() antlr.Parser { return s.parser }

func (s *StepPartitionDefContext) GetUnitsAmount() antlr.Token { return s.unitsAmount }

func (s *StepPartitionDefContext) SetUnitsAmount(v antlr.Token) { s.unitsAmount = v }

func (s *StepPartitionDefContext) GetFrom() IPartitionValueListContext { return s.from }

func (s *StepPartitionDefContext) GetTo() IPartitionValueListContext { return s.to }

func (s *StepPartitionDefContext) GetUnit() IUnitIdentifierContext { return s.unit }

func (s *StepPartitionDefContext) SetFrom(v IPartitionValueListContext) { s.from = v }

func (s *StepPartitionDefContext) SetTo(v IPartitionValueListContext) { s.to = v }

func (s *StepPartitionDefContext) SetUnit(v IUnitIdentifierContext) { s.unit = v }

func (s *StepPartitionDefContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *StepPartitionDefContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserTO, 0)
}

func (s *StepPartitionDefContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DorisParserINTERVAL, 0)
}

func (s *StepPartitionDefContext) AllPartitionValueList() []IPartitionValueListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueListContext); ok {
			tst[i] = t.(IPartitionValueListContext)
			i++
		}
	}

	return tst
}

func (s *StepPartitionDefContext) PartitionValueList(i int) IPartitionValueListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueListContext)
}

func (s *StepPartitionDefContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *StepPartitionDefContext) UnitIdentifier() IUnitIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitIdentifierContext)
}

func (s *StepPartitionDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StepPartitionDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StepPartitionDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStepPartitionDef(s)
	}
}

func (s *StepPartitionDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStepPartitionDef(s)
	}
}

func (p *DorisParser) StepPartitionDef() (localctx IStepPartitionDefContext) {
	localctx = NewStepPartitionDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, DorisParserRULE_stepPartitionDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5484)
		p.Match(DorisParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5485)

		var _x = p.PartitionValueList()

		localctx.(*StepPartitionDefContext).from = _x
	}
	{
		p.SetState(5486)
		p.Match(DorisParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5487)

		var _x = p.PartitionValueList()

		localctx.(*StepPartitionDefContext).to = _x
	}
	{
		p.SetState(5488)
		p.Match(DorisParserINTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5489)

		var _m = p.Match(DorisParserINTEGER_VALUE)

		localctx.(*StepPartitionDefContext).unitsAmount = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5491)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserDAY || _la == DorisParserHOUR || _la == DorisParserMINUTE || _la == DorisParserMONTH || _la == DorisParserQUARTER || _la == DorisParserSECOND || _la == DorisParserWEEK || _la == DorisParserYEAR {
		{
			p.SetState(5490)

			var _x = p.UnitIdentifier()

			localctx.(*StepPartitionDefContext).unit = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInPartitionDefContext is an interface to support dynamic dispatch.
type IInPartitionDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionName returns the partitionName rule contexts.
	GetPartitionName() IIdentifierContext

	// Get_partitionValueList returns the _partitionValueList rule contexts.
	Get_partitionValueList() IPartitionValueListContext

	// GetConstants returns the constants rule contexts.
	GetConstants() IPartitionValueListContext

	// SetPartitionName sets the partitionName rule contexts.
	SetPartitionName(IIdentifierContext)

	// Set_partitionValueList sets the _partitionValueList rule contexts.
	Set_partitionValueList(IPartitionValueListContext)

	// SetConstants sets the constants rule contexts.
	SetConstants(IPartitionValueListContext)

	// GetPartitionValueLists returns the partitionValueLists rule context list.
	GetPartitionValueLists() []IPartitionValueListContext

	// SetPartitionValueLists sets the partitionValueLists rule context list.
	SetPartitionValueLists([]IPartitionValueListContext)

	// Getter signatures
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	IN() antlr.TerminalNode
	AllPartitionValueList() []IPartitionValueListContext
	PartitionValueList(i int) IPartitionValueListContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsInPartitionDefContext differentiates from other interfaces.
	IsInPartitionDefContext()
}

type InPartitionDefContext struct {
	antlr.BaseParserRuleContext
	parser              antlr.Parser
	partitionName       IIdentifierContext
	_partitionValueList IPartitionValueListContext
	partitionValueLists []IPartitionValueListContext
	constants           IPartitionValueListContext
}

func NewEmptyInPartitionDefContext() *InPartitionDefContext {
	var p = new(InPartitionDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_inPartitionDef
	return p
}

func InitEmptyInPartitionDefContext(p *InPartitionDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_inPartitionDef
}

func (*InPartitionDefContext) IsInPartitionDefContext() {}

func NewInPartitionDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InPartitionDefContext {
	var p = new(InPartitionDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_inPartitionDef

	return p
}

func (s *InPartitionDefContext) GetParser() antlr.Parser { return s.parser }

func (s *InPartitionDefContext) GetPartitionName() IIdentifierContext { return s.partitionName }

func (s *InPartitionDefContext) Get_partitionValueList() IPartitionValueListContext {
	return s._partitionValueList
}

func (s *InPartitionDefContext) GetConstants() IPartitionValueListContext { return s.constants }

func (s *InPartitionDefContext) SetPartitionName(v IIdentifierContext) { s.partitionName = v }

func (s *InPartitionDefContext) Set_partitionValueList(v IPartitionValueListContext) {
	s._partitionValueList = v
}

func (s *InPartitionDefContext) SetConstants(v IPartitionValueListContext) { s.constants = v }

func (s *InPartitionDefContext) GetPartitionValueLists() []IPartitionValueListContext {
	return s.partitionValueLists
}

func (s *InPartitionDefContext) SetPartitionValueLists(v []IPartitionValueListContext) {
	s.partitionValueLists = v
}

func (s *InPartitionDefContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *InPartitionDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InPartitionDefContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *InPartitionDefContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *InPartitionDefContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *InPartitionDefContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisParserVALUES, 0)
}

func (s *InPartitionDefContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *InPartitionDefContext) AllPartitionValueList() []IPartitionValueListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueListContext); ok {
			tst[i] = t.(IPartitionValueListContext)
			i++
		}
	}

	return tst
}

func (s *InPartitionDefContext) PartitionValueList(i int) IPartitionValueListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueListContext)
}

func (s *InPartitionDefContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *InPartitionDefContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *InPartitionDefContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *InPartitionDefContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *InPartitionDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InPartitionDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InPartitionDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterInPartitionDef(s)
	}
}

func (s *InPartitionDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitInPartitionDef(s)
	}
}

func (p *DorisParser) InPartitionDef() (localctx IInPartitionDefContext) {
	localctx = NewInPartitionDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, DorisParserRULE_inPartitionDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5493)
		p.Match(DorisParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5497)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserIF {
		{
			p.SetState(5494)
			p.Match(DorisParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5495)
			p.Match(DorisParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5496)
			p.Match(DorisParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5499)

		var _x = p.Identifier()

		localctx.(*InPartitionDefContext).partitionName = _x
	}
	p.SetState(5516)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserVALUES {
		{
			p.SetState(5500)
			p.Match(DorisParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5501)
			p.Match(DorisParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5514)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 796, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5502)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5503)

				var _x = p.PartitionValueList()

				localctx.(*InPartitionDefContext)._partitionValueList = _x
			}
			localctx.(*InPartitionDefContext).partitionValueLists = append(localctx.(*InPartitionDefContext).partitionValueLists, localctx.(*InPartitionDefContext)._partitionValueList)
			p.SetState(5508)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(5504)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5505)

					var _x = p.PartitionValueList()

					localctx.(*InPartitionDefContext)._partitionValueList = _x
				}
				localctx.(*InPartitionDefContext).partitionValueLists = append(localctx.(*InPartitionDefContext).partitionValueLists, localctx.(*InPartitionDefContext)._partitionValueList)

				p.SetState(5510)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(5511)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(5513)

				var _x = p.PartitionValueList()

				localctx.(*InPartitionDefContext).constants = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionValueListContext is an interface to support dynamic dispatch.
type IPartitionValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_partitionValueDef returns the _partitionValueDef rule contexts.
	Get_partitionValueDef() IPartitionValueDefContext

	// Set_partitionValueDef sets the _partitionValueDef rule contexts.
	Set_partitionValueDef(IPartitionValueDefContext)

	// GetValues returns the values rule context list.
	GetValues() []IPartitionValueDefContext

	// SetValues sets the values rule context list.
	SetValues([]IPartitionValueDefContext)

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllPartitionValueDef() []IPartitionValueDefContext
	PartitionValueDef(i int) IPartitionValueDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionValueListContext differentiates from other interfaces.
	IsPartitionValueListContext()
}

type PartitionValueListContext struct {
	antlr.BaseParserRuleContext
	parser             antlr.Parser
	_partitionValueDef IPartitionValueDefContext
	values             []IPartitionValueDefContext
}

func NewEmptyPartitionValueListContext() *PartitionValueListContext {
	var p = new(PartitionValueListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionValueList
	return p
}

func InitEmptyPartitionValueListContext(p *PartitionValueListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionValueList
}

func (*PartitionValueListContext) IsPartitionValueListContext() {}

func NewPartitionValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValueListContext {
	var p = new(PartitionValueListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_partitionValueList

	return p
}

func (s *PartitionValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValueListContext) Get_partitionValueDef() IPartitionValueDefContext {
	return s._partitionValueDef
}

func (s *PartitionValueListContext) Set_partitionValueDef(v IPartitionValueDefContext) {
	s._partitionValueDef = v
}

func (s *PartitionValueListContext) GetValues() []IPartitionValueDefContext { return s.values }

func (s *PartitionValueListContext) SetValues(v []IPartitionValueDefContext) { s.values = v }

func (s *PartitionValueListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *PartitionValueListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *PartitionValueListContext) AllPartitionValueDef() []IPartitionValueDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueDefContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueDefContext); ok {
			tst[i] = t.(IPartitionValueDefContext)
			i++
		}
	}

	return tst
}

func (s *PartitionValueListContext) PartitionValueDef(i int) IPartitionValueDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueDefContext)
}

func (s *PartitionValueListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *PartitionValueListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *PartitionValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionValueListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPartitionValueList(s)
	}
}

func (s *PartitionValueListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPartitionValueList(s)
	}
}

func (p *DorisParser) PartitionValueList() (localctx IPartitionValueListContext) {
	localctx = NewPartitionValueListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, DorisParserRULE_partitionValueList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5518)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5519)

		var _x = p.PartitionValueDef()

		localctx.(*PartitionValueListContext)._partitionValueDef = _x
	}
	localctx.(*PartitionValueListContext).values = append(localctx.(*PartitionValueListContext).values, localctx.(*PartitionValueListContext)._partitionValueDef)
	p.SetState(5524)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(5520)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5521)

			var _x = p.PartitionValueDef()

			localctx.(*PartitionValueListContext)._partitionValueDef = _x
		}
		localctx.(*PartitionValueListContext).values = append(localctx.(*PartitionValueListContext).values, localctx.(*PartitionValueListContext)._partitionValueDef)

		p.SetState(5526)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5527)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionValueDefContext is an interface to support dynamic dispatch.
type IPartitionValueDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER_VALUE() antlr.TerminalNode
	SUBTRACT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	MAXVALUE() antlr.TerminalNode
	NULL() antlr.TerminalNode

	// IsPartitionValueDefContext differentiates from other interfaces.
	IsPartitionValueDefContext()
}

type PartitionValueDefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionValueDefContext() *PartitionValueDefContext {
	var p = new(PartitionValueDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionValueDef
	return p
}

func InitEmptyPartitionValueDefContext(p *PartitionValueDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_partitionValueDef
}

func (*PartitionValueDefContext) IsPartitionValueDefContext() {}

func NewPartitionValueDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValueDefContext {
	var p = new(PartitionValueDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_partitionValueDef

	return p
}

func (s *PartitionValueDefContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValueDefContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *PartitionValueDefContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(DorisParserSUBTRACT, 0)
}

func (s *PartitionValueDefContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *PartitionValueDefContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserMAXVALUE, 0)
}

func (s *PartitionValueDefContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisParserNULL, 0)
}

func (s *PartitionValueDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValueDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionValueDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPartitionValueDef(s)
	}
}

func (s *PartitionValueDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPartitionValueDef(s)
	}
}

func (p *DorisParser) PartitionValueDef() (localctx IPartitionValueDefContext) {
	localctx = NewPartitionValueDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, DorisParserRULE_partitionValueDef)
	var _la int

	p.SetState(5536)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserSUBTRACT, DorisParserINTEGER_VALUE:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5530)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserSUBTRACT {
			{
				p.SetState(5529)
				p.Match(DorisParserSUBTRACT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5532)
			p.Match(DorisParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5533)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserMAXVALUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5534)
			p.Match(DorisParserMAXVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserNULL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5535)
			p.Match(DorisParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollupDefsContext is an interface to support dynamic dispatch.
type IRollupDefsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_rollupDef returns the _rollupDef rule contexts.
	Get_rollupDef() IRollupDefContext

	// Set_rollupDef sets the _rollupDef rule contexts.
	Set_rollupDef(IRollupDefContext)

	// GetRollups returns the rollups rule context list.
	GetRollups() []IRollupDefContext

	// SetRollups sets the rollups rule context list.
	SetRollups([]IRollupDefContext)

	// Getter signatures
	AllRollupDef() []IRollupDefContext
	RollupDef(i int) IRollupDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRollupDefsContext differentiates from other interfaces.
	IsRollupDefsContext()
}

type RollupDefsContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	_rollupDef IRollupDefContext
	rollups    []IRollupDefContext
}

func NewEmptyRollupDefsContext() *RollupDefsContext {
	var p = new(RollupDefsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_rollupDefs
	return p
}

func InitEmptyRollupDefsContext(p *RollupDefsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_rollupDefs
}

func (*RollupDefsContext) IsRollupDefsContext() {}

func NewRollupDefsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollupDefsContext {
	var p = new(RollupDefsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_rollupDefs

	return p
}

func (s *RollupDefsContext) GetParser() antlr.Parser { return s.parser }

func (s *RollupDefsContext) Get_rollupDef() IRollupDefContext { return s._rollupDef }

func (s *RollupDefsContext) Set_rollupDef(v IRollupDefContext) { s._rollupDef = v }

func (s *RollupDefsContext) GetRollups() []IRollupDefContext { return s.rollups }

func (s *RollupDefsContext) SetRollups(v []IRollupDefContext) { s.rollups = v }

func (s *RollupDefsContext) AllRollupDef() []IRollupDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRollupDefContext); ok {
			len++
		}
	}

	tst := make([]IRollupDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRollupDefContext); ok {
			tst[i] = t.(IRollupDefContext)
			i++
		}
	}

	return tst
}

func (s *RollupDefsContext) RollupDef(i int) IRollupDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupDefContext)
}

func (s *RollupDefsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *RollupDefsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *RollupDefsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupDefsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollupDefsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRollupDefs(s)
	}
}

func (s *RollupDefsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRollupDefs(s)
	}
}

func (p *DorisParser) RollupDefs() (localctx IRollupDefsContext) {
	localctx = NewRollupDefsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, DorisParserRULE_rollupDefs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5538)

		var _x = p.RollupDef()

		localctx.(*RollupDefsContext)._rollupDef = _x
	}
	localctx.(*RollupDefsContext).rollups = append(localctx.(*RollupDefsContext).rollups, localctx.(*RollupDefsContext)._rollupDef)
	p.SetState(5543)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(5539)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5540)

			var _x = p.RollupDef()

			localctx.(*RollupDefsContext)._rollupDef = _x
		}
		localctx.(*RollupDefsContext).rollups = append(localctx.(*RollupDefsContext).rollups, localctx.(*RollupDefsContext)._rollupDef)

		p.SetState(5545)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollupDefContext is an interface to support dynamic dispatch.
type IRollupDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// GetRollupCols returns the rollupCols rule contexts.
	GetRollupCols() IIdentifierListContext

	// GetDupKeys returns the dupKeys rule contexts.
	GetDupKeys() IIdentifierListContext

	// GetProperties returns the properties rule contexts.
	GetProperties() IPropertyClauseContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// SetRollupCols sets the rollupCols rule contexts.
	SetRollupCols(IIdentifierListContext)

	// SetDupKeys sets the dupKeys rule contexts.
	SetDupKeys(IIdentifierListContext)

	// SetProperties sets the properties rule contexts.
	SetProperties(IPropertyClauseContext)

	// Getter signatures
	Identifier() IIdentifierContext
	AllIdentifierList() []IIdentifierListContext
	IdentifierList(i int) IIdentifierListContext
	DUPLICATE() antlr.TerminalNode
	KEY() antlr.TerminalNode
	PropertyClause() IPropertyClauseContext

	// IsRollupDefContext differentiates from other interfaces.
	IsRollupDefContext()
}

type RollupDefContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
	rollupCols IIdentifierListContext
	dupKeys    IIdentifierListContext
	properties IPropertyClauseContext
}

func NewEmptyRollupDefContext() *RollupDefContext {
	var p = new(RollupDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_rollupDef
	return p
}

func InitEmptyRollupDefContext(p *RollupDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_rollupDef
}

func (*RollupDefContext) IsRollupDefContext() {}

func NewRollupDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollupDefContext {
	var p = new(RollupDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_rollupDef

	return p
}

func (s *RollupDefContext) GetParser() antlr.Parser { return s.parser }

func (s *RollupDefContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *RollupDefContext) GetRollupCols() IIdentifierListContext { return s.rollupCols }

func (s *RollupDefContext) GetDupKeys() IIdentifierListContext { return s.dupKeys }

func (s *RollupDefContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *RollupDefContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *RollupDefContext) SetRollupCols(v IIdentifierListContext) { s.rollupCols = v }

func (s *RollupDefContext) SetDupKeys(v IIdentifierListContext) { s.dupKeys = v }

func (s *RollupDefContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *RollupDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RollupDefContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *RollupDefContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *RollupDefContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(DorisParserDUPLICATE, 0)
}

func (s *RollupDefContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserKEY, 0)
}

func (s *RollupDefContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *RollupDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollupDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRollupDef(s)
	}
}

func (s *RollupDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRollupDef(s)
	}
}

func (p *DorisParser) RollupDef() (localctx IRollupDefContext) {
	localctx = NewRollupDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, DorisParserRULE_rollupDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5546)

		var _x = p.Identifier()

		localctx.(*RollupDefContext).rollupName = _x
	}
	{
		p.SetState(5547)

		var _x = p.IdentifierList()

		localctx.(*RollupDefContext).rollupCols = _x
	}
	p.SetState(5551)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserDUPLICATE {
		{
			p.SetState(5548)
			p.Match(DorisParserDUPLICATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5549)
			p.Match(DorisParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5550)

			var _x = p.IdentifierList()

			localctx.(*RollupDefContext).dupKeys = _x
		}

	}
	p.SetState(5554)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPROPERTIES {
		{
			p.SetState(5553)

			var _x = p.PropertyClause()

			localctx.(*RollupDefContext).properties = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggTypeDefContext is an interface to support dynamic dispatch.
type IAggTypeDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAX() antlr.TerminalNode
	MIN() antlr.TerminalNode
	SUM() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	REPLACE_IF_NOT_NULL() antlr.TerminalNode
	HLL_UNION() antlr.TerminalNode
	BITMAP_UNION() antlr.TerminalNode
	QUANTILE_UNION() antlr.TerminalNode
	GENERIC() antlr.TerminalNode

	// IsAggTypeDefContext differentiates from other interfaces.
	IsAggTypeDefContext()
}

type AggTypeDefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggTypeDefContext() *AggTypeDefContext {
	var p = new(AggTypeDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_aggTypeDef
	return p
}

func InitEmptyAggTypeDefContext(p *AggTypeDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_aggTypeDef
}

func (*AggTypeDefContext) IsAggTypeDefContext() {}

func NewAggTypeDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggTypeDefContext {
	var p = new(AggTypeDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_aggTypeDef

	return p
}

func (s *AggTypeDefContext) GetParser() antlr.Parser { return s.parser }

func (s *AggTypeDefContext) MAX() antlr.TerminalNode {
	return s.GetToken(DorisParserMAX, 0)
}

func (s *AggTypeDefContext) MIN() antlr.TerminalNode {
	return s.GetToken(DorisParserMIN, 0)
}

func (s *AggTypeDefContext) SUM() antlr.TerminalNode {
	return s.GetToken(DorisParserSUM, 0)
}

func (s *AggTypeDefContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *AggTypeDefContext) REPLACE_IF_NOT_NULL() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE_IF_NOT_NULL, 0)
}

func (s *AggTypeDefContext) HLL_UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserHLL_UNION, 0)
}

func (s *AggTypeDefContext) BITMAP_UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserBITMAP_UNION, 0)
}

func (s *AggTypeDefContext) QUANTILE_UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserQUANTILE_UNION, 0)
}

func (s *AggTypeDefContext) GENERIC() antlr.TerminalNode {
	return s.GetToken(DorisParserGENERIC, 0)
}

func (s *AggTypeDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggTypeDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggTypeDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAggTypeDef(s)
	}
}

func (s *AggTypeDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAggTypeDef(s)
	}
}

func (p *DorisParser) AggTypeDef() (localctx IAggTypeDefContext) {
	localctx = NewAggTypeDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, DorisParserRULE_aggTypeDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5556)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserBITMAP_UNION || _la == DorisParserGENERIC || _la == DorisParserHLL_UNION || _la == DorisParserMAX || _la == DorisParserMIN || ((int64((_la-361)) & ^0x3f) == 0 && ((int64(1)<<(_la-361))&6291457) != 0) || _la == DorisParserSUM) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITabletListContext is an interface to support dynamic dispatch.
type ITabletListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_INTEGER_VALUE returns the _INTEGER_VALUE token.
	Get_INTEGER_VALUE() antlr.Token

	// Set_INTEGER_VALUE sets the _INTEGER_VALUE token.
	Set_INTEGER_VALUE(antlr.Token)

	// GetTabletIdList returns the tabletIdList token list.
	GetTabletIdList() []antlr.Token

	// SetTabletIdList sets the tabletIdList token list.
	SetTabletIdList([]antlr.Token)

	// Getter signatures
	TABLET() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTabletListContext differentiates from other interfaces.
	IsTabletListContext()
}

type TabletListContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	_INTEGER_VALUE antlr.Token
	tabletIdList   []antlr.Token
}

func NewEmptyTabletListContext() *TabletListContext {
	var p = new(TabletListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tabletList
	return p
}

func InitEmptyTabletListContext(p *TabletListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tabletList
}

func (*TabletListContext) IsTabletListContext() {}

func NewTabletListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TabletListContext {
	var p = new(TabletListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_tabletList

	return p
}

func (s *TabletListContext) GetParser() antlr.Parser { return s.parser }

func (s *TabletListContext) Get_INTEGER_VALUE() antlr.Token { return s._INTEGER_VALUE }

func (s *TabletListContext) Set_INTEGER_VALUE(v antlr.Token) { s._INTEGER_VALUE = v }

func (s *TabletListContext) GetTabletIdList() []antlr.Token { return s.tabletIdList }

func (s *TabletListContext) SetTabletIdList(v []antlr.Token) { s.tabletIdList = v }

func (s *TabletListContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLET, 0)
}

func (s *TabletListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *TabletListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *TabletListContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserINTEGER_VALUE)
}

func (s *TabletListContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, i)
}

func (s *TabletListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *TabletListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *TabletListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TabletListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TabletListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTabletList(s)
	}
}

func (s *TabletListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTabletList(s)
	}
}

func (p *DorisParser) TabletList() (localctx ITabletListContext) {
	localctx = NewTabletListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, DorisParserRULE_tabletList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5558)
		p.Match(DorisParserTABLET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5559)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5560)

		var _m = p.Match(DorisParserINTEGER_VALUE)

		localctx.(*TabletListContext)._INTEGER_VALUE = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	localctx.(*TabletListContext).tabletIdList = append(localctx.(*TabletListContext).tabletIdList, localctx.(*TabletListContext)._INTEGER_VALUE)
	p.SetState(5565)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(5561)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5562)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*TabletListContext)._INTEGER_VALUE = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*TabletListContext).tabletIdList = append(localctx.(*TabletListContext).tabletIdList, localctx.(*TabletListContext)._INTEGER_VALUE)

		p.SetState(5567)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5568)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlineTableContext is an interface to support dynamic dispatch.
type IInlineTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALUES() antlr.TerminalNode
	AllRowConstructor() []IRowConstructorContext
	RowConstructor(i int) IRowConstructorContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsInlineTableContext differentiates from other interfaces.
	IsInlineTableContext()
}

type InlineTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineTableContext() *InlineTableContext {
	var p = new(InlineTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_inlineTable
	return p
}

func InitEmptyInlineTableContext(p *InlineTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_inlineTable
}

func (*InlineTableContext) IsInlineTableContext() {}

func NewInlineTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineTableContext {
	var p = new(InlineTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_inlineTable

	return p
}

func (s *InlineTableContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineTableContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisParserVALUES, 0)
}

func (s *InlineTableContext) AllRowConstructor() []IRowConstructorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRowConstructorContext); ok {
			len++
		}
	}

	tst := make([]IRowConstructorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRowConstructorContext); ok {
			tst[i] = t.(IRowConstructorContext)
			i++
		}
	}

	return tst
}

func (s *InlineTableContext) RowConstructor(i int) IRowConstructorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowConstructorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowConstructorContext)
}

func (s *InlineTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *InlineTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *InlineTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterInlineTable(s)
	}
}

func (s *InlineTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitInlineTable(s)
	}
}

func (p *DorisParser) InlineTable() (localctx IInlineTableContext) {
	localctx = NewInlineTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, DorisParserRULE_inlineTable)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5570)
		p.Match(DorisParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5571)
		p.RowConstructor()
	}
	p.SetState(5576)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 805, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5572)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5573)
				p.RowConstructor()
			}

		}
		p.SetState(5578)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 805, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedExpressionContext is an interface to support dynamic dispatch.
type INamedExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	IdentifierOrText() IIdentifierOrTextContext
	AS() antlr.TerminalNode

	// IsNamedExpressionContext differentiates from other interfaces.
	IsNamedExpressionContext()
}

type NamedExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedExpressionContext() *NamedExpressionContext {
	var p = new(NamedExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_namedExpression
	return p
}

func InitEmptyNamedExpressionContext(p *NamedExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_namedExpression
}

func (*NamedExpressionContext) IsNamedExpressionContext() {}

func NewNamedExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedExpressionContext {
	var p = new(NamedExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_namedExpression

	return p
}

func (s *NamedExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NamedExpressionContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *NamedExpressionContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *NamedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterNamedExpression(s)
	}
}

func (s *NamedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitNamedExpression(s)
	}
}

func (p *DorisParser) NamedExpression() (localctx INamedExpressionContext) {
	localctx = NewNamedExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, DorisParserRULE_namedExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5579)
		p.Expression()
	}
	p.SetState(5584)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 807, p.GetParserRuleContext()) == 1 {
		p.SetState(5581)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserAS {
			{
				p.SetState(5580)
				p.Match(DorisParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

		{
			p.SetState(5583)
			p.IdentifierOrText()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedExpressionSeqContext is an interface to support dynamic dispatch.
type INamedExpressionSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNamedExpression() []INamedExpressionContext
	NamedExpression(i int) INamedExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsNamedExpressionSeqContext differentiates from other interfaces.
	IsNamedExpressionSeqContext()
}

type NamedExpressionSeqContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedExpressionSeqContext() *NamedExpressionSeqContext {
	var p = new(NamedExpressionSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_namedExpressionSeq
	return p
}

func InitEmptyNamedExpressionSeqContext(p *NamedExpressionSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_namedExpressionSeq
}

func (*NamedExpressionSeqContext) IsNamedExpressionSeqContext() {}

func NewNamedExpressionSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedExpressionSeqContext {
	var p = new(NamedExpressionSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_namedExpressionSeq

	return p
}

func (s *NamedExpressionSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedExpressionSeqContext) AllNamedExpression() []INamedExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedExpressionContext); ok {
			len++
		}
	}

	tst := make([]INamedExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedExpressionContext); ok {
			tst[i] = t.(INamedExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NamedExpressionSeqContext) NamedExpression(i int) INamedExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionContext)
}

func (s *NamedExpressionSeqContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *NamedExpressionSeqContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *NamedExpressionSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedExpressionSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedExpressionSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterNamedExpressionSeq(s)
	}
}

func (s *NamedExpressionSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitNamedExpressionSeq(s)
	}
}

func (p *DorisParser) NamedExpressionSeq() (localctx INamedExpressionSeqContext) {
	localctx = NewNamedExpressionSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, DorisParserRULE_namedExpressionSeq)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5586)
		p.NamedExpression()
	}
	p.SetState(5591)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 808, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5587)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5588)
				p.NamedExpression()
			}

		}
		p.SetState(5593)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 808, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BooleanExpression() IBooleanExpressionContext
	LambdaExpression() ILambdaExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ExpressionContext) LambdaExpression() ILambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *DorisParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, DorisParserRULE_expression)
	p.SetState(5596)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 809, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5594)
			p.booleanExpression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5595)
			p.LambdaExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaExpressionContext is an interface to support dynamic dispatch.
type ILambdaExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_errorCapturingIdentifier returns the _errorCapturingIdentifier rule contexts.
	Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext

	// GetBody returns the body rule contexts.
	GetBody() IBooleanExpressionContext

	// Set_errorCapturingIdentifier sets the _errorCapturingIdentifier rule contexts.
	Set_errorCapturingIdentifier(IErrorCapturingIdentifierContext)

	// SetBody sets the body rule contexts.
	SetBody(IBooleanExpressionContext)

	// GetArgs returns the args rule context list.
	GetArgs() []IErrorCapturingIdentifierContext

	// SetArgs sets the args rule context list.
	SetArgs([]IErrorCapturingIdentifierContext)

	// Getter signatures
	ARROW() antlr.TerminalNode
	AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext
	ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext
	BooleanExpression() IBooleanExpressionContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLambdaExpressionContext differentiates from other interfaces.
	IsLambdaExpressionContext()
}

type LambdaExpressionContext struct {
	antlr.BaseParserRuleContext
	parser                    antlr.Parser
	_errorCapturingIdentifier IErrorCapturingIdentifierContext
	args                      []IErrorCapturingIdentifierContext
	body                      IBooleanExpressionContext
}

func NewEmptyLambdaExpressionContext() *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_lambdaExpression
	return p
}

func InitEmptyLambdaExpressionContext(p *LambdaExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_lambdaExpression
}

func (*LambdaExpressionContext) IsLambdaExpressionContext() {}

func NewLambdaExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_lambdaExpression

	return p
}

func (s *LambdaExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaExpressionContext) Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext {
	return s._errorCapturingIdentifier
}

func (s *LambdaExpressionContext) GetBody() IBooleanExpressionContext { return s.body }

func (s *LambdaExpressionContext) Set_errorCapturingIdentifier(v IErrorCapturingIdentifierContext) {
	s._errorCapturingIdentifier = v
}

func (s *LambdaExpressionContext) SetBody(v IBooleanExpressionContext) { s.body = v }

func (s *LambdaExpressionContext) GetArgs() []IErrorCapturingIdentifierContext { return s.args }

func (s *LambdaExpressionContext) SetArgs(v []IErrorCapturingIdentifierContext) { s.args = v }

func (s *LambdaExpressionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(DorisParserARROW, 0)
}

func (s *LambdaExpressionContext) AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IErrorCapturingIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			tst[i] = t.(IErrorCapturingIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *LambdaExpressionContext) ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *LambdaExpressionContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LambdaExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *LambdaExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *LambdaExpressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *LambdaExpressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *LambdaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLambdaExpression(s)
	}
}

func (s *LambdaExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLambdaExpression(s)
	}
}

func (p *DorisParser) LambdaExpression() (localctx ILambdaExpressionContext) {
	localctx = NewLambdaExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, DorisParserRULE_lambdaExpression)
	var _la int

	p.SetState(5614)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5598)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*LambdaExpressionContext)._errorCapturingIdentifier = _x
		}
		localctx.(*LambdaExpressionContext).args = append(localctx.(*LambdaExpressionContext).args, localctx.(*LambdaExpressionContext)._errorCapturingIdentifier)
		{
			p.SetState(5599)
			p.Match(DorisParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5600)

			var _x = p.booleanExpression(0)

			localctx.(*LambdaExpressionContext).body = _x
		}

	case DorisParserLEFT_PAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5602)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5603)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*LambdaExpressionContext)._errorCapturingIdentifier = _x
		}
		localctx.(*LambdaExpressionContext).args = append(localctx.(*LambdaExpressionContext).args, localctx.(*LambdaExpressionContext)._errorCapturingIdentifier)
		p.SetState(5606)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == DorisParserCOMMA {
			{
				p.SetState(5604)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5605)

				var _x = p.ErrorCapturingIdentifier()

				localctx.(*LambdaExpressionContext)._errorCapturingIdentifier = _x
			}
			localctx.(*LambdaExpressionContext).args = append(localctx.(*LambdaExpressionContext).args, localctx.(*LambdaExpressionContext)._errorCapturingIdentifier)

			p.SetState(5608)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5610)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5611)
			p.Match(DorisParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5612)

			var _x = p.booleanExpression(0)

			localctx.(*LambdaExpressionContext).body = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanExpressionContext is an interface to support dynamic dispatch.
type IBooleanExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBooleanExpressionContext differentiates from other interfaces.
	IsBooleanExpressionContext()
}

type BooleanExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanExpressionContext() *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_booleanExpression
	return p
}

func InitEmptyBooleanExpressionContext(p *BooleanExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_booleanExpression
}

func (*BooleanExpressionContext) IsBooleanExpressionContext() {}

func NewBooleanExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_booleanExpression

	return p
}

func (s *BooleanExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanExpressionContext) CopyAll(ctx *BooleanExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BooleanExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExistContext struct {
	BooleanExpressionContext
}

func NewExistContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistContext {
	var p = new(ExistContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *ExistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEXISTS, 0)
}

func (s *ExistContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ExistContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *ExistContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ExistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterExist(s)
	}
}

func (s *ExistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitExist(s)
	}
}

type LogicalNotContext struct {
	BooleanExpressionContext
}

func NewLogicalNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalNotContext {
	var p = new(LogicalNotContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalNotContext) LOGICALNOT() antlr.TerminalNode {
	return s.GetToken(DorisParserLOGICALNOT, 0)
}

func (s *LogicalNotContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *LogicalNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLogicalNot(s)
	}
}

func (s *LogicalNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLogicalNot(s)
	}
}

type PredicatedContext struct {
	BooleanExpressionContext
}

func NewPredicatedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicatedContext {
	var p = new(PredicatedContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *PredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicatedContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicatedContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPredicated(s)
	}
}

func (s *PredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPredicated(s)
	}
}

type IsnullContext struct {
	BooleanExpressionContext
}

func NewIsnullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsnullContext {
	var p = new(IsnullContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *IsnullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsnullContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *IsnullContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *IsnullContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *IsnullContext) ISNULL() antlr.TerminalNode {
	return s.GetToken(DorisParserISNULL, 0)
}

func (s *IsnullContext) IS_NULL_PRED() antlr.TerminalNode {
	return s.GetToken(DorisParserIS_NULL_PRED, 0)
}

func (s *IsnullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIsnull(s)
	}
}

func (s *IsnullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIsnull(s)
	}
}

type Is_not_null_predContext struct {
	BooleanExpressionContext
}

func NewIs_not_null_predContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Is_not_null_predContext {
	var p = new(Is_not_null_predContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *Is_not_null_predContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Is_not_null_predContext) IS_NOT_NULL_PRED() antlr.TerminalNode {
	return s.GetToken(DorisParserIS_NOT_NULL_PRED, 0)
}

func (s *Is_not_null_predContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *Is_not_null_predContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *Is_not_null_predContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *Is_not_null_predContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIs_not_null_pred(s)
	}
}

func (s *Is_not_null_predContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIs_not_null_pred(s)
	}
}

type LogicalBinaryContext struct {
	BooleanExpressionContext
	left     IBooleanExpressionContext
	operator antlr.Token
	right    IBooleanExpressionContext
}

func NewLogicalBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalBinaryContext {
	var p = new(LogicalBinaryContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *LogicalBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *LogicalBinaryContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *LogicalBinaryContext) GetRight() IBooleanExpressionContext { return s.right }

func (s *LogicalBinaryContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *LogicalBinaryContext) SetRight(v IBooleanExpressionContext) { s.right = v }

func (s *LogicalBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalBinaryContext) AllBooleanExpression() []IBooleanExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			len++
		}
	}

	tst := make([]IBooleanExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBooleanExpressionContext); ok {
			tst[i] = t.(IBooleanExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalBinaryContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalBinaryContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisParserAND, 0)
}

func (s *LogicalBinaryContext) LOGICALAND() antlr.TerminalNode {
	return s.GetToken(DorisParserLOGICALAND, 0)
}

func (s *LogicalBinaryContext) XOR() antlr.TerminalNode {
	return s.GetToken(DorisParserXOR, 0)
}

func (s *LogicalBinaryContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisParserOR, 0)
}

func (s *LogicalBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLogicalBinary(s)
	}
}

type DoublePipesContext struct {
	BooleanExpressionContext
	left     IBooleanExpressionContext
	operator antlr.Token
	right    IBooleanExpressionContext
}

func NewDoublePipesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoublePipesContext {
	var p = new(DoublePipesContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *DoublePipesContext) GetOperator() antlr.Token { return s.operator }

func (s *DoublePipesContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *DoublePipesContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *DoublePipesContext) GetRight() IBooleanExpressionContext { return s.right }

func (s *DoublePipesContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *DoublePipesContext) SetRight(v IBooleanExpressionContext) { s.right = v }

func (s *DoublePipesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoublePipesContext) AllBooleanExpression() []IBooleanExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			len++
		}
	}

	tst := make([]IBooleanExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBooleanExpressionContext); ok {
			tst[i] = t.(IBooleanExpressionContext)
			i++
		}
	}

	return tst
}

func (s *DoublePipesContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *DoublePipesContext) DOUBLEPIPES() antlr.TerminalNode {
	return s.GetToken(DorisParserDOUBLEPIPES, 0)
}

func (s *DoublePipesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDoublePipes(s)
	}
}

func (s *DoublePipesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDoublePipes(s)
	}
}

func (p *DorisParser) BooleanExpression() (localctx IBooleanExpressionContext) {
	return p.booleanExpression(0)
}

func (p *DorisParser) booleanExpression(_p int) (localctx IBooleanExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBooleanExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBooleanExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 372
	p.EnterRecursionRule(localctx, 372, DorisParserRULE_booleanExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5640)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 813, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(5617)
			p.Match(DorisParserLOGICALNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5618)
			p.booleanExpression(10)
		}

	case 2:
		localctx = NewExistContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5619)
			p.Match(DorisParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5620)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5621)
			p.Query()
		}
		{
			p.SetState(5622)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewIsnullContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5624)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserIS_NULL_PRED || _la == DorisParserISNULL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5625)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5626)
			p.valueExpression(0)
		}
		{
			p.SetState(5627)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewIs_not_null_predContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5629)
			p.Match(DorisParserIS_NOT_NULL_PRED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5630)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5631)
			p.valueExpression(0)
		}
		{
			p.SetState(5632)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewPredicatedContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5634)
			p.valueExpression(0)
		}
		p.SetState(5636)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 812, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5635)
				p.Predicate()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5638)
			p.Match(DorisParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5639)
			p.booleanExpression(5)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(5656)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 815, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(5654)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 814, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_booleanExpression)
				p.SetState(5642)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(5643)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*LogicalBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisParserAND || _la == DorisParserLOGICALAND) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*LogicalBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(5644)

					var _x = p.booleanExpression(5)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 2:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_booleanExpression)
				p.SetState(5645)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(5646)

					var _m = p.Match(DorisParserXOR)

					localctx.(*LogicalBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5647)

					var _x = p.booleanExpression(4)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 3:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_booleanExpression)
				p.SetState(5648)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(5649)

					var _m = p.Match(DorisParserOR)

					localctx.(*LogicalBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5650)

					var _x = p.booleanExpression(3)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 4:
				localctx = NewDoublePipesContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*DoublePipesContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_booleanExpression)
				p.SetState(5651)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(5652)

					var _m = p.Match(DorisParserDOUBLEPIPES)

					localctx.(*DoublePipesContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5653)

					var _x = p.booleanExpression(2)

					localctx.(*DoublePipesContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(5658)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 815, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowConstructorContext is an interface to support dynamic dispatch.
type IRowConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllRowConstructorItem() []IRowConstructorItemContext
	RowConstructorItem(i int) IRowConstructorItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRowConstructorContext differentiates from other interfaces.
	IsRowConstructorContext()
}

type RowConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowConstructorContext() *RowConstructorContext {
	var p = new(RowConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_rowConstructor
	return p
}

func InitEmptyRowConstructorContext(p *RowConstructorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_rowConstructor
}

func (*RowConstructorContext) IsRowConstructorContext() {}

func NewRowConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowConstructorContext {
	var p = new(RowConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_rowConstructor

	return p
}

func (s *RowConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *RowConstructorContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *RowConstructorContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *RowConstructorContext) AllRowConstructorItem() []IRowConstructorItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRowConstructorItemContext); ok {
			len++
		}
	}

	tst := make([]IRowConstructorItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRowConstructorItemContext); ok {
			tst[i] = t.(IRowConstructorItemContext)
			i++
		}
	}

	return tst
}

func (s *RowConstructorContext) RowConstructorItem(i int) IRowConstructorItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowConstructorItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowConstructorItemContext)
}

func (s *RowConstructorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *RowConstructorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *RowConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRowConstructor(s)
	}
}

func (s *RowConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRowConstructor(s)
	}
}

func (p *DorisParser) RowConstructor() (localctx IRowConstructorContext) {
	localctx = NewRowConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, DorisParserRULE_rowConstructor)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5659)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5668)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305884869834611068) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-4612819754502202371) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4539691388691605019) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&2845980307192511093) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&8572566566736488189) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-304588910535901189) != 0) || ((int64((_la-391)) & ^0x3f) == 0 && ((int64(1)<<(_la-391))&1188948054525295071) != 0) || ((int64((_la-455)) & ^0x3f) == 0 && ((int64(1)<<(_la-455))&2458964612221977455) != 0) || ((int64((_la-524)) & ^0x3f) == 0 && ((int64(1)<<(_la-524))&923779367) != 0) {
		{
			p.SetState(5660)
			p.RowConstructorItem()
		}
		p.SetState(5665)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(5661)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5662)
				p.RowConstructorItem()
			}

			p.SetState(5667)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(5670)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowConstructorItemContext is an interface to support dynamic dispatch.
type IRowConstructorItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext
	DEFAULT() antlr.TerminalNode
	NamedExpression() INamedExpressionContext

	// IsRowConstructorItemContext differentiates from other interfaces.
	IsRowConstructorItemContext()
}

type RowConstructorItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowConstructorItemContext() *RowConstructorItemContext {
	var p = new(RowConstructorItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_rowConstructorItem
	return p
}

func InitEmptyRowConstructorItemContext(p *RowConstructorItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_rowConstructorItem
}

func (*RowConstructorItemContext) IsRowConstructorItemContext() {}

func NewRowConstructorItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowConstructorItemContext {
	var p = new(RowConstructorItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_rowConstructorItem

	return p
}

func (s *RowConstructorItemContext) GetParser() antlr.Parser { return s.parser }

func (s *RowConstructorItemContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *RowConstructorItemContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *RowConstructorItemContext) NamedExpression() INamedExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionContext)
}

func (s *RowConstructorItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowConstructorItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowConstructorItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRowConstructorItem(s)
	}
}

func (s *RowConstructorItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRowConstructorItem(s)
	}
}

func (p *DorisParser) RowConstructorItem() (localctx IRowConstructorItemContext) {
	localctx = NewRowConstructorItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, DorisParserRULE_rowConstructorItem)
	p.SetState(5675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 818, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5672)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5673)
			p.Match(DorisParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5674)
			p.NamedExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKind returns the kind token.
	GetKind() antlr.Token

	// SetKind sets the kind token.
	SetKind(antlr.Token)

	// GetLower returns the lower rule contexts.
	GetLower() IValueExpressionContext

	// GetUpper returns the upper rule contexts.
	GetUpper() IValueExpressionContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IValueExpressionContext

	// SetLower sets the lower rule contexts.
	SetLower(IValueExpressionContext)

	// SetUpper sets the upper rule contexts.
	SetUpper(IValueExpressionContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IValueExpressionContext)

	// Getter signatures
	AND() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	AllValueExpression() []IValueExpressionContext
	ValueExpression(i int) IValueExpressionContext
	NOT() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	REGEXP() antlr.TerminalNode
	RLIKE() antlr.TerminalNode
	MATCH() antlr.TerminalNode
	MATCH_ANY() antlr.TerminalNode
	MATCH_ALL() antlr.TerminalNode
	MATCH_PHRASE() antlr.TerminalNode
	MATCH_PHRASE_PREFIX() antlr.TerminalNode
	MATCH_REGEXP() antlr.TerminalNode
	MATCH_PHRASE_EDGE() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	Query() IQueryContext
	RIGHT_PAREN() antlr.TerminalNode
	IN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	IS() antlr.TerminalNode
	NULL() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	kind    antlr.Token
	lower   IValueExpressionContext
	upper   IValueExpressionContext
	pattern IValueExpressionContext
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_predicate
	return p
}

func InitEmptyPredicateContext(p *PredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_predicate
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) GetKind() antlr.Token { return s.kind }

func (s *PredicateContext) SetKind(v antlr.Token) { s.kind = v }

func (s *PredicateContext) GetLower() IValueExpressionContext { return s.lower }

func (s *PredicateContext) GetUpper() IValueExpressionContext { return s.upper }

func (s *PredicateContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *PredicateContext) SetLower(v IValueExpressionContext) { s.lower = v }

func (s *PredicateContext) SetUpper(v IValueExpressionContext) { s.upper = v }

func (s *PredicateContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *PredicateContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisParserAND, 0)
}

func (s *PredicateContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(DorisParserBETWEEN, 0)
}

func (s *PredicateContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PredicateContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *PredicateContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *PredicateContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(DorisParserREGEXP, 0)
}

func (s *PredicateContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserRLIKE, 0)
}

func (s *PredicateContext) MATCH() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH, 0)
}

func (s *PredicateContext) MATCH_ANY() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_ANY, 0)
}

func (s *PredicateContext) MATCH_ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_ALL, 0)
}

func (s *PredicateContext) MATCH_PHRASE() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_PHRASE, 0)
}

func (s *PredicateContext) MATCH_PHRASE_PREFIX() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_PHRASE_PREFIX, 0)
}

func (s *PredicateContext) MATCH_REGEXP() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_REGEXP, 0)
}

func (s *PredicateContext) MATCH_PHRASE_EDGE() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_PHRASE_EDGE, 0)
}

func (s *PredicateContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *PredicateContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *PredicateContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *PredicateContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserIN, 0)
}

func (s *PredicateContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PredicateContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PredicateContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *PredicateContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *PredicateContext) IS() antlr.TerminalNode {
	return s.GetToken(DorisParserIS, 0)
}

func (s *PredicateContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisParserNULL, 0)
}

func (s *PredicateContext) TRUE() antlr.TerminalNode {
	return s.GetToken(DorisParserTRUE, 0)
}

func (s *PredicateContext) FALSE() antlr.TerminalNode {
	return s.GetToken(DorisParserFALSE, 0)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPredicate(s)
	}
}

func (s *PredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPredicate(s)
	}
}

func (p *DorisParser) Predicate() (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, DorisParserRULE_predicate)
	var _la int

	p.SetState(5728)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 827, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5678)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(5677)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5680)

			var _m = p.Match(DorisParserBETWEEN)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5681)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).lower = _x
		}
		{
			p.SetState(5682)
			p.Match(DorisParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5683)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).upper = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5686)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(5685)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5688)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PredicateContext).kind = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserLIKE || _la == DorisParserREGEXP || _la == DorisParserRLIKE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PredicateContext).kind = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5689)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).pattern = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(5691)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(5690)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5693)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PredicateContext).kind = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&127) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PredicateContext).kind = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5694)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).pattern = _x
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(5696)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(5695)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5698)

			var _m = p.Match(DorisParserIN)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5699)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5700)
			p.Query()
		}
		{
			p.SetState(5701)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(5704)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(5703)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5706)

			var _m = p.Match(DorisParserIN)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5707)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5708)
			p.Expression()
		}
		p.SetState(5713)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(5709)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5710)
				p.Expression()
			}

			p.SetState(5715)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5716)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5718)
			p.Match(DorisParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5720)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(5719)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5722)

			var _m = p.Match(DorisParserNULL)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5723)
			p.Match(DorisParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5725)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(5724)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5727)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PredicateContext).kind = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserFALSE || _la == DorisParserTRUE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PredicateContext).kind = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueExpressionContext is an interface to support dynamic dispatch.
type IValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsValueExpressionContext differentiates from other interfaces.
	IsValueExpressionContext()
}

type ValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExpressionContext() *ValueExpressionContext {
	var p = new(ValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_valueExpression
	return p
}

func InitEmptyValueExpressionContext(p *ValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_valueExpression
}

func (*ValueExpressionContext) IsValueExpressionContext() {}

func NewValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExpressionContext {
	var p = new(ValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_valueExpression

	return p
}

func (s *ValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExpressionContext) CopyAll(ctx *ValueExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ValueExpressionDefaultContext struct {
	ValueExpressionContext
}

func NewValueExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValueExpressionDefaultContext {
	var p = new(ValueExpressionDefaultContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ValueExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionDefaultContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ValueExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitValueExpressionDefault(s)
	}
}

type ComparisonContext struct {
	ValueExpressionContext
	left  IValueExpressionContext
	right IValueExpressionContext
}

func NewComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonContext {
	var p = new(ComparisonContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ComparisonContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ComparisonContext) GetRight() IValueExpressionContext { return s.right }

func (s *ComparisonContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ComparisonContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitComparison(s)
	}
}

type ArithmeticBinaryContext struct {
	ValueExpressionContext
	left     IValueExpressionContext
	operator antlr.Token
	right    IValueExpressionContext
}

func NewArithmeticBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticBinaryContext {
	var p = new(ArithmeticBinaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticBinaryContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ArithmeticBinaryContext) GetRight() IValueExpressionContext { return s.right }

func (s *ArithmeticBinaryContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ArithmeticBinaryContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ArithmeticBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticBinaryContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArithmeticBinaryContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticBinaryContext) HAT() antlr.TerminalNode {
	return s.GetToken(DorisParserHAT, 0)
}

func (s *ArithmeticBinaryContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserASTERISK, 0)
}

func (s *ArithmeticBinaryContext) SLASH() antlr.TerminalNode {
	return s.GetToken(DorisParserSLASH, 0)
}

func (s *ArithmeticBinaryContext) MOD() antlr.TerminalNode {
	return s.GetToken(DorisParserMOD, 0)
}

func (s *ArithmeticBinaryContext) DIV() antlr.TerminalNode {
	return s.GetToken(DorisParserDIV, 0)
}

func (s *ArithmeticBinaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(DorisParserPLUS, 0)
}

func (s *ArithmeticBinaryContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(DorisParserSUBTRACT, 0)
}

func (s *ArithmeticBinaryContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(DorisParserAMPERSAND, 0)
}

func (s *ArithmeticBinaryContext) PIPE() antlr.TerminalNode {
	return s.GetToken(DorisParserPIPE, 0)
}

func (s *ArithmeticBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitArithmeticBinary(s)
	}
}

type ArithmeticUnaryContext struct {
	ValueExpressionContext
	operator antlr.Token
}

func NewArithmeticUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticUnaryContext {
	var p = new(ArithmeticUnaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticUnaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticUnaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticUnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticUnaryContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticUnaryContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(DorisParserSUBTRACT, 0)
}

func (s *ArithmeticUnaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(DorisParserPLUS, 0)
}

func (s *ArithmeticUnaryContext) TILDE() antlr.TerminalNode {
	return s.GetToken(DorisParserTILDE, 0)
}

func (s *ArithmeticUnaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitArithmeticUnary(s)
	}
}

func (p *DorisParser) ValueExpression() (localctx IValueExpressionContext) {
	return p.valueExpression(0)
}

func (p *DorisParser) valueExpression(_p int) (localctx IValueExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewValueExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 380
	p.EnterRecursionRule(localctx, 380, DorisParserRULE_valueExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5734)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 828, p.GetParserRuleContext()) {
	case 1:
		localctx = NewValueExpressionDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(5731)
			p.primaryExpression(0)
		}

	case 2:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5732)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ArithmeticUnaryContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-524)) & ^0x3f) == 0 && ((int64(1)<<(_la-524))&35) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ArithmeticUnaryContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5733)
			p.valueExpression(7)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(5757)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 830, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(5755)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 829, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_valueExpression)
				p.SetState(5736)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(5737)

					var _m = p.Match(DorisParserHAT)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5738)

					var _x = p.valueExpression(7)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 2:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_valueExpression)
				p.SetState(5739)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(5740)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisParserDIV || ((int64((_la-526)) & ^0x3f) == 0 && ((int64(1)<<(_la-526))&7) != 0)) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(5741)

					var _x = p.valueExpression(6)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 3:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_valueExpression)
				p.SetState(5742)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(5743)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisParserPLUS || _la == DorisParserSUBTRACT) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(5744)

					var _x = p.valueExpression(5)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 4:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_valueExpression)
				p.SetState(5745)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(5746)

					var _m = p.Match(DorisParserAMPERSAND)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5747)

					var _x = p.valueExpression(4)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 5:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_valueExpression)
				p.SetState(5748)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(5749)

					var _m = p.Match(DorisParserPIPE)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5750)

					var _x = p.valueExpression(3)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 6:
				localctx = NewComparisonContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ComparisonContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_valueExpression)
				p.SetState(5751)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(5752)
					p.ComparisonOperator()
				}
				{
					p.SetState(5753)

					var _x = p.valueExpression(2)

					localctx.(*ComparisonContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(5759)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 830, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_primaryExpression
	return p
}

func InitEmptyPrimaryExpressionContext(p *PrimaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_primaryExpression
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) CopyAll(ctx *PrimaryExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DereferenceContext struct {
	PrimaryExpressionContext
	base      IPrimaryExpressionContext
	fieldName IIdentifierContext
}

func NewDereferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DereferenceContext {
	var p = new(DereferenceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DereferenceContext) GetBase() IPrimaryExpressionContext { return s.base }

func (s *DereferenceContext) GetFieldName() IIdentifierContext { return s.fieldName }

func (s *DereferenceContext) SetBase(v IPrimaryExpressionContext) { s.base = v }

func (s *DereferenceContext) SetFieldName(v IIdentifierContext) { s.fieldName = v }

func (s *DereferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DereferenceContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *DereferenceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *DereferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DereferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDereference(s)
	}
}

func (s *DereferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDereference(s)
	}
}

type CurrentDateContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentDateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentDateContext {
	var p = new(CurrentDateContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentDateContext) GetName() antlr.Token { return s.name }

func (s *CurrentDateContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentDateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentDateContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_DATE, 0)
}

func (s *CurrentDateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCurrentDate(s)
	}
}

func (s *CurrentDateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCurrentDate(s)
	}
}

type CastContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastContext {
	var p = new(CastContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CastContext) GetName() antlr.Token { return s.name }

func (s *CastContext) SetName(v antlr.Token) { s.name = v }

func (s *CastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CastContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *CastContext) CastDataType() ICastDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastDataTypeContext)
}

func (s *CastContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CastContext) CAST() antlr.TerminalNode {
	return s.GetToken(DorisParserCAST, 0)
}

func (s *CastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCast(s)
	}
}

func (s *CastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCast(s)
	}
}

type ParenthesizedExpressionContext struct {
	PrimaryExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

type UserVariableContext struct {
	PrimaryExpressionContext
}

func NewUserVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserVariableContext {
	var p = new(UserVariableContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *UserVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserVariableContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserATSIGN, 0)
}

func (s *UserVariableContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *UserVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUserVariable(s)
	}
}

func (s *UserVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUserVariable(s)
	}
}

type ElementAtContext struct {
	PrimaryExpressionContext
	value IPrimaryExpressionContext
	index IValueExpressionContext
}

func NewElementAtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ElementAtContext {
	var p = new(ElementAtContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ElementAtContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *ElementAtContext) GetIndex() IValueExpressionContext { return s.index }

func (s *ElementAtContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *ElementAtContext) SetIndex(v IValueExpressionContext) { s.index = v }

func (s *ElementAtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementAtContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACKET, 0)
}

func (s *ElementAtContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACKET, 0)
}

func (s *ElementAtContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ElementAtContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ElementAtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterElementAt(s)
	}
}

func (s *ElementAtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitElementAt(s)
	}
}

type LocalTimestampContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewLocalTimestampContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LocalTimestampContext {
	var p = new(LocalTimestampContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LocalTimestampContext) GetName() antlr.Token { return s.name }

func (s *LocalTimestampContext) SetName(v antlr.Token) { s.name = v }

func (s *LocalTimestampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalTimestampContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCALTIMESTAMP, 0)
}

func (s *LocalTimestampContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLocalTimestamp(s)
	}
}

func (s *LocalTimestampContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLocalTimestamp(s)
	}
}

type CharFunctionContext struct {
	PrimaryExpressionContext
	_expression IExpressionContext
	arguments   []IExpressionContext
	charSet     IIdentifierOrTextContext
}

func NewCharFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CharFunctionContext {
	var p = new(CharFunctionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CharFunctionContext) Get_expression() IExpressionContext { return s._expression }

func (s *CharFunctionContext) GetCharSet() IIdentifierOrTextContext { return s.charSet }

func (s *CharFunctionContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *CharFunctionContext) SetCharSet(v IIdentifierOrTextContext) { s.charSet = v }

func (s *CharFunctionContext) GetArguments() []IExpressionContext { return s.arguments }

func (s *CharFunctionContext) SetArguments(v []IExpressionContext) { s.arguments = v }

func (s *CharFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharFunctionContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserCHAR, 0)
}

func (s *CharFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *CharFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *CharFunctionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CharFunctionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CharFunctionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *CharFunctionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *CharFunctionContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserUSING, 0)
}

func (s *CharFunctionContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CharFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCharFunction(s)
	}
}

func (s *CharFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCharFunction(s)
	}
}

type IntervalLiteralContext struct {
	PrimaryExpressionContext
}

func NewIntervalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalLiteralContext {
	var p = new(IntervalLiteralContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *IntervalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalLiteralContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *IntervalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIntervalLiteral(s)
	}
}

func (s *IntervalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIntervalLiteral(s)
	}
}

type SimpleCaseContext struct {
	PrimaryExpressionContext
	value          IExpressionContext
	elseExpression IExpressionContext
}

func NewSimpleCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleCaseContext {
	var p = new(SimpleCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SimpleCaseContext) GetValue() IExpressionContext { return s.value }

func (s *SimpleCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SimpleCaseContext) SetValue(v IExpressionContext) { s.value = v }

func (s *SimpleCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SimpleCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(DorisParserCASE, 0)
}

func (s *SimpleCaseContext) END() antlr.TerminalNode {
	return s.GetToken(DorisParserEND, 0)
}

func (s *SimpleCaseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SimpleCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(DorisParserELSE, 0)
}

func (s *SimpleCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSimpleCase(s)
	}
}

func (s *SimpleCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSimpleCase(s)
	}
}

type ColumnReferenceContext struct {
	PrimaryExpressionContext
}

func NewColumnReferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnReferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnReferenceContext) BINARY() antlr.TerminalNode {
	return s.GetToken(DorisParserBINARY, 0)
}

func (s *ColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterColumnReference(s)
	}
}

func (s *ColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitColumnReference(s)
	}
}

type StarContext struct {
	PrimaryExpressionContext
}

func NewStarContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StarContext {
	var p = new(StarContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *StarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StarContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserASTERISK, 0)
}

func (s *StarContext) AllExceptOrReplace() []IExceptOrReplaceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExceptOrReplaceContext); ok {
			len++
		}
	}

	tst := make([]IExceptOrReplaceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExceptOrReplaceContext); ok {
			tst[i] = t.(IExceptOrReplaceContext)
			i++
		}
	}

	return tst
}

func (s *StarContext) ExceptOrReplace(i int) IExceptOrReplaceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExceptOrReplaceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExceptOrReplaceContext)
}

func (s *StarContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *StarContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *StarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStar(s)
	}
}

func (s *StarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStar(s)
	}
}

type SessionUserContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewSessionUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SessionUserContext {
	var p = new(SessionUserContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SessionUserContext) GetName() antlr.Token { return s.name }

func (s *SessionUserContext) SetName(v antlr.Token) { s.name = v }

func (s *SessionUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SessionUserContext) SESSION_USER() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION_USER, 0)
}

func (s *SessionUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSessionUser(s)
	}
}

func (s *SessionUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSessionUser(s)
	}
}

type ConvertTypeContext struct {
	PrimaryExpressionContext
	argument IExpressionContext
}

func NewConvertTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConvertTypeContext {
	var p = new(ConvertTypeContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ConvertTypeContext) GetArgument() IExpressionContext { return s.argument }

func (s *ConvertTypeContext) SetArgument(v IExpressionContext) { s.argument = v }

func (s *ConvertTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertTypeContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(DorisParserCONVERT, 0)
}

func (s *ConvertTypeContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ConvertTypeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, 0)
}

func (s *ConvertTypeContext) CastDataType() ICastDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastDataTypeContext)
}

func (s *ConvertTypeContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ConvertTypeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConvertTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterConvertType(s)
	}
}

func (s *ConvertTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitConvertType(s)
	}
}

type ConvertCharSetContext struct {
	PrimaryExpressionContext
	argument IExpressionContext
	charSet  IIdentifierOrTextContext
}

func NewConvertCharSetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConvertCharSetContext {
	var p = new(ConvertCharSetContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ConvertCharSetContext) GetArgument() IExpressionContext { return s.argument }

func (s *ConvertCharSetContext) GetCharSet() IIdentifierOrTextContext { return s.charSet }

func (s *ConvertCharSetContext) SetArgument(v IExpressionContext) { s.argument = v }

func (s *ConvertCharSetContext) SetCharSet(v IIdentifierOrTextContext) { s.charSet = v }

func (s *ConvertCharSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertCharSetContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(DorisParserCONVERT, 0)
}

func (s *ConvertCharSetContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ConvertCharSetContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserUSING, 0)
}

func (s *ConvertCharSetContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ConvertCharSetContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConvertCharSetContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *ConvertCharSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterConvertCharSet(s)
	}
}

func (s *ConvertCharSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitConvertCharSet(s)
	}
}

type SubqueryExpressionContext struct {
	PrimaryExpressionContext
}

func NewSubqueryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryExpressionContext {
	var p = new(SubqueryExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubqueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *SubqueryExpressionContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *SubqueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSubqueryExpression(s)
	}
}

func (s *SubqueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSubqueryExpression(s)
	}
}

type EncryptKeyContext struct {
	PrimaryExpressionContext
	dbName  IIdentifierContext
	keyName IIdentifierContext
}

func NewEncryptKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EncryptKeyContext {
	var p = new(EncryptKeyContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *EncryptKeyContext) GetDbName() IIdentifierContext { return s.dbName }

func (s *EncryptKeyContext) GetKeyName() IIdentifierContext { return s.keyName }

func (s *EncryptKeyContext) SetDbName(v IIdentifierContext) { s.dbName = v }

func (s *EncryptKeyContext) SetKeyName(v IIdentifierContext) { s.keyName = v }

func (s *EncryptKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EncryptKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserKEY, 0)
}

func (s *EncryptKeyContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *EncryptKeyContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EncryptKeyContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *EncryptKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterEncryptKey(s)
	}
}

func (s *EncryptKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitEncryptKey(s)
	}
}

type CurrentTimeContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentTimeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentTimeContext {
	var p = new(CurrentTimeContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentTimeContext) GetName() antlr.Token { return s.name }

func (s *CurrentTimeContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentTimeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentTimeContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_TIME, 0)
}

func (s *CurrentTimeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCurrentTime(s)
	}
}

func (s *CurrentTimeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCurrentTime(s)
	}
}

type LocalTimeContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewLocalTimeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LocalTimeContext {
	var p = new(LocalTimeContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LocalTimeContext) GetName() antlr.Token { return s.name }

func (s *LocalTimeContext) SetName(v antlr.Token) { s.name = v }

func (s *LocalTimeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalTimeContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCALTIME, 0)
}

func (s *LocalTimeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterLocalTime(s)
	}
}

func (s *LocalTimeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitLocalTime(s)
	}
}

type SystemVariableContext struct {
	PrimaryExpressionContext
	kind antlr.Token
}

func NewSystemVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SystemVariableContext {
	var p = new(SystemVariableContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SystemVariableContext) GetKind() antlr.Token { return s.kind }

func (s *SystemVariableContext) SetKind(v antlr.Token) { s.kind = v }

func (s *SystemVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SystemVariableContext) DOUBLEATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserDOUBLEATSIGN, 0)
}

func (s *SystemVariableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SystemVariableContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *SystemVariableContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *SystemVariableContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION, 0)
}

func (s *SystemVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSystemVariable(s)
	}
}

func (s *SystemVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSystemVariable(s)
	}
}

type CollateContext struct {
	PrimaryExpressionContext
}

func NewCollateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollateContext {
	var p = new(CollateContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *CollateContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLLATE, 0)
}

func (s *CollateContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CollateContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CollateContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFAULT, 0)
}

func (s *CollateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCollate(s)
	}
}

func (s *CollateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCollate(s)
	}
}

type CurrentUserContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentUserContext {
	var p = new(CurrentUserContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentUserContext) GetName() antlr.Token { return s.name }

func (s *CurrentUserContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentUserContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_USER, 0)
}

func (s *CurrentUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCurrentUser(s)
	}
}

func (s *CurrentUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCurrentUser(s)
	}
}

type ConstantDefaultContext struct {
	PrimaryExpressionContext
}

func NewConstantDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstantDefaultContext {
	var p = new(ConstantDefaultContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ConstantDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantDefaultContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterConstantDefault(s)
	}
}

func (s *ConstantDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitConstantDefault(s)
	}
}

type ExtractContext struct {
	PrimaryExpressionContext
	field  IIdentifierContext
	source IValueExpressionContext
}

func NewExtractContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExtractContext {
	var p = new(ExtractContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ExtractContext) GetField() IIdentifierContext { return s.field }

func (s *ExtractContext) GetSource() IValueExpressionContext { return s.source }

func (s *ExtractContext) SetField(v IIdentifierContext) { s.field = v }

func (s *ExtractContext) SetSource(v IValueExpressionContext) { s.source = v }

func (s *ExtractContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(DorisParserEXTRACT, 0)
}

func (s *ExtractContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ExtractContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserFROM, 0)
}

func (s *ExtractContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ExtractContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExtractContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ExtractContext) DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATE, 0)
}

func (s *ExtractContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserTIMESTAMP, 0)
}

func (s *ExtractContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterExtract(s)
	}
}

func (s *ExtractContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitExtract(s)
	}
}

type CurrentTimestampContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentTimestampContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentTimestampContext {
	var p = new(CurrentTimestampContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentTimestampContext) GetName() antlr.Token { return s.name }

func (s *CurrentTimestampContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentTimestampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentTimestampContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_TIMESTAMP, 0)
}

func (s *CurrentTimestampContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCurrentTimestamp(s)
	}
}

func (s *CurrentTimestampContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCurrentTimestamp(s)
	}
}

type FunctionCallContext struct {
	PrimaryExpressionContext
}

func NewFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallContext {
	var p = new(FunctionCallContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) FunctionCallExpression() IFunctionCallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallExpressionContext)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

type ArraySliceContext struct {
	PrimaryExpressionContext
	value IPrimaryExpressionContext
	begin IValueExpressionContext
	end   IValueExpressionContext
}

func NewArraySliceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArraySliceContext {
	var p = new(ArraySliceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArraySliceContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *ArraySliceContext) GetBegin() IValueExpressionContext { return s.begin }

func (s *ArraySliceContext) GetEnd() IValueExpressionContext { return s.end }

func (s *ArraySliceContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *ArraySliceContext) SetBegin(v IValueExpressionContext) { s.begin = v }

func (s *ArraySliceContext) SetEnd(v IValueExpressionContext) { s.end = v }

func (s *ArraySliceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArraySliceContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACKET, 0)
}

func (s *ArraySliceContext) COLON() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLON, 0)
}

func (s *ArraySliceContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACKET, 0)
}

func (s *ArraySliceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ArraySliceContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArraySliceContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArraySliceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterArraySlice(s)
	}
}

func (s *ArraySliceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitArraySlice(s)
	}
}

type SearchedCaseContext struct {
	PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSearchedCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SearchedCaseContext {
	var p = new(SearchedCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SearchedCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SearchedCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SearchedCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(DorisParserCASE, 0)
}

func (s *SearchedCaseContext) END() antlr.TerminalNode {
	return s.GetToken(DorisParserEND, 0)
}

func (s *SearchedCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SearchedCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SearchedCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(DorisParserELSE, 0)
}

func (s *SearchedCaseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SearchedCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSearchedCase(s)
	}
}

func (s *SearchedCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSearchedCase(s)
	}
}

func (p *DorisParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	return p.primaryExpression(0)
}

func (p *DorisParser) primaryExpression(_p int) (localctx IPrimaryExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 382
	p.EnterRecursionRule(localctx, 382, DorisParserRULE_primaryExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5886)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 843, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCurrentDateContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(5761)

			var _m = p.Match(DorisParserCURRENT_DATE)

			localctx.(*CurrentDateContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewCurrentTimeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5762)

			var _m = p.Match(DorisParserCURRENT_TIME)

			localctx.(*CurrentTimeContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewCurrentTimestampContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5763)

			var _m = p.Match(DorisParserCURRENT_TIMESTAMP)

			localctx.(*CurrentTimestampContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewLocalTimeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5764)

			var _m = p.Match(DorisParserLOCALTIME)

			localctx.(*LocalTimeContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewLocalTimestampContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5765)

			var _m = p.Match(DorisParserLOCALTIMESTAMP)

			localctx.(*LocalTimestampContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewCurrentUserContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5766)

			var _m = p.Match(DorisParserCURRENT_USER)

			localctx.(*CurrentUserContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewSessionUserContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5767)

			var _m = p.Match(DorisParserSESSION_USER)

			localctx.(*SessionUserContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewSearchedCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5768)
			p.Match(DorisParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5770)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == DorisParserWHEN {
			{
				p.SetState(5769)
				p.WhenClause()
			}

			p.SetState(5772)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5776)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserELSE {
			{
				p.SetState(5774)
				p.Match(DorisParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5775)

				var _x = p.Expression()

				localctx.(*SearchedCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(5778)
			p.Match(DorisParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewSimpleCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5780)
			p.Match(DorisParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5781)

			var _x = p.Expression()

			localctx.(*SimpleCaseContext).value = _x
		}
		p.SetState(5783)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == DorisParserWHEN {
			{
				p.SetState(5782)
				p.WhenClause()
			}

			p.SetState(5785)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5789)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserELSE {
			{
				p.SetState(5787)
				p.Match(DorisParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5788)

				var _x = p.Expression()

				localctx.(*SimpleCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(5791)
			p.Match(DorisParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5793)

			var _m = p.Match(DorisParserCAST)

			localctx.(*CastContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5794)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5795)
			p.Expression()
		}
		{
			p.SetState(5796)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5797)
			p.CastDataType()
		}
		{
			p.SetState(5798)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewConstantDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5800)
			p.Constant()
		}

	case 12:
		localctx = NewIntervalLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5801)
			p.Interval()
		}

	case 13:
		localctx = NewStarContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5802)
			p.Match(DorisParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5806)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 835, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(5803)
					p.ExceptOrReplace()
				}

			}
			p.SetState(5808)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 835, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 14:
		localctx = NewStarContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5809)
			p.QualifiedName()
		}
		{
			p.SetState(5810)
			p.Match(DorisParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5811)
			p.Match(DorisParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5815)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 836, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(5812)
					p.ExceptOrReplace()
				}

			}
			p.SetState(5817)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 836, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 15:
		localctx = NewCharFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5818)
			p.Match(DorisParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5819)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5820)

			var _x = p.Expression()

			localctx.(*CharFunctionContext)._expression = _x
		}
		localctx.(*CharFunctionContext).arguments = append(localctx.(*CharFunctionContext).arguments, localctx.(*CharFunctionContext)._expression)
		p.SetState(5825)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(5821)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5822)

				var _x = p.Expression()

				localctx.(*CharFunctionContext)._expression = _x
			}
			localctx.(*CharFunctionContext).arguments = append(localctx.(*CharFunctionContext).arguments, localctx.(*CharFunctionContext)._expression)

			p.SetState(5827)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5830)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserUSING {
			{
				p.SetState(5828)
				p.Match(DorisParserUSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5829)

				var _x = p.IdentifierOrText()

				localctx.(*CharFunctionContext).charSet = _x
			}

		}
		{
			p.SetState(5832)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		localctx = NewConvertCharSetContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5834)
			p.Match(DorisParserCONVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5835)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5836)

			var _x = p.Expression()

			localctx.(*ConvertCharSetContext).argument = _x
		}
		{
			p.SetState(5837)
			p.Match(DorisParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5838)

			var _x = p.IdentifierOrText()

			localctx.(*ConvertCharSetContext).charSet = _x
		}
		{
			p.SetState(5839)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		localctx = NewConvertTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5841)
			p.Match(DorisParserCONVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5842)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5843)

			var _x = p.Expression()

			localctx.(*ConvertTypeContext).argument = _x
		}
		{
			p.SetState(5844)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5845)
			p.CastDataType()
		}
		{
			p.SetState(5846)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5848)
			p.FunctionCallExpression()
		}

	case 19:
		localctx = NewSubqueryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5849)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5850)
			p.Query()
		}
		{
			p.SetState(5851)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		localctx = NewUserVariableContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5853)
			p.Match(DorisParserATSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5854)
			p.IdentifierOrText()
		}

	case 21:
		localctx = NewSystemVariableContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5855)
			p.Match(DorisParserDOUBLEATSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5858)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 839, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5856)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*SystemVariableContext).kind = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserGLOBAL || _la == DorisParserSESSION) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*SystemVariableContext).kind = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5857)
				p.Match(DorisParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5860)
			p.Identifier()
		}

	case 22:
		localctx = NewColumnReferenceContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(5862)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserBINARY {
			{
				p.SetState(5861)
				p.Match(DorisParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5864)
			p.Identifier()
		}

	case 23:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5865)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5866)
			p.Expression()
		}
		{
			p.SetState(5867)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		localctx = NewEncryptKeyContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5869)
			p.Match(DorisParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5873)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 841, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5870)

				var _x = p.Identifier()

				localctx.(*EncryptKeyContext).dbName = _x
			}
			{
				p.SetState(5871)
				p.Match(DorisParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5875)

			var _x = p.Identifier()

			localctx.(*EncryptKeyContext).keyName = _x
		}

	case 25:
		localctx = NewExtractContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5876)
			p.Match(DorisParserEXTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5877)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5878)

			var _x = p.Identifier()

			localctx.(*ExtractContext).field = _x
		}
		{
			p.SetState(5879)
			p.Match(DorisParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5881)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 842, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5880)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserDATE || _la == DorisParserTIMESTAMP) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5883)

			var _x = p.valueExpression(0)

			localctx.(*ExtractContext).source = _x
		}
		{
			p.SetState(5884)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(5914)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 847, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(5912)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 846, p.GetParserRuleContext()) {
			case 1:
				localctx = NewElementAtContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*ElementAtContext).value = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_primaryExpression)
				p.SetState(5888)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
					goto errorExit
				}
				{
					p.SetState(5889)
					p.Match(DorisParserLEFT_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5890)

					var _x = p.valueExpression(0)

					localctx.(*ElementAtContext).index = _x
				}
				{
					p.SetState(5891)
					p.Match(DorisParserRIGHT_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				localctx = NewArraySliceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArraySliceContext).value = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_primaryExpression)
				p.SetState(5893)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
					goto errorExit
				}
				{
					p.SetState(5894)
					p.Match(DorisParserLEFT_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5895)

					var _x = p.valueExpression(0)

					localctx.(*ArraySliceContext).begin = _x
				}
				{
					p.SetState(5896)
					p.Match(DorisParserCOLON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(5898)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305884869834611068) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4610552282352573437) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4539693587714860571) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&2845980307192511093) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&8563559367481747197) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-304588910535901189) != 0) || ((int64((_la-391)) & ^0x3f) == 0 && ((int64(1)<<(_la-391))&1188948054525295071) != 0) || ((int64((_la-455)) & ^0x3f) == 0 && ((int64(1)<<(_la-455))&2458964612221977455) != 0) || ((int64((_la-524)) & ^0x3f) == 0 && ((int64(1)<<(_la-524))&923779111) != 0) {
					{
						p.SetState(5897)

						var _x = p.valueExpression(0)

						localctx.(*ArraySliceContext).end = _x
					}

				}
				{
					p.SetState(5900)
					p.Match(DorisParserRIGHT_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 3:
				localctx = NewDereferenceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*DereferenceContext).base = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_primaryExpression)
				p.SetState(5902)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(5903)
					p.Match(DorisParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5904)

					var _x = p.Identifier()

					localctx.(*DereferenceContext).fieldName = _x
				}

			case 4:
				localctx = NewCollateContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DorisParserRULE_primaryExpression)
				p.SetState(5905)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(5906)
					p.Match(DorisParserCOLLATE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(5910)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
					{
						p.SetState(5907)
						p.Identifier()
					}

				case DorisParserSTRING_LITERAL:
					{
						p.SetState(5908)
						p.Match(DorisParserSTRING_LITERAL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case DorisParserDEFAULT:
					{
						p.SetState(5909)
						p.Match(DorisParserDEFAULT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(5916)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 847, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExceptOrReplaceContext is an interface to support dynamic dispatch.
type IExceptOrReplaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExceptOrReplaceContext differentiates from other interfaces.
	IsExceptOrReplaceContext()
}

type ExceptOrReplaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExceptOrReplaceContext() *ExceptOrReplaceContext {
	var p = new(ExceptOrReplaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_exceptOrReplace
	return p
}

func InitEmptyExceptOrReplaceContext(p *ExceptOrReplaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_exceptOrReplace
}

func (*ExceptOrReplaceContext) IsExceptOrReplaceContext() {}

func NewExceptOrReplaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptOrReplaceContext {
	var p = new(ExceptOrReplaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_exceptOrReplace

	return p
}

func (s *ExceptOrReplaceContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptOrReplaceContext) CopyAll(ctx *ExceptOrReplaceContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExceptOrReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptOrReplaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ReplaceContext struct {
	ExceptOrReplaceContext
}

func NewReplaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReplaceContext {
	var p = new(ReplaceContext)

	InitEmptyExceptOrReplaceContext(&p.ExceptOrReplaceContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExceptOrReplaceContext))

	return p
}

func (s *ReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplaceContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *ReplaceContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ReplaceContext) NamedExpressionSeq() INamedExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionSeqContext)
}

func (s *ReplaceContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ReplaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterReplace(s)
	}
}

func (s *ReplaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitReplace(s)
	}
}

type ExceptContext struct {
	ExceptOrReplaceContext
}

func NewExceptContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExceptContext {
	var p = new(ExceptContext)

	InitEmptyExceptOrReplaceContext(&p.ExceptOrReplaceContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExceptOrReplaceContext))

	return p
}

func (s *ExceptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(DorisParserEXCEPT, 0)
}

func (s *ExceptContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *ExceptContext) NamedExpressionSeq() INamedExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionSeqContext)
}

func (s *ExceptContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *ExceptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterExcept(s)
	}
}

func (s *ExceptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitExcept(s)
	}
}

func (p *DorisParser) ExceptOrReplace() (localctx IExceptOrReplaceContext) {
	localctx = NewExceptOrReplaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, DorisParserRULE_exceptOrReplace)
	p.SetState(5927)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserEXCEPT:
		localctx = NewExceptContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5917)
			p.Match(DorisParserEXCEPT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5918)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5919)
			p.NamedExpressionSeq()
		}
		{
			p.SetState(5920)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserREPLACE:
		localctx = NewReplaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5922)
			p.Match(DorisParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5923)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5924)
			p.NamedExpressionSeq()
		}
		{
			p.SetState(5925)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastDataTypeContext is an interface to support dynamic dispatch.
type ICastDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DataType() IDataTypeContext
	SIGNED() antlr.TerminalNode
	UNSIGNED() antlr.TerminalNode
	INT() antlr.TerminalNode
	INTEGER() antlr.TerminalNode

	// IsCastDataTypeContext differentiates from other interfaces.
	IsCastDataTypeContext()
}

type CastDataTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastDataTypeContext() *CastDataTypeContext {
	var p = new(CastDataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_castDataType
	return p
}

func InitEmptyCastDataTypeContext(p *CastDataTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_castDataType
}

func (*CastDataTypeContext) IsCastDataTypeContext() {}

func NewCastDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastDataTypeContext {
	var p = new(CastDataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_castDataType

	return p
}

func (s *CastDataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CastDataTypeContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CastDataTypeContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(DorisParserSIGNED, 0)
}

func (s *CastDataTypeContext) UNSIGNED() antlr.TerminalNode {
	return s.GetToken(DorisParserUNSIGNED, 0)
}

func (s *CastDataTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(DorisParserINT, 0)
}

func (s *CastDataTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER, 0)
}

func (s *CastDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastDataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCastDataType(s)
	}
}

func (s *CastDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCastDataType(s)
	}
}

func (p *DorisParser) CastDataType() (localctx ICastDataTypeContext) {
	localctx = NewCastDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, DorisParserRULE_castDataType)
	var _la int

	p.SetState(5934)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserAGG_STATE, DorisParserALL, DorisParserARRAY, DorisParserBIGINT, DorisParserBITMAP, DorisParserBOOLEAN, DorisParserCHAR, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDOUBLE, DorisParserFLOAT, DorisParserHLL, DorisParserINT, DorisParserINTEGER, DorisParserIPV4, DorisParserIPV6, DorisParserJSON, DorisParserJSONB, DorisParserLARGEINT, DorisParserMAP, DorisParserQUANTILE_STATE, DorisParserSMALLINT, DorisParserSTRING, DorisParserSTRUCT, DorisParserTEXT, DorisParserTIME, DorisParserTINYINT, DorisParserVARCHAR, DorisParserVARIANT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5929)
			p.DataType()
		}

	case DorisParserSIGNED, DorisParserUNSIGNED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5930)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserSIGNED || _la == DorisParserUNSIGNED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(5932)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserINT || _la == DorisParserINTEGER {
			{
				p.SetState(5931)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserINT || _la == DorisParserINTEGER) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallExpressionContext is an interface to support dynamic dispatch.
type IFunctionCallExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetArguments returns the arguments rule context list.
	GetArguments() []IExpressionContext

	// SetArguments sets the arguments rule context list.
	SetArguments([]IExpressionContext)

	// Getter signatures
	FunctionIdentifier() IFunctionIdentifierContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	OVER() antlr.TerminalNode
	WindowSpec() IWindowSpecContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	DISTINCT() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsFunctionCallExpressionContext differentiates from other interfaces.
	IsFunctionCallExpressionContext()
}

type FunctionCallExpressionContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	_expression IExpressionContext
	arguments   []IExpressionContext
}

func NewEmptyFunctionCallExpressionContext() *FunctionCallExpressionContext {
	var p = new(FunctionCallExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionCallExpression
	return p
}

func InitEmptyFunctionCallExpressionContext(p *FunctionCallExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionCallExpression
}

func (*FunctionCallExpressionContext) IsFunctionCallExpressionContext() {}

func NewFunctionCallExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallExpressionContext {
	var p = new(FunctionCallExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_functionCallExpression

	return p
}

func (s *FunctionCallExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallExpressionContext) Get_expression() IExpressionContext { return s._expression }

func (s *FunctionCallExpressionContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *FunctionCallExpressionContext) GetArguments() []IExpressionContext { return s.arguments }

func (s *FunctionCallExpressionContext) SetArguments(v []IExpressionContext) { s.arguments = v }

func (s *FunctionCallExpressionContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *FunctionCallExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *FunctionCallExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *FunctionCallExpressionContext) OVER() antlr.TerminalNode {
	return s.GetToken(DorisParserOVER, 0)
}

func (s *FunctionCallExpressionContext) WindowSpec() IWindowSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecContext)
}

func (s *FunctionCallExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *FunctionCallExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionCallExpressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *FunctionCallExpressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *FunctionCallExpressionContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisParserORDER, 0)
}

func (s *FunctionCallExpressionContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserBY, 0)
}

func (s *FunctionCallExpressionContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *FunctionCallExpressionContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *FunctionCallExpressionContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTINCT, 0)
}

func (s *FunctionCallExpressionContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *FunctionCallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFunctionCallExpression(s)
	}
}

func (s *FunctionCallExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFunctionCallExpression(s)
	}
}

func (p *DorisParser) FunctionCallExpression() (localctx IFunctionCallExpressionContext) {
	localctx = NewFunctionCallExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, DorisParserRULE_functionCallExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5936)
		p.FunctionIdentifier()
	}
	{
		p.SetState(5937)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5961)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305884869833562492) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4610552282352573437) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4539691388691603995) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&2845980307192511093) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&8572566566736488189) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-304588910535901189) != 0) || ((int64((_la-391)) & ^0x3f) == 0 && ((int64(1)<<(_la-391))&1188948054525295071) != 0) || ((int64((_la-455)) & ^0x3f) == 0 && ((int64(1)<<(_la-455))&2458964612221977455) != 0) || ((int64((_la-524)) & ^0x3f) == 0 && ((int64(1)<<(_la-524))&923779367) != 0) {
		p.SetState(5939)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserALL || _la == DorisParserDISTINCT {
			{
				p.SetState(5938)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserALL || _la == DorisParserDISTINCT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(5941)

			var _x = p.Expression()

			localctx.(*FunctionCallExpressionContext)._expression = _x
		}
		localctx.(*FunctionCallExpressionContext).arguments = append(localctx.(*FunctionCallExpressionContext).arguments, localctx.(*FunctionCallExpressionContext)._expression)
		p.SetState(5946)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(5942)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5943)

				var _x = p.Expression()

				localctx.(*FunctionCallExpressionContext)._expression = _x
			}
			localctx.(*FunctionCallExpressionContext).arguments = append(localctx.(*FunctionCallExpressionContext).arguments, localctx.(*FunctionCallExpressionContext)._expression)

			p.SetState(5948)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5959)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserORDER {
			{
				p.SetState(5949)
				p.Match(DorisParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5950)
				p.Match(DorisParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5951)
				p.SortItem()
			}
			p.SetState(5956)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(5952)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5953)
					p.SortItem()
				}

				p.SetState(5958)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}

	}
	{
		p.SetState(5963)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5966)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 856, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5964)
			p.Match(DorisParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5965)
			p.WindowSpec()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionIdentifierContext is an interface to support dynamic dispatch.
type IFunctionIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDbName returns the dbName rule contexts.
	GetDbName() IIdentifierContext

	// SetDbName sets the dbName rule contexts.
	SetDbName(IIdentifierContext)

	// Getter signatures
	FunctionNameIdentifier() IFunctionNameIdentifierContext
	DOT() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsFunctionIdentifierContext differentiates from other interfaces.
	IsFunctionIdentifierContext()
}

type FunctionIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	dbName IIdentifierContext
}

func NewEmptyFunctionIdentifierContext() *FunctionIdentifierContext {
	var p = new(FunctionIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionIdentifier
	return p
}

func InitEmptyFunctionIdentifierContext(p *FunctionIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionIdentifier
}

func (*FunctionIdentifierContext) IsFunctionIdentifierContext() {}

func NewFunctionIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionIdentifierContext {
	var p = new(FunctionIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_functionIdentifier

	return p
}

func (s *FunctionIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionIdentifierContext) GetDbName() IIdentifierContext { return s.dbName }

func (s *FunctionIdentifierContext) SetDbName(v IIdentifierContext) { s.dbName = v }

func (s *FunctionIdentifierContext) FunctionNameIdentifier() IFunctionNameIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameIdentifierContext)
}

func (s *FunctionIdentifierContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, 0)
}

func (s *FunctionIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFunctionIdentifier(s)
	}
}

func (s *FunctionIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFunctionIdentifier(s)
	}
}

func (p *DorisParser) FunctionIdentifier() (localctx IFunctionIdentifierContext) {
	localctx = NewFunctionIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, DorisParserRULE_functionIdentifier)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(5971)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 857, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5968)

			var _x = p.Identifier()

			localctx.(*FunctionIdentifierContext).dbName = _x
		}
		{
			p.SetState(5969)
			p.Match(DorisParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(5973)
		p.FunctionNameIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionNameIdentifierContext is an interface to support dynamic dispatch.
type IFunctionNameIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ADD() antlr.TerminalNode
	CONNECTION_ID() antlr.TerminalNode
	CURRENT_CATALOG() antlr.TerminalNode
	CURRENT_USER() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	IF() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	REGEXP() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	SESSION_USER() antlr.TerminalNode
	TRIM() antlr.TerminalNode
	USER() antlr.TerminalNode

	// IsFunctionNameIdentifierContext differentiates from other interfaces.
	IsFunctionNameIdentifierContext()
}

type FunctionNameIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameIdentifierContext() *FunctionNameIdentifierContext {
	var p = new(FunctionNameIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionNameIdentifier
	return p
}

func InitEmptyFunctionNameIdentifierContext(p *FunctionNameIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_functionNameIdentifier
}

func (*FunctionNameIdentifierContext) IsFunctionNameIdentifierContext() {}

func NewFunctionNameIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameIdentifierContext {
	var p = new(FunctionNameIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_functionNameIdentifier

	return p
}

func (s *FunctionNameIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionNameIdentifierContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserADD, 0)
}

func (s *FunctionNameIdentifierContext) CONNECTION_ID() antlr.TerminalNode {
	return s.GetToken(DorisParserCONNECTION_ID, 0)
}

func (s *FunctionNameIdentifierContext) CURRENT_CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_CATALOG, 0)
}

func (s *FunctionNameIdentifierContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_USER, 0)
}

func (s *FunctionNameIdentifierContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATABASE, 0)
}

func (s *FunctionNameIdentifierContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserIF, 0)
}

func (s *FunctionNameIdentifierContext) LEFT() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT, 0)
}

func (s *FunctionNameIdentifierContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserLIKE, 0)
}

func (s *FunctionNameIdentifierContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD, 0)
}

func (s *FunctionNameIdentifierContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(DorisParserREGEXP, 0)
}

func (s *FunctionNameIdentifierContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT, 0)
}

func (s *FunctionNameIdentifierContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEMA, 0)
}

func (s *FunctionNameIdentifierContext) SESSION_USER() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION_USER, 0)
}

func (s *FunctionNameIdentifierContext) TRIM() antlr.TerminalNode {
	return s.GetToken(DorisParserTRIM, 0)
}

func (s *FunctionNameIdentifierContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisParserUSER, 0)
}

func (s *FunctionNameIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFunctionNameIdentifier(s)
	}
}

func (s *FunctionNameIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFunctionNameIdentifier(s)
	}
}

func (p *DorisParser) FunctionNameIdentifier() (localctx IFunctionNameIdentifierContext) {
	localctx = NewFunctionNameIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, DorisParserRULE_functionNameIdentifier)
	p.SetState(5991)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 858, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5975)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5976)
			p.Match(DorisParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5977)
			p.Match(DorisParserCONNECTION_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5978)
			p.Match(DorisParserCURRENT_CATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5979)
			p.Match(DorisParserCURRENT_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5980)
			p.Match(DorisParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5981)
			p.Match(DorisParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5982)
			p.Match(DorisParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5983)
			p.Match(DorisParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5984)
			p.Match(DorisParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5985)
			p.Match(DorisParserREGEXP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5986)
			p.Match(DorisParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5987)
			p.Match(DorisParserSCHEMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5988)
			p.Match(DorisParserSESSION_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(5989)
			p.Match(DorisParserTRIM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(5990)
			p.Match(DorisParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowSpecContext is an interface to support dynamic dispatch.
type IWindowSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	PartitionClause() IPartitionClauseContext
	SortClause() ISortClauseContext
	WindowFrame() IWindowFrameContext

	// IsWindowSpecContext differentiates from other interfaces.
	IsWindowSpecContext()
}

type WindowSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowSpecContext() *WindowSpecContext {
	var p = new(WindowSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_windowSpec
	return p
}

func InitEmptyWindowSpecContext(p *WindowSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_windowSpec
}

func (*WindowSpecContext) IsWindowSpecContext() {}

func NewWindowSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowSpecContext {
	var p = new(WindowSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_windowSpec

	return p
}

func (s *WindowSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowSpecContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *WindowSpecContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *WindowSpecContext) PartitionClause() IPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *WindowSpecContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *WindowSpecContext) WindowFrame() IWindowFrameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameContext)
}

func (s *WindowSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWindowSpec(s)
	}
}

func (s *WindowSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWindowSpec(s)
	}
}

func (p *DorisParser) WindowSpec() (localctx IWindowSpecContext) {
	localctx = NewWindowSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, DorisParserRULE_windowSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5993)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5995)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserPARTITION {
		{
			p.SetState(5994)
			p.PartitionClause()
		}

	}
	p.SetState(5998)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserORDER {
		{
			p.SetState(5997)
			p.SortClause()
		}

	}
	p.SetState(6001)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserRANGE || _la == DorisParserROWS {
		{
			p.SetState(6000)
			p.WindowFrame()
		}

	}
	{
		p.SetState(6003)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameContext is an interface to support dynamic dispatch.
type IWindowFrameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStart_ returns the start_ rule contexts.
	GetStart_() IFrameBoundaryContext

	// GetEnd returns the end rule contexts.
	GetEnd() IFrameBoundaryContext

	// SetStart_ sets the start_ rule contexts.
	SetStart_(IFrameBoundaryContext)

	// SetEnd sets the end rule contexts.
	SetEnd(IFrameBoundaryContext)

	// Getter signatures
	FrameUnits() IFrameUnitsContext
	AllFrameBoundary() []IFrameBoundaryContext
	FrameBoundary(i int) IFrameBoundaryContext
	BETWEEN() antlr.TerminalNode
	AND() antlr.TerminalNode

	// IsWindowFrameContext differentiates from other interfaces.
	IsWindowFrameContext()
}

type WindowFrameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	start_ IFrameBoundaryContext
	end    IFrameBoundaryContext
}

func NewEmptyWindowFrameContext() *WindowFrameContext {
	var p = new(WindowFrameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_windowFrame
	return p
}

func InitEmptyWindowFrameContext(p *WindowFrameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_windowFrame
}

func (*WindowFrameContext) IsWindowFrameContext() {}

func NewWindowFrameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameContext {
	var p = new(WindowFrameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_windowFrame

	return p
}

func (s *WindowFrameContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameContext) GetStart_() IFrameBoundaryContext { return s.start_ }

func (s *WindowFrameContext) GetEnd() IFrameBoundaryContext { return s.end }

func (s *WindowFrameContext) SetStart_(v IFrameBoundaryContext) { s.start_ = v }

func (s *WindowFrameContext) SetEnd(v IFrameBoundaryContext) { s.end = v }

func (s *WindowFrameContext) FrameUnits() IFrameUnitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameUnitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameUnitsContext)
}

func (s *WindowFrameContext) AllFrameBoundary() []IFrameBoundaryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrameBoundaryContext); ok {
			len++
		}
	}

	tst := make([]IFrameBoundaryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrameBoundaryContext); ok {
			tst[i] = t.(IFrameBoundaryContext)
			i++
		}
	}

	return tst
}

func (s *WindowFrameContext) FrameBoundary(i int) IFrameBoundaryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameBoundaryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameBoundaryContext)
}

func (s *WindowFrameContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(DorisParserBETWEEN, 0)
}

func (s *WindowFrameContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisParserAND, 0)
}

func (s *WindowFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWindowFrame(s)
	}
}

func (s *WindowFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWindowFrame(s)
	}
}

func (p *DorisParser) WindowFrame() (localctx IWindowFrameContext) {
	localctx = NewWindowFrameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, DorisParserRULE_windowFrame)
	p.SetState(6014)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 862, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6005)
			p.FrameUnits()
		}
		{
			p.SetState(6006)

			var _x = p.FrameBoundary()

			localctx.(*WindowFrameContext).start_ = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6008)
			p.FrameUnits()
		}
		{
			p.SetState(6009)
			p.Match(DorisParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6010)

			var _x = p.FrameBoundary()

			localctx.(*WindowFrameContext).start_ = _x
		}
		{
			p.SetState(6011)
			p.Match(DorisParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6012)

			var _x = p.FrameBoundary()

			localctx.(*WindowFrameContext).end = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameUnitsContext is an interface to support dynamic dispatch.
type IFrameUnitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROWS() antlr.TerminalNode
	RANGE() antlr.TerminalNode

	// IsFrameUnitsContext differentiates from other interfaces.
	IsFrameUnitsContext()
}

type FrameUnitsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameUnitsContext() *FrameUnitsContext {
	var p = new(FrameUnitsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_frameUnits
	return p
}

func InitEmptyFrameUnitsContext(p *FrameUnitsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_frameUnits
}

func (*FrameUnitsContext) IsFrameUnitsContext() {}

func NewFrameUnitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameUnitsContext {
	var p = new(FrameUnitsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_frameUnits

	return p
}

func (s *FrameUnitsContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameUnitsContext) ROWS() antlr.TerminalNode {
	return s.GetToken(DorisParserROWS, 0)
}

func (s *FrameUnitsContext) RANGE() antlr.TerminalNode {
	return s.GetToken(DorisParserRANGE, 0)
}

func (s *FrameUnitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameUnitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameUnitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFrameUnits(s)
	}
}

func (s *FrameUnitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFrameUnits(s)
	}
}

func (p *DorisParser) FrameUnits() (localctx IFrameUnitsContext) {
	localctx = NewFrameUnitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, DorisParserRULE_frameUnits)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6016)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserRANGE || _la == DorisParserROWS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameBoundaryContext is an interface to support dynamic dispatch.
type IFrameBoundaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBoundType returns the boundType token.
	GetBoundType() antlr.Token

	// SetBoundType sets the boundType token.
	SetBoundType(antlr.Token)

	// Getter signatures
	UNBOUNDED() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	ROW() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	Expression() IExpressionContext

	// IsFrameBoundaryContext differentiates from other interfaces.
	IsFrameBoundaryContext()
}

type FrameBoundaryContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	boundType antlr.Token
}

func NewEmptyFrameBoundaryContext() *FrameBoundaryContext {
	var p = new(FrameBoundaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_frameBoundary
	return p
}

func InitEmptyFrameBoundaryContext(p *FrameBoundaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_frameBoundary
}

func (*FrameBoundaryContext) IsFrameBoundaryContext() {}

func NewFrameBoundaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameBoundaryContext {
	var p = new(FrameBoundaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_frameBoundary

	return p
}

func (s *FrameBoundaryContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameBoundaryContext) GetBoundType() antlr.Token { return s.boundType }

func (s *FrameBoundaryContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *FrameBoundaryContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(DorisParserUNBOUNDED, 0)
}

func (s *FrameBoundaryContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(DorisParserPRECEDING, 0)
}

func (s *FrameBoundaryContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(DorisParserFOLLOWING, 0)
}

func (s *FrameBoundaryContext) ROW() antlr.TerminalNode {
	return s.GetToken(DorisParserROW, 0)
}

func (s *FrameBoundaryContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT, 0)
}

func (s *FrameBoundaryContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FrameBoundaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameBoundaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameBoundaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterFrameBoundary(s)
	}
}

func (s *FrameBoundaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitFrameBoundary(s)
	}
}

func (p *DorisParser) FrameBoundary() (localctx IFrameBoundaryContext) {
	localctx = NewFrameBoundaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, DorisParserRULE_frameBoundary)
	var _la int

	p.SetState(6025)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserUNBOUNDED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6018)
			p.Match(DorisParserUNBOUNDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6019)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FrameBoundaryContext).boundType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserFOLLOWING || _la == DorisParserPRECEDING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FrameBoundaryContext).boundType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case DorisParserCURRENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6020)

			var _m = p.Match(DorisParserCURRENT)

			localctx.(*FrameBoundaryContext).boundType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6021)
			p.Match(DorisParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserLEFT_PAREN, DorisParserLEFT_BRACKET, DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserADD, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBINARY, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCASE, DorisParserCAST, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATABASE, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXISTS, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserEXTRACT, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFALSE, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIF, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINTERVAL, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserKEY, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLEFT, DorisParserLESS, DorisParserLEVEL, DorisParserLIKE, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNOT, DorisParserNULL, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLACEHOLDER, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREGEXP, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRIGHT, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRIM, DorisParserTRUE, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserPLUS, DorisParserSUBTRACT, DorisParserASTERISK, DorisParserTILDE, DorisParserLOGICALNOT, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserATSIGN, DorisParserDOUBLEATSIGN, DorisParserSTRING_LITERAL, DorisParserINTEGER_VALUE, DorisParserEXPONENT_VALUE, DorisParserDECIMAL_VALUE, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6022)
			p.Expression()
		}
		{
			p.SetState(6023)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FrameBoundaryContext).boundType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserFOLLOWING || _la == DorisParserPRECEDING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FrameBoundaryContext).boundType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_qualifiedName
	return p
}

func InitEmptyQualifiedNameContext(p *QualifiedNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_qualifiedName
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(DorisParserDOT)
}

func (s *QualifiedNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserDOT, i)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterQualifiedName(s)
	}
}

func (s *QualifiedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitQualifiedName(s)
	}
}

func (p *DorisParser) QualifiedName() (localctx IQualifiedNameContext) {
	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, DorisParserRULE_qualifiedName)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6027)
		p.Identifier()
	}
	p.SetState(6032)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 864, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6028)
				p.Match(DorisParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6029)
				p.Identifier()
			}

		}
		p.SetState(6034)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 864, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpecifiedPartitionContext is an interface to support dynamic dispatch.
type ISpecifiedPartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	IdentifierList() IIdentifierListContext
	TEMPORARY() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode

	// IsSpecifiedPartitionContext differentiates from other interfaces.
	IsSpecifiedPartitionContext()
}

type SpecifiedPartitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecifiedPartitionContext() *SpecifiedPartitionContext {
	var p = new(SpecifiedPartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_specifiedPartition
	return p
}

func InitEmptySpecifiedPartitionContext(p *SpecifiedPartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_specifiedPartition
}

func (*SpecifiedPartitionContext) IsSpecifiedPartitionContext() {}

func NewSpecifiedPartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecifiedPartitionContext {
	var p = new(SpecifiedPartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_specifiedPartition

	return p
}

func (s *SpecifiedPartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecifiedPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITION, 0)
}

func (s *SpecifiedPartitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SpecifiedPartitionContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *SpecifiedPartitionContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *SpecifiedPartitionContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITIONS, 0)
}

func (s *SpecifiedPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecifiedPartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecifiedPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSpecifiedPartition(s)
	}
}

func (s *SpecifiedPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSpecifiedPartition(s)
	}
}

func (p *DorisParser) SpecifiedPartition() (localctx ISpecifiedPartitionContext) {
	localctx = NewSpecifiedPartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, DorisParserRULE_specifiedPartition)
	var _la int

	p.SetState(6048)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 868, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6036)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(6035)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6038)
			p.Match(DorisParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6041)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START, DorisParserIDENTIFIER, DorisParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(6039)
				p.Identifier()
			}

		case DorisParserLEFT_PAREN:
			{
				p.SetState(6040)
				p.IdentifierList()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(6044)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserTEMPORARY {
			{
				p.SetState(6043)
				p.Match(DorisParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6046)
			p.Match(DorisParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6047)
			p.IdentifierList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_constant
	return p
}

func InitEmptyConstantContext(p *ConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_constant
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) CopyAll(ctx *ConstantContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StructLiteralContext struct {
	ConstantContext
	_constant IConstantContext
	items     []IConstantContext
}

func NewStructLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StructLiteralContext {
	var p = new(StructLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *StructLiteralContext) Get_constant() IConstantContext { return s._constant }

func (s *StructLiteralContext) Set_constant(v IConstantContext) { s._constant = v }

func (s *StructLiteralContext) GetItems() []IConstantContext { return s.items }

func (s *StructLiteralContext) SetItems(v []IConstantContext) { s.items = v }

func (s *StructLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructLiteralContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACE, 0)
}

func (s *StructLiteralContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACE, 0)
}

func (s *StructLiteralContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *StructLiteralContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *StructLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *StructLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *StructLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStructLiteral(s)
	}
}

func (s *StructLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStructLiteral(s)
	}
}

type NullLiteralContext struct {
	ConstantContext
}

func NewNullLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralContext {
	var p = new(NullLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisParserNULL, 0)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

type StringLiteralContext struct {
	ConstantContext
}

func NewStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralContext {
	var p = new(StringLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *StringLiteralContext) BINARY() antlr.TerminalNode {
	return s.GetToken(DorisParserBINARY, 0)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

type TypeConstructorContext struct {
	ConstantContext
	type_ antlr.Token
}

func NewTypeConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeConstructorContext {
	var p = new(TypeConstructorContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *TypeConstructorContext) GetType_() antlr.Token { return s.type_ }

func (s *TypeConstructorContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *TypeConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConstructorContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *TypeConstructorContext) DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATE, 0)
}

func (s *TypeConstructorContext) DATEV1() antlr.TerminalNode {
	return s.GetToken(DorisParserDATEV1, 0)
}

func (s *TypeConstructorContext) DATEV2() antlr.TerminalNode {
	return s.GetToken(DorisParserDATEV2, 0)
}

func (s *TypeConstructorContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserTIMESTAMP, 0)
}

func (s *TypeConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTypeConstructor(s)
	}
}

func (s *TypeConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTypeConstructor(s)
	}
}

type ArrayLiteralContext struct {
	ConstantContext
	_constant IConstantContext
	items     []IConstantContext
}

func NewArrayLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *ArrayLiteralContext) Get_constant() IConstantContext { return s._constant }

func (s *ArrayLiteralContext) Set_constant(v IConstantContext) { s._constant = v }

func (s *ArrayLiteralContext) GetItems() []IConstantContext { return s.items }

func (s *ArrayLiteralContext) SetItems(v []IConstantContext) { s.items = v }

func (s *ArrayLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACKET, 0)
}

func (s *ArrayLiteralContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACKET, 0)
}

func (s *ArrayLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ArrayLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ArrayLiteralContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *ArrayLiteralContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ArrayLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitArrayLiteral(s)
	}
}

type PlaceholderContext struct {
	ConstantContext
}

func NewPlaceholderContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PlaceholderContext {
	var p = new(PlaceholderContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *PlaceholderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PlaceholderContext) PLACEHOLDER() antlr.TerminalNode {
	return s.GetToken(DorisParserPLACEHOLDER, 0)
}

func (s *PlaceholderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPlaceholder(s)
	}
}

func (s *PlaceholderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPlaceholder(s)
	}
}

type MapLiteralContext struct {
	ConstantContext
	_constant IConstantContext
	items     []IConstantContext
}

func NewMapLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MapLiteralContext {
	var p = new(MapLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *MapLiteralContext) Get_constant() IConstantContext { return s._constant }

func (s *MapLiteralContext) Set_constant(v IConstantContext) { s._constant = v }

func (s *MapLiteralContext) GetItems() []IConstantContext { return s.items }

func (s *MapLiteralContext) SetItems(v []IConstantContext) { s.items = v }

func (s *MapLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapLiteralContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACE, 0)
}

func (s *MapLiteralContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACE, 0)
}

func (s *MapLiteralContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOLON)
}

func (s *MapLiteralContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOLON, i)
}

func (s *MapLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *MapLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *MapLiteralContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *MapLiteralContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *MapLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterMapLiteral(s)
	}
}

func (s *MapLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitMapLiteral(s)
	}
}

type NumericLiteralContext struct {
	ConstantContext
}

func NewNumericLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

type BooleanLiteralContext struct {
	ConstantContext
}

func NewBooleanLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) BooleanValue() IBooleanValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (p *DorisParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, DorisParserRULE_constant)
	var _la int

	p.SetState(6101)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 875, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNullLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6050)
			p.Match(DorisParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewTypeConstructorContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6051)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TypeConstructorContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-115)) & ^0x3f) == 0 && ((int64(1)<<(_la-115))&41) != 0) || _la == DorisParserTIMESTAMP) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TypeConstructorContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6052)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewNumericLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6053)
			p.Number()
		}

	case 4:
		localctx = NewBooleanLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6054)
			p.BooleanValue()
		}

	case 5:
		localctx = NewStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(6056)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserBINARY {
			{
				p.SetState(6055)
				p.Match(DorisParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6058)
			p.Match(DorisParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewArrayLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6059)
			p.Match(DorisParserLEFT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6061)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17592186045056) != 0) || ((int64((_la-115)) & ^0x3f) == 0 && ((int64(1)<<(_la-115))&4611686018427387945) != 0) || _la == DorisParserNULL || _la == DorisParserPLACEHOLDER || ((int64((_la-464)) & ^0x3f) == 0 && ((int64(1)<<(_la-464))&2305843009213694977) != 0) || ((int64((_la-543)) & ^0x3f) == 0 && ((int64(1)<<(_la-543))&225) != 0) {
			{
				p.SetState(6060)

				var _x = p.Constant()

				localctx.(*ArrayLiteralContext)._constant = _x
			}
			localctx.(*ArrayLiteralContext).items = append(localctx.(*ArrayLiteralContext).items, localctx.(*ArrayLiteralContext)._constant)

		}
		p.SetState(6067)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(6063)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6064)

				var _x = p.Constant()

				localctx.(*ArrayLiteralContext)._constant = _x
			}
			localctx.(*ArrayLiteralContext).items = append(localctx.(*ArrayLiteralContext).items, localctx.(*ArrayLiteralContext)._constant)

			p.SetState(6069)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6070)
			p.Match(DorisParserRIGHT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewMapLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6071)
			p.Match(DorisParserLEFT_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6076)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17592186045056) != 0) || ((int64((_la-115)) & ^0x3f) == 0 && ((int64(1)<<(_la-115))&4611686018427387945) != 0) || _la == DorisParserNULL || _la == DorisParserPLACEHOLDER || ((int64((_la-464)) & ^0x3f) == 0 && ((int64(1)<<(_la-464))&2305843009213694977) != 0) || ((int64((_la-543)) & ^0x3f) == 0 && ((int64(1)<<(_la-543))&225) != 0) {
			{
				p.SetState(6072)

				var _x = p.Constant()

				localctx.(*MapLiteralContext)._constant = _x
			}
			localctx.(*MapLiteralContext).items = append(localctx.(*MapLiteralContext).items, localctx.(*MapLiteralContext)._constant)
			{
				p.SetState(6073)
				p.Match(DorisParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6074)

				var _x = p.Constant()

				localctx.(*MapLiteralContext)._constant = _x
			}
			localctx.(*MapLiteralContext).items = append(localctx.(*MapLiteralContext).items, localctx.(*MapLiteralContext)._constant)

		}
		p.SetState(6085)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(6078)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6079)

				var _x = p.Constant()

				localctx.(*MapLiteralContext)._constant = _x
			}
			localctx.(*MapLiteralContext).items = append(localctx.(*MapLiteralContext).items, localctx.(*MapLiteralContext)._constant)
			{
				p.SetState(6080)
				p.Match(DorisParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6081)

				var _x = p.Constant()

				localctx.(*MapLiteralContext)._constant = _x
			}
			localctx.(*MapLiteralContext).items = append(localctx.(*MapLiteralContext).items, localctx.(*MapLiteralContext)._constant)

			p.SetState(6087)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6088)
			p.Match(DorisParserRIGHT_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewStructLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6089)
			p.Match(DorisParserLEFT_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6090)

			var _x = p.Constant()

			localctx.(*StructLiteralContext)._constant = _x
		}
		localctx.(*StructLiteralContext).items = append(localctx.(*StructLiteralContext).items, localctx.(*StructLiteralContext)._constant)
		p.SetState(6095)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(6091)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6092)

				var _x = p.Constant()

				localctx.(*StructLiteralContext)._constant = _x
			}
			localctx.(*StructLiteralContext).items = append(localctx.(*StructLiteralContext).items, localctx.(*StructLiteralContext)._constant)

			p.SetState(6097)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6098)
			p.Match(DorisParserRIGHT_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewPlaceholderContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6100)
			p.Match(DorisParserPLACEHOLDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQ() antlr.TerminalNode
	NEQ() antlr.TerminalNode
	LT() antlr.TerminalNode
	LTE() antlr.TerminalNode
	GT() antlr.TerminalNode
	GTE() antlr.TerminalNode
	NSEQ() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_comparisonOperator
	return p
}

func InitEmptyComparisonOperatorContext(p *ComparisonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_comparisonOperator
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserEQ, 0)
}

func (s *ComparisonOperatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(DorisParserNEQ, 0)
}

func (s *ComparisonOperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(DorisParserLT, 0)
}

func (s *ComparisonOperatorContext) LTE() antlr.TerminalNode {
	return s.GetToken(DorisParserLTE, 0)
}

func (s *ComparisonOperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(DorisParserGT, 0)
}

func (s *ComparisonOperatorContext) GTE() antlr.TerminalNode {
	return s.GetToken(DorisParserGTE, 0)
}

func (s *ComparisonOperatorContext) NSEQ() antlr.TerminalNode {
	return s.GetToken(DorisParserNSEQ, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (p *DorisParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, DorisParserRULE_comparisonOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6103)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&127) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanValueContext is an interface to support dynamic dispatch.
type IBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBooleanValueContext differentiates from other interfaces.
	IsBooleanValueContext()
}

type BooleanValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueContext() *BooleanValueContext {
	var p = new(BooleanValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_booleanValue
	return p
}

func InitEmptyBooleanValueContext(p *BooleanValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_booleanValue
}

func (*BooleanValueContext) IsBooleanValueContext() {}

func NewBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueContext {
	var p = new(BooleanValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_booleanValue

	return p
}

func (s *BooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(DorisParserTRUE, 0)
}

func (s *BooleanValueContext) FALSE() antlr.TerminalNode {
	return s.GetToken(DorisParserFALSE, 0)
}

func (s *BooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterBooleanValue(s)
	}
}

func (s *BooleanValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitBooleanValue(s)
	}
}

func (p *DorisParser) BooleanValue() (localctx IBooleanValueContext) {
	localctx = NewBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, DorisParserRULE_booleanValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6105)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserFALSE || _la == DorisParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetResult returns the result rule contexts.
	GetResult() IExpressionContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetResult sets the result rule contexts.
	SetResult(IExpressionContext)

	// Getter signatures
	WHEN() antlr.TerminalNode
	THEN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExpressionContext
	result    IExpressionContext
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_whenClause
	return p
}

func InitEmptyWhenClauseContext(p *WhenClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_whenClause
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) GetCondition() IExpressionContext { return s.condition }

func (s *WhenClauseContext) GetResult() IExpressionContext { return s.result }

func (s *WhenClauseContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *WhenClauseContext) SetResult(v IExpressionContext) { s.result = v }

func (s *WhenClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(DorisParserWHEN, 0)
}

func (s *WhenClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(DorisParserTHEN, 0)
}

func (s *WhenClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WhenClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterWhenClause(s)
	}
}

func (s *WhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitWhenClause(s)
	}
}

func (p *DorisParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, DorisParserRULE_whenClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6107)
		p.Match(DorisParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6108)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).condition = _x
	}
	{
		p.SetState(6109)
		p.Match(DorisParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6110)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).result = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalContext is an interface to support dynamic dispatch.
type IIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value rule contexts.
	GetValue() IExpressionContext

	// GetUnit returns the unit rule contexts.
	GetUnit() IUnitIdentifierContext

	// SetValue sets the value rule contexts.
	SetValue(IExpressionContext)

	// SetUnit sets the unit rule contexts.
	SetUnit(IUnitIdentifierContext)

	// Getter signatures
	INTERVAL() antlr.TerminalNode
	Expression() IExpressionContext
	UnitIdentifier() IUnitIdentifierContext

	// IsIntervalContext differentiates from other interfaces.
	IsIntervalContext()
}

type IntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  IExpressionContext
	unit   IUnitIdentifierContext
}

func NewEmptyIntervalContext() *IntervalContext {
	var p = new(IntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_interval
	return p
}

func InitEmptyIntervalContext(p *IntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_interval
}

func (*IntervalContext) IsIntervalContext() {}

func NewIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalContext {
	var p = new(IntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_interval

	return p
}

func (s *IntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalContext) GetValue() IExpressionContext { return s.value }

func (s *IntervalContext) GetUnit() IUnitIdentifierContext { return s.unit }

func (s *IntervalContext) SetValue(v IExpressionContext) { s.value = v }

func (s *IntervalContext) SetUnit(v IUnitIdentifierContext) { s.unit = v }

func (s *IntervalContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DorisParserINTERVAL, 0)
}

func (s *IntervalContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalContext) UnitIdentifier() IUnitIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitIdentifierContext)
}

func (s *IntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterInterval(s)
	}
}

func (s *IntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitInterval(s)
	}
}

func (p *DorisParser) Interval() (localctx IIntervalContext) {
	localctx = NewIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, DorisParserRULE_interval)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6112)
		p.Match(DorisParserINTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6113)

		var _x = p.Expression()

		localctx.(*IntervalContext).value = _x
	}
	{
		p.SetState(6114)

		var _x = p.UnitIdentifier()

		localctx.(*IntervalContext).unit = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitIdentifierContext is an interface to support dynamic dispatch.
type IUnitIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YEAR() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	SECOND() antlr.TerminalNode

	// IsUnitIdentifierContext differentiates from other interfaces.
	IsUnitIdentifierContext()
}

type UnitIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitIdentifierContext() *UnitIdentifierContext {
	var p = new(UnitIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unitIdentifier
	return p
}

func InitEmptyUnitIdentifierContext(p *UnitIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_unitIdentifier
}

func (*UnitIdentifierContext) IsUnitIdentifierContext() {}

func NewUnitIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitIdentifierContext {
	var p = new(UnitIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_unitIdentifier

	return p
}

func (s *UnitIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitIdentifierContext) YEAR() antlr.TerminalNode {
	return s.GetToken(DorisParserYEAR, 0)
}

func (s *UnitIdentifierContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(DorisParserQUARTER, 0)
}

func (s *UnitIdentifierContext) MONTH() antlr.TerminalNode {
	return s.GetToken(DorisParserMONTH, 0)
}

func (s *UnitIdentifierContext) WEEK() antlr.TerminalNode {
	return s.GetToken(DorisParserWEEK, 0)
}

func (s *UnitIdentifierContext) DAY() antlr.TerminalNode {
	return s.GetToken(DorisParserDAY, 0)
}

func (s *UnitIdentifierContext) HOUR() antlr.TerminalNode {
	return s.GetToken(DorisParserHOUR, 0)
}

func (s *UnitIdentifierContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(DorisParserMINUTE, 0)
}

func (s *UnitIdentifierContext) SECOND() antlr.TerminalNode {
	return s.GetToken(DorisParserSECOND, 0)
}

func (s *UnitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUnitIdentifier(s)
	}
}

func (s *UnitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUnitIdentifier(s)
	}
}

func (p *DorisParser) UnitIdentifier() (localctx IUnitIdentifierContext) {
	localctx = NewUnitIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, DorisParserRULE_unitIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6116)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserDAY || _la == DorisParserHOUR || _la == DorisParserMINUTE || _la == DorisParserMONTH || _la == DorisParserQUARTER || _la == DorisParserSECOND || _la == DorisParserWEEK || _la == DorisParserYEAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeWithNullableContext is an interface to support dynamic dispatch.
type IDataTypeWithNullableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DataType() IDataTypeContext
	NULL() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsDataTypeWithNullableContext differentiates from other interfaces.
	IsDataTypeWithNullableContext()
}

type DataTypeWithNullableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeWithNullableContext() *DataTypeWithNullableContext {
	var p = new(DataTypeWithNullableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dataTypeWithNullable
	return p
}

func InitEmptyDataTypeWithNullableContext(p *DataTypeWithNullableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dataTypeWithNullable
}

func (*DataTypeWithNullableContext) IsDataTypeWithNullableContext() {}

func NewDataTypeWithNullableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeWithNullableContext {
	var p = new(DataTypeWithNullableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_dataTypeWithNullable

	return p
}

func (s *DataTypeWithNullableContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeWithNullableContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *DataTypeWithNullableContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisParserNULL, 0)
}

func (s *DataTypeWithNullableContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserNOT, 0)
}

func (s *DataTypeWithNullableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeWithNullableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeWithNullableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDataTypeWithNullable(s)
	}
}

func (s *DataTypeWithNullableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDataTypeWithNullable(s)
	}
}

func (p *DorisParser) DataTypeWithNullable() (localctx IDataTypeWithNullableContext) {
	localctx = NewDataTypeWithNullableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, DorisParserRULE_dataTypeWithNullable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6118)
		p.DataType()
	}
	p.SetState(6123)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserNOT || _la == DorisParserNULL {
		p.SetState(6120)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserNOT {
			{
				p.SetState(6119)
				p.Match(DorisParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6122)
			p.Match(DorisParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeContext is an interface to support dynamic dispatch.
type IDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDataTypeContext differentiates from other interfaces.
	IsDataTypeContext()
}

type DataTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeContext() *DataTypeContext {
	var p = new(DataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dataType
	return p
}

func InitEmptyDataTypeContext(p *DataTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_dataType
}

func (*DataTypeContext) IsDataTypeContext() {}

func NewDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeContext {
	var p = new(DataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_dataType

	return p
}

func (s *DataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeContext) CopyAll(ctx *DataTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ComplexDataTypeContext struct {
	DataTypeContext
	complex_ antlr.Token
}

func NewComplexDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComplexDataTypeContext {
	var p = new(ComplexDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *ComplexDataTypeContext) GetComplex_() antlr.Token { return s.complex_ }

func (s *ComplexDataTypeContext) SetComplex_(v antlr.Token) { s.complex_ = v }

func (s *ComplexDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComplexDataTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(DorisParserLT, 0)
}

func (s *ComplexDataTypeContext) AllDataType() []IDataTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeContext); ok {
			tst[i] = t.(IDataTypeContext)
			i++
		}
	}

	return tst
}

func (s *ComplexDataTypeContext) DataType(i int) IDataTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ComplexDataTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(DorisParserGT, 0)
}

func (s *ComplexDataTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(DorisParserARRAY, 0)
}

func (s *ComplexDataTypeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, 0)
}

func (s *ComplexDataTypeContext) MAP() antlr.TerminalNode {
	return s.GetToken(DorisParserMAP, 0)
}

func (s *ComplexDataTypeContext) ComplexColTypeList() IComplexColTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComplexColTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComplexColTypeListContext)
}

func (s *ComplexDataTypeContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRUCT, 0)
}

func (s *ComplexDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterComplexDataType(s)
	}
}

func (s *ComplexDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitComplexDataType(s)
	}
}

type AggStateDataTypeContext struct {
	DataTypeContext
	_dataTypeWithNullable IDataTypeWithNullableContext
	dataTypes             []IDataTypeWithNullableContext
}

func NewAggStateDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AggStateDataTypeContext {
	var p = new(AggStateDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *AggStateDataTypeContext) Get_dataTypeWithNullable() IDataTypeWithNullableContext {
	return s._dataTypeWithNullable
}

func (s *AggStateDataTypeContext) Set_dataTypeWithNullable(v IDataTypeWithNullableContext) {
	s._dataTypeWithNullable = v
}

func (s *AggStateDataTypeContext) GetDataTypes() []IDataTypeWithNullableContext { return s.dataTypes }

func (s *AggStateDataTypeContext) SetDataTypes(v []IDataTypeWithNullableContext) { s.dataTypes = v }

func (s *AggStateDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggStateDataTypeContext) AGG_STATE() antlr.TerminalNode {
	return s.GetToken(DorisParserAGG_STATE, 0)
}

func (s *AggStateDataTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(DorisParserLT, 0)
}

func (s *AggStateDataTypeContext) FunctionNameIdentifier() IFunctionNameIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameIdentifierContext)
}

func (s *AggStateDataTypeContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *AggStateDataTypeContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *AggStateDataTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(DorisParserGT, 0)
}

func (s *AggStateDataTypeContext) AllDataTypeWithNullable() []IDataTypeWithNullableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeWithNullableContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeWithNullableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeWithNullableContext); ok {
			tst[i] = t.(IDataTypeWithNullableContext)
			i++
		}
	}

	return tst
}

func (s *AggStateDataTypeContext) DataTypeWithNullable(i int) IDataTypeWithNullableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeWithNullableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeWithNullableContext)
}

func (s *AggStateDataTypeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *AggStateDataTypeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *AggStateDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterAggStateDataType(s)
	}
}

func (s *AggStateDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitAggStateDataType(s)
	}
}

type PrimitiveDataTypeContext struct {
	DataTypeContext
}

func NewPrimitiveDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimitiveDataTypeContext {
	var p = new(PrimitiveDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *PrimitiveDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveDataTypeContext) PrimitiveColType() IPrimitiveColTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveColTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveColTypeContext)
}

func (s *PrimitiveDataTypeContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *PrimitiveDataTypeContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *PrimitiveDataTypeContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserINTEGER_VALUE)
}

func (s *PrimitiveDataTypeContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, i)
}

func (s *PrimitiveDataTypeContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserASTERISK, 0)
}

func (s *PrimitiveDataTypeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *PrimitiveDataTypeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *PrimitiveDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPrimitiveDataType(s)
	}
}

func (s *PrimitiveDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPrimitiveDataType(s)
	}
}

func (p *DorisParser) DataType() (localctx IDataTypeContext) {
	localctx = NewDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, DorisParserRULE_dataType)
	var _la int

	p.SetState(6170)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 881, p.GetParserRuleContext()) {
	case 1:
		localctx = NewComplexDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6125)

			var _m = p.Match(DorisParserARRAY)

			localctx.(*ComplexDataTypeContext).complex_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6126)
			p.Match(DorisParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6127)
			p.DataType()
		}
		{
			p.SetState(6128)
			p.Match(DorisParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewComplexDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6130)

			var _m = p.Match(DorisParserMAP)

			localctx.(*ComplexDataTypeContext).complex_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6131)
			p.Match(DorisParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6132)
			p.DataType()
		}
		{
			p.SetState(6133)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6134)
			p.DataType()
		}
		{
			p.SetState(6135)
			p.Match(DorisParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewComplexDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6137)

			var _m = p.Match(DorisParserSTRUCT)

			localctx.(*ComplexDataTypeContext).complex_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6138)
			p.Match(DorisParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6139)
			p.ComplexColTypeList()
		}
		{
			p.SetState(6140)
			p.Match(DorisParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewAggStateDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6142)
			p.Match(DorisParserAGG_STATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6143)
			p.Match(DorisParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6144)
			p.FunctionNameIdentifier()
		}
		{
			p.SetState(6145)
			p.Match(DorisParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6146)

			var _x = p.DataTypeWithNullable()

			localctx.(*AggStateDataTypeContext)._dataTypeWithNullable = _x
		}
		localctx.(*AggStateDataTypeContext).dataTypes = append(localctx.(*AggStateDataTypeContext).dataTypes, localctx.(*AggStateDataTypeContext)._dataTypeWithNullable)
		p.SetState(6151)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserCOMMA {
			{
				p.SetState(6147)
				p.Match(DorisParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6148)

				var _x = p.DataTypeWithNullable()

				localctx.(*AggStateDataTypeContext)._dataTypeWithNullable = _x
			}
			localctx.(*AggStateDataTypeContext).dataTypes = append(localctx.(*AggStateDataTypeContext).dataTypes, localctx.(*AggStateDataTypeContext)._dataTypeWithNullable)

			p.SetState(6153)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6154)
			p.Match(DorisParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6155)
			p.Match(DorisParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewPrimitiveDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6157)
			p.PrimitiveColType()
		}
		p.SetState(6168)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserLEFT_PAREN {
			{
				p.SetState(6158)
				p.Match(DorisParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6159)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserASTERISK || _la == DorisParserINTEGER_VALUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(6164)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserCOMMA {
				{
					p.SetState(6160)
					p.Match(DorisParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6161)
					p.Match(DorisParserINTEGER_VALUE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(6166)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(6167)
				p.Match(DorisParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimitiveColTypeContext is an interface to support dynamic dispatch.
type IPrimitiveColTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	TINYINT() antlr.TerminalNode
	SMALLINT() antlr.TerminalNode
	INT() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	BIGINT() antlr.TerminalNode
	LARGEINT() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	TIME() antlr.TerminalNode
	DATEV2() antlr.TerminalNode
	DATETIMEV2() antlr.TerminalNode
	DATEV1() antlr.TerminalNode
	DATETIMEV1() antlr.TerminalNode
	BITMAP() antlr.TerminalNode
	QUANTILE_STATE() antlr.TerminalNode
	HLL() antlr.TerminalNode
	AGG_STATE() antlr.TerminalNode
	STRING() antlr.TerminalNode
	JSON() antlr.TerminalNode
	JSONB() antlr.TerminalNode
	TEXT() antlr.TerminalNode
	VARCHAR() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	DECIMALV2() antlr.TerminalNode
	DECIMALV3() antlr.TerminalNode
	IPV4() antlr.TerminalNode
	IPV6() antlr.TerminalNode
	VARIANT() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsPrimitiveColTypeContext differentiates from other interfaces.
	IsPrimitiveColTypeContext()
}

type PrimitiveColTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyPrimitiveColTypeContext() *PrimitiveColTypeContext {
	var p = new(PrimitiveColTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_primitiveColType
	return p
}

func InitEmptyPrimitiveColTypeContext(p *PrimitiveColTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_primitiveColType
}

func (*PrimitiveColTypeContext) IsPrimitiveColTypeContext() {}

func NewPrimitiveColTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveColTypeContext {
	var p = new(PrimitiveColTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_primitiveColType

	return p
}

func (s *PrimitiveColTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveColTypeContext) GetType_() antlr.Token { return s.type_ }

func (s *PrimitiveColTypeContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *PrimitiveColTypeContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(DorisParserTINYINT, 0)
}

func (s *PrimitiveColTypeContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(DorisParserSMALLINT, 0)
}

func (s *PrimitiveColTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(DorisParserINT, 0)
}

func (s *PrimitiveColTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER, 0)
}

func (s *PrimitiveColTypeContext) BIGINT() antlr.TerminalNode {
	return s.GetToken(DorisParserBIGINT, 0)
}

func (s *PrimitiveColTypeContext) LARGEINT() antlr.TerminalNode {
	return s.GetToken(DorisParserLARGEINT, 0)
}

func (s *PrimitiveColTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(DorisParserBOOLEAN, 0)
}

func (s *PrimitiveColTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(DorisParserFLOAT, 0)
}

func (s *PrimitiveColTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(DorisParserDOUBLE, 0)
}

func (s *PrimitiveColTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATE, 0)
}

func (s *PrimitiveColTypeContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(DorisParserDATETIME, 0)
}

func (s *PrimitiveColTypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserTIME, 0)
}

func (s *PrimitiveColTypeContext) DATEV2() antlr.TerminalNode {
	return s.GetToken(DorisParserDATEV2, 0)
}

func (s *PrimitiveColTypeContext) DATETIMEV2() antlr.TerminalNode {
	return s.GetToken(DorisParserDATETIMEV2, 0)
}

func (s *PrimitiveColTypeContext) DATEV1() antlr.TerminalNode {
	return s.GetToken(DorisParserDATEV1, 0)
}

func (s *PrimitiveColTypeContext) DATETIMEV1() antlr.TerminalNode {
	return s.GetToken(DorisParserDATETIMEV1, 0)
}

func (s *PrimitiveColTypeContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(DorisParserBITMAP, 0)
}

func (s *PrimitiveColTypeContext) QUANTILE_STATE() antlr.TerminalNode {
	return s.GetToken(DorisParserQUANTILE_STATE, 0)
}

func (s *PrimitiveColTypeContext) HLL() antlr.TerminalNode {
	return s.GetToken(DorisParserHLL, 0)
}

func (s *PrimitiveColTypeContext) AGG_STATE() antlr.TerminalNode {
	return s.GetToken(DorisParserAGG_STATE, 0)
}

func (s *PrimitiveColTypeContext) STRING() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING, 0)
}

func (s *PrimitiveColTypeContext) JSON() antlr.TerminalNode {
	return s.GetToken(DorisParserJSON, 0)
}

func (s *PrimitiveColTypeContext) JSONB() antlr.TerminalNode {
	return s.GetToken(DorisParserJSONB, 0)
}

func (s *PrimitiveColTypeContext) TEXT() antlr.TerminalNode {
	return s.GetToken(DorisParserTEXT, 0)
}

func (s *PrimitiveColTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserVARCHAR, 0)
}

func (s *PrimitiveColTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserCHAR, 0)
}

func (s *PrimitiveColTypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(DorisParserDECIMAL, 0)
}

func (s *PrimitiveColTypeContext) DECIMALV2() antlr.TerminalNode {
	return s.GetToken(DorisParserDECIMALV2, 0)
}

func (s *PrimitiveColTypeContext) DECIMALV3() antlr.TerminalNode {
	return s.GetToken(DorisParserDECIMALV3, 0)
}

func (s *PrimitiveColTypeContext) IPV4() antlr.TerminalNode {
	return s.GetToken(DorisParserIPV4, 0)
}

func (s *PrimitiveColTypeContext) IPV6() antlr.TerminalNode {
	return s.GetToken(DorisParserIPV6, 0)
}

func (s *PrimitiveColTypeContext) VARIANT() antlr.TerminalNode {
	return s.GetToken(DorisParserVARIANT, 0)
}

func (s *PrimitiveColTypeContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserALL, 0)
}

func (s *PrimitiveColTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveColTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveColTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterPrimitiveColType(s)
	}
}

func (s *PrimitiveColTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitPrimitiveColType(s)
	}
}

func (p *DorisParser) PrimitiveColType() (localctx IPrimitiveColTypeContext) {
	localctx = NewPrimitiveColTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, DorisParserRULE_primitiveColType)
	var _la int

	p.SetState(6204)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserTINYINT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6172)

			var _m = p.Match(DorisParserTINYINT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserSMALLINT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6173)

			var _m = p.Match(DorisParserSMALLINT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserINT, DorisParserINTEGER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6174)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PrimitiveColTypeContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserINT || _la == DorisParserINTEGER) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PrimitiveColTypeContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case DorisParserBIGINT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6175)

			var _m = p.Match(DorisParserBIGINT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserLARGEINT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6176)

			var _m = p.Match(DorisParserLARGEINT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserBOOLEAN:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6177)

			var _m = p.Match(DorisParserBOOLEAN)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserFLOAT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6178)

			var _m = p.Match(DorisParserFLOAT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDOUBLE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6179)

			var _m = p.Match(DorisParserDOUBLE)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDATE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6180)

			var _m = p.Match(DorisParserDATE)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDATETIME:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6181)

			var _m = p.Match(DorisParserDATETIME)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserTIME:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(6182)

			var _m = p.Match(DorisParserTIME)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDATEV2:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(6183)

			var _m = p.Match(DorisParserDATEV2)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDATETIMEV2:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(6184)

			var _m = p.Match(DorisParserDATETIMEV2)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDATEV1:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(6185)

			var _m = p.Match(DorisParserDATEV1)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDATETIMEV1:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(6186)

			var _m = p.Match(DorisParserDATETIMEV1)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserBITMAP:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(6187)

			var _m = p.Match(DorisParserBITMAP)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserQUANTILE_STATE:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(6188)

			var _m = p.Match(DorisParserQUANTILE_STATE)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserHLL:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(6189)

			var _m = p.Match(DorisParserHLL)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserAGG_STATE:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(6190)

			var _m = p.Match(DorisParserAGG_STATE)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserSTRING:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(6191)

			var _m = p.Match(DorisParserSTRING)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserJSON:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(6192)

			var _m = p.Match(DorisParserJSON)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserJSONB:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(6193)

			var _m = p.Match(DorisParserJSONB)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserTEXT:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(6194)

			var _m = p.Match(DorisParserTEXT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserVARCHAR:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(6195)

			var _m = p.Match(DorisParserVARCHAR)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserCHAR:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(6196)

			var _m = p.Match(DorisParserCHAR)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDECIMAL:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(6197)

			var _m = p.Match(DorisParserDECIMAL)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDECIMALV2:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(6198)

			var _m = p.Match(DorisParserDECIMALV2)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserDECIMALV3:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(6199)

			var _m = p.Match(DorisParserDECIMALV3)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserIPV4:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(6200)

			var _m = p.Match(DorisParserIPV4)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserIPV6:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(6201)

			var _m = p.Match(DorisParserIPV6)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserVARIANT:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(6202)

			var _m = p.Match(DorisParserVARIANT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserALL:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(6203)

			var _m = p.Match(DorisParserALL)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComplexColTypeListContext is an interface to support dynamic dispatch.
type IComplexColTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllComplexColType() []IComplexColTypeContext
	ComplexColType(i int) IComplexColTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsComplexColTypeListContext differentiates from other interfaces.
	IsComplexColTypeListContext()
}

type ComplexColTypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComplexColTypeListContext() *ComplexColTypeListContext {
	var p = new(ComplexColTypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_complexColTypeList
	return p
}

func InitEmptyComplexColTypeListContext(p *ComplexColTypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_complexColTypeList
}

func (*ComplexColTypeListContext) IsComplexColTypeListContext() {}

func NewComplexColTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComplexColTypeListContext {
	var p = new(ComplexColTypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_complexColTypeList

	return p
}

func (s *ComplexColTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *ComplexColTypeListContext) AllComplexColType() []IComplexColTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IComplexColTypeContext); ok {
			len++
		}
	}

	tst := make([]IComplexColTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IComplexColTypeContext); ok {
			tst[i] = t.(IComplexColTypeContext)
			i++
		}
	}

	return tst
}

func (s *ComplexColTypeListContext) ComplexColType(i int) IComplexColTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComplexColTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComplexColTypeContext)
}

func (s *ComplexColTypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserCOMMA)
}

func (s *ComplexColTypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMA, i)
}

func (s *ComplexColTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComplexColTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComplexColTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterComplexColTypeList(s)
	}
}

func (s *ComplexColTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitComplexColTypeList(s)
	}
}

func (p *DorisParser) ComplexColTypeList() (localctx IComplexColTypeListContext) {
	localctx = NewComplexColTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, DorisParserRULE_complexColTypeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6206)
		p.ComplexColType()
	}
	p.SetState(6211)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserCOMMA {
		{
			p.SetState(6207)
			p.Match(DorisParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6208)
			p.ComplexColType()
		}

		p.SetState(6213)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComplexColTypeContext is an interface to support dynamic dispatch.
type IComplexColTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	DataType() IDataTypeContext
	CommentSpec() ICommentSpecContext

	// IsComplexColTypeContext differentiates from other interfaces.
	IsComplexColTypeContext()
}

type ComplexColTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComplexColTypeContext() *ComplexColTypeContext {
	var p = new(ComplexColTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_complexColType
	return p
}

func InitEmptyComplexColTypeContext(p *ComplexColTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_complexColType
}

func (*ComplexColTypeContext) IsComplexColTypeContext() {}

func NewComplexColTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComplexColTypeContext {
	var p = new(ComplexColTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_complexColType

	return p
}

func (s *ComplexColTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ComplexColTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ComplexColTypeContext) COLON() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLON, 0)
}

func (s *ComplexColTypeContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ComplexColTypeContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *ComplexColTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComplexColTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComplexColTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterComplexColType(s)
	}
}

func (s *ComplexColTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitComplexColType(s)
	}
}

func (p *DorisParser) ComplexColType() (localctx IComplexColTypeContext) {
	localctx = NewComplexColTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, DorisParserRULE_complexColType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6214)
		p.Identifier()
	}
	{
		p.SetState(6215)
		p.Match(DorisParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6216)
		p.DataType()
	}
	p.SetState(6218)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserCOMMENT {
		{
			p.SetState(6217)
			p.CommentSpec()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommentSpecContext is an interface to support dynamic dispatch.
type ICommentSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsCommentSpecContext differentiates from other interfaces.
	IsCommentSpecContext()
}

type CommentSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentSpecContext() *CommentSpecContext {
	var p = new(CommentSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_commentSpec
	return p
}

func InitEmptyCommentSpecContext(p *CommentSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_commentSpec
}

func (*CommentSpecContext) IsCommentSpecContext() {}

func NewCommentSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentSpecContext {
	var p = new(CommentSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_commentSpec

	return p
}

func (s *CommentSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentSpecContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *CommentSpecContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *CommentSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterCommentSpec(s)
	}
}

func (s *CommentSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitCommentSpec(s)
	}
}

func (p *DorisParser) CommentSpec() (localctx ICommentSpecContext) {
	localctx = NewCommentSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, DorisParserRULE_commentSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6220)
		p.Match(DorisParserCOMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6221)
		p.Match(DorisParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampleContext is an interface to support dynamic dispatch.
type ISampleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSeed returns the seed token.
	GetSeed() antlr.Token

	// SetSeed sets the seed token.
	SetSeed(antlr.Token)

	// Getter signatures
	TABLESAMPLE() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	SampleMethod() ISampleMethodContext
	REPEATABLE() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsSampleContext differentiates from other interfaces.
	IsSampleContext()
}

type SampleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	seed   antlr.Token
}

func NewEmptySampleContext() *SampleContext {
	var p = new(SampleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sample
	return p
}

func InitEmptySampleContext(p *SampleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sample
}

func (*SampleContext) IsSampleContext() {}

func NewSampleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleContext {
	var p = new(SampleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_sample

	return p
}

func (s *SampleContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleContext) GetSeed() antlr.Token { return s.seed }

func (s *SampleContext) SetSeed(v antlr.Token) { s.seed = v }

func (s *SampleContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLESAMPLE, 0)
}

func (s *SampleContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_PAREN, 0)
}

func (s *SampleContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_PAREN, 0)
}

func (s *SampleContext) SampleMethod() ISampleMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleMethodContext)
}

func (s *SampleContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPEATABLE, 0)
}

func (s *SampleContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *SampleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSample(s)
	}
}

func (s *SampleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSample(s)
	}
}

func (p *DorisParser) Sample() (localctx ISampleContext) {
	localctx = NewSampleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, DorisParserRULE_sample)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6223)
		p.Match(DorisParserTABLESAMPLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6224)
		p.Match(DorisParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6226)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserINTEGER_VALUE {
		{
			p.SetState(6225)
			p.SampleMethod()
		}

	}
	{
		p.SetState(6228)
		p.Match(DorisParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6231)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 886, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6229)
			p.Match(DorisParserREPEATABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6230)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*SampleContext).seed = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampleMethodContext is an interface to support dynamic dispatch.
type ISampleMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSampleMethodContext differentiates from other interfaces.
	IsSampleMethodContext()
}

type SampleMethodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampleMethodContext() *SampleMethodContext {
	var p = new(SampleMethodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sampleMethod
	return p
}

func InitEmptySampleMethodContext(p *SampleMethodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_sampleMethod
}

func (*SampleMethodContext) IsSampleMethodContext() {}

func NewSampleMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleMethodContext {
	var p = new(SampleMethodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_sampleMethod

	return p
}

func (s *SampleMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleMethodContext) CopyAll(ctx *SampleMethodContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SampleMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SampleByRowsContext struct {
	SampleMethodContext
}

func NewSampleByRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SampleByRowsContext {
	var p = new(SampleByRowsContext)

	InitEmptySampleMethodContext(&p.SampleMethodContext)
	p.parser = parser
	p.CopyAll(ctx.(*SampleMethodContext))

	return p
}

func (s *SampleByRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleByRowsContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *SampleByRowsContext) ROWS() antlr.TerminalNode {
	return s.GetToken(DorisParserROWS, 0)
}

func (s *SampleByRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSampleByRows(s)
	}
}

func (s *SampleByRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSampleByRows(s)
	}
}

type SampleByPercentileContext struct {
	SampleMethodContext
	percentage antlr.Token
}

func NewSampleByPercentileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SampleByPercentileContext {
	var p = new(SampleByPercentileContext)

	InitEmptySampleMethodContext(&p.SampleMethodContext)
	p.parser = parser
	p.CopyAll(ctx.(*SampleMethodContext))

	return p
}

func (s *SampleByPercentileContext) GetPercentage() antlr.Token { return s.percentage }

func (s *SampleByPercentileContext) SetPercentage(v antlr.Token) { s.percentage = v }

func (s *SampleByPercentileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleByPercentileContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(DorisParserPERCENT, 0)
}

func (s *SampleByPercentileContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *SampleByPercentileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterSampleByPercentile(s)
	}
}

func (s *SampleByPercentileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitSampleByPercentile(s)
	}
}

func (p *DorisParser) SampleMethod() (localctx ISampleMethodContext) {
	localctx = NewSampleMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, DorisParserRULE_sampleMethod)
	p.SetState(6237)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 887, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSampleByPercentileContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6233)

			var _m = p.Match(DorisParserINTEGER_VALUE)

			localctx.(*SampleByPercentileContext).percentage = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6234)
			p.Match(DorisParserPERCENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewSampleByRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6235)
			p.Match(DorisParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6236)
			p.Match(DorisParserROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableSnapshotContext is an interface to support dynamic dispatch.
type ITableSnapshotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetVersion returns the version token.
	GetVersion() antlr.Token

	// GetTime returns the time token.
	GetTime() antlr.Token

	// SetVersion sets the version token.
	SetVersion(antlr.Token)

	// SetTime sets the time token.
	SetTime(antlr.Token)

	// Getter signatures
	FOR() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	TIME() antlr.TerminalNode

	// IsTableSnapshotContext differentiates from other interfaces.
	IsTableSnapshotContext()
}

type TableSnapshotContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	version antlr.Token
	time    antlr.Token
}

func NewEmptyTableSnapshotContext() *TableSnapshotContext {
	var p = new(TableSnapshotContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tableSnapshot
	return p
}

func InitEmptyTableSnapshotContext(p *TableSnapshotContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_tableSnapshot
}

func (*TableSnapshotContext) IsTableSnapshotContext() {}

func NewTableSnapshotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSnapshotContext {
	var p = new(TableSnapshotContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_tableSnapshot

	return p
}

func (s *TableSnapshotContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSnapshotContext) GetVersion() antlr.Token { return s.version }

func (s *TableSnapshotContext) GetTime() antlr.Token { return s.time }

func (s *TableSnapshotContext) SetVersion(v antlr.Token) { s.version = v }

func (s *TableSnapshotContext) SetTime(v antlr.Token) { s.time = v }

func (s *TableSnapshotContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserFOR, 0)
}

func (s *TableSnapshotContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisParserVERSION, 0)
}

func (s *TableSnapshotContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserAS, 0)
}

func (s *TableSnapshotContext) OF() antlr.TerminalNode {
	return s.GetToken(DorisParserOF, 0)
}

func (s *TableSnapshotContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *TableSnapshotContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING_LITERAL, 0)
}

func (s *TableSnapshotContext) TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserTIME, 0)
}

func (s *TableSnapshotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSnapshotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableSnapshotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterTableSnapshot(s)
	}
}

func (s *TableSnapshotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitTableSnapshot(s)
	}
}

func (p *DorisParser) TableSnapshot() (localctx ITableSnapshotContext) {
	localctx = NewTableSnapshotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, DorisParserRULE_tableSnapshot)
	var _la int

	p.SetState(6249)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 888, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6239)
			p.Match(DorisParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6240)
			p.Match(DorisParserVERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6241)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6242)
			p.Match(DorisParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6243)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableSnapshotContext).version = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserSTRING_LITERAL || _la == DorisParserINTEGER_VALUE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableSnapshotContext).version = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6244)
			p.Match(DorisParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6245)
			p.Match(DorisParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6246)
			p.Match(DorisParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6247)
			p.Match(DorisParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6248)

			var _m = p.Match(DorisParserSTRING_LITERAL)

			localctx.(*TableSnapshotContext).time = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorCapturingIdentifierContext is an interface to support dynamic dispatch.
type IErrorCapturingIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ErrorCapturingIdentifierExtra() IErrorCapturingIdentifierExtraContext

	// IsErrorCapturingIdentifierContext differentiates from other interfaces.
	IsErrorCapturingIdentifierContext()
}

type ErrorCapturingIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorCapturingIdentifierContext() *ErrorCapturingIdentifierContext {
	var p = new(ErrorCapturingIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_errorCapturingIdentifier
	return p
}

func InitEmptyErrorCapturingIdentifierContext(p *ErrorCapturingIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_errorCapturingIdentifier
}

func (*ErrorCapturingIdentifierContext) IsErrorCapturingIdentifierContext() {}

func NewErrorCapturingIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorCapturingIdentifierContext {
	var p = new(ErrorCapturingIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_errorCapturingIdentifier

	return p
}

func (s *ErrorCapturingIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorCapturingIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ErrorCapturingIdentifierContext) ErrorCapturingIdentifierExtra() IErrorCapturingIdentifierExtraContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierExtraContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierExtraContext)
}

func (s *ErrorCapturingIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorCapturingIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorCapturingIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterErrorCapturingIdentifier(s)
	}
}

func (s *ErrorCapturingIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitErrorCapturingIdentifier(s)
	}
}

func (p *DorisParser) ErrorCapturingIdentifier() (localctx IErrorCapturingIdentifierContext) {
	localctx = NewErrorCapturingIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, DorisParserRULE_errorCapturingIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6251)
		p.Identifier()
	}
	{
		p.SetState(6252)
		p.ErrorCapturingIdentifierExtra()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorCapturingIdentifierExtraContext is an interface to support dynamic dispatch.
type IErrorCapturingIdentifierExtraContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsErrorCapturingIdentifierExtraContext differentiates from other interfaces.
	IsErrorCapturingIdentifierExtraContext()
}

type ErrorCapturingIdentifierExtraContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorCapturingIdentifierExtraContext() *ErrorCapturingIdentifierExtraContext {
	var p = new(ErrorCapturingIdentifierExtraContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_errorCapturingIdentifierExtra
	return p
}

func InitEmptyErrorCapturingIdentifierExtraContext(p *ErrorCapturingIdentifierExtraContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_errorCapturingIdentifierExtra
}

func (*ErrorCapturingIdentifierExtraContext) IsErrorCapturingIdentifierExtraContext() {}

func NewErrorCapturingIdentifierExtraContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorCapturingIdentifierExtraContext {
	var p = new(ErrorCapturingIdentifierExtraContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_errorCapturingIdentifierExtra

	return p
}

func (s *ErrorCapturingIdentifierExtraContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorCapturingIdentifierExtraContext) CopyAll(ctx *ErrorCapturingIdentifierExtraContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ErrorCapturingIdentifierExtraContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorCapturingIdentifierExtraContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ErrorIdentContext struct {
	ErrorCapturingIdentifierExtraContext
}

func NewErrorIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ErrorIdentContext {
	var p = new(ErrorIdentContext)

	InitEmptyErrorCapturingIdentifierExtraContext(&p.ErrorCapturingIdentifierExtraContext)
	p.parser = parser
	p.CopyAll(ctx.(*ErrorCapturingIdentifierExtraContext))

	return p
}

func (s *ErrorIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorIdentContext) AllSUBTRACT() []antlr.TerminalNode {
	return s.GetTokens(DorisParserSUBTRACT)
}

func (s *ErrorIdentContext) SUBTRACT(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserSUBTRACT, i)
}

func (s *ErrorIdentContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ErrorIdentContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ErrorIdentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterErrorIdent(s)
	}
}

func (s *ErrorIdentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitErrorIdent(s)
	}
}

type RealIdentContext struct {
	ErrorCapturingIdentifierExtraContext
}

func NewRealIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RealIdentContext {
	var p = new(RealIdentContext)

	InitEmptyErrorCapturingIdentifierExtraContext(&p.ErrorCapturingIdentifierExtraContext)
	p.parser = parser
	p.CopyAll(ctx.(*ErrorCapturingIdentifierExtraContext))

	return p
}

func (s *RealIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RealIdentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterRealIdent(s)
	}
}

func (s *RealIdentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitRealIdent(s)
	}
}

func (p *DorisParser) ErrorCapturingIdentifierExtra() (localctx IErrorCapturingIdentifierExtraContext) {
	localctx = NewErrorCapturingIdentifierExtraContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, DorisParserRULE_errorCapturingIdentifierExtra)
	var _alt int

	p.SetState(6261)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 890, p.GetParserRuleContext()) {
	case 1:
		localctx = NewErrorIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6256)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(6254)
					p.Match(DorisParserSUBTRACT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6255)
					p.Identifier()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(6258)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 889, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		localctx = NewRealIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StrictIdentifier() IStrictIdentifierContext

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *DorisParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, DorisParserRULE_identifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6263)
		p.StrictIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStrictIdentifierContext is an interface to support dynamic dispatch.
type IStrictIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStrictIdentifierContext differentiates from other interfaces.
	IsStrictIdentifierContext()
}

type StrictIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrictIdentifierContext() *StrictIdentifierContext {
	var p = new(StrictIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_strictIdentifier
	return p
}

func InitEmptyStrictIdentifierContext(p *StrictIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_strictIdentifier
}

func (*StrictIdentifierContext) IsStrictIdentifierContext() {}

func NewStrictIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StrictIdentifierContext {
	var p = new(StrictIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_strictIdentifier

	return p
}

func (s *StrictIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *StrictIdentifierContext) CopyAll(ctx *StrictIdentifierContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StrictIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StrictIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QuotedIdentifierAlternativeContext struct {
	StrictIdentifierContext
}

func NewQuotedIdentifierAlternativeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuotedIdentifierAlternativeContext {
	var p = new(QuotedIdentifierAlternativeContext)

	InitEmptyStrictIdentifierContext(&p.StrictIdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*StrictIdentifierContext))

	return p
}

func (s *QuotedIdentifierAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierAlternativeContext) QuotedIdentifier() IQuotedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuotedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuotedIdentifierContext)
}

func (s *QuotedIdentifierAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterQuotedIdentifierAlternative(s)
	}
}

func (s *QuotedIdentifierAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitQuotedIdentifierAlternative(s)
	}
}

type UnquotedIdentifierContext struct {
	StrictIdentifierContext
}

func NewUnquotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnquotedIdentifierContext {
	var p = new(UnquotedIdentifierContext)

	InitEmptyStrictIdentifierContext(&p.StrictIdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*StrictIdentifierContext))

	return p
}

func (s *UnquotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnquotedIdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(DorisParserIDENTIFIER, 0)
}

func (s *UnquotedIdentifierContext) NonReserved() INonReservedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonReservedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonReservedContext)
}

func (s *UnquotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitUnquotedIdentifier(s)
	}
}

func (p *DorisParser) StrictIdentifier() (localctx IStrictIdentifierContext) {
	localctx = NewStrictIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, DorisParserRULE_strictIdentifier)
	p.SetState(6268)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserIDENTIFIER:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6265)
			p.Match(DorisParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserBACKQUOTED_IDENTIFIER:
		localctx = NewQuotedIdentifierAlternativeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6266)
			p.QuotedIdentifier()
		}

	case DorisParserLEFT_BRACE, DorisParserRIGHT_BRACE, DorisParserACTIONS, DorisParserAFTER, DorisParserAGG_STATE, DorisParserAGGREGATE, DorisParserALIAS, DorisParserANALYZED, DorisParserARRAY, DorisParserAT, DorisParserAUTHORS, DorisParserAUTO_INCREMENT, DorisParserALWAYS, DorisParserBACKENDS, DorisParserBACKUP, DorisParserBEGIN, DorisParserBELONG, DorisParserBIN, DorisParserBITAND, DorisParserBITMAP, DorisParserBITMAP_EMPTY, DorisParserBITMAP_UNION, DorisParserBITOR, DorisParserBITXOR, DorisParserBLOB, DorisParserBOOLEAN, DorisParserBRANCH, DorisParserBRIEF, DorisParserBROKER, DorisParserBUCKETS, DorisParserBUILD, DorisParserBUILTIN, DorisParserBULK, DorisParserCACHE, DorisParserCACHED, DorisParserCALL, DorisParserCATALOG, DorisParserCATALOGS, DorisParserCHAIN, DorisParserCHAR, DorisParserCHARSET, DorisParserCHECK, DorisParserCLUSTER, DorisParserCLUSTERS, DorisParserCOLLATION, DorisParserCOLLECT, DorisParserCOLOCATE, DorisParserCOLUMNS, DorisParserCOMMENT, DorisParserCOMMIT, DorisParserCOMMITTED, DorisParserCOMPACT, DorisParserCOMPLETE, DorisParserCOMPRESS_TYPE, DorisParserCOMPUTE, DorisParserCONDITIONS, DorisParserCONFIG, DorisParserCONNECTION, DorisParserCONNECTION_ID, DorisParserCONSISTENT, DorisParserCONSTRAINTS, DorisParserCONVERT, DorisParserCONVERT_LSC, DorisParserCOPY, DorisParserCOUNT, DorisParserCREATION, DorisParserCRON, DorisParserCURRENT_CATALOG, DorisParserCURRENT_DATE, DorisParserCURRENT_TIME, DorisParserCURRENT_TIMESTAMP, DorisParserCURRENT_USER, DorisParserDATA, DorisParserDATE, DorisParserDATETIME, DorisParserDATETIMEV2, DorisParserDATEV2, DorisParserDATETIMEV1, DorisParserDATEV1, DorisParserDAY, DorisParserDAYS, DorisParserDECIMAL, DorisParserDECIMALV2, DorisParserDECIMALV3, DorisParserDEFERRED, DorisParserDEMAND, DorisParserDIAGNOSE, DorisParserDIAGNOSIS, DorisParserDICTIONARIES, DorisParserDICTIONARY, DorisParserDISTINCTPC, DorisParserDISTINCTPCSA, DorisParserDO, DorisParserDORIS_INTERNAL_TABLE_ID, DorisParserDUAL, DorisParserDYNAMIC, DorisParserE, DorisParserENABLE, DorisParserENCRYPTKEY, DorisParserENCRYPTKEYS, DorisParserEND, DorisParserENDS, DorisParserENGINE, DorisParserENGINES, DorisParserERRORS, DorisParserEVENTS, DorisParserEVERY, DorisParserEXCLUDE, DorisParserEXPIRED, DorisParserEXTERNAL, DorisParserFAILED_LOGIN_ATTEMPTS, DorisParserFAST, DorisParserFEATURE, DorisParserFIELDS, DorisParserFILE, DorisParserFILTER, DorisParserFIRST, DorisParserFORMAT, DorisParserFREE, DorisParserFRONTENDS, DorisParserFUNCTION, DorisParserGENERATED, DorisParserGENERIC, DorisParserGLOBAL, DorisParserGRAPH, DorisParserGROUPING, DorisParserGROUPS, DorisParserHASH, DorisParserHASH_MAP, DorisParserHDFS, DorisParserHELP, DorisParserHISTOGRAM, DorisParserHLL_UNION, DorisParserHOSTNAME, DorisParserHOTSPOT, DorisParserHOUR, DorisParserHOURS, DorisParserHUB, DorisParserIDENTIFIED, DorisParserIGNORE, DorisParserIMMEDIATE, DorisParserINCREMENTAL, DorisParserINDEXES, DorisParserINVERTED, DorisParserIP_TRIE, DorisParserIPV4, DorisParserIPV6, DorisParserIS_NOT_NULL_PRED, DorisParserIS_NULL_PRED, DorisParserISNULL, DorisParserISOLATION, DorisParserJOB, DorisParserJOBS, DorisParserJSON, DorisParserJSONB, DorisParserLABEL, DorisParserLAST, DorisParserLDAP, DorisParserLDAP_ADMIN_PASSWORD, DorisParserLESS, DorisParserLEVEL, DorisParserLINES, DorisParserLINK, DorisParserLOCAL, DorisParserLOCALTIME, DorisParserLOCALTIMESTAMP, DorisParserLOCATION, DorisParserLOCK, DorisParserLOGICAL, DorisParserMANUAL, DorisParserMAP, DorisParserMATCH_ALL, DorisParserMATCH_ANY, DorisParserMATCH_PHRASE, DorisParserMATCH_PHRASE_EDGE, DorisParserMATCH_PHRASE_PREFIX, DorisParserMATCH_REGEXP, DorisParserMATERIALIZED, DorisParserMAX, DorisParserMEMO, DorisParserMERGE, DorisParserMIGRATE, DorisParserMIGRATIONS, DorisParserMIN, DorisParserMINUTE, DorisParserMINUTES, DorisParserMODIFY, DorisParserMONTH, DorisParserMTMV, DorisParserNAME, DorisParserNAMES, DorisParserNEGATIVE, DorisParserNEVER, DorisParserNEXT, DorisParserNGRAM_BF, DorisParserNO, DorisParserNON_NULLABLE, DorisParserNULLS, DorisParserOF, DorisParserOFFSET, DorisParserONLY, DorisParserOPEN, DorisParserOPTIMIZED, DorisParserPARAMETER, DorisParserPARSED, DorisParserPARTITIONS, DorisParserPASSWORD, DorisParserPASSWORD_EXPIRE, DorisParserPASSWORD_HISTORY, DorisParserPASSWORD_LOCK_TIME, DorisParserPASSWORD_REUSE, DorisParserPATH, DorisParserPAUSE, DorisParserPERCENT, DorisParserPERIOD, DorisParserPERMISSIVE, DorisParserPHYSICAL, DorisParserPI, DorisParserPLAN, DorisParserPRIVILEGES, DorisParserPROCESS, DorisParserPLUGIN, DorisParserPLUGINS, DorisParserPOLICY, DorisParserPROC, DorisParserPROCESSLIST, DorisParserPROFILE, DorisParserPROPERTIES, DorisParserPROPERTY, DorisParserQUANTILE_STATE, DorisParserQUANTILE_UNION, DorisParserQUERY, DorisParserQUEUED, DorisParserQUOTA, DorisParserQUALIFY, DorisParserQUARTER, DorisParserRANDOM, DorisParserRECENT, DorisParserRECOVER, DorisParserRECYCLE, DorisParserREFRESH, DorisParserREPEATABLE, DorisParserREPLACE, DorisParserREPLACE_IF_NOT_NULL, DorisParserREPLAYER, DorisParserREPOSITORIES, DorisParserREPOSITORY, DorisParserRESOURCE, DorisParserRESOURCES, DorisParserRESTORE, DorisParserRESTRICTIVE, DorisParserRESUME, DorisParserRETAIN, DorisParserRETENTION, DorisParserRETURNS, DorisParserREWRITTEN, DorisParserRLIKE, DorisParserROLLBACK, DorisParserROLLUP, DorisParserROUTINE, DorisParserS3, DorisParserSAMPLE, DorisParserSCHEDULE, DorisParserSCHEDULER, DorisParserSCHEMA, DorisParserSECOND, DorisParserSERIALIZABLE, DorisParserSESSION, DorisParserSESSION_USER, DorisParserSET_SESSION_VARIABLE, DorisParserSHAPE, DorisParserSKEW, DorisParserSNAPSHOT, DorisParserSNAPSHOTS, DorisParserSONAME, DorisParserSPLIT, DorisParserSQL, DorisParserSTAGE, DorisParserSTAGES, DorisParserSTART, DorisParserSTARTS, DorisParserSTATS, DorisParserSTATUS, DorisParserSTOP, DorisParserSTORAGE, DorisParserSTREAM, DorisParserSTREAMING, DorisParserSTRING, DorisParserSTRUCT, DorisParserSUM, DorisParserTABLES, DorisParserTAG, DorisParserTASK, DorisParserTASKS, DorisParserTEMPORARY, DorisParserTEXT, DorisParserTHAN, DorisParserTIME, DorisParserTIMESTAMP, DorisParserTRANSACTION, DorisParserTREE, DorisParserTRIGGERS, DorisParserTRUNCATE, DorisParserTYPE, DorisParserTYPES, DorisParserUNCOMMITTED, DorisParserUNLOCK, DorisParserUNSET, DorisParserUP, DorisParserUSER, DorisParserVALUE, DorisParserVARCHAR, DorisParserVARIABLE, DorisParserVARIABLES, DorisParserVARIANT, DorisParserVAULT, DorisParserVAULTS, DorisParserVERBOSE, DorisParserVERSION, DorisParserVIEW, DorisParserVIEWS, DorisParserWARM, DorisParserWARNINGS, DorisParserWEEK, DorisParserWORK, DorisParserYEAR, DorisParserHINT_START, DorisParserHINT_END, DorisParserCOMMENT_START:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6267)
			p.NonReserved()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuotedIdentifierContext is an interface to support dynamic dispatch.
type IQuotedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BACKQUOTED_IDENTIFIER() antlr.TerminalNode

	// IsQuotedIdentifierContext differentiates from other interfaces.
	IsQuotedIdentifierContext()
}

type QuotedIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuotedIdentifierContext() *QuotedIdentifierContext {
	var p = new(QuotedIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_quotedIdentifier
	return p
}

func InitEmptyQuotedIdentifierContext(p *QuotedIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_quotedIdentifier
}

func (*QuotedIdentifierContext) IsQuotedIdentifierContext() {}

func NewQuotedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuotedIdentifierContext {
	var p = new(QuotedIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_quotedIdentifier

	return p
}

func (s *QuotedIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *QuotedIdentifierContext) BACKQUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKQUOTED_IDENTIFIER, 0)
}

func (s *QuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterQuotedIdentifier(s)
	}
}

func (s *QuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitQuotedIdentifier(s)
	}
}

func (p *DorisParser) QuotedIdentifier() (localctx IQuotedIdentifierContext) {
	localctx = NewQuotedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, DorisParserRULE_quotedIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6270)
		p.Match(DorisParserBACKQUOTED_IDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_number
	return p
}

func InitEmptyNumberContext(p *NumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_number
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) CopyAll(ctx *NumberContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DecimalLiteralContext struct {
	NumberContext
}

func NewDecimalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) EXPONENT_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserEXPONENT_VALUE, 0)
}

func (s *DecimalLiteralContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserDECIMAL_VALUE, 0)
}

func (s *DecimalLiteralContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(DorisParserSUBTRACT, 0)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

type IntegerLiteralContext struct {
	NumberContext
}

func NewIntegerLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserINTEGER_VALUE, 0)
}

func (s *IntegerLiteralContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(DorisParserSUBTRACT, 0)
}

func (s *IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitIntegerLiteral(s)
	}
}

func (p *DorisParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, DorisParserRULE_number)
	var _la int

	p.SetState(6280)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 894, p.GetParserRuleContext()) {
	case 1:
		localctx = NewIntegerLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6273)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserSUBTRACT {
			{
				p.SetState(6272)
				p.Match(DorisParserSUBTRACT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6275)
			p.Match(DorisParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewDecimalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(6277)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserSUBTRACT {
			{
				p.SetState(6276)
				p.Match(DorisParserSUBTRACT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6279)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserEXPONENT_VALUE || _la == DorisParserDECIMAL_VALUE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonReservedContext is an interface to support dynamic dispatch.
type INonReservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACTIONS() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	AGG_STATE() antlr.TerminalNode
	AGGREGATE() antlr.TerminalNode
	ALIAS() antlr.TerminalNode
	ALWAYS() antlr.TerminalNode
	ANALYZED() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	AT() antlr.TerminalNode
	AUTHORS() antlr.TerminalNode
	AUTO_INCREMENT() antlr.TerminalNode
	BACKENDS() antlr.TerminalNode
	BACKUP() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	BELONG() antlr.TerminalNode
	BIN() antlr.TerminalNode
	BITAND() antlr.TerminalNode
	BITMAP() antlr.TerminalNode
	BITMAP_EMPTY() antlr.TerminalNode
	BITMAP_UNION() antlr.TerminalNode
	BITOR() antlr.TerminalNode
	BITXOR() antlr.TerminalNode
	BLOB() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	BRANCH() antlr.TerminalNode
	BRIEF() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	BUILD() antlr.TerminalNode
	BUILTIN() antlr.TerminalNode
	BULK() antlr.TerminalNode
	CACHE() antlr.TerminalNode
	CACHED() antlr.TerminalNode
	CALL() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	CATALOGS() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	CLUSTERS() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	COLLECT() antlr.TerminalNode
	COLOCATE() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	COMMENT_START() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	COMPACT() antlr.TerminalNode
	COMPLETE() antlr.TerminalNode
	COMPRESS_TYPE() antlr.TerminalNode
	COMPUTE() antlr.TerminalNode
	CONDITIONS() antlr.TerminalNode
	CONFIG() antlr.TerminalNode
	CONNECTION() antlr.TerminalNode
	CONNECTION_ID() antlr.TerminalNode
	CONSISTENT() antlr.TerminalNode
	CONSTRAINTS() antlr.TerminalNode
	CONVERT() antlr.TerminalNode
	CONVERT_LSC() antlr.TerminalNode
	COPY() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	CREATION() antlr.TerminalNode
	CRON() antlr.TerminalNode
	CURRENT_CATALOG() antlr.TerminalNode
	CURRENT_DATE() antlr.TerminalNode
	CURRENT_TIME() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	CURRENT_USER() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	DATETIMEV1() antlr.TerminalNode
	DATETIMEV2() antlr.TerminalNode
	DATEV1() antlr.TerminalNode
	DATEV2() antlr.TerminalNode
	DAY() antlr.TerminalNode
	DAYS() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	DECIMALV2() antlr.TerminalNode
	DECIMALV3() antlr.TerminalNode
	DEFERRED() antlr.TerminalNode
	DEMAND() antlr.TerminalNode
	DIAGNOSE() antlr.TerminalNode
	DIAGNOSIS() antlr.TerminalNode
	DICTIONARIES() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	DISTINCTPC() antlr.TerminalNode
	DISTINCTPCSA() antlr.TerminalNode
	DO() antlr.TerminalNode
	DORIS_INTERNAL_TABLE_ID() antlr.TerminalNode
	DUAL() antlr.TerminalNode
	DYNAMIC() antlr.TerminalNode
	E() antlr.TerminalNode
	ENABLE() antlr.TerminalNode
	ENCRYPTKEY() antlr.TerminalNode
	ENCRYPTKEYS() antlr.TerminalNode
	END() antlr.TerminalNode
	ENDS() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	ENGINES() antlr.TerminalNode
	ERRORS() antlr.TerminalNode
	EVENTS() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	EXCLUDE() antlr.TerminalNode
	EXPIRED() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode
	FAST() antlr.TerminalNode
	FEATURE() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	FILE() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	FREE() antlr.TerminalNode
	FRONTENDS() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	GENERATED() antlr.TerminalNode
	GENERIC() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	GRAPH() antlr.TerminalNode
	GROUPING() antlr.TerminalNode
	GROUPS() antlr.TerminalNode
	HASH() antlr.TerminalNode
	HASH_MAP() antlr.TerminalNode
	HDFS() antlr.TerminalNode
	HELP() antlr.TerminalNode
	HINT_END() antlr.TerminalNode
	HINT_START() antlr.TerminalNode
	HISTOGRAM() antlr.TerminalNode
	HLL_UNION() antlr.TerminalNode
	HOSTNAME() antlr.TerminalNode
	HOTSPOT() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	HOURS() antlr.TerminalNode
	HUB() antlr.TerminalNode
	IDENTIFIED() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	IMMEDIATE() antlr.TerminalNode
	INCREMENTAL() antlr.TerminalNode
	INDEXES() antlr.TerminalNode
	INVERTED() antlr.TerminalNode
	IP_TRIE() antlr.TerminalNode
	IPV4() antlr.TerminalNode
	IPV6() antlr.TerminalNode
	IS_NOT_NULL_PRED() antlr.TerminalNode
	IS_NULL_PRED() antlr.TerminalNode
	ISNULL() antlr.TerminalNode
	ISOLATION() antlr.TerminalNode
	JOB() antlr.TerminalNode
	JOBS() antlr.TerminalNode
	JSON() antlr.TerminalNode
	JSONB() antlr.TerminalNode
	LABEL() antlr.TerminalNode
	LAST() antlr.TerminalNode
	LDAP() antlr.TerminalNode
	LDAP_ADMIN_PASSWORD() antlr.TerminalNode
	LEFT_BRACE() antlr.TerminalNode
	LESS() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	LINES() antlr.TerminalNode
	LINK() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	LOCALTIME() antlr.TerminalNode
	LOCALTIMESTAMP() antlr.TerminalNode
	LOCATION() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	LOGICAL() antlr.TerminalNode
	MANUAL() antlr.TerminalNode
	MAP() antlr.TerminalNode
	MATCH_ALL() antlr.TerminalNode
	MATCH_ANY() antlr.TerminalNode
	MATCH_PHRASE() antlr.TerminalNode
	MATCH_PHRASE_EDGE() antlr.TerminalNode
	MATCH_PHRASE_PREFIX() antlr.TerminalNode
	MATCH_REGEXP() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MEMO() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	MIGRATE() antlr.TerminalNode
	MIGRATIONS() antlr.TerminalNode
	MIN() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MINUTES() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	MTMV() antlr.TerminalNode
	NAME() antlr.TerminalNode
	NAMES() antlr.TerminalNode
	NEGATIVE() antlr.TerminalNode
	NEVER() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	NGRAM_BF() antlr.TerminalNode
	NO() antlr.TerminalNode
	NON_NULLABLE() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	OF() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	OPTIMIZED() antlr.TerminalNode
	PARAMETER() antlr.TerminalNode
	PARSED() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	PASSWORD_EXPIRE() antlr.TerminalNode
	PASSWORD_HISTORY() antlr.TerminalNode
	PASSWORD_LOCK_TIME() antlr.TerminalNode
	PASSWORD_REUSE() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	PATH() antlr.TerminalNode
	PAUSE() antlr.TerminalNode
	PERCENT() antlr.TerminalNode
	PERIOD() antlr.TerminalNode
	PERMISSIVE() antlr.TerminalNode
	PHYSICAL() antlr.TerminalNode
	PI() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	PLUGINS() antlr.TerminalNode
	POLICY() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	PROC() antlr.TerminalNode
	PROCESS() antlr.TerminalNode
	PROCESSLIST() antlr.TerminalNode
	PROFILE() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode
	QUANTILE_STATE() antlr.TerminalNode
	QUANTILE_UNION() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	QUOTA() antlr.TerminalNode
	QUALIFY() antlr.TerminalNode
	QUEUED() antlr.TerminalNode
	RANDOM() antlr.TerminalNode
	RECENT() antlr.TerminalNode
	RECOVER() antlr.TerminalNode
	RECYCLE() antlr.TerminalNode
	REFRESH() antlr.TerminalNode
	REPEATABLE() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	REPLACE_IF_NOT_NULL() antlr.TerminalNode
	REPLAYER() antlr.TerminalNode
	REPOSITORIES() antlr.TerminalNode
	REPOSITORY() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	RESOURCES() antlr.TerminalNode
	RESTORE() antlr.TerminalNode
	RESTRICTIVE() antlr.TerminalNode
	RESUME() antlr.TerminalNode
	RETAIN() antlr.TerminalNode
	RETENTION() antlr.TerminalNode
	RETURNS() antlr.TerminalNode
	REWRITTEN() antlr.TerminalNode
	RIGHT_BRACE() antlr.TerminalNode
	RLIKE() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	S3() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	SCHEDULER() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode
	SET_SESSION_VARIABLE() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	SESSION_USER() antlr.TerminalNode
	SHAPE() antlr.TerminalNode
	SKEW() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	SNAPSHOTS() antlr.TerminalNode
	SONAME() antlr.TerminalNode
	SPLIT() antlr.TerminalNode
	SQL() antlr.TerminalNode
	STAGE() antlr.TerminalNode
	STAGES() antlr.TerminalNode
	START() antlr.TerminalNode
	STARTS() antlr.TerminalNode
	STATS() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	STOP() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	STREAM() antlr.TerminalNode
	STREAMING() antlr.TerminalNode
	STRING() antlr.TerminalNode
	STRUCT() antlr.TerminalNode
	SUM() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	TAG() antlr.TerminalNode
	TASK() antlr.TerminalNode
	TASKS() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TEXT() antlr.TerminalNode
	THAN() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	TREE() antlr.TerminalNode
	TRIGGERS() antlr.TerminalNode
	TRUNCATE() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	TYPES() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	UNLOCK() antlr.TerminalNode
	UNSET() antlr.TerminalNode
	UP() antlr.TerminalNode
	USER() antlr.TerminalNode
	VALUE() antlr.TerminalNode
	VARCHAR() antlr.TerminalNode
	VARIABLE() antlr.TerminalNode
	VARIABLES() antlr.TerminalNode
	VARIANT() antlr.TerminalNode
	VAULT() antlr.TerminalNode
	VAULTS() antlr.TerminalNode
	VERBOSE() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	VIEWS() antlr.TerminalNode
	WARM() antlr.TerminalNode
	WARNINGS() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	WORK() antlr.TerminalNode
	YEAR() antlr.TerminalNode

	// IsNonReservedContext differentiates from other interfaces.
	IsNonReservedContext()
}

type NonReservedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedContext() *NonReservedContext {
	var p = new(NonReservedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_nonReserved
	return p
}

func InitEmptyNonReservedContext(p *NonReservedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserRULE_nonReserved
}

func (*NonReservedContext) IsNonReservedContext() {}

func NewNonReservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedContext {
	var p = new(NonReservedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserRULE_nonReserved

	return p
}

func (s *NonReservedContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedContext) ACTIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserACTIONS, 0)
}

func (s *NonReservedContext) AFTER() antlr.TerminalNode {
	return s.GetToken(DorisParserAFTER, 0)
}

func (s *NonReservedContext) AGG_STATE() antlr.TerminalNode {
	return s.GetToken(DorisParserAGG_STATE, 0)
}

func (s *NonReservedContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(DorisParserAGGREGATE, 0)
}

func (s *NonReservedContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(DorisParserALIAS, 0)
}

func (s *NonReservedContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(DorisParserALWAYS, 0)
}

func (s *NonReservedContext) ANALYZED() antlr.TerminalNode {
	return s.GetToken(DorisParserANALYZED, 0)
}

func (s *NonReservedContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(DorisParserARRAY, 0)
}

func (s *NonReservedContext) AT() antlr.TerminalNode {
	return s.GetToken(DorisParserAT, 0)
}

func (s *NonReservedContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTHORS, 0)
}

func (s *NonReservedContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserAUTO_INCREMENT, 0)
}

func (s *NonReservedContext) BACKENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKENDS, 0)
}

func (s *NonReservedContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(DorisParserBACKUP, 0)
}

func (s *NonReservedContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(DorisParserBEGIN, 0)
}

func (s *NonReservedContext) BELONG() antlr.TerminalNode {
	return s.GetToken(DorisParserBELONG, 0)
}

func (s *NonReservedContext) BIN() antlr.TerminalNode {
	return s.GetToken(DorisParserBIN, 0)
}

func (s *NonReservedContext) BITAND() antlr.TerminalNode {
	return s.GetToken(DorisParserBITAND, 0)
}

func (s *NonReservedContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(DorisParserBITMAP, 0)
}

func (s *NonReservedContext) BITMAP_EMPTY() antlr.TerminalNode {
	return s.GetToken(DorisParserBITMAP_EMPTY, 0)
}

func (s *NonReservedContext) BITMAP_UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserBITMAP_UNION, 0)
}

func (s *NonReservedContext) BITOR() antlr.TerminalNode {
	return s.GetToken(DorisParserBITOR, 0)
}

func (s *NonReservedContext) BITXOR() antlr.TerminalNode {
	return s.GetToken(DorisParserBITXOR, 0)
}

func (s *NonReservedContext) BLOB() antlr.TerminalNode {
	return s.GetToken(DorisParserBLOB, 0)
}

func (s *NonReservedContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(DorisParserBOOLEAN, 0)
}

func (s *NonReservedContext) BRANCH() antlr.TerminalNode {
	return s.GetToken(DorisParserBRANCH, 0)
}

func (s *NonReservedContext) BRIEF() antlr.TerminalNode {
	return s.GetToken(DorisParserBRIEF, 0)
}

func (s *NonReservedContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserBROKER, 0)
}

func (s *NonReservedContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisParserBUCKETS, 0)
}

func (s *NonReservedContext) BUILD() antlr.TerminalNode {
	return s.GetToken(DorisParserBUILD, 0)
}

func (s *NonReservedContext) BUILTIN() antlr.TerminalNode {
	return s.GetToken(DorisParserBUILTIN, 0)
}

func (s *NonReservedContext) BULK() antlr.TerminalNode {
	return s.GetToken(DorisParserBULK, 0)
}

func (s *NonReservedContext) CACHE() antlr.TerminalNode {
	return s.GetToken(DorisParserCACHE, 0)
}

func (s *NonReservedContext) CACHED() antlr.TerminalNode {
	return s.GetToken(DorisParserCACHED, 0)
}

func (s *NonReservedContext) CALL() antlr.TerminalNode {
	return s.GetToken(DorisParserCALL, 0)
}

func (s *NonReservedContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOG, 0)
}

func (s *NonReservedContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(DorisParserCATALOGS, 0)
}

func (s *NonReservedContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(DorisParserCHAIN, 0)
}

func (s *NonReservedContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserCHAR, 0)
}

func (s *NonReservedContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(DorisParserCHARSET, 0)
}

func (s *NonReservedContext) CHECK() antlr.TerminalNode {
	return s.GetToken(DorisParserCHECK, 0)
}

func (s *NonReservedContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(DorisParserCLUSTER, 0)
}

func (s *NonReservedContext) CLUSTERS() antlr.TerminalNode {
	return s.GetToken(DorisParserCLUSTERS, 0)
}

func (s *NonReservedContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLLATION, 0)
}

func (s *NonReservedContext) COLLECT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLLECT, 0)
}

func (s *NonReservedContext) COLOCATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLOCATE, 0)
}

func (s *NonReservedContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserCOLUMNS, 0)
}

func (s *NonReservedContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT, 0)
}

func (s *NonReservedContext) COMMENT_START() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMENT_START, 0)
}

func (s *NonReservedContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMIT, 0)
}

func (s *NonReservedContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMMITTED, 0)
}

func (s *NonReservedContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPACT, 0)
}

func (s *NonReservedContext) COMPLETE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPLETE, 0)
}

func (s *NonReservedContext) COMPRESS_TYPE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPRESS_TYPE, 0)
}

func (s *NonReservedContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(DorisParserCOMPUTE, 0)
}

func (s *NonReservedContext) CONDITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserCONDITIONS, 0)
}

func (s *NonReservedContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(DorisParserCONFIG, 0)
}

func (s *NonReservedContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(DorisParserCONNECTION, 0)
}

func (s *NonReservedContext) CONNECTION_ID() antlr.TerminalNode {
	return s.GetToken(DorisParserCONNECTION_ID, 0)
}

func (s *NonReservedContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(DorisParserCONSISTENT, 0)
}

func (s *NonReservedContext) CONSTRAINTS() antlr.TerminalNode {
	return s.GetToken(DorisParserCONSTRAINTS, 0)
}

func (s *NonReservedContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(DorisParserCONVERT, 0)
}

func (s *NonReservedContext) CONVERT_LSC() antlr.TerminalNode {
	return s.GetToken(DorisParserCONVERT_LSC, 0)
}

func (s *NonReservedContext) COPY() antlr.TerminalNode {
	return s.GetToken(DorisParserCOPY, 0)
}

func (s *NonReservedContext) COUNT() antlr.TerminalNode {
	return s.GetToken(DorisParserCOUNT, 0)
}

func (s *NonReservedContext) CREATION() antlr.TerminalNode {
	return s.GetToken(DorisParserCREATION, 0)
}

func (s *NonReservedContext) CRON() antlr.TerminalNode {
	return s.GetToken(DorisParserCRON, 0)
}

func (s *NonReservedContext) CURRENT_CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_CATALOG, 0)
}

func (s *NonReservedContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_DATE, 0)
}

func (s *NonReservedContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_TIME, 0)
}

func (s *NonReservedContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_TIMESTAMP, 0)
}

func (s *NonReservedContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(DorisParserCURRENT_USER, 0)
}

func (s *NonReservedContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserDATA, 0)
}

func (s *NonReservedContext) DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserDATE, 0)
}

func (s *NonReservedContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(DorisParserDATETIME, 0)
}

func (s *NonReservedContext) DATETIMEV1() antlr.TerminalNode {
	return s.GetToken(DorisParserDATETIMEV1, 0)
}

func (s *NonReservedContext) DATETIMEV2() antlr.TerminalNode {
	return s.GetToken(DorisParserDATETIMEV2, 0)
}

func (s *NonReservedContext) DATEV1() antlr.TerminalNode {
	return s.GetToken(DorisParserDATEV1, 0)
}

func (s *NonReservedContext) DATEV2() antlr.TerminalNode {
	return s.GetToken(DorisParserDATEV2, 0)
}

func (s *NonReservedContext) DAY() antlr.TerminalNode {
	return s.GetToken(DorisParserDAY, 0)
}

func (s *NonReservedContext) DAYS() antlr.TerminalNode {
	return s.GetToken(DorisParserDAYS, 0)
}

func (s *NonReservedContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(DorisParserDECIMAL, 0)
}

func (s *NonReservedContext) DECIMALV2() antlr.TerminalNode {
	return s.GetToken(DorisParserDECIMALV2, 0)
}

func (s *NonReservedContext) DECIMALV3() antlr.TerminalNode {
	return s.GetToken(DorisParserDECIMALV3, 0)
}

func (s *NonReservedContext) DEFERRED() antlr.TerminalNode {
	return s.GetToken(DorisParserDEFERRED, 0)
}

func (s *NonReservedContext) DEMAND() antlr.TerminalNode {
	return s.GetToken(DorisParserDEMAND, 0)
}

func (s *NonReservedContext) DIAGNOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserDIAGNOSE, 0)
}

func (s *NonReservedContext) DIAGNOSIS() antlr.TerminalNode {
	return s.GetToken(DorisParserDIAGNOSIS, 0)
}

func (s *NonReservedContext) DICTIONARIES() antlr.TerminalNode {
	return s.GetToken(DorisParserDICTIONARIES, 0)
}

func (s *NonReservedContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(DorisParserDICTIONARY, 0)
}

func (s *NonReservedContext) DISTINCTPC() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTINCTPC, 0)
}

func (s *NonReservedContext) DISTINCTPCSA() antlr.TerminalNode {
	return s.GetToken(DorisParserDISTINCTPCSA, 0)
}

func (s *NonReservedContext) DO() antlr.TerminalNode {
	return s.GetToken(DorisParserDO, 0)
}

func (s *NonReservedContext) DORIS_INTERNAL_TABLE_ID() antlr.TerminalNode {
	return s.GetToken(DorisParserDORIS_INTERNAL_TABLE_ID, 0)
}

func (s *NonReservedContext) DUAL() antlr.TerminalNode {
	return s.GetToken(DorisParserDUAL, 0)
}

func (s *NonReservedContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(DorisParserDYNAMIC, 0)
}

func (s *NonReservedContext) E() antlr.TerminalNode {
	return s.GetToken(DorisParserE, 0)
}

func (s *NonReservedContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserENABLE, 0)
}

func (s *NonReservedContext) ENCRYPTKEY() antlr.TerminalNode {
	return s.GetToken(DorisParserENCRYPTKEY, 0)
}

func (s *NonReservedContext) ENCRYPTKEYS() antlr.TerminalNode {
	return s.GetToken(DorisParserENCRYPTKEYS, 0)
}

func (s *NonReservedContext) END() antlr.TerminalNode {
	return s.GetToken(DorisParserEND, 0)
}

func (s *NonReservedContext) ENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserENDS, 0)
}

func (s *NonReservedContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(DorisParserENGINE, 0)
}

func (s *NonReservedContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(DorisParserENGINES, 0)
}

func (s *NonReservedContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(DorisParserERRORS, 0)
}

func (s *NonReservedContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(DorisParserEVENTS, 0)
}

func (s *NonReservedContext) EVERY() antlr.TerminalNode {
	return s.GetToken(DorisParserEVERY, 0)
}

func (s *NonReservedContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(DorisParserEXCLUDE, 0)
}

func (s *NonReservedContext) EXPIRED() antlr.TerminalNode {
	return s.GetToken(DorisParserEXPIRED, 0)
}

func (s *NonReservedContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisParserEXTERNAL, 0)
}

func (s *NonReservedContext) FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode {
	return s.GetToken(DorisParserFAILED_LOGIN_ATTEMPTS, 0)
}

func (s *NonReservedContext) FAST() antlr.TerminalNode {
	return s.GetToken(DorisParserFAST, 0)
}

func (s *NonReservedContext) FEATURE() antlr.TerminalNode {
	return s.GetToken(DorisParserFEATURE, 0)
}

func (s *NonReservedContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(DorisParserFIELDS, 0)
}

func (s *NonReservedContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisParserFILE, 0)
}

func (s *NonReservedContext) FILTER() antlr.TerminalNode {
	return s.GetToken(DorisParserFILTER, 0)
}

func (s *NonReservedContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DorisParserFIRST, 0)
}

func (s *NonReservedContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DorisParserFORMAT, 0)
}

func (s *NonReservedContext) FREE() antlr.TerminalNode {
	return s.GetToken(DorisParserFREE, 0)
}

func (s *NonReservedContext) FRONTENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserFRONTENDS, 0)
}

func (s *NonReservedContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserFUNCTION, 0)
}

func (s *NonReservedContext) GENERATED() antlr.TerminalNode {
	return s.GetToken(DorisParserGENERATED, 0)
}

func (s *NonReservedContext) GENERIC() antlr.TerminalNode {
	return s.GetToken(DorisParserGENERIC, 0)
}

func (s *NonReservedContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserGLOBAL, 0)
}

func (s *NonReservedContext) GRAPH() antlr.TerminalNode {
	return s.GetToken(DorisParserGRAPH, 0)
}

func (s *NonReservedContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUPING, 0)
}

func (s *NonReservedContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(DorisParserGROUPS, 0)
}

func (s *NonReservedContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisParserHASH, 0)
}

func (s *NonReservedContext) HASH_MAP() antlr.TerminalNode {
	return s.GetToken(DorisParserHASH_MAP, 0)
}

func (s *NonReservedContext) HDFS() antlr.TerminalNode {
	return s.GetToken(DorisParserHDFS, 0)
}

func (s *NonReservedContext) HELP() antlr.TerminalNode {
	return s.GetToken(DorisParserHELP, 0)
}

func (s *NonReservedContext) HINT_END() antlr.TerminalNode {
	return s.GetToken(DorisParserHINT_END, 0)
}

func (s *NonReservedContext) HINT_START() antlr.TerminalNode {
	return s.GetToken(DorisParserHINT_START, 0)
}

func (s *NonReservedContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(DorisParserHISTOGRAM, 0)
}

func (s *NonReservedContext) HLL_UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserHLL_UNION, 0)
}

func (s *NonReservedContext) HOSTNAME() antlr.TerminalNode {
	return s.GetToken(DorisParserHOSTNAME, 0)
}

func (s *NonReservedContext) HOTSPOT() antlr.TerminalNode {
	return s.GetToken(DorisParserHOTSPOT, 0)
}

func (s *NonReservedContext) HOUR() antlr.TerminalNode {
	return s.GetToken(DorisParserHOUR, 0)
}

func (s *NonReservedContext) HOURS() antlr.TerminalNode {
	return s.GetToken(DorisParserHOURS, 0)
}

func (s *NonReservedContext) HUB() antlr.TerminalNode {
	return s.GetToken(DorisParserHUB, 0)
}

func (s *NonReservedContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(DorisParserIDENTIFIED, 0)
}

func (s *NonReservedContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(DorisParserIGNORE, 0)
}

func (s *NonReservedContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(DorisParserIMMEDIATE, 0)
}

func (s *NonReservedContext) INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(DorisParserINCREMENTAL, 0)
}

func (s *NonReservedContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(DorisParserINDEXES, 0)
}

func (s *NonReservedContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserINVERTED, 0)
}

func (s *NonReservedContext) IP_TRIE() antlr.TerminalNode {
	return s.GetToken(DorisParserIP_TRIE, 0)
}

func (s *NonReservedContext) IPV4() antlr.TerminalNode {
	return s.GetToken(DorisParserIPV4, 0)
}

func (s *NonReservedContext) IPV6() antlr.TerminalNode {
	return s.GetToken(DorisParserIPV6, 0)
}

func (s *NonReservedContext) IS_NOT_NULL_PRED() antlr.TerminalNode {
	return s.GetToken(DorisParserIS_NOT_NULL_PRED, 0)
}

func (s *NonReservedContext) IS_NULL_PRED() antlr.TerminalNode {
	return s.GetToken(DorisParserIS_NULL_PRED, 0)
}

func (s *NonReservedContext) ISNULL() antlr.TerminalNode {
	return s.GetToken(DorisParserISNULL, 0)
}

func (s *NonReservedContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(DorisParserISOLATION, 0)
}

func (s *NonReservedContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserJOB, 0)
}

func (s *NonReservedContext) JOBS() antlr.TerminalNode {
	return s.GetToken(DorisParserJOBS, 0)
}

func (s *NonReservedContext) JSON() antlr.TerminalNode {
	return s.GetToken(DorisParserJSON, 0)
}

func (s *NonReservedContext) JSONB() antlr.TerminalNode {
	return s.GetToken(DorisParserJSONB, 0)
}

func (s *NonReservedContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisParserLABEL, 0)
}

func (s *NonReservedContext) LAST() antlr.TerminalNode {
	return s.GetToken(DorisParserLAST, 0)
}

func (s *NonReservedContext) LDAP() antlr.TerminalNode {
	return s.GetToken(DorisParserLDAP, 0)
}

func (s *NonReservedContext) LDAP_ADMIN_PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisParserLDAP_ADMIN_PASSWORD, 0)
}

func (s *NonReservedContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(DorisParserLEFT_BRACE, 0)
}

func (s *NonReservedContext) LESS() antlr.TerminalNode {
	return s.GetToken(DorisParserLESS, 0)
}

func (s *NonReservedContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(DorisParserLEVEL, 0)
}

func (s *NonReservedContext) LINES() antlr.TerminalNode {
	return s.GetToken(DorisParserLINES, 0)
}

func (s *NonReservedContext) LINK() antlr.TerminalNode {
	return s.GetToken(DorisParserLINK, 0)
}

func (s *NonReservedContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCAL, 0)
}

func (s *NonReservedContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCALTIME, 0)
}

func (s *NonReservedContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCALTIMESTAMP, 0)
}

func (s *NonReservedContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCATION, 0)
}

func (s *NonReservedContext) LOCK() antlr.TerminalNode {
	return s.GetToken(DorisParserLOCK, 0)
}

func (s *NonReservedContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(DorisParserLOGICAL, 0)
}

func (s *NonReservedContext) MANUAL() antlr.TerminalNode {
	return s.GetToken(DorisParserMANUAL, 0)
}

func (s *NonReservedContext) MAP() antlr.TerminalNode {
	return s.GetToken(DorisParserMAP, 0)
}

func (s *NonReservedContext) MATCH_ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_ALL, 0)
}

func (s *NonReservedContext) MATCH_ANY() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_ANY, 0)
}

func (s *NonReservedContext) MATCH_PHRASE() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_PHRASE, 0)
}

func (s *NonReservedContext) MATCH_PHRASE_EDGE() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_PHRASE_EDGE, 0)
}

func (s *NonReservedContext) MATCH_PHRASE_PREFIX() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_PHRASE_PREFIX, 0)
}

func (s *NonReservedContext) MATCH_REGEXP() antlr.TerminalNode {
	return s.GetToken(DorisParserMATCH_REGEXP, 0)
}

func (s *NonReservedContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserMATERIALIZED, 0)
}

func (s *NonReservedContext) MAX() antlr.TerminalNode {
	return s.GetToken(DorisParserMAX, 0)
}

func (s *NonReservedContext) MEMO() antlr.TerminalNode {
	return s.GetToken(DorisParserMEMO, 0)
}

func (s *NonReservedContext) MERGE() antlr.TerminalNode {
	return s.GetToken(DorisParserMERGE, 0)
}

func (s *NonReservedContext) MIGRATE() antlr.TerminalNode {
	return s.GetToken(DorisParserMIGRATE, 0)
}

func (s *NonReservedContext) MIGRATIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserMIGRATIONS, 0)
}

func (s *NonReservedContext) MIN() antlr.TerminalNode {
	return s.GetToken(DorisParserMIN, 0)
}

func (s *NonReservedContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(DorisParserMINUTE, 0)
}

func (s *NonReservedContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(DorisParserMINUTES, 0)
}

func (s *NonReservedContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserMODIFY, 0)
}

func (s *NonReservedContext) MONTH() antlr.TerminalNode {
	return s.GetToken(DorisParserMONTH, 0)
}

func (s *NonReservedContext) MTMV() antlr.TerminalNode {
	return s.GetToken(DorisParserMTMV, 0)
}

func (s *NonReservedContext) NAME() antlr.TerminalNode {
	return s.GetToken(DorisParserNAME, 0)
}

func (s *NonReservedContext) NAMES() antlr.TerminalNode {
	return s.GetToken(DorisParserNAMES, 0)
}

func (s *NonReservedContext) NEGATIVE() antlr.TerminalNode {
	return s.GetToken(DorisParserNEGATIVE, 0)
}

func (s *NonReservedContext) NEVER() antlr.TerminalNode {
	return s.GetToken(DorisParserNEVER, 0)
}

func (s *NonReservedContext) NEXT() antlr.TerminalNode {
	return s.GetToken(DorisParserNEXT, 0)
}

func (s *NonReservedContext) NGRAM_BF() antlr.TerminalNode {
	return s.GetToken(DorisParserNGRAM_BF, 0)
}

func (s *NonReservedContext) NO() antlr.TerminalNode {
	return s.GetToken(DorisParserNO, 0)
}

func (s *NonReservedContext) NON_NULLABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserNON_NULLABLE, 0)
}

func (s *NonReservedContext) NULLS() antlr.TerminalNode {
	return s.GetToken(DorisParserNULLS, 0)
}

func (s *NonReservedContext) OF() antlr.TerminalNode {
	return s.GetToken(DorisParserOF, 0)
}

func (s *NonReservedContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(DorisParserOFFSET, 0)
}

func (s *NonReservedContext) ONLY() antlr.TerminalNode {
	return s.GetToken(DorisParserONLY, 0)
}

func (s *NonReservedContext) OPEN() antlr.TerminalNode {
	return s.GetToken(DorisParserOPEN, 0)
}

func (s *NonReservedContext) OPTIMIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserOPTIMIZED, 0)
}

func (s *NonReservedContext) PARAMETER() antlr.TerminalNode {
	return s.GetToken(DorisParserPARAMETER, 0)
}

func (s *NonReservedContext) PARSED() antlr.TerminalNode {
	return s.GetToken(DorisParserPARSED, 0)
}

func (s *NonReservedContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD, 0)
}

func (s *NonReservedContext) PASSWORD_EXPIRE() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD_EXPIRE, 0)
}

func (s *NonReservedContext) PASSWORD_HISTORY() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD_HISTORY, 0)
}

func (s *NonReservedContext) PASSWORD_LOCK_TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD_LOCK_TIME, 0)
}

func (s *NonReservedContext) PASSWORD_REUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserPASSWORD_REUSE, 0)
}

func (s *NonReservedContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserPARTITIONS, 0)
}

func (s *NonReservedContext) PATH() antlr.TerminalNode {
	return s.GetToken(DorisParserPATH, 0)
}

func (s *NonReservedContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserPAUSE, 0)
}

func (s *NonReservedContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(DorisParserPERCENT, 0)
}

func (s *NonReservedContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(DorisParserPERIOD, 0)
}

func (s *NonReservedContext) PERMISSIVE() antlr.TerminalNode {
	return s.GetToken(DorisParserPERMISSIVE, 0)
}

func (s *NonReservedContext) PHYSICAL() antlr.TerminalNode {
	return s.GetToken(DorisParserPHYSICAL, 0)
}

func (s *NonReservedContext) PI() antlr.TerminalNode {
	return s.GetToken(DorisParserPI, 0)
}

func (s *NonReservedContext) PLAN() antlr.TerminalNode {
	return s.GetToken(DorisParserPLAN, 0)
}

func (s *NonReservedContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(DorisParserPLUGIN, 0)
}

func (s *NonReservedContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(DorisParserPLUGINS, 0)
}

func (s *NonReservedContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserPOLICY, 0)
}

func (s *NonReservedContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(DorisParserPRIVILEGES, 0)
}

func (s *NonReservedContext) PROC() antlr.TerminalNode {
	return s.GetToken(DorisParserPROC, 0)
}

func (s *NonReservedContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(DorisParserPROCESS, 0)
}

func (s *NonReservedContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(DorisParserPROCESSLIST, 0)
}

func (s *NonReservedContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserPROFILE, 0)
}

func (s *NonReservedContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTIES, 0)
}

func (s *NonReservedContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(DorisParserPROPERTY, 0)
}

func (s *NonReservedContext) QUANTILE_STATE() antlr.TerminalNode {
	return s.GetToken(DorisParserQUANTILE_STATE, 0)
}

func (s *NonReservedContext) QUANTILE_UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserQUANTILE_UNION, 0)
}

func (s *NonReservedContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(DorisParserQUARTER, 0)
}

func (s *NonReservedContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DorisParserQUERY, 0)
}

func (s *NonReservedContext) QUOTA() antlr.TerminalNode {
	return s.GetToken(DorisParserQUOTA, 0)
}

func (s *NonReservedContext) QUALIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserQUALIFY, 0)
}

func (s *NonReservedContext) QUEUED() antlr.TerminalNode {
	return s.GetToken(DorisParserQUEUED, 0)
}

func (s *NonReservedContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(DorisParserRANDOM, 0)
}

func (s *NonReservedContext) RECENT() antlr.TerminalNode {
	return s.GetToken(DorisParserRECENT, 0)
}

func (s *NonReservedContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(DorisParserRECOVER, 0)
}

func (s *NonReservedContext) RECYCLE() antlr.TerminalNode {
	return s.GetToken(DorisParserRECYCLE, 0)
}

func (s *NonReservedContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserREFRESH, 0)
}

func (s *NonReservedContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPEATABLE, 0)
}

func (s *NonReservedContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE, 0)
}

func (s *NonReservedContext) REPLACE_IF_NOT_NULL() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLACE_IF_NOT_NULL, 0)
}

func (s *NonReservedContext) REPLAYER() antlr.TerminalNode {
	return s.GetToken(DorisParserREPLAYER, 0)
}

func (s *NonReservedContext) REPOSITORIES() antlr.TerminalNode {
	return s.GetToken(DorisParserREPOSITORIES, 0)
}

func (s *NonReservedContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisParserREPOSITORY, 0)
}

func (s *NonReservedContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCE, 0)
}

func (s *NonReservedContext) RESOURCES() antlr.TerminalNode {
	return s.GetToken(DorisParserRESOURCES, 0)
}

func (s *NonReservedContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESTORE, 0)
}

func (s *NonReservedContext) RESTRICTIVE() antlr.TerminalNode {
	return s.GetToken(DorisParserRESTRICTIVE, 0)
}

func (s *NonReservedContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisParserRESUME, 0)
}

func (s *NonReservedContext) RETAIN() antlr.TerminalNode {
	return s.GetToken(DorisParserRETAIN, 0)
}

func (s *NonReservedContext) RETENTION() antlr.TerminalNode {
	return s.GetToken(DorisParserRETENTION, 0)
}

func (s *NonReservedContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(DorisParserRETURNS, 0)
}

func (s *NonReservedContext) REWRITTEN() antlr.TerminalNode {
	return s.GetToken(DorisParserREWRITTEN, 0)
}

func (s *NonReservedContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(DorisParserRIGHT_BRACE, 0)
}

func (s *NonReservedContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserRLIKE, 0)
}

func (s *NonReservedContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLBACK, 0)
}

func (s *NonReservedContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserROLLUP, 0)
}

func (s *NonReservedContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserROUTINE, 0)
}

func (s *NonReservedContext) S3() antlr.TerminalNode {
	return s.GetToken(DorisParserS3, 0)
}

func (s *NonReservedContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(DorisParserSAMPLE, 0)
}

func (s *NonReservedContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEDULE, 0)
}

func (s *NonReservedContext) SCHEDULER() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEDULER, 0)
}

func (s *NonReservedContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisParserSCHEMA, 0)
}

func (s *NonReservedContext) SECOND() antlr.TerminalNode {
	return s.GetToken(DorisParserSECOND, 0)
}

func (s *NonReservedContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserSERIALIZABLE, 0)
}

func (s *NonReservedContext) SET_SESSION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserSET_SESSION_VARIABLE, 0)
}

func (s *NonReservedContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION, 0)
}

func (s *NonReservedContext) SESSION_USER() antlr.TerminalNode {
	return s.GetToken(DorisParserSESSION_USER, 0)
}

func (s *NonReservedContext) SHAPE() antlr.TerminalNode {
	return s.GetToken(DorisParserSHAPE, 0)
}

func (s *NonReservedContext) SKEW() antlr.TerminalNode {
	return s.GetToken(DorisParserSKEW, 0)
}

func (s *NonReservedContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisParserSNAPSHOT, 0)
}

func (s *NonReservedContext) SNAPSHOTS() antlr.TerminalNode {
	return s.GetToken(DorisParserSNAPSHOTS, 0)
}

func (s *NonReservedContext) SONAME() antlr.TerminalNode {
	return s.GetToken(DorisParserSONAME, 0)
}

func (s *NonReservedContext) SPLIT() antlr.TerminalNode {
	return s.GetToken(DorisParserSPLIT, 0)
}

func (s *NonReservedContext) SQL() antlr.TerminalNode {
	return s.GetToken(DorisParserSQL, 0)
}

func (s *NonReservedContext) STAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTAGE, 0)
}

func (s *NonReservedContext) STAGES() antlr.TerminalNode {
	return s.GetToken(DorisParserSTAGES, 0)
}

func (s *NonReservedContext) START() antlr.TerminalNode {
	return s.GetToken(DorisParserSTART, 0)
}

func (s *NonReservedContext) STARTS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTARTS, 0)
}

func (s *NonReservedContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATS, 0)
}

func (s *NonReservedContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserSTATUS, 0)
}

func (s *NonReservedContext) STOP() antlr.TerminalNode {
	return s.GetToken(DorisParserSTOP, 0)
}

func (s *NonReservedContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserSTORAGE, 0)
}

func (s *NonReservedContext) STREAM() antlr.TerminalNode {
	return s.GetToken(DorisParserSTREAM, 0)
}

func (s *NonReservedContext) STREAMING() antlr.TerminalNode {
	return s.GetToken(DorisParserSTREAMING, 0)
}

func (s *NonReservedContext) STRING() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRING, 0)
}

func (s *NonReservedContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(DorisParserSTRUCT, 0)
}

func (s *NonReservedContext) SUM() antlr.TerminalNode {
	return s.GetToken(DorisParserSUM, 0)
}

func (s *NonReservedContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserTABLES, 0)
}

func (s *NonReservedContext) TAG() antlr.TerminalNode {
	return s.GetToken(DorisParserTAG, 0)
}

func (s *NonReservedContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisParserTASK, 0)
}

func (s *NonReservedContext) TASKS() antlr.TerminalNode {
	return s.GetToken(DorisParserTASKS, 0)
}

func (s *NonReservedContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserTEMPORARY, 0)
}

func (s *NonReservedContext) TEXT() antlr.TerminalNode {
	return s.GetToken(DorisParserTEXT, 0)
}

func (s *NonReservedContext) THAN() antlr.TerminalNode {
	return s.GetToken(DorisParserTHAN, 0)
}

func (s *NonReservedContext) TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserTIME, 0)
}

func (s *NonReservedContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserTIMESTAMP, 0)
}

func (s *NonReservedContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisParserTRANSACTION, 0)
}

func (s *NonReservedContext) TREE() antlr.TerminalNode {
	return s.GetToken(DorisParserTREE, 0)
}

func (s *NonReservedContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(DorisParserTRIGGERS, 0)
}

func (s *NonReservedContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(DorisParserTRUNCATE, 0)
}

func (s *NonReservedContext) TYPE() antlr.TerminalNode {
	return s.GetToken(DorisParserTYPE, 0)
}

func (s *NonReservedContext) TYPES() antlr.TerminalNode {
	return s.GetToken(DorisParserTYPES, 0)
}

func (s *NonReservedContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(DorisParserUNCOMMITTED, 0)
}

func (s *NonReservedContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(DorisParserUNLOCK, 0)
}

func (s *NonReservedContext) UNSET() antlr.TerminalNode {
	return s.GetToken(DorisParserUNSET, 0)
}

func (s *NonReservedContext) UP() antlr.TerminalNode {
	return s.GetToken(DorisParserUP, 0)
}

func (s *NonReservedContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisParserUSER, 0)
}

func (s *NonReservedContext) VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserVALUE, 0)
}

func (s *NonReservedContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserVARCHAR, 0)
}

func (s *NonReservedContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserVARIABLE, 0)
}

func (s *NonReservedContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserVARIABLES, 0)
}

func (s *NonReservedContext) VARIANT() antlr.TerminalNode {
	return s.GetToken(DorisParserVARIANT, 0)
}

func (s *NonReservedContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULT, 0)
}

func (s *NonReservedContext) VAULTS() antlr.TerminalNode {
	return s.GetToken(DorisParserVAULTS, 0)
}

func (s *NonReservedContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserVERBOSE, 0)
}

func (s *NonReservedContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisParserVERSION, 0)
}

func (s *NonReservedContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEW, 0)
}

func (s *NonReservedContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(DorisParserVIEWS, 0)
}

func (s *NonReservedContext) WARM() antlr.TerminalNode {
	return s.GetToken(DorisParserWARM, 0)
}

func (s *NonReservedContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(DorisParserWARNINGS, 0)
}

func (s *NonReservedContext) WEEK() antlr.TerminalNode {
	return s.GetToken(DorisParserWEEK, 0)
}

func (s *NonReservedContext) WORK() antlr.TerminalNode {
	return s.GetToken(DorisParserWORK, 0)
}

func (s *NonReservedContext) YEAR() antlr.TerminalNode {
	return s.GetToken(DorisParserYEAR, 0)
}

func (s *NonReservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonReservedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.EnterNonReserved(s)
	}
}

func (s *NonReservedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(DorisParserListener); ok {
		listenerT.ExitNonReserved(s)
	}
}

func (p *DorisParser) NonReserved() (localctx INonReservedContext) {
	localctx = NewNonReservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, DorisParserRULE_nonReserved)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6282)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305902462020672000) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4609989332399152113) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-4540397275156637211) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&2557745532860070517) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&8545544968972265069) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-305714810442809349) != 0) || ((int64((_la-391)) & ^0x3f) == 0 && ((int64(1)<<(_la-391))&1188948054525294943) != 0) || ((int64((_la-455)) & ^0x3f) == 0 && ((int64(1)<<(_la-455))&2458964612221191023) != 0) || ((int64((_la-538)) & ^0x3f) == 0 && ((int64(1)<<(_la-538))&7) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *DorisParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 114:
		var t *QueryTermContext = nil
		if localctx != nil {
			t = localctx.(*QueryTermContext)
		}
		return p.QueryTerm_Sempred(t, predIndex)

	case 117:
		var t *QuerySpecificationContext = nil
		if localctx != nil {
			t = localctx.(*QuerySpecificationContext)
		}
		return p.QuerySpecification_Sempred(t, predIndex)

	case 186:
		var t *BooleanExpressionContext = nil
		if localctx != nil {
			t = localctx.(*BooleanExpressionContext)
		}
		return p.BooleanExpression_Sempred(t, predIndex)

	case 190:
		var t *ValueExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ValueExpressionContext)
		}
		return p.ValueExpression_Sempred(t, predIndex)

	case 191:
		var t *PrimaryExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryExpressionContext)
		}
		return p.PrimaryExpression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *DorisParser) QueryTerm_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DorisParser) QuerySpecification_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return !ansiSQLSyntax

	case 3:
		return ansiSQLSyntax

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DorisParser) BooleanExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DorisParser) ValueExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DorisParser) PrimaryExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 14:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
